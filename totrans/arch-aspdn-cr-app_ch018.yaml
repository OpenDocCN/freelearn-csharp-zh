- en: 17 Getting Started with Vertical Slice Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 开始使用垂直切片架构
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，属于早期访问订阅）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file111.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file111.png)'
- en: This chapter introduces Vertical Slice Architecture, an effective way to organize
    our ASP.NET Core applications. Vertical Slice Architecture moves elements from
    multiple layers to a feature-oriented design, helping us maintain a clean, simple,
    cohesive, loosely-coupled, and manageable codebase.Vertical Slice Architecture
    flips our architectural perspective toward simplified architecture. Historically,
    we divided the logic of a feature across various layers like UI, business logic,
    and data access. However, we create independent slices of functionality with Vertical
    Slice Architecture instead. Think of your application as a cake; instead of cutting
    it horizontally (layers), we're cutting vertically (features), with each slice
    being fully functional on its own.This style changes how we design and organize
    our project, testing strategies, and coding approach. We don't have to worry about
    bloated controllers or overly complicated "God objects"; instead, making changes
    becomes more manageable because of the loose coupling between features.This chapter
    guides you through applying Vertical Slice Architecture to your ASP.NET Core applications,
    detailing how to handle commands, queries, validation, and entity mapping using
    CQS, MVC, MediatR, AutoMapper, and FluentValidation, which we explored in the
    previous chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了垂直切片架构，这是一种有效组织我们的 ASP.NET Core 应用程序的方法。垂直切片架构将元素从多个层移动到面向功能的设计，帮助我们保持代码库的整洁、简单、统一、松散耦合和管理性。垂直切片架构将我们的架构视角转向简化的架构。历史上，我们将功能的逻辑分割到各种层，如
    UI、业务逻辑和数据访问。然而，我们通过垂直切片架构创建了功能独立的切片。想象你的应用程序就像一个蛋糕；我们不是水平切割（层），而是垂直切割（功能），每个切片都能独立运行。这种风格改变了我们设计和组织项目、测试策略和编码方法的方式。我们不必担心臃肿的控制器或过于复杂的“上帝对象”；相反，由于功能之间的松散耦合，更改变得更加容易管理。本章将指导你将垂直切片架构应用到你的
    ASP.NET Core 应用程序中，详细说明如何使用 CQS、MVC、MediatR、AutoMapper 和 FluentValidation 来处理命令、查询、验证和实体映射，这些我们在前面的章节中已经探讨过。
- en: We don’t have to use those tools to apply the architectural style and can replace
    those libraries with others or even code the whole stack ourselves.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们不必使用那些工具来应用架构风格，可以用其他库替换它们，甚至可以自己编写整个堆栈。
- en: 'By the end of this chapter, you will understand Vertical Slice Architecture
    and its benefits, and should have the confidence to apply this style to your next
    project. In this chapter, we cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解垂直切片架构及其优势，并应该有信心将这种风格应用到你的下一个项目中。在本章中，我们将涵盖以下主题：
- en: Anti-pattern – Big Ball of Mud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式 - 大泥球
- en: Vertical Slice Architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直切片架构
- en: 'Continuing your journey: A few tips and tricks'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续你的旅程：一些技巧和窍门
- en: Let's journey through the vertical slices and piece the architecture together,
    one slice at a time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地穿越垂直切片，一次一个切片地拼凑架构。
- en: Anti-pattern – Big Ball of Mud
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反模式 - 大泥球
- en: 'Let’s start with an anti-pattern. The **Big Ball of Mud** anti-pattern describes
    a system that ended badly or was never properly designed. Sometimes a system starts
    great but evolves into a Big Ball of Mud due to pressure, volatile requirements,
    impossible deadlines, bad practices, or other reasons. We often refer to the Big
    Ball of Mud as **spaghetti code**, which means the same thing.This anti-pattern
    means a very hard-to-maintain codebase, poorly written code that is difficult
    to read, lots of unwanted tight coupling, low cohesion, or worse: all that in
    the same codebase.Applying the techniques covered in this book should help you
    avoid this anti-pattern. Aim at small, well-designed components that are testable.
    Enforce that using automated testing. Refactor and improve your codebase whenever
    you can, iteratively (continuous improvement). Apply the SOLID principles. Define
    your application pattern before starting. Think of the best way to implement each
    component and feature; do research, and make one or more proof of concept or experiments
    if unsure of the best approach. Ensure you understand the business requirements
    of the program you are building (this is probably the best advice). Those tips
    should help you avoid creating a Big Ball of Mud.Building feature-oriented applications
    is one of the best ways to avoid creating a Big Ball of Mud. Let’s get started!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种反模式开始。**大泥球**反模式描述的是一个设计失败或从未得到适当设计的系统。有时一个系统开始得很好，但由于压力、易变的需求、不可能的截止日期、不良实践或其他原因，会演变成一个大泥球。我们通常将大泥球称为**意大利面代码**，意思相同。这种反模式意味着一个非常难以维护的代码库，编写糟糕且难以阅读的代码，大量不希望出现的紧密耦合，低内聚性，或者更糟：所有这些都在同一个代码库中。应用本书中涵盖的技术应该能帮助你避免这种反模式。目标是小型、设计良好的组件，这些组件是可测试的。通过自动化测试强制执行。
    whenever you can, iteratively (continuous improvement). 应用SOLID原则。在开始之前定义你的应用程序模式。考虑实现每个组件和功能的最佳方式；进行研究，并在不确定最佳方法时进行一个或多个概念验证或实验。确保你理解你正在构建的程序的业务需求（这可能是最好的建议）。这些提示应该能帮助你避免创建一个大泥球。构建面向功能的程序是避免创建大泥球的最佳方法之一。让我们开始吧！
- en: Vertical Slice Architecture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直切片架构
- en: 'Instead of separating an application horizontally (layers), a vertical slice
    groups all horizontal concerns together to encapsulate a feature. Here is a diagram
    that illustrates that:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与将应用程序水平分割（层）不同，垂直切片将所有水平关注点组合在一起，以封装一个功能。以下是一个说明这一点的图示：
- en: '![Figure 17.1: Diagram representing a vertical slice crossing all layers](img/file112.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1：表示垂直切片跨越所有层的图](img/file112.png)'
- en: 'Figure 17.1: Diagram representing a vertical slice crossing all layers'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：表示垂直切片跨越所有层的图
- en: 'Jimmy Bogard, who is a pioneer of this type of architecture, wrote the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jimmy Bogard，这种架构的先驱，写了以下内容：
- en: '*[The goal is to] minimize coupling between slices and maximize coupling within
    a slice.*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[目标是]最小化切片之间的耦合，最大化切片内的耦合。*'
- en: 'What does that mean? Let’s split that sentence into two distinct points:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？让我们将这句话分成两个不同的点：
- en: “minimize coupling between slices” (improved maintainability, loose coupling)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “最小化切片之间的耦合” (提高可维护性，松耦合)
- en: “maximize coupling within a slice” (cohesion)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “最大化切片内的耦合” (内聚性)
- en: 'We could see the former as one vertical slice should not depend on another,
    so when you modify a vertical slice, you don’t have to worry about the impact
    on the other slices because the coupling is minimal.We could see the latter as:
    instead of spreading code around multiple layers, with potentially superfluous
    abstractions along the way, let’s regroup and simplify that code. That helps keep
    the tight coupling inside a vertical slice to create a cohesive unit of code that
    serves a single purpose: handling the feature end to end.Then we could wrap that
    to create software around the business problem we are trying to solve instead
    of the developer’s concerns, which your customers have no interest in (such as
    data access).Now, what is a slice in more generic terms? I see slices as composite
    hierarchies. For example, a shipping manager program has a multistep creation
    workflow, a list, and a details page. Each step of the creation flow would be
    a slice responsible for handling its respective logic. When put together, they
    compose the “create slice”, which is responsible for creating a shipment (a bigger
    slice). The list and details pages are two other slices. Then, all of those slices
    become another bigger slice, leading to something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前者视为一个垂直切片不应该依赖于另一个，因此当你修改一个垂直切片时，你不必担心对其他切片的影响，因为耦合是最小的。我们可以将后者视为：而不是在多个层中分散代码，沿途可能存在多余的抽象，让我们重新组合并简化那段代码。这有助于保持垂直切片内部的紧密耦合，以创建一个具有单一目的的代码单元：从头到尾处理功能。然后我们可以将其包装起来，围绕我们试图解决的商业问题构建软件，而不是开发者的关注点（例如数据访问）。现在，从更通用的角度来看，什么是切片？我认为切片是复合层次结构。例如，一个运输经理程序有一个多步骤的创建工作流程、一个列表和一个详情页面。创建流程的每一步都会是一个负责处理其相应逻辑的切片。当组合在一起时，它们构成了“创建切片”，负责创建一个运输（一个更大的切片）。列表和详情页面是另外两个切片。然后，所有这些切片又构成了另一个更大的切片，导致类似这样的情况：
- en: '![Figure 17.2: A diagram displaying a top-down coupling structure where smaller
    parts (top) depend on bigger parts (middle) of complex features (bottom) based
    on their cohesion with one another (vertically)](img/file113.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2：显示复杂功能（底部）的顶部部分（顶部）基于它们之间的内聚（垂直）依赖于更大的部分（中间）的从上到下的耦合结构的图](img/file113.png)'
- en: 'Figure 17.2: A diagram displaying a top-down coupling structure where smaller
    parts (top) depend on bigger parts (middle) of complex features (bottom) based
    on their cohesion with one another (vertically)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2：一个显示复杂功能（底部）的顶部部分（顶部）基于它们之间的内聚（垂直）依赖于更大的部分（中间）的从上到下的耦合结构的图
- en: 'There is strong coupling inside **Step 1**, with limited coupling between the
    other steps; they share some creation code as part of the **Create** slice. **Create**,
    **List**, and **Details** also share some code, but in a limited way; they are
    all part of the **Shipments** slice and access or manipulate the same entity:
    one or more shipments. Finally, the **Shipments** slice shares no code (or very
    little) with **Other features**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**内部存在强耦合，而其他步骤之间的耦合有限；它们作为**创建**切片的一部分共享一些创建代码。**创建**、**列表**和**详情**也以有限的方式共享一些代码；它们都是**运输**切片的一部分，并访问或操作相同的实体：一个或多个运输。最后，**运输**切片与**其他功能**没有共享代码（或非常少）。
- en: Following the pattern I just described, we have limited coupling and maximum
    cohesion. The downside is that you must continuously design and refactor the application,
    which requires stronger design skills than a layered approach. Moreover, you must
    know how to build the feature end to end, limiting the division of tasks between
    people and centralizing them on each team member instead; each member becomes
    a full-stack developer. We revisit this example in the *Continuing your journey*
    section near the end of the chapter.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按照我刚才描述的模式，我们有限耦合和最大内聚。缺点是您必须持续设计和重构应用程序，这需要比分层方法更强的设计技能。此外，您必须知道如何从头到尾构建功能，限制任务在人们之间的划分，并将它们集中在每个团队成员身上；每个成员都成为全栈开发者。我们将在章节末尾的*继续您的旅程*部分重新审视这个例子。
- en: We explore the advantages and disadvantages next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面探讨优点和缺点。
- en: What are the advantages and disadvantages?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点是什么？
- en: Let’s explore some advantages and disadvantages of Vertical Slice Architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨垂直切片架构的一些优缺点。
- en: Advantages
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优点
- en: 'On the upside, we have the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 优点方面，我们有以下内容：
- en: We reduce coupling between features, making working on such a project more manageable.
    We only need to think about a single vertical slice, not *N* layers, improving
    **maintainability** by centralizing the code around a shared concern.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们减少了功能之间的耦合，这使得在这样一个项目上工作更容易管理。我们只需要考虑一个垂直切片，而不是*N*层，通过将代码集中在共享关注点上，提高了**可维护性**。
- en: We can choose how each vertical slice interacts with the external resources
    they require without considering the other slices. That adds **flexibility** since
    one slice can use T-SQL while another uses EF Core, for example.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择每个垂直切片如何与它们所需的资源交互，而无需考虑其他切片。这增加了**灵活性**，因为一个切片可以使用T-SQL，而另一个可以使用EF Core，例如。
- en: We can start small with a few lines of code (described as **Transaction Scripts**
    in *Patterns of Enterprise Application Architecture,* by Martin Fowler) without
    extravagant design or over-engineering. Then we can refactor our way to a better
    design when the need arises and patterns emerge, leading to a **faster time to
    market**.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从小处着手，用几行代码开始（在马丁·福勒的《企业应用架构模式》中描述为**事务脚本**），无需奢华的设计或过度工程。当需要时，我们可以通过重构来改进设计，当模式出现时，这将导致**更快的上市时间**。
- en: Each vertical slice should contain precisely the right amount of code needed
    to be correct—not more, not less. That leads to a **more robust** codebase (less
    code means less extraneous code and less code to maintain).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个垂直切片应包含恰好正确数量的代码，以实现正确性——不多也不少。这导致代码库更加**健壮**（代码少意味着额外的代码更少，维护的代码也更少）。
- en: It is easier for newcomers to find their way around an existing system since
    each feature is near-independent, leading to a **faster onboarding time**.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个功能几乎都是独立的，因此新来者更容易在现有系统中找到自己的位置，这导致**更快的上手时间**。
- en: All patterns and techniques you learned in previous chapters still apply.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的章节中学习的所有模式和技巧仍然适用。
- en: From my experience, features tend to start small and grow over time. The users
    often find out what they need while using the software, changing the requirements
    over time, which leads to changes in the software. After the fact, I wish many
    projects I worked on were built using Vertical Slice Architecture instead of layering.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据我的经验，功能往往开始时规模较小，随着时间的推移而增长。用户通常在使用软件时发现他们需要什么，随着时间的推移改变需求，这导致软件的变化。事后，我希望我参与过的许多项目都是使用垂直切片架构而不是分层来构建的。
- en: Disadvantages
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Of course, nothing is perfect, so here are some downsides:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有什么是完美的，所以这里有一些缺点：
- en: It may take time to wrap your head around Vertical Slice Architecture if you’re
    used to layering, leading to an adaptation period to learn a new way to think
    about your software.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你习惯了分层，那么理解垂直切片架构可能需要时间，这将导致一个适应期来学习一种新的思考软件的方式。
- en: It is a “newer” type of architecture, and people don’t like change.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种“较新的”架构类型，人们不喜欢改变。
- en: 'Another thing that I learned the hard way is to embrace change. I don’t think
    I’ve seen one project end as it was supposed to. Everyone identifies the missing
    pieces of the business processes while using the software. That leads to the following
    advice: release the software as fast as possible and have your customers use the
    software as soon as possible. That advice can be easier to achieve with Vertical
    Slice Architecture because you build value for your customers instead of more
    or less valuable abstractions and layers. Having a customer try staged software
    is very hard; no customer has time to do such a thing; they are busy running their
    business. However, releasing production-ready slices may lead to faster adoption
    and feedback.'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一件事是我通过艰难的方式学到的，那就是接受变化。我认为我没有看到过一个项目是以它应有的方式结束的。当使用软件时，每个人都识别出业务流程中缺失的部分。这导致以下建议：尽可能快地发布软件，并尽快让客户使用软件。由于垂直切片架构可以为客户创造价值，而不是更多或更少的抽象和层，因此这些建议可能更容易实现。让客户尝试分阶段软件是非常困难的；没有客户有时间做这样的事情；他们正忙于经营自己的业务。然而，发布生产就绪的切片可能会导致更快的采用和反馈。
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the beginning of my career, I was frustrated when specifications changed,
    and I thought that better planning would have fixed that. Sometimes better planning
    would have helped, but sometimes, the customer just did not know how to express
    their business processes or needs and had to try the application to figure it
    out. My advice here is don’t be frustrated when the specs change, even if that
    means rewriting a part of the software that took you days or more to code in the
    first place; that will happen all the time. Learn to accept that instead, and
    find ways to make this process easier and faster. If you are in contact with the
    customers, find ways to help them figure out their needs and reduce the number
    of changes.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我的职业生涯初期，每当规格发生变化时，我都会感到沮丧，并认为更好的规划本可以解决这个问题。有时更好的规划确实有所帮助，但有时，客户并不知道如何表达他们的业务流程或需求，只能通过试用应用程序来弄清楚。我的建议是，当规格发生变化时，不要感到沮丧，即使这意味着重写最初花费你数天或更多时间编写的软件部分；这种情况会经常发生。学会接受这一点，并找到使这个过程更容易、更快捷的方法。如果你与客户有联系，找到帮助他们弄清楚需求并减少变更数量的方法。
- en: Downside or Upsides?
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优点还是缺点？
- en: 'The following points are downsides that we can tame as upsides:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们可以将其转化为优点的缺点：
- en: Suppose you are used to working in silos (such as the DBAs doing the data stuff).
    In that case, assigning tasks that touch the whole feature may be more challenging,
    but this can become an advantage since everyone in your team works more closely
    together, leading to more learning and collaboration and possibly a new cross-functional
    team—which is excellent. Having a data expert on the team is great; no one is
    an expert in all areas.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你习惯于在孤岛（如数据库管理员处理数据）中工作。在这种情况下，分配涉及整个功能的任务可能会更具挑战性，但这也可能成为优势，因为你的团队中的每个人都更紧密地合作，从而带来更多的学习和协作，甚至可能形成一个新的跨职能团队——这是非常好的。在团队中有数据专家是很好的；没有人是所有领域的专家。
- en: 'Refactoring: strong refactoring skills will go a long way. Over time, most
    systems need some refactoring, which is even more true for Vertical Slice Architecture.
    That can be caused by changes in the requirements or due to technical debt. No
    matter the reason, you may end up with a **Big Ball of Mud** if you don''t. First,
    writing isolated code and then refactoring to patterns is a crucial part of Vertical
    Slice Architecture. That’s one of the best ways to keep cohesion high inside a
    slice and coupling as low as possible between slices. This tip applies to all
    types of architecture and is made easier with a robust test suite that validates
    your changes automatically.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构：强大的重构技能会大有裨益。随着时间的推移，大多数系统都需要进行一些重构，对于垂直切片架构来说更是如此。这可能是由于需求的变化或技术债务造成的。无论原因如何，如果你不这样做，你可能会最终得到一个**一团糟的大泥球**。首先，编写隔离的代码，然后重构到模式中是垂直切片架构的关键部分。这是在切片内部保持高度内聚并尽可能降低切片之间耦合的最佳方式之一。这个技巧适用于所有类型的架构，并且有了强大的测试套件来自动验证你的更改，这会更容易实现。
- en: A way to start refactoring that business logic would be to push the logic into
    the **domain model**, creating a **rich domain model**. You can also use other
    design patterns and techniques to fine-tune the code and make it more maintainable,
    such as creating services or layers. A layer does not have to cross all vertical
    slices; it can cross only a subset of them.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 开始重构业务逻辑的一种方法是将逻辑推入**领域模型**，创建一个**丰富的领域模型**。你还可以使用其他设计模式和技巧来微调代码，使其更易于维护，例如创建服务或层。一个层不需要跨越所有垂直切片；它只需要跨越其中的一部分。
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compared to other application-level patterns, such as layering, fewer rules
    lead to more choices (Vertical Slice Architecture). *You can use all design patterns,
    principles, and best practices inside a vertical slice without exporting those
    choices application-wide.*
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与其他应用级模式（如分层）相比，垂直切片架构的规则更少，这意味着有更多的选择（垂直切片架构）。*你可以在垂直切片内部使用所有设计模式、原则和最佳实践，而无需将这些选择应用到整个应用程序中。*
- en: How do you organize a project into Vertical Slice Architecture? Unfortunately,
    there is no definitive answer to that, and it depends on the engineers working
    on the project. We explore one way in the next project, but you can organize your
    project as you see fit. Then we dig deeper into refactoring and organization.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将项目组织成垂直切片架构？遗憾的是，对此没有明确的答案，这取决于在项目上工作的工程师。我们将在下一个项目中探讨一种方法，但你可以根据自己的需要组织项目。然后我们将更深入地探讨重构和组织。
- en: Project – Vertical Slice Architecture
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 垂直切片架构
- en: '**Context**: We are getting tired of layering, and we got asked to rebuild
    our small demo shop using Vertical Slice Architecture.Here is an updated diagram
    that shows how we conceptually organized the project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们对分层感到厌倦，并被要求使用垂直切片架构重建我们的小型演示商店。以下是更新后的图示，展示了我们概念上如何组织项目：'
- en: '![Figure 17.3: Diagram representing the organization of the demo shop project](img/file114.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图17.3：表示演示商店项目组织的图示](img/file114.png)'
- en: 'Figure 17.3: Diagram representing the organization of the demo shop project'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：表示演示商店项目组织的图示
- en: 'Each vertical box is a use case (or slice), while each horizontal box is a
    crosscutting concern or a shared component. This is a small project, so we share
    the data access code (`DbContext`) and the `Product` model between the three use
    cases. This sharing is unrelated to Vertical Slice Architecture, but splitting
    it more in a small project like this is hard and pointless.In this project, I
    decided to go with web API controllers instead of minimal APIs and an anemic product
    model instead of a rich one. We could have used minimal APIs, a rich model, or
    any combination. I chose this so you have a glimpse of using controllers, as this
    is something you might very well end up using. We go back to minimal APIs in the
    next chapter.Here are the actors:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个垂直框是一个用例（或切片），而每个水平框是一个横切关注点或共享组件。这是一个小型项目，所以我们共享数据访问代码（`DbContext`）和`Product`模型在三个用例之间。这种共享与垂直切片架构无关，但在像这样的小型项目中进一步分割它是困难和没有意义的。在这个项目中，我决定使用Web
    API控制器而不是最小API，以及使用贫血模型而不是富模型。我们可以使用最小API、富模型或任何组合。我选择这样做，以便您能一瞥使用控制器的情况，因为您很可能最终会使用它。我们将在下一章回到最小API。以下是参与者：
- en: '`ProductsController` is the REST API to manage products.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductsController`是管理产品的REST API。'
- en: '`StocksController` is the REST API to manage the inventory.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StocksController`是管理库存的REST API。'
- en: '`AddStocks`, `RemoveStocks`, and `ListAllProducts` are the same use cases we
    have copied in our project since *Chapter 14*, *Layering and Clean Architecture*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddStocks`、`RemoveStocks`和`ListAllProducts`是我们从第14章“分层和清洁架构”以来在我们的项目中复制的相同用例。'
- en: The persistence “layer” consists of an EF Core `DbContext` that persists the
    `Product` model to an in-memory database.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性“层”由一个EF Core `DbContext`组成，该`DbContext`将`Product`模型持久化到内存数据库中。
- en: We could add other crosscutting concerns on top of our vertical slices, such
    as authorization, error management, and logging, to name a few.Next, let’s look
    at how we organized the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的垂直切片之上添加其他横切关注点，例如授权、错误管理和日志记录，仅举几例。接下来，让我们看看我们是如何组织这个项目的。
- en: Project organization
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目组织
- en: 'Here is how we organized the project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的项目组织方式：
- en: The `Data` directory contains EF Core-related classes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Data`目录包含与EF Core相关的类。'
- en: The `Features` directory contains the features. Each subfolder contains its
    underlying features (vertical slices), including controllers, exceptions, and
    other support classes required to implement the feature.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Features`目录包含功能。每个子文件夹包含其底层功能（垂直切片），包括控制器、异常和其他支持类，这些类是实现功能所需的。'
- en: 'Each use case is self-contained and exposes the following classes:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个用例都是独立的，并暴露以下类：
- en: '`Command` or `Query` representing the MediatR request.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Command`或`Query`代表MediatR请求。'
- en: '`Result` is the return value of that request.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Result`是请求的返回值。'
- en: '`MapperProfile` instructs AutoMapper on how to map the use case-related objects
    (if any).'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MapperProfile`指导AutoMapper如何映射与用例相关的对象（如果有）。'
- en: '`Validator` contains the validation rules to validate the `Command` or `Query`
    objects (if any).'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Validator`包含验证规则，用于验证`Command`或`Query`对象（如果有）。'
- en: '`Handler` contains the use case logic: how to handle the request.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Handler`包含用例逻辑：如何处理请求。'
- en: The `Models` directory contains the domain model.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Models`目录包含领域模型。'
- en: '![Figure 17.4: Solution Explorer view of the file organization](img/file115.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图17.4：文件组织的解决方案资源管理器视图](img/file115.png)'
- en: 'Figure 17.4: Solution Explorer view of the file organization'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：文件组织的解决方案资源管理器视图
- en: In this project, we support request validation using **FluentValidation**, a
    third-party NuGet package. We can also use `System.ComponentModel.DataAnnotations`
    or any other validation library that we want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们支持使用**FluentValidation**进行请求验证，这是一个第三方NuGet包。我们也可以使用`System.ComponentModel.DataAnnotations`或任何我们想要的其它验证库。
- en: With FluentValidation, I find it easy to keep the validation within our vertical
    slice but outside the class we want to validate. The out-of-the-box .NET validation
    framework, `DataAnnotations`, does the opposite, forcing us to include the validation
    as metadata on the entities themselves. Both have pros and cons, but FluentValidation
    is easier to test and extend.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用FluentValidation，我发现将验证保留在我们的垂直切片中但不在我们想要验证的类之外很容易。开箱即用的.NET验证框架`DataAnnotations`则相反，它强迫我们将验证作为实体的元数据包含在内。两者都有优缺点，但FluentValidation更容易测试和扩展。
- en: 'The following code is the `Program.cs` file. The highlighted lines represent
    registering FluentValidation and scanning the assembly to find validators:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Program.cs`文件。高亮显示的行表示注册FluentValidation并扫描程序集以查找验证器：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code adds the bindings we explored in previous chapters, FluentValidation,
    and the other pieces required to run the application. The highlighted lines register
    FluentValidation and scan the `currentAssembly` for validator classes. The validators
    themselves are part of each vertical slice. Now that we covered the organization
    of the project, let’s look at features.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码添加了我们在之前章节中探索的绑定，FluentValidation以及运行应用程序所需的其他组件。高亮显示的行注册了FluentValidation并扫描`currentAssembly`以查找验证器类。验证器本身是每个垂直切片的一部分。现在我们已经了解了项目的组织结构，让我们看看功能。
- en: Exploring the RemoveStock feature
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索删除库存功能
- en: In this subsection, we explore the `RemoveStocks` feature with the same logic
    as in previous samples but organized differently (a.k.a. the difference between
    architectural styles). Since we use an anemic product model, we moved the add
    and remove stocks logic from the `Product` class to the `Handler` class. Let’s
    look at the code next. I describe each nested class along the way.The sample starts
    with the `RemoveStocks` class that contains the feature’s nested classes. That
    helps organize the feature and saves us some headaches about naming collision.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们使用与之前示例相同的逻辑来探索`RemoveStocks`功能，但组织方式不同（即架构风格之间的差异）。由于我们使用贫血产品模型，我们将添加和删除库存的逻辑从`Product`类移动到了`Handler`类。接下来，让我们看看代码。我将沿途描述每个嵌套类。示例从包含功能嵌套类的`RemoveStocks`类开始。这有助于组织功能，并使我们避免了一些关于命名冲突的烦恼。
- en: We could use namespaces instead, but tools like Visual Studio recommend adding
    a `using` statement and removing the inline namespace. Nowadays, it often automatically
    adds the using statement, like when pasting code, which is great for many scenarios
    but inconvenient for this specific one. So using nested classes fixes this.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用命名空间，但像Visual Studio这样的工具建议添加一个`using`语句并删除内联命名空间。如今，它通常会在粘贴代码时自动添加`using`语句，这在许多情况下很棒，但在这个特定情况下不方便。因此，使用嵌套类解决了这个问题。
- en: 'Here is the `RemoveStocks` class skeleton:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`RemoveStocks`类的骨架：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code showcases that the `RemoveStocks` class contains all the
    required elements it needs for its specific use case:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了`RemoveStocks`类包含其特定用例所需的所有元素：
- en: '`Command` is the input DTO.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`是输入DTO。'
- en: '`Result` is the output DTO.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result`是输出DTO。'
- en: '`MapperProfile` is the AutoMapper profile that maps feature-specific classes
    to non-feature-specific classes and vice versa.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapperProfile`是AutoMapper配置文件，它将特定于功能的类映射到非特定于功能的类，反之亦然。'
- en: '`Validator` validates the input before an instance hits the `Handler` class
    (the `Command` class).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validator`在实例到达`Handler`类（`Command`类）之前验证输入。'
- en: '`Handler` encapsulates the use case logic.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Handler`封装了用例逻辑。'
- en: 'Next, we explore those nested classes, starting with the `Command` class, which
    is the **input of the use case** (the request):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探索这些嵌套类，从`Command`类开始，它是用例的**输入**（请求）：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding request contains everything it needs to remove stocks from the
    inventory and fulfill the operation. The `IRequest<TResult>` interface tells MediatR
    that the `Command` class is a request and should be routed to its handler. The
    `Result` class is the return value of that handler and represents the **output
    of the use case**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条请求包含了从库存中删除库存并完成操作所需的所有内容。`IRequest<TResult>`接口告诉MediatR，`Command`类是一个请求，应该被路由到其处理程序。`Result`类是处理程序的返回值，代表用例的**输出**：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The mapper profile is optional and allows encapsulating AutoMapper *maps* related
    to the use case. The following `MapperProfile` class registers the mapping from
    a `Product` instance to a `Result` instance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 映射配置文件是可选的，允许封装与用例相关的AutoMapper *映射*。以下`MapperProfile`类注册了从`Product`实例到`Result`实例的映射：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `validator` class is also optional and allows validating the input (`Command`)
    before it hits the handler; in this case, it ensures the `Amount` value is greater
    than zero:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`validator` 类也是可选的，允许在输入（`Command`）到达处理器之前对其进行验证；在这种情况下，它确保 `Amount` 值大于零：'
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the most important piece is the `Handler` class, which implements
    the use case logic:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最重要的部分是 `Handler` 类，它实现了用例逻辑：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Handler` class implements the `IRequestHandler<Command, Result>` interface,
    which links the `Command`, the `Handler`, and the `Result` classes. The `Handle`
    method implements the same logic as the previous implementations from *Chapter
    14*, *Layering* *and Clean Architecture*, onward.Now that we have a fully functional
    use case, let’s look at the skeleton of the `StocksController` class that translates
    the HTTP requests to the MediatR pipeline so our use case gets executed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler` 类实现了 `IRequestHandler<Command, Result>` 接口，它将 `Command`、`Handler`
    和 `Result` 类连接起来。`Handle` 方法实现了从 *第 14 章*、*分层* 和 *清洁架构* 以来相同逻辑的先前实现。现在我们有一个完全功能性的用例，让我们看看将
    HTTP 请求转换为 MediatR 管道以执行我们的用例的 `StocksController` 类的骨架：'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the controller, we inject an `IMediator` into the constructor. We used constructor
    injection because all actions of this controller use the `IMediator` interface.
    We have two actions, add and remove stocks.The following code represents the remove
    stocks action method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中，我们在构造函数中注入了一个 `IMediator`。我们使用构造函数注入是因为这个控制器的所有操作都使用了 `IMediator` 接口。我们有两个操作，添加和删除股票。以下代码表示删除股票操作方法：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we read the content of the `RemoveStocks.Command` instance
    from the body, the action sets the `ProductId` property from the route value,
    and it sends the `command` object into the MediatR pipeline. From there, MediatR
    routes the request to its handler before returning the result of that operation
    with an HTTP `200 OK` status code. One of the differences between the preceding
    code and previous implementations is that we moved the DTOs to the vertical slice
    itself. Each vertical slice defines the input, the logic, and the output of its
    feature, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从体中读取了 `RemoveStocks.Command` 实例的内容，操作将 `ProductId` 属性设置为路由值，并将 `command`
    对象发送到 MediatR 管道。从那里，MediatR 将请求路由到其处理器，在返回该操作的结果并带有 HTTP `200 OK` 状态码之前。与前述代码和之前的实现相比的一个区别是我们将
    DTOs 移到了垂直切片本身。每个垂直切片定义了其功能的输入、逻辑和输出，如下所示：
- en: '![Figure 17.5: Diagram representing the three primary pieces of a vertical
    slice](img/file116.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.5：表示垂直切片三个主要部分的图](img/file116.png)'
- en: 'Figure 17.5: Diagram representing the three primary pieces of a vertical slice'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5：表示垂直切片三个主要部分的图
- en: 'When we add input validation, we have the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加输入验证时，我们有以下内容：
- en: '![Figure 17.6: Diagram representing the three primary pieces of a vertical
    slice, with added validation](img/file117.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6：表示垂直切片三个主要部分，并添加了验证的图](img/file117.png)'
- en: 'Figure 17.6: Diagram representing the three primary pieces of a vertical slice,
    with added validation'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6：表示垂直切片三个主要部分，并添加了验证的图
- en: The controller is a tiny layer between HTTP and our domain, guiding the HTTP
    requests to the MediatR pipeline and the responses back to HTTP. That thin piece
    represents the presentation of the API and allows access to the domain logic;
    the features. When controllers grow, it is often a sign that part of the feature
    logic is in the wrong place, most likely leading to code that is harder to test
    because the HTTP and other logic become intertwined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是 HTTP 和我们的领域之间的一个微薄层，引导 HTTP 请求到 MediatR 管道，并将响应返回到 HTTP。这个微薄的部分代表了 API
    的表示，并允许访问领域逻辑；功能。当控制器增长时，这通常是一个迹象，表明功能逻辑的一部分在错误的位置，很可能是导致代码更难测试，因为 HTTP 和其他逻辑变得交织在一起。
- en: We still have the extra line for the `productId` and `try/catch` blocks in the
    controller’s code, but we could eliminate these using custom model binders and
    exception filters. I left additional resources at the end of the chapter, and
    we dig deeper into this in the next chapter.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们仍然在控制器代码中保留了 `productId` 的额外行和 `try/catch` 块，但我们可以使用自定义模型绑定器和异常过滤器来消除这些。我在本章末尾留下了额外的资源，我们将在下一章深入探讨这一点。
- en: 'With that in place, it is now straightforward to add new features to the project.
    Visually, we end up with the following vertical slices (bold), possible vertical
    expansions (normal), and shared classes (italics):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，现在向项目中添加新功能变得简单直接。从视觉上看，我们最终得到以下垂直切片（粗体），可能的垂直扩展（正常），以及共享类（斜体）：
- en: '![Figure 17.7: Diagram representing the project and possible extensions related
    to product management](img/file118.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图17.7：表示项目和与产品管理相关的可能扩展的图表](img/file118.png)'
- en: 'Figure 17.7: Diagram representing the project and possible extensions related
    to product management'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7：表示项目和与产品管理相关的可能扩展的图表
- en: The diagram shows the grouping of the two main areas, products, and stocks.
    On the products side, I included an expansion that depicts a CRUD-like feature
    group.In our tiny application, it is tough to divide the data access part into
    more than one `DbContext`, so `ProductContext` is used by all slices, creating
    a shared data access layer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了两个主要区域，产品，和库存的分组。在产品方面，我包含了一个扩展，描述了一个类似CRUD的功能组。在我们的小型应用程序中，很难将数据访问部分分成多个`DbContext`，因此所有切片都使用`ProductContext`，创建了一个共享的数据访问层。
- en: In other cases, create multiple `DbContext` when possible. This has nothing
    to do with Vertical Slice Archvaliitecture but is a good practice to divide your
    domain into smaller bounded contexts.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在其他情况下，当可能时，创建多个`DbContext`。这与垂直切片架构无关，但将域划分为更小的边界上下文是一个好的实践。
- en: Think about grouping features when they are cohesive and fit under the same
    part of the domain.Next, let’s test our application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当功能具有凝聚性并适合于域的同一部分时，考虑将它们分组。接下来，让我们测试我们的应用程序。
- en: Testing
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试
- en: 'For this project, I wrote one integration test per use case outcome, which
    lowers the number of unit tests required while increasing the level of confidence
    in the system at the same time. Why? Because we are testing the features themselves
    instead of many abstracted parts independently. This is grey-box testing.We can
    also add as many unit tests as we need. This approach helps us write fewer but
    better feature-oriented tests, diminishing the need for mock-heavy unit tests.
    Unit tests are practical for validating complex use cases and algorithms faster
    than integration tests.Let’s look at the `StocksTest` class skeleton first:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我为每个用例结果编写了一个集成测试，这降低了所需的单元测试数量，同时提高了对系统的信心。为什么？因为我们正在测试功能本身，而不是独立地测试许多抽象的部分。这是灰盒测试。我们也可以添加我们需要的任何数量的单元测试。这种方法帮助我们编写更少但更好的面向功能的测试，减少了需要大量模拟的单元测试的需求。单元测试可以比集成测试更快地验证复杂用例和算法。让我们首先看看`StocksTest`类的骨架：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `SeedAsync` method removes all products and inserts two new ones in the
    in-memory test database so the test methods can run using a predictable data set.
    The `AddStocksTest` and `RemoveStocksTest` classes contain the test methods for
    their respective use case. `StocksControllerTest` tests the MVC part. Let’s explore
    the happy path of the `AddStocksTest` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeedAsync`方法从内存测试数据库中删除所有产品并插入两个新的，以便测试方法可以使用可预测的数据集运行。`AddStocksTest`和`RemoveStocksTest`类包含它们各自用例的测试方法。`StocksControllerTest`测试MVC部分。让我们探索`AddStocksTest`类的快乐路径：'
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the *Arrange* section of the preceding test case, we create an instance of
    the application, create a scope to simulate an HTTP request, access the EF Core
    `DbContext`, and then get an `IMediator` instance to act on.In the *Act* block,
    we send a valid `AddStocks.Command` through the MediatR pipeline.We create a new
    scope in the *Assert* block then and get a `ProductContext` out of the container.
    With that `DbContext`, we find the product, ensure it’s not null, and validate
    that the quantity in stock is what we expect. Using a new `ProductContext` ensures
    we are not dealing with any cached items from the previous operations and the
    transaction has been saved as expected.With that test case, we know that if a
    valid command is issued to the mediator, that handler gets executed and successfully
    increments the stock property by the specified amount.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个测试用例的*安排*部分，我们创建了一个应用程序实例，创建了一个作用域来模拟HTTP请求，访问EF Core `DbContext`，然后获取一个`IMediator`实例来执行操作。在*行为*块中，我们通过MediatR管道发送一个有效的`AddStocks.Command`。在*断言*块中，我们创建一个新的作用域，并从容器中获取`ProductContext`。使用这个`DbContext`，我们找到产品，确保它不为空，并验证库存数量是否符合预期。使用新的`ProductContext`确保我们不会处理任何来自先前操作的缓存项，并且事务已按预期保存。通过这个测试用例，我们知道如果向中介者发出有效命令，该处理程序将被执行，并且成功地将库存属性增加指定数量。
- en: The `VerticalAppApplication` class inherits from `WebApplicationFactory<TEntryPoint>`,
    creates a new `DbContextOptionsBuilder<ProductContext>` instance that has a configurable
    database name, implements a `SeedAsync` method that allows seeding the database,
    and allows altering the application services. I omitted the code for brevity reasons,
    but you can consult the complete source code in the GitHub repository ([https://adpg.link/mWep](https://adpg.link/mWep)).
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`VerticalAppApplication`类继承自`WebApplicationFactory<TEntryPoint>`，创建了一个新的`DbContextOptionsBuilder<ProductContext>`实例，该实例具有可配置的数据库名称，实现了一个`SeedAsync`方法，允许对数据库进行初始化，并允许修改应用程序服务。出于简洁的考虑，我省略了代码，但您可以在GitHub仓库中查看完整的源代码（[https://adpg.link/mWep](https://adpg.link/mWep))。'
- en: 'Now, we can test the MVC part to ensure the controller is configured correctly.
    In the `StocksControllerTest` class, the `AddAsync` class contains the following
    test method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试MVC部分以确保控制器配置正确。在`StocksControllerTest`类中，`AddAsync`类包含以下测试方法：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The highlighted code of the preceding test case *Arrange* block mocks the `IMediator`
    and saves what is passed to the `Send` method in the `addStocksCommand` variable.
    We are using that value in the highlighted code of the *Assert* block. When creating
    the `VerticalAppApplication` instance, we register the mock with the container
    to use it instead of the MediatR one, which bypasses the default behavior. We
    then create an `HttpClient` connected to our in-process application and craft
    a valid HTTP request to add the stocks we POST in the *Act* section.The *Assert*
    block code ensures the request was successful, verifies the mock method was hit
    once, and ensures `AddStocks.Command` was configured correctly.From the first
    test, we know the MediatR piece works. With this second test in place, we know
    the HTTP piece works. We are now almost certain that a valid add stocks request
    will hit the database with those two tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个测试用例中高亮的`Arrange`块模拟了`IMediator`，并将传递给`addStocksCommand`变量的内容保存。我们在`Assert`块的高亮代码中使用这个值。在创建`VerticalAppApplication`实例时，我们将模拟注册到容器中，以使用它而不是MediatR的一个，从而绕过了默认行为。然后我们创建了一个连接到我们进程内应用程序的`HttpClient`，并在`Act`部分构建了一个有效的HTTP请求来添加我们POST的股票。`Assert`块代码确保请求成功，验证模拟方法被调用了一次，并确保`AddStocks.Command`配置正确。从第一个测试中，我们知道MediatR部分是正常工作的。有了这个第二个测试，我们知道HTTP部分也是正常工作的。现在我们几乎可以确定，有效的添加股票请求将通过这两个测试击中数据库。
- en: I say “almost certain” because our tests run against an in-memory database,
    which is different from a real database engine (for example, it has no relational
    integrity and the like). In case of more complex database operations that affect
    more than one table or to ensure the correctness of the feature, you can run the
    tests against a database closer to the production database. For example, we can
    run the tests against a SQL Server container to spawn and tear down the databases
    in our CI/CD pipeline easily.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我说“几乎确定”，是因为我们的测试是在内存数据库上运行的，这与真实的数据库引擎（例如，它没有关系完整性等）不同。在涉及多个表或确保功能正确性的更复杂的数据库操作中，您可以对接近生产数据库的数据库运行测试。例如，我们可以运行测试以针对SQL
    Server容器，以便在我们的CI/CD管道中轻松地启动和销毁数据库。
- en: In the test project, I added more tests covering the remove stocks and listing
    all products’ features, and ensuring AutoMapper configuration correctness. Feel
    free to browse the code. I omitted them here as they become redundant. The objective
    is to explore testing a feature almost end to end with very few tests (two for
    the happy path in this case), and I think we covered that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试项目中，我添加了更多测试，涵盖了删除股票和列出所有产品功能，并确保AutoMapper配置正确。请随意浏览代码。我这里省略了它们，因为它们变得冗余。目标是探索使用非常少的测试（在这种情况下是两个用于快乐路径的测试）来测试功能几乎端到端，我认为我们已经做到了这一点。
- en: Conclusion
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The vertical slice project shows how we can remove abstractions while keeping
    the objects loosely coupled. We also organized the project into features (verticals)
    instead of layers (horizontals). We leveraged CQS, Mediator, and MVC patterns.
    Conceptually, the layers are still there; for example, the controllers are part
    of the presentation layer, but they are not organized that way, making them part
    of the feature. The sole dependency that crosses all our features is the `ProductContext`
    class, which makes sense since our model comprises a single class (`Product`).
    We could, for example, add a new feature that leverages minimal APIs instead of
    a controller, which would be okay because each slice is independent.We can significantly
    reduce the number of mocks required by testing each vertical slice with integration
    tests. That can also significantly lower the number of unit tests, testing features
    instead of mocked units of code. We should focus on producing features and business
    value, not the details behind querying the infrastructure or the code itself.
    We should not neglect the technical aspects either; performance and maintainability
    are also important characteristics, but reducing the number of abstractions can
    also make the application easier to maintain and for sure easier to understand.Overall,
    we explored a modern way to design an application that aligns well with Agile
    and helps generate value for our customers.Before moving to the summary, let’s
    see how Vertical Slice Architecture can help us follow the **SOLID** principles:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直切片项目展示了我们如何在保持对象松散耦合的同时移除抽象。我们还把项目组织成了功能（垂直），而不是层（水平）。我们利用了CQS、中介者和MVC模式。从概念上讲，层仍然存在；例如，控制器是表示层的一部分，但它们不是那样组织的，这使得它们成为功能的一部分。唯一跨越所有功能的依赖是`ProductContext`类，这是有意义的，因为我们的模型只包含一个类（`Product`）。例如，我们可以添加一个利用最小API而不是控制器的新功能，这是可以接受的，因为每个切片都是独立的。我们可以通过用集成测试测试每个垂直切片来显著减少所需的模拟数量。这也可以显著减少单元测试的数量，测试功能而不是模拟的代码单元。我们应该专注于产生功能和商业价值，而不是查询基础设施或代码背后的细节。我们也不应该忽视技术方面；性能和可维护性也是重要特征，但减少抽象的数量也可以使应用程序更容易维护，当然更容易理解。总的来说，我们探索了一种与现代设计方法相一致的应用程序设计方式，这有助于与敏捷开发保持一致并为客户创造价值。在进入总结之前，让我们看看垂直切片架构如何帮助我们遵循**SOLID**原则：
- en: '**S**: Each vertical slice (feature) becomes a cohesive unit that changes as
    a whole, leading to the segregation of responsibilities per feature. Based on
    a CQS-inspired approach, each feature splits the application’s complexity into
    commands and queries, leading to multiple small pieces. Each piece handles a part
    of the process. For example, we can define an input, a validator, a mapper profile,
    a handler, a result, an HTTP bridge (controller or endpoint), and as many more
    pieces as we need to craft the slice.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 每个垂直切片（功能）成为一个整体变化的统一单元，导致每个功能的责任分离。基于受CQS启发的方案，每个功能将应用程序的复杂性分解为命令和查询，导致多个小块。每个小块处理过程的一部分。例如，我们可以定义一个输入、一个验证器、一个映射配置文件、一个处理器、一个结果、一个HTTP桥接器（控制器或端点），以及我们需要的任何更多部分来构建切片。'
- en: '**O**: We can enhance the system globally by extending the ASP.NET Core, MVC,
    or MediatR pipelines. We can design the features as we see fit, including respecting
    the OCP.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 我们可以通过扩展ASP.NET Core、MVC或MediatR管道来全局增强系统。我们可以根据需要设计功能，包括尊重OCP。'
- en: '**L**: N/A'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: N/A'
- en: '**I**: By organizing features by units of domain-centric use cases, we create
    many client-specific components instead of general-purpose elements, like layers.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 通过按领域中心用例的单元组织功能，我们创建了众多针对特定客户端的组件，而不是像层这样的通用元素。'
- en: '**D**: The slice pieces depend on interfaces and are tied together using dependency
    injection. Furthermore, by cutting the less useful abstractions out of the system,
    we simplify it, making it more maintainable and concise. Having that many pieces
    of a feature living close to each other makes the system easier to maintain and
    improves its discoverability.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 切片部分依赖于接口，并通过依赖注入相互连接。此外，通过从系统中移除不太有用的抽象，我们简化了它，使其更易于维护和简洁。许多功能部分紧密相邻使得系统更容易维护并提高了其可发现性。'
- en: Next, we look at a few tricks and processes to get started with a bigger application.
    These are ways that I found work for me and will hopefully work for you too. Take
    what works for you and leave the rest; we are all different and work differently.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些技巧和流程，以开始处理更大的应用程序。这些是我发现对我有效的方法，也许对您也有效。取您认为有效的东西，其余的则留给别人；我们都是不同的，工作方式也不同。
- en: 'Continuing your journey: A few tips and tricks'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续您的旅程：一些技巧和窍门
- en: 'The previous project was tiny. It had a shared model that served as the data
    layer because it was composed of a single class. When building real-world applications,
    you have more than one class, so I’ll give you a good starting point to tackle
    bigger apps. The idea is to create slices as small as possible, limit interactions
    with other slices as much as possible, and refactor that code into better code.
    We cannot remove coupling, so we need to organize it instead, and the key is to
    centralize that coupling inside a feature.Here is a workflow inspired by TDD,
    yet less rigid:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的项目很小。它有一个共享模型，作为数据层，因为它由一个类组成。在构建现实世界的应用程序时，您有不止一个类，所以我会给您一个良好的起点来处理更大的应用程序。想法是尽可能创建小的切片，尽可能限制与其他切片的交互，并将该代码重构为更好的代码。我们不能消除耦合，所以我们需要组织它，关键是将其耦合集中在一个功能内部。以下是一个受TDD启发的流程，但不太严格：
- en: Write the contracts that cover your feature (input and output).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写覆盖您功能（输入和输出）的合约。
- en: Write one or more integration tests covering your feature, using those contracts;
    the `Query` or `Command` class (`IRequest`) as input and the `Result` class as
    output.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些合约编写一个或多个覆盖您功能的集成测试；以`Query`或`Command`类（`IRequest`）作为输入，以`Result`类作为输出。
- en: Implement your `Handler`, `Validator`, `MapperProfile`, and any other bit that
    needs to be coded. At this point, the code could be a giant `Handler`; it does
    not matter.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Handler`、`Validator`、`MapperProfile`以及任何需要编码的其他部分。在此阶段，代码可能是一个巨大的`Handler`；这并不重要。
- en: Once your integration tests pass, refactor that code by breaking down your giant
    `Handle` method as needed.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的集成测试通过，根据需要拆分您的巨大`Handle`方法来重构代码。
- en: Make sure your tests still pass.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的测试仍然通过。
- en: 'During *step 2*, you may also test the validation rules with unit tests. It
    is way easier and faster to test multiple combinations and scenarios from unit
    tests, and you don’t need to access a database for that. The same also applies
    to any other parts of your system that are not tied to an external resource.During
    *step 4*, you may find duplicated logic between features. If that’s the case,
    it is time to encapsulate that logic elsewhere, in a shared place. That could
    be creating a method in the model, a service class, or any other pattern and technique
    you know might solve your duplication of logic problem. Working from isolated
    features and extracting shared logic will help you design the application. You
    want to push that shared logic outside of a handler, not the other way around
    (well, once you have that shared logic, you can use it as needed). Here, I want
    to emphasize *shared logic*, which means a business rule. When a business rule
    changes, all consumers of that business rule must also change their behavior.
    Avoid sharing *similar code* but do share business rules. Remember the DRY principle.What
    is very important when designing software is to focus on the functional needs,
    not the technical ones. Your customers and users don’t care about the technical
    stuff; they want results, new features, bug fixes, and improvements. Simultaneously,
    beware of the technical debt, so don’t skip the refactoring step, or your project
    may get in trouble. This advice applies to all types of architecture.Another advice
    is to keep all the code that makes a vertical slice as close as possible. You
    don’t have to keep all use case classes in a single file, but I find this helps.
    Partial classes are a way to split classes into multiple files. If named correctly,
    Visual Studio will nest them under the primary file. For example, Visual Studio
    will nest the `MyFeature.Hander.cs` file under the `MyFeature.cs` file, and so
    on.You can also create a folder hierarchy where the deeper levels share the previous
    levels. For example, the creation process of a workflow I implemented in an MVC
    application related to shipments had multiple steps. So I ended up with a hierarchy
    that looked like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，您还可以使用单元测试来测试验证规则。通过单元测试测试多个组合和场景要容易和快得多，而且您不需要为此访问数据库。同样，这也适用于您的系统中与外部资源无关的任何其他部分。在
    *步骤 4* 中，您可能会在功能之间发现重复的逻辑。如果是这样，那么是时候将这部分逻辑封装到其他地方，一个共享的位置。这可能是在模型中创建一个方法、一个服务类，或者任何其他您知道可以解决您逻辑重复问题的模式和技巧。从隔离的功能中提取共享逻辑将帮助您设计应用程序。您希望将共享逻辑推到处理器外部，而不是相反（当然，一旦您有了共享逻辑，您可以根据需要使用它）。在这里，我想强调
    *共享逻辑*，这意味着业务规则。当业务规则发生变化时，所有使用该业务规则的消费者也必须改变他们的行为。避免共享 *相似代码*，但共享业务规则。记住 DRY
    原则。在设计软件时，非常重要的一点是关注功能需求，而不是技术需求。您的客户和用户不关心技术细节；他们想要结果、新功能、错误修复和改进。同时，要警惕技术债务，不要跳过重构步骤，否则您的项目可能会遇到麻烦。这些建议适用于所有类型的架构。另一个建议是尽可能保持所有构成垂直切片的代码的紧密性。您不需要将所有用例类都放在一个文件中，但我发现这样做有帮助。部分类是一种将类拆分为多个文件的方法。如果命名正确，Visual
    Studio 将将其嵌套在主文件下。例如，Visual Studio 将将 `MyFeature.Hander.cs` 文件嵌套在 `MyFeature.cs`
    文件下，依此类推。您还可以创建一个文件夹层次结构，其中较深级别共享上一级别的文件。例如，我在一个 MVC 应用程序中实现的一个与运输相关的流程创建过程有多个步骤。因此，我最终得到了一个如下所示的层次结构：
- en: '![Figure 17.12: The organizational hierarchy of directories and elements](img/file119.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.12：目录和元素的组织层次结构](img/file119.png)'
- en: 'Figure 17.12: The organizational hierarchy of directories and elements'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.12：目录和元素的组织层次结构
- en: Initially, I coded all the handlers individually. Then I saw patterns emerge,
    so I encapsulated that shared logic into shared classes. Then I reused some upper-level
    exceptions, so I moved those up from the `Features/Shipments/Create` folder to
    the `Features/Shipments` folder. I also extracted a service class to manage shared
    logic between multiple use cases. Ultimately, I have only the code I need, no
    duplicated logic, and the collaborators (classes, interfaces) are as close as
    possible. The coupling between features was minimal, while parts of the system
    work in synergy (cohesion). Moreover, there is very little to no coupling with
    other parts of the system. If we compare that result to another type of architecture,
    such as layering, I would most likely have needed more abstractions, such as repositories,
    services, and whatnot; the result with Vertical Slice Architecture was cleaner
    and simpler.The key point here is to code your handlers independently, organize
    them the best you can, keep an eye open for shared logic and emerging patterns,
    extract and encapsulate that logic, and try to limit interactions between use
    cases and slices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我单独编写了所有处理程序。然后我看到了模式的出现，所以我将共享逻辑封装到共享类中。然后我重用了某些高级异常，所以我将它们从`Features/Shipments/Create`文件夹移动到`Features/Shipments`文件夹。我还提取了一个服务类来管理多个用例之间的共享逻辑。最终，我只有我需要的代码，没有重复的逻辑，协作者（类、接口）尽可能接近。功能之间的耦合最小，而系统的某些部分协同工作（内聚）。此外，与其他系统部分的耦合非常小。如果我们将这个结果与另一种类型的架构，如分层架构进行比较，我可能需要更多的抽象，例如存储库、服务和之类的东西；垂直切片架构的结果更干净、更简单。关键点在于独立编写处理程序，尽可能好地组织它们，留心共享逻辑和出现的模式，提取并封装该逻辑，并尝试限制用例和切片之间的交互。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter overviewed Vertical Slice Architecture, which flips layers by 90°.
    Vertical Slice Architecture is about writing minimal code to generate maximum
    value by getting superfluous abstractions and rules out of the equation by relying
    on the developers’ skills and judgment instead.Refactoring is critical in a Vertical
    Slice Architecture project; success or failure will most likely depend on it.
    We can also use any patterns with Vertical Slice Architecture. It has lots of
    advantages over layering with only a few disadvantages. Teams who work in silos
    (horizontal teams) may need to rethink switching to Vertical Slice Architecture
    and first create or aim at creating multi-functional teams instead (vertical teams).We
    replaced the low-value abstraction with commands and queries (CQS-inspired). Those
    are then routed to their respective `Handler` using the Mediator pattern (helped
    by MediatR). That allows encapsulating the business logic and decoupling it from
    its callers. Those commands and queries ensure that each bit of domain logic is
    centralized in a single location.Of course, if you start with a strong analysis
    of your problem, you will most likely have a head start, like with any project.
    Nothing stops you from building and using a robust domain model in your slices.
    The more requirements you have, the easier the initial project organization will
    be. To reiterate, all engineering practices that you know still apply.The next
    chapter simplifies the concept of Vertical Slice Architecture even more by exploring
    the Request-EndPoint-Response (REPR) pattern using Minimal APIs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了垂直切片架构，该架构通过将层旋转90°来实现。垂直切片架构是关于通过依赖开发者的技能和判断，从方程中去除多余的抽象和规则，以编写最小代码来生成最大价值。在垂直切片架构项目中，重构至关重要；成功或失败很可能取决于它。我们也可以在垂直切片架构中使用任何模式。它相对于分层架构有很多优点，只有少数缺点。在孤岛（水平团队）中工作的团队可能需要重新考虑转向垂直切片架构，并首先创建或旨在创建多功能团队（垂直团队）。我们用命令和查询（受CQS启发）替换了低价值的抽象。然后，使用中介者模式（由MediatR帮助）将它们路由到相应的`Handler`。这允许封装业务逻辑并将其与其调用者解耦。这些命令和查询确保每个领域逻辑的每一部分都集中在一个单一的位置。当然，如果你从对问题的强大分析开始，你很可能会领先，就像任何项目一样。没有什么能阻止你在你的切片中构建和使用健壮的领域模型。你拥有的需求越多，初始项目组织就越容易。重复一遍，你了解的所有工程实践仍然适用。下一章通过探索使用最小API的请求-端点-响应（REPR）模式，进一步简化了垂直切片架构的概念。
- en: Questions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个实践问题：
- en: What design patterns can we use in a vertical slice?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在垂直切片中使用哪些设计模式？
- en: When using Vertical Slice Architecture, is it true that you must pick a single
    ORM and stick with it, such as a data layer?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用垂直切片架构时，是否必须选择一个单一的ORM并坚持使用它，例如数据层？
- en: What will likely happen if you don’t refactor your code and pay the technical
    debt in the long run?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你长期不重构代码和不偿还技术债务，可能会发生什么？
- en: What does cohesion mean?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内聚性是什么意思？
- en: What does tight coupling mean?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧耦合是什么意思？
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few links to build upon what we learned in the chapter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'For UI implementations, you can look at how Jimmy Bogard upgraded ContosoUniversity:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于UI实现，你可以看看Jimmy Bogard是如何升级ContosoUniversity的：
- en: 'ContosoUniversity on ASP.NET Core with .NET Core: [https://adpg.link/UXnr](https://adpg.link/UXnr)'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用.NET Core的ASP.NET Core上的ContosoUniversity: [https://adpg.link/UXnr](https://adpg.link/UXnr)'
- en: 'ContosoUniversity on ASP.NET Core with .NET Core and Razor Pages: [https://adpg.link/6Lbo](https://adpg.link/6Lbo)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用.NET Core和Razor Pages的ASP.NET Core上的ContosoUniversity: [https://adpg.link/6Lbo](https://adpg.link/6Lbo)'
- en: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
- en: 'AutoMapper: [https://adpg.link/5AUZ](https://adpg.link/5AUZ)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AutoMapper: [https://adpg.link/5AUZ](https://adpg.link/5AUZ)'
- en: 'MediatR: [https://adpg.link/ZQap](https://adpg.link/ZQap)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MediatR: [https://adpg.link/ZQap](https://adpg.link/ZQap)'
- en: Answers
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Any pattern and technique you know that can help you implement your feature.
    That’s the beauty of Vertical Slice Architecture; you are limited only by yourself.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道的任何可以帮助你实现特性的模式和技巧。这就是垂直切片架构的美丽之处；你受到的限制只有你自己。
- en: No, you can pick the best tool for the job inside each vertical slice; you don’t
    even need layers.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，你可以在每个垂直切片内选择最适合的工具；你甚至不需要层。
- en: The application will most likely become a Big Ball of Mud and be very hard to
    maintain, which is not good for your stress level, the product quality, time to
    market of changes, and so on.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序很可能会变成一个大泥球，维护起来非常困难，这对你的压力水平、产品质量、变更上市时间等都不利。
- en: Cohesion means elements that should work together as a united whole.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内聚性意味着应该作为一个统一的整体一起工作的元素。
- en: Tight coupling describes elements that cannot change independently; that directly
    depend on one another.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧耦合描述了不能独立改变、直接相互依赖的元素。
