<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.2.1">Testing Your Code</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Testing code</span></strong><span class="koboSpan" id="kobo.4.1"> is an overloaded term when it comes to development. </span><span class="koboSpan" id="kobo.4.2">It can refer to several concepts, such as load testing, unit tests, or integration testing, just to name a few. </span><span class="koboSpan" id="kobo.4.3">All testing concepts are important for developers to understand regarding the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Software Development Life Cycle</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">SDLC</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">Each has its purpose and is equally important to provide stability and confidence, and even </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">provide documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">testing concepts</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Best approaches </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">for testing</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Testing Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Framework Core</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">In the first section, we’ll cover the basic concepts of testing, including unit, integration, regression, load, system, and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">UI tests.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Next, we’ll review some best approaches when writing solid tests for software, including why tests are necessary, how many unit tests are required, using the </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Arrange, Act, Assert</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.23.1">AAA</span></strong><span class="koboSpan" id="kobo.24.1">) technique when writing unit tests, why unit test scaffolding should be avoided, why to avoid large unit tests, how and why to avoid static methods, and, finally, how to use tests </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">for documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Finally, we’ll apply our knowledge of this chapter by creating a full integration test using Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Framework Core.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.28.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.29.1">We recommend using a favorite editor to view this book’s GitHub repository. </span><span class="koboSpan" id="kobo.29.2">Our recommendations include </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">Visual Studio (preferably 2022, though any version </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">is fine)</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Studio Code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.35.1">JetBrains Rider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The code for this chapter is located in Packt Publishing’s GitHub repository, which is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Chapter07</span></strong><span class="koboSpan" id="kobo.40.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.44.1">Understand testing concepts</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Unit tests are</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.46.1"> important to developers because they provide stability to software, confidence in their code, and the added benefit of documenting complex code. </span><span class="koboSpan" id="kobo.46.2">Unit tests provide numerous benefits, as we’ll see in </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">In this section, we’ll review the concepts of testing and why each one is important to the stability and confidence in building </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">a website.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.50.1">Unit tests</span></h2>
<p><span class="koboSpan" id="kobo.51.1">The smallest test we can write to </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.52.1">confirm the code functions as </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.53.1">expected is a unit test. </span><span class="koboSpan" id="kobo.53.2">Unit tests are usually created to test small(-ish) methods, as well as to test multiple parameters sent into those methods and expect a </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">certain result.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Identifying the types of unit tests to write is a simple process of finding conditions in a method and writing the relevant test for </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The following scenarios could justify unit tests throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">a method:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.59.1">Successful flow of a method (that is, the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">happy path)</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Failure of a method’s behavior (that is, the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">unhappy path)</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">Any branching or condition (if..then, switch, inline if, and </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">so on)</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Different parameters passed into </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the method</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.67.1">Exception handling</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.68.1">If we have a large system, the number of unit tests is expected to be in the hundreds since these small, granular methods comprise most of </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The following example shows an extension method formatting a date/time object for display purposes. </span><span class="koboSpan" id="kobo.70.2">Since it’s self-contained, we can simply create a date/time object and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">test it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
[TestMethod]
public void FormattedDateTimeWithTimeTest()
{
    // Arrange
    var startDate = new DateTime(2023, 5, 2, 14, 0, 0);
    const string expected = @"May 2&lt;sup&gt;nd&lt;/sup&gt;, 2023 at 2:00pm";
    // Act
    var actual = startDate.ToFormattedDateTime();
    // Assert
    Assert.AreEqual(expected, actual);
}</span></pre> <p><span class="koboSpan" id="kobo.73.1">This code creates a</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.74.1"> new date with a time. </span><span class="koboSpan" id="kobo.74.2">The unit test is formatted </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.75.1">using the AAA technique (which we’ll cover in a bit) and returns a string to be displayed in </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">our HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Once unit tests are in place, the next step is to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">integration tests.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.79.1">Integration tests</span></h2>
<p><span class="koboSpan" id="kobo.80.1">The next level</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.81.1"> of </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.82.1">testing is integration tests, which require additional functionality as to how the system is tested. </span><span class="koboSpan" id="kobo.82.2">Integration tests involve grouping modules and the ability to test those components as a group, which contrasts with </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">In my experience, the primary difference between integration and unit tests is external resources. </span><span class="koboSpan" id="kobo.84.2">If a unit test accesses an external resource (such as a disk drive, database, network call, or API), it can be considered an </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">integration test.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">The following example shows a simple integration test where we’re connecting to a local test database to </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.87.1">confirm the connection of the database and</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.88.1"> returning a valid </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">IndexModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
[TestClass]
public class PageTests
{
    private DbContextOptions&lt;ThemeParkDbContext&gt; _options;
    private ThemeParkDbContext _context;
    [TestInitialize]
    public void Setup()
    {
        _options = new DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
            .UseSqlServer("Data Source=localhost;Initial                  Catalog=ASPNetCore8BestPractices;" +
                 "Integrated                  Security=True;MultipleActiveResultSets=True;")
                 .Options;
        var config = new Mock&lt;IConfiguration&gt;();
        _context = new ThemeParkDbContext(_options, config.Object);
    }
    [TestMethod]
    [TestCategory("Integration")]
    public void ReturnAnIndexModelTest()
    {
        // Arrange
        var logger = new Mock&lt;ILogger&lt;IndexModel&gt;&gt;();
        var service = new AttractionService(_context);
        // Act
        var actual = new IndexModel(logger.Object, service);
        // Assert
        Assert.IsNotNull(actual);
        Assert.IsInstanceOfType(actual, typeof(IndexModel));
    }
}</span></pre> <p><span class="koboSpan" id="kobo.92.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">DbContextOptionsBuilder</span></strong><span class="koboSpan" id="kobo.94.1">, we created a connection to our local database, created a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">AttractionService</span></strong><span class="koboSpan" id="kobo.96.1"> while passing in our valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.98.1">, and confirmed we have the right type </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">of model.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">In the end, there are</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.101.1"> different ways to conduct integration</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.102.1"> tests, such as creating a mocked-up database or API, duplicating an environment, or even creating a new server for </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">our tests.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.104.1">Regression tests</span></h2>
<p><span class="koboSpan" id="kobo.105.1">Regression tests</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.106.1"> are the functional and nonfunctional </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.107.1">tests we’ve performed in the past. </span><span class="koboSpan" id="kobo.107.2">By nature, these are the past successful tests we ran against the system. </span><span class="koboSpan" id="kobo.107.3">Regression tests are types of tests that are conducted to confirm new features don’t break existing features. </span><span class="koboSpan" id="kobo.107.4">These include the unit tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">integration tests.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.109.1">Load testing</span></h2>
<p><span class="koboSpan" id="kobo.110.1">Once you have the </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.111.1">tests (unit and integration) running in </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.112.1">the CI/CD pipeline (see </span><a href="B19493_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.114.1">) and are expecting a large number of users to hit the site, it is advantageous to create load test(s) for </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the site.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">When load testing a website, subject it to stress levels beyond what a single developer experiences when running the site standalone. </span><span class="koboSpan" id="kobo.116.2">Load testing simulates a large number of users hitting the website concurrently and reports on whether the site can handle a large influx </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">of users.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">The results of a load test may require several team members to help with the performance of the website. </span><span class="koboSpan" id="kobo.118.2">Not only would developers be involved, but </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">database administrators</span></strong><span class="koboSpan" id="kobo.120.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">DBAs</span></strong><span class="koboSpan" id="kobo.122.1">), system </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.123.1">administrators, and even architects would be involved with fixing the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">the site.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">A continuous increase in performance should be the goal of the website and creating load tests to measure performance is key </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">to that.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.127.1">System testing (end-to-end or E2E)</span></h2>
<p><span class="koboSpan" id="kobo.128.1">System testing is </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.129.1">based on certain scenarios </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.130.1">and is a team effort. </span><span class="koboSpan" id="kobo.130.2">Users of the system test new features introduced into the system while other team members conduct regression system testing to confirm new features don’t break </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">existing features.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Members of the team create scenarios for users. </span><span class="koboSpan" id="kobo.132.2">These users are then asked to walk through each scenario and provide feedback on whether it works </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">One example scenario could be broken down into several categories, as </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">shown here:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.136.1">Shopping cart:</span></span><ul><li><span class="koboSpan" id="kobo.137.1">Log in to </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the website</span></span></li><li><span class="koboSpan" id="kobo.139.1">Place an item into the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">shopping cart</span></span></li><li><span class="koboSpan" id="kobo.141.1">Click </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">on checkout</span></span></li><li><span class="koboSpan" id="kobo.143.1">Receive a confirmation page with an </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">order number</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.145.1">If the scenario succeeds, the top scenario (“shopping cart”) will contain a green checkmark, meaning all steps passed with no issues. </span><span class="koboSpan" id="kobo.145.2">If one of the steps failed, a red “X” with a reason underneath it would appear and be placed into the backlog for developers to </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">examine later.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">These types of tests require multiple users to go through the site and find issues with certain scenarios. </span><span class="koboSpan" id="kobo.147.2">There are times when manually testing a site is necessary, but if there’s time </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.148.1">available, it </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.149.1">may make sense to automate these scenarios using a </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">user interface</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">UI</span></strong><span class="koboSpan" id="kobo.153.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">testing approach.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.155.1">UI testing</span></h2>
<p><span class="koboSpan" id="kobo.156.1">UI testing is visually</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.157.1"> conducted through a software tool such as Selenium</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.158.1"> or Cypress and automates an end user clicking around or a customer navigating the website based on a given scenario. </span><span class="koboSpan" id="kobo.158.2">This requires a tester to understand how the UI testing software works; they should know how to access elements on a page, know how to place values into those elements, and know how to activate events such as click and blur to simulate an end user clicking </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">a button.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">These types of tests are usually done after work hours through a CI/CD pipeline but can be run during work hours on a dedicated server (that is, a QA server) to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">issues early.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">In this section, we reviewed various types of testing, including unit tests, integration tests, regression tests, load tests, system tests, and UI testing, and how each one is important and leverages </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">In the next section, we’ll look at what developers are accustomed to when it comes to unit tests, including why we write unit tests, debunking the 100% test coverage myth, how using AAA is a great approach for unit tests, why we should write a unit test library, creating large unit tests, why unnecessary mocks should be avoided, and why unit tests have the added benefit of documentation. </span><span class="koboSpan" id="kobo.164.2">We’ll also learn how to identify slow integration </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.165.1">tests, when</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.166.1"> to write a unit test, and how to avoid testing .</span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">NET code.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.168.1">Best approaches for testing</span></h1>
<p><span class="koboSpan" id="kobo.169.1">Every company has its way </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.170.1">of testing software. </span><span class="koboSpan" id="kobo.170.2">Whether it’s manually or automated, it’s a requirement for developers. </span><span class="koboSpan" id="kobo.170.3">Developers are becoming more than just people who type code. </span><span class="koboSpan" id="kobo.170.4">We’re required to design, write, test, debug, document, build, and </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">deploy software.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Automating tests using a CI/CD approach is where companies can save time and provide consistent stability and quality when releasing software to </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the public.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">In this section, we’ll cover the standards of why testing is important, how to avoid the 100% test coverage myth, what AAA is and why it’s a great approach for unit tests, how to avoid writing a unit test library, large unit tests, and unnecessary mocks. </span><span class="koboSpan" id="kobo.174.2">We’ll also learn about why tests have the added benefit of documentation, how to identify slow integration tests, when to write a unit test, and how to avoid testing .</span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">NET code.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.176.1">Why do we write tests?</span></h2>
<p><span class="koboSpan" id="kobo.177.1">While some believe</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.178.1"> testing starts with developers, I believe it should start </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">with management.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Developers consider tests as an absolute requirement when writing software, but if management believes tests are a waste of time, it may be time to update </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">the resume.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Management, and possibly some developers, have various opinions about the stability of their software and the impact tests have </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">on timetables.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The reason for tests is simple: it allows developers to confirm the code they write to perform as expected. </span><span class="koboSpan" id="kobo.184.2">Further, if tests are providing a simple way to consume a certain module of code, those tests provide clarity to others as well as the original author, for </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">that matter.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.186.1">The “100% test coverage” myth</span></h2>
<p><span class="koboSpan" id="kobo.187.1">As we swing</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.188.1"> the pendulum to the other side, some managers require 100% test coverage. </span><span class="koboSpan" id="kobo.188.2">While some people believe it’s possible, 100% is not achievable </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">or desirable.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">Tests should be created where they are needed, not just for the sake of coverage. </span><span class="koboSpan" id="kobo.190.2">This creates a false metric and presents an illusion of “100% test coverage” if some unit tests are included to fulfill a metric. </span><span class="koboSpan" id="kobo.190.3">Developers may build tests just to “make their quota” to achieve this mythical metric. </span><span class="koboSpan" id="kobo.190.4">Each test should provide integrity with solid results </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">and value.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">This metric goes hand in</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.193.1"> hand with the </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Line-Of-Code</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">LoC</span></strong><span class="koboSpan" id="kobo.197.1">) false metric as well because a developer </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.198.1">who can write code with the least amount of lines is more efficient than a developer who writes less efficient code. </span><span class="koboSpan" id="kobo.198.2">More doesn’t always </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">mean better.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.200.1">Using AAA</span></h2>
<p><span class="koboSpan" id="kobo.201.1">When we write </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.202.1">our unit tests, the best way is to use the </span><a id="_idIndexMarker419"/><span class="No-Break"><span class="koboSpan" id="kobo.203.1">AAA technique:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.204.1">Arrange</span></strong><span class="koboSpan" id="kobo.205.1">: Initialize the code for </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">a test</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.207.1">Act</span></strong><span class="koboSpan" id="kobo.208.1">: Perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">actual test</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.210.1">Assert</span></strong><span class="koboSpan" id="kobo.211.1">: Determine whether the result is the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">expected behavior</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.213.1">The Arrange step should initialize the code and be as minimal </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">The Act step should execute the code in question and should look similar to (if not exactly) like code </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Finally, the Assert step compares the result with what we’re expecting back from </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">The AAA technique provides the easiest way to identify how tests in a system </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">are tested.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.221.1">Avoid writing unit test code for your code</span></h2>
<p><span class="koboSpan" id="kobo.222.1">While the AAA concept</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.223.1"> is a simple way of writing unit tests, there is another approach that I consider a </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">code smell.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Imagine this scenario: the developer has to write a unit test where they have to make a database call using Entity Framework Core. </span><span class="koboSpan" id="kobo.225.2">The Arrange step has 30 lines of code to prepare the Act step to work properly. </span><span class="koboSpan" id="kobo.225.3">The developer takes these 30 lines of code and moves them into a library, making them available for other </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">These 30 lines of code are the code smell I mentioned. </span><span class="koboSpan" id="kobo.227.2">It makes more sense to refactor the code and abstract it even further to simplify the code. </span><span class="koboSpan" id="kobo.227.3">The Arrange step should not include an additional library of custom code to run a unit test. </span><span class="koboSpan" id="kobo.227.4">It should focus on testing the production code already written, not writing additional testing code to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">code pass.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">However, if there is a need for a helper library, it shouldn’t contain any branching statements, which </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.230.1">would require the need to unit test the unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">helper library.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.232.1">Avoid large unit tests</span></h2>
<p><span class="koboSpan" id="kobo.233.1">Developers have </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.234.1">various definitions of what “large” is considered. </span><span class="koboSpan" id="kobo.234.2">Unit tests with more than one page (a screen) of code or more than 30 lines of code should </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">be avoided.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">These types of unit test methods present a problem: they are one step away from creating a library for the Arrange step from our </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">previous tip.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Again, it’s considered a code smell, where someone may need to take a step back and look at better ways to produce smaller setups instead of large code blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">of initialization.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.240.1">Avoid unnecessary mocks, fakes, or stubs</span></h2>
<p><span class="koboSpan" id="kobo.241.1">There are times </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.242.1">when a method on a</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.243.1"> class doesn’t have any dependencies and is completely isolated. </span><span class="koboSpan" id="kobo.243.2">When we encounter this, we may not need to create a mocked object to fully unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Mocking is when we want to test a predefined behavior where stubs return a predefined value. </span><span class="koboSpan" id="kobo.245.2">Fakes are fully populated objects with </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">working implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">At the very beginning of this chapter, we mentioned what a unit test was. </span><span class="koboSpan" id="kobo.247.2">We also created a simple extension method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">.ToFormattedDateTime()</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">Since it’s an isolated method, we don’t require a mocked date/time object. </span><span class="koboSpan" id="kobo.249.3">We simply call </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">For example, if we have a large library of extension methods that contain strings, we can create a unit test, create a string, pass it in, and check the return value is what is expected. </span><span class="koboSpan" id="kobo.251.2">If it requires further testing, rinse and repeat with </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">different parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">When there’s a simple method, sometimes, it’s easier to test its functionality. </span><span class="koboSpan" id="kobo.253.2">No mock, fake, or stub </span><a id="_idIndexMarker425"/><span class="No-Break"><span class="koboSpan" id="kobo.254.1">is</span></span><span class="No-Break"><a id="_idIndexMarker426"/></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1"> necessary.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.256.1">Using tests as documentation</span></h2>
<p><span class="koboSpan" id="kobo.257.1">Every unit </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.258.1">test should contain some explanation of what is tested either in the method signature or in a comment explaining </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">the situation.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">Unit tests should be informative to peers (and our future self) and indicate knowledge of what’s involved in the effort (or abstraction) of completing each unit test and how it relates to the production code </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Along with informative unit tests, directory structure can also act as documentation and can go a long way. </span><span class="koboSpan" id="kobo.262.2">We should mirror the directory structure of the application in the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">If we see a folder in the application (or have a project) named </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Data</span></strong><span class="koboSpan" id="kobo.266.1">, create a similar folder or project for the unit tests called </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Data.Tests</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">While this may be a simple concept, it helps our peers know immediately where and what the tests relate to in </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">For example, if we look at a sample project with unit tests, you may have seen this type </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">of structure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.272.1"><img alt="Figure 7.1 – Example of well-structured tests for a project" src="image/B19493_07_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1">Figure 7.1 – Example of well-structured tests for a project</span></p>
<p><span class="koboSpan" id="kobo.274.1">While some folders are missing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">ThemePark.Tests</span></strong><span class="koboSpan" id="kobo.276.1"> project, we can immediately see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Extensions</span></strong><span class="koboSpan" id="kobo.278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Pages</span></strong><span class="koboSpan" id="kobo.280.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Services</span></strong><span class="koboSpan" id="kobo.282.1"> folders contain at least one type of test. </span><span class="koboSpan" id="kobo.282.2">The presence of test folders mirroring the project folders itself makes it</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.283.1"> known that they contain unit or integration tests and shows a need for additional tests to be included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">testing project.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.285.1">Identifying slow integration tests</span></h2>
<p><span class="koboSpan" id="kobo.286.1">Integration tests </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.287.1">are performed using external resources such as a database, filesystem, or API. </span><span class="koboSpan" id="kobo.287.2">Therefore, integration tests will always run slower than </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">If we are working with a test environment to mimic another environment (such as arranging a QA environment to mimic production), the ability to detect slow connections provides a safeguard that an environment is working as expected. </span><span class="koboSpan" id="kobo.289.2">Ever heard the statement “It works in QA, but not in </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">production” before?</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">However, if we’re working with an in-memory representation of an environment, it doesn’t make sense to identify whether a test is slow or not, does it? </span><span class="koboSpan" id="kobo.291.2">Compared to an actual environment, an in-memory representation of an environment will always </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">run faster.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">One example of this is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Stopwatch</span></strong><span class="koboSpan" id="kobo.295.1"> class to gauge processes (a page or API) to determine whether they’re fast or </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.296.1">very</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1"> fast.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">If we look at our Entity Framework example from </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.299.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.300.1">, and we add an integration test to the project, we can create a simple way to identify whether our page call is slow or not, as shown</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.301.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
using System.Diagnostics;
using EFApplication.Pages;
using EFApplication.Services;
using Microsoft.Extensions.Logging;
using Moq;
namespace ThemePark.Tests.Pages;
[TestClass]
public class PagesTest
{
    [TestMethod]
    [TestCategory("Integration")]
    public void ConfirmTheMainPageReturnsWithinThreeSecondTest()
    {
        // Arrange
        var logger = new Mock&lt;ILogger&lt;IndexModel&gt;&gt;();
        var service = new Mock&lt;IAttractionService&gt;();
        var stopwatch = Stopwatch.StartNew();
        // Act
        _ = new IndexModel(logger.Object, service.Object);
        // Assert
        // Make sure our call is less than 3 seconds
        stopwatch.Stop();
        var duration = stopwatch.Elapsed.Seconds;
        Assert.IsTrue(duration &lt;= 3);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.304.1">In this integration </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.305.1">test, we are testing the main page of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">ThemePark</span></strong><span class="koboSpan" id="kobo.307.1"> application and finding out if it performs well or not. </span><span class="koboSpan" id="kobo.307.2">First, we arrange our classes, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">IndexModel</span></strong><span class="koboSpan" id="kobo.309.1"> accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">ILogger&lt;PageModel&gt;</span></strong><span class="koboSpan" id="kobo.311.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">IAttractionService</span></strong><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">Once we create our stopwatch, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">IndexModel</span></strong><span class="koboSpan" id="kobo.315.1"> (Act) and stop the stopwatch immediately. </span><span class="koboSpan" id="kobo.315.2">We convert it into seconds and conduct our </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">Assert step.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Of course, we are performing an in-memory integration test for illustration purposes, but this concept is best suited to integration tests with external resources to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">latency issues.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">In the example above, we can’t tell if it’s in memory or not just by reading the test. </span><span class="koboSpan" id="kobo.319.2">It’s encapsulated in </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">IndexModel</span></strong><span class="koboSpan" id="kobo.321.1"> and its goal is meant to identify whether it performs quick </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">or not.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.323.1">Find a bug, write a test</span></h2>
<p><span class="koboSpan" id="kobo.324.1">Unit tests are </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.325.1">vital to a stable product, regardless of </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.326.1">whether it’s a web application or a smartphone app. </span><span class="koboSpan" id="kobo.326.2">Every developer will most definitely experience bugs in the application, so it makes sense to always keep the unit tests up </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">to date.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">When we (or the users) encounter a bug, repeat this mantra: </span><em class="italic"><span class="koboSpan" id="kobo.329.1">Find a bug, write a test</span></em><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">This may be a simple concept, but </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">it’s recommended.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">When anyone finds a bug in the application, immediately write a unit test about that bug. </span><span class="koboSpan" id="kobo.332.2">This gives us peace of mind when deploying an application. </span><span class="koboSpan" id="kobo.332.3">If we had a bug and confirmed a unit test fixed the problem, we’ll have enough confidence to say it was tested before being deployed. </span><span class="koboSpan" id="kobo.332.4">It’s one thing to fix the problem, but adding a test makes the code more bulletproof and provides confidence that the bug won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">happen again.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.334.1">Avoid testing .NET</span></h2>
<p><span class="koboSpan" id="kobo.335.1">.NET is a large </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.336.1">framework. </span><span class="koboSpan" id="kobo.336.2">Unit tests are meant to test specific code. </span><em class="italic"><span class="koboSpan" id="kobo.337.1">YOUR code</span></em><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">There is no need to create unit tests for .NET code (or other libraries/frameworks for that matter) when it’s already been tested </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">by Microsoft.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">For example, if there is a test for determining whether a substring method returns the right value, this is testing the .NET framework. </span><em class="italic"><span class="koboSpan" id="kobo.341.1">Don’t write this </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.342.1">unit test</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Our efforts are better suited to a higher scope of the method. </span><span class="koboSpan" id="kobo.344.2">Focus on unit testing the calling method where our code lives as opposed to a .</span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">NET method.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">In this section, we examined why creating unit tests is important and why 100% test coverage is a myth. </span><span class="koboSpan" id="kobo.346.2">We also learned about various common unit testing strategies, such as how to use an AAA scaffolding for our unit tests, why it’s considered a code smell to write additional unit test libraries when creating large unit tests, and why sometimes mocking libraries aren’t necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">for everything.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">We also learned about using tests as documentation using comments and folders, identifying slow integration tests by adding stopwatches, finding a bug and immediately writing a test to bulletproof our code even further, and how to avoid testing .</span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">NET methods.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">In the next section, we’ll review our strategies and apply them to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">ThemePark</span></strong><span class="koboSpan" id="kobo.352.1"> application</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.353.1"> from </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.354.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.356.1">Testing data access</span></h1>
<p><span class="koboSpan" id="kobo.357.1">Over the years, Entity </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.358.1">Framework has strived to become unit testable and gives developers a better level of confidence when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">data access.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Building on when we created a sample database with Entity Framework Core in </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.362.1">, in this section, we’ll cover a simple way to use a SQLite in-memory database to confirm the functionality of our application… even though we don’t have a database connection. </span><span class="koboSpan" id="kobo.362.2">Using the in-memory provider option, Microsoft has recommended avoiding this approach and using either SQLite to conduct database calls or using a production (or better, a QA) database for </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">our queries.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.364.1">Avoid in-memory providers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.365.1">Since in-memory is an extremely simplistic implementation of a database, Microsoft has recommended using alternative methods for testing and avoiding the in-memory provider for databases. </span><span class="koboSpan" id="kobo.365.2">Refer to the following URL for additional </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">details: </span></span><a href="https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database"><span class="No-Break"><span class="koboSpan" id="kobo.367.1">https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.368.1">.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.369.1">Adding the SQLite provider</span></h2>
<p><span class="koboSpan" id="kobo.370.1">Since we don’t</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.371.1"> have a way to access data yet in our </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.372.1">tests, we have to add SQLite to get as close to an implementation as possible. </span><span class="koboSpan" id="kobo.372.2">Using NuGet, we have to add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">NuGet packages:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Microsoft.EntityFrameworkCore.Sqlite</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Microsoft.EntityFrameworkCore.InMemory</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.376.1">Once we have those in our tests, we can proceed with creating our </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">AttractionService</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">LocationService</span></strong><span class="koboSpan" id="kobo.380.1"> tests to confirm they work </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">as expected.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.382.1">Creating the AttractionService test</span></h2>
<p><span class="koboSpan" id="kobo.383.1">Since we</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.384.1"> are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">AttractionService</span></strong><span class="koboSpan" id="kobo.386.1"> as a “repository,” we only </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.387.1">need to pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">DbContext</span></strong><span class="koboSpan" id="kobo.389.1"> for it to work as expected. </span><span class="koboSpan" id="kobo.389.2">Currently, </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.391.1"> creates seeded data for an </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">empty database.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">This is perfect for our needs because when passing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.395.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">DbContext</span></strong><span class="koboSpan" id="kobo.397.1"> could be an in-memory representation or an actual connection to a production database. </span><span class="koboSpan" id="kobo.397.2">In this case, we are creating an in-memory SQLite database for </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">our purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">The SQLite provider opens connections when a call is made and deletes the connection when it’s closed. </span><span class="koboSpan" id="kobo.399.2">We create the connection during setup and provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">[Cleanup]</span></strong><span class="koboSpan" id="kobo.401.1"> attribute to deallocate the connection. </span><span class="koboSpan" id="kobo.401.2">This is specifically </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">for SQLite.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">AttractionService</span></strong><span class="koboSpan" id="kobo.405.1"> integration test is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
using Microsoft.EntityFrameworkCore;
using System.Data.Common;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Configuration;
using Moq;
using ThemePark.DataContext;
using ThemePark.Services;
namespace ThemePark.Tests.Services;
[TestClass]
public class AttractionServiceTest
{
    private DbConnection _connection = null!;
    private DbContextOptions&lt;ThemeParkDbContext&gt; _options = null!;
    private IThemeParkDbContext _context = null!;
    [TestInitialize]
    public void Setup()
    {
        _connection = new SqliteConnection("Filename=:memory:");
        _connection.Open();
        // These options will be used by the context instances in this            test suite,
        // including the connection opened above.
</span><span class="koboSpan" id="kobo.407.2">        _options = new DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
            .UseSqlite(_connection)
            .Options;
        var config = new Mock&lt;IConfiguration&gt;();
        // Create the schema and seed some data
        _context = new ThemeParkDbContext(_options, config.Object);
        _context?.Database.EnsureCreated();
    }
    [TestCleanup]
    public void Cleanup()
    {
        _connection.Dispose();
    }
    [TestMethod]
    public async Task ReturnAllAttractionsTest()
    {
        // Arrange
        var service = new AttractionService(_context);
        // Act
        var records = await service.GetAttractionsAsync();
        // Assert
        Assert.IsTrue(records.Any());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.408.1">In the preceding </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.409.1">example, we tell our tests to run </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.410.1">the setup method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">[TestInitialize]</span></strong><span class="koboSpan" id="kobo.412.1"> attribute and clean up our mess using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">[TestCleanup]</span></strong><span class="koboSpan" id="kobo.414.1"> attribute. </span><span class="koboSpan" id="kobo.414.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">[TestInitialize]</span></strong><span class="koboSpan" id="kobo.416.1"> attribute attaches to a method for initialization purposes. </span><span class="koboSpan" id="kobo.416.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">[TestCleanup]</span></strong><span class="koboSpan" id="kobo.418.1"> attribute identifies a method to clean up what was initialized with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">[</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">TestInitialize]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Since we’re using SQLite for our database, we must create a connection in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Setup()</span></strong><span class="koboSpan" id="kobo.424.1"> method and open the connection. </span><span class="koboSpan" id="kobo.424.2">Once we open it, we need to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">DbContextOptions</span></strong><span class="koboSpan" id="kobo.426.1"> for our fake database. </span><span class="koboSpan" id="kobo.426.2">The final step is to ensure the databases were created for </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">our tests.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">There are two things to notice here. </span><span class="koboSpan" id="kobo.428.2">The first is that we didn’t need a mocked object for </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">DbContext</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">OnConfiguring()</span></strong><span class="koboSpan" id="kobo.432.1"> configuration method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">DbContext</span></strong><span class="koboSpan" id="kobo.434.1">, if we have a configuration (such as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.436.1"> file), we should use it. </span><span class="koboSpan" id="kobo.436.2">If not, we should create a SQLite in-memory database for </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">our testing.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">The second thing to notice is our Act step in our integration test. </span><span class="koboSpan" id="kobo.438.2">This line should be the same one that we have in our production code. </span><span class="koboSpan" id="kobo.438.3">The closer we can get test calls to match what you have in</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.439.1"> production, the more confident we’ll </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.440.1">feel about the code, along with the accuracy and value of </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">those tests.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.442.1">Creating the LocationService test</span></h2>
<p><span class="koboSpan" id="kobo.443.1">Since we have a</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.444.1"> structure of what our tests consist of</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.445.1"> now, we can use those tests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">LocationService</span></strong><span class="koboSpan" id="kobo.447.1">. </span><span class="koboSpan" id="kobo.447.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">LocationService</span></strong><span class="koboSpan" id="kobo.449.1"> test consists of two methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">GetAllLocationsAsync()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.451.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">GetLocationAsync(int)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
[TestMethod]
public async Task ReturnAllLocationsTest()
{
    // Arrange
    var service = new LocationService(_context);
    // Act
    var records = await service.GetLocationsAsync();
    // Assert
    Assert.IsTrue(records.Any());
}
[TestMethod]
[TestCategory("Integration")]
public async Task ReturnOneLocationByIdTest()
{
    // Arrange
    var service = new LocationService(_context);
    // Act
    var record = await service.GetLocationAsync(1);
    // Assert
    Assert.IsNotNull(record);
    Assert.IsTrue(record.Id==1);
}</span></pre> <p><span class="koboSpan" id="kobo.455.1">Again, notice that we didn’t need to mock </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">DbContext</span></strong><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">We created </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">LocationService</span></strong><span class="koboSpan" id="kobo.459.1"> by passing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.461.1"> and used it as we would in a production environment. </span><span class="koboSpan" id="kobo.461.2">The ability to set up and tear down a full database is one of the greatest ways to test the database’s functionality. </span><span class="koboSpan" id="kobo.461.3">While using an existing database would be as equally beneficial, this provides a quicker way of “setting up” and “tearing down” database functionality without the clutter or modifications when others update the database. </span><span class="koboSpan" id="kobo.461.4">If others are using an existing database, this could cause integration tests to fail in a </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">CI/CD pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">In this section, we</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.464.1"> learned how to set up tests with SQLite</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.465.1"> and how to perform queries using an in-memory database to mimic a production database. </span><span class="koboSpan" id="kobo.465.2">We also gave three examples of testing Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">Framework Core.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.467.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.468.1">Testing and documentation are often areas that get deprioritized or overlooked by development teams. </span><span class="koboSpan" id="kobo.468.2">However, testing is a requirement for code bases. </span><span class="koboSpan" id="kobo.468.3">As a final point, developers should make their tests as small and fast as possible using as close to production code in the Act step </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">In this chapter, we covered the different types of testing, which include unit, integration, regression, load testing, system (or E2E tests), and </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">UI testing.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">Once we understood the difference between these types of testing, we examined why creating unit tests is important and why test coverage goals shouldn’t be 100%. </span><span class="koboSpan" id="kobo.472.2">We then covered common unit testing strategies, such as how to use AAA scaffolding for our unit tests, why writing too much code for our unit tests is considered a code smell, and why mocking libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">aren’t required.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Finally, we learned how to supplement documentation by using comments and folders, how to identify slow integration tests by adding stopwatches, how to find a bug and immediately write a test to bulletproof our code even further, and how to avoid testing .</span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">NET methods.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">In the next chapter, we’ll cover exception handling and some of the better ways to handle errors in </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the application.</span></span></p>
</div>
</body></html>