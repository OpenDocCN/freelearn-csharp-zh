- en: Chapter 8. Async
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。异步
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating an `async` method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `异步` 方法
- en: Handling `Exceptions` in asynchronous code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步代码中的 `异常`
- en: Cancelling an asynchronous operation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: Cancelling `async` operation after timeout period
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时后取消 `异步` 操作
- en: Processing multiple `async` tasks as they complete
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务完成时处理多个 `异步` 任务
- en: Improving performance of `async` solution with `Task.WhenAll`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Task.WhenAll` 提高异步解决方案的性能
- en: Using `async` for file access
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `async` 进行文件访问
- en: Checking the progress of an asynchronous task
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异步任务的进度
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: We've all seen client applications that do not respond to mouse events or update
    the display for noticeable periods of time. This delay is likely the result of
    code holding on to the single UI thread for far too long. Maybe it is waiting
    for network I/O or maybe it is performing an intensive computation. Meanwhile,
    the user is left sitting there waiting, as our application grinds to a halt. The
    answer to this problem is asynchrony.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都见过客户端应用程序对鼠标事件没有反应或更新显示需要明显的时间。这种延迟很可能是代码长时间占用单个 UI 线程的结果。也许它正在等待网络 I/O，或者它正在进行密集的计算。与此同时，用户只能坐着等待，因为我们的应用程序几乎停止了。解决这个问题的是异步。
- en: How is the concept of asynchrony different from parallelism? Parallelism, with
    which you are quite familiar by this point in the book, is mainly about application
    performance. Parallelism enables developers to perform CPU intensive work on multiple
    threads at once, taking advantage of modern multi-core computer architectures.
    Asynchrony on the other hand, is a superset of concurrency. It includes concurrency
    as well as other asynchronous calls which are more I/O bound than CPU bound. Let's
    say you are saving a large file to your hard drive or you want to download some
    data from the server. These kinds of I/O bound tasks are ideal for asynchrony.
    Asynchrony is a pattern which yields control instantly, and waits for a callback
    or other notification to occur before continuing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的概念与并行性有何不同？到这本书的这一部分，你很可能对并行性非常熟悉，它主要关于应用性能。并行性使开发者能够同时在一个或多个线程上执行 CPU 密集型工作，利用现代的多核计算机架构。另一方面，异步性是并发的超集。它包括并发以及其他比
    CPU 密集型更 I/O 密集型的异步调用。比如说，你正在将大文件保存到硬盘上，或者你想要从服务器下载一些数据。这类 I/O 密集型任务非常适合异步。异步是一种立即释放控制权并等待回调或其他通知发生后再继续的模式。
- en: 'So, just do things using an asynchronous pattern and your UI responsiveness
    problems are solved, right? Well, yes, but there is one small problem. Asynchronous
    code is difficult, at least historically speaking. However, asynchrony is taking
    a huge leap forward in terms of usability. Microsoft has delivered this by building
    on the `Task` functionality in .NET 4.5, as well as the addition of two new keywords
    to the .NET Framework: `async` and `await`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需使用异步模式做事，你的 UI 响应性问题就解决了，对吧？嗯，是的，但有一个小问题。异步代码是困难的，至少从历史的角度来看。然而，异步性在可用性方面取得了巨大的进步。微软通过在
    .NET 4.5 的 `Task` 功能上构建，以及向 .NET 框架中添加两个新关键字：`async` 和 `await` 来实现这一点。
- en: In this chapter, we will walk through several recipes that show how to maintain
    a responsive UI or scalable services by using the new **Task-based Asynchronous
    Pattern** (**TAP**) of the .NET Framework 4.5.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过几个食谱展示如何使用 .NET Framework 4.5 中的新 **基于任务的异步模式** （**TAP**） 来保持 UI 的响应性或可扩展的服务。
- en: Creating an async method
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个异步方法
- en: The TAP is a new pattern for asynchronous programming in .NET Framework 4.5\.
    It is based on a task, but in this case a task doesn't represent work which will
    be performed on another thread. In this case, a task is used to represent arbitrary
    asynchronous operations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TAP 是 .NET Framework 4.5 中异步编程的新模式。它基于任务，但在这个案例中，任务并不代表将在另一个线程上执行的工作。在这种情况下，任务用于表示任意异步操作。
- en: Let's start learning how `async` and `await` work by creating a **Windows Presentation**
    **Foundation** (**WPF**) application that accesses the web using `HttpClient`.
    This kind of network access is ideal for seeing TAP in action. The application
    will get the contents of a classic book from the web, and will provide a count
    of the number of words in the book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个使用 `HttpClient` 访问网络的 **Windows 表现基础** （**WPF**） 应用程序开始，来学习 `async`
    和 `await` 的工作原理。这种网络访问非常适合观察 TAP 的实际应用。该应用程序将从网络获取一本经典书籍的内容，并提供书中单词数量的统计。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's go to Visual Studio 2012 and see how to use the `async` and `await` keywords
    to maintain a responsive UI by doing the web communications asynchronously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去 Visual Studio 2012 看看如何使用 `async` 和 `await` 关键字通过异步进行网络通信来保持响应式 UI。
- en: Start a new project using the **WPF Application** project template and assign
    `WordCountAsync` as **Solution name**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **WPF 应用程序** 项目模板启动一个新的项目，并将 `WordCountAsync` 作为 **解决方案名称**。
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    a simple user interface containing `Button` and `TextBlock`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开 `MainWindow.xaml` 并添加以下 XAML 以创建一个包含 `Button` 和 `TextBlock` 的简单用户界面：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![How to do it…](img/0225OT_08_01.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/0225OT_08_01.jpg)'
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project** and add a reference
    to `System.Net.Http`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `MainWindow.xaml.cs`。在 **项目** 中添加对 `System.Net.Http` 的引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `MainWindow` 类的顶部：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加一个 `character` 数组常量，该常量将用于将书籍内容拆分为单词数组。
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add a button click event for the `StartButton` and add the `async` modifier
    to the method signature to indicate that this will be a `async` method. Please
    note that `async` methods that return `void` are normally only used for event
    handlers, and should be avoided.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `StartButton` 添加按钮点击事件，并将 `async` 修饰符添加到方法签名中，以指示这将是一个 `async` 方法。请注意，通常只使用返回
    `void` 的 `async` 方法作为事件处理器，应避免使用。
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, let's create a `async` method called `GetWordCountAsync` that returns
    `Task<int>`. This method will create `HttpClient` and call its `GetStringAsync`
    method to download the book contents as a string. It will then use the `Split`
    method to split the string into a `wordArray`. We can return the count of the
    `wordArray` as our `return` value.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `GetWordCountAsync` 的 `async` 方法，它返回 `Task<int>`。这个方法将创建 `HttpClient`
    并调用其 `GetStringAsync` 方法以将书籍内容作为字符串下载。然后，它将使用 `Split` 方法将字符串拆分为 `wordArray`。我们可以返回
    `wordArray` 的计数作为我们的 `return` 值。
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, let's complete the implementation of our button click event. The `Click`
    event handler will just call `GetWordCountAsync` with the `await` keyword and
    display the results to `TextBlock`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们完成按钮点击事件的实现。`Click` 事件处理器将仅使用 `await` 关键字调用 `GetWordCountAsync` 并将结果显示到
    `TextBlock`。
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button, and your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。单击 **开始** 按钮，你的应用程序应该如图所示：![如何做…](img/0225OT_08_02.jpg)
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the TAP, asynchronous methods are marked with an `async` modifier. The `async`
    modifier on a method does not mean that the method will be scheduled to run asynchronously
    on a worker thread. It means that the method contains control flow that involves
    waiting for the result of an asynchronous operation, and will be rewritten by
    the compiler to ensure that the asynchronous operation can resume this method
    at the right spot.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TAP 中，异步方法用 `async` 修饰符标记。方法上的 `async` 修饰符并不意味着该方法将在工作线程上异步运行。它意味着该方法包含涉及等待异步操作结果的控制流，并且将由编译器重写以确保异步操作可以在正确的位置恢复此方法。
- en: Let me try to put this a little more simply. When you add the `async` modifier
    to a method, it indicates that the method will wait on an asynchronous code to
    complete. This is done with the `await` keyword. The compiler actually takes the
    code that follows the `await` keyword in an `async` method and turns it into a
    continuation that will run after the result of the `async` operation is available.
    In the meantime, the method is suspended, and control returns to the method's
    caller.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我尝试将这说得简单一点。当你将 `async` 修饰符添加到方法中时，它表示该方法将等待异步代码完成。这是通过 `await` 关键字完成的。编译器实际上会将
    `async` 方法中 `await` 关键字后面的代码转换为在异步操作结果可用后运行的延续。在此期间，方法被挂起，控制权返回到方法的调用者。
- en: If you add the `async` modifier to a method, and then don't `await` anything,
    it won't cause an error. The method will simply run synchronously.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `async` 修饰符添加到方法中，但没有 `await` 任何内容，它不会导致错误。该方法将简单地同步运行。
- en: 'An `async` method can have one of the three return types: `void`, `Task`, or
    `Task<TResult>`. As mentioned before, a task in this context doesn''t mean that
    this is something that will execute on a separate thread. In this case, task is
    just a container for the asynchronous work, and in the case of `Task<TResult>`,
    it is a promise that a result value of type `TResult` will show up after the asynchronous
    operation completes.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法可以有一个三种返回类型之一：`void`、`Task`或`Task<TResult>`。如前所述，在这个上下文中，任务并不意味着这将在一个单独的线程上执行。在这种情况下，任务只是异步工作的容器，而在`Task<TResult>`的情况下，它是一个承诺，异步操作完成后将出现类型为`TResult`的结果值。
- en: In our application, we use the `async` keyword to mark the button click event
    handler as asynchronous, and then we wait for the `GetWordCountAsync` method to
    complete by using the `wait` keyword.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们使用`async`关键字标记按钮点击事件处理器为异步，然后使用`await`关键字等待`GetWordCountAsync`方法完成。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code that follows the a`wait` keyword, in this case, the same line of code
    that updates `TextBlock`, is turned by the compiler into a continuation that will
    run after the `integer` result is available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`await`关键字之后的代码，在这个例子中，是更新`TextBlock`的同一行代码，被编译器转换为一个在`integer`结果可用后运行的延续。
- en: If the `Click` event is fired again while this asynchronous task is in progress,
    another asynchronous task is created and awaited. To prevent this, it is a common
    practice to disable the button that is clicked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在异步任务进行中再次触发`Click`事件，将创建另一个异步任务并等待。为了防止这种情况，通常的做法是禁用被点击的按钮。
- en: It is a convention to name an asynchronous method with an `Async` postfix, as
    we have done with `GetWordCountAsync`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，异步方法应以`Async`后缀命名，正如我们在`GetWordCountAsync`中所做的那样。
- en: Handling Exceptions in asynchronous code
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在异步代码中处理异常
- en: So how would you add `Exception` handling to code that is executed asynchronously?
    In previous asynchronous patterns, this was very difficult to achieve. In C# 5.0
    it is much more straightforward because you just have to wrap the asynchronous
    function call with a standard `try`/`catch` block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你将如何向执行异步的代码中添加`异常`处理？在之前的异步模式中，这非常困难。在C# 5.0中，这要简单得多，因为你只需要用标准的`try`/`catch`块包装异步函数调用。
- en: On the surface this sounds easy, and it is, but there is more going on behind
    the scene that will be explained right after we build our next example application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上这听起来很简单，确实如此，但在幕后还有更多的事情发生，这些事情将在我们构建下一个示例应用程序后立即解释。
- en: For this recipe, we will return to our classic books word count scenario, and
    we will be handling an `Exception` thrown by `HttpClient` when it tries to get
    the book contents using an incorrect URL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将回到我们经典的书籍单词计数场景，并且我们将处理`HttpClient`在尝试使用错误的URL获取书籍内容时抛出的`异常`。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Let's build another WPF application and take a look at how to handle `Exceptions`
    when something goes wrong in one of our asynchronous methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再构建一个WPF应用程序，并看看当我们的异步方法中发生错误时如何处理`异常`。
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncExceptions` as **Solution name**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**WPF应用程序**项目模板启动一个新项目，并将**解决方案名称**设置为`AsyncExceptions`。
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    a simple user interface containing `Button` and a `TextBlock`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时打开`MainWindow.xaml`，并添加以下XAML以创建一个包含`Button`和`TextBlock`的简单用户界面：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, right-click
    on **References**, click on **Framework** from the menu on the left side of the
    **Reference Manager**, and then add a reference to `System.Net.Http`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`MainWindow.xaml.cs`。转到**项目资源管理器**，右键单击**引用**，点击**框架**从**引用管理器**左侧菜单，然后添加对`System.Net.Http`的引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`MainWindow`类的顶部：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的顶部，添加一个`字符`数组常量，该常量将用于将书籍内容分割成单词数组。
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's create our `GetWordCountAsync` method. This method will be very similar
    to the last recipe, but it will be trying to access the book on an incorrect URL.
    The asynchronous code will be wrapped in a `try`/`catch` block to handle `Exception`.
    We will also use a `finally` block to dispose of `HttpClient`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`GetWordCountAsync`方法。这个方法将与上一个菜谱非常相似，但它将尝试访问一个错误的URL上的书籍。异步代码将被包裹在`try`/`catch`块中，以处理`Exception`。我们还将使用`finally`块来释放`HttpClient`。
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, let create the `Click` event handler for our `StartButton`. This is
    pretty much the same as the last recipe, just wrapped in a `try`/`catch` block.
    Don't forget to add the `async` modifier to the method signature.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建`StartButton`的`Click`事件处理程序。这基本上与上一个菜谱相同，只是包裹在`try`/`catch`块中。别忘了在方法签名上添加`async`修饰符。
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, in Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_03.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Visual Studio 2012中，按*F5*运行项目。点击**Start**按钮。你的应用程序应该如图所示：![如何实现它…](img/0225OT_08_03.jpg)
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Wrapping your asynchronous code in a `try`/`catch` block is pretty easy. In
    fact, it hides some of the complex work Visual Studio 2012 to doing for us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的异步代码包裹在`try`/`catch`块中相当简单。实际上，它隐藏了一些Visual Studio 2012为我们做的复杂工作。
- en: To understand this, you need to think about the context in which your code is
    running.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，你需要考虑你的代码运行的环境。
- en: When the TAP is used in Windows Forms or WPF applications, there's already a
    context that the code is running in, such as the message loop UI thread. When
    `async` calls are made in those applications, the awaited code goes off to do
    its work asynchronously and the `async` method exits back to its caller. In other
    words, the program execution returns to the message loop UI thread.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Windows Forms或WPF应用程序中使用TAP时，代码运行在已经存在的上下文中，例如消息循环UI线程。当在这些应用程序中调用`async`方法时，等待的代码将异步执行其工作，然后`async`方法返回到其调用者。换句话说，程序执行返回到消息循环UI线程。
- en: The `Console` applications don't have the concept of a context. When the code
    hits an awaited call inside the `try` block, it will exit back to its caller,
    which in this case is `Main`. If there is no more code after the awaited call,
    the application ends without the `async` method ever finishing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`应用程序没有上下文的概念。当代码在`try`块中遇到等待的调用时，它将返回到其调用者，在这个例子中是`Main`。如果在等待调用之后没有更多的代码，应用程序将在`async`方法完成之前结束。'
- en: To alleviate this issue, Microsoft included `async` compatible context with
    the TAP that is used for `Console` apps or unit test apps to prevent this inconsistent
    behavior. This new context is called `GeneralThreadAffineContext`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，Microsoft在TAP中包含了与`Console`应用程序或单元测试应用程序兼容的上下文，以防止这种不一致的行为。这个新的上下文被称为`GeneralThreadAffineContext`。
- en: Do you really need to understand these context issues to handle async `Exceptions`?
    No, not really. That's part of the beauty of the Task-based Asynchronous Pattern.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要理解这些上下文问题来处理异步`Exceptions`吗？不，实际上并不需要。这正是基于任务的异步模式（Task-based Asynchronous
    Pattern，简称TAP）之美的一部分。
- en: Cancelling an asynchronous operation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: In .NET 4.5, asynchronous operations can be cancelled in the same way that parallel
    tasks can be cancelled, by passing in `CancellationToken` and calling the `Cancel`
    method on `CancellationTokenSource`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 4.5中，可以通过传递`CancellationToken`并在`CancellationTokenSource`上调用`Cancel`方法来以与取消并行任务相同的方式取消异步操作。
- en: In this recipe, we are going to create a WPF application that gets the contents
    of a classic book over the web and performs a word count. This time though we
    are going to set up a **Cancel** button that we can use to cancel the `async`
    operation if we don't want to wait for it to finish.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个WPF应用程序，从网络上获取一本经典书籍的内容并执行单词计数。这次，我们将设置一个**取消**按钮，我们可以使用它来取消`async`操作，如果我们不想等待它完成的话。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: Let's create a WPF application to show how we can add cancellation to our asynchronous
    methods.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个WPF应用程序来展示我们如何向异步方法添加取消功能。
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncCancellation` as **Solution name**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**WPF应用程序**项目模板启动一个新项目，并将`Solution name`设置为`AsyncCancellation`。
- en: Begin by opening `MainWindow.xaml` and adding the following XAML to create our
    user interface. In this case, the UI contains `TextBlock`, `StartButton`, and
    `CancelButton`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`MainWindow.xaml`并添加以下XAML来创建我们的用户界面。在这种情况下，UI包含`TextBlock`、`StartButton`和`CancelButton`。
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, open up `MainWindow.xaml.cs`, click on the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `MainWindow.xaml.cs`，点击 **项目资源管理器**，并添加对 `System.Net.Http` 的引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `MainWindow` 类的顶部添加以下 `using` 指令：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加一个 `character` 数组常量，该常量将用于将书籍内容拆分为单词数组。
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let's create the `GetWordCountAsync` method. This method is very similar
    to the method explained before. It needs to be marked as asynchronous with the
    `async` modifier and it returns `Task<int>`. This time however, the method takes
    a `CancellationToken` parameter. We also need to use the `GetAsync` method of
    `HttpClient` instead of the `GetStringAsync` method, because the former supports
    cancellation, whereas the latter does not. We will add a small delay in the method
    so we have time to cancel the operation before the download completes.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `GetWordCountAsync` 方法。这个方法与之前解释的方法非常相似。它需要使用 `async` 修饰符标记为异步，并返回
    `Task<int>`。然而，这次方法需要一个 `CancellationToken` 参数。我们还需要使用 `HttpClient` 的 `GetAsync`
    方法而不是 `GetStringAsync` 方法，因为前者支持取消，而后者则不支持。我们将在方法中添加一个小的延迟，以便在下载完成之前有时间取消操作。
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's create the `Click` event handler for our `CancelButton`. This method
    just needs to check if `CancellationTokenSource` is `null`, and if not, it calls
    the `Cancel` method.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的 `CancelButton` 创建一个 `Click` 事件处理器。这个方法只需要检查 `CancellationTokenSource`
    是否为 `null`，如果不是，就调用 `Cancel` 方法。
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ok, let's finish up by adding a `Click` event handler for `StartButton`. This
    method is the same as explained before, except we also have a `catch` block that
    specifically handles `OperationCancelledException`. Don't forget to mark the method
    with the `async` modifier.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们通过为 `StartButton` 添加一个 `Click` 事件处理器来完成。这个方法与之前解释的相同，只是我们还有一个专门处理 `OperationCancelledException`
    的 `catch` 块。别忘了用 `async` 修饰符标记该方法。
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In Visual Studio 2012, press *F5* to run the project Click on the **Start**
    button, then the **Cancel** button. Your application should appear as shown in
    the following screenshot:![How to do it…](img/0225OT_08_04.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。点击 **启动** 按钮，然后点击 **取消** 按钮。你的应用程序应该看起来像下面的截图所示：![如何做…](img/0225OT_08_04.jpg)
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cancellation is an aspect of user interaction that you need to consider to build
    a professional `async` application. In this example, we implemented cancellation
    by using a **Cancel** button, which is one of the most common ways to surface
    cancellation functionality in a GUI application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 取消是构建专业 `async` 应用程序时需要考虑的用户交互的一个方面。在这个例子中，我们通过使用 **取消** 按钮实现了取消，这是在 GUI 应用程序中公开取消功能的最常见方式之一。
- en: In this recipe, cancellation follows a very common flow.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，取消遵循一个非常常见的流程。
- en: The caller (start button click event handler) creates a `CancellationTokenSource`
    object.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者（启动按钮点击事件处理器）创建一个 `CancellationTokenSource` 对象。
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The caller calls a cancelable method, and passes `CancellationToken` from `CancellationTokenSource`
    (`CancellationTokenSource.Token`).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者调用一个可取消的方法，并传递来自 `CancellationTokenSource` 的 `CancellationToken`（`CancellationTokenSource.Token`）。
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The cancel button click event handler requests cancellation using the `CancellationTokenSource`
    object (`CancellationTokenSource.Cancel()`).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消按钮点击事件处理器使用 `CancellationTokenSource` 对象（`CancellationTokenSource.Cancel()`）请求取消。
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The task acknowledges the cancellation by throwing `OperationCancelledException`,
    which we handle in a `catch` block in the start button click event handler.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务通过抛出 `OperationCancelledException` 来确认取消，我们在启动按钮点击事件处理器的 `catch` 块中处理它。
- en: Cancelling async operation after timeout period
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时周期后取消异步操作
- en: Another common scenario for cancelling asynchronous tasks is to set a timeout
    period by using the `CancellationTokenSource.CancelAfter` method. This method
    schedules the cancellation of any associated tasks that aren't complete within
    the period of time that's designated by the `CancelAfter` expression.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 取消异步任务的另一个常见场景是使用 `CancellationTokenSource.CancelAfter` 方法设置超时周期。此方法安排在 `CancelAfter`
    表达式指定的周期内未完成的任何相关任务的取消。
- en: In this recipe, we are going to create a WPF application that gets the contents
    of a classic book over the web and performs a word count. This time though, we
    are going to set a timeout period after which the task gets cancelled.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 WPF 应用程序，从网络上获取经典书籍的内容并执行单词计数。不过这次，我们将设置一个超时期间，在此期间任务将被取消。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's see how we can create an asynchronous task that cancels after a specified
    timeout period.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个在指定超时期间取消的异步任务。
- en: Start a new project using the **WPF Application** project template and assign
    `CancelAfterTimeout` as **Solution name**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **WPF 应用程序** 项目模板启动一个新的项目，并将 `CancelAfterTimeout` 作为 **解决方案名称**。
- en: 'Begin by opening `MainWindow.xaml` and add the following XAML to create our
    user interface:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开 `MainWindow.xaml` 并添加以下 XAML 以创建我们的用户界面：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![How to do it…](img/0225OT_08_05.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/0225OT_08_05.jpg)'
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer** and add a
    reference to `System.Net.Http`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `MainWindow.xaml.cs`。转到 **项目资源管理器** 并添加对 `System.Net.Http` 的引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `MainWindow` 类的顶部：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加一个 `character` 数组常量，该常量将用于将书籍的内容分割成单词数组。
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, let's create the `GetWordCountAsync` method. This method is exactly the
    same as the last recipe. It needs to be marked as asynchronous with the `async`
    modifier and it returns `Task<int>`. The method takes a `CancellationToken` parameter.
    We will add a small delay in the method so we have time to cancel the operation
    before the download completes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `GetWordCountAsync` 方法。这个方法与上一个菜谱完全相同。它需要使用 `async` 修饰符标记为异步，并返回 `Task<int>`。该方法接受一个
    `CancellationToken` 参数。我们将在方法中添加一个小的延迟，以便在下载完成之前有时间取消操作。
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ok, let's finish up by adding a `Click` event handler for `StartButton`. This
    method is similar to the last recipe, except we call the `CancellationTokenSource.CancelAfter`
    method, passing it the value of our `timeout` textbox. Don't forget to mark the
    method with the `async` modifier.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们通过为 `StartButton` 添加 `Click` 事件处理程序来完成。这个方法与上一个菜谱类似，只是我们调用 `CancellationTokenSource.CancelAfter`
    方法，传入 `timeout` 文本框的值。别忘了用 `async` 修饰符标记该方法。
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Visual Studio 2012, press *F5* to run the project. Set the `timeout` value
    to `100`. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_06.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。将 `timeout` 值设置为 `100`。您的应用程序应如图所示：![如何操作…](img/0225OT_08_06.jpg)
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The application is very similar to the application we created in the last recipe,
    except this time the `Cancel` button isn't used. The actual cancellation follows
    a similar flow however.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序与我们上一次创建的应用程序非常相似，只是这次没有使用 `Cancel` 按钮。实际的取消流程与此类似。
- en: The caller (start button click event handler) creates a `CancellationTokenSource`
    object, and then calls the `CancelAfter` method to pass in the `timeout` value.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者（开始按钮点击事件处理程序）创建一个 `CancellationTokenSource` 对象，然后调用 `CancelAfter` 方法传入 `timeout`
    值。
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The caller calls a cancelable method, and passes `CancellationToken` from `CancellationTokenSource`
    (`CancellationTokenSource.Token`).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者调用一个可取消的方法，并传递来自 `CancellationTokenSource` 的 `CancellationToken` (`CancellationTokenSource.Token`)。
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After the timeout period expires, `CancellationTokenSource` triggers a cancellation
    same as if we had made a call to `CancellationTokenSource.Cancel`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超时期间过后，`CancellationTokenSource` 触发取消操作，就像我们调用 `CancellationTokenSource.Cancel`
    一样。
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The task acknowledges the cancellation by throwing `OperationCancelledException`,
    which we handle in a `catch` block in the start button click event handler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 任务通过抛出 `OperationCancelledException` 来确认取消，我们在开始按钮点击事件处理程序中的 `catch` 块中处理它。
- en: Processing multiple async tasks as they complete
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个异步任务，当它们完成时
- en: Many of the methods of the `Task` class that we learned about in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Task Parallel Library"), *Getting Started with
    Task Parallel Library*, are as useful when writing an asynchronous code as they
    are when writing a parallel code. In this recipe, we are going to download the
    contents of multiple books and use `Task.WhenAny` to process them as they finish.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](ch01.html "第 1 章。使用任务并行库入门") 中学到的 `Task` 类的许多方法，在编写异步代码时与编写并行代码时一样有用。在本菜谱中，我们将下载多本书的内容，并使用
    `Task.WhenAny` 在它们完成时处理它们。
- en: This application will use a `while` loop to create a collection of tasks. Each
    task downloads the contents of a specified book. In each iteration of a loop,
    an awaited call to `WhenAny` returns the task in the collection of tasks that
    finishes first. That task is removed from the collection and processed. The loop
    repeats until the collection contains no more tasks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将使用 `while` 循环创建任务集合。每个任务下载指定书籍的内容。在循环的每次迭代中，对 `WhenAny` 的等待调用返回任务集合中首先完成的任务。该任务从集合中删除并处理。循环重复进行，直到集合中不再包含任务。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Now, let's create a WPF application that creates multiple asynchronous tasks
    and processes them as they complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 WPF 应用程序，该程序创建多个异步任务并在它们完成时处理它们。
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncMultipleRequest` as **Solution name**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **WPF 应用程序** 项目模板启动一个新项目，并将 `AsyncMultipleRequest` 作为 **解决方案名称**。
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `MainWindow.xaml` 并添加以下 XAML 以创建我们的用户界面：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `MainWindow.xaml.cs`。转到 **项目资源管理器**，并将 `System.Net.Http` 添加为引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加以下 `using` 指令：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加一个 `character` 数组常量，该常量将用于将书籍内容拆分为单词数组。
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's start by creating a helper function that builds a list of `KeyValuePair<string,string>`
    which represents our book titles and URLs.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个辅助函数，该函数构建一个 `KeyValuePair<string,string>` 列表，表示我们的书籍标题和 URL。
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now let's create an `async` method that does the book download and returns `KeyValuePair<string,
    int>` that represents our book titles and word count. This method will need to
    accept a `KeyValuePair<string, string>` parameter representing the book title
    and URL. The method also needs an `HttpClient` parameter.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 `async` 方法，该方法执行书籍下载并返回 `KeyValuePair<string, int>`，表示我们的书籍标题和单词数。此方法需要接受一个
    `KeyValuePair<string, string>` 参数，表示书籍标题和 URL。该方法还需要一个 `HttpClient` 参数。
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we need to create another `async` method called `GetMultipleWordCount`.
    This method executes a query on our list of books. Each query calls the `ProcessBook`
    method to actually do the download and obtain the word count. After the query,
    we set up a `while` loop that loops while our list of book processing tasks is
    greater than zero. Each iteration of the loop awaits a call to `Task.WhenAny`.
    When a task is completed, the results are written out and `Task` is removed from
    the `Task` list. This method takes no parameters and returns `Task`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建另一个名为 `GetMultipleWordCount` 的 `async` 方法。此方法在我们的书籍列表上执行查询。每个查询调用 `ProcessBook`
    方法来实际下载并获取单词数。查询后，我们设置一个 `while` 循环，该循环在书籍处理任务列表大于零时循环。循环的每次迭代都等待对 `Task.WhenAny`
    的调用。当任务完成时，结果被写入并从 `Task` 列表中删除。此方法不接受任何参数并返回 `Task`。
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, let's create our start button click event handler. The handler only
    needs to call the `GetMultipleWordCount` method.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建我们的启动按钮点击事件处理程序。处理程序只需要调用 `GetMultipleWordCount` 方法。
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_08_07.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。您的应用程序应如图所示：![如何做到这一点…](img/0225OT_08_07.jpg)
- en: How it works…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We have already seen in the previous recipes that the `WhenAny` method of the
    `Task` class can be used on a list of parallel tasks to continue processing when
    any of the tasks in the array is complete.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们已经看到 `Task` 类的 `WhenAny` 方法可以用于并行任务列表，以便在数组中的任何任务完成时继续处理。
- en: Even though a task in the `async` context doesn't mean that our list of `async`
    tasks are running in parallel on separate worker threads, we can still use the
    `WhenAny` method to handle `async` requests as they complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在`async`上下文中，一个任务并不意味着我们的`async`任务列表在单独的工作线程上并行运行，我们仍然可以使用`WhenAny`方法来处理`async`请求，当它们完成时。
- en: In this recipe, we downloaded the text of multiple books and displayed the word
    count of each of the books as the download finished. The start button's click
    event handler doesn't do much other than add some text to `TextBlock` and `await`
    a call to the `GetMultipleWordCount` method. After creating `HttpClient`, the
    `GetMultipleWordCount` method makes a call to the `GetBookUrls` helper method
    that we created, which just returns a list of three books and their URLs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在下载完成后下载了多本书的文本，并显示了每本书的单词计数。除了向`TextBlock`添加一些文本并等待调用`GetMultipleWordCount`方法之外，开始按钮的点击事件处理器并没有做太多的事情。在创建`HttpClient`之后，`GetMultipleWordCount`方法调用我们创建的辅助方法`GetBookUrls`，该方法仅返回三本书及其URL的列表。
- en: After getting the list of books and their URLs, the `GetMultipleWordCount` method
    creates `IEnumerable<Task<TResult>>` by executing a LINQ query that calls the
    `ProcessBook` method on each `book` in the list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取书籍及其URL的列表后，`GetMultipleWordCount`方法通过执行一个LINQ查询来创建`IEnumerable<Task<TResult>>`，该查询对列表中的每个`book`调用`ProcessBook`方法。
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we set up a `while` loop on the condition that `bookTasks.Count` is greater
    than zero. In the body of the `while` loop, we `await` a call to the `Task.WhenAny`
    method, which will return when the first list of tasks is complete. We then remove
    this `Task` from `bookTasks` so the count is decremented. Below that, we await
    the `firstFinished` task variable. This has the effect of the compiler creating
    a continuation for us at this point that will run, as soon as the `task` variable
    `firstFinished` is completed, the compiler-created continuation will contain the
    code to update the `TextBlock` with the word count for the book.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个`while`循环，条件是`bookTasks.Count`大于零。在`while`循环的主体中，我们`await`调用`Task.WhenAny`方法，该方法将在第一个任务列表完成时返回。然后我们从`bookTasks`中移除这个`Task`，以便计数递减。下面，我们`await``firstFinished`任务变量。这会导致编译器在此处为我们创建一个延续，一旦`task`变量`firstFinished`完成，编译器创建的延续将包含更新`TextBlock`中书籍单词计数的代码。
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Improving performance of async solution with Task.WhenAll
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Task.WhenAll改进异步解决方案的性能
- en: We have already seen how we can use the `Task.WhenAny` method to handle asynchronous
    tasks as they complete. You will also find the `Task.WhenAll` method very useful
    in the asynchronous context. In some applications that create multiple asynchronous
    requests, it can improve application performance by using `Task.WhenAll` to hold
    off on processing results until all the asynchronous tasks have completed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`Task.WhenAny`方法来处理异步任务，当它们完成时。你也会发现`Task.WhenAll`方法在异步上下文中非常有用。在一些创建多个异步请求的应用程序中，使用`Task.WhenAll`可以延迟处理结果，直到所有异步任务都完成，从而提高应用程序的性能。
- en: In this recipe, we are going to create a WPF application that downloads the
    contents of multiple books asynchronously, but holds off on processing the results
    until all the tasks have completed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个WPF应用程序，该应用程序异步下载多本书的内容，但在所有任务完成之前不处理结果。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncMultipleRequest` as **Solution name**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**WPF应用程序**项目模板启动一个新的项目，并将**解决方案名称**分配为`AsyncMultipleRequest`。
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时，打开`MainWindow.xaml`并添加以下XAML以创建我们的用户界面：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`MainWindow.xaml.cs`。转到**项目资源管理器**，并添加对`System.Net.Http`的引用。
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`MainWindow`类的顶部：
- en: '[PRE39]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的顶部，添加一个`character`数组常量，该常量将用于将书籍内容拆分为单词数组。
- en: '[PRE40]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's start by creating a helper function that builds a list of `KeyValuePair<string,string>`,
    which represents our book titles and URLs.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个辅助函数，该函数构建一个`KeyValuePair<string,string>`列表，表示我们的书籍标题和URL。
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now let's create a `async` method that performs the book download and returns
    `KeyValuePair<string, int>` that represents our book titles and word count. This
    method will need to accept a `KeyValuePair<string, string>` parameter representing
    the book title and URL. The method also needs a `HttpClient` parameter.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个执行书籍下载并返回表示我们的书籍标题和单词计数的 `KeyValuePair<string, int>` 的 `async` 方法。此方法需要接受一个表示书籍标题和
    URL 的 `KeyValuePair<string, string>` 参数。该方法还需要一个 `HttpClient` 参数。
- en: '[PRE42]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we need to create the `GetWordCount` method. This method will execute
    a LINQ query to call the `ProcessBook` method on each `book` in the list of books.
    It then calls `Task.WhenAll` to `await` the tasks completed of all of the tasks.
    When all tasks have finished, it needs to write the results to the `TextBlock`
    in a `for` loop.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `GetWordCount` 方法。此方法将执行 LINQ 查询以对列表中的每个 `book` 调用 `ProcessBook`
    方法。然后它调用 `Task.WhenAll` 以 `await` 所有任务的完成。当所有任务完成时，它需要在 `for` 循环中将结果写入 `TextBlock`。
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Lastly, the start button click event handler just needs to call the `GetWordCount`
    method and `await` the task.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动按钮的点击事件处理程序只需调用 `GetWordCount` 方法并 `await` 任务。
- en: '[PRE44]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    have results as shown in the following screenshot:![How to do it…](img/0225OT_08_08.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你的应用程序应该有如下截图所示的结果：![如何做…](img/0225OT_08_08.jpg)
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, the `GetWordCount` method calls the `ProcessBook` method for
    each book in the list by executing a LINQ query. This returns an `IEnumerable<Task<TResult>>`,
    when we turn in to an array of tasks by calling the `ToArray` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，`GetWordCount` 方法通过执行 LINQ 查询为列表中的每本书调用 `ProcessBook` 方法。这返回一个 `IEnumerable<Task<TResult>>`，当我们调用
    `ToArray` 方法时，将其转换为任务数组。
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we just `await` a call to the `Task.WhenAll` method which will return
    when all of the asynchronous tasks complete. Finally, we just use a `for` loop
    to update the `TextBlock`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需 `await` 一个调用 `Task.WhenAll` 方法的调用，该方法将在所有异步任务完成时返回。最后，我们只需使用一个 `for`
    循环来更新 `TextBlock`。
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using async for file access
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步进行文件访问
- en: Until now, we have created applications that use `async` for web access, using
    `HttpClient`. Another common use for `async` is performing asynchronous file I/O
    without blocking the main thread.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了使用 `async` 进行网络访问的应用程序，使用了 `HttpClient`。`async` 的另一个常见用途是在不阻塞主线程的情况下执行异步文件
    I/O。
- en: In this recipe, we are going to create a WPF application that can write to and
    read from a file asynchronously. The application will have two text boxes, one
    containing the text to write to a file, and the other containing text to read
    from a file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 WPF 应用程序，该程序可以异步写入和读取文件。应用程序将有两个文本框，一个包含要写入文件的文本，另一个包含要读取的文件中的文本。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncFileAccess` as **Solution name**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **WPF 应用程序** 项目模板启动一个新的项目，并将 `AsyncFileAccess` 作为 **解决方案名称**。
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `MainWindow.xaml` 并添加以下 XAML 以创建我们的用户界面：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![How to do it…](img/0225OT_08_09.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/0225OT_08_09.jpg)'
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `MainWindow` 类的顶部添加以下 `using` 指令：
- en: '[PRE48]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the top of the `MainWindow` class, add a `path` constant for the path of
    the text file you will be writing. This can be any path you like.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的顶部添加一个 `path` 常量，用于将要写入的文本文件的路径。这可以是任何你喜欢的路径。
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, let's create a `async` method called `WriteToFileAsync` that returns `Task`.
    This method gets a `Unicode` encoded `byte` array of the text in our `TextBox`,
    creates a file stream, and writes the text to the file.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个返回 `Task` 的 `async` 方法，称为 `WriteToFileAsync`。此方法获取 `TextBox` 中文本的
    `Unicode` 编码 `byte` 数组，创建一个文件流，并将文本写入文件。
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now create an asynchronous `Click` event handler for the `Write` button. Here,
    we just need to `await` a call to `WriteFileAsync`, passing it the input string.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个异步的 `Click` 事件处理程序，用于 `Write` 按钮。在这里，我们只需 `await` 一个调用 `WriteFileAsync`
    的调用，并传递输入字符串。
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, let's create an asynchronous method called `ReadFromFileAsync` that returns
    `Task<string>`. This method creates `FileStream` and reads the contents of the
    file into `string`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个返回 `Task<string>` 的异步方法，称为 `ReadFromFileAsync`。此方法创建 `FileStream`
    并将文件内容读取到 `string` 中。
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, let's create the read button click handler. This `async` method just
    needs to check for the existence of the file, and `await` a call to `ReadFromFileAsync`.
    Set the results of the method call to the proper `TextBox`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建读取按钮的点击处理程序。这个`async`方法只需要检查文件是否存在，并`await`对`ReadFromFileAsync`的调用。将方法调用的结果设置到适当的`TextBox`中。
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_08_010.jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你的应用程序应该如图所示：![如何操作…](img/0225OT_08_010.jpg)
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `Click` event handler is pretty straightforward. It is marked with the `async`
    keyword because it awaits a call to `WriteToFileAsync`. You must have noticed
    that we disabled the `Write` button at the start of the method and enabled it
    again at the end. This is a good practice to control reentrancy with `async` methods.
    The UI is free to respond to clicks and will fire the `Click` event handler again,
    if it receives a click.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Click`事件处理程序非常简单明了。它被标记为`async`关键字，因为它等待对`WriteToFileAsync`的调用。你一定注意到了，我们在方法开始时禁用了`Write`按钮，并在方法结束时再次启用它。这是一种很好的实践，用于使用`async`方法控制可重入性。UI可以自由响应用户点击，并在接收到点击时再次触发`Click`事件处理程序。'
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `WriteToFileAsync` method gets a `Unicode` encoded `byte` array of the input
    string then creates `FileStream` with `Write` access in the `Append` mode. Once
    `stream` is open, we `await` a call to the `WriteAsync` method of `FileStream`,
    passing it our `byte` array.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteToFileAsync`方法获取输入字符串的`Unicode`编码`byte`数组，然后以`Append`模式创建具有写入访问权限的`FileStream`。一旦`stream`打开，我们`await`对`FileStream`的`WriteAsync`方法的调用，并传递我们的`byte`数组。'
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `ReadFromFileAsync` method just creates `FileStream` in open mode with read
    access. Once the `stream` is open, we `await` a call to the `ReadAsync` method
    of `FileStream` in a `while` loop, and read its contents.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromFileAsync`方法仅创建具有读取访问权限的`FileStream`。一旦`stream`打开，我们就在`while`循环中`await`对`FileStream`的`ReadAsync`方法的调用，并读取其内容。'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Checking the progress of an asynchronous task
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查异步任务进度
- en: If an asynchronous functionality in your application involves a noticeable delay
    while the user waits for the result, you might want to inform users that there
    will be a wait and provide a sense of how long the wait might be. The progress
    and cancellation features of the `async` programming model enable you to deliver
    on these needs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序中的异步功能在用户等待结果时涉及明显的延迟，你可能想通知用户将会有等待，并提供等待可能持续多长时间的感觉。`async`编程模型的进度和取消功能使你能够满足这些需求。
- en: In this recipe, we are going to create a WPF application that uses the progress
    events of `WebClient` to display the status of a `Download` task with a `ProgressBar`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个使用`WebClient`的进度事件来显示`Download`任务状态的WPF应用程序。
- en: How to do it…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create a WPF application and see how we can add progress reporting to
    our asynchronous operations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个WPF应用程序，看看我们如何向异步操作添加进度报告。
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncProgress` as **Solution name**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**WPF应用程序**项目模板启动一个新项目，并将`AsyncProgress`作为**解决方案名称**。
- en: 'Begin by opening `MainWindow.xaml` and add the following XAML to create our
    user interface:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`MainWindow.xaml`，并添加以下XAML以创建我们的用户界面：
- en: '[PRE57]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![How to do it…](img/0225OT_08_011.jpg)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/0225OT_08_011.jpg)'
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`MainWindow`类的顶部：
- en: '[PRE58]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array. Also add a `string`
    constant for the user agent header for a `WebClient`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的顶部添加一个`character`数组常量，该常量将用于将书籍内容分割成单词数组。还要添加一个用于`WebClient`用户代理头的`string`常量。
- en: '[PRE59]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now let's add a method called `client_DownloadFileCompleted` that will be the
    event handler for the `DownloadFileCompleted` event of a `WebClient`. This method
    just needs to add some text to `TextBlock` to indicate that the download has finished.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`client_DownloadFileCompleted`的方法，它将是`WebClient`的`DownloadFileCompleted`事件的事件处理程序。这个方法只需要向`TextBlock`添加一些文本，以指示下载已完成。
- en: '[PRE60]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, create a method called `client_DownloadProgressChanged`. This method will
    be the event handler for the WebClient's `DownloadProgressChanged` event, and
    needs to calculate the bytes received, the total bytes, the percentage complete,
    and update the progress bar.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `client_DownloadProgressChanged` 的方法。这个方法将是 `WebClient` 的 `DownloadProgressChanged`
    事件的事件处理程序，需要计算已接收的字节数、总字节数、完成百分比，并更新进度条。
- en: '[PRE61]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now we need to create our asynchronous `GetWordCountAsync` method. This method
    returns `Task<int>`, and after creating `WebClient`, and wiring up the `DownloadFileCompletedEvent`
    and `DownloadProgressChanged` events, it awaits a call to the `DownloadStringTaskAsync`
    method of `WebClient` to download the contents of the book and split the words
    into an array of strings.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的异步 `GetWordCountAsync` 方法。该方法返回 `Task<int>`，在创建 `WebClient` 并连接 `DownloadFileCompletedEvent`
    和 `DownloadProgressChanged` 事件之后，它等待对 `WebClient` 的 `DownloadStringTaskAsync`
    方法的调用，以下载书籍的内容并将单词分割成字符串数组。
- en: '[PRE62]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, let's create an asynchronous `Click` event handler for `StartButton`.
    This button just writes some text to `TextBlock` and awaits a call to `GetWordCountAsync`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们为 `StartButton` 创建一个异步的 `Click` 事件处理程序。这个按钮只是将一些文本写入 `TextBlock` 并等待对
    `GetWordCountAsync` 的调用。
- en: '[PRE63]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display the results as shown in the following screenshot:![How to do it…](img/0225OT_08_012.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你的应用程序应该显示如下截图所示的结果：![如何做到这一点…](img/0225OT_08_012.jpg)
- en: How it works…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This application was able to show the progress of its download by wiring up
    two events of the `WebClient` class: `DownloadProgressChanged` and `DownloadFileCompleted`.
    It then calls the `DownloadStringTaskAsync` method of `WebClient`, which triggers
    the events as the download progresses.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序能够通过连接 `WebClient` 类的两个事件：`DownloadProgressChanged` 和 `DownloadFileCompleted`
    来显示其下载进度。然后它调用 `WebClient` 的 `DownloadStringTaskAsync` 方法，随着下载的进行，该方法会触发这些事件。
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The event handler for `DownloadFileCompleted` is pretty self-explanatory. The
    event handler for `DownloadProgressChanged` is where the calculation of the progress
    actually happens. Each time the event fires, we get the number of bytes the `WebClient`
    has received, the total number of bytes to receive, and we calculate the percentage
    completed of the download. Finally, we set the `Value` property of `ProgressBar`
    with the results of the `percentage` calculation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadFileCompleted` 的事件处理程序相当直观。`DownloadProgressChanged` 的事件处理程序是实际进行进度计算的地方。每次事件触发时，我们都会得到
    `WebClient` 已接收的字节数、总字节数，并计算下载完成的百分比。最后，我们使用 `percentage` 计算的结果设置 `ProgressBar`
    的 `Value` 属性。'
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
