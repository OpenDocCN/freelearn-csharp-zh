<html><head></head><body>
		<div><h1 id="_idParaDest-200"><em class="italic"><a id="_idTextAnchor205"/>Chapter 11</em>: Benchmarking Relational Data Access Frameworks</h1>
			<p>Data is extensively used in all aspects of our daily lives. In today's world of big data, the volumes of data being collected and stored for all kinds of analysis are phenomenal. When working with data, performance can slow down exponentially as the size of your data grows. Depending upon how much data you have to process, the time factor is often critical. </p>
			<p>In a professional development environment, computer programmers don't always have access to the database server. Database server access is usually restricted for use by database developers and database administrators. With that in mind, this chapter is about benchmarking what code performs a database insert, update, read, and delete in the shortest possible time. In the <em class="italic">Further reading</em> section, there are links to documentation on database server performance that will help you to further improve the performance that you gain from working through this chapter.</p>
			<p>In this chapter, we will be benchmarking three different ways of manipulating SQL Server database data. We will be performing a side-by-side comparison of Entity Framework, ADO.NET, and Dapper. After running the benchmarks for each of these data access and object mappers, you will be able to make an educated judgment call on the best form of data access and object mapping for your projects.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><strong class="bold">Benchmarking data insertion methods</strong>: In this section, we write the benchmarks for inserting data with ADO.NET, Entity Framework Core, and Dapper.NET with and without using stored procedures.</li>
				<li><strong class="bold">Benchmarking data selection methods</strong>: In this section, we write the benchmarks for selecting data with ADO.NET, Entity Framework Core, and Dapper.NET with and without using stored procedures.</li>
				<li><strong class="bold">Benchmarking data editing methods</strong>: In this section, we write the benchmarks for applying updates to data with ADO.NET, Entity Framework Core, and Dapper.NET with and without using stored procedures.</li>
				<li><strong class="bold">Benchmarking data deletion methods</strong>: In this section, we write the benchmarks for deleting data with ADO.NET, Entity Framework Core, and Dapper.NET with and without using stored procedures.</li>
				<li><strong class="bold">The benchmarking results and their analysis</strong>: In this section, we run the benchmarks that we wrote in the previous sections. We then analyze the results of our benchmark results to conclude the best way to perform various efficient data access and manipulation tasks.</li>
			</ul>
			<p>After working through this chapter, you will have the skills needed to access and manipulate data with ADO.NET, Entity Framework, and Dapper.NET. You'll also be able to form your own judgment on which method of data access to use for your own projects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This chapter mainly involves you following along with writing a lot of code in preparation for running our data access benchmark methods in the last section. If you don't want to bother writing the code and just want to see the results, then jump to the last section of this chapter on the benchmarking results and their analysis. You can then jump to the areas of this chapter that are of most interest to you in helping you form your own opinions on the best data access methods for your needs. The source code is also available on GitHub to study for yourself.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor206"/>Technical requirements</h1>
			<p>To master the skills presented in this chapter, it will be useful to have access to the following: </p>
			<ul>
				<li>Visual Studio 2022 or higher</li>
				<li>SQL Server 2019 or higher</li>
				<li>SQL Server Management Student 2019 or higher</li>
				<li>The book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10</a><a href="https://github.com/PacktPublishing/Mastering-High-Performance-with-C-10.0-and-.NET-6&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor207"/>Benchmarking data insertion methods</h1>
			<p>In this section, we <a id="_idIndexMarker1083"/>will be following on from the work we did in <a href="B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189"><em class="italic">Chapter 10</em></a>, <em class="italic">Setting Up Our Database Project</em>, by writing methods that will benchmark the performance of insert methods using ADO.NET, Entity Framework Core, and Dapper.NET. So, if you have not read <a href="B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189"><em class="italic">Chapter 10</em></a><em class="italic">,</em> or looked at the source code, now would be a good time to do that.</p>
			<p>The benchmarks written in this chapter will be run and the results will be analyzed in the last section. To save space due to chapter and page constraints, I will be leaving out references to <code>using</code> statements. Therefore, you will need to use Visual Studio's quick tips for adding missing <code>using</code> statements. Follow these steps to write our insertion method benchmarks:</p>
			<ol>
				<li>Add the <code>BenchmarkDotNet</code> NuGet package.</li>
				<li>Open the <code>BenchmarkTests</code> class and modify it as follows:<pre>[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.Declared)]
[RankColumn]
public class BenchmarkTests
{
    [GlobalSetup]
    public void GlobalSetup()
    {
        InsertProductADNSP();
        InsertProductEFSP();
        InsertProductDDN();
}
}</pre></li>
			</ol>
			<p>We have set our class up to execute benchmarks and summarize them in the order that they are declared, as well as diagnosing the memory usage and providing a performance ranking of the benchmarking methods. Then, we provided <code>GlobalSetup</code>, which is run before the benchmarks. This is to provide our benchmarks with data to select, update, and delete.</p>
			<ol>
				<li value="3">Add <a id="_idIndexMarker1084"/>the <code>InsertProductADN</code> method:<pre>[Benchmark]
public void InsertProductADN()
{
    string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     AdoDotNetData adnData = new(connectionString);
    adnData.ExecuteNonQuery("INSERT INTO Products 
      (ProductName, CategoryID, SupplierId, 
         Discontinued) VALUES('ADO.NET Product', 1, 1, 
           0)");
    adnData.Dispose();
}</pre></li>
			</ol>
			<p>This method obtains the connection string from the secrets file and creates a new <code>AdoDotNetData</code> instance by passing the connection string into its constructor. It then calls the <code>ExecuteNonQuery</code> method, passing into the method a raw SQL insert method. Once the query is run, the instance is disposed of.</p>
			<ol>
				<li value="4">Add<a id="_idIndexMarker1085"/> the <code>InsertProductADNSP</code> method:<pre>[Benchmark]
public void InsertProductADNSP()
{
    string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     AdoDotNetData aaa = new(connectionString);
    SqlCommandModel model = new()
    {
        CommandText = "InsertProduct",
        CommandType = CommandType.StoredProcedure,
         CommandParameters = 
         new SqlCommandParameterModel[] {
         new SqlCommandParameterModel() {   
             ParameterName = "@ProductName", 
                 DataType = DbType.String,
                 Value = "Dapper Product Edited"
             }, 
             new SqlCommandParameterModel() {   
                 ParameterName = "@CategoryID",
                 DataType = DbType.Int32,
                 Value = 1 
             }
             , new SqlCommandParameterModel() { 
                 ParameterName = "@SupplierID",
                 DataType = DbType.Int32,
                 Value = 1
             }, new SqlCommandParameterModel() { 
                 ParameterName = "@Discontinued",   
                 DataType = DbType.Boolean,
                 Value = false
             }
         }
     };
     aaa.ExecuteNonQuery(model);
    aaa.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1086"/> obtains the connection string from the secrets file and passes the string into the constructor of the <code>AdoDotNetData</code> class. It then creates a new <code>SqlCommandModel</code> that builds the properties for a stored procedure insert operation on the products table. It then calls the <code>ExecuteNonQuery</code> method, passing in the model that will be used to generate and execute the stored procedure call. The <code>AdoDotNetData</code> class is then disposed of.</p>
			<ol>
				<li value="5">Add the <code>InsertProductEF</code> method:</li>
				<li>Add the <code>InsertProductEF</code> method:<pre>[Benchmark]
public void InsertProductEF()
{
string connectionString = SecretsManager
     .GetSecrets&lt;DatabaseSettings&gt;
     ("ConnectionString");
EntityFrameworkCoreData efData 
     = new(connectionString);
    Product product = new() { 
         ProductName = "EF Product", 
         CategoryID = 1, 
         SupplierID = 1,
         Discontinued = false,
           QuantityPerUnit = "1"
     };
    efData.Products.Add(product);
    efData.SaveChanges();
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1087"/>obtains the connection string from the secrets file and passes it into the constructor of the <code>EntityFrameworkCoreData</code> class. It then creates a new product and adds that product to the <code>Products</code> collection. The changes are then saved, and the <code>EntityFrameworkCoreData</code> class is disposed of.</p>
			<ol>
				<li value="7">Now, add the <code>InsertProductEFSP</code> method:<pre>[Benchmark]
public void InsertProductEFSP()
{
    string connectionString = SecretsManager.
         GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     EntityFrameworkCoreData efData 
         = new(connectionString);
     SqlCommandModel model = new()
     {
         CommandText = "EXEC InsertProduct 
           @ProductName = {0}, @CategoryID = {1},
              @SupplierID = {2}, @Discontinued = {3}",
         CommandType = CommandType.StoredProcedure,
        CommandParameters 
             = new SqlCommandParameterModel[] {
                 new SqlCommandParameterModel() { 
                 ParameterName = "@ProductName", 
                 DataType = DbType.String, 
                  Value = "EF Product Edited"
                 }
                , new SqlCommandParameterModel() { 
                 ParameterName = "@CategoryID", 
                 DataType = DbType.Int32, 
                 Value = 1 
                 }
                , new SqlCommandParameterModel() { 
                 ParameterName = "@SupplierID", 
                 DataType = DbType.Int32, 
                 Value = 1 
                 }
                 , new SqlCommandParameterModel() { 
                 ParameterName = "@Discontinued", 
                 DataType = DbType.Boolean, 
                 Value = false 
                 }
             }
        };
     efData.ExecuteNonQuerySP(model);
     efData.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1088"/> obtains the connection string from the secrets file and creates a new instance of the <code>EntityFrameworkCoreData</code> class. It then builds up the properties needed for the stored procedure insert via <code>SqlCommandModel</code>. Then, it executes the <code>ExecuteNonQuerySP</code> model, passing in the model that executes the insert stored procedure, and then disposes of the <code>EntityFrameworkCoreData</code> class.</p>
			<ol>
				<li value="8">Add the <code>InsertProductDDN</code> method:<pre>[Benchmark]
public void InsertProductDDN()
{
    string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     DapperDotNet ddnData = new(connectionString);
    int recordsAffected = ddnData
         .ExecuteNonQuery("INSERT INTO Products 
            (ProductName, CategoryID, SupplierId,
               Discontinued) VALUES('Dapper.NET 
                 Product', 1, 1, 0)");
     ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1089"/>obtains the connection string from the secrets file, creates a new instance of the <code>DapperDotNet</code> class, and executes a raw SQL insert statement by calling the <code>ExecuteNonQuery</code> method. It then disposes of the <code>DapperDotNet</code> class.</p>
			<ol>
				<li value="9">Add the <code>InsertProductDDNSP</code> method:<pre>[Benchmark]
public void InsertProductDDNSP()
{
     string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     DapperDotNet ddnData = new(connectionString);
     SqlCommandModel model = new() {
         CommandText = "InsertProduct",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
             = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                 ParameterName = "@ProductName", 
                 DataType = DbType.String, 
                 Value = "Dapper Product" }
                , new SqlCommandParameterModel() {
                 ParameterName = "@CategoryID", 
                 DataType = DbType.Int32, 
                 Value = 1 }
                 , new SqlCommandParameterModel() { 
                 ParameterName = "@SupplierID", 
                 DataType = DbType.Int32, 
                 Value = 1 }
                 , new SqlCommandParameterModel() { 
                 ParameterName = "@Discontinued", 
                 DataType = DbType.Boolean, 
                 Value = false }
             }
     };
     ddnData.ExecuteNonQuery(model);
     ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new <code>DapperDotNet</code> class. It then builds the <code>SqlCommandModel</code> properties required to execute the product insert stored procedure. Then, it calls the <code>ExecuteNonQuery</code> procedure, passing in the model that will execute the stored procedure. It then disposes of the <code>DapperDotNet</code> class.</p>
			<p>That concludes <a id="_idIndexMarker1090"/>our look at insert benchmarking methods. Now, we will start writing our selection benchmarking methods.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor208"/>Benchmarking data selection methods</h1>
			<p>In this section, we <a id="_idIndexMarker1091"/>will be writing our benchmarking methods that will test the performance of various data selection methods. These benchmarks will be run and analyzed in the last section of this chapter:</p>
			<ol>
				<li value="1">Add the <code>ReadScalarProductADN</code> method:<pre>[Benchmark]
public void ReadScalarProductADN()
{
     string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
              ("ConnectionString");
     AdoDotNetData adnData = new(connectionString);
     string productName = adnData
         .ExecuteScalar&lt;string&gt;("SELECT TOP 1 
            ProductName FROM Products  WHERE Product
              Name LIKE 'ADO.NET Product%'");
    adnData.Dispose();
}</pre></li>
			</ol>
			<p>This method obtains the connection from the <code>secrets</code> file, creates a new <code>AdoDotNetData</code> class, and executes the <code>ExecuteScalar</code> method, passing in a raw SQL statement that returns a string. It then disposes of the <code>AdoDotNet</code> class.</p>
			<ol>
				<li value="2">Add<a id="_idIndexMarker1092"/> the <code>ReadScalarADNSP</code> method:<pre>[Benchmark]
public void ReadScalarProductADNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    AdoDotNetData aaa = new(connectionString);
    SqlCommandModel model = new SqlCommandModel() {
        CommandText = "GetProductName",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
                Value = "ADO.NET Product" }
            }
    };
    string productName 
        = aaa.ExecuteScalar&lt;string&gt;(model);
    aaa.Dispose();
}</pre></li>
			</ol>
			<p>This method obtains the connection string from the secrets file and creates a new instance of the <code>AdoDotNetData</code> class. It then builds <code>SqlCommandModel</code> up that contains the necessary properties to execute the scalar stored procedure. Then, it calls the <code>ExecuteScalar</code> method, passing in the model that executes the stored procedure, and returns the product name. It then disposes<a id="_idIndexMarker1093"/> of the <code>AdoDotNetData</code> class.</p>
			<ol>
				<li value="3">Add the <code>ReadFilteredProductADN</code> method:<pre>[Benchmark]
public void ReadFilteredProductADN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
    AdoDotNetData adnData = new(connectionString);
    IEnumerator&lt;Product&gt; data 
        = adnData.ExecuteReader&lt;Product&gt;("SELECT * 
             FROM Products  WHERE ProductName LIKE 
                 'ADO.NET Product'");
    adnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>AdoDotNetData</code> class. It then executes the <code>ExecuteReader</code> method, which takes a raw SQL statement and returns an enumerator of the <code>Product</code> type, and then disposes of the <code>AdoDotNetData</code> class.</p>
			<ol>
				<li value="4">Add the <code>ReadFilteredProductADNSP</code> method:<pre>[Benchmark]
public void ReadFilteredProductADNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    AdoDotNetData aaa = new(connectionString);
    SqlCommandModel model = new SqlCommandModel() {
        CommandText = "FilterProducts",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
                Value = "ADO.NET Product" }
            }
     };
    var data = aaa.ExecuteReader&lt;dynamic&gt;(model);
    aaa.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>AdoDotNetData</code> class. It then builds up <code>SqlCommandModel</code> that contains the properties that are required to execute the read stored procedure. Then, it executes the <code>ExecuteReader</code> method, which returns an enumerator, and then disposes of the <code>AdoDotNetData</code> class.</p>
			<ol>
				<li value="5">Add <a id="_idIndexMarker1094"/>the <code>ReadScalarProductEF</code> method:<pre>[Benchmark]
public void ReadScalarProductEF()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
        = new(connectionString);
    string productName 
        = efData.Products.FirstOrDefault(
            p =&gt; p.ProductName
            .Contains("EF Product")
          ).ProductName;
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>EntityFrameworkCore</code> method. It then gets the first item in the <code>Product</code> collection that matches the filter and assigns <code>ProductName</code>. Then, it disposes of the <code>EntityFrameworkCore</code> class.</p>
			<ol>
				<li value="6">Add <code>ReadScalarProductEFSP</code>:<pre>[Benchmark]
public void ReadScalarProductEFSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
        = new(connectionString);
    string productName = efData
        .ExecuteScalarSP("EF Product");
     efData.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1095"/> gets the connection string from the secrets file and then creates a new instance of the <code>EntityFrameworkCoreData</code> class. Then, it calls the <code>ExecuteScalarSP</code> method, passing in the name of the filter, returning the first <code>ProductName</code> that matches the filter, and then disposes of the <code>EntityFrameworkCoreData</code> class.</p>
			<ol>
				<li value="7">Add the <code>ReadFilteredProductsEF</code> method:<pre>[Benchmark]
public void ReadFilteredProductsEF()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
        = new(connectionString);
    IEnumerator&lt;Product&gt; products = efData.Products
        .Where(p =&gt; p.ProductName
        .Contains("EF Product")).GetEnumerator();
    efData.Dispose();
        products.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and then creates an instance of the <code>EntityFrameworkCoreData</code> class. It then filters the products<a id="_idIndexMarker1096"/> and returns an enumerator of products. Then, the method disposes of the <code>EntityFrameworkCoreData</code> class and the enumerator.</p>
			<ol>
				<li value="8">Add the <code>ReadFilteredProductsEFSP</code> method:<pre>[Benchmark]
public void ReadFilteredProductsEFSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
        = new(connectionString);
    IEnumerator&lt;Product&gt; products = efData
        .ExecuteReaderSP("EF Product");
    efData.Dispose();
        products.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the secret from the secrets file and creates a new instance of the <code>EntityFrameworkCoreData</code> class. It then calls the <code>ExecuteReaderSP</code> method, which executes a stored procedure that returns an enumerator of the <code>Products</code> type. Then, the method disposes of the <code>EntityFrameworkCoreData</code> class and the enumerator.</p>
			<ol>
				<li value="9">Add <a id="_idIndexMarker1097"/>the <code>ReadScalarProductDDN</code> method:<pre>[Benchmark]
public void ReadScalarProductDDN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    string productName = ddnData
        .ExecuteScalar&lt;string&gt;("SELECT TOP 1 
             ProductName FROM Products  WHERE Product
                 Name LIKE 'Dapper.NET Product%'");
    ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>DapperDotNet</code> class. It then executes the <code>ExecuteScalar</code> method, passing in a raw SQL statement that returns the top <code>ProductName</code> that matches the filter. Then, it disposes of the <code>DapperDotNet</code> class.</p>
			<ol>
				<li value="10">Add<a id="_idIndexMarker1098"/> the <code>ReadScalarProductDDNSP</code> method:<pre>[Benchmark]
public void ReadScalarProductDDNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "GetProductName",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
                Value = "Dapper Product" }
             }
    };
    string productName 
         = ddnData.ExecuteScalarSP(model);
     ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>DapperDotNet</code> class. Then, the method builds <code>SqlCommandModel</code> that contains the properties necessary to execute a stored procedure. It then calls the <code>ExecuteScalarSP</code> method, passing in the model. The <code>ProductName</code> of the first matching product is returned. The method then disposes of the <code>DapperDotNet</code> class.</p>
			<ol>
				<li value="11">Add<a id="_idIndexMarker1099"/> the <code>ReadFilteredProductsDDN</code> class:<pre>[Benchmark]
public void ReadFilteredProductsDDN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    IEnumerator&lt;Product&gt; data 
        = ddnData.ExecuteReader&lt;Product&gt;("SELECT * 
        FROM Products WHERE ProductName LIKE
            'Dapper.NET Product%'");
     ddnData.Dispose();
     data.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the <code>secrets</code> file and then creates a new instance of the <code>DapperDotNet</code> class. It then calls the <code>ExecuteReader</code> method, passing in a raw SQL statement. An enumerator of the <code>Product</code> type is returned. <code>DapperDotNet</code> and the enumerator are then disposed of.</p>
			<ol>
				<li value="12">Add <a id="_idIndexMarker1100"/>the <code>ReadFilteredProductsDDNSP</code> method:<pre>[Benchmark]
public void ReadFilteredProductsDDNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "GetProductName",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
                Value = "Dapper.NET Product" }
            }
    };
    IEnumerator&lt;Product&gt; products 
        = ddnData.ExecuteReaderSP&lt;Product&gt;(model);
    ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and then creates an instance of the <code>DapperDotNet</code> class. It then builds up a <code>SqlCommandModel</code> that has the properties needed to execute a stored procedure. It then calls <code>ExcuteReaderSP</code>, passing in the model that returns an enumerator of the <code>Product</code> type.</p>
			<p>We have <a id="_idIndexMarker1101"/>now finished writing our selection benchmarks. Now, we'll move on to writing our update benchmarks.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor209"/>Benchmarking data editing methods</h1>
			<p>In this <a id="_idIndexMarker1102"/>section, we will be writing our benchmarks that test the performance of various update statements. These benchmarks will be run and analyzed in the final section of this chapter:</p>
			<ol>
				<li value="1">Add the <code>UpdateProductADN</code> method:<pre>[Benchmark]
public void UpdateProductADN()
{
     string connectionString = SecretsManager
         .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
     AdoDotNetData adnData = new(connectionString);
    int recordsAffected 
         = adnData.ExecuteNonQuery("UPDATE Products 
             SET ProductName = 'ADO.NET Product - 
                 Edited' WHERE ProductName = 
                     'ADO.NET Product'");
     adnData.Dispose();
}</pre></li>
			</ol>
			<p>This method obtains the <code>connection</code> string from the <code>secrets</code> file and then creates a new instance of the <code>AdoDotNetData</code> class. It then calls the <code>ExecuteNonQuery</code> product, passing in a raw SQL statement, then returns the number of records affected and disposes of the <code>AdoDotNetData</code> class.</p>
			<ol>
				<li value="2">Add <a id="_idIndexMarker1103"/>the <code>UpdateProductADNSP</code> method:<pre>[Benchmark]
public void UpdateProductADNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    AdoDotNetData aaa = new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "UpdateProductName",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@OldProductName",
                DataType = DbType.String, 
                Value = "ADO.NET Product" }
                , new SqlCommandParameterModel() { 
                ParameterName = "@NewProductName", 
                DataType = DbType.String, 
                Value = "ADO.NET Product - Edited"}
                }
     };
     aaa.ExecuteNonQuery(model);
    aaa.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>AdoDotNetData</code> class. <code>SqlCommandModel</code> is then built up with the properties needed to execute the update stored procedure. <code>ExecuteNonQuery</code> is then called with the model being passed in, and the stored procedure that performs the update is executed. The <code>AdoDotNetData</code> class is <a id="_idIndexMarker1104"/>then disposed of.</p>
			<ol>
				<li value="3">Add the <code>UpdateProductEF</code> method:<pre>[Benchmark]
public void UpdateProductEF()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
    = new EntityFrameworkCoreData(connectionString);
    IQueryable&lt;Product&gt; products = efData.Products
    .Where(p =&gt; p.ProductName.Contains("EF 
        Product"));
    foreach (Product product in products)
        product.ProductName = "EF Product Edited";
    efData.Products.UpdateRange(products);
     int recordsAffected = efData.SaveChanges();
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>EntityFrameworkCoreData</code> class. It then declares and assigns a queryable collection of products. This collection is then iterated with the name of each product updated. The <code>UpdateRange</code> method is then called on the <code>Products</code> collection, and the updated collection is passed in. The modifications are then saved, and the <code>EntityFrameworkCoreData</code> class is disposed of.</p>
			<ol>
				<li value="4">Add<a id="_idIndexMarker1105"/> the <code>UpdateProductEFSP</code> method:<pre>[Benchmark]
public void UpdateProductEFSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
             ("ConnectionString");
    EntityFrameworkCoreData efData = 
        new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "EXEC UpdateProductName 
             @OldProductName = {0}, @NewProductName = 
                 {1}",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@OldProductName",
                DataType = DbType.String, 
                Value = "EF Product" }
                , new SqlCommandParameterModel() {  
                ParameterName = "@NewProductName", 
                DataType = DbType.String, 
                Value = "EF Product - Edited" }
                }
     };
    efData.ExecuteNonQuerySP(model);
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker1106"/>method gets the connection string from the <code>secrets</code> file and creates an instance of the <code>EntityFrameworkCoreData</code> class. It then builds up the <code>SqlCommandModel</code> that contains the properties needed to generate the call to the update stored procedure. The method then calls the <code>ExecuteNonQuerySP</code> procedure, which executes the stored procedure, passing in the model, and then disposes of the <code>EntityFrameworkCoreData</code> method.</p>
			<ol>
				<li value="5">Add the <code>UpdateProductDDN</code> method:<pre>[Benchmark]
public void UpdateProductDDN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    int recordsAffected 
        = ddnData.ExecuteNonQuery("UPDATE Products 
           SET ProductName = 'Dapper.NET Product - 
             Edited' WHERE ProductName = 'Dapper.NET 
               Product'");
    ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file and creates a new instance of the <code>DapperDotNet</code> class. It then calls the <code>ExecuteNonQuery</code> method, passing<a id="_idIndexMarker1107"/> in a raw SQL update statement. The number of records affected is returned, and the <code>DapperDotNet</code> class is disposed of.</p>
			<ol>
				<li value="6">Add the <code>UpdateProductDDNSP</code> method:<pre>[Benchmark]
public void UpdateProductDDNSP()
{
string connectionString = SecretsManager
    .GetSecrets&lt;DatabaseSettings&gt;("ConnectionString");
DapperDotNet ddnData = new(connectionString);
SqlCommandModel model = new()
{
     CommandText = "UpdateProductName",
     CommandType = CommandType.StoredProcedure,
    CommandParameters = new SqlCommand
        ParameterModel[]{
        new SqlCommandParameterModel() { 
            ParameterName = "@OldProductName", 
            DataType = DbType.String,
            Value = "Dapper.NET Product - Edited" }
        , new SqlCommandParameterModel() { 
              ParameterName = "@NewProductName",
            DataType = DbType.String,
            Value = "Dapper.NET Product" }
    }
};
ddnData.ExecuteNonQuery(model);
ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1108"/> gets the connection string from the secrets file and creates a new instance of the <code>DapperDotNet</code> class. It then builds an <code>SQLCommandModel</code> in preparation for executing a stored procedure. It calls the <code>ExecuteNonQuery</code> method, passing in the model. The stored procedure is executed, and the method disposes of the <code>DapperDotNet</code> class.</p>
			<p>This is the end of our look at the update benchmarks. Now for our final set of benchmark methods. In the next section, we will write our deletion benchmarks.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor210"/>Benchmarking data deletion methods</h1>
			<p>In this section, we <a id="_idIndexMarker1109"/>write our benchmarks for measuring the performance of our deletion methods. These benchmarks will be run and analyzed in the next section:</p>
			<ol>
				<li value="1">Add the <code>DeleteProductADN</code> method:<pre>[Benchmark]
public void DeleteProductADN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    AdoDotNetData adnData = new(connectionString);
    int recordsAffected 
        = adnData.ExecuteNonQuery("DELETE FROM 
           Products WHERE ProductName LIKE 'ADO.NET 
             Product%'");
    adnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets the connection string from the secrets file. It then creates an instance of the <code>AdoDotNetData</code> class. Then, the method calls the <code>ExecuteNonQuery</code> method, passing into it a raw SQL delete statement. It then disposes of the <code>AdoDotNetData</code> class.</p>
			<ol>
				<li value="2">Add the <code>DeleteProductADNSP</code> method:<pre>[Benchmark]
public void DeleteProductADNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    AdoDotNetData aaa = new(connectionString);
    SqlCommandModel model = new()
    {
        CommandText = "DeleteProduct",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
                Value = "ADO.NET Product - Edited"}
            }
    };
    aaa.ExecuteNonQuery(model);
    aaa.Dispose();
}</pre></li>
			</ol>
			<p>This method gets <a id="_idIndexMarker1110"/>the connection string from the secrets file, and then it creates an instance of the <code>AdoDotNetData</code> class. <code>SqlCommandModel</code> is built up with the properties required for the delete stored procedure execution. The model is then passed into the <code>ExecuteNonQuery</code> model, which executes the stored procedure, and the <code>AdoDotNetData</code> class is then disposed of.</p>
			<ol>
				<li value="3">Add the <code>DeleteProductEF</code> method:<pre>[Benchmark]
public void DeleteProductEF()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
    = new EntityFrameworkCoreData(connectionString);
    IQueryable&lt;Product&gt; products = efData.Products
    .Where(p =&gt; p.ProductName.Contains("EF Product"));
    efData.Products.RemoveRange(products);
    int recordsAffected = efData.SaveChanges();
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1111"/> gets the connection string from the secrets file and then creates an instance of the <code>EntityFrameworkCoreData</code> class. A queryable collection of products is then returned, matching the deletion criteria. This collection is then passed into the <code>RemoveRange</code> method of the <code>Products</code> collection, and the modification is saved with those items removed from the database. The method then disposes of the <code>EntityFrameworkCoreData</code> class.</p>
			<ol>
				<li value="4">Add the <code>DeleteProductEFSP</code> method:<pre>[Benchmark]
public void DeleteProductEFSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    EntityFrameworkCoreData efData 
        = new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "EXEC DeleteProduct @ProductName 
            = {0}",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@NewProductName", 
                DataType = DbType.String, 
                Value = "EF Product - Edited" }
                }
    };
    efData.ExecuteNonQuerySP(model);
    efData.Dispose();
}</pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker1112"/> gets the connection string from the secrets file and creates an instance of the <code>EntityFrameworkCoreData</code> class. It then builds up a <code>SqlCommandModel</code> that contains the properties of the deletion stored procedure. The <code>ExecuteNonQuerySP</code> method is called with the model that is passed in, the deletion stored procedure is executed, and the <code>EntityFrameworkCoreData</code> class is disposed of.</p>
			<ol>
				<li value="5">Add the <code>DeleteProductDDN</code> method:<pre>[Benchmark]
public void DeleteProductDDN()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    int recordsAffected 
        = ddnData.ExecuteNonQuery("DELETE FROM 
             Products WHERE ProductName LIKE
                'Dapper.NET Product%'");
    ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This<a id="_idIndexMarker1113"/> method gets the connection string from the secrets file and creates an instance of the <code>DapperDotNet</code> class. It then calls the <code>ExecuteNonQuery</code> method, passing into that method a raw SQL delete statement. The deletion is carried out and the number of records affected is returned. The <code>DapperDotNet</code> class is then disposed of.</p>
			<ol>
				<li value="6">Add the <code>DeleteProductDDNSP</code> method:<pre>[Benchmark]
public void DeleteProductDDNSP()
{
    string connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;
            ("ConnectionString");
    DapperDotNet ddnData = new(connectionString);
    SqlCommandModel model = new() {
        CommandText = "DeleteProduct",
        CommandType = CommandType.StoredProcedure,
        CommandParameters 
            = new SqlCommandParameterModel[] {
                new SqlCommandParameterModel() { 
                ParameterName = "@ProductName", 
                DataType = DbType.String, 
               Value = "Dapper.NET Product - Edited" }
            }
    };
    ddnData.ExecuteNonQuery(model);
    ddnData.Dispose();
}</pre></li>
			</ol>
			<p>This method gets<a id="_idIndexMarker1114"/> the connection string from the secrets file and creates an instance of the <code>DapperDotNet</code> class. It then builds up the <code>SqlCommandModel</code>, containing stored procedure properties. This model is then passed into the <code>ExecuteNonQuery</code> method, which executes the stored procedure, and the <code>DapperDotNet</code> class is disposed of.</p>
			<p>That was the last of our benchmarking methods. There is just one more job to do before we are able to run our benchmarks. Update the <code>Program</code> class as follows:</p>
			<pre class="source-code">using BenchmarkDotNet.Running;</pre>
			<pre class="source-code">class Program</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">static void Main(string[] args)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        BenchmarkRunner.Run&lt;BenchmarkTests&gt;();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>The <code>Main</code> method executes the <code>BenchmarkTests</code> class. You can now do a release build to run the benchmarks. The program will take a while to execute, so you will need to be patient. In the next section, we will analyze the results of our various benchmarks to find out the <a id="_idIndexMarker1115"/>most performant ways of performing inserts, selections, updates, and deletions.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor211"/>The benchmarking results and their analysis</h1>
			<p>Before we analyze the <a id="_idIndexMarker1116"/>results, it is worth noting some big data statistics from 2020. Google gets more than 40,000 queries per second. This equates to 3,456,000,000 queries per day. There are 65,000,000,000 WhatsApp business app messages sent per day. In the course of 24 hours, there are 1,440 minutes, which is 86,400 seconds, which is 86,400,000 milliseconds.</p>
			<p>Here is our benchmark summary report:</p>
			<div><div><img src="img/B16617_11_01.jpg" alt="Figure 11.1 – Data access benchmark summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Data access benchmark summary</p>
			<p>Let's discuss the<a id="_idIndexMarker1117"/> insert statements first. The results are as follows:</p>
			<ul>
				<li><code>InsertProductDDNSP</code> = 1.841 ms</li>
				<li><code>InsertProductADNSP</code> = 1.894 ms</li>
				<li><code>InsertProductDDN</code> = 2.058 ms</li>
				<li><code>InsertProductADN</code> = 2.092 ms</li>
				<li><code>InsertProductEF</code> = 2.196 ms</li>
				<li><code>InsertProductEFSP</code> = 396.509 ms</li>
			</ul>
			<p>From the summary, we can see that the best-performing insert statement is the Dapper.NET stored procedure insert, taking approximately 1.841 ms to execute, followed by <code>InsertProductADNSP</code>, which takes approximately 1.894 ms to execute. By far the worst performer is the <code>InsertProductEFSP</code> method, which takes 396.509 ms to execute. As we can see from these methods, even though we have six different ways of inserting data, they all perform at different speeds. When performance is a serious issue, your best option is to use Dapper.NET stored procedure execution or ADO.NET stored procedure execution when inserting data.</p>
			<p>We will now look at<a id="_idIndexMarker1118"/> scalar operations, starting with an ordered list of method performance:</p>
			<ul>
				<li><code>ReadScalarProductDDN</code> = 1.403 ms</li>
				<li><code>ReadScalarProductADN</code> = 1.407 ms</li>
				<li><code>ReadScalarProductADNSP</code> = 1.433 ms</li>
				<li><code>ReadScalarProductDDNSP</code> = 1.514 ms</li>
				<li><code>ReadScalarProductEFSP</code> = 53.235 ms</li>
				<li><code>ReadScalarProductEF</code> = 396.509 ms</li>
			</ul>
			<p>Looking at these results, the Dapper.NET raw SQL execution takes approximately 1.403 ms, followed by the ADO.NET raw SQL execution at 1.407 ms. Both the Entity Framework Core methods perform much more slowly. So, when performance matters, you are best off using Dapper.NET or ADO.NET raw SQL queries to obtain scalar values.</p>
			<p>Next are the filtered list queries. Here is an ordered list of the results:</p>
			<ul>
				<li><code>ReadFilteredProductsADNSP</code> = 1.078 ms</li>
				<li><code>ReadFilteredProductsADN</code> = 1.084 ms</li>
				<li><code>ReadFilteredProductsEFSP</code> = 1.187 ms</li>
				<li><code>ReadFilteredProductsEF</code> = 1.305 ms</li>
				<li><code>ReadFilteredProductsDDNSP</code> = 1.529 ms</li>
				<li><code>ReadFilteredProductsDDN</code> = 199.910 ms</li>
			</ul>
			<p>As we can see from these results, ADO.NET raw SQL and stored procedure access perform the best at 1.078 ms and 1.084 ms, respectively. Surprisingly, this time it is Dapper.NET that performs the worst when it comes to raw SQL and stored procedure access. So, when performance matters for performing queries that return multiple records, you are best off using ADO.NET.</p>
			<p>Now, we turn our attention to performing updates. Here is an ordered list of our results:</p>
			<ul>
				<li><code>UpdateProductADNSP</code> = 1.562 ms</li>
				<li><code>UpdateProductEFSP</code> = 1.964 ms</li>
				<li><code>UpdateProductDDNSP</code> = 1.891 ms</li>
				<li><code>UpdateProductDDN</code> = 2.297 ms</li>
				<li><code>UpdateProductADN</code> = 3.583 ms</li>
				<li><code>UpdateProductEF</code> = 5,304.279 ms</li>
			</ul>
			<p>From these results, <strong class="bold">the clear winner is the ADO.NET stored procedure access at</strong> <strong class="bold">1.562 ms</strong>. The<a id="_idIndexMarker1119"/> worst performer is the Entity Framework Core update method. When performance matters, use ADO.NET stored procedures to update database records.</p>
			<p>Finally, we'll look at our deletion benchmarks. Here is an ordered list of our results:</p>
			<ul>
				<li><code>DeleteProductADNSP</code> = 1.760 ms</li>
				<li><code>DeleteProductDDNSP</code> = 1.863 ms</li>
				<li><code>DeleteProductEFSP</code> = 2.012 ms</li>
				<li><code>DeleteProductDDN</code> = 2.522 ms</li>
				<li><code>DeleteProductADN</code> = 6.263 ms</li>
				<li><code>DeleteProductEF</code> = 386.716 ms</li>
			</ul>
			<p>It can be seen that the worst performer is the Entity Framework Core method, taking about 386.716 ms to execute. On the other hand, the best performer is the ADO.NET stored procedure method, which takes only 1.760 ms, with the Dapper.NET stored procedure next, taking 1.863 ms. So, when performance matters, your best deletion strategy is to use ADO.NET stored procedures.</p>
			<p>What can we summarize from these results?</p>
			<p>Dapper.NET and ADO.NET come out on top when performing insert, read, update, and delete operations. The performance varies between raw SQL and stored procedure execution. When performance is critical, it would seem that the best strategy is rather than choosing just one framework and using only that one for all your data operations, to use a hybrid approach.</p>
			<p>With a hybrid approach to data access, you will use a combination of data access frameworks. From each framework, you will decide on the best performer and use that for your data operation. In the case of our benchmarks, we would use two frameworks. The frameworks chosen are ADO.NET and Dapper.NET. This way, we could find the best performance possible for each type of data operation.</p>
			<p>But given that these times only have millisecond differences, why does such performance matter?</p>
			<p>Well, remember at the beginning of this section how we mentioned the big data statistics<a id="_idIndexMarker1120"/> for 2020? The following table shows the performance of these methods when put into the context of big data search queries and app message storage:</p>
			<div><div><img src="img/Table_10.1.jpg" alt="Table 10.1 – Big data operation durations if SQL Server were used to store and read data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1 – Big data operation durations if SQL Server were used to store and read data</p>
			<p>These benchmarks were run on an HP laptop with an Intel Core i5-6300U CPU 2.40 GHz (Skylake) processor. This is one CPU with four logical cores and two physical cores. I have 8 GB of RAM and a 256 GB SSD.</p>
			<p>If the SQL Server on my laptop were used and I had the space available (which I don't) to store the WhatsApp business app message data, depending upon which method I used to insert the data, it <a id="_idIndexMarker1121"/>would take between 1,385.01157 and 298,299.595 processing days on my laptop. If my laptop were used to retrieve Google search results from my SQL Server, then it would take between 43.12 and 7,996.4 processing days to retrieve those results.</p>
			<p>This real-life application of the benchmarks to actual big data volumes based on the big data statistics of 2020 shows the importance of computer infrastructure and the type of investment that would be needed to make these searches and message sending and receiving instantaneous. It was important to have peak performance when working with such large datasets.</p>
			<p>Tweaking large datasets through code can only go so far. That is why server computers have many more processors and disks, along with more memory, than your normal day-to-day workstations and home computers.</p>
			<p>The key thing to take away from this chapter is that whenever you are deciding on a way forward to maximize performance, experiment and benchmark. Along with that, take the time to choose your physical infrastructure carefully.</p>
			<p>Another thing to bear in mind when using a cloud host is the cost per data execution and cost per hour when running virtual machines. Then, there is the cost of data throughput and data storage saving and retrieval. With figures of apps such as Google and WhatsApp being in the billions, if you were to be that successful, could you imagine the running costs involved? That is why performance in today's competitive market is also so important. The quicker a piece of code executes in the cloud, the cheaper the price. The longer a piece of code takes to run, the more expensive it becomes.</p>
			<p>As an example, if you have an Azure function that performs your data operations that are located in the West US region on the Consumption tier using a memory size of 128 with an execution time of 1.078 ms and 65,000,000,000 executions per month, then your bill for the month would be US$13,133.54. But if your execution time was 396.509 ms, then your bill for the month would be US$64,539.57. So, doing the same code action can mean a difference of 64,539.57 – 12,133.54 = US$52,406.03 per month on cloud expenditure operations. I am sure you would not want to spend that much money on such outgoings, and<a id="_idIndexMarker1122"/> that does not even include the cost of the SQL Server instances!</p>
			<p>That concludes this rather long chapter, and so we will now summarize what we have learned.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we learned how to perform inserts, selections, updates, and deletes in SQL Server. We learned how to perform these operations in different ways using pure ADO.NET, Entity Framework Core, and Dapper.NET. The different data operations were performed using raw SQL and stored procedures.</p>
			<p>To understand the performance of each of these data access methods of the different data access frameworks, in this chapter, we benchmarked their runtime performance using <code>BenchmarkDotNet</code>. We saw that both Dapper.NET and ADO.NET performed better than Entity Framework Core in most cases and that even with these two frameworks, the performance varied considerably.</p>
			<p>We concluded that rather than just adopting a single data access technology, in some situations where performance really matters, it could be beneficial to employ a hybrid approach to data access. With a hybrid approach, you use the best framework and method within that framework for the data access task in question. That way, you maximize your overall performance. This can also be critical in terms of keeping your infrastructure expenses down, especially when the infrastructure you are employing is a third-party cloud provider with your monthly bill being in the thousands of dollars.</p>
			<p>But apart from computer code performance enhancements, we also studied big data volumes and calculated the number of processing days it would take to perform query and data insert operations when the volumes involved are in the billions. So, apart from code performance, we also came to understand that it is necessary to choose the right kind of infrastructure, which also comes at a price when using cloud services.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whatever you are doing, whenever performance is a critical business requirement, you are strongly advised to experiment and provide your own benchmarks. Based on your results, you can then choose your own methods of data access that you feel are most beneficial for your needs.</p>
			<p>In the next chapter, we will be looking at improving the performance of SQL Server and Cosmos DB. But before we do, have a go at the following questions to see how well you have retained the information contained in this chapter. Also, there are very useful articles in the <em class="italic">Further reading</em> section that expand upon what has been covered in this chapter. This chapter purely focused on identifying the best data access methods in code using three different frameworks. But in the <em class="italic">Further reading</em> section, you will find topics that are specific to improving database performance that are well worth reading about.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor213"/>Questions</h1>
			<ol>
				<li value="1">Which data access method was fastest when inserting data?</li>
				<li>Which data access method was fastest when selecting a scalar value?</li>
				<li>Which data access method was fastest when selecting multiple records?</li>
				<li>Which data access method was fastest when updating data?</li>
				<li>Which data access method was fastest when deleting data?</li>
				<li>Should you use one framework for all data access operations and why?</li>
			</ol>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor214"/>Further reading</h1>
			<ul>
				<li><em class="italic">Dapper vs Entity Framework vs ADO.NET Performance Benchmarking</em>: <a href="https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/&#13;">https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/</a></li>
				<li>Dapper tutorial: <a href="https://dapper-tutorial.net/dapper&#13;">https://dapper-tutorial.net/dapper</a></li>
				<li><em class="italic">ADO.NET Tutorial for Beginners and Professionals</em>: <a href="https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/&#13;">https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/</a></li>
				<li><em class="italic">SQL Server Database Performance Tuning</em>: <a href="https://www.brentozar.com/sql/sql-server-performance-tuning/&#13;">https://www.brentozar.com/sql/sql-server-performance-tuning/</a></li>
				<li>Book – <em class="italic">High Performance SQL Server: Consistent Response for Mission-Critical Applications</em> by Benjamin Nevarez: <a href="https://amzn.to/3gnUbe7&#13;">https://amzn.to/3gnUbe7</a></li>
				<li><em class="italic">Performance tips for Azure Cosmos DB and .NET</em>: <a href="https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql&#13;">https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql</a></li>
				<li><em class="italic">A technique for building high-performance databases with EF Core</em>: <a href="https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/&#13;">https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/</a></li>
				<li><em class="italic">How to improve SQL Server query performance in .NET</em>: <a href="https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net">https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net</a></li>
				<li><em class="italic">Using Dapper and SQLKata in .NET Core for High-Performance Application</em>: <a href="https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210&#13;">https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210</a></li>
				<li><em class="italic">What are the best databases for a small .NET application?</em>: <a href="https://www.slant.co/topics/274/~best-databases-for-a-small-net-application&#13;">https://www.slant.co/topics/274/~best-databases-for-a-small-net-application</a><p class="callout-heading">Point to Remember</p><p class="callout">Reading about performance in a book is all very good. But you should always do your own experimentation and benchmarking if performance is very important to you. Different hardware architecture and different programming styles will yield very different results, and this point is well worth remembering. Network usage, security software, and data volumes, along with file input and output, can all have an effect on the performance of your application.</p></li>
			</ul>
		</div>
	</body></html>