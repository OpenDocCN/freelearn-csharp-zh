- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: MVVM for Maintainability and Testability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM的可维护性和可测试性
- en: When building XAML-based applications, one of the most important design patterns
    to learn is the MVVM pattern. MVVM provides a clear separation of concerns between
    the XAML markup in the view and the C# code in the View Model using data binding.
    With this separation comes ease of maintenance and testability. The View Model
    classes can be tested without taking a dependency on the underlying **User Interface**
    (**UI**) platform. For large teams, another benefit of this separation is that
    changing the XAML enables UI designers to work on the UI independently of developers
    who specialize in writing the business logic and the backend of the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建基于XAML的应用程序时，最重要的设计模式之一就是MVVM模式。MVVM通过数据绑定在视图的XAML标记和视图模型的C#代码之间提供清晰的关注点分离。这种分离带来了易于维护和可测试性。视图模型类可以在不依赖于底层**用户界面**（UI）平台的情况下进行测试。对于大型团队来说，这种分离的另一个好处是，更改XAML使得UI设计师可以独立于专注于编写业务逻辑和应用程序后端的开发者工作。
- en: 'In this chapter, you will learn about the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下概念：
- en: Fundamentals of the MVVM design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM设计模式的基础
- en: Popular MVVM frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的MVVM框架
- en: Implementing MVVM in WinUI applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WinUI应用程序中实现MVVM
- en: Handling View Model changes in the view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中处理视图模型更改
- en: Event handling in MVVM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM中的事件处理
- en: Streamline View Model implementations with the MVVM Toolkit
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVVM Toolkit简化视图模型实现
- en: By the end of the chapter, you will understand the basics of the MVVM design
    pattern, have some familiarity with some popular MVVM frameworks available to
    developers, and know how to implement MVVM in a WinUI application. We will wrap
    up by getting hands-on with the open source **MVVM Toolkit**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解MVVM设计模式的基础，对一些流行的MVVM框架有一些了解，并知道如何在WinUI应用程序中实现MVVM。我们将通过实际操作开源的**MVVM
    Toolkit**来结束本章。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the examples in this chapter, please refer to the *Technical
    requirements* section of [*Chapter 2*](B20908_02.xhtml#_idTextAnchor044), *Configuring
    the Development Environment and Creating* *the Project*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，请参阅[*第2章*](B20908_02.xhtml#_idTextAnchor044)的*技术要求*部分，*配置开发环境并创建*
    *项目*。
- en: 'You will find the code files of this chapter here: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的代码文件：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03)
- en: Understanding MVVM
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MVVM
- en: MVVM was introduced by Microsoft in 2005 and gained popularity with developers
    following the launch of **Windows Presentation Foundation** (**WPF**) and **Silverlight**
    because it lends itself so well to building applications with XAML. It is like
    the **Presentation Model** pattern, which was created by Martin Fowler – one of
    the most influential proponents of design patterns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM于2005年由微软引入，随着**Windows Presentation Foundation**（WPF）和**Silverlight**的发布而受到开发者的欢迎，因为它非常适合构建XAML应用程序。它类似于由Martin
    Fowler创建的**展示模型**模式，他是设计模式最有影响力的倡导者之一。
- en: 'The MVVM pattern consists of the following three layers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式由以下三个层组成：
- en: '**Model**: The Model layer contains the application’s business logic and should
    perform all the data access operations. The View Model communicates with the Model
    to retrieve and save the application’s data.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型层包含应用程序的业务逻辑，应执行所有数据访问操作。视图模型与模型通信以检索和保存应用程序的数据。'
- en: '**View**: The View layer is only responsible for the presentation of data in
    the application. The layout or structure is defined here, along with style definitions.
    This is the layer responsible for interacting with the user and receiving input
    events and data. The View is aware of the View Model only through data-binding
    expressions.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图层仅负责在应用程序中展示数据。布局或结构在这里定义，以及样式定义。这是负责与用户交互、接收输入事件和数据的那一层。视图通过数据绑定表达式仅了解视图模型。'
- en: '**ViewModel**: The View Model (or ViewModel) layer is responsible for maintaining
    the state of data for the View. It has a set of properties that provide data to
    the View through data binding and a set of commands invoked by the View in response
    to user input events. View Model classes have no knowledge of their corresponding
    Views.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：视图模型（或 ViewModel）层负责维护视图的数据状态。它有一组属性，通过数据绑定向视图提供数据，以及一组由视图在响应用户输入事件时调用的命令。视图模型类对其对应的视图没有了解。'
- en: MVVM – the big picture
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM – 整体架构
- en: 'Let’s look at how the components of MVVM fit into the overall architecture
    of an application implementing the pattern, depicted in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 MVVM 的组件如何适应实现该模式的整体应用程序架构，以下图所示：
- en: '![Figure 3.1 – The MVVM pattern in use](img/B20908_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 使用中的 MVVM 模式](img/B20908_03_01.jpg)'
- en: Figure 3.1 – The MVVM pattern in use
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 使用中的 MVVM 模式
- en: 'In *Figure 3**.1*, you can see a representation of the MVVM pattern along with
    other parts of the application: services, data, and unit tests. The arrows in
    the diagram represent dependencies, not the data flow. You can imagine that data
    would need to move both ways along most of these pathways to create a functional
    application.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.1* 中，你可以看到 MVVM 模式的表示以及应用程序的其他部分：服务、数据和单元测试。图中的箭头表示依赖关系，而不是数据流。你可以想象，数据需要沿着这些路径的大部分双向移动，以创建一个功能性的应用程序。
- en: As with many design patterns, the MVVM pattern is meant to be a guide for developers
    to create reliable, maintainable applications. However, not all developers implement
    the pattern in the same way. The differences usually lie in the implementation
    of the model. Some developers will create a domain model in the **Domain-Driven
    Design** (**DDD**) style. This makes sense for large applications with complex
    business logic. For simpler applications, the model may only be a simple data
    access layer, residing either on the client or behind a service layer. In some
    of these cases, the **Services** cloud in the preceding diagram would move between
    the View Model and Model layers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多设计模式一样，MVVM 模式旨在为开发者提供创建可靠、可维护应用程序的指南。然而，并非所有开发者都以相同的方式实现该模式。差异通常在于模型的实现。一些开发者会以
    **领域驱动设计** (**DDD**) 风格创建领域模型。这对于具有复杂业务逻辑的大型应用程序是有意义的。对于更简单的应用程序，模型可能只是一个简单的数据访问层，位于客户端或服务层之后。在这些情况中，前图中
    **服务** 云会在视图模型和模型层之间移动。
- en: The point of MVVM is to help guide you in building the best app for your users.
    As you gain experience with MVVM and WinUI, you will find the right implementation
    for your applications. A good way to get started is to find some frameworks that
    make it easier to work with MVVM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 的目的是帮助你构建最适合用户的应用程序。随着你对 MVVM 和 WinUI 的经验积累，你将找到适合你应用程序的正确实现方式。一个不错的开始是找到一些使与
    MVVM 一起工作变得更简单的框架。
- en: MVVM libraries for WinUI
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinUI 的 MVVM 库
- en: When working with MVVM in WinUI applications, you must create a little infrastructure
    code to facilitate data binding between Views and View Models. You can either
    write this yourself or choose a framework that abstracts this plumbing code away
    from your application. Although we will start by writing our own plumbing code
    for the application in the next section, let’s review some popular MVVM frameworks
    for WinUI.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WinUI 应用程序中使用 MVVM 时，你必须创建一些基础设施代码来促进视图和视图模型之间的数据绑定。你可以自己编写这些代码，或者选择一个将这种管道代码从你的应用程序中抽象出来的框架。虽然我们将在下一节中编写应用程序的管道代码，但让我们回顾一些流行的
    WinUI MVVM 框架。
- en: The MVVM Toolkit
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 工具包
- en: We will discuss the `CommunityToolkit.Mvvm` **NuGet package** through the **NuGet
    Package Manager** in Visual Studio or view its details on the NuGet website, at
    [https://www.nuget.org/packages/CommunityToolkit.Mvvm/](https://www.nuget.org/packages/CommunityToolkit.Mvvm/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Visual Studio 中的 **NuGet 包管理器** 讨论通过 `CommunityToolkit.Mvvm` **NuGet 包**，或者在
    NuGet 网站上查看其详细信息，网址为 [https://www.nuget.org/packages/CommunityToolkit.Mvvm/](https://www.nuget.org/packages/CommunityToolkit.Mvvm/)。
- en: The library includes base classes to support `INotifyPropertyChanged`, `IMessenger`,
    and `ICommand`. It also includes other messaging and **Inversion of Control**
    (**IoC**) helper classes. In addition, the latest versions of the MVVM Toolkit
    use **Roslyn source generators** to reduce the amount of boilerplate code developers
    need to write.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包括支持 `INotifyPropertyChanged`、`IMessenger` 和 `ICommand` 的基类。它还包括其他消息和 **控制反转**
    (**IoC**) 辅助类。此外，MVVM Toolkit 的最新版本使用 **Roslyn 源生成器** 来减少开发者需要编写的样板代码量。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are unfamiliar with Roslyn, it is the code name of the **.NET Compiler
    Platform**. It was first **released to manufacturing** (**RTM**) with Visual Studio
    2015, and it is the current compiler for the C# and VB.NET languages. Roslyn’s
    extensibility, via the .NET Compiler Platform SDK, allows developers to create
    things such as custom source generators and source code analyzers for Visual Studio.
    For more information about the platform, you can check out the documentation on
    Microsoft Learn: [https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/](https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Roslyn，它是 **.NET 编译器平台** 的代码名称。它首次与 Visual Studio 2015 一起 **发布到制造**（**RTM**），并且是
    C# 和 VB.NET 语言的当前编译器。Roslyn 通过 .NET 编译器平台 SDK 的可扩展性允许开发者创建诸如自定义源生成器和 Visual Studio
    的源代码分析器等工具。有关该平台的信息，您可以查看 Microsoft Learn 上的文档：[https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/](https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/)。
- en: Later in the chapter, after you have learned how to implement your own MVVM
    base class, we will leverage the MVVM Toolkit in our sample application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，在您学习了如何实现自己的 MVVM 基类之后，我们将在我们的示例应用程序中利用 MVVM Toolkit。
- en: The Prism Library
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prism 库
- en: '**Prism** started out as a library created and maintained by Microsoft. It
    was part of the **Patterns & Practices** guidance, reference architectures, and
    libraries that Microsoft’s developer division used to maintain.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prism** 最初是由 Microsoft 创建和维护的库。它是 Microsoft 开发者部门用于维护的 **模式与实践** 指南、参考架构和库的一部分。'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The remaining *Patterns & Practices* projects still maintained by Microsoft
    are available on GitHub here: [https://github.com/mspnp](https://github.com/mspnp).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下由 Microsoft 维护的剩余 *模式与实践* 项目可以在 GitHub 上找到：[https://github.com/mspnp](https://github.com/mspnp)。
- en: Microsoft decided to open source the Prism Library and transferred ownership
    to the community. The project is hosted on GitHub and can be found on the web
    at [https://prismlibrary.com/](https://prismlibrary.com/). Prism has packages
    available for WPF, Xamarin, UWP, and WinUI projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 决定开源 Prism 库并将所有权转让给社区。该项目托管在 GitHub 上，可以在网络上找到：[https://prismlibrary.com/](https://prismlibrary.com/)。Prism
    为 WPF、Xamarin、UWP 和 WinUI 项目提供了包。
- en: Prism is much more than an MVVM framework. It also includes `EventAggregator`
    for loosely coupled application messaging. Prism can be added to a project through
    NuGet. There is also an installer available on the Prism site to add a Visual
    Studio project and item templates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Prism 不仅仅是一个 MVVM 框架。它还包括用于松散耦合应用程序消息的 `EventAggregator`。Prism 可以通过 NuGet 添加到项目中。Prism
    网站上还有一个安装程序，可以添加 Visual Studio 项目和项目模板。
- en: MVVMCross
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVMCross
- en: '**MVVMCross** is an MVVM framework that was first created for Xamarin developers.
    It now has NuGet packages available for Xamarin, .NET MAUI, WPF, UWP, and WinUI.
    As with Prism, MVVMCross does much more than facilitate data binding in WinUI
    applications. It has helpers for the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVMCross** 是一个最初为 Xamarin 开发者创建的 MVVM 框架。现在它提供了适用于 Xamarin、.NET MAUI、WPF、UWP
    和 WinUI 的 NuGet 包。与 Prism 类似，MVVMCross 不仅在 WinUI 应用程序中促进了数据绑定，它还提供了以下方面的辅助工具：'
- en: Data binding
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Navigation
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航
- en: Logging and tracing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和跟踪
- en: DI and IoC
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入和 IoC
- en: Unit testing
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'There are some additional libraries, but most are specific to .NET MAUI applications.
    The MVVMCross package can also be added to your project via NuGet. For more information
    about MVVMCross use with WinUI, check out their site: [https://www.mvvmcross.com/](https://www.mvvmcross.com/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的库，但大多数都是针对 .NET MAUI 应用程序的。MVVMCross 包也可以通过 NuGet 添加到您的项目中。有关在 WinUI 中使用
    MVVMCross 的更多信息，请查看他们的网站：[https://www.mvvmcross.com/](https://www.mvvmcross.com/)。
- en: Choosing a framework for WinUI applications
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 WinUI 应用程序的框架
- en: Using a third-party framework for building production XAML applications is a
    great choice. These provide built-in support for things such as logging and DI.
    For the WinUI application in this book, we will use the MVVM Toolkit for data
    binding at the end of this chapter. However, first, we will implement the MVVM
    pattern from scratch. This will help you understand the underlying mechanisms
    of data binding, DI, and other core concepts relating to MVVM.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方框架构建生产 XAML 应用程序是一个很好的选择。这些提供了内置的日志和依赖注入支持。对于本书中的 WinUI 应用程序，我们将在本章末尾使用
    MVVM Toolkit 进行数据绑定。然而，首先，我们将从头开始实现 MVVM 模式。这将帮助您了解数据绑定、依赖注入和其他与 MVVM 相关的核心概念的基础机制。
- en: Before jumping into the code, you should have some background on exactly how
    data binding works in WinUI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，您应该了解 WinUI 中数据绑定是如何工作的。
- en: Understanding data binding in WinUI
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 WinUI 中的数据绑定
- en: In the previous chapter, you saw some simple examples of data binding, using
    both the `Binding` and `x:Bind` markup extensions. Let’s dissect some of the components
    that allow the View to receive updates when the View Model data changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了一些使用 `Binding` 和 `x:Bind` 标记扩展的简单数据绑定示例。让我们分析一下允许视图在视图模型数据发生变化时接收更新的组件。
- en: What are markup extensions?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是标记扩展？
- en: 'An in-depth discussion of markup extensions is beyond the scope of this introductory
    book. In brief, they are a class that executes some logic to return a value to
    the XAML parser. You can identify their use in XAML by looking for some markup
    inside curly braces. Take this example of `Binding` in the `Text` property of
    a `TextBlock`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对标记扩展的深入讨论超出了本入门书的范围。简而言之，它们是一个执行一些逻辑并将值返回给 XAML 解析器的类。你可以在 XAML 中通过查找大括号内的某些标记来识别它们的使用。以下是一个
    `TextBlock` 的 `Text` 属性中的 `Binding` 示例：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From this, you can derive that there is a markup extension class named `Binding`
    and that two of its properties are `Path` and `Mode`. This markup extension takes
    these properties, resolves a value, and returns it to the XAML parser for display
    in the application’s View.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，你可以推断出存在一个名为 `Binding` 的标记扩展类，并且它有两个属性是 `Path` 和 `Mode`。这个标记扩展会获取这些属性，解析一个值，并将其返回给
    XAML 解析器，以便在应用程序的视图中显示。
- en: 'Some XAML markup languages allow developers to write their own custom markup
    extensions. WPF and .NET MAUI have custom markup extensions, but WinUI does not.
    If you’re curious about the implementation of a markup extension, Microsoft Learn
    has documentation on how to create one for .NET MAUI: [https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create](https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 XAML 标记语言允许开发者编写自己的自定义标记扩展。WPF 和 .NET MAUI 有自定义标记扩展，但 WinUI 没有。如果你对标记扩展的实现感兴趣，Microsoft
    Learn 提供了关于如何为 .NET MAUI 创建一个的文档：[https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create](https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create)。
- en: Now, let’s learn more about the `Binding` markup extension in WinUI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解 WinUI 中的 `Binding` 标记扩展。
- en: Binding markup extension
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记扩展
- en: 'As you briefly saw, the `Binding` markup extension maps data from the binding
    source, the View Model in MVVM, and provides it to a binding target in the View.
    These are all the properties of the `Binding` markup extension:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你简要看到的，`Binding` 标记扩展将绑定源（MVVM 中的视图模型）中的数据映射到绑定目标（视图），并提供给它。这些都是 `Binding`
    标记扩展的属性：
- en: '`Path`: The path to the value in the data-binding source. For our application,
    this will be the property name on the View Model.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path`：数据绑定源中值的路径。对于我们的应用程序，这将是在视图模型上的属性名称。'
- en: '`Converter`: If the data type of the source property does not match the data
    type of the control’s property in the View, a `Converter` property is used to
    define the mapping between the two data types.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Converter`：如果源属性的 数据类型与视图中控件属性的 数据类型不匹配，则使用 `Converter` 属性来定义两者之间的映射。'
- en: '`ConverterLanguage`: If a `Converter` property is specified, a `ConverterLanguage`
    property can optionally be set to support internationalization.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConverterLanguage`：如果指定了 `Converter` 属性，可以可选地设置 `ConverterLanguage` 属性以支持国际化。'
- en: '`ConverterParameter`: If a `Converter` property takes a parameter, use the
    `ConverterParameter` property to provide it. It’s not common to use a `Converter``     Parameter` property, and it is typically a `string` value. If you need to provide
    multiple values to a `Converter`, you can concatenate them and then parse them
    inside the method.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConverterParameter`：如果 `Converter` 属性需要一个参数，请使用 `ConverterParameter` 属性来提供它。通常不使用
    `ConverterParameter` 属性，它通常是一个 `string` 值。如果你需要向 `Converter` 提供多个值，你可以将它们连接起来，然后在方法内部解析它们。'
- en: '`ElementName`: This parameter is used when binding to an attribute of another
    element in the View.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementName`：当绑定到视图中的另一个元素的属性时使用此参数。'
- en: '`FallBackValue`: If the data binding fails for any reason, you can specify
    a `FallBackValue` property to display in the View.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FallBackValue`：如果数据绑定因任何原因失败，你可以指定一个 `FallBackValue` 属性在视图中显示。'
- en: '`Mode`: This defines whether the data binding is `OneTime` (sets the value
    only when the XAML is first parsed), `OneWay` (fetches the value from the View
    Model when changes are detected), or `TwoWay` (the value flows both ways between
    the View and View Model). The default `Mode` setting for `Binding` varies depending
    on the control and property being bound. It is important to check the documentation
    if you are unsure of the default `Mode`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode`：这定义了数据绑定是 `OneTime`（仅在 XAML 首次解析时设置值）、`OneWay`（在检测到更改时从 View Model 获取值）还是
    `TwoWay`（值在 View 和 View Model 之间双向流动）。`Binding` 的默认 `Mode` 设置取决于所绑定的控件和属性。如果您不确定默认的
    `Mode`，请检查文档。'
- en: '`RelativeSource`: This is used to define a data-binding source that is relative
    to the current control. This is usually used with control templates that get their
    data through a parent element.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeSource`：用于定义相对于当前控件的数据绑定源。这通常与通过父元素获取数据的控件模板一起使用。'
- en: '`Source`: Specifies the data-binding source. This is usually defined at a top-level
    control level in WinUI as the View Model. However, it is possible for child controls
    to set a different `Source`, overriding the `Source` inherited from their ancestor.
    The `Source` value defined at any level in the View will be inherited by all child
    elements unless a new `Source` is set.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`：指定数据绑定源。这通常在 WinUI 的顶级控件级别定义，作为 View Model。然而，子控件可以设置不同的 `Source`，覆盖从其祖先继承的
    `Source`。在 View 的任何级别定义的 `Source` 值将被所有子元素继承，除非设置了新的 `Source`。'
- en: '`TargetNullValue`: Specifies a default value to display if the data-binding
    source is resolved but has a `null` value.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetNullValue`：指定如果数据绑定源解析但具有 `null` 值时显示的默认值。'
- en: '`UpdateSourceTrigger`: Specifies the frequency with which to update `TwoWay`
    binding sources. The options are `PropertyChanged`, `Explicit`, and `LostFocus`.
    The default frequency for most properties is `PropertyChanged`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateSourceTrigger`：指定更新 `TwoWay` 绑定源的频率。选项有 `PropertyChanged`、`Explicit`
    和 `LostFocus`。大多数属性的默认频率是 `PropertyChanged`。'
- en: '`Path` is the default property and is assumed when no property name is given
    for a parameter. For example, the earlier `TextBlock` example could also be written
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 是默认属性，在没有给出参数属性名称时假定。例如，前面的 `TextBlock` 示例也可以写成以下形式：'
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `Name` is assumed to be the value provided for the `Path` parameter. Providing
    two parameters without specifying parameter names will result in a XAML parser
    error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Name` 假定是提供的 `Path` 参数的值。提供两个参数而不指定参数名称将导致 XAML 解析器错误。
- en: The `Binding` markup extension is found in every XAML language. The other option
    for data binding, `x:Bind`, is not. It is only an option with UWP and WinUI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding` 标记扩展在每种 XAML 语言中都能找到。另一种数据绑定选项 `x:Bind` 则不是。它仅是 UWP 和 WinUI 中的一个选项。'
- en: x:Bind markup extension
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: x:Bind 标记扩展
- en: '`x:Bind` is an alternative markup extension for WinUI. It is faster and uses
    less memory than `Binding` and has better debugging support. It achieves this
    performance gain by generating code at compile time to be used during binding
    at runtime. By contrast, the `Binding` markup extension is executed by the XAML
    parser at runtime, which incurs additional overhead. Compile-time bindings also
    result in incorrect data binding expressions being caught when compiling, rather
    than generating data binding failures at runtime.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Bind` 是 WinUI 的一个替代标记扩展。它比 `Binding` 更快，使用的内存更少，并且具有更好的调试支持。它通过在编译时生成代码以在运行时进行绑定来实现这种性能提升。相比之下，`Binding`
    标记扩展是在运行时由 XAML 解析器执行的，这会产生额外的开销。编译时绑定还会在编译时捕获不正确的数据绑定表达式，而不是在运行时生成数据绑定失败。'
- en: 'Another important distinction between `Binding` and `x:Bind` is that `Binding`
    requires a `Data``     Context` to be set. Data is bound to properties of objects within the `DataContext`.
    When using `x:Bind`, you are binding directly to properties on the current `Window`
    or `UserControl`. You can also bind events directly to event handlers in the code-behind
    for the Window with `x:Bind`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding` 和 `x:Bind` 之间的另一个重要区别是 `Binding` 需要设置 `Data`     `Context`。数据绑定到 `DataContext` 内对象的属性。当使用 `x:Bind` 时，您直接绑定到当前 `Window` 或 `UserControl`
    上的属性。您还可以使用 `x:Bind` 直接将事件绑定到代码背后的 Window 的事件处理器。'
- en: 'While most of the properties of `x:Bind` are the same as those in `Binding`,
    let’s highlight those that differ, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `x:Bind` 的大多数属性与 `Binding` 相同，但让我们突出以下不同的属性：
- en: '`ElementName`: Not available in `x:Bind`. You must use `Binding` to data-bind
    to other XAML element attributes. If your application must bind to other elements,
    `x:Bind` and `Binding` can be used in the same View.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementName`：在 `x:Bind` 中不可用。您必须使用 `Binding` 来将数据绑定到其他 XAML 元素属性。如果您的应用程序必须绑定到其他元素，可以在同一视图中使用
    `x:Bind` 和 `Binding`。'
- en: '`Mode`: The only difference here is that the default `Mode` for `x:Bind` is
    usually `OneTime`, not `OneWay`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode`：这里唯一的区别是 `x:Bind` 的默认 `Mode` 通常为 `OneTime`，而不是 `OneWay`。'
- en: '`RelativeSource`: Not available in `x:Bind`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeSource`：在 `x:Bind` 中不可用。'
- en: '`Source`: Not available in `x:Bind`. Instead, you will typically define a `ViewModel`
    property in the code-behind file of each View with a data type of the corresponding
    View Model class. You could also create a domain-specific name for the property,
    such as `MediaItems` for our application.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`：在 `x:Bind` 中不可用。相反，您通常会在每个视图的代码隐藏文件中定义一个 `ViewModel` 属性，其数据类型为相应的
    ViewModel 类。您也可以为属性创建一个特定领域的名称，例如，在我们的应用程序中为 `MediaItems`。'
- en: '`BindBack`: This property is unique to `x:Bind`. It allows a custom function
    to be called in `TwoWay` binding when reverse data binding is invoked. This is
    not commonly used, and we will not use it in our application.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindBack`：这个属性是 `x:Bind` 独有的。它允许在调用反向数据绑定时调用一个自定义函数。这并不常用，我们不会在我们的应用程序中使用它。'
- en: '`x:Bind` is a powerful and complex markup extension. For more information about
    it, you can read this page on Microsoft Learn: [https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension](https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Bind` 是一个强大且复杂的标记扩展。有关更多信息，您可以阅读 Microsoft Learn 上的此页面：[https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension](https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension)。'
- en: Next, let’s discuss `INotifyPropertyChanged`, the interface that enables changes
    in data-bound properties in the ViewModel to be reflected in the view.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论 `INotifyPropertyChanged`，这个接口使得 ViewModel 中数据绑定属性的变化可以在视图中反映出来。
- en: Updating View data with INotifyPropertyChanged
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 INotifyPropertyChanged 更新视图数据
- en: 'So, how does the View get notified when data changes in the ViewModel? That
    magic lies within the `Microsoft.UI.Xaml.Data.INotifyPropertyChanged` interface.
    This interface consists of a single member, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当 ViewModel 中的数据发生变化时，视图是如何得到通知的呢？这个魔法就隐藏在 `Microsoft.UI.Xaml.Data.INotifyPropertyChanged`
    接口中。这个接口只有一个成员，如下所示：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every ViewModel class must implement this interface and raise the `PropertyChanged`
    event to update the View. Indicate which property is changed by passing its name
    in the `PropertyChangedEventArgs` parameter. To refresh all properties, pass `null`
    or `string.Empty` as the property name, but be aware of the potential performance
    implications this can have on large views.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 ViewModel 类都必须实现这个接口，并通过触发 `PropertyChanged` 事件来更新视图。通过在 `PropertyChangedEventArgs`
    参数中传递其名称来指示哪个属性已更改。为了刷新所有属性，可以将属性名称传递为 `null` 或 `string.Empty`，但请注意这可能会对大型视图的性能产生潜在影响。
- en: Updating collection data with INotifyCollectionChanged
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 INotifyCollectionChanged 更新集合数据
- en: '`INotifyPropertyChanged` works great for most properties, but it will not update
    the View if items from a collection have been added or removed. This is where
    the `Microsoft.UI.Xaml.Interop.INotifyCollectionChanged` interface is used. Again,
    this interface only has a single member, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 对于大多数属性都工作得很好，但如果集合中的项目被添加或删除，它将不会更新视图。这就是使用 `Microsoft.UI.Xaml.Interop.INotifyCollectionChanged`
    接口的地方。同样，这个接口只有一个成员，如下所示：'
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: None of the collections or collection interfaces commonly used in .NET (`List<T>`,
    `IEnumerable<T>`, and so on) implement this interface. You can create your own
    collection derived from an existing list type and implement `INotifiedCollectionChanged`
    yourself, but it’s much easier to use the `ObservableCollection<T>` list type
    that is already available to WinUI developers. This is a collection that will
    update the View when items are added or removed, or when the contents are completely
    refreshed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中常用的一些集合或集合接口（如 `List<T>`、`IEnumerable<T>` 等）都没有实现这个接口。您可以创建一个从现有列表类型派生的自定义集合，并自行实现
    `INotifiedCollectionChanged`，但使用已经对 WinUI 开发者可用的 `ObservableCollection<T>` 列表类型要容易得多。这是一个在添加或删除项目，或内容完全刷新时更新视图的集合。
- en: The `Items` property of an `ObservableCollection<T>` is read-only, thus it cannot
    be directly set. You can add items by passing a `List<T>` or `IEnumerable<T>`
    to the constructor when creating `ObservableCollection<T>` or by using its `Add`
    or `Insert` methods (there is no `AddRange` method to add multiple items). You
    can update individual values in the collection by assigning a new item to the
    current index. You can remove items with the `Remove`, `RemoveAt`, `ClearItems`,
    or `Clear` methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableCollection<T>` 的 `Items` 属性是只读的，因此不能直接设置。你可以在创建 `ObservableCollection<T>`
    时通过传递一个 `List<T>` 或 `IEnumerable<T>` 到构造函数来添加项目，或者使用它的 `Add` 或 `Insert` 方法（没有
    `AddRange` 方法来添加多个项目）。你可以通过将新项目赋值给当前索引来更新集合中的单个值。你可以使用 `Remove`、`RemoveAt`、`ClearItems`
    或 `Clear` 方法来删除项目。'
- en: In the next section, when we implement the MVVM pattern for ourselves, you will
    see these concepts in practice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，当我们自己实现 MVVM 模式时，你将看到这些概念在实际中的应用。
- en: Implementing MVVM in WinUI applications
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WinUI 应用程序中实现 MVVM
- en: 'It’s time to start converting our project to use MVVM. To gain a thorough understanding
    of the MVVM pattern, we will start by building our own MVVM infrastructure. For
    simple applications, it doesn’t require more than a single base class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始将我们的项目转换为使用 MVVM 了。为了彻底理解 MVVM 模式，我们将首先构建自己的 MVVM 基础设施。对于简单的应用程序，它不需要超过一个基类：
- en: Start by adding a **ViewModels** folder to the project. If you are using the
    code from GitHub, you can either continue with your project from the previous
    chapter or use the **Start** project in the folder for this chapter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在项目中添加一个 **ViewModels** 文件夹。如果你正在使用 GitHub 上的代码，你可以继续使用上一章的项目，或者使用该章节文件夹中的
    **Start** 项目。
- en: 'Next, add a new class to the `BindableBase`. This will be the base class for
    all our View Model classes in the project. It will be responsible for notifying
    the corresponding views of any property changes. This is accomplished by implementing
    the `INotifyPropertyChanged` interface. Let’s review the `BindableBase` class
    code, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `BindableBase` 添加一个新的类。这将是项目中所有 View Model 类的基类。它将负责通知相应的视图任何属性的变化。这是通过实现
    `INotifyPropertyChanged` 接口来完成的。让我们回顾一下 `BindableBase` 类的代码，如下所示：
- en: '[PRE4]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By using this as the base class of our View Models, they will have two new
    methods available to use, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其作为我们 View Models 的基类，它们将有两个新的方法可供使用，如下所示：
- en: '`OnPropertyChanged`: Use this to trigger a `PropertyChanged` event to notify
    the View of changes in the data'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPropertyChanged`：使用此方法触发 `PropertyChanged` 事件以通知 View 数据的变化'
- en: '`SetProperty`: This method is used to set the value of a property if the value
    has been changed and will then call `OnPropertyChanged`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetProperty`：此方法用于设置属性的值，如果值已更改，则会调用 `OnPropertyChanged`'
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be sure you have these two using directives at the top of the `BindableBase`
    class file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `BindableBase` 类文件顶部有这两个 `using` 指令：
- en: '`using System.ComponentModel;`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`using System.ComponentModel;`'
- en: '`using System.Runtime.CompilerServices;`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`using System.Runtime.CompilerServices;`'
- en: 'Now that we have a base class, let’s add our first View Model to the project.
    Right-click the `MainViewModel`. This View Model is going to replace most of the
    code in the `MainWindow`. The following code is part of the revised class. Please
    refer to `MainViewModel.txt` in the GitHub repository for the chapter ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels))
    for the current version of the complete class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基类，让我们将第一个 View Model 添加到项目中。右键单击 `MainViewModel`。这个 View Model 将会替换
    `MainWindow` 中的大部分代码。以下代码是修改后的类的一部分。请参考 GitHub 仓库中该章节的 `MainViewModel.txt` ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels))
    以获取完整类的当前版本：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You may have noticed that the code has been updated, using the new `BindableBase.SetProperty`
    method inside each property’s `Set` block. This ensures that the UI will be notified
    when the property value has been changed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到代码已经更新，在每个属性的 `Set` 块中使用新的 `BindableBase.SetProperty` 方法。这确保了当属性值发生变化时，UI
    将会收到通知：
- en: 'Now, we’ll need to make the `MainViewModel` class available to the `MainWindow`
    view. Because there will be a single instance of this View Model used throughout
    the lifetime of the app, we will add a static read-only property to the `App.xaml.cs`
    file to make it available to the application, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使`MainViewModel`类对`MainWindow`视图可用。由于在整个应用程序生命周期中将使用此视图模型的单个实例，我们将在`App.xaml.cs`文件中添加一个静态只读属性，使其对应用程序可用，如下所示：
- en: '[PRE6]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now strip out all the code from `MainViewModel` class. In addition,
    add a property to make `App.ViewModel` available to `MainWindow` for data binding,
    as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以删除`MainViewModel`类中的所有代码。此外，添加一个属性使`App.ViewModel`对`MainWindow`的数据绑定可用，如下所示：
- en: '[PRE7]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only other code we need to keep in the code-behind file right now is for
    the `MainViewModel`. There are only two changes required to handle the new data
    source, detailed next.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前我们只需要在代码隐藏文件中保留关于`MainViewModel`的代码。现在只需要对处理新数据源进行两个更改，详细说明如下。
- en: 'First, update `ComboBox` to remove the `x:Name` property and add `x:Bind` data
    binding for the `ItemsSource` and `SelectedItem` properties. The `SelectedItem`
    binding needs to be set to `TwoWay`. This will ensure that the data in `MainViewModel`
    is updated when the user changes `SelectedMedium` in the UI. The code can be seen
    in the following snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新`ComboBox`以删除`x:Name`属性，并为`ItemsSource`和`SelectedItem`属性添加`x:Bind`数据绑定。`SelectedItem`绑定需要设置为`TwoWay`。这将确保当用户在UI中更改`SelectedMedium`时，`MainViewModel`中的数据会更新。代码可以在以下代码片段中看到：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, update `ListView` to remove the `x:Name` property and add an `ItemsSource`
    `x:Bind` data binding, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`ListView`以删除`x:Name`属性，并添加一个`ItemsSource` `x:Bind`数据绑定，如下所示：
- en: '[PRE9]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The assigned names for these controls are no longer needed because we are not
    referencing them anywhere in the code.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为这些控件分配的名称不再需要，因为我们没有在代码中的任何地方引用它们。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Assigning names to XAML elements allocates additional resources. It is recommended
    to only name elements when the elements must be referenced directly from code-behind
    files or by other View elements’ data binding via `ElementName`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为XAML元素分配名称会分配额外的资源。建议仅在元素必须直接从代码隐藏文件或其他视图元素的`ElementName`数据绑定中引用时才命名元素。
- en: Now, run the application and try changing the `Medium` filter with the `ComboBox`.
    It should behave exactly as it did before, but now we have decoupled the View
    Model data from the UI, making it easier to test or potentially reuse.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并尝试使用`ComboBox`更改`Medium`过滤器。它应该表现得与之前完全一样，但现在我们已经将视图模型数据与UI解耦，这使得测试或潜在的重用变得更加容易。
- en: Next, we will address the button `Click` event that we still have in the **MainWindow.xaml.cs**
    file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解决`MainWindow.xaml.cs`文件中仍然存在的按钮`Click`事件。
- en: Working with events and commands
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与事件和命令一起工作
- en: It’s time to update the project to move the event handling code to `MainViewModel`.
    By the end of this section, you will have removed all the code that was added
    to the `ViewModel` property. This will be great for the separation of concerns,
    as well as for the maintainability and testability of the project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更新项目，将事件处理代码移动到`MainViewModel`。在本节结束时，你将删除添加到`ViewModel`属性的所有代码。这将有利于关注点的分离，以及项目的可维护性和可测试性。
- en: 'We could use the same process of wiring up events with the `Click` event and
    connect it to a method on the `MainViewModel` class. There are two problems with
    this approach:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与`Click`事件连接并连接到`MainViewModel`类上的方法的相同过程。这种方法有两个问题：
- en: The View and View Model layers become more tightly coupled, reducing maintainability
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图层和视图模型层变得更加紧密耦合，降低了可维护性
- en: UI concerns are injected into the view model, reducing the testability of the
    class
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI关注点被注入到视图模型中，降低了类的可测试性
- en: Let’s take another route. The MVVM pattern has the concept of `Command` properties
    all expect a type of `System.Windows.Input.ICommand`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们另辟蹊径。MVVM模式中的`Command`属性都有一个概念，即它们都期望一个`System.Windows.Input.ICommand`类型的类型。
- en: Implementing ICommand
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ICommand`
- en: To use commands in the project, we’ll start by creating an implementation of
    `ICommand`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中使用命令，我们首先需要创建一个`ICommand`的实现。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another advantage of using an MVVM framework such as Prism or the MVVM Toolkit
    is that they provide implementations of `ICommand`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Prism或MVVM Toolkit这样的MVVM框架的优点之一是它们提供了`ICommand`的实现。
- en: 'Add a new class to the `ViewModel` folder in the project and name it `RelayCommand`.
    This class will implement the `ICommand` interface. The `RelayCommand` class will
    look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中的`ViewModel`文件夹中添加一个新类，并将其命名为`RelayCommand`。这个类将实现`ICommand`接口。`RelayCommand`类将如下所示：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`RelayCommand` has two constructors that both take an `Action` that will be
    invoked when the command is executed. One of the constructors also takes a `Func<bool>`.
    This will allow us to enable or disable UI actions based on the return value of
    `CanExecute`. We will use this to enable a `ListView`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelayCommand`有两个构造函数，它们都接受一个在命令执行时将被调用的`Action`。其中一个构造函数还接受一个`Func<bool>`。这将允许我们根据`CanExecute`的返回值启用或禁用UI操作。我们将使用此功能来启用`ListView`。'
- en: Using commands in the View Model
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图模型中使用命令
- en: 'Now, it’s time to update `MainViewModel` to handle commands from the **Add**
    and **Delete** buttons. In the next chapter, we will enhance the add operation
    so it can add or edit items. So, let’s name the command and method accordingly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新`MainViewModel`以处理来自**添加**和**删除**按钮的命令了。在下一章中，我们将增强添加操作，使其能够添加或编辑项目。因此，让我们相应地命名命令和方法：
- en: 'First, add two new private variables to the `MainViewModel` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向`MainViewModel`类中添加两个新的私有变量：
- en: '[PRE11]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `additionalItemCount` variable is a temporary variable that we will use
    to track how many new items we have added to the list. The counter will help to
    generate unique IDs and names for each new media item. `selectedMediaItem` is
    a backing variable for the new `SelectedMediaItem` property.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`additionalItemCount`变量是一个临时变量，我们将用它来跟踪我们添加到列表中的新项目数量。计数器将帮助我们为每个新媒体项目生成唯一的ID和名称。"selectedMediaItem"是新的`SelectedMediaItem`属性的备份变量。'
- en: 'Add the `SelectedMediaItem` property next:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`SelectedMediaItem`属性：
- en: '[PRE12]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In addition to calling `SetProperty` to notify the UI that `SelectedMediaItem`
    has changed, we also need to call `RaiseCanExecuteChanged` on a new `DeleteCommand`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了调用`SetProperty`来通知UI`SelectedMediaItem`已更改外，我们还需要在新的`DeleteCommand`上调用`RaiseCanExecuteChanged`。
- en: 'Next, let’s add `DeleteCommand` and `AddEditCommand` along with their corresponding
    actions:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加`DeleteCommand`和`AddEditCommand`以及它们对应的行为：
- en: '[PRE13]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is an `ICommand` property for each UI operation (`AddEditCommand` and
    `Delete``     Command`) and new methods for each command to execute (`AddOrEditItem` and `DeleteItem`).
    There is also a `CanDeleteItem` method that returns a `bool` value to indicate
    whether a media item has been selected by the user.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个UI操作（`AddEditCommand`和`Delete`）都有一个`ICommand`属性，以及每个命令的执行方法（`AddOrEditItem`和`DeleteItem`）。还有一个`CanDeleteItem`方法，它返回一个`bool`值，以指示用户是否已选择媒体项目。
- en: 'At the end of the `MainViewModel` constructor, add two lines of code to initialize
    the commands, connecting them to the corresponding methods:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewModel`构造函数的末尾，添加两行代码来初始化命令，将它们连接到相应的函数：
- en: '[PRE14]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is part of the revised `MainViewModel` class. Please refer
    to `MainViewModel2.txt` in the GitHub repository for the chapter ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels))
    for the current version of the complete class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是修改后的`MainViewModel`类的一部分。请参考GitHub仓库中的`MainViewModel2.txt`文件以获取完整类的当前版本，该文件位于[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels)。
- en: Our View Model has been updated to use commands. Next, we will update the view
    to bind to them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图模型已被更新为使用命令。接下来，我们将更新视图以绑定到它们。
- en: Updating the View
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新视图
- en: 'Our view model is ready to go. It’s now safe to remove all the event handling
    code from the `MainWindow` code. It should look like this when you’re finished:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图模型已经准备好了。现在可以安全地从`MainWindow`代码中移除所有的事件处理代码。完成时，它应该看起来像这样：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The **MainWindow.xaml** file will need a few updates to get the **Add Item**
    and **Delete Item** buttons fully functional with the temporary test data. Perform
    the following steps to accomplish this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.xaml**文件需要一些更新，以便**添加项目**和**删除项目**按钮能够与临时测试数据完全功能化。执行以下步骤以完成此操作：'
- en: 'Update the `ListView` to bind the `SelectedItem` property to `SelectedMediaItem`
    in the view model:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ListView`以将视图模型中的`SelectedItem`属性绑定到`SelectedMediaItem`：
- en: '[PRE16]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, move the `Grid`. Then, create a `Click` event handler and set the properties
    of the grid and two buttons to match the following snippet:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，移动`网格`。然后，创建一个`点击`事件处理程序，并将网格和两个按钮的属性设置为以下代码片段：
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each button’s `Command` property will be bound to the new `ICommand` properties
    in the view model. The `Command` property of a button is invoked when it’s clicked
    by the user.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个按钮的 `Command` 属性将绑定到视图模型中的新 `ICommand` 属性。当用户点击按钮时，将调用按钮的 `Command` 属性。
- en: We’re now done updating the project to use MVVM. Run the application to see
    how it works.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已更新项目以使用 MVVM。运行应用程序以查看其工作情况。
- en: When it first loads, the **Delete Item** button will be disabled. Select an
    item in the list and notice that the button is automatically enabled. If you click
    **Delete Item**, the selected item is removed from the list and the button is
    disabled again.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它首次加载时，**删除项目**按钮将被禁用。选择列表中的一个项目，注意按钮会自动启用。如果您点击**删除项目**，所选项目将从列表中删除，按钮再次被禁用。
- en: 'Finally, click **Add Item** a few times to see how new items are created and
    added to the list. Each new item has a unique name using the counter we created
    in the view model, as illustrated in the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**添加项目**几次，看看新项目是如何创建并添加到列表中的。每个新项目都使用我们在视图模型中创建的计数器具有一个独特的名称，如下面的截图所示：
- en: '![Figure 3.2 – My Media Collection after adding and removing a few items](img/B20908_03_02.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 添加和删除一些项目后的我的媒体收藏](img/B20908_03_02.jpg)'
- en: Figure 3.2 – My Media Collection after adding and removing a few items
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 添加和删除一些项目后的我的媒体收藏
- en: '`MainWindow` now has a view model that is completely decoupled from any UI
    concerns. This will allow you to maximize the unit test coverage on the project.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow` 现在有一个完全与任何 UI 关注点解耦的视图模型。这将允许您在项目中最大化单元测试覆盖率。'
- en: Before we wrap up, let’s see how we can reduce the amount of code in our project
    by using an MVVM framework such as the MVVM Toolkit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，让我们看看如何通过使用 MVVM 框架（如 MVVM 工具包）来减少项目中代码的数量。
- en: Leveraging the MVVM Toolkit
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 MVVM 工具包
- en: 'We briefly introduced the MVVM Toolkit earlier in the chapter. In this section,
    we will update the `MainViewModel` to see how we can remove the need for a `BindableBase`
    class and reduce the amount of code in the view model itself:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中简要介绍了 MVVM 工具包。在本节中，我们将更新 `MainViewModel` 以了解我们如何消除对 `BindableBase` 类的需求并减少视图模型本身的代码量：
- en: Start by right-clicking on the solution file in **Solution Explorer** and select
    **Manage NuGet Packages** **for Solution**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**解决方案资源管理器**中右键单击解决方案文件，并选择**解决方案**的**管理 NuGet 包**。
- en: In the NuGet window, select the `CommunityToolkit.Mvvm`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NuGet 窗口中，选择 `CommunityToolkit.Mvvm`。
- en: Select the **CommunityToolkit.Mvvm** package in the results and install the
    latest stable version (8.2.0 or later).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果中选择 **CommunityToolkit.Mvvm** 包，并安装最新稳定版本（8.2.0 或更高版本）。
- en: 'Close the NuGet window and open the `MainViewModel` class. The first thing
    we need to do to use the MVVM Toolkit’s source generators is update `MainViewModel`
    to be a partial class and have it inherit from `CommunityToolkit.Mvvm.ComponentModel.ObservableObject`
    instead of our own `BindableBase` class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 NuGet 窗口并打开 `MainViewModel` 类。我们需要做的第一件事是使用 MVVM 工具包的源生成器，将 `MainViewModel`
    更新为部分类，并使其继承自 `CommunityToolkit.Mvvm.ComponentModel.ObservableObject` 而不是我们自己的
    `BindableBase` 类：
- en: '[PRE18]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about how the MVVM Toolkit uses **.NET source generators** to
    generate public properties and commands, check out the documentation on Microsoft
    Learn: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview).
    If you are unfamiliar with .NET source generators, you can also read about them
    on Microsoft Learn in the .NET documentation: [https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview](https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 MVVM 工具包如何使用 **.NET 源生成器**生成公共属性和命令的更多信息，请查看 Microsoft Learn 上的文档：[https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview)。如果您不熟悉
    .NET 源生成器，您也可以在 Microsoft Learn 的 .NET 文档中了解它们：[https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview](https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview)。
- en: 'Next, each simple property that only calls `SetProperty` in its setter will
    be removed, and the backing variable will be updated to have an `ObservableProperty`
    attribute. Remove the `Mediums` and `Items` properties and the private `mediums`
    and `items` fields should now look like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，每个只在其设置器中调用 `SetProperty` 的简单属性将被移除，并且后备变量将被更新以具有 `ObservableProperty` 属性。移除
    `Mediums` 和 `Items` 属性，以及私有的 `mediums` 和 `items` 字段现在应如下所示：
- en: '[PRE19]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have two public properties remaining in the class. Let’s start with `SelectedMedium`.
    We will remove `SelectedMediaItem` after updating the commands.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类中剩下两个公共属性。让我们从 `SelectedMedium` 开始。在更新命令后，我们将移除 `SelectedMediaItem`。
- en: 'The setter for `SelectedMedium` has some custom logic after the call to `SetProperty`.
    Create a new partial method named `OnSelectedMediumChanged` to contain that code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SelectedMedium` 的设置器在调用 `SetProperty` 之后有一些自定义逻辑。创建一个新的部分方法 `OnSelectedMediumChanged`
    来包含那段代码：'
- en: '[PRE20]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we also updated the uses of `selectedMedium` to `value`. The `value`
    parameter contains the new `selectedMedium` value. You may have also noticed some
    green squiggles in Visual Studio inside the `PopulateData` method, indicating
    that you should be using the generated properties instead of using the private
    `ObservableProperty` members directly. You can update all of these uses by capitalizing
    the first letter of each variable.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们还更新了 `selectedMedium` 的使用为 `value`。`value` 参数包含新的 `selectedMedium` 值。你可能也注意到了在
    Visual Studio 中的 `PopulateData` 方法内的一些绿色波浪线，这表明你应该使用生成的属性而不是直接使用私有的 `ObservableProperty`
    成员。你可以通过将每个变量的首字母大写来更新所有这些使用。
- en: 'Next, we will update the two commands. Add the `RelayCommand` attribute to
    the `AddOr``     EditItem` and `DeleteItem` methods and rename them to `AddEdit` and `Delete` to
    ensure that the generated commands have the same names that our old commands had.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更新两个命令。将 `RelayCommand` 属性添加到 `AddOrEditItem` 和 `DeleteItem` 方法中，并将它们重命名为
    `AddEdit` 和 `Delete`，以确保生成的命令具有与旧命令相同的名称。
- en: 'Remove the two commands and the code to initialize them in the `MainViewModel`
    constructor. The code for the constructor and the signatures for the two command
    methods should now look like this:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除两个命令以及它们在 `MainViewModel` 构造函数中初始化的代码。构造函数的代码和两个命令方法的签名现在应如下所示：
- en: '[PRE21]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The attribute for `DeleteItem` also indicates that `CanDeleteItem` should be
    used for checking whether the command can be invoked.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DeleteItem` 的属性还指示应使用 `CanDeleteItem` 来检查命令是否可以调用。'
- en: 'Finally, let’s replace the `SelectedMediaItem` property with a source-generated
    property from the MVVM Toolkit. The existing public property tells the `DeleteCommand`
    that `CanExecute` should be checked. Remove that property and update the private
    `selectedMediaItem` variable to add two attributes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将 `SelectedMediaItem` 属性替换为 MVVM 工具包生成的源属性。现有的公共属性告诉 `DeleteCommand` 应该检查
    `CanExecute`。移除该属性，并将私有的 `selectedMediaItem` 变量更新以添加两个属性：
- en: '[PRE22]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to the `ObservableProperty` attribute, we’ve added a `NotifyCan``     ExecuteChangedFor` attribute, providing the name of the `DeleteCommand` generated
    `ICommand` property. The generated property, which is invisible to us, would be
    equivalent to this:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 `ObservableProperty` 属性之外，我们还添加了一个 `NotifyCanExecuteChangedFor` 属性，提供了由 `DeleteCommand`
    生成的 `ICommand` 属性的名称。对我们不可见的生成属性将等同于以下内容：
- en: '[PRE23]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s all you need to do. There are no changes needed in the view, and the
    application works exactly as it did before. All we’ve done is remove quite a bit
    of code from `MainViewModel`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的全部。在视图中不需要进行任何更改，应用程序的工作方式与之前完全相同。我们所做的就是从 `MainViewModel` 中移除了一大块代码。
- en: We will continue to use the MVVM Toolkit throughout the remaining chapters.
    Now, let’s review what we’ve learned in this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中继续使用 MVVM 工具包。现在，让我们回顾一下本章学到的内容。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We’ve made quite a bit of progress with the application in this chapter. While
    it’s not yet connected to a live data source, we have methods in place to add
    and remove items from the media collection in memory. In addition, the project
    has been refactored to use the `MainWindow` code-behind file to a new `MainViewModel`
    class. The new `MainViewModel` class has no dependencies on the UI. Finally, we
    saw how integrating the MVVM Toolkit into the project can reduce the boilerplate
    code in our view models. These good software design habits will serve us well
    in the chapters ahead as we build more functionality onto the project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对应用程序已经取得了一些进展。虽然它还没有连接到实时数据源，但我们已经有了在内存中添加和删除媒体集合项的方法。此外，项目已经被重构，使用
    `MainWindow` 代码隐藏文件转换为新的 `MainViewModel` 类。新的 `MainViewModel` 类不依赖于 UI。最后，我们看到了如何将
    MVVM Toolkit 集成到项目中可以减少我们视图模型中的样板代码。这些良好的软件设计习惯将在我们构建更多功能到项目中的后续章节中为我们服务。
- en: In the next chapter, we will continue learning how to use the MVVM pattern to
    write robust, maintainable WinUI applications. We will cover some more advanced
    MVVM topics and learn some techniques for window management in a WinUI project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习如何使用 MVVM 模式来编写健壮、可维护的 WinUI 应用程序。我们将涵盖一些更高级的 MVVM 主题，并学习在 WinUI
    项目中进行窗口管理的技巧。
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does MVVM stand for?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVVM 代表什么？
- en: Which layer typically defines the business entities in the MVVM pattern?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVVM 模式中，哪一层通常定义业务实体？
- en: Name one of the popular MVVM frameworks discussed in the chapter.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举本章讨论的流行 MVVM 框架之一。
- en: Which interface must every View Model class implement in an MVVM application?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVVM 应用程序中，每个视图模型类必须实现哪个接口？
- en: Which special collection type in .NET notifies the UI of changes to the collection,
    via data binding?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET 中，哪种特殊的集合类型通过数据绑定通知 UI 集合的变化？
- en: Which control property of `ComboBox` and `ListView` is used to get or set the
    currently selected item in the control?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ComboBox` 和 `ListView` 控件的哪个属性用于获取或设置控件中当前选中的项？'
- en: Which interface is implemented to create commands for event binding?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现事件绑定的命令的哪个接口被实现？
