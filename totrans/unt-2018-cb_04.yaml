- en: Playing and Manipulating Sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing different one-off sound effects with a single AudioSource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing and controlling different sounds each with their own AudioSource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating just-in-time AudioSource components at runtime through C# scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaying before playing a sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing an Audio Clip from restarting if it is already playing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for audio to finish playing before auto-destructing an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a metronome through the precise scheduling of sounds with dspTime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the audio pitch to the animation speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating acoustic environments with Reverb Zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding volume control with Audio Mixers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a dynamic soundtrack with Snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing in-game audio with Ducking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio visualization from sample spectral data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop
    manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound is a very important part of the gaming experience. In fact, it can't be
    stressed enough how crucial it is to the player's immersion in a virtual environment.
    Just think of the engine running in your favorite racing game, the distant urban
    buzz in a simulator game, or the creeping noises in horror games. Think of how
    these sounds transport you into the game.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting on with the recipes, let''s first review how the different sound
    features work in Unity. A project with audio needs one or more audio files, which
    are called **AudioClips** in Unity, and these sit in your **Project** folders.
    At the time of writing, Unity 2017 supports four audio file formats: `.wav`, `.ogg`,
    `.mp3`, and `.aif`. Files in these types are re-encoded when Unity builds for
    a target platform. It also supports tracker modules in four formats: .xm, **.mod**,
    **.****it**, and **.s3m**.'
  prefs: []
  type: TYPE_NORMAL
- en: A scene or prefab GameObject can have an **AudioSource** component – which can
    be linked to an **AudioClip** sound file at Design-Time, or through scripting
    at Run-Time. At any time in a scene, there is one active **AudioListener** component
    inside a GameObject. When you create a new scene, there is one added automatically
    for you in the *Main Camera*. One can think of an **AudioListener** as a simulated
    digital '"ear," since the sounds Unity plays are based on the relationship between
    playing **AudioSources** and the active **AudioListener**.
  prefs: []
  type: TYPE_NORMAL
- en: Simple sounds, such as pickup effects and background soundtrack music, can be
    defined as as **2D sound**. However, Unity supports **3D sounds**, which means
    that the location and distance between playing **AudioSources** and the active
    **AudioListener** determine the way the sound is perceived in terms of loudness
    and the left/right balance.
  prefs: []
  type: TYPE_NORMAL
- en: You can also engineer synchronized sound playing and scheduling through `AudioSettings.dspTime` –
    a value based on the samples in the audio system, so it is much more precise than
    the `Time.time` value. Also, `dspTime` will pause/suspend with the scene, so no
    logic is required for rescheduling when using `dspTime`. Several recipes in this
    chapter illustrate this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent years, Unity has added a powerful new feature to game audio: the
    **AudioMixer**. The **AudioMixer** radically changes the way in which sound elements
    can be experienced by players and worked with by game developers. It allows us
    to mix and arrange audio pretty much in the same way that musicians and producers
    do in their **Digital Audio Workstations** (**D.A.W.**), such as **GarageBand**
    or **ProTools**. It allows you to route **AudioSource** clips into specific channels
    that can have their volumes individually adjusted and processed by customized
    effects and filters. You can work with multiple **AudioMixers**, send a mixer''s
    output to a parent mixer, and save mix preferences as **Snapshots**. Also, you
    can access mixer parameters from scripting. The following figure represents the
    main Unity audio mixing concepts and their relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb76899-3541-4772-bfae-f4fe02750351.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The figure above represents the main Unity audio mixing concepts and their
    relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the new AudioMixer feature in many example projects, this
    chapter is filled with recipes that will hopefully help you implement a better
    and more efficient sound design for your projects, augmenting the player's sense
    of immersion, transporting them into the game environment, and even improving
    the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Future audio features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes demonstrate both scripted and Unity audio system approaches to managing
    audio and introducing dynamic effects at runtime. Games can become much more engaging
    when the audio environment of effects and music can subtly change based on the
    context of what is happening in the game – whether you chose effects such as reverb
    zones, ducking to de-emphasize some sounds for a while, or allow the user to control
    the audio volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, what is possible with special audio is now getting even more interesting,
    with the introduction of Ambisonic Audio when playing 3D VR games – allowing rich
    audio experiences based on whether sounds are above or below the listener, as
    well as their distance from an audio source. Some reference sources for ambisonic
    audio include:'
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia offers some history of ambisonics: [https://en.wikipedia.org/wiki/Ambisonics](https://en.wikipedia.org/wiki/Ambisonics).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about Unity and ambisonic audio in the Unity docs:[ https://docs.unity3d.com/Manual/AmbisonicAudio.html](https://docs.unity3d.com/Manual/AmbisonicAudio.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google's reference pages about special audio and ambisonics: [https://developers.google.com/vr/concepts/spatial-audio](https://developers.google.com/vr/concepts/spatial-audio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occulus reference pages about special audio and ambisonics: [https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/](https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robert Hernadez has published a great article at Medium.com disambiguating how
    to record and edit ambisonic audio: [https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca](https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing different one-off sound effects with a single AudioSource component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basics of playing a sound are very straightforward in Unity (adding an **AudioSource**
    component to a GameObject and linking it to an **AudioClip** sound file). For
    simple sound effects such as short, one-off plays of pickup confirmation noises,
    it's useful to have a single **AudioSource** component and reuse it to play different
    sound effects – which is what we'll do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try this with any short audio clip that is less than one second in duration.
    We have included some classic Pacman game sound clips inside the `04_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To play multiple sounds using the same **AudioSource** component, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, `PlaySound`s, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the **Main
    Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the **MainCamera** GameObject is selected in the **Hierarchy**.
    Then, in the **Inspector** panel, drag the Pacman Eating Cherry sound clip from
    the **Project** panel into the public Pacman Eating Cherry **AudioClip** variable in
    the `PlaySounds (Script)` scripted component. Repeat this procedure for the Pacman
    Extra Life sound clip. These steps are illustrated in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/288ddefa-548e-4662-b08d-2adeb64b8360.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to play the different
    sound effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created a C# script class, `PlaySounds`. The script class includes
    a `RequireComponent` attribute declaring that any GameObject containing a scripted
    object component of this class must have a sibling AudioSource component (and
    one will be automatically added if such a component does not exist when the scripted
    component is added).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaySounds` script class has two public **AudioClip** properties: `Pacman
    Eating Cherry` and `Pacman Extra Life`. At **Design-Time**, we associated **AudioClip**
    sound files from the **Project** panel with these public properties.'
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, the `Update()` method is executed in every frame. This method checks
    for the *UP* and *DOWN* array keys being pressed, and if so, plays the Eat Cherry
    or Extra Life sounds correspondingly – sending the **AudioSource** component a
    `PlayOneShot()` message with the appropriate **AudioClip** sound file link.
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE: Cannot pause/interrogate sounds played with **PlayOneShot**'
  prefs: []
  type: TYPE_NORMAL
- en: While great for short, one-off sound effects, a limitation of the `PlayOneShot()`
    method is that you cannot then interrogate the status of the playing sound (has
    it finished, at what point is it playing, and so on). Nor can you pause/restart
    a sound played with `PlayOneShot()`. For such detailed control of sounds, each
    sound needs its own AudioSource component.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the `PlayOneShot()` method in the Unity documentation: [https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Play a sound at a static point in 3D world space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `PlayOneShot()` is the `PlayClipAtPoint()` **AudioSource** method.
    This allows you to play a sound clip for an **AudioSource** created at a specific
    point in 3D World Space. Note that this is a static class method – so that you
    don''t need an **AudioSource** component to use this method – an **AudioSource**
    component is created (at the location you give), and will exist as long as the
    **AudioClip** sound is playing. The **AudioSource** component will automatically
    be removed by Unity once the sound has finished playing. All you need is a `Vector3`
    (x,y,z) position object, and a reference to the **AudioClip** file to be played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Playing and controlling different sounds each with their own AudioSource component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the approach in the previous recipe (using `PlayOneShot(...)` with a single
    **AudioSource**) is fine for one-off sound effects, when further control may be
    required over a playing sound, each sound will needs to be played in its own **AudioSource**
    component. In this recipe, we'll create two separate **AudioSource** components
    and pause/resume each with different arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try this with two audio clips that are several seconds long. We have included
    two free music clips inside folder `04_02`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To play different sounds each with their own AudioSouce component, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the 186772__dafawe__medieval **AudioClip**. This can be done in a single step
    by dragging the music clip from the **Project** panel into either the **Hierarchy**
    or **Scene** panels. Rename this new GameObject to music1_medieval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step to create another GameObject named music2_arcade, containing
    an **AudioSource** linked to 251461__joshuaempyre__arcade-music-loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both AudioSources created, uncheck the Play Awake property – so these sounds
    do not begin playing as soon as the scene is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty GameObject named Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, MusicManager, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the Manager
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the **Manager** GameObject is selected in the **Hierarchy**. In
    the **Inspector** panel, drag the music1_medieval **GameObject** from the Scene
    panel into the public **Audio Source Medieval** AudioSource variable in the `MusicManager
    (Script)` scripted component. Repeat this procedure, dragging GameObject music2_arcade
    into the public Audio Source Arcade variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to start/resume and
    pause the medieval sound clip. Press the *RIGHT* and *LEFT* arrow keys to start/resume
    and pause the arcade sound clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a C# script class, `MusicManager`, and added an instance of this
    class as a component to the Manager GameObject. You also created two **GameObjects**,
    named music1_medieval and music2_arcade, in the scene, each containing an **AudioSource**
    component linked to a different music clip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script class has two public **AudioSource** properties: `Music Medieval`
    and `Music Arcade`. At **Design-Time**, we associated the **AudioSource** components
    of **GameObjects** music1_medieval and music2_arcade with these public properties.'
  prefs: []
  type: TYPE_NORMAL
- en: At Run-Time, the `Update()` method is executed in every frame. This method checks
    for the *UP/DOWN/RIGHT/LEFT* array keys being pressed. If the *UP* arrow key is
    detected, the medieval music audio source is sent a `Play()` or `UnPause()` message.
    The `Play()` message is sent if the clip is not already playing (its time property
    is zero). If the DOWN arrow key is pressed, the medieval music audio source is
    sent a `Pause()` message.
  prefs: []
  type: TYPE_NORMAL
- en: The arcade music clip is controlled in a corresponding way through detection
    of the RIGHT/LEFT array keys.
  prefs: []
  type: TYPE_NORMAL
- en: Each **AudioClip** sound file being associated with its own **AudioSource**
    component allows simultaneous playing, and managing of each sound independently.
  prefs: []
  type: TYPE_NORMAL
- en: Creating just-in-time AudioSource components at runtime through C# scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, for each sound clip we wanted to manage, in the scene
    we had to manually create **GameObjects** with **AudioSource** components at Design-Time.
    However, using C# scripting, we can create our own **GameObjects** that contain **AudioSources**
    at **Run-Time**, just when they are needed. This method is similar to the built-in
    **AudioSource PlayClipAtPoint()** method, but the created **AudioSource** component
    is completely under our programmatic control – although we then have to be responsible
    for destroying this component when it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: This code was inspired by some of the code posted in 2011 in the online **Unity
    Answers** forum by user Bunny83\. Unity has a great online community helping each
    other and posting interesting ways of adding features to games. Learn more about
    that post at [http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html](http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create just-in-time AudioSource components at run time through C# scripting
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the music1_medieval and music-loop GameObjects from the scene – we'll
    be creating these at **Run-Time** in this recipe!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refactor the `MusicManager` C# script class to read as follows (note that the
    `Update()` method is unchanged):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the `MainCamera` **GameObject** is selected in the **Hierarchy**.
    In the Inspector panel, drag the **AudioClip** 186772__dafawe__medieval sound
    clip from the Project panel into the public Clip Medieval **AudioClip** variable
    in the `MusicManager (Script)` scripted component. Repeat this procedure with
    **AudioClip** 251461__joshuaempyre__arcade-music-loop for the Clip Arcade variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to start/resume and
    pause the medieval sound clip. Press the *RIGHT* and *LEFT* arrow keys to start/resume
    and pause the arcade sound clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key feature of this recipe is the new `CreateAudioSource(...)` method.
    This method takes input as a reference to a sound clip file and a Boolean true/false
    value as to whether the sound should start playing immediately. The method does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new **GameObject** (with the same parent, and at the same location
    as the **GameObject** doing the creating)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a new **AudioSource** component to the new **GameObject**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the audio clip of the new AudioSource component to the provided AudioClip
    parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Boolean parameter was true, the **AudioSource** component is immediately
    sent a `Play()` message to start it playing the sound clip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the AudioSource component is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the `MusicManager` script class is very similar to that in the previous
    recipe. There are two public `AudioClip` variables, `clipMedieval` and `clipArcade`,
    which are set through drag-and-drop at **Design-Time** to link to the sound clip
    files in **Sounds Project** folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `audioSourceMedieval` and `audioSourceArcade AudioSource` variables are
    now private. These values are set up in the `Awake(`) method, by calling and storing
    values returned by the `CreateAudioSource(...)` method with the **clipMedieval**
    and `clipArcade` AudioClip variables.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how the Boolean parameter works, the medieval music **AudioSource**
    is created to play immediately, while the arcade music won't start playing until
    the *UP* arrow key is pressed. Playing/Resuming/Pausing the two audio clips is
    just the same as in the previous recipe – via the arrow-key detection logic in
    the (unchanged) `Update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CreateAudioSource(...) method as an extension to the MonoBehavior
    class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the `CreateAudioSource(...)` method is a general-purpose method that could
    be used by many different game script classes, it doesn't naturally sit within
    the `MusicManager` class. The best place for general-purpose generative methods
    such as this is to add them as static (class) methods to the component class they
    work with – in this case it would be great if we could add this method to `MonoBehavior` class
    itself – so any scripted component could create **AudioSource** GameObjects on
    the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is create a class (usually named `ExtensionMethods`) with
    a static method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we add an extra first parameter to the extension method, stating
    which class we are adding this method to. Since we have added this to the `MonoBehavior`
    class, we can now use this method in our scripted classes as if it were built-in.
    So our `Awake()` method in our `MusicManager` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's it – we can now remove the method from our `MusicManager` class and use
    this method in any of our `MonoBehavior` scripted classes.
  prefs: []
  type: TYPE_NORMAL
- en: Delaying before playing a sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we don't want to play a sound immediately, but after a short delay.
    For example, we might want to wait a second or two before playing a sound to indicate
    the slightly delayed onset of a poison drunk or having walked into a spell that
    weakens the player. For such cases, **AudioSource** offers the `PlayDelayed(...)`
    method. This recipe illustrates a simple approach for such cases where we do not
    wish to immediately start playing a sound.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try this with two audio clips that are several seconds long. We have included
    two free music clips inside the `04_04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To schedule a sound to play after a given delay, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **GameObject** in the scene containing an **AudioSource** component
    linked to the **Pacman Opening Song** **AudioClip**. This can be done in a single
    step by dragging the music clip from the Project panel into either the **Hierarchy**
    or **Scene** panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step to create another **GameObject**, containing an **AudioSource**
    linked to the Pacman Dies clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both **AudioSources** created, uncheck the Play Awake property – so these
    sounds do not begin playing as soon as the scene is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Button** named **Button-music** on the screen, changing its text
    to Play Music Immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Button** named **Button-dies** on the screen, changing its text
    to Play Dies Sound After 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty **GameObject** named SoundManager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, DelayedSoundManager, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the SoundManager **GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the Button-music **GameObject** selected in the Hierarchy panel, create
    a new on-click event-handler, dragging the SoundsManager **GameObject** into the
    Object slot, and selecting the ACTION_PlayMusicNow() method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Button-dies GameObject selected in the Hierarchy panel, create a new
    on-click event-handler, dragging the SoundsManager GameObject into the Object
    slot, and selecting the ACTION_PlayDiesSoundAfterDelay() method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You add two **GameObjects** to the scene, containing `AudioSources` linked to
    music and dying sound clips. You created a C# script class, `DelayedSoundManager`,
    and added an instance to an empty **GameObject**. You associated the two AudioSources
    in your **GameObjects** with the two public variables in your scripted component.
  prefs: []
  type: TYPE_NORMAL
- en: 'You created two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Button-music, with a click action to invoke the `DelayedSoundManager.ACTION_PlayMusicNow()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button-dies, with a click action to invoke the `DelayedSoundManager.PlayDiesSoundAfterDelay()`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DelayedSoundManager.ACTION_PlayMusicNow()` method immediately sends a Play()
    message to the audio source linked to the **Pacman Opening Song AudioClip**. However,
    the `DelayedSoundManager.PlayDiesSoundAfterDelay()` method sends a PlayDelayed(...)
    message to the audio source linked to the **Pacman Dies AudioClip**, passing a
    value of 1.0, making Unity wait 1 second before playing the sound clip.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing an Audio Clip from restarting if it is already playing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a game, there may be several different events that cause a particular sound
    effect to start playing. If the sound is already playing, then in almost all cases,
    we won't wish to restart the sound. This recipe includes a test, so that an Audio
    Source component is only sent a `Play()` message if it is currently not playing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try this with any audio clip that is one second or longer in duration. We have
    included the engineSound audio clip inside the `04_05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prevent an **AudioClip** from restarting, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the sound clip file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the `AudioClip engineSound`. This can be done in a single step by dragging
    the music clip from the Project panel into either the Hierarchy or Scene panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play Awake property for the **AudioSource** component of the engineSound GameObject –
    so this sound does not begin playing as soon as the scene is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI button named **Button-play-sound**, changing its text to Play Sound.
    Position the button in the center of the screen by setting its Rect **Transform**
    property position to middle-center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, `WaitToFinishBeforePlaying`, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the Main Camera GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With Main Camera selected in the **Hierarchy** panel, drag engineSound into
    the Inspector panel for the public Audio Source variable, and drag the Text child
    of Button-play-sound for the public ButtonText.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Button-play-sound selected in the Hierarchy panel, create a new on-click
    event-handler, dragging the Main Camera into the Object slot, and selecting the
    `ACTION_PlaySoundIfNotPlaying()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Audio Source** components have a public readable property, **isPlaying**,
    which is a Boolean true/false flag, indicating whether the sound is currently
    playing. In this recipe, the text of the button is set to display Play Sound when
    the sound is not playing, and (`sound playing`) when it is. When the button is
    clicked, the `ACTION_PlaySoundIfNotPlaying()` method is called. This method uses
    an `if` statement, ensuring that a `Play()` message is only sent to the Audio
    Source component if its **isPlaying** is false, and updates the button''s text
    as appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Waiting for the audio to finish playing before auto-destructing an object*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for the audio to finish playing before auto-destructing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event may occur (such as an object pickup or the killing of an enemy) that
    we wish to notify to the player of by playing an audio clip, and an associated
    visual object (such as an explosion particle system, or a temporary object in
    the location of the event). However, as soon as the clip has finished playing,
    we will want the visual object to be removed from the scene. This recipe provides
    a simple way to link the ending of a playing audio clip with the automatic destruction
    of its containing object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try this with any audio clip that is a second or more in duration. We have included
    the `engineSound` audio clip inside the `04_06` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To wait for audio to finish playing before destroying its parent GameObject,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the sound clip file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the **AudioClip** **engineSound**. This can be done in a single step by dragging
    the music clip from the Project panel into either the **Hierarchy** or **Scene**
    panels. Rename this the AudioObject GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play Awake property for the AudioSource component of the **GameObject**
    engineSound – so this sound does not begin playing as soon as the scene is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, `AudioDestructBehaviour`, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the AudioObject GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Inspector** panel, disable (uncheck) the `AudioDestructBehaviour`
    scripted component of AudioObject (when needed, it will be re-enabled via C# code):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea58c4f8-5e25-4d9e-9dbc-1584ab99cb18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class, `ButtonActions`, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the Main Camera
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With Main Camera selected in the **Hierarchy** panel, drag AudioObject into
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the **Inspector** panel for the public Audio Source variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With Main Camera selected in the **Hierarchy** panel, drag AudioObject into
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the **Inspector** panel for the public Audio Destruct Scripted Object variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a UI button named **Button-play-sound**, changing its text to Play Sound.
    Position the button in the center of the screen by setting its **Rect Transform**
    property to middle-center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Button-play-sound selected in the **Hierarchy** panel, create a new on-click
    event-handler, dragging the Main Camera into the Object slot, and selecting the
    `ACTION_PlaySound()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second UI button named Button-destroy-when-finished-playing, changing
    its text to Destroy When Sound Finished. Position the button in the center of
    the screen (just below the other button) by setting its **Rect Transform** property
    to middle-center and then drag the button down a little.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Button-destroy-when-finished-playing selected in the **Hierarchy** panel,
    create a new on-click event-handler, dragging the Main Camera into the Object
    slot, and selecting the `ACTION_ DestroyAfterSoundStops()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. Clicking the Play Sound button will play the engine sound each
    time. However, once the Destroy When Sound Finished button has been clicked, as
    soon as the engineSound finished playing, you'll see the AudioObject GameObject disappear
    from the **Hierarchy** panel, since the GameObject has destroyed itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a ButtonActions script class and added an instance as a component
    to the Main Camera **GameObject**. This has two public variables, one to an **AudioSource**
    and one to an instance of the AudioDestructBehaviour scripted component.
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject named **AudioObject** contains an **AudioSource** component,
    which stores and manages the playing of the audio clip. **AudioObject** also contains
    a scripted component, which is an instance of the `AudioDestructBehaviour` class.
    This script is initially disabled. When enabled, every frame in this object (via
    its `Update()` method) tests whether the audio source is playing (`!audio.isPlaying`).
    As soon as the audio is found to be not playing, the GameObject is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: There are two UI buttons created. The **Button-play-sound** button calls the
    `ACTION_PlaySound()` method of the scripted component in **Main Camera**. This
    method will start playing the audio clip, if it is not already playing.
  prefs: []
  type: TYPE_NORMAL
- en: The second button, **Button-destroy-when-finished-playing**, calls the `ACTION_``DestoryAfterSoundStops()` method
    of the scripted component in Main Camera. This method enables the **AudioDestructBehaviour** scripted
    component in the **AudioObject** GameObject – so that the **AudioObject GameObject** will
    be destroyed, once its **AudioSource** sound has finished playing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Preventing an Audio Clip from restarting if it is already playing* recipe
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a metronome through the precise scheduling of sounds with dspTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In cases where we need precise scheduling of when sounds play, we should use
    the `AudioSource.PlayScheduled(...)` method. This method uses the `AudioSettings.dspTime`
    value, which is highly accurate based on the playing of music data through the
    Unity audio system. Another advantage of the `dspTime` value is that is it independent
    of the graphical rendering frame rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14fad81a-0b48-4ccc-bb69-4fa176b67d3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `dspTime` value is automatically frozen when a game is paused
    or suspended – so music scheduled using this approach will pause and resume flawlessly
    along with the scene gameplay. In this recipe, we'll create a metronome by precisely
    scheduling when two different sounds will play. Note that this recipe is based
    on some examples from the Unity documentation for the `AudioSource.PlayScheduled(...)`
    method: [https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided two metronome sound clips inside the `04_07`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To schedule a sound to play after a given delay, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project and import the provided sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the **metronome_tick AudioClip**. This can be done in a single step by dragging
    the music clip from the Project panel into either the **Hierarchy** or **Scene**
    panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step to create another GameObject, containing an **AudioSource**
    linked to the metronome_tick_accent clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both **AudioSources** created, uncheck the Play Awake property – so these
    sounds do not begin playing as soon as the scene is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty GameObject named MetronomeManager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, Metronome, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the MetronomeManager
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Select the MetronomeManager GameObject in the Hierarchy. Drag metronome_tick
    from the Hierarchy into the **Inspector** Audio Source Tick Basic public variable,
    for the Metronome (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag metronome_tick_accent from the Hierarchy into the Inspector Audio Source
    Tick Accent public variable, for the Metronome (Script) component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd68dae0-aece-415a-b050-2e78d38f168e.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the scene. You will see (in the Console) and hear the regular metronome
    sounds, with the first beat of each count playing the accented (and louder) sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try changing the Bpm (beats per minute) setting, to speed up or slow down the
    metronome. Or change the number of Beats Per Measure, to count up to 3, 4, or
    6 beats between each accented beat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You add to the scene two GameIObjects, containing AudioSources linked to music
    clips for a basic and an accented metronome "tick." You created a Metronome C#
    script class and added an instance to an empty GameObject. You associated the
    two AudioSources in your GameObjects with the two public variables in your scripted
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method calculates the duration of each beat (based on bpm), initializes
    the beat count (so the first beat is an accented beat), and then sets `nextTickTime`,
    the time for the next tick to the current dspTime.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsNearlyTimeForNextTick()` method returns a Boolean true/false value indicating
    if it is nearly time to schedule the next tick. The value returned is based on
    whether the current `dspTime` is within 1/10^(th) of a second of the value of
    `nextTickTime`. If so, then true is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method is a single if statement. If it's nearly time for the
    next beat, the `BeatAction()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BeatAction()` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds 1 to the number of beats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes the accentMessage string to be empty (the default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IF:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the next beat should be 1 (the accent), AccentBeatAction() and the string returned
    are stored in accentMessage
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ELSE (if not accent next beat):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the basic beat sound is scheduled
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next beat time is calculated (current beat time + duration of each beat)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It displays the beat count message in Console (including the string for any
    accent message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The AccentBeatAction() method does three things: it schedules the accented
    beat sound, it resets the beat count to 1, and it returns a string to be shown
    with the beat message (with text to indicate an accent beat is next: -- ACCENT
    ---).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Creating just-in-time AudioSource GameObjects for the basic and accented beats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can reduce the Design-Time work for the metronome by making use of the Extension
    method presented in the *Creating just-in-time AudioSource components at runtime
    through C# scripting* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the `ExtensionMethods.cs`  C# script class into your metronome
    project. Next, delete the two GameObjects in the scene containing **AudioSource**
    components, and instead declare two public variables for each `AudioClip ()`.
    Finally, we just need to write an `Awake()` method that will create the required
    GameObjects in the scene containing **AudioSource** basic on the **AudioClip**
    variables (and making the basic beat quieter than the accented one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating beat sounds through data rather than AudioClips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity documentation about `dspTime` provides an interesting approach to
    creating the basic and accented beats for a metronome – though editing the audio
    data samples themselves. Check out their scripted metronome at [https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html](https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html).
  prefs: []
  type: TYPE_NORMAL
- en: Matching the audio pitch to the animation speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many artifacts sound higher in pitch when accelerated and lower when slowed
    down. Car engines, fan coolers, a record player... the list goes on. If you want
    to simulate this kind of sound effect in an animated object that can have its
    speed changed dynamically, follow this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need an animated 3D object and an audio clip. Please
    use the `animatedRocket.fbx` and `engineSound.wav` files, available in the `04_08`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To change the pitch of an audio clip according to the speed of an animated
    object, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Models folder in the Project panel, and into this import the provided
    animatedRocket.fbx file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sounds folder in the Project panel, and into this Import the provided
    audio clip, engineSound.wav.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the animatedRocket file in the Project panel. In the Inspector for animatedRocket
    Import Settings, click the Animations button. In Animations select (the only) Take
    001 clip, and make sure to check the Loop Time option. Click on the Apply button
    to save the changes. See the screenshot for these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/287379b6-8649-4823-9ee6-d6dbd243f51d.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason we didn't need to check **Loop Pose** option is because our animation
    already loops in a seamless fashion. If it didn't, we could have checked that
    option to automatically create a seamless transition from the last to the first
    frame of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of `animatedRocket` as a GameObject in the scene by dragging
    it from the **Project** panel into the Scene or **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an AudioSource component to the engineSound GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With engineSound selected in the **Hierarchy**, drag the engineSound AudioClip
    file from the **Project** panel into the **Inspector** for the **Audio Clip**
    parameter of the Audio Source component. Ensure the Loop option is checked, and
    the Play On Awake option is unchecked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76e48ab6-4c24-4282-a9ed-7f01865ee829.png)'
  prefs: []
  type: TYPE_IMG
- en: Create an Animator Controller for our model. Select the Models folder in the
    Project panel, and use the Create menu to create a new **Animator** Controller
    file named Rocket Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the Rocket Controller file in the Project panel to open the **Animator**
    panel. Create a new state by choosing menu option: Create State | Empty (as shown
    in the screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0851aa59-05c6-44b6-a4dd-671a7322b5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rename this new state spin (in its **Inspector** properties), and set Take
    001 as its motion in the Motion field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3bc6c09-492f-46a9-9f72-e6a5830cfb12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select animatedRocket in the **Hierarchy** panel. Drag Rocket Controller from
    the `Models` folder in the Project panel into the Controller parameter for the
    Animator component in the **Inspector**. Ensure that the Apply Root Motion option
    is unchecked in the **Inspector**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d01c174-4d66-42a1-b905-887aba4211fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class, `ChangePitch`, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the `animatedRocket`
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Play the scene and change the animation speed by pressing number key 1 (accelerate)
    and 2 (decelerate) on your keyboard. The audio pitch will change accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a C# script class, **ChangePitch**, and added an instance to the **animatedRocket**
    GameObject. It declares several variables, the most important of which is `acceleration`.
  prefs: []
  type: TYPE_NORMAL
- en: It's `Awake()` method caches references to the Animator and **AudioSource**
    sibling components. The `Start()` method sets the initial speed from the **Animator**,
    and calls the `AccelerateRocket(...)` method, passing 0 to calculate the resulting
    pitch for the Audio Source.
  prefs: []
  type: TYPE_NORMAL
- en: In each frame, the Update() method tests for keyboard keys 1 and 2\. When detected,
    they call the `AccelerateRocket(...)` method, passing a positive or negative value
    of acceleration as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The `AccelerateRocket(...)` method increments variable speed with the received
    argument. The `Mathf.Clamp()` command limits the new speed value between the minimum
    and maximum speed. Then, it changes the **Animator** speed and **Audio Source**
    pitch according to the new speed absolute (positive) value. The value is then
    clamped a second time to avoid negative numbers. If you wish to reverse the animation,
    check out the code files in the solution provided for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that setting the animation speed, and therefore the sound pitch,
    to 0 will cause the sound to stop, making it clear that stopping the object's
    animation also prevents the engine sound from playing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is some information on how to fine-tune and customize this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Animation/Sound Ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want the audio clip pitch to be more or less affected by the animation
    speed, change the value of the public Animation/Sound Ratio parameter in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the function from other scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AccelerateRocket(...)` function was made public so that it can be accessed
    from other scripts. As an example, we have included the `ExternalChangePitch.cs`
    script in the `_Scripts` folder. To illustrate how the **ChangePitch** scripted
    component can be controlled form another script, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach this script to the **Main Camera** GameObject. Drag the **animatedRocket** GameObject
    from the Hierarchy into the public **Change Pitch Scripted Component** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *UP* and *DOWN* arrow keys to control the animation speed (and sound
    pitch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowing reverse animation (negative speeds!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Animator panel, create a new Float parameter, **Speed**, initialized
    to 1.0\. With state spin selected in the **Animator** panel, check the **Speed
    Parameter Multiplier** option and choose the **Speed** parameter. In the Inspector,
    set **Min Speed** to -2, to allow negative speeds for animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **ChangePitch** C# script, replace the **AccelerateRocket** method with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now when you use key 1 (accelerate) and 2 (decelerate), you can actually decelerate
    to zero and then continue to reverse the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating acoustic environments with Reverb Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created your level's geometry and the scene is looking just the
    way you want it to, you might want your sound effects to correspond to that look.
    Sound behaves differently depending upon the environment in which it is projected,
    so it can be a good idea to make it reverberate accordingly. In this recipe, we
    will address this acoustic effect by using Reverb Zones.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `ReverbZone.unitypackage` file, containing
    a basic level named **reverbScene** and a prefab, Signal. The package can be found
    in the `04_09` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to simulate the sonic landscape of a tunnel:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided **Unity** package, **ReverbZone**, into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project panel, open **reverbScene** – it's in the `_Scenes` folder
    in the `ReverbZones` folder. This scene gives you a tunnel, and a controllable
    character (*W A S D* keys and *Shift* to run).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Project panel, drag the Signal prefab into the Hierarchy – it''s in
    the `_Prefabs` folder in the `ReverbZones` folder. This will add a sound-emitting
    object to the scene. Place it in the center of the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5f6e601-504a-4af4-a12e-8db352f55463.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make five copies of the **Signal** GameObject and distribute them throughout
    the tunnel (leaving a copy just outside each entrance):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/496916f1-7221-4a49-b39c-60114dedfdd3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Hierarchy panel, use the **Create menu** | **Audio** | **Audio Reverb
    Zone** to add a **Reverb Zone** to the scene. Then place this new GameObjct in
    the center of the tunnel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use menu GameObject | Move To View if there is already a GameObject where you
    want to position another one. Since our Signal GameObject is in the middle of
    the tunnel, we can double-click that GameObject, then single-click Reverb Zone
    and move to view – to move the Reverb Zone object to the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Reverb Zone** GameObject. In the Inspector panel, change the **Reverb
    Zone** component parameters to these values: **Min Distance** = `6`, **Max Distance**
    = `18`, and **Preset** = `StoneCorridor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5bd41d25-65a8-4e4f-9c0b-266f32bf832b.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the scene. As you walk through the tunnel, you will hear the audio reverberate
    when inside the Reverb Zone area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once positioned, the Audio Reverb Zone applies an audio filter to all audio
    sources within its radius.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are more options for you to try.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the Audio Reverb Zone component to Audio Sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of creating an Audio Reverb Zone GameObject, you can attach it to the
    sound-emitting object (in our case, Signal) as a component through the **Component**
    | **Audio** | **Audio** **Reverb Zone** menu. In such cases, the Reverb Zone will
    be individually set up around its parent GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Making your own Reverb settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity comes with several **Reverb Presets**. We have used **StoneCorridor**,
    but your scene can ask for something less intense (such as Room) or more radical
    (such as Psychotic). If these presets still won't be able to recreate the effect
    that you have in mind, change it to User and edit its parameters as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Adding volume control with Audio Mixers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound-volume adjustment can be a very important feature, especially if your
    game is a standalone. After all, it can be very frustrating for players to have
    to access the **Operating System** volume control. In this recipe, we will use
    the Audio Mixer feature to create independent volume controls for Music and Sound
    FX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided a Unity package named `VolumeControl.unitypackage`,
    containing an initial scene featuring soundtrack music and sound effects. The
    file is available inside the `04_10` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add volume control sliders to your scene, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided **Unity** package, **Volume**, into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Volume** scene from **Project** panel folder, **VolumeControl** |
    `_Scenes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the scene and walk toward the semitransparent green wall in the tunnel,
    using the *W A S D* keys (press *Shift* to run). You will be able to listen to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A looping music soundtrack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bells ringing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A robotic speech whenever the character collides with the wall
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Project** panel, use the Create menu to add an **Audio Mixer** file.
    Rename this new file MainMixer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click MainMixer to open the **Audio Mixer** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the the **Audio Mixer** panel **Groups** section, highlight **Master** and
    click the + (plus) sign to add a child to the **Master** group. Name this child
    **Music**. Repeat these actions to add a second child of **Master** named FX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e196b5d-9e9f-481b-81dc-4c86d2caf4e2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the the Audio Mixer panel Mixers section, highlight MainMixer and click the
    + (plus) sign to add a new item to the Mixers group. Rename this MusicMixer (you
    may need to rename this via the Project panel, since you've created a new Audio
    Mixer file through this process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag MusicMixer onto MainMixer (child it), and select Music as its output in
    the pop-up dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the the **Audio Mixer** panel Mixers section, highlight **MainMixer** and
    click the + (plus) sign to add a new item to the **Mixers** group. Name this **FxMixer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Child (drag) **FxMixer** onto **MainMixer**, and select Fx as its output in
    the pop-up dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select MusicMixer. Select its Master group and add a child named Soundtrack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **FxMixer** and add two children to its **Master** group: one named
    Speech, and another named Bells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbb0f356-94dd-44f5-95cf-cfd45f3d0948.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the **DialogueTrigger** GameObject in the **Hierarchy**. In the **Inspector**,
    change its **Audio Source** component Output track to **FxMixer** | **Speech**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7707cd89-f690-4463-bfe7-ef346b642c88.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Soundtrack** GameObject in the **Hierarchy**. In the **Inspector**,
    change its Audio Source component **Output** track to **MusicMixer** | **Soundtrack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Signal** from the `Prefabs` folder in the **Project** panel. In the
    **Inspector**, change its Audio Source component Output track to FxMixer | Bells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **MainMixer** in the **Audio Mixer** panel, and select its **Master**
    track. In the **Inspector** panel, right-click on Volume in the **Attenuation**
    component. From the pop-up-context menu, select **Expose** **Volume** (of Master)
    to script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dde7821-a2ce-4bb1-b8af-89bccd79ce27.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the operation to expose the **Volume** to scripts for both the **Music**
    and FX Groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top-right of the **Audio Mixer** panel, you should see **Exposed Parameters**
    (three). Click the drop-down icon, and rename them as follows: MyExposedParam
    to OverallVolume; MyExposedParam1 to MusicVolume, and MyExposedParam2 to FxVolume.
    Note the sequence of the three parameters may not match the order you added them,
    so double-check that the greyed-out track names on the right correspond correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5337a07a-2550-47f3-854a-05d204563484.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Hierarchy** panel, use the **Create** drop-down menu to add a **UI
    Panel** to the scene (menu: **Create** | **UI** | **Panel**). Unity will automatically
    add a Canvas parent for this panel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, create a UI Slider to the scene (menu: **Create**
    | **UI** | **Slider**). Make it a child of the **Panel** object. Rename this slider
    as **Slider-overall**. Set the slider''s Min Value to `0.000025` (or `2.5e-05`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate it and rename the new copy to Slider-music. In the **Inspecto**r panel,
    **Rect Transform** component, change its Pos Y parameter to `-40`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Duplicate Slider-music and rename the new copy to **Slider-fx**. Change its
    **Pos Y** parameter to `-70`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/350f4d6a-fd4c-4b39-8456-96e54abbf58f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class, **VolumeControl**, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the **Main
    Camera** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With **Main Camera** selected in the **Hierarchy** panel, drag the **Panel**
    GameObject into the Inspector for the public Panel variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Main Camera** selected in the **Hierarchy** panel, drag **MainMixer**
    from the Project panel into the **Inspector** for the public My Mixer variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OverallSlider** component. Below the **On Value Changed** list,
    click the + sign to add an action. From the **Hierarchy** panel, drag Main Camera
    into the Object slot and using the drop-down menu, choose VolumeControl | ON_CHANGE_OverallVol
    option.  For testing purposes, change the appropriate selector from Runtime Only
    to Editor and Runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step with MusicSlider and FxSlider, but this time, choose
    the ON_CHANGE_MusicVol and ON_CHANGE_FxVol options, respectively, from the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene. You will be able to access the sliders when pressing *ESCAPE*
    on your keyboard and adjust volume settings from there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Audio Mixer** feature works in a similar fashion to **Digital Audio Workstations**,
    such as **Logic** and **Sonar**. Through Audio Mixers you can organize and manage
    audio elements by routing them into specific groups that can have individual audio
    tracks you can tweak, allowing adjustments in volume level and sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: By organizing and routing our audio clips into two groups (Music and FX), we
    established MainMixer as a unified controller for volume. Then, we used the Audio
    Mixer to expose the volume levels for each track of **MainMixer**, making them
    accessible to our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have set up a basic UI featuring three sliders that, when in use,
    will pass their float values (between 0.000025 and 1) as arguments to three specific
    functions in our script: ON_CHANGE_MusicVol, ON_CHANGE_FxVol, and ON_CHANGE_OverallVol.
    These functions, on their turn, use the SetFloat command to effectively change
    the volume levels at runtime. However, before passing on the new volume levels,
    the script converts linear values (between 0.000025 and 1) to the decibel levels
    that are used by the Audio Mixer. This conversion is calculated through the log(x)
    * 20 mathematical function.'
  prefs: []
  type: TYPE_NORMAL
- en: For a full explanation on issues regarding the conversion of linear values to
    decibel levels and vice-versa, check out Aaron Brown's excellent article at [http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/](http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the sliders seems not to work, double-check that the name of the
    first parameter to `SetFloat(...)` matches the exposed parameter in the **AudioMixer** –
    any spelling difference will mean the on-change function will not change values
    in the **Audio Mixer**. For example, if the named exposed parameter was wrongly
    named "**OveralVolume**" (missing an "l"), this statement in response to a slider
    change would not work due to the spelling mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `VolumeControl` script includes code to enable and disable the UI and the
    **EventSystem**, depending upon whether the player hits the *ESCAPE* key to activate/deactivate
    the volume-control sliders.
  prefs: []
  type: TYPE_NORMAL
- en: Since our VolumeControl script sets the maximum volume level for the music and
    Fx tracks, you should not manually change any of the track volumes of the MainMixer
    at Design-Time. For general adjustments, use the secondary MusicMixer and FxMixer
    mixers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is some extra information on Audio Mixers.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Audio Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many creative uses for exposed parameters. We can, for instance, add
    effects such as **Distortion**, **Flange**, and **Chorus** to audio channels,
    allowing users to operate virtual sound tables/mixing boards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *Balancing the in-game audio with Ducking* in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making a dynamic soundtrack with Snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic soundtracks are the ones that change according to what is happening
    to the player in the game, musically reflecting that place or moment of the character's
    adventure. In this recipe, we will implement a soundtrack that changes twice;
    the first time when entering a tunnel, and the second time when coming out of
    it. To achieve this, we will use the **Snapshot** feature of the **Audio Mixer**.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshots are a way of saving the state of your **Audio Mixer**, keeping your
    preferences for volume levels, audio effects, and more. We can access these states
    through C# scripting, creating transitions between mixes, and by bringing up the
    desired sonic ambience for each moment of the player's journey.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we have prepared a basic game level, contained inside the
    Unity package named `DynamicSoundtrack`, and two soundtrack audio clips in the `.ogg`
    format: `Theme01_Percussion` and `Theme01_Synths`. All these files can be found
    in the `04_11` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a dynamic soundtrack, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided Unity package, DynamicSoundtrack, and the two `.ogg` files
    into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Dynamic scene from **Project** panel folder, DynamicSoundtrack | _Scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, use the Create menu to add an Audio Mixer file. Rename
    this new file Mixer-music. Double-click it to open the Audio Mixer panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the the Audio Mixer panel Groups section, highlight Master and click the
    + (plus) sign to add a child to the Master group. Name this child Percussion.
    Repeat these actions to add a second child of Master, named Synths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce937ba3-ebb4-43d9-b076-7c6734a3f936.png)'
  prefs: []
  type: TYPE_IMG
- en: From the **Hierarchy** view, create a new **Empty** GameObject. Name it Music.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the Theme01_Percussion **AudioClip**. This can be done in a single step by
    dragging the music clip from the Project panel into either the **Hierarchy** or
    Scene panels. Child this new GameObject to the **Music** GameObject in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure the Theme01_Percussion GameObject is selected in the **Hierarchy**.
    In the Inspector for the **AudioSource** component, change its Output to Percussion
    (**MusicMixer**), make sure the **Play On Awake** option is checked, check the
    **Loop** option, and make sure its **Spatial Blend** is set to 2D:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc2c2792-bde9-4a45-a330-ca278dc289f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the previous two steps for the Theme01_Synths **AudioClip** – setting
    the **Output** to Synths (**MusicMixer**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Audio Mixer** and play the scene. We will now use the mixer to set
    the soundtrack for the start of the scene. With the scene playing, click on the
    **Edit** in Play Mode button, as shown in the screenshot, at the top of the **Audio
    Mixer**. Drop the volume on the **Synths** track down to **-30 dB**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa270b68-b74b-450d-80ab-68824bd8e401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Percussion track. Click the Add.. button for **Attenuation**, and
    add a **High-pass** effect. From the **Inspector** view, change the **Cutoff**
    frequency of the **High-pass** effect to **544.00 Hz**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c15d7736-a7f2-466f-ab6c-3146f255afd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Every change, so far, has been assigned to the current Snapshot. From the Snaphots
    view, right-click on the current Snapshot and rename it to Start. Click the +
    (plus) sign to make a copy of the current snapshot, rename this copy Tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7adeff53-424e-4a1d-8e8f-e1d64ea92857.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the **Tunnel** snapshot and select the **High-pass** effect of the Percussion
    group. In the Inspector, set property **Cutoff frequency** of **10.00** Hz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b25d80c-50cc-4fe4-bc07-db9ae098fe53.png)'
  prefs: []
  type: TYPE_IMG
- en: Switch between the **Tunnel** and Start snapshots. You'll be able to hear the
    difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **Tunnel** snapshot, rename it **OtherSide**, and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise the volume of the **Synths** track up to 0 dB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our three **Snapshots**, it's time to create triggers to make
    transitions among them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop running the scene (so changes to the **Hierarchy** will be stored in the
    scene).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy**, create a **Cube** GameObject (menu: **Create** | **3D
    Object** | **Cube**). Name it Cube-tunnel-trigger.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Inspector, access the Cube-tunnel-trigger GameObject''s Box Collider
    component and check the **Is Trigger** option. Uncheck its **Mesh Renderer** component.
    Adjust its size and position to the scene tunnel''s interior. You may find Scene
    Wireframe view useful for the cube collider positioning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a23204bd-a7d1-470e-ad44-2a000deabb13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make two copies of cube Cube-tunnel-trigger and rename them to cube Cube-start-trigger
    and cube Cube-otherside-trigger. Adjust their size and position, so that they
    occupy the areas before the tunnel''s entrance (where the character is) and after
    its exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98f42182-da98-42a3-b7e3-181c33041b26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class, `SnapshotTrigger`, in the _Scripts folder, containing
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add an instance of `SnapshotTrigger` to all three trigger cubes (Cube-tunnel-trigger,
    Cube-start-trigger, and Cube-otherside-trigger).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Cube-tunnel-trigger. From the **Inspector** for the Snapshot Trigger
    (Script) component, set Snapshot to **Tunnel**, and **Crossfade** as 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ab0df2e-e1ac-44f5-bf68-3f45524941ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Make changes to **Cube-start-trigger** and **Cube-otherside-trigger** by setting
    their **Snapshots** to **Start** and **OtherSide**, respectively – also with **Crossfade**
    as `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene. The background music will change as the character moves from
    the starting point, through the tunnel, and out the other side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Snapshot feature allows you to save **Audio Mixer** states (including all
    volume levels and every filter setting) so that you can change those mixing preferences
    at **Run-Time**, making the audio design more suitable for specific locations
    or gameplay settings. For this recipe, we have created three **Snapshots** for
    different moments in the player''s journey:'
  prefs: []
  type: TYPE_NORMAL
- en: Before entering the tunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the tunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the tunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the **Highpass** filter to make the initial **Snapshot** less intense.
    We have also turned the Synths track volume up to emphasize the open environment
    outside the tunnel. Our aim is for the changes in the audio mix to help set the
    right mood for the game.
  prefs: []
  type: TYPE_NORMAL
- en: To activate our snapshots, we have placed **trigger** colliders, featuring our
    **Snapshot Trigger** scripted component in which we set the desired Snapshot and
    the time in seconds, that it takes to make the transition (a crossfade) between
    the previous Snapshot and the next. In fact, the function in our script is really
    this straightforward – the line of `snapshot.TransitionTo (crossfade)` code simply
    starts a transition lasting `crossfade` seconds to the desired Snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is some information on how to fine-tune and customize this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the need for multiple audio clips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed how different the `Theme01_Percussion` audio clip sounds
    when the **Cutoff frequency** of the **High-pass** filter is set as `10.00 Hz`.
    This is because the high-pass filter, as its name suggests, cuts off lower frequencies
    of the audio signal. In this case, it attenuated the bass drum down to inaudible
    levels while keeping the shakers audible. The opposite effect can be achieved
    through the **Lowpass** filter. A major benefit is
  prefs: []
  type: TYPE_NORMAL
- en: the opportunity to have two separate tracks in the same audio clip.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with audio file formats and compression rates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid a loss of audio quality, you should import your sound clips using the
    appropriate file format, depending upon your target platform. If you are not sure
    which format to use, check out Unity's documentation on the subject at [http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html).
  prefs: []
  type: TYPE_NORMAL
- en: Applying Snapshots to background noise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have applied Snapshots to our music soundtrack, background noise
    can also benefit immensely. If your character travels across places that are significantly
    different, transitioning from open spaces to indoor environments, you should consider
    applying snapshots to your environment audio mix. Be careful, however, to create
    separate **Audio Mixers** for Music and Environment – unless you don't mind having
    musical and ambient
  prefs: []
  type: TYPE_NORMAL
- en: sound tied to the same Snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting creative with effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have mentioned the High-pass and Low-pass filters. However,
    there are many effects that can make audio clips sound radically different. Experiment!
    Try applying effects such as Distortion, Flange, and Chorus. In fact, we encourage
    you to try every effect, playing with their settings. The creative use of these
    effects can bring out different expressions to a single audio clip.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding volume control with Audio Mixers* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *Balancing soundtrack volume with Ducking* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing in-game audio with Ducking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as the background music can be important in establishing the right atmosphere,
    there will be times when other audio clips should be emphasized, and the music
    volume turned down for the duration of that clip. This effect is known as **Ducking**.
    Maybe you will need it for dramatic effect (simulating hearing loss after an explosion
    took place), or maybe you want to make sure that the player listens to a specific
    bit of information presented as an audio speed sound clip. In this recipe, we
    will learn how to emphasize a piece of dialog by ducking the audio whenever a
    specific sound message is played. For that effect, we will use the **Audio Mixer**
    to send information between tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided the `soundtrack.mp3` audio clip and a Unity
    package named Ducking.unitypackage, containing an initial scene. All these files
    are available inside the `04_12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To apply Audio Ducking to your soundtrack, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Unity 3D** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided **Unity** package,**Ducking**, and the `soundtrack.mp3`
    file into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Ducking scene from **Project** panel folder, **Ducking** | `_Scenes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter Run-Time by playing the scene and walk toward the semitransparent green
    wall in the tunnel, using the *W, A, S,* and *D* keys (by pressing *Shift* to
    run). You will hear the robotDucking speech audio clip play as the character collides
    with the green wall ("This your captain speaking ..."). Then stop the scene playing
    to return to Design-Time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **GameObject** in the scene containing an **AudioSource** component
    linked to the soundtrack **AudioClip**. This can be done in a single step by dragging
    the music clip from the **Project** panel into either the **Hierarchy** or **Scene**
    panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the GameObject soundtrack is selected in the **Hierarchy**. In the **Inspector**
    for the **Audio Source** component, make sure the Play On Awake option is checked,
    check the Loop option, and make sure its **Spatial Blend** is set to 2D (if necessary,
    see screenshot in the previous recipe for same action on the percussion GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene again. The soundtrack music should be playing. Then stop the
    scene playing to return to **Design-Time**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, use the **Create** menu to add an **Audio Mixer**
    file. Rename this new file **MainMixer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click **MainMixer** to open the **Audio Mixer** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the the **Audio Mixer** panel Groups section, highlight **Master** and click
    the + (plus) sign to add a child to the **Master** group. Name this child Music.
    Repeat these actions to add a second child of Master, named FX. Add a third child
    to the **Master** group, named Input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51d8ac5b-84a1-4b63-b141-44ca6296f723.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Audio Mixers view, add a new **Mixer** by clicking the + (plus) sign
    to add a new **Mixer** to the project. Name it **MusicMixer**. Drag it into the
    **MainMixer** (to become its child) and select the Music group as its Output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68ad76d8-b80d-4153-b6f2-d8c360d9e46e.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the previous step to add another child of **MainMixer**, named **FxMixer**,
    to the project, selecting the FX group as the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **MusicMixer**. Select its **Master** group and add a child named `Soundtrack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2cd38a48-a015-46ba-a2d4-2acdf2c61858.png)'
  prefs: []
  type: TYPE_IMG
- en: Select **FxMixer** and add a child named **Bells**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Hierarchy** view, select the **DialogueTrigger GameObject**. In
    the **Inspector**, change the Output track to **MainMixer** | **Input**, for the **Audio
    Source** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/865c010c-bab9-49db-9a42-17ca978e8453.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Soundtrack** GameObject. In the **Inspector** for the **Audio**
    **Sourc**e component, change its Output track to **MusicMixer** | **Soundtrack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Ducking** | **Prefabs** folder in the Project panel, select the Signal
    prefab. In the Inspector, set its **Audio Source** component **Output** to **FxMixer**
    | **Bells**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Audio Mixer** window. Choose **MainMixer**, select the Music track
    controller, right-click on **Attenuation**, and using the context menu, add the
    **Duck Volume** effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25a69c10-a7ae-4764-8e71-4ce0aeae78da.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Input track, right-click on **Attenuation**, and using the context
    menu, add **Send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Input track still selected, go to the **Inspector** view and change
    the Receive setting in **Send** to **Music\Duck** Volume and its **Send** level
    to 0.00 db.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Music** track. From the Inspector view, change the settings on
    the **Duck Volume** as follows: **Threshold**: `-``40.00 db`, **Ratio**: `300.00%`, **Attack**
    **Time**: `100.00 ms`, **Release Time**: `200.00 ms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a0ca160-25e9-43c5-a513-b028d1bf447c.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the scene again. Entering the trigger object will cause the soundtrack
    volume to drop considerably, recovering the original volume in two seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have created, in addition to Music and Sound FX, a group
    named Input, to which we have routed the audio clip that triggers the Duck Volume
    effect attached to our music track. The Duck Volume effect changes the track's
    volume whenever it receives an input that is louder than indicated in its Threshold
    setting. In our case, we have sent the Input track as input, and adjusted the
    settings so the volume will be reduced as soon as 0.1 seconds after the input
    had been received, turning back to its original value of 2 seconds after the input
    has ceased. The amount of volume reduction was determined by our Ratio of 300.00%.
    Playing around with the setting values will give you a better idea of how each
    parameter affects the final result. Also, make sure to visualize the graphic as
    the trigger sound is played. You will be able to see how the Input sound passes
    the threshold, triggering the effect.
  prefs: []
  type: TYPE_NORMAL
- en: The tracks are organized so that the other sound clips (other than speech) will
    not affect the volume of the music – but every music clip will be affected by
    audio clips sent to the input track.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding volume control with Audio Mixers* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Audio visualization from sample spectral data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity audio systems allows us to access the music data – via the `AudioSource.GetSpectrumData(...)`
    method. This gives us the opportunity to use that data to present Run-Time visualization
    of the overall sound being heard (from the **AudioListener**), or the individual
    sound being played by individual **AudioSources**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot shows lines drawn using a sample script provided by Unity ([https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html](https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09aa10c3-5f54-420d-a202-25edf5fcf4a6.png)'
  prefs: []
  type: TYPE_IMG
- en: However, in that sample code, their use of `Debug.DrawLine()` only appears in
    the Scene panel when running the game in the Unity Editor (not for final builds),
    and so cannot be seen by the game player. In this recipe, we'll take that same
    spectral data, and use it to create a **Run-Time** audio spectral visualization
    in the Game panel. We'll do this by creating a row of 512 small cubes, and then
    changing their heights each frame based on 512 audio data samples for the playing
    **AudioSource** component.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided several 140 bmp sampled free music clips inside
    the `04_13` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To schedule a sound to play after a given delay, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project and import the provided sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, set the Background of the Main Camera to black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Main Camera Transform Position to (224, 50, -200).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Main Camera Camera component to have these settings: Projection = Perspective,
    Field of View 60, and Clipping Planes 0.3 - 300.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **DirectionalLight** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new empty GameObject named visualizer to the scene. Add an **AudioSource**
    component to this GameObject, and set its **AudioClip** to one of the 140 bmp
    loops provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, **SpectrumCubes**, in a new folder, _Scripts, containing
    the following code, and add an instance as a scripted component to the visualizer
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the visualizer GameObject selected in the **Hierarchy**, click to choose
    a visualization color from the **Inspector Display Color** public variable for
    the **SpectrumCubes** (Script) component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene – you should see the cubes jump up and down, presenting a Run-Time
    visualization of the sound data spectrum for the playing sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a C# script class, `SpectrumCubes`. You created a GameObject with
    an **AudioSource** component, and an instance of your scripted class. All the
    work is done by the methods in the `SpectrumCues` C# script class, so each of
    these is explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The void Awake() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method caches references to the sibling **AudioSource** component, and
    then invokes the `CreateCubes()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The void CreateCubes() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method loops for the number of samples (default is 512), to create a 3D
    Cube GameObject, in a row along the X-axis. Each Cube is created with the name
    "Cube<i>" (where "i" is from 0 to 511) and then parented to the visualizer GameObject (since
    the scripted method is running in this GameObject). Each cube then has the color
    of its renderer set to the value of the public displayColor parameter. The cube
    is then positioned on the X-axis according to the loop number, at the value of
    the public startY parameter (so multiple visualizations can be at different parts
    of the screen), and Z = 0\. Finally, a reference to the new cube GameObject is
    stored in the cubes[] array.
  prefs: []
  type: TYPE_NORMAL
- en: The void Update() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each frame in this method updates the values inside the spectrum[] array through
    a call to `GetSpectrumData(...)`. In our example, the `FFTWindow.BlackmanHarris`
    frequency window technique is used. Then the `UpdateCubeHeights()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The void UpdateCubeHeights() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method loops for each cube to set its height to a scaled value of its corresponding
    audio data value in the `spectrum[]` array. The cube has its Y-value scaled by
    the value returned by the `HeightFromSample(spectrum[i])` method. The cube is
    then moved up (its transform position is set) from the value of `startY` by half
    its height – so that all the scaling appears upwards (rather than up and down) –
    this is to have a flat line along the base of our spectrum of cubes.
  prefs: []
  type: TYPE_NORMAL
- en: The float HeightFromSample(float) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method  `HeightFromSample(float)` does a simple calculation (sample value times
    public parameter multiplier), plus minimum value of two added to it. The value
    returned from the function is this result, limited to the maxHeight public parameter (via
    the `Mathf.Clamp(...)` method).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding visualizations to a second AudioSource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script has been written to be easy to have multiple visualizations in a
    scene. So to create a second visualizer for a second **AudioClip** in the scene,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the visualizer GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a different AudioClip from the **Project** panel into the **Audio Source**
    component of your new GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Start **Y** public parameter in the **Inspector** to 60 (so the new
    row of cubes will be above the original row).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector**, choose a different Display Color public variable for
    the **SpectrumCubes (Script)** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/987f9d56-391c-4727-aa15-b530eaaa2ad9.png)'
  prefs: []
  type: TYPE_IMG
- en: Try out different FFT (Fast Fourier Transform) window types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several different approaches to frequency analysis of audio data,
    our recipe currently uses the `FFTWindow.BlackmanHarris` version. Learn (and try
    out!) some of the others from the Unity `FFTWindow` documentation page: [https://docs.unity3d.com/ScriptReference/FFTWindow.html](https://docs.unity3d.com/ScriptReference/FFTWindow.html).
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop
    manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a metronome through the precise scheduling of sounds with* `dspTime` recipe
    demonstrated how to create a metronome by scheduling when sounds play using the `AudioSource.PlayScheduled(...)`
    method and the `AudioSettings.dspTime` value. Another situation when we need to
    precisely schedule audio start times is to ensure a smooth transition from one
    music track to another, or to ensure simultaneous music tracks play in time together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create a simple 4-track 140 bpm music manager that starts
    playing a new sound after a fixed time – the result of which is that the tracks
    fit together perfectly, and those that overlap do so in synchronicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47e24a71-b907-4ddf-9aab-99df2b36f208.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided several 140 bmp sampled free music clips inside
    the `04_14` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a music-loop manager, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project and import the provided sound clip files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create four GameObjects in the scene containing an **AudioSource** component
    linked to different **AudioClip** loops from the 140 bpm files provided. This
    can be done in a single step by dragging the music clip from the **Project** panel
    into either the **Hierarchy** or Scene panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, uncheck the **Play On Awake** parameter for all four **AudioSource**
    components (so they don't start playing until we tell them to).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new empty **GameObject** named **musicScheduler** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, **LoopScheduler**, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the **musicScheduler**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the **musicScheduler** GameObject selected in the **Hierarchy**, drag
    each of the music loop GameObjects into the four available slots for the **AudioSources**
    public array variable in the **Loop Scheduler (Script)** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7718015b-b831-4215-8b4f-8173a251bdea.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the scene – each clips should start in turn after the same time delay. If
    you chose one or two longer clips, they will continue playing while the next clip
    begins – all overlapping perfectly since they are all 140 bpm sound clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You added four **GameObjects** to the scene, containing **AudioSources** linked
    to 140 bpm music clips. You created a C# script class, `LoopScheduler`, and added
    an instance to an empty **GameObject**. You associated the four **AudioSources**
    in your **GameObjects** with the four slots in the public **AudioSource** array
    variable in your scripted component.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers of music clips you use can easily be changed by changing the size
    of the public array variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method counts the length of the array to set the `numLoops` variable.
    It then calculates the number of seconds to delay before starting each clip (this
    is fixed according to the beats-per-minute and beats-per-measure). Finally, it
    sets the current time to be the time to start the first loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method decides whether it's time to schedule the next loop, by
    testing whether the current time plus a 1-second look-ahead, is past the time
    to start the next loop. If so, the `StartNextLoop()` method is invoked. Regardless
    of whether we have started the next loop, the `PrintLoopPlayingStatus()` method
    to display to the user which loops are playing or not is printed to the Console.
  prefs: []
  type: TYPE_NORMAL
- en: The `PrintLoopPlayingStatus()` method loops for each **AudioSource** reference
    in the array, creating a string of trues and falses to be then printed out.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartNextLoop()` method sends a `PlayScheduled(...)` message to the next
    `AudioSource` to be played, passing the `nextEventTime` value. It then adds the
    time between plays for the next event time. The next value of the loop index is
    then calculated (add one, if past the end of the array, then reset to 0 again).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding visualizations to the four playing loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s great fun to watch the visualization of the loop sounds as they play
    together. To add visualizations to the four AudioSources, all you have to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the **SpectrumCubes.cs** C# script file from the previous recipe into
    this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Main Camera Transform Position to (224, 50, -200).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Main Camera Camera component** to have these settings: Projection
    = Perspective, Field of View 60, and Clipping Planes 0.3 - 300.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Directional Light GameObject** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the four **GameObjects** containing your **AudioSources**, add an
    instance of the **SpectrumCubes** script class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** for the **Spectrum Cubes (Script)** component, change the
    displayColors for each **AudioSource GameObject**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the startY values of Spectrum Cubes (Script) components for the four **GameObjects**
    to be -50, 0, 50, 100\. For most screen sizes, this should allow you too see all
    four visualization spectrums:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
