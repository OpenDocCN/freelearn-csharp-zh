- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Aspect-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: 'Throughout the book, you should have noticed a theme: automation. This means
    writing code that makes your code easier, more maintainable, and takes away repetitive
    work. In [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting
    Concerns*, we talked about code that could be created for a specific concern and
    be automatically applied. In this chapter, we will take this concept to the next
    level and dive into a formalization that is designed for this purpose; **aspect-oriented**
    **programming** (**AOP**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你应该已经注意到了一个主题：自动化。这意味着编写使你的代码更简单、更易于维护并消除重复工作的代码。在[*第13章*](B19418_13.xhtml#_idTextAnchor206)中，*应用横切关注点*，我们讨论了可以创建用于特定关注点的代码，并且可以自动应用。在本章中，我们将把这个概念提升到下一个层次，并深入探讨为此目的而设计的正式化；**面向方面**
    **编程**（**AOP**）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is AOP?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP是什么？
- en: Logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: Authorization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: By the end of this chapter, you should have a solid understanding of AOP and
    how it can be used in C# to create more modular, maintainable, and scalable applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对AOP及其如何在C#中用于创建更模块化、可维护和可扩展的应用程序有一个扎实的理解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14))
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14)），并且它建立在GitHub上找到的**基础**代码之上（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)）。
- en: What is AOP?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP是什么？
- en: In traditional programming, developers write code to implement the desired behavior
    of their applications. This code is organized into functions, classes, and modules
    that implement specific functionalities. However, many applications require additional
    functionality that spans multiple parts of the codebase, such as logging, error
    handling, and security. These functionalities, often referred to as cross-cutting
    concerns, can be difficult to manage and maintain when scattered throughout the
    codebase.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，开发者编写代码以实现应用程序所需的行为。这些代码被组织成函数、类和模块，以实现特定的功能。然而，许多应用程序需要跨越代码库多个部分的功能，例如记录、错误处理和安全。这些功能，通常被称为横切关注点，当它们散布在代码库中时，可能会难以管理和维护。
- en: AOP is a programming paradigm that aims to address this problem by separating
    cross-cutting concerns from the rest of the code. In AOP, developers define aspects,
    which encapsulate the behavior of cross-cutting concerns, and apply them to specific
    parts of the codebase using join points and pointcuts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AOP是一种编程范式，旨在通过将横切关注点从其余代码中分离出来来解决此问题。在AOP中，开发者定义方面，它们封装了横切关注点的行为，并使用连接点和切入点将它们应用于代码库的特定部分。
- en: AOP is very well suited in combination with other programming paradigms, such
    as **object-oriented programming** (**OOP**) and **functional programming** (**FP**),
    to create more modular, maintainable, and scalable applications. AOP has become
    increasingly popular in recent years, and there are many AOP frameworks available
    for various programming languages and platforms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AOP非常适合与其他编程范式结合使用，例如**面向对象编程**（**OOP**）和**函数式编程**（**FP**），以创建更模块化、可维护和可扩展的应用程序。近年来，AOP越来越受欢迎，并且有多个AOP框架可用于各种编程语言和平台。
- en: In this chapter, we will explore how AOP can be used in C# to address cross-cutting
    concerns and improve code maintainability and reusability. We will cover the key
    concepts of AOP, such as aspects, pointcuts, and join points, and show how they
    can be applied to specific use cases, such as security and logging. We will do
    so using a framework called Castle Windsor ([https://www.castleproject.org/projects/windsor/](https://www.castleproject.org/projects/windsor/)),
    and show how you use it to implement AOP in your C# applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用AOP在C#中解决横切关注点并提高代码的可维护性和可重用性。我们将介绍AOP的关键概念，如方面、切入点、连接点，并展示如何将它们应用于特定用例，例如安全和日志记录。我们将使用名为Castle
    Windsor的框架（[https://www.castleproject.org/projects/windsor/](https://www.castleproject.org/projects/windsor/））来完成这项工作，并展示如何将其用于实现C#应用程序中的AOP。
- en: Aspects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方面
- en: In AOP, an aspect is a modular unit of behavior that can be selectively applied
    to different parts of a program. An aspect is essentially a set of instructions
    that describe how to modify the behavior of a program in a particular way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向切面编程（AOP）中，方面是一个可以选择性应用于程序不同部分的行为模块单元。方面本质上是一组指令，描述了如何以特定方式修改程序的行为。
- en: Aspects are used to address cross-cutting concerns, which are concerns that
    span multiple parts of a program and cannot be encapsulated in a single module
    or class. Examples of cross-cutting concerns include logging, security, caching,
    and error handling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方面用于解决横切关注点，这些关注点跨越程序的多部分，不能封装在单个模块或类中。横切关注点的例子包括日志记录、安全、缓存和错误处理。
- en: An aspect can be thought of as a reusable, modular piece of code that can be
    applied to multiple parts of a program. Aspects can be designed to be composable
    so that different aspects can be combined to achieve more complex behavior.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将方面视为可重用、模块化的代码片段，可以应用于程序的多部分。方面可以设计为可组合的，以便不同的方面可以组合起来实现更复杂的行为。
- en: Aspects are typically implemented as classes or modules that define the behavior
    to be added to the program. In AOP frameworks such as Castle Windsor, aspects
    are often implemented as interceptors, which are classes that intercept calls
    to methods or properties and modify their behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 方面通常实现为定义要添加到程序中的行为的类或模块。在如Castle Windsor这样的AOP框架中，方面通常实现为拦截器，这些类拦截对方法或属性的调用并修改其行为。
- en: Pointcuts
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切入点
- en: Pointcuts are the mechanism used in AOP to specify the places in the code where
    an aspect should be applied. A pointcut is a set of join points, which are specific
    locations in the code where the aspect can be applied.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点是AOP中用于指定方面应应用的位置的机制。切入点是一组连接点，是代码中方面可以应用的具体位置。
- en: A join point is a point in the execution of a program where an aspect can be
    applied. Examples of join points include method calls, method executions, field
    accesses, and exception handlers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是在程序执行过程中可以应用方面的点。连接点的例子包括方法调用、方法执行、字段访问和异常处理程序。
- en: To define a pointcut, you need to specify the join points that the pointcut
    includes. This can be done using a variety of criteria, such as method name, method
    signature, class name, or annotations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个切入点，你需要指定切入点包含的连接点。这可以通过各种标准完成，例如方法名、方法签名、类名或注解。
- en: Join points
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接点
- en: In AOP, join points are specific points in the execution of a program where
    an aspect can be applied. Join points represent specific events, or method calls
    in the program, that can be intercepted by an aspect. For example, a join point
    could be a method call, field access, or an exception being thrown.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在AOP中，连接点是程序执行过程中可以应用方面的特定点。连接点代表程序中的特定事件或方法调用，可以被方面拦截。例如，一个连接点可以是方法调用、字段访问或抛出的异常。
- en: Join points are defined using pointcuts, which specify the criteria for selecting
    the join points where an aspect should be applied. Pointcuts can be defined using
    various criteria, such as method signatures, class names, or annotations. For
    example, a pointcut could select all methods that have a specific attribute or
    all methods in a specific namespace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是通过切入点定义的，这些切入点指定了应用方面时应选择的连接点标准。切入点可以使用各种标准定义，例如方法签名、类名或注解。例如，一个切入点可以选择所有具有特定属性的方法或特定命名空间中的所有方法。
- en: Once a pointcut has been defined, it can be used to apply an aspect to the selected
    join points. Aspects can modify the behavior of the join points they intercept
    by adding, modifying, or removing functionality. For example, an aspect could
    add logging or caching functionality to a method call or validate user input before
    allowing it to be processed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了切入点，就可以将其用于将方面应用于选定的连接点。方面可以通过添加、修改或删除功能来修改它们所拦截的连接点的行为。例如，方面可以向方法调用添加日志或缓存功能，或者在允许处理之前验证用户输入。
- en: Join points are an essential concept in AOP, as they allow aspects to be applied
    selectively to specific parts of the codebase rather than having to modify the
    entire codebase to implement cross-cutting concerns. Join points also enable the
    modularization of cross-cutting concerns, making them easier to manage and maintain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是AOP中的一个基本概念，因为它们允许方面有选择性地应用于代码库的特定部分，而不是必须修改整个代码库来实现横切关注点。连接点还使横切关注点的模块化成为可能，使它们更容易管理和维护。
- en: 'Some common examples of join points in C# include the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C#中常见的连接点示例包括以下内容：
- en: '**Method calls**: These are join points that intercept method calls, either
    before the method is called (using a before advice) or after the method is called
    (using an after advice)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用**：这些是拦截方法调用的连接点，无论是方法被调用之前（使用前置通知）还是之后（使用后置通知）'
- en: '**Field access**: These are join points that intercept read or write access
    to a field, either before the field is accessed (using a before advice) or after
    the field is accessed (using an after advice)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段访问**：这些是拦截对字段读取或写入访问的连接点，无论是字段被访问之前（使用前置通知）还是之后（使用后置通知）'
- en: '**Exception handling**: Join points that intercept the throwing of an exception,
    allowing the aspect to handle the exception or modify its behavior'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理**：拦截抛出异常的连接点，允许方面处理异常或修改其行为'
- en: 'The following diagram summarizes **Aspect**, **Pointcuts**, and **Join Points**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了**方面**、**切入点**和**连接点**：
- en: '![](img/B19418_14_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_14_01.jpg)'
- en: Figure 14.1 – AOP terminology visualization
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – AOP术语可视化
- en: With the terminology in place, we should now be ready to take a first dive into
    AOP and use it in some canonical examples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在术语准备就绪后，我们现在应该准备好首次深入探索AOP，并在一些典型示例中使用它。
- en: Logging
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: Logging is often cited as the canonical example of how AOP can be used to improve
    the modularity and maintainability of software. Logging is a common cross-cutting
    concern, meaning that it affects multiple parts of a software system and cannot
    be easily encapsulated within a single module or class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 日志经常被引用为AOP如何用于提高软件模块化和可维护性的典型示例。日志是一个常见的横切关注点，意味着它影响软件系统的多个部分，并且不能轻易地封装在单个模块或类中。
- en: AOP provides a way to encapsulate the logging behavior and apply it consistently
    throughout the system without the need to modify each module or class individually.
    This allows developers to focus on the core functionality of their modules while
    still providing a consistent and coherent way to log system behavior.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AOP提供了一种封装日志行为并在整个系统中一致应用的方法，而无需单独修改每个模块或类。这允许开发者专注于模块的核心功能，同时仍然提供一种一致且连贯的方式来记录系统行为。
- en: In this section, we will explore the role of logging in software systems and
    how AOP can be used to implement logging behavior in a modular and maintainable
    way. We will look at the benefits and drawbacks of different logging approaches
    and how AOP can help to address some of the challenges associated with logging
    in complex software systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨日志在软件系统中的作用以及如何使用AOP以模块化和可维护的方式实现日志行为。我们将分析不同日志方法的优缺点，以及AOP如何帮助解决与复杂软件系统中的日志相关的挑战。
- en: Creating a logging sample
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建日志示例
- en: 'Let’s start by creating a new project for the chapter. Create a folder called
    **Chapter14**, change into this folder in your command line and create a new console
    project:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为这一章创建一个新项目开始。创建一个名为**Chapter14**的文件夹，在命令行中切换到这个文件夹，并创建一个新的控制台项目：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this chapter, as discussed, we will use a framework called Castle Windsor.
    It’s one of many frameworks coming out of **The Castle Project**, which you can
    read more about it here ([http://www.castleproject.org/](http://www.castleproject.org/)).
    Castle Windsor is an **Inversion of Control** (**IoC**), a container that provides
    extensive capabilities performing AOP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，正如之前所讨论的，我们将使用一个名为 Castle Windsor 的框架。它是从 **The Castle Project** 中涌现出的许多框架之一，你可以在[这里](http://www.castleproject.org/)了解更多相关信息。Castle
    Windsor 是一个 **控制反转** (**IoC**) 容器，它提供了执行 AOP 的广泛功能。
- en: To make all the AOP magic possible, Castle Windsor is built on top of a project
    called Castle Core, which provides a convenient way to create dynamic runtime
    proxy objects, as we did in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098), *Dynamic
    Proxy Generation*. This could be a natural step up from having to do everything
    yourself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使所有 AOP 魔法成为可能，Castle Windsor 是建立在名为 Castle Core 的项目之上的，它提供了一种方便的方式来创建动态运行时代理对象，就像我们在
    [*第 6 章*](B19418_06.xhtml#_idTextAnchor098) 中所做的那样，*动态代理生成*。这可能是从必须自己完成所有事情的自然步骤。
- en: It is all open source, and the concrete framework you will be using here is
    the **Windsor** part and can be found on GitHub ([https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是开源的，你在这里将使用的具体框架是 **Windsor** 部分，可以在 GitHub 上找到([https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor))。
- en: 'Add the package to dependency of the project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将包添加到项目的依赖项中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To get started with the Windsor container, you can simply replace the content
    of **Program.cs** with the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Windsor 容器，你可以简单地替换 **Program.cs** 中的内容如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code creates an instance of **WindsorContainer** and instructs it to install
    any implementations of **IWindsorInstaller** from the running application. An
    installer is a way to configure the container. They are discovered in the **.Install()**
    call, and you can have multiple installers for specific use cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个 **WindsorContainer** 的实例，并指示它安装运行应用程序中任何实现 **IWindsorInstaller** 的实例。安装器是一种配置容器的方式。它们在
    **.Install()** 调用中被发现，并且你可以为特定的用例有多个安装器。
- en: 'We want to create **DefaultInstaller** that will set up a default behavior
    for the container. Add a file called **DefaultInstaller.cs** and make it look
    like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个 **DefaultInstaller**，它将为容器设置默认行为。添加一个名为 **DefaultInstaller.cs** 的文件，并使其看起来如下：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code implements the **IWindsorInstaller** interface and implements the **Install()**
    method. Within it, the code instructs **container** to register all classes from
    the application by associating it with a service represented by what is referred
    to as **DefaultInterfaces**. This means that it will establish a convention as
    we did in [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*,
    that says any class with a matching interface with a name prefixed by **I** will
    be bound together (**IFoo** -> **Foo**). Finally, it tells it that the lifestyle
    should be transient. Castle Windsor has a default life cycle of singleton, which
    could be dangerous and have undesired side effects, so my recommendation is to
    stay with transient as default and then override it when needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了 **IWindsorInstaller** 接口并实现了 **Install()** 方法。在它内部，代码指示 **容器** 通过将其与表示为
    **DefaultInterfaces** 的服务相关联来注册应用程序中的所有类。这意味着它将建立一种约定，就像我们在 [*第 10 章*](B19418_10.xhtml#_idTextAnchor162)
    中所做的那样，即 *约定优于配置*，即任何具有以 **I** 为前缀的匹配接口的类将被绑定在一起（**IFoo** -> **Foo**）。最后，它告诉它应该使用瞬态的生命周期。Castle
    Windsor 默认的生命周期是单例，这可能是危险的，并可能产生不期望的副作用，因此我的建议是保持瞬态作为默认值，并在需要时进行覆盖。
- en: An installer is just a tool to help you structure your code and help you with
    keeping things focused on a single responsibility and enable a more cohesive codebase.
    You can, in fact, work directly with the container right after instantiating it,
    as we will see later. Some things make sense to do right away, while others should
    be separated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安装器只是一个帮助你结构化代码并帮助你保持关注单一责任的工具。实际上，你可以在实例化后直接与容器一起工作，就像我们稍后将要看到的那样。有些事情应该立即做，而有些事情则应该分开。
- en: '**Console.WriteLine()** is not optimal for logging, so let’s use the Microsoft
    logger instead.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Console.WriteLine()** 对于日志记录来说不是最优的，所以让我们使用 Microsoft 日志记录器代替。'
- en: Adding the Microsoft logger
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Microsoft 日志记录器
- en: By writing to the console using **Console.WriteLine()**, you don’t get any structure
    to your logging. Log messages just become text, and the format is what you put
    into it. You often also want a different output for your local development than
    in production. Using a structured logging approach captures any values used in
    a log statement that could then be forwarded to a centralized log database, indexing
    them and making them searchable. There are many such tools out there, a[nd I recommend
    looking](https://datalust.co/seq) at Seq ([https://datalust.co/seq](https://datalust.co/seq)),
    which provides a tool that is free for local development.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 **Console.WriteLine()** 将信息写入控制台，你不会得到任何结构化的日志。日志消息只是文本，格式是你放入的内容。你通常还希望本地开发与生产环境有不同的输出。使用结构化日志方法可以捕获日志语句中使用的任何值，然后可以将这些值转发到集中的日志数据库中，对它们进行索引并使其可搜索。市面上有许多这样的工具，我推荐查看
    Seq ([https://datalust.co/seq](https://datalust.co/seq))，它提供了一个免费用于本地开发的工具。
- en: For this sample, we will use a library from Microsoft for structured logging.
    It is the same one used by Microsoft for everything they build. It provides extension
    points and can also be used with other popular logg[ing libraries, such](https://serilog.net)
    as Serilog ([https://serilog.net](https://serilog.net)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用来自微软的库来进行结构化日志记录。这是微软在构建所有内容时使用的相同库。它提供了扩展点，并且也可以与其他流行的日志库一起使用，例如
    Serilog ([https://serilog.net](https://serilog.net))。
- en: 'Start by adding package references to the core logging package and also to
    the **Console** output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加对核心日志包的引用，以及到 **Console** 输出的引用：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then in the **Program.cs** file, add the following code at the end:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 **Program.cs** 文件中，在末尾添加以下代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code creates **LoggerFactory** and configures it to output to the console.
    It then goes on to register the **ILoggerFactory** interface with the concrete
    instance you just configured into the Windsor IoC container. Any constructors
    with a dependency to **ILoggerFactory** will now get this instance. **ILoggerFactory**
    provides a way to create concrete **ILogger** instances, which is what will be
    used for logging.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码创建 **LoggerFactory** 并将其配置为输出到控制台。然后它继续将 **ILoggerFactory** 接口与您刚刚配置的具体实例注册到
    Windsor IoC 容器中。任何依赖于 **ILoggerFactory** 的构造函数现在将获得此实例。**ILoggerFactory** 提供了一种创建具体
    **ILogger** 实例的方法，这就是用于日志记录的内容。
- en: In ASP.NET Core, **ILoggerFactory** is being used internally in some cases to
    create logger instances. While in other cases, constructors have a dependency
    to **ILogger** and, even more specifically, on the generic **ILogger<>** version.
    The generic version of **ILogger** allows you to get a scoped logger that is for
    your specific type. In the log output, you’ll see the source of the log messages,
    which is important metadata.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，**ILoggerFactory** 在某些情况下被内部用于创建日志实例。而在其他情况下，构造函数依赖于 **ILogger**，甚至更具体地，依赖于泛型
    **ILogger<>** 版本。**ILogger** 的泛型版本允许你获取一个作用域特定的日志记录器，这是针对你的特定类型的。在日志输出中，你会看到日志消息的来源，这是重要的元数据。
- en: 'Let’s configure the IoC container to support both of these scenarios. In the
    **Program.cs** file, add the following code at the end:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置 IoC 容器以支持这两种场景。在 **Program.cs** 文件中，在末尾添加以下代码：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code starts by using reflection to get the **CreateLogger<>()** extension
    method from **LoggerFactoryExtensions**. This is because **ILoggerFactory** only
    has a non-typed way of creating a logger, and the generic one is an extension
    method. Next, the code registers the untyped non-generic **ILogger** with the
    container using a factory method that will create the instance dynamically when
    asked. It then leverages the container to get **ILoggerFactory** and then creates
    a logger by giving it the type **Ilogger** is being injected into. Since the default
    behavior of Windsor is to make everything a singleton, we explicitly configure
    **Ilogger** to be transient. This way, we get different logger instances for the
    types using it. Otherwise, you would be sharing the same logger across all types.
    Lastly, the code configures the generic **ILogger<>** using a factory method that
    uses the **CreateLogger<>()** extension method from **LoggerFactoryExtensions**
    by creating a generic method for the requested type and its generic type argument.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先使用反射从 **LoggerFactoryExtensions** 获取 **CreateLogger<>()** 扩展方法。这是因为 **ILoggerFactory**
    只有一种非类型化的创建日志的方式，而泛型的是一种扩展方法。接下来，代码使用一个会在需要时动态创建实例的工厂方法将未类型化的非泛型 **ILogger** 注册到容器中。然后，它利用容器获取
    **ILoggerFactory** 并通过给定的 **Ilogger** 注入的类型创建一个日志记录器。由于 Windsor 的默认行为是将一切设置为单例，我们明确配置
    **Ilogger** 为瞬时的。这样，我们就可以为使用它的类型获取不同的日志记录器实例。否则，你将共享同一个日志记录器跨所有类型。最后，代码使用一个工厂方法配置泛型
    **ILogger<>**，该方法使用 **LoggerFactoryExtensions** 中的 **CreateLogger<>()** 扩展方法，通过为请求的类型及其泛型类型参数创建一个泛型方法来完成。
- en: With the basic logging infrastructure in place, we’re now ready to apply cross-cutting
    logging.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本日志基础设施到位后，我们现在可以应用横切日志了。
- en: Interceptors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截器
- en: In Castle Windsor, there is the concept of interceptors. They represent how
    you can implement the actual aspect and perform the cross-cutting operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Castle Windsor 中，存在拦截器的概念。它们代表了如何实现实际方面并执行横切操作。
- en: 'Let’s create one for handling logging for all method calls. In the root of
    **Chapter14**, add a file called **LoggingInterceptor.cs** and make it look like
    the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于处理所有方法调用日志的拦截器。在 **Chapter14** 的根目录下添加一个名为 **LoggingInterceptor.cs**
    的文件，并使其看起来如下：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code sets up an implementation of **IInterceptor** from Castle Windsor.
    In the **Intercept()** method, the code calls the **Proceed()** method on the
    invocation object, which will perform the actual call it is intercepting. Before
    and after this call is where we can do our cross-cutting operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了 Castle Windsor 的 **IInterceptor** 实现方案。在 **Intercept()** 方法中，代码在调用对象上调用
    **Proceed()** 方法，这将执行它所拦截的实际调用。在这个调用之前和之后，我们可以执行我们的横切操作。
- en: With .NET 6, Microsoft introduced an approach to logging that helps you become
    even more structured by encapsulating log messages into its own code file. This
    helps you with the maintenance of log messages and makes it easier for those scenarios
    when you want to output the same log message for different scenarios.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，Microsoft 引入了一种将日志消息封装到其自己的代码文件中的日志方法，这有助于你通过封装日志消息来变得更加结构化。这有助于日志消息的维护，并使得在需要为不同场景输出相同日志消息时更加容易。
- en: 'Create a new file called **LoggingInterceptorLogMessages.cs** and add the following
    code to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 **LoggingInterceptorLogMessages.cs** 的新文件，并将以下代码添加到其中：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code sets up a static partial class with extension methods for each log
    statement and leverages **[LoggerMessage]** to configure the log message, its
    severity, a unique identifier within the file or globally, and optionally, an
    event name. Since all the methods are also partial and do not have any implementations,
    the C# compiler will generate the necessary code for this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了一个静态的局部类，其中包含每个日志语句的扩展方法，并利用 **[LoggerMessage]** 来配置日志消息，其严重性，文件内的唯一标识符或全局唯一标识符，以及可选的事件名称。由于所有方法都是局部的且没有实现，C#
    编译器将生成必要的代码来完成这项工作。
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: I find it to be good practice to make logger messages like this internal, for
    both the class and the methods. That way, you isolate them for their module and
    do not run the risk of making them an extension method that will show up as IntelliSense
    in your editor globally across different projects. Normally you should also use
    the generic **ILogger<>** as the type to extend for the extension method makes
    it specific to your concrete type. But since the log messages we have here are
    cross-cutting, we don’t know the type they will be used in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为将记录器消息像这样内部化是一种良好的实践，对于类和方法都是如此。这样，您可以将其隔离在模块中，并且不会冒将其变成一个将在您的编辑器中全局显示为IntelliSense的扩展方法的危险。通常，您还应该使用泛型的**ILogger<>**作为扩展方法的类型来扩展，因为扩展方法使其针对具体类型。但是，由于我们这里的日志消息是跨切的，我们不知道它们将在哪里使用。
- en: 'With the log messages in place for what we want to log, we can modify **LoggingInterceptor**
    to do the logging. Open the **LoggingInterceptor** file and change it to look
    like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了我们想要记录的日志消息后，我们可以修改**LoggingInterceptor**以执行日志记录。打开**LoggingInterceptor**文件，并将其更改为以下内容：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code gets changed to take **ILoggerFactory** as a dependency in the constructor.
    In the **Intercept()** method, you now use the logger factory to create a logger
    for the target type. It then uses structured logging calling **BeforeInvocation()**
    and **AfterInvocation()** and passing the name of the method being invoked.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被修改为在构造函数中接受**ILoggerFactory**作为依赖项。在**Intercept()**方法中，您现在使用日志工厂为目标类型创建一个记录器。然后它使用结构化日志调用**BeforeInvocation()**和**AfterInvocation()**，并传递被调用的方法名称。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Just seeing the method being invoked in your logs by name might not be enough
    information. The **IInvocation** type has details about the parameters being passed,
    and you could be logging them as well. The only thing to keep in mind would be
    to redact values that are sensitive, such as **General Data Protection Regulation**
    (**GDPR**)-related information or security information. Luckily, if you follow
    the advice in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about
    Types Using Reflection*, and use the **ConceptAs<>** encapsulation for types,
    you could easily identify the types you need to redact and automatically do so.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过日志中按名称看到被调用的方法可能不足以提供足够的信息。**IInvocation**类型包含有关传递的参数的详细信息，您也可以将它们记录下来。唯一需要注意的是，要删除敏感值，例如与**通用数据保护条例**（**GDPR**）相关的信息或安全信息。幸运的是，如果您遵循[*第4章*](B19418_04.xhtml#_idTextAnchor059)中*使用反射推理类型*的建议，并使用**ConceptAs<>**封装类型，您可以轻松地识别需要删除的类型并自动执行删除。
- en: 'With the interceptor in place, the next step is to hook it up to Castle Windsor.
    Open the **DefaultInstaller.cs** file and change it to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置拦截器后，下一步是将它连接到Castle Windsor。打开**DefaultInstaller.cs**文件，并将其更改为以下内容：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only change made to the installer is the registration of **LoggingInterceptor**.
    Castle Windsor does not know how to resolve concrete types automatically, so we
    register it manually. The second addition is to configure the registration for
    the default convention to include **LoggingInterceptor**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对安装程序所做的唯一更改是注册了**LoggingInterceptor**。Castle Windsor不知道如何自动解析具体类型，因此我们手动注册它。第二个新增内容是为默认约定配置注册，包括**LoggingInterceptor**。
- en: Now that you have all the infrastructure in place, you need something to test
    it with. Let’s create a user service for registering users, not focusing on implementing
    it, just something to test the interceptor with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置了所有基础设施，您需要一些东西来测试它。让我们创建一个用于注册用户的用户服务，不是关注实现它，只是用来测试拦截器的东西。
- en: Trying out the interceptor
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试拦截器
- en: 'Create a file called **IUsersService.cs** in the root of **Chapter14** and
    make it look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter14**的根目录下创建一个名为**IUsersService.cs**的文件，并使其看起来如下：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The interface holds a single method for registering a user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含一个用于注册用户的单一方法。
- en: 'For the interface, you’ll need an implementation. Add a file called **UsersService.cs**
    and add the following code to it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接口，您需要一个实现。添加一个名为**UsersService.cs**的文件，并将其以下代码添加到其中：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code represents an implementation of **IUsersService**. It takes **ILogger<UsersService>**
    as a dependency so that we can log from within it. For the **Register()** method,
    it only logs it, creates a new **Guid**, and returns this as a result.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码表示**IUsersService**的实现。它将**ILogger<UsersService>**作为依赖项，这样我们就可以在其中记录日志。对于**Register()**方法，它只记录它，创建一个新的**Guid**，并将其作为结果返回。
- en: 'With a sample in place, you now need to get an instance of it and see that
    the interceptor works. Open the **Program.cs** file and add the following to the
    very end:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好示例之后，你现在需要获取其实例并验证拦截器是否工作。打开**Program.cs**文件，并在文件末尾添加以下内容：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code asks the Castle Windsor container for an instance of **IUsersService**
    and then calls the **Register()** method. We put in **Console.ReadLine()** due
    to the use of async; if we didn’t, it would exit without any of the log messages
    being printed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码请求Castle Windsor容器提供**IUsersService**的实例，然后调用**Register()**方法。我们添加**Console.ReadLine()**是因为使用了异步；如果没有这样做，它将退出而不会打印任何日志消息。
- en: 'You can now run this using **dotnet run** or your preferred approach in your
    editor, and you should see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用**dotnet run**或你编辑器中的首选方法运行此代码，你应该看到以下输出：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The calling code has no concept of the interceptor; it is configured once and
    will be weaved into the running code automatically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码没有拦截器的概念；它一旦配置好就会自动编织到运行代码中。
- en: 'However, the implementation of the **Intercept()** method in **LoggingInterceptor**
    is a bit naïve. It should support errors, and it also needs to support asynchronous
    method calls properly. Open the **LoggingInterceptor.cs** file and change the
    **Intercept()** method as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**LoggingInterceptor**中**Intercept()**方法的实现有些天真。它应该支持错误，并且还需要正确地支持异步方法调用。打开**LoggingInterceptor.cs**文件，并按如下方式更改**Intercept()**方法：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code wraps the **Proceed()** call in **try {} catch {}** to be able to log
    the error, but rethrows it as the logging shouldn’t swallow the exception; it
    should bubble up to the original caller. For handling asynchronous calls, it looks
    at **ReturnValue** of the **invocation** instance if it is a **Task**. If it is
    a task, it will continue, and get notified when it is completed. Tasks can have
    a faulty state, which would be if the call results in an exception.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将**Proceed()**调用包裹在**try {} catch {}**中，以便能够记录错误，但会重新抛出异常，因为日志不应该吞没异常；它应该冒泡到原始调用者。对于处理异步调用，如果**invocation**实例是**Task**，它会查看**ReturnValue**。如果是任务，它将继续，并在完成时得到通知。任务可能处于错误状态，这将是如果调用导致异常的情况。
- en: Mixins
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入
- en: In C++, multiple inheritances provide a powerful way to combine behaviors from
    multiple base classes. However, this can lead to complexity and the diamond problem.
    Mixins provide a simpler alternative to multiple inheritances that avoids these
    issues and are particularly useful for implementing cross-cutting concerns in
    your code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，多重继承提供了一种强大的方式来组合来自多个基类的行为。然而，这可能导致复杂性和菱形问题。混入提供了一种更简单的多重继承替代方案，避免了这些问题，并且特别适用于在代码中实现横切关注点。
- en: In the .NET **common language runtime** (**CLR**), however, multiple inheritance
    is not supported, as it uses a single inheritance model. This means that there
    is no built-in mechanism for combining behaviors from multiple classes. Mixins
    can be used to achieve this, providing a way to add functionality to a class without
    needing to modify its inheritance hierarchy. In this section, we’ll explore what
    mixins are, how they work, and why you might want to use them in your C# applications
    to overcome the limitations of the .NET CLR’s single inheritance model.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在.NET公共语言运行时（**CLR**）中，不支持多重继承，因为它使用单继承模型。这意味着没有内置机制来组合来自多个类的行为。混入可以用来实现这一点，提供了一种在不修改其继承层次结构的情况下向类添加功能的方法。在本节中，我们将探讨混入是什么，它们是如何工作的，以及为什么你可能在C#应用程序中使用它们来克服.NET
    CLR单继承模型的限制。
- en: One of the key features of Castle Core is its support for dynamic proxies, which
    allow you to intercept method calls and add behavior at runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 城堡核心的关键特性之一是其对动态代理的支持，这允许你在运行时拦截方法调用并添加行为。
- en: Castle Windsor’s approach to mixins builds on this support for dynamic proxies
    to provide a way to compose behavior from multiple sources into a single object.
    Mixins allow you to define a set of behaviors as independent components, which
    can be combined with the behavior of another object to create a new object with
    the combined behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 城堡Windsor对混入的支持建立在动态代理的此支持之上，以提供一种将来自多个来源的行为组合到单个对象中的方法。混入允许你定义一组行为作为独立的组件，这些组件可以与另一个对象的行为结合，以创建具有组合行为的新的对象。
- en: In Castle Windsor, mixins are implemented using a combination of dynamic proxies
    and an interception. When you register a component with mixins, Castle Windsor
    creates a dynamic proxy object that intercepts method calls to the component and
    delegates them to the mixins. The mixins can then modify the behavior of the component
    by adding new functionality or modifying the behavior of existing methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Castle Windsor 中，混入（mixins）是通过动态代理和拦截的组合来实现的。当你注册带有混入的组件时，Castle Windsor 创建一个动态代理对象，该对象拦截对组件的方法调用，并将它们委托给混入。混入可以通过添加新功能或修改现有方法的行为来修改组件的行为。
- en: To register a component with mixins in Castle Windsor, you typically define
    one or more interfaces that represent the mixins and register them as separate
    components with the container. You then register the component to which you want
    to add the mixins to and specify the mixins as dependencies. When the component
    is resolved from the container, Castle Windsor creates a dynamic proxy object
    that implements the component interface and the mixin interfaces and delegates
    method calls to the appropriate objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Castle Windsor 中注册带有混入（mixins）的组件时，通常定义一个或多个表示混入的接口，并将它们作为单独的组件注册到容器中。然后，将您想要添加混入的组件注册到容器中，并指定混入作为依赖项。当组件从容器中解析出来时，Castle
    Windsor 创建一个动态代理对象，该对象实现了组件接口和混入接口，并将方法调用委托给适当的对象。
- en: Mixing it up
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合起来
- en: The **UserService** you created earlier could be a candidate for mixins. In
    a system, you typically need a way to authenticate users and a way to ask whether
    they are authorized to perform an action. Obviously, .NET provides building blocks
    and great support for both authentication and authorization, but let’s say you
    want your abstraction on top of what .NET provides for specific use where you
    need to be able to authenticate a user by its username and password and then be
    able to ask whether the user is authorized to perform an action.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前创建的 **UserService** 可能是混入的候选者。在一个系统中，通常需要一种方式来验证用户身份，以及一种方式来询问他们是否有权执行某个操作。显然，.NET
    提供了构建块和出色的支持，用于认证和授权，但假设你想要在你的抽象之上构建一个特定于.NET提供的抽象，以便能够通过用户名和密码验证用户，然后能够询问用户是否有权执行某个操作。
- en: 'In the folder for the **Chapter14** code, add a file called **IAuthenticator.cs**
    and put the following into it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Chapter14** 代码的文件夹中，添加一个名为 **IAuthenticator.cs** 的文件，并将以下内容放入其中：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The **IAuthenticator** interface defines a method for performing authentication
    with a username and a password. It would typically return **true** if it could
    successfully authenticate the user and **false** if not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAuthenticator** 接口定义了一个使用用户名和密码进行认证的方法。如果它能够成功认证用户，则通常返回 **true**，否则返回 **false**。'
- en: 'An implementation of **IAuthenticator** can be put in a file called **Authenticator.cs**,
    which looks like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAuthenticator** 的实现可以放在一个名为 **Authenticator.cs** 的文件中，其内容如下：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code implements the **IAuthenticator** interface, and for demo purposes,
    it only returns **true**. Since we won’t be building anything specifically and
    are just demonstrating the power of mixins, this is OK for now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了 **IAuthenticator** 接口，出于演示目的，它仅返回 **true**。由于我们不会构建任何特定内容，只是展示混入（mixins）的强大功能，所以目前这样是可以的。
- en: 'For the authorization part, you’re going to need another interface. Add a file
    called **IAuthorizer.cs** and make it look like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于授权部分，你需要另一个接口。添加一个名为 **IAuthorizer.cs** 的文件，并使其看起来如下：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Checking for authorization is done by giving it a username and an action. The
    method will then return **true** if the user is authorized to perform the action
    and **false** if not.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供用户名和操作来检查授权。如果用户被授权执行该操作，则该方法将返回 **true**，否则返回 **false**。
- en: 'For the authorizer, you’ll also need an implementation, so create a file called
    **Authorizer.cs** and put the following into it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于授权者，你还需要一个实现，因此创建一个名为 **Authorizer.cs** 的文件，并将以下内容放入其中：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with the **Authenticator** implementation, it will just return **true** for
    demonstration purposes. This is where you’d have your logic for checking whether
    the user is authorized for a specific action.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **Authenticator** 实现一样，出于演示目的，它将仅返回 **true**。这就是你检查用户是否有权执行特定操作的地方。
- en: The **IAuthenticator** and **IAuthorizer**, with their respective implementations,
    are separate, and they’re also separate from **IUsersService**. This is great
    as they represent different aspects of working with a user. They serve specific
    responsibilities of the system, and it’s logical to keep them separate, which
    leads to a more maintainable codebase.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAuthenticator** 和 **IAuthorizer**，以及它们各自的实现，是独立的，并且它们也与 **IUsersService**
    独立。这很好，因为它们代表了与用户交互的不同方面。它们承担系统的特定责任，保持它们独立是逻辑上合理的，这有助于代码库的维护。'
- en: However, it might be desirable to be able to access them all as one at runtime.
    This is where mixins come in and can make it look as if it is one implementation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行时能够一次性访问所有这些功能可能是有需求的。这就是混入（mixins）发挥作用的地方，它们可以使它看起来像是一个单一实现。
- en: 'To be able to do so, you need to configure Castle Windsor correctly. Open the
    **DefaultInstaller.cs** file and at the top of the **Install()** method, add the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你需要正确配置 Castle Windsor。打开 **DefaultInstaller.cs** 文件，并在 **Install()**
    方法的顶部添加以下内容：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code adds explicit container registrations for the **IAuthenticator** and
    **IAuthorizer** services. The reason for adding this explicitly is that we have
    to add an explicit registration for **IUsersService**, and this has to happen
    prior to the automatic registrations that are already set up in **DefaultInstaller**.
    If you were to register **IUsersService** after the automatic registrations, you
    would get an exception saying there are duplicate registrations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为 **IAuthenticator** 和 **IAuthorizer** 服务添加了显式的容器注册。添加这些显式注册的原因是我们必须为 **IUsersService**
    添加一个显式注册，并且这必须发生在 **DefaultInstaller** 中已经设置的自动注册之前。如果你在自动注册之后注册 **IUsersService**，你会得到一个异常，表明有重复注册。
- en: 'For the mixin, you’re going to need another explicit registration. Add the
    following code right after the **IAuthenticator** and **IAuthorize** registrations
    and before the automatic registrations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混入，你需要另一个显式注册。在 **IAuthenticator** 和 **IAuthorize** 注册之后，在自动注册之前添加以下代码：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The registration for **IUsersService** is slightly different from what you’ve
    done before. First, it instructs Castle Windsor that **IUsersService** is implemented
    by **UsersService**, then it instructs it to implement some additional interfaces:
    **IAuthorizer** and **IAuthenticator**. The additional interfaces are then instructed
    to be implemented using the **.Mixins()** call that tells it that they’re implemented
    by their respective **Authorizer** and **Authenticator** components. Since this
    is an explicit registration, the automatic one will not kick in, and **LoggingInterceptor**
    you previously hooked up won’t kick in for this. For it to do so, you need to
    add an explicit **.Interceptors<>()** call for the interceptor. Lastly, you set
    the lifestyle to be transient.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**IUsersService** 的注册与之前所做的略有不同。首先，它指示 Castle Windsor **IUsersService** 由 **UsersService**
    实现，然后它指示它实现一些额外的接口：**IAuthorizer** 和 **IAuthenticator**。然后，这些额外的接口被指示通过 **.Mixins()**
    调用实现，该调用告诉它们由各自的 **Authorizer** 和 **Authenticator** 组件实现。由于这是一个显式注册，自动注册将不会启动，你之前连接的
    **LoggingInterceptor** 也不会启动。为了使其启动，你需要为拦截器添加一个显式的 **.Interceptors<>()** 调用。最后，你设置生命周期为瞬时的。'
- en: 'If you run this with the debugger attached, you can investigate what has happened
    to **UserService**. In the **Program.cs** file, you can put a breakpoint right
    after you call **container.Resolve<IUserService>()**. Run the debugger to this
    point:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用调试器运行此代码，你可以调查 **UserService** 发生了什么。在 **Program.cs** 文件中，你可以在调用 **container.Resolve<IUserService>()**
    后立即设置一个断点。运行调试器到这个点：
- en: '![](img/B19418_14_02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_14_02.jpg)'
- en: Figure 14.2 – The debug breakpoint
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 调试断点
- en: 'In the **Debug** console (immediate window) of your editor/**integrated development
    environment** (**IDE**), you should be able to write the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器/集成开发环境（**IDE**）的 **Debug** 控制台（即时窗口）中，你应该能够编写以下内容：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this should be something like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的内容可能如下所示：
- en: '![](img/B19418_14_03.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_14_03.jpg)'
- en: Figure 14.3 – The implemented interfaces
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 实现的接口
- en: 'To prove the calls are going to the mixins, you can add the following to the
    **Program.cs** file before **Console.ReadLine();**:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明调用是传递给混入的，你可以在 **Program.cs** 文件中在 **Console.ReadLine();** 之前添加以下内容：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code assumes that **UserService** also implements the **IAuthenticator**
    and **IAuthorizer** interfaces and uses casting to get to them and calls the **Authenticate()**
    and **IsAuthorized()** methods, respectively. It then prints out the results of
    these.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设 **UserService** 也实现了 **IAuthenticator** 和 **IAuthorizer** 接口，并使用类型转换来获取它们，并分别调用
    **Authenticate()** 和 **IsAuthorized()** 方法。然后它打印出这些方法的输出结果。
- en: 'If you run your application now, you should see an output similar to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该会看到以下类似的输出：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The downside to this approach is that it is not clear in the contract of **IUsersService**
    that it will also implement the **IAuthenticator** and **IAuthorizer** interfaces.
    However, this can be overcome by different techniques.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，在 **IUsersService** 的契约中并不明确它还将实现 **IAuthenticator** 和 **IAuthorizer**
    接口。然而，这可以通过不同的技术来克服。
- en: 'One approach is to have an interface that represents the composition without
    an implementation, for instance, something such as the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是有这样一个没有实现但表示组合的接口，例如以下内容：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The **IUsersServiceComposition** interface is just for composition; it shouldn’t
    have any direct members on it as the goal is to combine implementations of **IUsersService**,
    **IAuthenticator**, and **IAuthorizer**. We can then leverage the underlying **ProxyGenerator**
    in the Castle **DynamicProxy** library to create a proxy that represents this
    with the implementations in the different components.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**IUsersServiceComposition** 接口仅用于组合；它不应该有任何直接成员，因为目标是结合 **IUsersService**、**IAuthenticator**
    和 **IAuthorizer** 的实现。然后我们可以利用 Castle **DynamicProxy** 库中的底层 **ProxyGenerator**
    来创建一个代理，以表示不同组件中的实现。'
- en: 'In the **DefaultInstaller.cs** file, you can now create a new type of registration
    for the new **IUsersServiceComposition** interface. At the end of the method,
    you can add the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DefaultInstaller.cs** 文件中，你现在可以为新的 **IUsersServiceComposition** 接口创建一种新的注册类型。在方法末尾，你可以添加以下代码：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code sets up a registration that uses a method to create the instance. With
    the **UsingFactoryMethod()** instruction, you’re giving Castle Windsor a method
    that will be called when it needs to resolve the instance. The factory method
    uses **ProxyGenerator** from the Castle **DynamicProxy** and adds the different
    mixins for the **IAuthorizer** and **IAuthenticator** interfaces by using the
    container to provide an instance of these. For **IUsersService**, we have to create
    an instance of it ourselves for this sample, providing the logger that uses the
    container to get an instance. The reason for this is that you already have a registration
    for **IUsersService** that adds mixins for the **IAuthorizer** and **IAuthenticator**
    interfaces, which would throw an exception when creating a proxy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了一个使用方法创建实例的注册。使用 **UsingFactoryMethod()** 指令，你为 Castle Windsor 提供了一个当它需要解析实例时将被调用的方法。工厂方法使用
    Castle **DynamicProxy** 中的 **ProxyGenerator** 并通过容器提供这些接口的实例来添加 **IAuthorizer**
    和 **IAuthenticator** 接口的不同混合。对于 **IUsersService**，在这个示例中我们必须自己创建其实例，提供使用容器获取实例的记录器。这样做的原因是，你已经有了一个为
    **IUsersService** 的注册，它为 **IAuthorizer** 和 **IAuthenticator** 接口添加了混合，这将在创建代理时抛出异常。
- en: Once all the mixins are configured, the code creates a class proxy with a target
    based on the **object** type and tells it that it should implement the **IUsersServiceComposition**
    interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有混合配置完成，代码创建了一个基于 **object** 类型的目标类代理，并告诉它应该实现 **IUsersServiceComposition**
    接口。
- en: With all that, you now get an instance that implements all the interfaces and
    delegates the implementation of them to the mixed-in instances. Kind of neat.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些，你现在得到了一个实现了所有接口的实例，并将它们的实现委托给混合实例。相当巧妙。
- en: 'Using **IUserServiceComposition** is now much more intuitive and very clear
    for the consumer, as you don’t have to know what other interfaces it might implement.
    Open up the **Program.cs** file and add the following code before **Console.ReadLine()**:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **IUserServiceComposition** 现在对于消费者来说更加直观和清晰，因为你不需要知道它可能实现的其他接口。打开 **Program.cs**
    文件，在 **Console.ReadLine()** 之前添加以下代码：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running the program should now give you a result similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序现在应该给出以下类似的结果：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Mixins provide a powerful way to add behavior to an object by combining it
    with behavior from other objects. Some of the benefits of using mixins include
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式提供了一种通过结合其他对象的行为来向对象添加行为的有效方式。使用混合模式的一些好处包括以下内容：
- en: '**Composition**: Mixins allow you to compose complex behavior from simple,
    reusable components. This makes it easier to maintain and modify your code over
    time.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：混入允许你从简单、可重用的组件中组合复杂的行为。这使得随着时间的推移维护和修改代码变得更加容易。'
- en: '**Separation of concerns**: Mixins enable you to separate the concerns of an
    object by breaking it down into smaller, more focused pieces of functionality.
    This makes it easier to understand and reason about your code.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：混入通过将对象分解成更小、更专注的功能部分，使你能够分离关注点。这使得理解代码和推理代码变得更加容易。'
- en: '**Reusability**: Mixins allow you to reuse behavior across multiple objects,
    which reduces code duplication and makes it easier to maintain and modify your
    code over time.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：混入允许你在多个对象之间重用行为，这减少了代码重复，并使得随着时间的推移维护和修改代码变得更加容易。'
- en: '**Flexibility**: Mixins provide a flexible way to modify the behavior of an
    object by allowing you to selectively apply behavior as needed. This gives you
    greater control over the behavior of your code and makes it easier to customize
    for specific use cases.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：混入通过允许你根据需要选择性地应用行为，提供了一种修改对象行为的方式。这为你提供了对代码行为的更大控制，并使得针对特定用例进行定制变得更加容易。'
- en: '**Testability**: Mixins allow you to test individual pieces of functionality
    in isolation, which makes it easier to write tests and ensure the correctness
    of your code.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：混入允许你单独测试功能的一部分，这使得编写测试和确保代码的正确性更加容易。'
- en: Mixins are often used in conjunction with techniques such as pointcuts, which
    allow you to apply behavior to specific points in your code. Pointcuts provide
    a way to selectively apply mixins to specific parts of your code, which gives
    you even greater flexibility and control over the behavior of your code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 混入通常与切点等技术结合使用，这些技术允许你在代码的特定点应用行为。切点提供了一种选择性地将混入应用于代码特定部分的方法，这为你提供了更大的灵活性和对代码行为的控制。
- en: In summary, mixins are a powerful tool for adding behavior to objects in a flexible,
    maintainable, and reusable way. When used in conjunction with pointcuts and other
    AOP techniques, they provide a powerful way to customize the behavior of your
    code and achieve greater modularity, flexibility, and testability.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，混入（mixins）是一种强大的工具，可以以灵活、可维护和可重用的方式向对象添加行为。当与切点和其他AOP技术结合使用时，它们提供了一种强大的方式来自定义代码的行为，并实现更高的模块化、灵活性和可测试性。
- en: Authorization
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: Authorization is a critical concern for many software systems, as it is important
    to ensure that users and applications only have access to the resources and functionality
    that they are authorized to use. AOP can be a powerful tool for implementing authorization
    behavior, as it allows developers to encapsulate authorization logic and apply
    it consistently throughout the system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 授权对于许多软件系统来说是一个关键问题，因为确保用户和应用只能访问他们被授权使用的资源和功能非常重要。AOP可以作为一种强大的工具来实现授权行为，因为它允许开发者封装授权逻辑并在整个系统中一致地应用它。
- en: One approach to implementing authorization with AOP is to use join points to
    filter down to specific namespaces in C# code. Join points are points in the code
    where an aspect can be applied, such as method calls, field accesses, or object
    creation. By using join points to filter down specific namespaces, developers
    can apply authorization logic only to the relevant parts of the system, reducing
    the risk of errors or inconsistencies.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实现AOP授权的一种方法是在C#代码中使用连接点（join points）过滤到特定的命名空间。连接点是代码中可以应用方面的点，例如方法调用、字段访问或对象创建。通过使用连接点过滤到特定的命名空间，开发者可以将授权逻辑仅应用于系统的相关部分，从而降低错误或不一致的风险。
- en: In AOP, a pointcut is a specific location in the source code where an aspect
    should be applied. In other words, it’s a way to define the set of join points
    (i.e., specific points in a program’s execution flow) where an aspect should be
    executed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向切面编程（AOP）中，切点是指源代码中应用方面（aspect）的具体位置。换句话说，它是一种定义应该执行方面的集合（即程序执行流程中的特定点）的方法。
- en: Pointcuts are often defined using a combination of different criteria, such
    as method names, method signatures, class names, package names, annotations, and
    more. The criteria used to define a pointcut are typically expressed using a syntax
    known as a “pointcut expression” or “pointcut language.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 切点通常使用多种不同的标准定义，例如方法名称、方法签名、类名称、包名称、注解等。用于定义切点的标准通常使用一种称为“切点表达式”或“切点语言”的语法来表示。
- en: The pointcut language used may vary depending on the AOP framework being used.
    For example, in C#, with the help of libraries such as PostSharp, you can define
    pointcuts using a combination of attribute annotations and method signatures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的切点语言可能因所使用的 AOP 框架而异。例如，在 C# 中，借助 PostSharp 等库的帮助，你可以通过属性注解和方法签名的组合来定义切点。
- en: Once a pointcut is defined, it can be used to “weave” one or more aspects into
    the code at the specified join points. This means that the aspect’s behavior is
    inserted into the code at the specified join points without requiring any modification
    to the original source code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了切点，就可以将其用于在指定的连接点将一个或多个方面“编织”到代码中。这意味着方面的行为被插入到指定的连接点，而无需对原始源代码进行任何修改。
- en: Overall, pointcuts provide a powerful way to apply cross-cutting concerns, such
    as logging, caching, or security, to specific parts of a program’s execution flow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，切点提供了一种强大的方式，可以将跨切面关注点，如日志记录、缓存或安全，应用于程序执行流程的特定部分。
- en: Using pointcuts
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切点
- en: With interceptors, you might not want them applied to everything. This could
    especially be true for authorization. You could have parts of your application
    that do not require authorization, such as infrastructure, and possibly also concrete
    parts that are open to all users. With Castle Windsor, we can create pointcuts
    by leveraging selectors for the interceptors. This is a way to provide the actual
    interceptors to be applied dynamically based on type and method information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拦截器时，你可能不希望它们应用于所有内容。这尤其是对于授权而言。你可能有一些不需要授权的应用程序部分，例如基础设施，以及可能对所有用户开放的具体部分。使用
    Castle Windsor，我们可以通过利用拦截器的选择器来创建切点。这是一种根据类型和方法信息动态提供实际拦截器的方法。
- en: 'Let’s create a service for adding to-do items to a list, represented with an
    **ITodoService** interface. Create a folder called **Todo** in the root of the
    **Chapter14** project, add a file called **ITodoService.cs**, and add the following
    to it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于向列表添加待办事项的服务，该列表由 **ITodoService** 接口表示。在 **Chapter14** 项目的根目录下创建一个名为
    **Todo** 的文件夹，添加一个名为 **ITodoService.cs** 的文件，并将以下内容添加到其中：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The interface only exposes a simple **Add()** method for adding an item in
    the form of a string. Its implementation should be added to a file called **TodoService.cs**
    within the **Todo** folder and look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接口仅公开一个简单的 **Add()** 方法用于以字符串形式添加一个项目。其实现应该添加到 **Todo** 文件夹内名为 **TodoService.cs**
    的文件中，并看起来如下：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we’re not focused on building something that creates a **todo** item in
    a datastore, we just print what is added in the implementation. This is just to
    prove how you can leverage interceptors and selectors to filter what calls are
    made.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是专注于构建在数据存储中创建 **todo** 项的东西，我们只是在实现中打印添加的内容。这只是为了证明你可以如何利用拦截器和选择器来过滤调用。
- en: The next thing you will need is an interceptor that checks whether the user
    is authorized.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要的是一个检查用户是否授权的拦截器。
- en: 'Add a file called **AuthorizationInterceptor.cs** to the root of the **Chapter14**
    project and add the following code to it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将名为 **AuthorizationInterceptor.cs** 的文件添加到 **Chapter14** 项目的根目录，并将以下代码添加到该文件中：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code implements the Castle **DynamicProxy** **IInterceptor** interface,
    and the constructor has a dependency on the **IUsersServiceComposition** service
    you created for the mixins section. The **Intercept()** method leverages the composed
    user service to check whether the user is authorized. If the user is authorized,
    it lets the invocation carry on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了 Castle **DynamicProxy** **IInterceptor** 接口，构造函数依赖于为混合部分创建的 **IUsersServiceComposition**
    服务。**Intercept()** 方法利用组合用户服务来检查用户是否授权。如果用户被授权，它允许调用继续进行。
- en: 'Important note:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The user is hardcoded to **jane@doe.io**, you would obviously need to get the
    currently logged-in user in a production system. Also, the implementation does
    not do anything if it’s not authorized. One approach could be to throw **UnauthorizedException()**
    and let that bubble up.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被硬编码为 **jane@doe.io**，在生产系统中显然需要获取当前登录的用户。此外，如果未授权，实现不会做任何事情。一种方法可能是抛出 **UnauthorizedException()**
    并让异常向上冒泡。
- en: 'For the actual pointcut that will be filtering down which interceptors to apply
    when, you must implement the **IinterceptorSelector** interface found in Castle
    **DynamicProxy**. Add a file in the root of the project called **InterceptorSelector.cs**
    and add the following code to it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际将过滤出何时应用哪些拦截器的实际切入点，你必须实现 Castle **DynamicProxy** 中找到的 **IInterceptorSelector**
    接口。在项目的根目录中添加一个名为 **InterceptorSelector.cs** 的文件，并将其中的以下代码添加到该文件中：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The **SelectInterceptors()** method gets called with the target type and the
    method being called, and you’re given the configured interceptors. You can, at
    this stage, decide which interceptors should be applied to the method call. The
    code makes this decision by looking at the namespace of the type and anything
    that starts with **Chapter14.Todo** should have all interceptors, while anything
    else gets all interceptors except **AuthorizationInterceptor**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**SelectInterceptors()** 方法会调用目标类型和被调用的方法，并给出配置的拦截器。在这个阶段，你可以决定哪些拦截器应该应用于方法调用。代码通过查看类型的命名空间来做出这个决定，任何以
    **Chapter14.Todo** 开头的都应该有所有拦截器，而其他任何东西则除了 **AuthorizationInterceptor** 之外的所有拦截器。'
- en: 'With the interceptor and the selector in place, you will have to register them
    both in the Castle Windsor container and hook them up for use in existing registrations.
    Open the **DefaultInstaller.cs** file and add the following to the top of the
    **Install()** method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在拦截器和选择器就位后，你必须在 Castle Windsor 容器中注册它们，并将它们连接起来以用于现有注册。打开 **DefaultInstaller.cs**
    文件并在 **Install()** 方法的顶部添加以下内容：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code registers both **InterceptorSelector** and **AuthorizationInterceptor**
    with the container, making them possible to be injected into services needing
    it. In the **Install()** method, there are two places where you’ve already added
    **LoggingInterceptor**; in both these places, we want to add the new **AuthorizationInterceptor**
    and also a statement telling Castle Windsor to use the new **InterceptorSelector**
    to select the correct interceptors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将 **InterceptorSelector** 和 **AuthorizationInterceptor** 都注册到容器中，使它们能够注入需要它们的服务。在
    **Install()** 方法中，你已经添加了 **LoggingInterceptor** 的两个地方；在这两个地方，我们想要添加新的 **AuthorizationInterceptor**，并添加一个语句告诉
    Castle Windsor 使用新的 **InterceptorSelector** 来选择正确的拦截器。
- en: 'The following lines add the interceptor and selector:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行添加了拦截器和选择器：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For reference, the block that configures **IUsersService** needs these two
    lines:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，配置 **IUsersService** 的代码块需要这两行：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the second block that needs the two lines is generally, by convention,
    the automatic hookup:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两行的第二个块通常按照惯例是自动连接：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that everything is registered, it’s time to try it out. Open the **Program.cs**
    file and add the following before **Console.ReadLine()**:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已注册，是时候尝试一下了。打开 **Program.cs** 文件并在 **Console.ReadLine()** 之前添加以下内容：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By running your application now, you should see the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的应用程序，你应该会看到以下输出：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As expected, you should be allowed to buy the milk. Let’s alter the authorizer
    to not permit this. Open the **Authorizer.cs** file and return **false** instead:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，你应该可以购买牛奶。让我们修改授权器以不允许这样做。打开 **Authorizer.cs** 文件并将返回值改为 **false**：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the program again should produce a different result with the **Adding
    ''Buy milk'' to the todo list** output being removed. You’ll still see that the
    method invocation from the logger happens, but the actual invocation is filtered
    out:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序应该会产生不同的结果，**Adding 'Buy milk' to the todo list** 输出将被移除。你仍然会看到日志记录器发生的方法调用，但实际的调用被过滤掉了：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Windsor Castle provides a flexible and powerful pointcut mechanism, based on
    Castle **DynamicProxy**, that allows you to select join points based on the metadata
    found on the type and method. For example, you can create pointcuts based on the
    following criteria:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Windsor Castle 提供了一个基于 Castle **DynamicProxy** 的灵活且强大的切入点机制，允许你根据类型和方法上找到的元数据选择连接点。例如，你可以根据以下标准创建切入点：
- en: The name of the method
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的名称
- en: The return type of the method
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的返回类型
- en: The parameters of the method
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的参数
- en: The presence of attributes on the type or method
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型或方法上存在属性
- en: The accessibility of the method (e.g., public, private, and so on)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法的可访问性（例如，公共、私有等）
- en: By combining multiple criteria, you can create complex pointcuts that match
    very specific sets of join points. For example, you could create a pointcut that
    matches all public methods with a specific attribute or all non-public methods
    with a specific name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合多个标准，您可以创建复杂的切入点，以匹配非常具体的连接点集合。例如，您可以创建一个匹配所有具有特定属性的公共方法或所有具有特定名称的非公共方法的切入点。
- en: Pointcuts are a powerful mechanism for filtering calls and applying aspects
    only to specific parts of the code. By using pointcuts, you can avoid the overhead
    of applying aspects to every single method call and, instead, selectively apply
    aspects only where they are needed. This can result in faster and more efficient
    code, with better separation of concerns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 切入点是一种强大的机制，用于过滤调用并将方面仅应用于代码的特定部分。通过使用切入点，您可以避免将方面应用于每个单独的方法调用的开销，相反，仅在有需要的地方选择性地应用方面。这可以导致代码更快、更高效，并且关注点分离得更好。
- en: Overall, pointcuts are a key feature of AOP, and Windsor Castle provides a rich
    and flexible pointcut mechanism that can be used to create complex and powerful
    aspect-based solutions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，切入点是面向方面编程（AOP）的一个关键特性，Windsor Castle提供了一个丰富且灵活的切入点机制，可用于创建复杂且强大的基于方面的解决方案。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although we’ve used Castle Windsor throughout, there are other tools, frameworks,
    or libr[aries that could al](https://autofac.org)so be used, such as PostSharp
    ([https://www.postsharp.net](https://www.postsharp.net)), Autofac ([https://autofac.org](https://autofac.org)),
    or just use the underlying Castle Core **DynamicProxy** to achieve the same without
    buying into a full-blown framework. You could be hand-rolling this yourself using
    reflection emit as well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们一直使用Castle Windsor，但还有其他工具、框架或库也可以使用，例如PostSharp ([https://www.postsharp.net](https://www.postsharp.net))、Autofac
    ([https://autofac.org](https://autofac.org))，或者只需使用底层的Castle Core **DynamicProxy**来实现相同的功能，而无需购买完整的框架。您也可以使用反射发射自行实现这一点。
- en: Overall, AOP and Castle Windsor provide a powerful mechanism for separating
    concerns in your code and making them more modular and reusable. By selectively
    applying aspects to specific parts of your code, you can achieve a high degree
    of flexibility and control over the behavior of your application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，AOP和Castle Windsor提供了一种强大的机制，用于在您的代码中分离关注点，并使它们更加模块化和可重用。通过选择性地将方面应用于代码的特定部分，您可以实现高度灵活性和对应用程序行为的控制。
- en: In [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting
    Concerns*, we discussed the importance of reducing risk in your codebase, which
    is perhaps the most critical use case. Since security is the most vulnerable aspect
    of our software, it is essential to adopt a zero-trust mindset when it comes to
    this and take all necessary steps to prevent security vulnerabilities.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B19418_13.xhtml#_idTextAnchor206)，*应用横切关注点*中，我们讨论了在代码库中降低风险的重要性，这可能是最关键的使用场景。由于安全性是我们软件中最脆弱的方面，因此在处理这个问题时，采取零信任的心态并采取所有必要的步骤来预防安全漏洞是至关重要的。
- en: Moving onto the next chapter, we will dive into the power of the C# compiler,
    also known as Roslyn. With Roslyn, you get a whole new set of metadata to play
    with and new capabilities for metaprogramming.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 进入下一章，我们将深入探讨C#编译器（也称为Roslyn）的力量。使用Roslyn，您将获得一组全新的元数据来玩耍，以及元编程的新功能。
- en: Part 4:Compiler Magic Using Roslyn
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：使用Roslyn进行编译器魔法
- en: In this part, you will get a glimpse into the C# compiler’s capabilities and
    the different extension points it provides through the .NET Compiler SDK. It dives
    into how the compiler has become an ecosystem and how you can do metaprogramming
    on a compile-time level rather than just the runtime. This part concludes the
    book with an overview of what the book has covered, thoughts on when to use what,
    and some closing words.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您将了解C#编译器的功能以及它通过.NET编译器SDK提供的不同扩展点。它深入探讨了编译器如何成为一个生态系统，以及您如何在编译时而不是仅在运行时进行元编程。这部分以对本书涵盖内容的概述、何时使用什么的思考以及一些结束语结束。
- en: 'This part has the following chapters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn Compiler Extensions*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19418_15.xhtml#_idTextAnchor250)，*Roslyn编译器扩展*'
- en: '[*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating Code*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19418_16.xhtml#_idTextAnchor272)，*生成代码*'
- en: '[*Chapter 17*](B19418_17.xhtml#_idTextAnchor299), *Static Code Analysis*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19418_17.xhtml#_idTextAnchor299)，*静态代码分析*'
- en: '[*Chapter 18*](B19418_18.xhtml#_idTextAnchor323), *Caveats and Final Words*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B19418_18.xhtml#_idTextAnchor323)，*注意事项和结语*'
