<html><head></head><body><div><div><div><h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-371" class="chapterTitle">Implementing Interfaces and Inheriting Classes</h1>
    <p class="normal">This chapter is about deriving new types from existing ones <a id="_idIndexMarker813"/>using <strong class="keyWord">object-oriented programming</strong> (<strong class="keyWord">OOP</strong>). You will learn how to use operators as an alternative method to implement simple functionality, and you will learn how to use generics to make your code safer and more performant. You will learn about delegates and events to exchange messages between types. You will implement interfaces for common functionality. You will create a derived class to inherit from a base class to reuse functionality, override an inherited type member, and use polymorphism. Finally, you will learn how to create extension methods and cast between classes in an inheritance hierarchy.</p>
    <p class="normal">In an online-only section, you will see the differences between reference and value types and how they are stored in memory. You will find links to online materials at the end of this chapter.</p>
    <p class="normal">This chapter covers the following topics:</p>
    <ul>
      <li class="bulletList">Setting up a class library and console application</li>
      <li class="bulletList">Static methods and overloading operators</li>
      <li class="bulletList">Making types safely reusable with generics</li>
      <li class="bulletList">Raising and handling events</li>
      <li class="bulletList">Implementing interfaces</li>
      <li class="bulletList">Working with <code class="inlineCode">null</code> values</li>
      <li class="bulletList">Inheriting from classes</li>
      <li class="bulletList">Casting within inheritance hierarchies</li>
      <li class="bulletList">Inheriting and extending .NET types</li>
      <li class="bulletList">Summarizing custom type choices</li>
    </ul>
    <h1 id="_idParaDest-372" class="heading-1">Setting up a class library and console application</h1>
    <p class="normal">We <a id="_idIndexMarker814"/>will start by <a id="_idIndexMarker815"/>defining a solution with two projects, like the one created in <em class="chapterRef">Chapter 5</em>, <em class="italic">Building Your Own Types with Object-Oriented Programming</em>. Even if you completed all the exercises in that chapter, follow the instructions below so that you start this chapter with fresh working projects:</p>
    <ol>
      <li class="numberedList" value="1">Use your preferred code editor to create a new project, as defined in the following list:<ul>
          <li class="bulletList level-2">Project template: <strong class="screenText">Class Library</strong> / <code class="inlineCode">classlib</code></li>
          <li class="bulletList level-2">Project file and folder: <code class="inlineCode">PacktLibrary</code></li>
          <li class="bulletList level-2">Solution file and folder: <code class="inlineCode">Chapter06</code></li>
          <li class="bulletList level-2">Framework: .NET 9.0 (Standard-Term Support)</li>
        </ul>
      </li>
      <li class="numberedList">Add a new project, as defined in the following list:<ul>
          <li class="bulletList level-2">Project template: <strong class="screenText">Console App</strong> / <code class="inlineCode">console</code></li>
          <li class="bulletList level-2">Project file and folder: <code class="inlineCode">PeopleApp</code></li>
          <li class="bulletList level-2">Solution file and folder: <code class="inlineCode">Chapter06</code></li>
          <li class="bulletList level-2">Framework: .NET 9.0 (Standard-Term Support)</li>
          <li class="bulletList level-2">Do not use top-level statements: Cleared</li>
          <li class="bulletList level-2">Enable native AOT publish: Cleared</li>
        </ul>
      </li>
    </ol>
    <div><p class="normal">In this chapter, both projects target .NET 9 and, therefore, use the C# 13 compiler by default.</p>
    </div>
    <ol>
      <li class="numberedList" value="3">In the <code class="inlineCode">PacktLibrary</code> project, rename the file named <code class="inlineCode">Class1.cs</code> to <code class="inlineCode">Person.cs</code>.</li>
      <li class="numberedList">In both projects, add <code class="inlineCode">&lt;ItemGroup&gt;</code> to globally and statically import the <code class="inlineCode">System.Console</code> class, as shown in the following markup:
        <pre class="programlisting code-one"><code class="hljs-code">&lt;ItemGroup&gt;
  &lt;Using Include="System.Console" Static="true" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Person.cs</code>, delete<a id="_idIndexMarker816"/> any existing statements and <a id="_idIndexMarker817"/>define a <code class="inlineCode">Person</code> class, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class Person
{
  #region Properties
  public string? Name { get; set; }
  public DateTimeOffset Born { get; set; }
  public List&lt;Person&gt; Children { get; set; } = new();
  #endregion
  #region Methods
  public void WriteToConsole()
  {
    WriteLine($"{Name} was born on a {Born:dddd}.");
  }
  public void WriteChildrenToConsole()
  {
    string term = Children.Count == 1 ? "child" : "children";
    WriteLine($"{Name} has {Children.Count} {term}.");
  }
  #endregion
}
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">PeopleApp</code> project, add<a id="_idIndexMarker818"/> a project reference to <code class="inlineCode">PacktLibrary</code>, as <a id="_idIndexMarker819"/>shown in the following markup:
        <pre class="programlisting code-one"><code class="hljs-code">&lt;ItemGroup&gt;
  &lt;ProjectReference
    Include="..\PacktLibrary\PacktLibrary.csproj" /&gt;
&lt;/ItemGroup&gt;
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete the existing statements, write statements to create an instance of <code class="inlineCode">Person</code>, and then write information about it to the console, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">using Packt.Shared;
Person harry = new()
{
  Name = "Harry",
  Born = new(year: 2001, month: 3, day: 25,
    hour: 0, minute: 0, second: 0,
    offset: TimeSpan.Zero)
};
harry.WriteToConsole();
</code></pre>
      </li>
      <li class="numberedList">If you use Visual Studio, configure the startup project for the solution as the current selection.</li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project <a id="_idIndexMarker820"/>and note the result, as shown in the <a id="_idIndexMarker821"/>following output:
        <pre class="programlisting con-one"><code class="hljs-con">Harry was born on a Sunday.
</code></pre>
      </li>
    </ol>
    <h1 id="_idParaDest-373" class="heading-1">Static methods and overloading operators</h1>
    <p class="normal">This section is specifically about methods<a id="_idIndexMarker822"/> that apply to two instances of the same type. It is not about the more general case of methods that apply to zero, one, or more than two instances. Remember that static methods do not require an object instance. They are called directly using the class name.</p>
    <p class="normal">I wanted to think of<a id="_idIndexMarker823"/> some methods that would apply to two <code class="inlineCode">Person</code> instances that could also become binary operators, like <code class="inlineCode">+</code> and <code class="inlineCode">*</code>. What would adding two people <a id="_idIndexMarker824"/>together represent? What would multiplying two people represent? The obvious answers are getting married and having babies.</p>
    <div><p class="normal">We will design our methods to enable us to model the story of Lamech and his two wives and their children, as described at the following link:</p>
      <p class="normal"><a href="https://www.kingjamesbibleonline.org/Genesis-4-19/">https://www.kingjamesbibleonline.org/Genesis-4-19/</a></p>
    </div>
    <p class="normal">We might want two instances of <code class="inlineCode">Person</code> to be able to marry and procreate. We can implement this by writing methods and overriding operators. Instance methods are actions that an object does to itself; static methods are actions the type does.</p>
    <p class="normal">Which you choose depends on what makes the most sense for the action.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Having both static and instance methods to perform similar actions often makes sense. For example, <code class="inlineCode">string</code> has both a <code class="inlineCode">Compare</code> static method and a <code class="inlineCode">CompareTo</code> instance method. This puts the choice of how to use the functionality in the hands of the programmers using your type, giving them more flexibility.</p>
    </div>
    <h2 id="_idParaDest-374" class="heading-2">Implementing functionality using methods</h2>
    <p class="normal">Let’s start by implementing some functionality<a id="_idIndexMarker825"/> by using both static and instance methods:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Person.cs</code>, add properties with private backing storage fields to indicate if that person is married and to whom, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Allow multiple spouses to be stored for a person.
public List&lt;Person&gt; Spouses { get; set; } = new();
// A read-only property to show if a person is married to anyone.
public bool Married =&gt; Spouses.Count &gt; 0;
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Person.cs</code>, add one instance method and one static method that will allow two <code class="inlineCode">Person</code> objects to marry, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Static method to marry two people.
public static void Marry(Person p1, Person p2)
{
  ArgumentNullException.ThrowIfNull(p1);
  ArgumentNullException.ThrowIfNull(p2);
  if (p1.Spouses.Contains(p2) || p2.Spouses.Contains(p1))
  {
    throw new ArgumentException(
      string.Format("{0} is already married to {1}.",
      arg0: p1.Name, arg1: p2.Name));
  }
  p1.Spouses.Add(p2);
  p2.Spouses.Add(p1);
}
// Instance method to marry another person.
public void Marry(Person partner)
{
  Marry(this, partner); // "this" is the current person.
}
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Note the <a id="_idIndexMarker826"/>following:</p>
    <ul>
      <li class="bulletList level-2">In the <code class="inlineCode">static</code> method, the <code class="inlineCode">Person</code> objects are passed as parameters named <code class="inlineCode">p1</code> and <code class="inlineCode">p2</code>, and guard clauses are used to check for <code class="inlineCode">null</code> values. If either is already married to the other, an exception is thrown; otherwise, they are each added to each other’s list of spouses. You can model this differently if you want to allow two people to have multiple marriage ceremonies. In that case, you might choose to not throw an exception and instead do nothing. Their state of marriage would remain the same. Additional calls to <code class="inlineCode">Marry</code> would not change if they are married or not. In this scenario, I want you to see that the code recognizes that they are already married by throwing an exception.</li>
      <li class="bulletList level-2">In the instance method, a call is made to the <code class="inlineCode">static</code> method, passing the current person (<code class="inlineCode">this</code>) and the <code class="inlineCode">partner</code> they want to marry.<div><p class="normal"><strong class="keyWord">Warning!</strong> Although instance methods can call static methods, the opposite is not true. A static method cannot call an instance method because there isn’t an object instance to call it on.</p>
        </div>
      </li>
    </ul>
    <ol>
      <li class="numberedList" value="3">In <code class="inlineCode">Person.cs</code>, add an instance method to the <code class="inlineCode">Person</code> class that will output the spouses of a person if they are married, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public void OutputSpouses()
{
  if (Married)
  {
    string term = Spouses.Count == 1 ? "person" : "people";
    WriteLine($"{Name} is married to {Spouses.Count} {term}:");
    foreach (Person spouse in Spouses)
    {
      WriteLine($"  {spouse.Name}");
    }
  }
  else
  {
    WriteLine($"{Name} is a singleton.");
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Person.cs</code>, add one instance method and one static method to the <code class="inlineCode">Person</code> class that will allow two <code class="inlineCode">Person</code> objects to procreate if they are married to each other, as <a id="_idIndexMarker827"/>shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">/// &lt;summary&gt;
/// Static method to "multiply" aka procreate and have a child together.
/// &lt;/summary&gt;
/// &lt;param name="p1"&gt;Parent 1&lt;/param&gt;
/// &lt;param name="p2"&gt;Parent 2&lt;/param&gt;
/// &lt;returns&gt;A Person object that is the child of Parent 1 and Parent 2.&lt;/returns&gt;
/// &lt;exception cref="ArgumentNullException"&gt;If p1 or p2 are null.&lt;/exception&gt;
/// &lt;exception cref="ArgumentException"&gt;If p1 and p2 are not married.&lt;/exception&gt;
public static Person Procreate(Person p1, Person p2)
{
  ArgumentNullException.ThrowIfNull(p1);
  ArgumentNullException.ThrowIfNull(p2);
  if (!p1.Spouses.Contains(p2) &amp;&amp; !p2.Spouses.Contains(p1))
  {
    throw new ArgumentException(string.Format(
      "{0} must be married to {1} to procreate with them.",
      arg0: p1.Name, arg1: p2.Name));
  }
  Person baby = new()
  {
    Name = $"Baby of {p1.Name} and {p2.Name}",
    Born = DateTimeOffset.Now
  };
  p1.Children.Add(baby);
  p2.Children.Add(baby);
  return baby;
}
// Instance method to "multiply".
public Person ProcreateWith(Person partner)
{
  return Procreate(this, partner);
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Note the <a id="_idIndexMarker828"/>following:</p>
    <ul>
      <li class="bulletList">In the <code class="inlineCode">static</code> method named <code class="inlineCode">Procreate</code>, the <code class="inlineCode">Person</code> objects that will procreate are passed as parameters named <code class="inlineCode">p1</code> and <code class="inlineCode">p2</code>.</li>
      <li class="bulletList">A new <code class="inlineCode">Person</code> class named <code class="inlineCode">baby</code> is created with a name composed of a combination of the two people who have procreated. This could be changed later by setting the returned <code class="inlineCode">baby</code> variable’s <code class="inlineCode">Name</code> property. Although we could add a third parameter to the <code class="inlineCode">Procreate</code> method for the baby name, we will define a binary operator later, and they cannot have third parameters. So, for consistency, we will just return the baby reference and let the calling code set the name of it.</li>
      <li class="bulletList">The <code class="inlineCode">baby</code> object is added to the <code class="inlineCode">Children</code> collection of both parents and then returned. Classes are reference types, meaning a reference to the <code class="inlineCode">baby</code> object stored in memory is added, not a clone of the <code class="inlineCode">baby</code> object.</li>
      <li class="bulletList">In the instance method named <code class="inlineCode">ProcreateWith</code>, the <code class="inlineCode">Person</code> object to procreate with is passed as a parameter named <code class="inlineCode">partner</code>, and that, along with <code class="inlineCode">this</code>, which represents the current object, is passed to the static <code class="inlineCode">Procreate</code> method to reuse the method implementation. <code class="inlineCode">this</code> is a keyword that references the current instance of the class. It is a convention to use different method names for related static and instance methods, but not to the extent that you would fail to match standard English meaning. </li>
    </ul>
    <p class="bulletList">So, that could mean naming both methods the same, as in the example of <code class="inlineCode">Marry(x, y)</code> for the static method name and <code class="inlineCode">x.Marry(y)</code> for the instance method name. More commonly, it would mean using a different method name, for example, <code class="inlineCode">Procreate(x, y)</code> for the static method name and <code class="inlineCode">x.ProcreateWith(y)</code> for the instance method name, or <code class="inlineCode">Compare(x, y)</code> for the static method name and <code class="inlineCode">x.CompareTo(y)</code> for the instance method name.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: A method that creates a new object, or modifies an existing object, should return a reference to that object so that the caller can access the results.</p>
    </div>
    <p class="numberedList">5. In <code class="inlineCode">Program.cs</code>, create<a id="_idIndexMarker829"/> three people and have them marry and then procreate with each other, noting that to add a double-quote character into a <code class="inlineCode">string</code>, you must prefix it with a backslash character like this, <code class="inlineCode">\"</code>, as shown in the following code:</p>
    <pre class="programlisting code-one"><code class="hljs-code">// Implementing functionality using methods.
Person lamech = new() { Name = "Lamech" };
Person adah = new() { Name = "Adah" };
Person zillah = new() { Name = "Zillah" };
// Call the instance method to marry Lamech and Adah.
lamech.Marry(adah);
// Call the static method to marry Lamech and Zillah.
Person.Marry(lamech, zillah);
lamech.OutputSpouses();
adah.OutputSpouses();
zillah.OutputSpouses();
// Call the instance method to make a baby.
Person baby1 = lamech.ProcreateWith(adah);
baby1.Name = "Jabal";
WriteLine($"{baby1.Name} was born on {baby1.Born}");
// Call the static method to make a baby.
Person baby2 = Person.Procreate(zillah, lamech);
baby2.Name = "Tubalcain";
adah.WriteChildrenToConsole();
zillah.WriteChildrenToConsole();
lamech.WriteChildrenToConsole();
for (int i = 0; i &lt; lamech.Children.Count; i++)
{
  WriteLine(format: "  {0}'s child #{1} is named \"{2}\".",
    arg0: lamech.Name, arg1: i,
    arg2: lamech.Children[i].Name);
}
</code></pre>
    <div><p class="normal">I used a <code class="inlineCode">for</code> instead of a <code class="inlineCode">foreach</code> statement so that I could use the <code class="inlineCode">i</code> variable with the indexer to access each child.</p>
    </div>
    <p class="numberedList">6. Run the <code class="inlineCode">PeopleApp</code> project <a id="_idIndexMarker830"/>and view the result, as shown in the following output:</p>
    <pre class="programlisting con-one"><code class="hljs-con">Lamech is married to 2 people:
  Adah
  Zillah
Adah is married to 1 person:
  Lamech
Zillah is married to 1 person:
  Lamech
Jabal was born on 05/07/2023 15:17:03 +01:00
Adah has 1 child.
Zillah has 1 child.
Lamech has 2 children:
  Lamech's child #0 is named "Jabal".
  Lamech's child #1 is named "Tubalcain".
</code></pre>
    <p class="normal">As you have just <a id="_idIndexMarker831"/>seen, for functionality that applies to two instances of an object type, it is easy to provide both static and instance methods to implement the same functionality. Neither static nor instance methods are best in all scenarios, and you cannot predict how your type might be used. It is best to provide both to allow a developer to use your types in the way that best fits their needs.</p>
    <p class="normal">Now let’s see how we can add a third way to provide the same functionality for two instances of a type.</p>
    <h2 id="_idParaDest-375" class="heading-2">Implementing functionality using operators</h2>
    <p class="normal">The <code class="inlineCode">System.String</code> class has a <code class="inlineCode">static</code> method <a id="_idIndexMarker832"/>named <code class="inlineCode">Concat</code> that concatenates two <code class="inlineCode">string</code> values and returns the result, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">string s1 = "Hello ";
string s2 = "World!";
string s3 = string.Concat(s1, s2);
WriteLine(s3); // Hello World!
</code></pre>
    <p class="normal">Calling a method like <code class="inlineCode">Concat</code> works, but it might be more natural for a programmer to use the <code class="inlineCode">+</code> symbol operator to “add” two <code class="inlineCode">string</code> values together, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">string s3 = s1 + s2;
</code></pre>
    <p class="normal">A well-known biblical phrase is <em class="italic">Go forth and multiply</em>, meaning to procreate. Let’s write code so that the <code class="inlineCode">*</code> (multiply) symbol will allow two <code class="inlineCode">Person</code> objects to procreate. And we will use the <code class="inlineCode">+</code> operator to marry two people.</p>
    <p class="normal">We do this by <a id="_idIndexMarker833"/>defining a <code class="inlineCode">static</code> operator for the <code class="inlineCode">*</code> symbol. The syntax is rather like a method, because in effect, an operator <em class="italic">is</em> a method, but it uses a symbol instead of a method name, which makes the syntax more concise:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Person.cs</code>, create a <code class="inlineCode">static</code> operator for the <code class="inlineCode">+</code> symbol, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">#region Operators
// Define the + operator to "marry".
public static bool operator +(Person p1, Person p2)
{
  Marry(p1, p2);
  // Confirm they are both now married.
  return p1.Married &amp;&amp; p2.Married;
}
#endregion
</code></pre>
      </li>
    </ol>
    <div><p class="normal">The return type for an operator does not need to match the types passed as parameters to the operator, but the return type cannot be <code class="inlineCode">void</code>.</p>
    </div>
    <ol>
      <li class="numberedList" value="2">In <code class="inlineCode">Person.cs</code>, create a <code class="inlineCode">static</code> operator for the <code class="inlineCode">*</code> symbol, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Define the * operator to "multiply".
public static Person operator *(Person p1, Person p2)
{
  // Return a reference to the baby that results from multiplying.
  return Procreate(p1, p2);
}
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Unlike methods, operators do not appear in IntelliSense lists for a type or a type instance when you enter a dot (<code class="inlineCode">.</code>). For every operator that you define, make a method as well, because it may not be obvious to a programmer that the operator is available. The implementation of the operator can then call the method, reusing the code you have written. A second reason to provide a method is that operators are not supported by every language compiler; for example, although arithmetic operators like <code class="inlineCode">*</code> are supported by Visual Basic and F#, there is no requirement that other languages support all operators supported by C#. You have to read the type definition or the documentation to discover whether operators are implemented.</p>
    </div>
    <ol>
      <li class="numberedList" value="3">In <code class="inlineCode">Program.cs</code>, comment <a id="_idIndexMarker834"/>out the statement that calls the static <code class="inlineCode">Marry</code> method to marry Zillah and Lamech, and replace it with an <code class="inlineCode">if</code> statement that uses the <code class="inlineCode">+</code> operator to marry them, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Person.Marry(lamech, zillah);
if (lamech + zillah)
{
  WriteLine($"{lamech.Name} and {zillah.Name} successfully got married.");
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, after calling the <code class="inlineCode">Procreate</code> method and before the statements that write the children to the console, use the <code class="inlineCode">*</code> operator for Lamech to have two more babies with his wives, Adah and Zillah, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Use the * operator to "multiply".
Person baby3 = lamech * adah;
baby3.Name = "Jubal";
Person baby4 = zillah * lamech;
baby4.Name = "Naamah";
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project<a id="_idIndexMarker835"/> and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Lamech and Zillah successfully got married.
Lamech is married to 2 people:
  Adah
  Zillah
Adah is married to 1 person:
  Lamech
Zillah is married to 1 person:
  Lamech
Jabal was born on 05/07/2023 15:27:30 +01:00
Adah has 2 children.
Zillah has 2 children.
Lamech has 4 children:
  Lamech's child #0 is named "Jabal".
  Lamech's child #1 is named "Tubalcain".
  Lamech's child #2 is named "Jubal".
  Lamech's child #3 is named "Naamah".
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">More Information</strong>: To learn more about operator overloading, you can read the documentation at the following link:</p>
      <p class="normal"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading</a></p>
    </div>
    <h1 id="_idParaDest-376" class="heading-1">Making types safely reusable with generics</h1>
    <p class="normal">In 2005, with C# 2 and .NET Framework 2, Microsoft introduced a feature named <strong class="keyWord">generics</strong>, which <a id="_idIndexMarker836"/>enables your types to be more safely reusable and efficient. It does this by allowing a programmer to pass types as parameters, like how you can pass objects as parameters.</p>
    <div><p class="normal">This topic is only about types that need to provide flexibility for the types they work with. For example, collection types need to be able to store multiple instances of any type. That flexibility can be provided either by using the <code class="inlineCode">System.Object</code> type or generics. For other scenarios that do not need type flexibility, the use of non-generic types is good practice.</p>
    </div>
    <h2 id="_idParaDest-377" class="heading-2">Working with non-generic types</h2>
    <p class="normal">First, let’s look at an<a id="_idIndexMarker837"/> example of working with a non-generic type so that you can understand the problems that generics are designed to solve, such as weakly typed parameters and values, and performance problems caused by using <code class="inlineCode">System.Object</code>.</p>
    <p class="normal"><code class="inlineCode">System.Collections.Hashtable</code> can be used to store multiple key-value pairs, each with a unique key that can later be used to quickly look up its value. Both the key and value can be any object because they are declared as <code class="inlineCode">System.Object</code>. Although this provides flexibility, it is slow, and bugs are easier to introduce because no type checks are made when adding items.</p>
    <p class="normal">Let’s write some code:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, create an instance of the non-generic collection, <code class="inlineCode">System.Collections.Hashtable</code>, and then add four items to it, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Non-generic lookup collection.
System.Collections.Hashtable lookupObject = new();
lookupObject.Add(key: 1, value: "Alpha");
lookupObject.Add(key: 2, value: "Beta");
lookupObject.Add(key: 3, value: "Gamma");
lookupObject.Add(key: harry, value: "Delta");
</code></pre>
      </li>
    </ol>
    <div><p class="normal">Note that three items have a unique integer key to look them up. The last item has a <code class="inlineCode">Person</code> object as its key to look it up. This is valid in a non-generic collection.</p>
    </div>
    <ol>
      <li class="numberedList" value="2">Add<a id="_idIndexMarker838"/> statements to define a <code class="inlineCode">key</code> with the value of <code class="inlineCode">2</code> and use it to look up its value in the <em class="italic">hash</em> table, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">int key = 2; // Look up the value that has 2 as its key.
WriteLine(format: "Key {0} has value: {1}",
  arg0: key,
  arg1: lookupObject[key]);
</code></pre>
      </li>
      <li class="numberedList">Add statements to use the <code class="inlineCode">harry</code> object to look up its value, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Look up the value that has harry as its key.
WriteLine(format: "Key {0} has value: {1}",
  arg0: harry,
  arg1: lookupObject[harry]);
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and note that it works, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Key 2 has value: Beta
Key Packt.Shared.Person has value: Delta
</code></pre>
      </li>
    </ol>
    <p class="normal">Although the code works, there is potential for mistakes because literally any type can be used for the key or value. If another developer used your variable named <code class="inlineCode">lookupObject</code> and expected all the items to be a certain type, they might cast them to that type and get exceptions because some values might be a different type. A lookup object with lots of items would also give poor performance.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Avoid types in the <code class="inlineCode">System.Collections</code> namespace. Use types in the <code class="inlineCode">System.Collections.Generics</code> and related namespaces instead. If you need to use a library that uses non-generic types, then of course you will have to use non-generic types. This is an example of what is commonly referred to as technical debt.</p>
    </div>
    <h2 id="_idParaDest-378" class="heading-2">Working with generic types</h2>
    <p class="normal"><code class="inlineCode">System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;</code> can be used to store multiple values, each with <a id="_idIndexMarker839"/>a unique key that can later be used to quickly look up its value. Both the key and value can be any object, but you must tell the compiler what the types of the key and value will be when you first instantiate the collection. You do this by specifying types for the <strong class="keyWord">generic parameters</strong> in<a id="_idIndexMarker840"/> angle brackets <code class="inlineCode">&lt;&gt;</code>, <code class="inlineCode">TKey</code>, and <code class="inlineCode">TValue</code>.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: When a generic type has one definable type, it should be named <code class="inlineCode">T</code>, for example, <code class="inlineCode">List&lt;T&gt;</code>, where <code class="inlineCode">T</code> is the type stored in the list. When a generic type has multiple definable types, it should use <code class="inlineCode">T</code> as a name prefix and have a sensible name, for example, <code class="inlineCode">Dictionary&lt;TKey, TValue&gt;</code>.</p>
    </div>
    <p class="normal">Generics provides flexibility, is faster, and makes bugs easier to avoid because type checks are made when adding items at compile time. We will not need to explicitly specify the <code class="inlineCode">System.Collections.Generic</code> namespace that contains <code class="inlineCode">Dictionary&lt;TKey, TValue&gt;</code> because it is implicitly and globally imported by default.</p>
    <p class="normal">Let’s write some code to solve the problem by using generics:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, create <a id="_idIndexMarker841"/>an instance of the generic lookup collection <code class="inlineCode">Dictionary&lt;TKey, TValue&gt;</code> and then add four items to it, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Define a generic lookup collection.
Dictionary&lt;int, string&gt; lookupIntString = new();
lookupIntString.Add(key: 1, value: "Alpha");
lookupIntString.Add(key: 2, value: "Beta");
lookupIntString.Add(key: 3, value: "Gamma");
lookupIntString.Add(key: harry, value: "Delta");
</code></pre>
      </li>
      <li class="numberedList">Note the compile error when using <code class="inlineCode">harry</code> as a key, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">/Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503: Argument 1: cannot convert from 'Packt.Shared.Person' to 'int' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj]
</code></pre>
      </li>
      <li class="numberedList">Replace <code class="inlineCode">harry</code> with <code class="inlineCode">4</code>.</li>
      <li class="numberedList">Add statements to set the <code class="inlineCode">key</code> to <code class="inlineCode">3</code>, and use it to look up its value in the dictionary, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">key = 3;
WriteLine(format: "Key {0} has value: {1}",
  arg0: key,
  arg1: lookupIntString[key]);
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and note that it works, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Key 3 has value: Gamma
</code></pre>
      </li>
    </ol>
    <p class="normal">You have now seen the difference between non-generic and generic types that need the flexibility to store any type. You know to always use generic collection types if possible. Unless you are unlucky enough to be forced to use a legacy non-generic library, you never <a id="_idIndexMarker842"/>need to write code that uses non-generic types that can store any type again.</p>
    <p class="normal">Just because it is good practice to use generic collection types in preference to non-generic collection types does not mean the more general case is also true. Non-generic non-collection types and other types that do not need the flexibility to work with any type are used all the time. Collection types just happen to be the most common type that benefits from generics.</p>
    <h1 id="_idParaDest-379" class="heading-1">Raising and handling events</h1>
    <p class="normal">Methods <a id="_idIndexMarker843"/>are often described as <em class="italic">actions that an object can perform, either on itself or on related objects</em>. For example, <code class="inlineCode">List&lt;T&gt;</code> can add an item to itself or clear<a id="_idIndexMarker844"/> itself, and <code class="inlineCode">File</code> can create or delete a file in the filesystem.</p>
    <p class="normal">Events are often described as <em class="italic">actions that happen to an object</em>. For example, in a user interface, <code class="inlineCode">Button</code> has a <code class="inlineCode">Click</code> event, a click being something that happens to a button. Also, <code class="inlineCode">FileSystemWatcher</code> listens to the filesystem for change notifications and raises events like <code class="inlineCode">Created</code> and <code class="inlineCode">Deleted</code>, which are triggered when a directory or file changes.</p>
    <p class="normal">Another way to think of events is that they provide a way of exchanging messages between objects.</p>
    <p class="normal">Events are built on <strong class="keyWord">delegates</strong>, so let’s<a id="_idIndexMarker845"/> start by having a look at what delegates are and how they work.</p>
    <h2 id="_idParaDest-380" class="heading-2">Calling methods using delegates</h2>
    <p class="normal">You have <a id="_idIndexMarker846"/>already seen the most common way to call<a id="_idIndexMarker847"/> or execute a method: using the <code class="inlineCode">.</code> operator to access the method using its name. For example, <code class="inlineCode">Console.WriteLine</code> tells the <code class="inlineCode">Console</code> type to call its <code class="inlineCode">WriteLine</code> method.</p>
    <p class="normal">The<a id="_idIndexMarker848"/> other way to call or execute a method is to use a delegate. If <a id="_idIndexMarker849"/>you have used languages that <a id="_idIndexMarker850"/>support <strong class="keyWord">function pointers</strong>, then think of a delegate as being<a id="_idIndexMarker851"/> a <strong class="keyWord">type-safe method pointer</strong>.</p>
    <p class="normal">In other words, a delegate contains the memory address of a method that must match the same signature as the delegate, enabling it to be called safely with the correct parameter types.</p>
    <div><p class="normal">The code in this section is illustrative and not meant to be typed into a project. You will explore code like this in the next section, so for now, just read the code and try to understand its meaning.</p>
    </div>
    <p class="normal">For example, imagine there is a method in the <code class="inlineCode">Person</code> class that must have a <code class="inlineCode">string</code> type passed as its only parameter, and it returns an <code class="inlineCode">int</code> type, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public class Person
{
  public int MethodIWantToCall(string input)
  {
    return input.Length; // It doesn't matter what the method does.
  }
</code></pre>
    <p class="normal">I can call this method on an instance of <code class="inlineCode">Person</code> named <code class="inlineCode">p1</code> like this:</p>
    <pre class="programlisting code"><code class="hljs-code">Person p1 = new();
int answer = p1.MethodIWantToCall("Frog");
</code></pre>
    <p class="normal">Alternatively, I can define a delegate with a matching signature to call the method indirectly. Note that the names of the parameters do not have to match. Only the types of parameters and return values must match, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">delegate int DelegateWithMatchingSignature(string s);
</code></pre>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: A <code class="inlineCode">delegate</code> is a reference type like a <code class="inlineCode">class</code>, so if you define one in <code class="inlineCode">Program.cs</code>, then it must be at the bottom of the file. It would be best to define it in its own class file, for example, <code class="inlineCode">Program.Delegates.cs</code>. If you defined a delegate in the middle of <code class="inlineCode">Program.cs</code>, then you would see the following compiler error: <code class="inlineCode">CS8803: Top-level statements must precede namespace and type declarations</code>.</p>
    </div>
    <p class="normal">Now, I can <a id="_idIndexMarker852"/>create an instance of the delegate, point it<a id="_idIndexMarker853"/> at the method, and finally, call the delegate (which calls the method), as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// Create a delegate instance that points to the method.
DelegateWithMatchingSignature d = new(p1.MethodIWantToCall);
// Call the delegate, which then calls the method.
int answer2 = d("Frog");
</code></pre>
    <h2 id="_idParaDest-381" class="heading-2">Examples of delegate use</h2>
    <p class="normal">You are probably thinking, <em class="italic">“What’s the point of that?”</em></p>
    <p class="normal">It<a id="_idIndexMarker854"/> provides flexibility. For example, we could use delegates to create a queue of methods that need to be called in order. Queuing actions that need to be performed is common in services to provide improved scalability.</p>
    <p class="normal">Another example is to allow multiple actions to execute in parallel. Delegates have built-in support for asynchronous operations that run on a different thread, which can provide improved responsiveness.</p>
    <p class="normal">The most important example is that delegates allow us to implement events to send messages between different objects that do not need to know about each other. Events are an example of loose coupling between components because they do <a id="_idIndexMarker855"/>not need to know about each other; they just need to know the event signature.</p>
    <h2 id="_idParaDest-382" class="heading-2">Status: It’s complicated</h2>
    <p class="normal">Delegates and <a id="_idIndexMarker856"/>events are two <a id="_idIndexMarker857"/>of the most confusing features of C# and can take a few attempts to understand, so don’t worry if you feel lost as we walk through how they work! Move on to other topics and come back again another day when your brain has had the opportunity to process the concepts while you sleep.</p>
    <h2 id="_idParaDest-383" class="heading-2">Defining and handling delegates</h2>
    <p class="normal">Microsoft<a id="_idIndexMarker858"/> has two predefined delegates<a id="_idIndexMarker859"/> for use as events. They both have two parameters:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">object? sender</code>: This parameter is a reference to the object raising the event or sending the message. The <code class="inlineCode">?</code> indicates that this reference could be <code class="inlineCode">null</code>.</li>
      <li class="bulletList"><code class="inlineCode">EventArgs e</code> or <code class="inlineCode">TEventArgs e</code>: This parameter contains additional relevant information about the event. For example, in a GUI app, you might define <code class="inlineCode">MouseMoveEventArgs</code>, which has properties for the <code class="inlineCode">X</code> and <code class="inlineCode">Y</code> coordinates for the mouse pointer. A bank account might have a <code class="inlineCode">WithdrawEventArgs</code> with a property for the <code class="inlineCode">Amount</code> to withdraw.</li>
    </ul>
    <p class="normal">Their signatures are simple, yet flexible, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// For methods that do not need additional argument values passed in.
public delegate void EventHandler(object? sender, EventArgs e);
// For methods that need additional argument values passed in as
// defined by the generic type TEventArgs.
public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);
</code></pre>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: When you want to define an event in your own type, you should use one of these two predefined delegates.</p>
    </div>
    <p class="normal">Some types provide “empty” values for when you need an instance, but it doesn’t need to have any particular value. For example:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">string.Empty</code> is an empty string value <code class="inlineCode">""</code>. It is better to use <code class="inlineCode">string.Empty</code> than <code class="inlineCode">""</code> because every time you use <code class="inlineCode">""</code> the compiler must instantiate a new empty string instance. You can think of <code class="inlineCode">string.Empty</code> as a global single instance of an empty string. Sharing it is more efficient than creating your own new instances every time you need to reference an empty string value.</li>
      <li class="bulletList"><code class="inlineCode">EventArgs.Empty</code> is an empty <code class="inlineCode">EventArgs</code> value. Use it when you must conform to the built-in event delegates that require an <code class="inlineCode">EventArgs</code> instance to be passed as a parameter, but it doesn’t need any particular value because it won’t be read or used in the method anyway.</li>
    </ul>
    <p class="normal">You might<a id="_idIndexMarker860"/> have a delegate <a id="_idIndexMarker861"/>defined, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public EventHandler? Shout; // This field could be null.
</code></pre>
    <p class="normal">In that case, there are multiple ways to call the delegate, as shown in the following code examples:</p>
    <ul>
      <li class="bulletList">Use its variable name, <code class="inlineCode">Shout</code>:
        <pre class="programlisting code-one"><code class="hljs-code">Shout(this, EventArgs.Empty);
</code></pre>
      </li>
      <li class="bulletList">Use its <code class="inlineCode">Invoke</code> method to call it synchronously:
        <pre class="programlisting code-one"><code class="hljs-code">Shout.Invoke(this, EventArgs.Empty);
</code></pre>
      </li>
      <li class="bulletList">Use its <code class="inlineCode">BeginInvoke</code> method to call it asynchronously, without a callback function or any state:
        <pre class="programlisting code-one"><code class="hljs-code">IAsyncResult result = Shout.BeginInvoke(
  this, EventArgs.Empty, null, null);
</code></pre>
      </li>
    </ul>
    <div><p class="normal">The <code class="inlineCode">BeginInvoke</code> method is beyond the scope of this book, but I have included it so that you know it exists.</p>
    </div>
    <p class="normal">Delegates and <a id="_idIndexMarker862"/>their method handlers have a potentially many-to-many <a id="_idIndexMarker863"/>relationship. One delegate can have one method handler. But one delegate can also have many method handlers (you will do this when you hook up <code class="inlineCode">Shout</code> to both <code class="inlineCode">Harry_Shout</code> and <code class="inlineCode">Harry_Shout_2</code>). And many delegates can reference one method handler, or any combination of these. Let’s explore delegates and events:</p>
    <ol>
      <li class="numberedList" value="1">Add statements to the <code class="inlineCode">Person</code> class and note the following points, as shown in the following code:<ul>
          <li class="bulletList level-2">It defines an <code class="inlineCode">EventHandler</code> delegate field named <code class="inlineCode">Shout</code>.</li>
          <li class="bulletList level-2">It defines an <code class="inlineCode">int</code> field to store <code class="inlineCode">AngerLevel</code>.</li>
          <li class="bulletList level-2">It defines a method named <code class="inlineCode">Poke</code>.</li>
          <li class="bulletList level-2">Each time a person is poked, their <code class="inlineCode">AngerLevel</code> increments. Once their <code class="inlineCode">AngerLevel</code> reaches three, they raise the <code class="inlineCode">Shout</code> event, but only if there is at least one event delegate pointing at a method defined somewhere else in the code; that is, it is not <code class="inlineCode">null</code>:</li>
        </ul>
        <pre class="programlisting code-one"><code class="hljs-code">#region Events
// Delegate field to define the event.
public EventHandler? Shout; // null initially.
// Data field related to the event.
public int AngerLevel;
// Method to trigger the event in certain conditions.
public void Poke()
{
  AngerLevel++;
  if (AngerLevel &lt; 3) return;
  // If something is listening to the event...
  if (Shout is not null)
  {
    // ...then call the delegate to "raise" the event.
    Shout(this, EventArgs.Empty);
  }
}
#endregion
</code></pre>
      </li>
    </ol>
    <div><p class="normal">Checking whether an object is not <code class="inlineCode">null</code> before calling one of its methods is very common. C# 6 and later allow <code class="inlineCode">null</code> checks to be simplified inline using a <code class="inlineCode">?</code> symbol before the <code class="inlineCode">.</code> operator, as shown in the following code:</p>
      <p class="normal"><code class="inlineCode">Shout?.Invoke(this, EventArgs.Empty);</code></p>
    </div>
    <ol>
      <li class="numberedList" value="2">In the <code class="inlineCode">PeopleApp</code> project, add<a id="_idIndexMarker864"/> a new class file named <code class="inlineCode">Program.EventHandlers.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.EventHandlers.cs</code>, delete <a id="_idIndexMarker865"/>any existing statements, and then add a method with a matching signature that gets a reference to the <code class="inlineCode">Person</code> object from the <code class="inlineCode">sender</code> parameter and outputs some information about them, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">using Packt.Shared; // To use Person.
// No namespace declaration so this extends the Program class
// in the null namespace.
partial class Program
{
  // A method to handle the Shout event received by the harry object.
  private static void Harry_Shout(object? sender, EventArgs e)
  {
    // If no sender, then do nothing.
    if (sender is null) return;
    // If sender is not a Person, then do nothing and return; else assign sender to p.
    if (sender is not Person p) return;
    WriteLine($"{p.Name} is this angry: {p.AngerLevel}.");
  }
}
</code></pre>
        <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Microsoft’s convention for method names that handle events is <code class="inlineCode">ObjectName_EventName</code>. In this project, <code class="inlineCode">sender</code> will always be a <code class="inlineCode">Person</code> instance, so the <code class="inlineCode">null</code> checks are not necessary, and the event handler could be much simpler with just the <code class="inlineCode">WriteLine</code> statement. However, it is important to know that these types of <code class="inlineCode">null</code> checks make your code more robust in cases of event misuse.</p>
        </div>
      </li>
    </ol>
    <div><p class="normal">You can have as many methods as you like to be event handlers, named whatever you like, as long as the method signature matches the delegate signature. This means you could have 50 <code class="inlineCode">Person</code> instances, each with their own method, or have one method that they all share. The methods can be declared at any level that makes sense for the scenario and matches the access levels set (like <code class="inlineCode">protected</code>, <code class="inlineCode">private</code>, <code class="inlineCode">public</code>, and so on). One of the key benefits of delegates and events is loose binding between components so maximum flexibility is desired.</p>
    </div>
    <ol>
      <li class="numberedList" value="4">In <code class="inlineCode">Program.cs</code>, add a <a id="_idIndexMarker866"/>statement to assign the method to the delegate<a id="_idIndexMarker867"/> field, and then add statements to call the <code class="inlineCode">Poke</code> method four times, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Assign the method to the Shout delegate.
harry.Shout = Harry_Shout;
// Call the Poke method that eventually raises the Shout event.
harry.Poke();
harry.Poke();
harry.Poke();
harry.Poke();
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and view the result. Note that Harry says nothing the first two times he is poked, and only gets angry enough to shout once he’s <a id="_idIndexMarker868"/>been poked at least three times, as shown in the<a id="_idIndexMarker869"/> following output:
        <pre class="programlisting con-one"><code class="hljs-con">Harry is this angry: 3.
Harry is this angry: 4.
</code></pre>
      </li>
    </ol>
    <p class="normal">In Step 3, note that the <code class="inlineCode">sender</code> is checked to make sure it is a <code class="inlineCode">Person</code> instance, and if it is, then it is assigned to a local variable named <code class="inlineCode">p</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// If sender is not a Person, then do nothing and return; else assign sender to p.
if (sender is not Person p) return;
WriteLine($"{p.Name} is this angry: {p.AngerLevel}.");
</code></pre>
    <p class="normal">The first statement does two things at once, which needs more explanation. The parameter named <code class="inlineCode">sender</code> is declared to be of type <code class="inlineCode">object</code>. This means we cannot just say <code class="inlineCode">sender.Name</code> or <code class="inlineCode">sender.AngerLevel</code>. We need to cast <code class="inlineCode">sender</code> to a local variable that is explicitly defined as <code class="inlineCode">Person</code>. We also need to check that <code class="inlineCode">sender</code> actually is a <code class="inlineCode">Person</code>.</p>
    <p class="normal">We can do both things at once in a single expression: <code class="inlineCode">sender is not Person p</code>. This expression will return <code class="inlineCode">true</code> if <code class="inlineCode">sender</code> is not a <code class="inlineCode">Person</code>, and hence the statement executes <code class="inlineCode">return</code> so the method immediately returns. Or the expression returns <code class="inlineCode">false</code> if <code class="inlineCode">sender</code> is a <code class="inlineCode">Person</code>, and sender will be stored in the local variable named <code class="inlineCode">p</code>, which is of type <code class="inlineCode">Person</code>. After that, we can use expressions like <code class="inlineCode">p.Name</code> and <code class="inlineCode">p.AngerLevel</code>.</p>
    <h2 id="_idParaDest-384" class="heading-2">Defining and handling events</h2>
    <p class="normal">You’ve now seen how <a id="_idIndexMarker870"/>delegates implement the most important functionality of<a id="_idIndexMarker871"/> events: the ability to define a signature for a method that can be implemented by a completely different piece of code, calling that method and any others that are hooked up to the delegate field.</p>
    <p class="normal">But what about events? There is less to them than you might think.</p>
    <p class="normal">When assigning a method to a delegate field, you should not use the simple assignment operator as we did in the preceding example.</p>
    <p class="normal">Delegates are multicast, meaning that you can assign multiple delegates to a single delegate field. Instead of the <code class="inlineCode">=</code> assignment, we could have used the <code class="inlineCode">+=</code> operator so that we could add more methods to the same delegate field. When the delegate is called, all the assigned methods are called, although you have no control over the order in which they are called. Do not use events to implement a queuing system to buy concert tickets; otherwise, the wrath of millions of Swifties will fall upon you.</p>
    <p class="normal">If the <code class="inlineCode">Shout</code> delegate field already referenced one or more methods, by assigning another method, that method would replace all the others. With delegates that are used for events, we usually want to make sure that a programmer only ever uses either the <code class="inlineCode">+=</code> operator or the <code class="inlineCode">-=</code> operator to assign and remove methods:</p>
    <ol>
      <li class="numberedList" value="1">To enforce this, in <code class="inlineCode">Person.cs</code>, add the <code class="inlineCode">event</code> keyword to the delegate field declaration, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public <strong class="hljs-keyword-slc">event</strong> EventHandler? Shout;
</code></pre>
      </li>
      <li class="numberedList">Build the <code class="inlineCode">PeopleApp</code> project and note the compiler error message, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Program.cs(41,13): error CS0079: The event 'Person.Shout' can only appear on the left hand side of += or -=
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This is (almost) all that the <code class="inlineCode">event</code> keyword does! If you will never have more than one method assigned to a delegate field, then technically you do not need events, but it is still good practice to indicate your meaning and that you expect a delegate field to be used as an event.</p>
    <ol>
      <li class="numberedList" value="3">In <code class="inlineCode">Program.cs</code>, modify the comment and the method assignment to use <code class="inlineCode">+=</code> instead of just <code class="inlineCode">=</code>, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Assign the method to the Shout <strong class="hljs-comment-slc">event</strong> delegate.
harry.Shout <strong class="hljs-slc">+</strong>= Harry_Shout;
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and note that it has the same behavior as before.</li>
      <li class="numberedList">In <code class="inlineCode">Program.EventHandlers.cs</code>, create a second event handler for Harry’s <code class="inlineCode">Shout</code> event, as <a id="_idIndexMarker872"/>shown in the <a id="_idIndexMarker873"/>following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Another method to handle the event received by the harry object.
private static void Harry_Shout_2(object? sender, EventArgs e)
{
  WriteLine("Stop it!");
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, after the statement that assigns the <code class="inlineCode">Harry_Shout</code> method to the <code class="inlineCode">Shout</code> event, add a statement to attach the new event handler to the <code class="inlineCode">Shout</code> event too, as shown highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// Assign the method<strong class="hljs-comment-slc">(s)</strong> to the Shout event delegate.
harry.Shout += Harry_Shout;
<strong class="hljs-slc">harry.Shout += Harry_Shout_2;</strong>
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project, view the result. Note that both event handlers execute whenever an event is raised, which only happens once the anger level is three or more, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Harry is this angry: 3.
Stop it!
Harry is this angry: 4.
Stop it!
</code></pre>
      </li>
    </ol>
    <p class="normal">In Windows <a id="_idIndexMarker874"/>desktop development, imagine that you have three<a id="_idIndexMarker875"/> buttons: <code class="inlineCode">AddButton</code>, <code class="inlineCode">SaveButton</code>, and <code class="inlineCode">DeleteButton</code>. Each button has very different functionality. Good practice would be to create three methods to handle their <code class="inlineCode">Click</code> events, named <code class="inlineCode">AddButton_Click</code>, <code class="inlineCode">SaveButton_Click</code>, and <code class="inlineCode">DeleteButton_Click</code>. Each would have a different implementation code.</p>
    <p class="normal">But now, imagine you have 26 buttons: <code class="inlineCode">AButton</code>, <code class="inlineCode">BButton</code>, <code class="inlineCode">CButton</code>, and so on, up to <code class="inlineCode">ZButton</code>. Each button has the same functionality: to filter a list of people by the first letter of their name. Good practice would be to create one method to handle their <code class="inlineCode">Click</code> events, perhaps named <code class="inlineCode">AtoZButtons_Click</code>. This method would have an implementation code that would use the <code class="inlineCode">sender</code> parameter to know which button was clicked, and therefore how to apply the filtering, but otherwise be the same for all the buttons.</p>
    <p class="normal">That’s it for events. Now, let’s look at interfaces.</p>
    <h1 id="_idParaDest-385" class="heading-1">Implementing interfaces</h1>
    <p class="normal">Interfaces are a<a id="_idIndexMarker876"/> way to implement standard functionality and connect different types to make new things. Think of them like the studs on top of LEGO™ bricks, which allow them to “stick” together, or electrical standards for plugs and sockets.</p>
    <p class="normal">If a type implements an interface, then it makes a promise to the rest of .NET that it <a id="_idIndexMarker877"/>supports specific functionality. Therefore, they are sometimes described as contracts.</p>
    <h2 id="_idParaDest-386" class="heading-2">Common interfaces</h2>
    <p class="normal"><em class="italic">Table 6.1</em> shows some common interfaces that your types might implement:</p>
    <table id="table001-5" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Interface</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Method(s)</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IComparable</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CompareTo(other)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This<a id="_idIndexMarker878"/> defines a comparison method that a type implements to order or sort its instances.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IComparer</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Compare(first, second)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This <a id="_idIndexMarker879"/>defines a comparison method that a secondary type implements to order or sort instances of a primary type.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IDisposable</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Dispose()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This<a id="_idIndexMarker880"/> defines a disposal method to release unmanaged resources more efficiently than waiting for a finalizer. See the <em class="italic">Releasing unmanaged resources</em> section later in this chapter for more details.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IFormattable</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ToString(format, culture)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This <a id="_idIndexMarker881"/>defines a culture-aware method to format the value of an object into a string representation.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IFormatter</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Serialize(stream, object)</code></p>
            <p class="normal"><code class="inlineCode">Deserialize(stream)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This <a id="_idIndexMarker882"/>defines methods to convert an object to and from a stream of bytes for storage or transfer.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">IFormatProvider</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">GetFormat(type)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This<a id="_idIndexMarker883"/> defines a method to format inputs based on a language and region.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.1: Some common interfaces that your types might implement</p>
    <h2 id="_idParaDest-387" class="heading-2">Comparing objects when sorting</h2>
    <p class="normal">One of the most<a id="_idIndexMarker884"/> common interfaces that you will want to implement in your types that represent data is <code class="inlineCode">IComparable</code>. If a type implements one of the <code class="inlineCode">IComparable</code> interfaces, then arrays and collections containing instances of that type can be sorted.</p>
    <p class="normal">This is an example of an abstraction for the concept of sorting. To sort any type, the minimum functionality would be the ability to compare two items and decide which goes before the other. If a type implements that minimum functionality, then a sorting algorithm can use it to sort instances of that type in any way the sorting algorithm wants.</p>
    <p class="normal">The <code class="inlineCode">IComparable</code> interface has one method named <code class="inlineCode">CompareTo</code>. This has two variations, one that works with a nullable <code class="inlineCode">object</code> type and one that works with a nullable generic type <code class="inlineCode">T</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">namespace System
{
  public interface IComparable
  {
    int CompareTo(object? obj);
  }
  public interface IComparable&lt;in T&gt;
  {
    int CompareTo(T? other);
  }
}
</code></pre>
    <div><p class="normal">The <code class="inlineCode">in</code> keyword specifies that the type parameter <code class="inlineCode">T</code> is contravariant, which means that you can use a less derived type than that specified. For example, if <code class="inlineCode">Employee</code> derives from <code class="inlineCode">Person</code>, then both can be compared to each other.</p>
    </div>
    <p class="normal">For <a id="_idIndexMarker885"/>example, the <code class="inlineCode">string</code> type implements <code class="inlineCode">IComparable</code> by returning <code class="inlineCode">-1</code> if the <code class="inlineCode">string</code> should be sorted before the <code class="inlineCode">string</code> is compared to, <code class="inlineCode">1</code> if it should be sorted after, and <code class="inlineCode">0</code> if they are equal. The <code class="inlineCode">int</code> type implements <code class="inlineCode">IComparable</code> by returning <code class="inlineCode">-1</code> if the <code class="inlineCode">int</code> is less than the <code class="inlineCode">int</code> being compared to, <code class="inlineCode">1</code> if it is greater, and <code class="inlineCode">0</code> if they are equal.</p>
    <p class="normal"><code class="inlineCode">CompareTo</code> return values can be summarized as shown in <em class="italic">Table 6.2</em>:</p>
    <table id="table002-5" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">this before other</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">this is equal to other</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">this after other</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">-1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.2: Summary of the CompareTo return values</p>
    <p class="normal">Before we implement the <code class="inlineCode">IComparable</code> interface and its <code class="inlineCode">CompareTo</code> method for the <code class="inlineCode">Person</code> class, let’s see what happens when we try to sort an array of <code class="inlineCode">Person</code> instances without implementing this interface, including some that are <code class="inlineCode">null</code> or have a <code class="inlineCode">null</code> value for their <code class="inlineCode">Name</code> property:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PeopleApp</code> project, add a new class file named <code class="inlineCode">Program.Helpers.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.Helpers.cs</code>, delete any existing statements. Then define a method for the <code class="inlineCode">partial</code> <code class="inlineCode">Program</code> class that will output all the names of a collection of people passed as a parameter, with a title beforehand, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">using Packt.Shared;
partial class Program
{
  private static void OutputPeopleNames(
    IEnumerable&lt;Person?&gt; people, string title)
  {
    WriteLine(title);
    foreach (Person? p in people)
    {
      WriteLine("  {0}",
        p is null ? "&lt;null&gt; Person" : p.Name ?? "&lt;null&gt; Name");
      /* if p is null then output: &lt;null&gt; Person
         else output: p.Name
         unless p.Name is null then output: &lt;null&gt; Name */
    }
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add <a id="_idIndexMarker886"/>statements that create an array of <code class="inlineCode">Person</code> instances, call the <code class="inlineCode">OutputPeopleNames</code> method to write the items to the console, and then attempt to sort the array and write the items to the console again, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Person?[] people =
{
  null,
  new() { Name = "Simon" },
  new() { Name = "Jenny" },
  new() { Name = "Adam" },
  new() { Name = null },
  new() { Name = "Richard" }
};
OutputPeopleNames(people, "Initial list of people:");
Array.Sort(people);
OutputPeopleNames(people,
  "After sorting using Person's IComparable implementation:");
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and an exception will be thrown. As the message explains, to fix the problem, our type must implement <code class="inlineCode">IComparable</code>, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Unhandled Exception: System.InvalidOperationException: Failed to compare two elements in the array. ---&gt; System.ArgumentException: At least one object must implement IComparable.
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Person.cs</code>, after inheriting from <code class="inlineCode">object</code>, add a comma and enter <code class="inlineCode">IComparable&lt;Person?&gt;</code>, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public class Person :<strong class="hljs-slc"> </strong><strong class="hljs-title-slc">IComparable</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">Person</strong><strong class="hljs-slc">?&gt;</strong>
</code></pre>
        <div><p class="normal">Your code editor will draw a red squiggle under the new code to warn you that you have not yet implemented the method you promised to. Your code editor can write the skeleton implementation for you.</p>
        </div>
      </li>
    </ol>
    <ol>
      <li class="numberedList" value="6">Click on the<a id="_idIndexMarker887"/> light bulb and then click <strong class="screenText">Implement interface</strong>.</li>
      <li class="numberedList">Scroll down to the bottom of the <code class="inlineCode">Person</code> class to find the method that was written for you, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public int CompareTo(Person? other)
{
  throw new NotImplementedException();
}
</code></pre>
      </li>
      <li class="numberedList">Delete the statement that throws the <code class="inlineCode">NotImplementedException</code> error.</li>
      <li class="numberedList">Add statements to handle variations of input values, including <code class="inlineCode">null</code>. Call the <code class="inlineCode">CompareTo</code> method of the <code class="inlineCode">Name</code> field, which uses the <code class="inlineCode">string</code> type’s implementation of <code class="inlineCode">CompareTo</code>. Return the result, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">int position;
if (other is not null)
{
  if ((Name is not null) &amp;&amp; (other.Name is not null))
  {
    // If both Name values are not null, then
    // use the string implementation of CompareTo.
    position = Name.CompareTo(other.Name);
  }
  else if ((Name is not null) &amp;&amp; (other.Name is null))
  {
    position = -1; // this Person precedes other Person.
  }
  else if ((Name is null) &amp;&amp; (other.Name is not null))
  {
    position = 1; // this Person follows other Person.
  }
  else // Name and other.Name are both null.
  {
    position = 0; // this and other are at same position.
  }
}
else if (other is null)
{
  position = -1; // this Person precedes other Person.
}
else // this and other are both null.
{
  position = 0; // this and other are at same position.
}
return position;
</code></pre>
      </li>
    </ol>
    <div><p class="normal">We have chosen to <a id="_idIndexMarker888"/>compare two <code class="inlineCode">Person</code> instances by comparing their <code class="inlineCode">Name</code> fields. <code class="inlineCode">Person</code> instances will, therefore, be sorted alphabetically by their name. <code class="inlineCode">null</code> values will be sorted to the bottom of the collection. Storing the calculated <code class="inlineCode">position</code> before returning it is useful when debugging. I’ve also used more round brackets than the compiler needs to make the code easier for me to read. If you prefer fewer brackets, then feel free to remove them.</p>
      <p class="normal">Also, note that the final <code class="inlineCode">else</code> statement will never execute because the logic of the <code class="inlineCode">if</code> and <code class="inlineCode">else</code> <code class="inlineCode">if</code> clauses means it will only execute when <code class="inlineCode">this</code> (the current object instance) is <code class="inlineCode">null</code>. In that scenario, the method could not execute anyway since the object wouldn’t exist! I wrote the <code class="inlineCode">if</code> statement to exhaustively cover all combinations of <code class="inlineCode">null</code> and not <code class="inlineCode">null</code> for <code class="inlineCode">other</code> and <code class="inlineCode">this</code>, but the last of those combinations could, in practice, never happen.</p>
    </div>
    <ol>
      <li class="numberedList" value="10">Run the <code class="inlineCode">PeopleApp</code> project. Note that this time it works as it should, sorted <a id="_idIndexMarker889"/>alphabetically by name, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Initial list of people:
  Simon
  &lt;null&gt; Person
  Jenny
  Adam
  &lt;null&gt; Name
  Richard
After sorting using Person's IComparable implementation:
  Adam
  Jenny
  Richard
  Simon
  &lt;null&gt; Name
  &lt;null&gt; Person
</code></pre>
        <div><p class="normal"><strong class="keyWord">Good Practice</strong>: If you want to sort an array or collection of instances of your type, then implement the <code class="inlineCode">IComparable</code> interface.</p>
        </div>
      </li>
    </ol>
    <h2 id="_idParaDest-388" class="heading-2">Comparing objects using a separate class</h2>
    <p class="normal">Sometimes, you won’t <a id="_idIndexMarker890"/>have access to the source code for a type, and it might not implement the <code class="inlineCode">IComparable</code> interface. Luckily, there is another way to sort instances of a type. You can create a separate type that implements a slightly different interface, named <code class="inlineCode">IComparer</code>:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">PersonComparer.cs</code>, containing a class implementing the <code class="inlineCode">IComparer</code> interface that will compare two people, that is, two <code class="inlineCode">Person</code> instances. Implement it by comparing the length of their <code class="inlineCode">Name</code> fields, or if the names are the same length, then compare the names alphabetically, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class PersonComparer : IComparer&lt;Person?&gt;
{
  public int Compare(Person? x, Person? y)
  {
    int position;
    if ((x is not null) &amp;&amp; (y is not null))
    {
      if ((x.Name is not null) &amp;&amp; (y.Name is not null))
      {
        // If both Name values are not null...
        // ...then compare the Name lengths...
        int result = x.Name.Length.CompareTo(y.Name.Length);
        // ...and if they are equal...
        if (result == 0)
        {
          // ...then compare by the Names...
          return x.Name.CompareTo(y.Name);
        }
        else
        {
          // ...otherwise compare by the lengths.
          position = result;
        }
      }
      else if ((x.Name is not null) &amp;&amp; (y.Name is null))
      {
        position = -1; // x Person precedes y Person.
      }
      else if ((x.Name is null) &amp;&amp; (y.Name is not null))
      {
        position = 1; // x Person follows y Person.
      }
      else // x.Name and y.Name are both null.
      {
        position = 0; // x and y are at same position.
      }
    }
    else if ((x is not null) &amp;&amp; (y is null))
    {
      position = -1; // x Person precedes y Person.
    }
    else if ((x is null) &amp;&amp; (y is not null))
    {
      position = 1; // x Person follows y Person.
    }
    else // x and y are both null.
    {
      position = 0; // x and y are at same position.
    }
    return position;
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add <a id="_idIndexMarker891"/>statements to sort the array using an alternative implementation, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Array.Sort(people, new PersonComparer());
OutputPeopleNames(people,
  "After sorting using PersonComparer's IComparer implementation:");
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project, and view the result of sorting the people by the length of their names and then alphabetically, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">After sorting using PersonComparer's IComparer implementation:
  Adam
  Jenny
  Simon
  Richard
  &lt;null&gt; Name
  &lt;null&gt; Person
</code></pre>
      </li>
    </ol>
    <p class="normal">This time, when we sort the <code class="inlineCode">people</code> array, we explicitly ask the sorting algorithm to use the <code class="inlineCode">PersonComparer</code> type instead so that the people are sorted with the shortest names first, like <code class="inlineCode">Adam</code>, and the longest names last, like <code class="inlineCode">Richard</code>. When the lengths of two or <a id="_idIndexMarker892"/>more names are equal, they are sorted alphabetically, like <code class="inlineCode">Jenny</code> and <code class="inlineCode">Simon</code>.</p>
    <h2 id="_idParaDest-389" class="heading-2">Implicit and explicit interface implementations</h2>
    <p class="normal">Interfaces can be <a id="_idIndexMarker893"/>implemented implicitly and explicitly. Implicit implementations are simpler and more common. Explicit implementations are only necessary if a type must have multiple methods with the same<a id="_idIndexMarker894"/> name and signature. Personally, the only time I can remember ever having to explicitly implement an interface is when writing the code example for this book.</p>
    <p class="normal">For example, both <code class="inlineCode">IGamePlayer</code> and <code class="inlineCode">IKeyHolder</code> might have a method called <code class="inlineCode">Lose</code> with the same parameters because both a game and a key can be lost. The members of an interface are always and automatically <code class="inlineCode">public</code> because they have to be accessible for another type to implement them!</p>
    <p class="normal">In a type that must implement both interfaces, only one implementation of <code class="inlineCode">Lose</code> can be the implicit method. If both interfaces can share the same implementation, there is no problem, but if not, then the other <code class="inlineCode">Lose</code> method will have to be implemented differently and called explicitly, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public interface IGamePlayer // Defaults to internal.
{
  void Lose(); // Defaults to public. Could be set to internal.
}
public interface IKeyHolder
{
  void Lose();
}
public class Human : IGamePlayer, IKeyHolder
{
  // Implicit implementation must be public.
  public void Lose() // Implicit implementation.
  {
    // Implement losing a key.
    WriteLine("Implementation for losing a key.");
  }
  // Explicit implementation can be any access modifier.
  void IGamePlayer.Lose() // Defaults to private.
  {
    // Implement losing a game.
    WriteLine("Implementation for losing a game.");
  }
}
Human human = new();
human.Lose(); // Calls implicit implementation of losing a key.
// Outputs: Implementation for losing a key.
((IGamePlayer)human).Lose(); // Calls explicit implementation of losing a game.
// Outputs: Implementation for losing a game.
// Alternative way to do the same.
IGamePlayer player = human as IGamePlayer;
player.Lose(); // Calls explicit implementation of losing a game.
// Outputs: Implementation for losing a game.
</code></pre>
    <div><p class="normal">Although the implementation of <code class="inlineCode">IGamePlayer.Lose</code> in <code class="inlineCode">Human</code> is <code class="inlineCode">private</code>, the <code class="inlineCode">IGamePlayer.Lose</code> member itself has an access modifier of <code class="inlineCode">public</code>, so if we cast the <code class="inlineCode">Human</code> instance into the interface type, then that <code class="inlineCode">Lose</code> implementation is accessible.</p>
    </div>
    <div><p class="normal"><strong class="keyWord">Warning!</strong> Method access modifiers in an implementation type must match the method definition in the interface. For example, the <code class="inlineCode">Lose</code> method in the interface is <code class="inlineCode">public</code>, so the method implementation in the class must also be <code class="inlineCode">public</code>.</p>
    </div>
    <h2 id="_idParaDest-390" class="heading-2">Defining interfaces with default implementations</h2>
    <p class="normal">A language <a id="_idIndexMarker895"/>feature introduced in <a id="_idIndexMarker896"/>C# 8 is the <strong class="keyWord">default implementation</strong> for an interface. This allows an interface to contain <a id="_idIndexMarker897"/>implementation. This breaks the clean separation between interfaces that define a contract and classes and other types that implement them. It is considered by some .NET developers to be a perversion of the language.</p>
    <p class="normal">Let’s see it in action:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new file named <code class="inlineCode">IPlayable.cs</code>, and modify the statements to define a public <code class="inlineCode">IPlayable</code> interface with two methods to <code class="inlineCode">Play</code> and <code class="inlineCode">Pause</code>, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public interface IPlayable
{
  void Play();
  void Pause();
}
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">DvdPlayer.cs</code>, and modify the statements in the file to implement the <code class="inlineCode">IPlayable</code> interface, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class DvdPlayer : IPlayable
{
  public void Pause()
  {
    WriteLine("DVD player is pausing.");
  }
  public void Play()
  {
    WriteLine("DVD player is playing.");
  }
}
</code></pre>
      </li>
    </ol>
    <p class="normal">This is useful, but <a id="_idIndexMarker898"/>what if we decide to add a third method named <code class="inlineCode">Stop</code>? Before C# 8, this would be impossible once at least one type is implemented in the original interface. One of the main traits of an interface is that it is a fixed contract.</p>
    <p class="normal">C# 8 allows you to add new members to an interface after release if those new members have a default implementation. C# purists do not like the idea, but for practical reasons, such as avoiding breaking changes or having to define a whole new interface, it is useful, and other languages such as Java and Swift enable similar techniques.</p>
    <div><p class="normal">Support for default interface implementations requires some fundamental changes to the underlying platform, so they are only supported with C# if the target framework is .NET 5 or later, .NET Core 3 or later, or .NET Standard 2.1. They are, therefore, not supported by .NET Framework.</p>
    </div>
    <p class="normal">Let’s add a default implementation to the interface:</p>
    <ol>
      <li class="numberedList" value="1">Modify the <code class="inlineCode">IPlayable</code> interface to add a <code class="inlineCode">Stop</code> method with a default implementation, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public interface IPlayable
{
  void Play();
  void Pause();
<strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">void</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Stop</strong><strong class="hljs-function-slc">() </strong><strong class="hljs-comment-slc">// Default interface implementation.</strong>
<strong class="hljs-slc">  {</strong>
<strong class="hljs-slc">    WriteLine(</strong><strong class="hljs-string-slc">"Default implementation of Stop."</strong><strong class="hljs-slc">);</strong>
<strong class="hljs-slc">  }</strong>
}
</code></pre>
      </li>
      <li class="numberedList">Build the <code class="inlineCode">PeopleApp</code> project, and note that the projects compile successfully despite the <code class="inlineCode">DvdPlayer</code> class not implementing <code class="inlineCode">Stop</code>. In the future, we could override the default implementation of <code class="inlineCode">Stop</code> by implementing it in the <code class="inlineCode">DvdPlayer</code> class.</li>
    </ol>
    <p class="normal">Although <a id="_idIndexMarker899"/>controversial, default implementations in interfaces might be useful in scenarios where the most common implementation is known at the time of defining the interface. Therefore, it is best if the interface defines that implementation once, and then most types that implement that interface can inherit it without needing to implement their own. However, if the interface definer does not know how the member should or even could be implemented, then it is a waste of effort to add a default implementation because it will always be replaced.</p>
    <p class="normal">Think about the <code class="inlineCode">IComparable</code> interface that you saw earlier in this chapter. It defines a <code class="inlineCode">CompareTo</code> method. What might a default implementation of that method be? Personally, I think it’s obvious that there is no default implementation that would make any practical sense. The least-worst implementation that I can think of would be to compare the <code class="inlineCode">string</code> values returned from calling <code class="inlineCode">ToString</code> on the two objects. However, every type really should implement its own <code class="inlineCode">CompareTo</code> method. You are likely to find the same with 99.9% of the interfaces you use.</p>
    <p class="normal">Now let’s look at how to work with null values.</p>
    <h1 id="_idParaDest-391" class="heading-1">Working with null values</h1>
    <p class="normal">What if a variable does not yet have a<a id="_idIndexMarker900"/> value? How can we indicate that? C# has the concept of a <code class="inlineCode">null</code> value, which can be used to indicate that a variable has not been set.</p>
    <div><p class="normal">If you are unsure of the difference between reference types and value types in .NET, then I recommend that you read the following online-only section before you continue with this section: <a href="https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md">https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md</a>.</p>
    </div>
    <h2 id="_idParaDest-392" class="heading-2">Making a value type nullable</h2>
    <p class="normal">By default, <strong class="keyWord">value types</strong> like <code class="inlineCode">int</code> and <code class="inlineCode">DateTime</code> must always have a <em class="italic">value</em>, hence their name. Sometimes, for example, when reading values stored in a database that allows empty, missing, or <code class="inlineCode">null</code> values, it is convenient to<a id="_idIndexMarker901"/> allow a value type to be <code class="inlineCode">null</code>. We call this a <strong class="keyWord">nullable value type</strong>.</p>
    <p class="normal">You can enable this by adding a question mark as a suffix to the type when declaring a variable.</p>
    <p class="normal">Let’s see an example. We will create a new project because some of the null handling options are set at the project level:</p>
    <ol>
      <li class="numberedList" value="1">Use your preferred code editor to add a new <strong class="screenText">Console App</strong>/<code class="inlineCode">console</code> project named <code class="inlineCode">NullHandling</code> to the <code class="inlineCode">Chapter06</code> solution.</li>
      <li class="numberedList">In <code class="inlineCode">NullHandling.csproj</code>, add an <code class="inlineCode">&lt;ItemGroup&gt;</code> to globally and statically import the <code class="inlineCode">System.Console</code> class.</li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete the existing statements, and then add statements to declare and assign values, including <code class="inlineCode">null</code>, two <code class="inlineCode">int</code> variables, one suffixed with <code class="inlineCode">?</code> and one not, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">int thisCannotBeNull  = 4;
thisCannotBeNull = null; // CS0037 compiler error!
WriteLine(thisCannotBeNull);
int? thisCouldBeNull = null;
WriteLine(thisCouldBeNull);
WriteLine(thisCouldBeNull.GetValueOrDefault());
thisCouldBeNull = 7;
WriteLine(thisCouldBeNull);
WriteLine(thisCouldBeNull.GetValueOrDefault());
</code></pre>
      </li>
      <li class="numberedList">Build the project and note the compile error, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Cannot convert null to 'int' because it is a non-nullable value type
</code></pre>
      </li>
      <li class="numberedList">Comment out the statement that gives the compile error, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">//thisCannotBeNull = null; // CS0037 compiler error!
</code></pre>
      </li>
      <li class="numberedList">Run the<a id="_idIndexMarker902"/> project and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">4
0
7
7
</code></pre>
      </li>
    </ol>
    <div><p class="normal">The second line is blank because it outputs the <code class="inlineCode">null</code> value.</p>
    </div>
    <ol>
      <li class="numberedList" value="7">Add statements to use alternative syntax, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">// The actual type of int? is Nullable&lt;int&gt;.
Nullable&lt;int&gt; thisCouldAlsoBeNull = null;
thisCouldAlsoBeNull = 9;
WriteLine(thisCouldAlsoBeNull);
</code></pre>
      </li>
      <li class="numberedList">Click on <code class="inlineCode">Nullable&lt;int&gt;</code> and press <em class="keystroke">F12</em>, or right-click and choose <strong class="screenText">Go To Definition</strong>.</li>
      <li class="numberedList">Note that the generic value type, <code class="inlineCode">Nullable&lt;T&gt;</code>, must have a type <code class="inlineCode">T</code>, which is <a id="_idIndexMarker903"/>a <code class="inlineCode">struct</code>, or a value type. It has useful members like <code class="inlineCode">HasValue</code>, <code class="inlineCode">Value</code>, and <code class="inlineCode">GetValueOrDefault</code>, as shown in <em class="italic">Figure 6.1</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B22322_06_01.png" alt="" width="825" height="355"/></figure>
    <p class="packt_figref">Figure 6.1: Revealing Nullable&lt;T&gt; members</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: When you append a <code class="inlineCode">?</code> after a <code class="inlineCode">struct</code> type, you change it to a different type. For example, <code class="inlineCode">DateTime?</code> becomes <code class="inlineCode">Nullable&lt;DateTime&gt;</code>.</p>
    </div>
    <h2 id="_idParaDest-393" class="heading-2">Understanding null-related initialisms</h2>
    <p class="normal">Before we see some code, let’s<a id="_idIndexMarker904"/> review some commonly used initialisms in <em class="italic">Table 6.3</em>:</p>
    <table id="table003-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Initialism</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Meaning</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">NRT</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nullable Reference Type</p>
          </td>
          <td class="table-cell">
            <p class="normal">This is a <a id="_idIndexMarker905"/>compiler feature introduced with C# 8 and enabled by default in new projects with C# 10, which performs static analysis of your code at design time and shows warnings of potential misuse of <code class="inlineCode">null</code> values for reference types.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">NRE</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">NullReferenceException</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This is an <a id="_idIndexMarker906"/>exception thrown at runtime when <strong class="keyWord">dereferencing</strong> a <code class="inlineCode">null</code> value, also known as accessing a variable or member on an object that is <code class="inlineCode">null</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">ANE</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ArgumentNullException</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This is an<a id="_idIndexMarker907"/> exception thrown at runtime by a method, property, or indexer invocation when an argument or value is <code class="inlineCode">null</code>, and when the business logic determines that it is not valid.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.3: Commonly used initialisms</p>
    <h2 id="_idParaDest-394" class="heading-2">Understanding nullable reference types</h2>
    <p class="normal">The use of the <code class="inlineCode">null</code> value is so <a id="_idIndexMarker908"/>common, in so many languages, that many experienced programmers never question the need for its existence. However, there are many scenarios where we could write better, simpler code if a variable is not allowed to have a <code class="inlineCode">null</code> value.</p>
    <p class="normal">The most significant change to the C# 8 language compiler was the introduction of checks and warnings for nullable and non-nullable reference types. <em class="italic">“But wait!”</em>, you are probably thinking. <em class="italic">“Reference types are already nullable!”</em></p>
    <p class="normal">And you would be right, but in C# 8 and later, reference types can be configured to warn you about <code class="inlineCode">null</code> values by setting a file- or project-level option, enabling this useful new feature. Since this is a big change for C#, Microsoft decided to make the feature an opt-in.</p>
    <p class="normal">It will take several years<a id="_idIndexMarker909"/> for this new C# language compiler feature to make an impact, since thousands of existing library packages and apps will expect the old behavior. Even Microsoft did not have time to fully implement this new feature in all the main .NET packages until .NET 6. Important libraries like <code class="inlineCode">Microsoft.Extensions</code> for logging, dependency injections, and configuration were not annotated until .NET 7.</p>
    <p class="normal">During the transition, you can choose between several approaches for your own projects:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Default</strong>: For projects created using .NET 5 or earlier, no changes are needed. Non-nullable reference types are not checked. For projects created using .NET 6 or later, nullability checks are enabled by default, but this can be disabled by either deleting the <code class="inlineCode">&lt;Nullable&gt;</code> entry in the project file or setting it to <code class="inlineCode">disable</code>.</li>
      <li class="bulletList"><strong class="keyWord">Opt-in project and opt-out files</strong>: Enable the feature at the project level, and for any files that need to remain compatible with old behavior, opt out. This was the approach Microsoft used internally while it updated its own packages to use this new feature.</li>
      <li class="bulletList"><strong class="keyWord">Opt-in files</strong>: Only enable the NRT feature for individual files.</li>
    </ul>
    <div><p class="normal"><strong class="keyWord">Warning!</strong> This NRT feature does not <em class="italic">prevent</em> <code class="inlineCode">null</code> values – it just <em class="italic">warns</em> you about them, and the warnings can be disabled, so you still need to be careful! For example, using the <code class="inlineCode">?</code> character to declare a variable as nullable does not allow <code class="inlineCode">null</code> values, it just disables the warning, as shown in the following code:</p>
      <pre class="programlisting code"><code class="hljs-code">string firstName; // Allows null but gives warning when
potentially null.
string? lastName; // Allows null and does not give warning if
null.
</code></pre>
    </div>
    <h2 id="_idParaDest-395" class="heading-2">Controlling the nullability warning check feature</h2>
    <p class="normal">To enable the nullability warning <a id="_idIndexMarker910"/>check feature at the project level, have the <code class="inlineCode">&lt;Nullable&gt;</code> element set to <code class="inlineCode">enable</code> in your project file, as highlighted in the following markup:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
  ...
<strong class="hljs-slc">  &lt;Nullable&gt;enable&lt;/Nullable&gt;</strong>
&lt;/PropertyGroup&gt;
</code></pre>
    <p class="normal">To disable the nullability warning check feature at the project level, have the <code class="inlineCode">&lt;Nullable&gt;</code> element set to <code class="inlineCode">disable</code> in your project file, as highlighted in the following markup:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
  ...
<strong class="hljs-slc">  &lt;Nullable&gt;disable&lt;/Nullable&gt;</strong>
&lt;/PropertyGroup&gt;
</code></pre>
    <p class="normal">You could also remove the <code class="inlineCode">&lt;Nullable&gt;</code> element completely because the default, if not explicitly set, is disabled.</p>
    <p class="normal">To disable the feature at the file level, add the following at the top of a code file:</p>
    <pre class="programlisting code"><code class="hljs-code">#nullable disable
</code></pre>
    <p class="normal">To enable the feature at the file level, add the following at the top of a code file:</p>
    <pre class="programlisting code"><code class="hljs-code">#nullable enable
</code></pre>
    <h2 id="_idParaDest-396" class="heading-2">Disabling null and other compiler warnings</h2>
    <p class="normal">You could <a id="_idIndexMarker911"/>decide to enable the nullability feature at the project or file level but then disable some of the 50+ warnings related to it. Some common nullability warnings are shown in <em class="italic">Table 6.4</em>:</p>
    <table id="table004-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Code</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8600</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Converting a null literal or a possible null value to a non-nullable type</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8601</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">A possible null reference assignment</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8602</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">A dereference of a possibly null reference</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8603</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">A possible null reference return</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8604</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">A possible null reference argument for a parameter</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8618</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">A non-nullable field <code class="inlineCode">&lt;field_name&gt;</code> must contain a non-null value when exiting a constructor. Consider declaring the field as nullable</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8625</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Cannot convert a null literal to a non-nullable reference type</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">CS8655</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The <a id="_idIndexMarker912"/>switch expression does not handle some null inputs (it is not exhaustive)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.4: Common nullability warnings</p>
    <p class="normal">You can disable compiler warnings for a whole project. To do so, add a <code class="inlineCode">NoWarn</code> element with a semicolon-separated list of compiler warning codes, as shown in the following markup:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;NoWarn&gt;CS8600;CS8602&lt;/NoWarn&gt;
</code></pre>
    <p class="normal">To disable compiler warnings at the statement level, you can disable and then restore a specified compiler warning to temporarily suppress it for a block of statements, as shown in the following code:</p>
    <pre class="programlisting gen"><code class="hljs">#pragma warning disable CS8602
WriteLine(firstName.Length);
WriteLine(lastName.Length);
#pragma warning restore CS8602
</code></pre>
    <p class="normal">These techniques can be used for any compiler warnings, not just those related to nullability.</p>
    <h2 id="_idParaDest-397" class="heading-2">Declaring non-nullable variables and parameters</h2>
    <p class="normal">If you enable NRTs and you <a id="_idIndexMarker913"/>want a reference type to be <a id="_idIndexMarker914"/>assigned the <code class="inlineCode">null</code> value, then you will have to use the same syntax to make a value type nullable, that is, adding a <code class="inlineCode">?</code> symbol after the type declaration.</p>
    <p class="normal">So, how do NRTs work? Let’s look at an example. When storing information about an address, you might want to force a value for the street, city, and region, but the building can be left blank, that is, <code class="inlineCode">null</code>:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">NullHandling</code> project, add a class file named <code class="inlineCode">Address.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Address.cs</code>, delete any existing statements and then add statements to declare an <code class="inlineCode">Address</code> class with four fields, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class Address
{
  public string? Building;
  public string Street;
  public string City;
  public string Region;
}
</code></pre>
      </li>
      <li class="numberedList">After a few seconds, note the warnings about non-nullable fields, like <code class="inlineCode">Street</code> not being initialized, as shown in <em class="italic">Figure 6.2</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B22322_06_02.png" alt="" width="812" height="357"/></figure>
    <p class="packt_figref">Figure 6.2: Warning messages about non-nullable fields in the Error List window</p>
    <ol>
      <li class="numberedList" value="4">Assign the<a id="_idIndexMarker915"/> empty <code class="inlineCode">string</code> value to the <code class="inlineCode">Street</code> field, and<a id="_idIndexMarker916"/> define constructors to set the other fields that are non-nullable, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public string Street<strong class="hljs-slc"> = </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc">.Empty</strong>;
public string City;
public string Region;
<strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Address</strong><strong class="hljs-function-slc">()</strong>
<strong class="hljs-slc">{</strong>
<strong class="hljs-slc">  City = </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc">.Empty;</strong>
<strong class="hljs-slc">  Region = </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc">.Empty;</strong>
<strong class="hljs-slc">}</strong>
<strong class="hljs-comment-slc">// Call the default parameterless constructor</strong>
<strong class="hljs-comment-slc">// to ensure that Region is also set.</strong>
<strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Address</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-params-slc"> city</strong><strong class="hljs-function-slc">) : </strong><strong class="hljs-title-slc">this</strong><strong class="hljs-function-slc">()</strong>
<strong class="hljs-slc">{</strong>
<strong class="hljs-slc">  City = city;</strong>
<strong class="hljs-slc">}</strong>
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, import the namespace to use <code class="inlineCode">Address</code>, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">using Packt.Shared; // To use Address.
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to instantiate an <code class="inlineCode">Address</code> and set its properties, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Address address = new(city: "London")
{
  Building = null,
  Street = null,
  Region = "UK"
};
</code></pre>
      </li>
      <li class="numberedList">Note the <code class="inlineCode">Warning</code> <code class="inlineCode">CS8625</code> on setting <a id="_idIndexMarker917"/>the <code class="inlineCode">Street</code> but not the <code class="inlineCode">Building</code>, as shown in <a id="_idIndexMarker918"/>the following output:
        <pre class="programlisting con-one"><code class="hljs-con">CS8625 Cannot convert null literal to non-nullable reference type.
</code></pre>
      </li>
      <li class="numberedList">Append an exclamation mark to <code class="inlineCode">null</code> when setting <code class="inlineCode">Street</code>, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Street = null<strong class="hljs-slc">!</strong>, // null-forgiving operator.
</code></pre>
      </li>
      <li class="numberedList">Note that the warning disappears.</li>
      <li class="numberedList">Add statements that will dereference the <code class="inlineCode">Building</code> and <code class="inlineCode">Street</code> properties, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">WriteLine(address.Building.Length);
WriteLine(address.Street.Length);
</code></pre>
      </li>
      <li class="numberedList">Note the <code class="inlineCode">Warning CS8602</code> on setting the <code class="inlineCode">Building</code> but not the <code class="inlineCode">Street</code>, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">CS8602 Dereference of a possibly null reference.
</code></pre>
      </li>
    </ol>
    <p class="normal-one">At runtime it is still possible for an exception to be thrown when working with <code class="inlineCode">Street</code>, but the compiler should continue to warn you of potential exceptions when working with <code class="inlineCode">Building</code> so that you can change your code to avoid them.</p>
    <ol>
      <li class="numberedList" value="12">Use the <a id="_idIndexMarker919"/>null-conditional operator to <a id="_idIndexMarker920"/>return <code class="inlineCode">null</code> instead of accessing the <code class="inlineCode">Length</code>, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">WriteLine(address.Building?.Length);
</code></pre>
      </li>
      <li class="numberedList">Run the console app, and note that the statement that accesses the <code class="inlineCode">Length</code> of the <code class="inlineCode">Building</code> outputs a <code class="inlineCode">null</code> value (blank line), but a runtime exception occurs when we access the <code class="inlineCode">Length</code> of the <code class="inlineCode">Street</code>, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
</code></pre>
      </li>
      <li class="numberedList">Wrap the statement that accesses the <code class="inlineCode">Street</code> length in a null check, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">if (address.Street is not null)
{
  WriteLine(address.Street.Length);
}
</code></pre>
      </li>
    </ol>
    <p class="normal">It is worth reminding yourself that an NRT is only about asking the compiler to provide warnings about potential <code class="inlineCode">null</code> values that might cause problems. It does not actually change the behavior of your code. It performs a static analysis of your code at compile time.</p>
    <p class="normal">This explains<a id="_idIndexMarker921"/> why the new language feature is named <strong class="keyWord">nullable reference types</strong> (<strong class="keyWord">NRTs</strong>). Starting with C# 8, unadorned reference types can become <a id="_idIndexMarker922"/>non-nullable, and the<a id="_idIndexMarker923"/> same syntax is used to make a reference type nullable, as it is used for value types.</p>
    <div><p class="normal">Suffixing a reference type with <code class="inlineCode">?</code> does not change the type. This is different from suffixing a value type with <code class="inlineCode">?</code>, which changes its type to <code class="inlineCode">Nullable&lt;T&gt;</code>. Reference types can already have <code class="inlineCode">null</code> values. All <a id="_idIndexMarker924"/>you do with <strong class="keyWord">NRTs</strong> is tell the compiler that you expect it to be <code class="inlineCode">null</code>, so the compiler does not need to warn you. However, this does not remove the need to perform <code class="inlineCode">null</code> checks throughout your code.</p>
    </div>
    <p class="normal">Now let’s look at language features to work with <code class="inlineCode">null</code> values that change the behavior of your code and work well as a complement to NRTs.</p>
    <h2 id="_idParaDest-398" class="heading-2">Checking for null</h2>
    <p class="normal">Checking whether a <a id="_idIndexMarker925"/>nullable reference type or value type variable currently contains <code class="inlineCode">null</code> is important because if you do not, a <code class="inlineCode">NullReferenceException</code> can be thrown, which results in an error. You should check for a <code class="inlineCode">null</code> value before using a nullable variable, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// Check that the variable is not null before using it.
if (thisCouldBeNull != null)
{
  // Access a member of thisCouldBeNull.
  int length = thisCouldBeNull.Length;
  ...
}
</code></pre>
    <p class="normal">C# 7 introduced <code class="inlineCode">is</code> combined with the <code class="inlineCode">!</code> (<code class="inlineCode">not</code>) operator as an alternative to <code class="inlineCode">!=</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">if (!(thisCouldBeNull is null))
{
</code></pre>
    <p class="normal">C# 9 introduced <code class="inlineCode">is not</code> as an even clearer alternative, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">if (thisCouldBeNull is not null)
{
</code></pre>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Although you would traditionally use the expression <code class="inlineCode">(thisCouldBeNull != null)</code>, this is no longer considered good practice because the developer could have overloaded the <code class="inlineCode">!=</code> operator to change how it works. Using pattern matching with <code class="inlineCode">is null</code> and <code class="inlineCode">is not null</code> is the only guaranteed way to check for <code class="inlineCode">null</code>. For many developers, it is still instinctual to use <code class="inlineCode">!=</code>, so I apologize in advance if you catch me still using it!</p>
    </div>
    <div><p class="normal">Since the <code class="inlineCode">is</code> operator cannot be overloaded by a developer, its behavior is guaranteed. Both the <code class="inlineCode">==</code> and <code class="inlineCode">!=</code> operators could be overloaded by a developer so their behavior could change. The .NET team has now consistently implemented their null checks using <code class="inlineCode">is</code>, so I recommend that you do the same, as you can see at the following link:</p>
      <p class="normal"><a href="https://twitter.com/Dave_DotNet/status/1764995927868076428">https://twitter.com/Dave_DotNet/status/1764995927868076428</a></p>
      <p class="normal">The term <em class="italic">overriding</em> is about <a id="_idIndexMarker926"/>altering or extending the behavior of an inherited method in the context of object-oriented inheritance. <em class="italic">Overloading</em> occurs<a id="_idIndexMarker927"/> when you provide a new implementation for an existing operator or method.</p>
    </div>
    <p class="normal">If you try to use a <a id="_idIndexMarker928"/>member of a variable that might be <code class="inlineCode">null</code>, use<a id="_idIndexMarker929"/> the <strong class="keyWord">null-conditional operator</strong>, <code class="inlineCode">?.</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">string authorName = null;
int? authorNameLength;
// The following throws a NullReferenceException.
authorNameLength = authorName.Length;
// Instead of throwing an exception, null is assigned.
authorNameLength = authorName?.Length;
</code></pre>
    <p class="normal">Sometimes, you want to either assign a variable to a result or use an alternative value, such as <code class="inlineCode">3</code>, if the variable is <code class="inlineCode">null</code>. You do this using<a id="_idIndexMarker930"/> the <strong class="keyWord">null-coalescing operator</strong>, <code class="inlineCode">??</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// Result will be 25 if authorName?.Length is null.
authorNameLength = authorName?.Length ?? 25;
</code></pre>
    <h2 id="_idParaDest-399" class="heading-2">Checking for null in method parameters</h2>
    <p class="normal">Even if you enable NRTs, when<a id="_idIndexMarker931"/> defining methods with parameters, it is good practice to check for <code class="inlineCode">null</code> values.</p>
    <p class="normal">In earlier versions of C#, you would have to write <code class="inlineCode">if</code> statements to check for <code class="inlineCode">null</code> parameter values and then throw an <code class="inlineCode">ArgumentNullException</code> for any parameter that is <code class="inlineCode">null</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public void Hire(Person manager, Person employee)
{
  if (manager is null)
  {
    throw new ArgumentNullException(paramName: nameof(manager));
  }
  if (employee is null)
  {
    throw new ArgumentNullException(paramName: nameof(employee));
  }
  ...
}
</code></pre>
    <p class="normal">C# 10 introduced a convenience method to throw an exception if an argument is <code class="inlineCode">null</code>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public void Hire(Person manager, Person employee)
{
  ArgumentNullException.ThrowIfNull(manager);
  ArgumentNullException.ThrowIfNull(employee);
  ...
}
</code></pre>
    <p class="normal">C# 11 previews proposed and introduced a new <code class="inlineCode">!!</code> operator that does this for you, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public void Hire(Person manager!!, Person employee!!)
{
  ...
}
</code></pre>
    <p class="normal">The <code class="inlineCode">if</code> statement and throwing of the exception would be done for you. The code is injected and executed before any statements that you write.</p>
    <p class="normal">This proposal was<a id="_idIndexMarker932"/> controversial within the C# developer community. Some would prefer the use of attributes to decorate parameters instead of a pair of characters. The .NET product team said they reduced the .NET libraries by more than 10,000 lines of code by using this feature. </p>
    <p class="normal">That sounds like a good reason to use it to me! And no one must use it if they choose not to. Unfortunately, the team eventually decided to remove the feature, so now we all have to write the null checks manually. If you’re interested in this story, then you can read more about it at the following link:</p>
    <p class="normal"><a href="https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11">https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11</a></p>
    <p class="normal">I include this story in this book because I think it’s an interesting example of Microsoft being transparent, by developing .NET in the open and listening to and responding to feedback from the community.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Always remember that nullable is a warning check, not an enforcement. You can read more about the compiler warnings relating to <code class="inlineCode">null</code> at the following link:</p>
      <p class="normal"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings</a></p>
    </div>
    <p class="normal">That’s more than enough talk about “nothing”! Let’s look at the meat of this chapter, inheritance.</p>
    <h1 id="_idParaDest-400" class="heading-1">Inheriting from classes</h1>
    <p class="normal">The <code class="inlineCode">Person</code> type we<a id="_idIndexMarker933"/> created earlier derived (inherited) from <code class="inlineCode">System.Object</code>. Now, we will create a subclass that inherits from <code class="inlineCode">Person</code>:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">Employee.cs</code>.</li>
      <li class="numberedList">Modify its contents to define a class named <code class="inlineCode">Employee</code> that derives from <code class="inlineCode">Person</code>, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class Employee : Person
{
}
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">PeopleApp</code> project, in <code class="inlineCode">Program.cs</code>, add statements to create an instance of the <code class="inlineCode">Employee</code> class, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Employee john = new()
{
  Name = "John Jones",
  Born = new(year: 1990, month: 7, day: 28,
    hour: 0, minute: 0, second: 0, offset: TimeSpan.Zero)
};
john.WriteToConsole();
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">John Jones was born on a Saturday.
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that the <code class="inlineCode">Employee</code> class has inherited all the members of <code class="inlineCode">Person</code>.</p>
    <h2 id="_idParaDest-401" class="heading-2">Extending classes to add functionality</h2>
    <p class="normal">Now, we will add some <a id="_idIndexMarker934"/>employee-specific members to extend the class:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Employee.cs</code>, add statements to define two properties, for an employee code and the date they were hired (we do not need to know a start time, so we can use the <code class="inlineCode">DateOnly</code> type), as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public string? EmployeeCode { get; set; }
public DateOnly HireDate { get; set; }
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to set John’s employee code and hire date, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">john.EmployeeCode = "JJ001";
john.HireDate = new(year: 2014, month: 11, day: 23);
WriteLine($"{john.Name} was hired on {john.HireDate:yyyy-MM-dd}.");
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project <a id="_idIndexMarker935"/>and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">John Jones was hired on 2014-11-23.
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-402" class="heading-2">Hiding members</h2>
    <p class="normal">So far, the <code class="inlineCode">WriteToConsole</code> method is<a id="_idIndexMarker936"/> inherited from <code class="inlineCode">Person</code>, and it only outputs the employee’s name and date and time of birth. We might want to change what this method does for an employee:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Employee.cs</code>, add statements to redefine the <code class="inlineCode">WriteToConsole</code> method, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class Employee : Person
{
  public string? EmployeeCode { get; set; }
  public DateOnly HireDate { get; set; }
<strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-keyword-slc">void</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">WriteToConsole</strong><strong class="hljs-function-slc">()</strong>
<strong class="hljs-slc">  {</strong>
<strong class="hljs-slc">    WriteLine(format:</strong>
<strong class="hljs-slc">      </strong><strong class="hljs-string-slc">"{0} was born on {1:dd/MM/yy} and hired on {2:dd/MM/yy}."</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc">      arg0: Name, arg1: Born, arg2: HireDate);</strong>
<strong class="hljs-slc">  }</strong>
}
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project, view the result, and note that the first line of output is before the employees were hired; hence, it has a default date, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">John Jones was born on 28/07/90 and hired on 01/01/01.
John Jones was hired on 2014-11-23.
</code></pre>
      </li>
    </ol>
    <p class="normal">Your code editor warns <a id="_idIndexMarker937"/>you that your method now hides the method from <code class="inlineCode">Person</code> by drawing a squiggle under the method name, the <strong class="screenText">PROBLEMS</strong>/<strong class="screenText">Error List</strong> window includes more details, and the compiler will output a warning when you build and run the console application, as shown in <em class="italic">Figure 6.3</em>:</p>
    <figure class="mediaobject"><img src="img/B22322_06_03.png" alt="" width="878" height="299"/></figure>
    <p class="packt_figref">Figure 6.3: Hidden method warning</p>
    <p class="normal">As the warning describes, you should hide this message by applying the <code class="inlineCode">new</code> keyword to the method, indicating that you are deliberately replacing the old method, as highlighted in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public <strong class="hljs-keyword-slc">new</strong> void WriteToConsole()
</code></pre>
    <p class="normal">Make this fix now.</p>
    <h2 id="_idParaDest-403" class="heading-2">Understanding the this and base keywords</h2>
    <p class="normal">There are two special C# keywords that can be used to refer to the current object instance or the base class that it inherits from:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">this</code>: It represents the<a id="_idIndexMarker938"/> current object instance. For example, in the <code class="inlineCode">Person</code> class instance members (but not in static members), you could use the expression <code class="inlineCode">this.Born</code> to access the <code class="inlineCode">Born</code> field of the current object instance. You rarely need to use it, since the expression <code class="inlineCode">Born</code> would also work. It is only when there is a local variable also named <code class="inlineCode">Born</code> that you would need to use <code class="inlineCode">this.Born</code> to explicitly say you are referring to the field, not the local variable.</li>
      <li class="bulletList"><code class="inlineCode">base</code>: It <a id="_idIndexMarker939"/>represents the base class that the current object inherits from. For example, anywhere in the <code class="inlineCode">Person</code> class, you could use the expression <code class="inlineCode">base.ToString()</code> to call the base class implementation of that method.</li>
    </ul>
    <div><p class="normal">You will (hopefully) remember from <em class="chapterRef">Chapter 5</em>, <em class="italic">Building Your Own Types with Object-Oriented Programming</em>, that to access static members, you must use the type name.</p>
    </div>
    <h2 id="_idParaDest-404" class="heading-2">Overriding members</h2>
    <p class="normal">Rather than <a id="_idIndexMarker940"/>hiding a method, it is usually better to <strong class="keyWord">override</strong> it. You can only override it if the base class chooses to allow overriding, by applying the <code class="inlineCode">virtual</code> keyword to any methods that should allow overriding.</p>
    <p class="normal">Let’s see an example:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, add a statement to write the value of the <code class="inlineCode">john</code> variable to the console using its <code class="inlineCode">string</code> representation, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">WriteLine(john.ToString());
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and note that the <code class="inlineCode">ToString</code> method is inherited from <code class="inlineCode">System.Object</code>, so the implementation returns the namespace and type name, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Packt.Shared.Employee
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Person.cs</code> (not in the <code class="inlineCode">Employee</code> class!), override this behavior by adding a <code class="inlineCode">ToString</code> method to output the name of the person as well as the type <a id="_idIndexMarker941"/>name, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">#region Overridden methods
public override string ToString()
{
  return $"{Name} is a {base.ToString()}.";
}
#endregion
</code></pre>
        <div><p class="normal">The <code class="inlineCode">base</code> keyword allows a subclass to access members of its superclass, that is, the <strong class="keyWord">base class</strong> that it <a id="_idIndexMarker942"/>inherits or derives from.</p>
        </div>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Some code editors like Visual Studio will automatically add a call to the base class member when you override a member. To decide if you need to keep the call or not, view the tooltip or definition of the member. For example, in <em class="chapterRef">Chapter 10</em>, <em class="chapterRef">Working with Data Using Entity Framework Core</em>, you will override a method of the <code class="inlineCode">DbContext</code> class named <code class="inlineCode">OnConfiguring</code>. If you hover over the method name, its tooltip tells you “The base implementation does nothing.” If you <strong class="screenText">Go To Definition</strong> (<em class="keystroke">F12</em>) of the method, you will see that it does nothing, as shown in the following code:</p>
      <pre class="programlisting code"><code class="hljs-code">protected internal virtual void OnConfiguring(
DbContextOptionsBuilder optionsBuilder)
{
}
</code></pre>
      <p class="normal">The method only exists in the base class so that subclasses can override it and then EF Core can call your code when it needs to configure the data context. It would be a waste for your overridden method implementation to call the base implementation.</p>
    </div>
    <ol>
      <li class="numberedList" value="4">Run the <code class="inlineCode">PeopleApp</code> project and view the result. Now, when the <code class="inlineCode">ToString</code> method is called, it outputs the person’s name, as well as returning the<a id="_idIndexMarker943"/> base class’s implementation of <code class="inlineCode">ToString</code>, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">John Jones is a Packt.Shared.Employee.
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Many real-world APIs, for example, Microsoft’s Entity Framework Core, Castle’s DynamicProxy, and Optimizely CMS’s content models, require the properties that you define in your classes to be marked as <code class="inlineCode">virtual</code> so that they can be overridden. Carefully decide which of your methods and property members should be marked as <code class="inlineCode">virtual</code>.</p>
    </div>
    <h2 id="_idParaDest-405" class="heading-2">Inheriting from abstract classes</h2>
    <p class="normal">Earlier in this chapter, you<a id="_idIndexMarker944"/> learned about interfaces that can define a set of members that a type must have to meet a basic level of functionality. These are very useful, but their main limitation is that until C# 8 they could not provide any implementation of their own.</p>
    <p class="normal">This is a particular problem if you still need to create class libraries that will work with .NET Framework and other platforms that do not support .NET Standard 2.1.</p>
    <p class="normal">In those earlier platforms, you could use an <strong class="keyWord">abstract class</strong> as a sort of halfway house between a pure interface and a fully implemented class.</p>
    <p class="normal">When a class is marked as <code class="inlineCode">abstract</code>, this means that it cannot be instantiated because you have indicated that the class is not complete. It needs more implementation before it can be instantiated.</p>
    <p class="normal">For example, the <code class="inlineCode">System.IO.Stream</code> class is <code class="inlineCode">abstract</code> because it implements common functionality that all streams would need but is not complete. Therefore, it is useless without more implementation that is specific to the type of stream, so you cannot instantiate it using <code class="inlineCode">new Stream()</code>.</p>
    <p class="normal">Let’s compare the two <a id="_idIndexMarker945"/>types of interface and the two types of class, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public interface INoImplementation // C# 1 and later.
{
  void Alpha(); // Must be implemented by derived type.
}
public interface ISomeImplementation // C# 8 and later.
{
  void Alpha(); // Must be implemented by derived type.
  void Beta()
  {
    // Default implementation; can be overridden.
  }
}
public abstract class PartiallyImplemented // C# 1 and later.
{
  public abstract void Gamma(); // Must be implemented by derived type.
  public virtual void Delta() // Can be overridden.
  {
    // Implementation.
  }
}
public class FullyImplemented : PartiallyImplemented, ISomeImplementation
{
  public void Alpha()
  {
    // Implementation.
  }
  public override void Gamma()
  {
    // Implementation.
  }
}
// You can only instantiate the fully implemented class.
FullyImplemented a = new();
// All the other types give compile errors.
PartiallyImplemented b = new(); // Compile error!
ISomeImplementation c = new(); // Compile error!
INoImplementation d = new(); // Compile error!
</code></pre>
    <h2 id="_idParaDest-406" class="heading-2">Choosing between an interface and an abstract class</h2>
    <p class="normal">You have now seen<a id="_idIndexMarker946"/> examples of implementing the<a id="_idIndexMarker947"/> concept of abstraction using either an interface or an <code class="inlineCode">abstract</code> class. Which should you pick? Now that an interface can have default implementations for its members, is the <code class="inlineCode">abstract</code> keyword for a class obsolete?</p>
    <p class="normal">Well, let’s think about a real example. <code class="inlineCode">Stream</code> is an <code class="inlineCode">abstract</code> class. Would or could the .NET team use an interface for that today?</p>
    <p class="normal">Every member of an interface must be <code class="inlineCode">public</code> (or at least match the interface’s access level, which could be <code class="inlineCode">internal</code> if it should only be used in the class library that it’s defined in). An <code class="inlineCode">abstract</code> class has more flexibility in its members’ access modifiers.</p>
    <p class="normal">Another advantage of an <code class="inlineCode">abstract</code> class over an interface is that serialization often does not work for an interface. So, no, we still need to be able to define abstract classes.</p>
    <h2 id="_idParaDest-407" class="heading-2">Preventing inheritance and overriding</h2>
    <p class="normal">You can prevent another <a id="_idIndexMarker948"/>developer from inheriting from your class by applying the <code class="inlineCode">sealed</code> keyword to its definition. For example, no one can inherit from Scrooge <a id="_idIndexMarker949"/>McDuck, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public sealed class ScroogeMcDuck
{
}
</code></pre>
    <p class="normal">An example of <code class="inlineCode">sealed</code> in .NET is the <code class="inlineCode">string</code> class. Microsoft has implemented some extreme optimizations inside the <code class="inlineCode">string</code> class that could be negatively affected by your inheritance, so Microsoft prevents that.</p>
    <p class="normal">You can prevent someone from further overriding a <code class="inlineCode">virtual</code> method in your class by applying the <code class="inlineCode">sealed</code> keyword to the method. For example, no one can change the way Lady Gaga sings, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">namespace Packt.Shared;
public class Singer
{
  // Virtual allows this method to be overridden.
  public virtual void Sing()
  {
    WriteLine("Singing...");
  }
}
public class LadyGaga : Singer
{
  // The sealed keyword prevents overriding the method in subclasses.
  public sealed override void Sing()
  {
    WriteLine("Singing with style...");
  }
}
</code></pre>
    <p class="normal">You can only seal an overridden method.</p>
    <h2 id="_idParaDest-408" class="heading-2">Understanding polymorphism</h2>
    <p class="normal">You <a id="_idIndexMarker950"/>have now seen two ways to change the behavior of an inherited method. We <a id="_idIndexMarker951"/>can <em class="italic">hide</em> it using the <code class="inlineCode">new</code> keyword (known as <strong class="keyWord">non-polymorphic inheritance</strong>), or we can <em class="italic">override</em> it (known <a id="_idIndexMarker952"/>as <strong class="keyWord">polymorphic inheritance</strong>).</p>
    <p class="normal">Both ways can access members of the base or superclass by using the <code class="inlineCode">base</code> keyword, so what is the difference?</p>
    <p class="normal">It all depends on the type of variable holding a reference to the object. For example, a variable of the <code class="inlineCode">Person</code> type can hold a reference to a <code class="inlineCode">Person</code> class, or any type that derives from <code class="inlineCode">Person</code>.</p>
    <p class="normal">Let’s see how this could affect your code:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Employee.cs</code>, add statements to override the <code class="inlineCode">ToString</code> method so that it writes the employee’s name and code to the console, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public override string ToString()
{
  return $"{Name}'s code is {EmployeeCode}.";
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, write statements to create a new employee named Alice stored in a variable of type <code class="inlineCode">Employee</code>. Also, store Alice in a second variable of type <code class="inlineCode">Person</code>, and then call both variables’ <code class="inlineCode">WriteToConsole</code> and <code class="inlineCode">ToString</code> methods, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Employee aliceInEmployee = new()
  { Name = "Alice", EmployeeCode = "AA123" };
Person aliceInPerson = aliceInEmployee;
aliceInEmployee.WriteToConsole();
aliceInPerson.WriteToConsole();
WriteLine(aliceInEmployee.ToString());
WriteLine(aliceInPerson.ToString());
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Alice was born on 01/01/01 and hired on 01/01/01
Alice was born on a Monday
Alice's code is AA123
Alice's code is AA123
</code></pre>
      </li>
    </ol>
    <p class="normal">When a method is<a id="_idIndexMarker953"/> hidden with <code class="inlineCode">new</code>, the compiler is not smart enough to know that the object is an <code class="inlineCode">Employee</code>, so it calls the <code class="inlineCode">WriteToConsole</code> method in <code class="inlineCode">Person</code>.</p>
    <p class="normal">When a method is overridden with <code class="inlineCode">virtual</code> and <code class="inlineCode">override</code>, the compiler is smart enough to know that although the variable is declared as a <code class="inlineCode">Person</code> class and the object itself is an <code class="inlineCode">Employee</code> class, and therefore, the <code class="inlineCode">Employee</code> implementation of <code class="inlineCode">ToString</code> is called.</p>
    <p class="normal">The member modifiers and the effect they have are summarized in <em class="italic">Table 6.5</em>:</p>
    <table id="table005-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Variable type</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Member modifier</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Method executed</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">In class</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Person</code></p>
          </td>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">WriteToConsole</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Person</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Employee</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">new</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">WriteToConsole</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Employee</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Person</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">virtual</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ToString</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Employee</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Employee</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">override</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ToString</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Employee</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.5: Member modifiers and the effect they have</p>
    <p class="normal">In my opinion, polymorphism is<a id="_idIndexMarker954"/> academic to most programmers. If you get the concept, that’s cool; but if not, I suggest that you don’t worry about it. Some people like to make others feel inferior by saying understanding polymorphism is important for all C# programmers, but in my opinion, it’s not. There are thousands of other topics that your time and effort will be better spent on.</p>
    <p class="normal">You can have a successful career with C# and never need to be able to explain polymorphism, just as a racing car driver doesn’t need to explain the engineering behind fuel injection.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: You should use <code class="inlineCode">virtual</code> and <code class="inlineCode">override</code> rather than <code class="inlineCode">new</code> to change the implementation of an inherited method whenever possible.</p>
    </div>
    <h1 id="_idParaDest-409" class="heading-1">Casting within inheritance hierarchies</h1>
    <p class="normal"><strong class="keyWord">Casting</strong> between types is subtly different from converting between types. Casting<a id="_idIndexMarker955"/> is between similar types, like between a 16-bit integer and a 32-bit integer, or between a superclass and one of its subclasses. <strong class="keyWord">Converting</strong> is between<a id="_idIndexMarker956"/> dissimilar types, such as between text and a number.</p>
    <p class="normal">For example, if you need to work with multiple types of <code class="inlineCode">stream</code>, then instead of declaring specific types of stream like <code class="inlineCode">MemoryStream</code> or <code class="inlineCode">FileStream</code>, you could declare an array of <code class="inlineCode">Stream</code>, the supertype of <code class="inlineCode">MemoryStream</code>, and <code class="inlineCode">FileStream</code>.</p>
    <h2 id="_idParaDest-410" class="heading-2">Implicit casting</h2>
    <p class="normal">In the previous example, you saw how an instance of a derived type can be stored in a variable<a id="_idIndexMarker957"/> of its base type (or its base’s base type, and so on). When we do this, it is<a id="_idIndexMarker958"/> called <strong class="keyWord">implicit casting</strong>.</p>
    <h2 id="_idParaDest-411" class="heading-2">Explicit casting</h2>
    <p class="normal">The opposite of implicit <a id="_idIndexMarker959"/>casting is <a id="_idIndexMarker960"/>explicit casting, and you must use parentheses around the type you want to cast into as a prefix to do it:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, add a statement to assign the <code class="inlineCode">aliceInPerson</code> variable to a new <code class="inlineCode">Employee</code> variable, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Employee explicitAlice = aliceInPerson;
</code></pre>
      </li>
      <li class="numberedList">Your code editor displays a red squiggle and a compile error, as shown in <em class="italic">Figure 6.4</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B22322_06_04.png" alt="" width="812" height="299"/></figure>
    <p class="packt_figref">Figure 6.4: A missing explicit cast compile error</p>
    <ol>
      <li class="numberedList" value="3">Change the statement to prefix the assigned variable name with a cast to the <code class="inlineCode">Employee</code> type, as shown highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Employee explicitAlice = <strong class="hljs-slc">(Employee)</strong>aliceInPerson;
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-412" class="heading-2">Avoiding casting exceptions</h2>
    <p class="normal">The compiler is now<a id="_idIndexMarker961"/> happy; however, because <code class="inlineCode">aliceInPerson</code> might be a different derived type, like <code class="inlineCode">Student</code> instead of <code class="inlineCode">Employee</code>, we need to be careful. In a real application with more complex code, the current value of this variable could have been set to a <code class="inlineCode">Student</code> instance, and then this statement would throw an <code class="inlineCode">InvalidCastException</code> error at runtime.</p>
    <h2 id="_idParaDest-413" class="heading-2">Using is to check a type</h2>
    <p class="normal">We<a id="_idIndexMarker962"/> can handle this by writing a <code class="inlineCode">try</code> statement, but there is a better way. We can check the type of an object using the <code class="inlineCode">is</code> keyword:</p>
    <ol>
      <li class="numberedList" value="1">Wrap the explicit cast statement in an <code class="inlineCode">if</code> statement, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (aliceInPerson </strong><strong class="hljs-keyword-slc">is</strong><strong class="hljs-slc"> Employee)</strong>
<strong class="hljs-slc">{</strong>
<strong class="hljs-slc">  WriteLine(</strong><strong class="hljs-string-slc">$"</strong><strong class="hljs-subst-slc">{</strong><strong class="hljs-keyword-slc">nameof</strong><strong class="hljs-subst-slc">(aliceInPerson)}</strong><strong class="hljs-string-slc"> is an Employee."</strong><strong class="hljs-slc">);</strong>
  Employee explicitAlice = (Employee)aliceInPerson;
<strong class="hljs-slc">  </strong><strong class="hljs-comment-slc">// Safely do something with explicitAlice.</strong>
<strong class="hljs-slc">}</strong>
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">aliceInPerson is an Employee.
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: You could simplify the code further using a declaration pattern, and this will avoid the need to perform an explicit cast, as shown in the following code:</p>
      <pre class="programlisting code"><code class="hljs-code">if (aliceInPerson is Employee explicitAlice)
{
  WriteLine($"{nameof(aliceInPerson)} is an Employee.");
  // Safely do something with explicitAlice.
}
</code></pre>
      <p class="normal">This technique of both checking and casting was covered in <em class="chapterRef">Chapter 3</em>,<em class="chapterRef"> Controlling Flow, Converting Types, and Handling Exceptions</em>.</p>
    </div>
    <p class="normal">What if you want to execute a block of statements when Alice is <em class="italic">not</em> an employee?</p>
    <p class="normal">In the past, you would have had to use the <code class="inlineCode">!</code> (not) operator, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">if (!(aliceInPerson is Employee))
</code></pre>
    <p class="normal">With C# 9 and later, you can use the <code class="inlineCode">not</code> keyword, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">if (aliceInPerson is not Employee)
</code></pre>
    <h2 id="_idParaDest-414" class="heading-2">Using as to cast a type</h2>
    <p class="normal">Alternatively, you can use the <code class="inlineCode">as</code> keyword to cast a type. Instead of throwing an exception, the <code class="inlineCode">as</code> keyword<a id="_idIndexMarker963"/> returns <code class="inlineCode">null</code> if the type cannot be cast:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, add statements to cast Alice using the <code class="inlineCode">as</code> keyword, and then check whether the return value is not null, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Employee? aliceAsEmployee = aliceInPerson as Employee;
if (aliceAsEmployee is not null)
{
  WriteLine($"{nameof(aliceInPerson)} as an Employee.");
  // Safely do something with aliceAsEmployee.
}
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Since accessing a member of a <code class="inlineCode">null</code> variable will throw a <code class="inlineCode">NullReferenceException</code> error, you should always check for <code class="inlineCode">null</code> before using the result.</p>
    <ol>
      <li class="numberedList" value="2">Run the <code class="inlineCode">PeopleApp</code> project and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">aliceInPerson as an Employee.
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Use the <code class="inlineCode">is</code> and <code class="inlineCode">as</code> keywords to prevent throwing exceptions when casting between derived types. If you don’t do this, you must write <code class="inlineCode">try</code>-<code class="inlineCode">catch</code> statements for <code class="inlineCode">InvalidCastException</code>.</p>
    </div>
    <h1 id="_idParaDest-415" class="heading-1">Inheriting and extending .NET types</h1>
    <p class="normal">.NET has pre-built class libraries containing hundreds of thousands of types. Rather than creating your own completely new types, you can often get a head start by deriving from one of Microsoft’s types to inherit some or all its behavior, and then overriding or extending it.</p>
    <h2 id="_idParaDest-416" class="heading-2">Inheriting exceptions</h2>
    <p class="normal">As an example of inheritance, we will <a id="_idIndexMarker964"/>derive a new type of exception:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">PersonException.cs</code>.</li>
      <li class="numberedList">Modify the contents of the file to define a class named <code class="inlineCode">PersonException</code> with three constructors, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
public class PersonException : Exception
{
  public PersonException() : base() { }
  public PersonException(string message) : base(message) { }
  public PersonException(string message, Exception innerException)
    : base(message, innerException) { }
}
</code></pre>
      </li>
    </ol>
    <div><p class="normal">Unlike ordinary methods, constructors are not inherited, so we must explicitly declare and explicitly call the <code class="inlineCode">base</code> constructor implementations in <code class="inlineCode">System.Exception</code> (or whichever exception class you derived from) to make them available to programmers who might want to use those constructors with our custom exception.</p>
    </div>
    <ol>
      <li class="numberedList" value="3">In <code class="inlineCode">Person.cs</code>, add <a id="_idIndexMarker965"/>statements to define a method that throws an exception if a date/time parameter is earlier than a person’s date and time of birth, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public void TimeTravel(DateTime when)
{
  if (when &lt;= Born)
  {
    throw new PersonException("If you travel back in time to a date earlier than your own birth, then the universe will explode!");
  }
  else
  {
    WriteLine($"Welcome to {when:yyyy}!");
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to test what happens when employee John Jones tries to time-travel too far back, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">try
{
  john.TimeTravel(when: new(1999, 12, 31));
  john.TimeTravel(when: new(1950, 12, 25));
}
catch (PersonException ex)
{
  WriteLine(ex.Message);
}
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project <a id="_idIndexMarker966"/>and view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Welcome to 1999!
If you travel back in time to a date earlier than your own birth, then the universe will explode!
</code></pre>
      </li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: When defining your own exceptions, give them the same three constructors that explicitly call the built-in ones in <code class="inlineCode">System.Exception</code>. Other exceptions that you might inherit from may have more.</p>
    </div>
    <h2 id="_idParaDest-417" class="heading-2">Extending types when you can’t inherit</h2>
    <p class="normal">Earlier, we saw how the <code class="inlineCode">sealed</code> modifier can be used to prevent inheritance.</p>
    <p class="normal">Microsoft has applied the <code class="inlineCode">sealed</code> keyword to the <code class="inlineCode">System.String</code> class so that no one can inherit and potentially break the behavior of strings.</p>
    <p class="normal">Can we still add new methods to strings? Yes, if we use a language feature named <strong class="keyWord">extension methods</strong>, which was <a id="_idIndexMarker967"/>introduced with C# 3.0. To properly understand extension methods, we need to review static methods first.</p>
    <h2 id="_idParaDest-418" class="heading-2">Using static methods to reuse functionality</h2>
    <p class="normal">Since the first version of C#, we’ve<a id="_idIndexMarker968"/> been able to create <code class="inlineCode">static</code> methods to reuse functionality, such as the ability to validate that a <code class="inlineCode">string</code> contains an email address. The implementation will use a regular expression that you will learn more about in <em class="chapterRef">Chapter 8</em>, <em class="italic">Working with Common .NET Types</em>.</p>
    <p class="normal">Let’s <a id="_idIndexMarker969"/>write some code:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">StringExtensions.cs</code>.</li>
      <li class="numberedList">Modify <code class="inlineCode">StringExtensions.cs</code>, as shown in the following code, and note the following:<ul>
          <li class="bulletList level-2">The class imports a namespace to handle regular expressions.</li>
          <li class="bulletList level-2">The <code class="inlineCode">IsValidEmail</code> method is <code class="inlineCode">static</code>, and it uses the <code class="inlineCode">Regex</code> type to check for matches against a simple email pattern that looks for valid characters before and after the <code class="inlineCode">@</code> symbol:
            <pre class="programlisting code"><code class="hljs-code">using System.Text.RegularExpressions; // To use Regex.
namespace Packt.Shared;
public class StringExtensions
{
  public static bool IsValidEmail(string input)
  {
    // Use a simple regular expression to check
    // that the input string is a valid email.
    return Regex.IsMatch(input,
      @"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+");
  }
}
</code></pre>
          </li>
        </ul>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to validate two examples of email addresses, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">string email1 = "pamela@test.com";
string email2 = "ian&amp;test.com";
WriteLine("{0} is a valid e-mail address: {1}",
  arg0: email1,
  arg1: StringExtensions.IsValidEmail(email1));
WriteLine("{0} is a valid e-mail address: {1}",
  arg0: email2,
  arg1: StringExtensions.IsValidEmail(email2));
</code></pre>
      </li>
      <li class="numberedList">Run the <code class="inlineCode">PeopleApp</code> project and<a id="_idIndexMarker970"/> view the result, as shown in the following output:
        <pre class="programlisting con-one"><code class="hljs-con">pamela@test.com is a valid e-mail address: True
ian&amp;test.com is a valid e-mail address: False
</code></pre>
      </li>
    </ol>
    <p class="normal">This works, but extension methods can reduce the amount of code we must type and simplify the usage of this function.</p>
    <h2 id="_idParaDest-419" class="heading-2">Using extension methods to reuse functionality</h2>
    <p class="normal">It is easy to turn <code class="inlineCode">static</code> methods into <a id="_idIndexMarker971"/>extension methods:</p>
    <ol>
      <li class="numberedList" value="1">In <code class="inlineCode">StringExtensions.cs</code>, add the <code class="inlineCode">static</code> modifier before the class, and then add the <code class="inlineCode">this</code> modifier before the <code class="inlineCode">string</code> type, as highlighted in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">public <strong class="hljs-keyword-slc">static</strong> class StringExtensions
{
  public static bool IsValidEmail(<strong class="hljs-keyword-slc">this</strong> string input)
  {
</code></pre>
        <div><p class="normal"><strong class="keyWord">Good Practice</strong>: These two changes tell the compiler that it should treat the method as one that extends the <code class="inlineCode">string</code> type.</p>
        </div>
      </li>
    </ol>
    <ol>
      <li class="numberedList" value="2">In <code class="inlineCode">Program.cs</code>, add statements to use the extension method for <code class="inlineCode">string</code> values that need to be checked for valid email addresses, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">WriteLine("{0} is a valid e-mail address: {1}",
  arg0: email1,
  arg1: email1.IsValidEmail());
WriteLine("{0} is a valid e-mail address: {1}",
  arg0: email2,
  arg1: email2.IsValidEmail());
</code></pre>
      </li>
    </ol>
    <div><p class="normal">Note the subtle simplification in the syntax to call the <code class="inlineCode">IsValidEmail</code> method. The older, longer syntax still works too.</p>
    </div>
    <ol>
      <li class="numberedList" value="3">The <code class="inlineCode">IsValidEmail</code> extension method now appears to be a method just like all the actual instance methods of the <code class="inlineCode">string</code> type, such as <code class="inlineCode">IsNormalized</code>, except with a small down arrow on the method icon to indicate an <a id="_idIndexMarker972"/>extension method, as shown in <em class="italic">Figure 6.5</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B22322_06_05.png" alt="" width="812" height="248"/></figure>
    <p class="packt_figref">Figure 6.5: Extension methods appear in IntelliSense alongside instance methods</p>
    <ol>
      <li class="numberedList" value="4">Run the <code class="inlineCode">PeopleApp</code> project and view the result, which will be the same as before.</li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Extension methods cannot replace or override existing instance methods. You cannot, for example, redefine the <code class="inlineCode">Insert</code> method. The extension method will appear as an overload in IntelliSense, but an instance method will be called in preference to an extension method with the same name and signature.</p>
    </div>
    <p class="normal">Although extension methods might not seem to give a big benefit, in <em class="chapterRef">Chapter 11</em>, <em class="italic">Querying and Manipulating Data Using LINQ</em>, you will see some extremely powerful uses of extension methods.</p>
    <h2 id="_idParaDest-420" class="heading-2">Method chaining or fluent style</h2>
    <p class="normal">Method chaining, also known as<a id="_idIndexMarker973"/> fluent style, is a programming technique where multiple <a id="_idIndexMarker974"/>method calls are chained together in a single statement. This is achieved by having each method return an instance of the same object (often the object the method was called on), enabling a sequence of method calls on the same object. This style is popular in C# for creating readable and concise code, especially for configuring objects or building complex queries.</p>
    <p class="normal">For example, consider this <code class="inlineCode">Person</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Person SetName(string name)
    {
        Name = name;
        return this;
    }
    public Person SetAge(int age)
    {
        Age = age;
        return this;
    }
}
</code></pre>
    <p class="normal">To construct a <code class="inlineCode">Person</code> instance, you can chain method calls, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">Person person = new()
  .SetName("John Doe")
  .SetAge(30);
</code></pre>
    <p class="normal">Extension methods allow adding new methods to existing types without modifying their source code or creating a new derived type. When combined with method chaining, this can enhance the readability and functionality of existing classes.</p>
    <p class="normal">Suppose you have a <code class="inlineCode">Car</code> class, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public class Car
{
  public string Model { get; set; }
  public string Color { get; set; }
}
</code></pre>
    <p class="normal">You can create extension methods to enable method chaining for the <code class="inlineCode">Car</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">public static class CarExtensions
{
  public static Car SetModel(this Car car, string model)
  {
    car.Model = model;
    return car;
  }
  public static Car SetColor(this Car car, string color)
  {
    car.Color = color;
    return car;
  }
}
</code></pre>
    <p class="normal">Now you can use these extension methods to chain method calls on a Car object:</p>
    <pre class="programlisting code"><code class="hljs-code">Car car = new()
  .SetModel("Tesla Model S")
  .SetColor("Red");
</code></pre>
    <p class="normal">The benefits of <a id="_idIndexMarker975"/>method chaining include:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Readability</strong>: The code is more readable and resembles natural language</li>
      <li class="bulletList"><strong class="keyWord">Conciseness</strong>: Reduces the need for repetitive code</li>
      <li class="bulletList"><strong class="keyWord">Configurability</strong>: Allows the flexible and easy configuration of objects</li>
    </ul>
    <p class="normal">But the potential drawbacks of method chaining include debugging difficulty because long chains can be harder to debug, and misleading code because if not used carefully, it can lead to less intuitive code, especially when dealing with nullable objects or complex logic.</p>
    <div><p class="normal"><strong class="keyWord">Good practice</strong>: When method chaining, use clear method names to ensure they clearly indicate their purpose, return <code class="inlineCode">this</code> or the object itself to maintain the chain, and carefully consider how to handle potential errors or exceptions within chained methods.</p>
    </div>
    <p class="normal">Method chaining and the fluent style, especially when combined with extension methods in C#, provide clean, readable, and maintainable code.</p>
    <h1 id="_idParaDest-421" class="heading-1">Summarizing custom type choices</h1>
    <p class="normal">Now that we have covered OOP and the C# features that enable you to define your own types, let’s summarize what you’ve learned.</p>
    <h2 id="_idParaDest-422" class="heading-2">Categories of custom types and their capabilities</h2>
    <p class="normal">Categories of <a id="_idIndexMarker976"/>custom types and their capabilities<a id="_idIndexMarker977"/> are summarized in <em class="italic">Table 6.6</em>:</p>
    <table id="table006-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Type</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Instantiation</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Inheritance</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Equality</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Memory</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">class</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Yes</p>
          </td>
          <td class="table-cell">
            <p class="normal">Single</p>
          </td>
          <td class="table-cell">
            <p class="normal">Reference</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heap</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">sealed</code> <code class="inlineCode">class</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Yes</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
          <td class="table-cell">
            <p class="normal">Reference</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heap</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">abstract</code> <code class="inlineCode">class</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">No</p>
          </td>
          <td class="table-cell">
            <p class="normal">Single</p>
          </td>
          <td class="table-cell">
            <p class="normal">Reference</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heap</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">record</code> or <code class="inlineCode">record</code> <code class="inlineCode">class</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Yes</p>
          </td>
          <td class="table-cell">
            <p class="normal">Single</p>
          </td>
          <td class="table-cell">
            <p class="normal">Value</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heap</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">struct</code> or <code class="inlineCode">record</code> <code class="inlineCode">struct</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Yes</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
          <td class="table-cell">
            <p class="normal">Value</p>
          </td>
          <td class="table-cell">
            <p class="normal">Stack</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">interface</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">No</p>
          </td>
          <td class="table-cell">
            <p class="normal">Multiple</p>
          </td>
          <td class="table-cell">
            <p class="normal">Reference</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heap</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.6: Categories of custom types and their capabilities</p>
    <p class="normal">It is best to think about<a id="_idIndexMarker978"/> these differences by starting with the “normal” case and then spotting the differences in other cases. For example, a “normal” <code class="inlineCode">class</code> can be instantiated with <code class="inlineCode">new</code>, it supports single inheritance, it uses memory reference equality, and its state is stored in heap memory.</p>
    <p class="normal">Now let’s highlight what is different about the more specialized types of classes:</p>
    <ul>
      <li class="bulletList">A <code class="inlineCode">sealed</code> class does not support inheritance.</li>
      <li class="bulletList">An <code class="inlineCode">abstract</code> class does not allow instantiation with <code class="inlineCode">new</code>.</li>
      <li class="bulletList">A <code class="inlineCode">record</code> class uses value equality instead of reference equality.</li>
    </ul>
    <p class="normal">We can do the same for other types compared to a “normal” class:</p>
    <ul>
      <li class="bulletList">A <code class="inlineCode">struct</code> or <code class="inlineCode">record struct</code> does not support inheritance, it uses value equality instead of reference equality, and its state is stored in stack memory.</li>
      <li class="bulletList">An <code class="inlineCode">interface</code> does not allow instantiation with <code class="inlineCode">new</code> and supports multiple inheritance.</li>
    </ul>
    <h2 id="_idParaDest-423" class="heading-2">Mutability and records</h2>
    <p class="normal">A common misconception is that <code class="inlineCode">record</code> types<a id="_idIndexMarker979"/> are immutable, meaning their instance property and field values cannot be changed after initialization. However, the mutability of a <code class="inlineCode">record</code> type actually depends on how the <code class="inlineCode">record</code> is defined. Let’s <a id="_idIndexMarker980"/>explore mutability:</p>
    <ol>
      <li class="numberedList" value="1">In the <code class="inlineCode">PacktLibrary</code> project, add a new class file named <code class="inlineCode">Mutability.cs</code>.</li>
      <li class="numberedList">Modify <code class="inlineCode">Mutability.cs</code>, as shown in the following code, and note the following:
        <pre class="programlisting code-one"><code class="hljs-code">namespace Packt.Shared;
// A mutable record class.
public record class C1
{
  public string? Name { get; set; }
}
// An immutable record class.
public record class C2(string? Name);
// A mutable record struct.
public record struct S1
{
  public string? Name { get; set; }
}
// Another mutable record struct.
public record struct S2(string? Name);
// An immutable record struct.
public readonly record struct S3(string? Name);
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">PeopleApp</code> project, in <code class="inlineCode">Program.cs</code>, create an instance of each type, setting the initial <code class="inlineCode">Name</code> value to <code class="inlineCode">Bob</code>, and then modify the <code class="inlineCode">Name</code> property <a id="_idIndexMarker981"/>to <code class="inlineCode">Bill</code>. You will see the two types that are immutable after<a id="_idIndexMarker982"/> initialization because they will give the compiler error <code class="inlineCode">CS8852</code>, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">C1 c1 = new() { Name = "Bob" };
c1.Name = "Bill";
C2 c2 = new(Name: "Bob");
c2.Name = "Bill"; // CS8852: Init-only property.
S1 s1 = new() { Name = "Bob" };
s1.Name = "Bill";
S2 s2 = new(Name: "Bob");
s2.Name = "Bill";
S3 s3 = new(Name: "Bob");
s3.Name = "Bill"; // CS8852: Init-only property.
</code></pre>
      </li>
      <li class="numberedList">Note that record <code class="inlineCode">C1</code> is mutable and <code class="inlineCode">C2</code> is immutable. Note that <code class="inlineCode">S1</code> and <code class="inlineCode">S2</code> are mutable and <code class="inlineCode">S3</code> is immutable.</li>
      <li class="numberedList">Comment<a id="_idIndexMarker983"/> out the <a id="_idIndexMarker984"/>two statements that cause compiler errors.<div><p class="normal">Microsoft made some interesting design choices with records. Make sure you remember the subtle differences in behavior when combining record, class, and struct, and use different types of declaration of each.</p>
        </div>
      </li>
    </ol>
    <h2 id="_idParaDest-424" class="heading-2">Comparing inheritance and implementation</h2>
    <p class="normal">For me, the<a id="_idIndexMarker985"/> terms <em class="italic">inherit</em> and <em class="italic">implement</em> are different, and in the early days of C# and .NET you could strictly apply them to classes and interfaces, respectively. For example, the <code class="inlineCode">FileStream</code> class inherits from the <code class="inlineCode">Stream</code> class, and the <code class="inlineCode">Int32</code> <code class="inlineCode">struct</code> implements the <code class="inlineCode">IComparable</code> interface.</p>
    <p class="normal"><em class="italic">Inherit</em> implies <a id="_idIndexMarker986"/>some functionality that a subclass gets “for free” by inheriting from its <strong class="keyWord">base</strong>, or <strong class="keyWord">superclass</strong>. <em class="italic">Implement</em> implies some functionality that is NOT inherited but<a id="_idIndexMarker987"/> instead MUST be provided by the subclass. This is why I chose to title this chapter <em class="chapterRef">Implementing Interfaces and Inheriting Classes</em>.</p>
    <p class="normal">Before C# 8, interfaces were always purely contracts. There was no functionality in an interface that you could inherit. In those days, you could strictly use the term <em class="italic">implement</em> for interfaces that represent a list of members that your type must implement, and <em class="italic">inherit</em> for classes with functionality that your type can inherit and potentially override.</p>
    <p class="normal">With C# 8, interfaces can now include default implementations, making them more like abstract classes, and the term <em class="italic">inherit</em> for an interface that has default implementations does make sense. But I feel uncomfortable with this capability, as do many other .NET developers, because it messes up what used to be a clean language design. Default interfaces also require changes to the underlying .NET runtime, so they cannot be used with legacy platforms like .NET Standard 2.0 class libraries and .NET Framework.</p>
    <p class="normal">Classes can also have abstract members, for example, methods or properties without any implementation, just like an interface could have. When a subclass inherits from this class, it MUST provide an implementation of those abstract members, and the base class must be decorated with the <code class="inlineCode">abstract</code> keyword to prevent it from being instantiated using <code class="inlineCode">new</code> because it is missing some functionality.</p>
    <h2 id="_idParaDest-425" class="heading-2">Reviewing illustrative code</h2>
    <p class="normal">Let’s review some example code that illustrates some of the important differences between types.</p>
    <p class="normal">Note the following:</p>
    <ul>
      <li class="bulletList">To simplify the code, I have left out access modifiers like <code class="inlineCode">private</code> and <code class="inlineCode">public</code>.</li>
      <li class="bulletList">Instead of normal brace formatting, to save vertical space I have put all the method implementations in one statement, for example:
        <pre class="programlisting gen-one"><code class="hljs">void M1() { /* implementation */ }
</code></pre>
      </li>
      <li class="bulletList">Using “I” as a prefix for interfaces is a convention, not a requirement. It is useful to highlight interfaces using this prefix, since only interfaces support multiple inheritance.</li>
    </ul>
    <p class="normal">Here’s the code:</p>
    <pre class="programlisting code"><code class="hljs-code">// These are both "classic" interfaces in that they are pure contracts.
// They have no functionality, just the signatures of members that
// must be implemented.
interface IAlpha
{
  // A method that must be implemented in any type that implements
  // this interface.
  void M1();
}
interface IBeta
{
  void M2(); // Another method.
}
// A type (a struct in this case) implementing an interface.
// ": IAlpha" means Gamma promises to implement all members of IAlpha.
struct Gamma : IAlpha
{
  void M1() { /* implementation */ }
}
// A type (a class in this case) implementing two interfaces.
class Delta : IAlpha, IBeta
{
  void M1() { /* implementation */ }
  void M2() { /* implementation */ }
}
// A sub class inheriting from a base aka super class.
// ": Delta" means inherit all members from Delta.
class Episilon : Delta
{
  // This can be empty because this inherits M1 and M2 from Delta.
  // You could also add new members here.
}
// A class with one inheritable method and one abstract method
// that must be implemented in sub classes. A class with at least
// one abstract member must be decorated with the abstract keyword
// to prevent instantiation.
abstract class Zeta
{
  // An implemented method would be inherited.
  void M3() { /* implementation */ }
  // A method that must be implemented in any type that inherits
  // this abstract class.
  abstract void M4();
}
// A class inheriting the M3 method from Zeta but it must provide
// an implementation for M4.
class Eta : Zeta
{
  void M4() { /* implementation */ }
}
// In C# 8 and later, interfaces can have default implementations
// as well as members that must be implemented.
// Requires: .NET Standard 2.1, .NET Core 3.0 or later.
interface ITheta
{
  void M3() { /* implementation */ }
  void M4();
}
// A class inheriting the default implementation from an interface
// and must provide an implementation for M4.
class Iota : ITheta
{
  void M4() { /* implementation */ }
}
</code></pre>
    <h1 id="_idParaDest-426" class="heading-1">Practicing and exploring</h1>
    <p class="normal">Test your knowledge and understanding by answering some questions, getting some hands-on practice, and exploring this chapter’s topics with more in-depth research.</p>
    <h2 id="_idParaDest-427" class="heading-2">Exercise 6.1 – Online material</h2>
    <p class="normal">Online material can be extra content written by me for this book, or it can be references to content created by Microsoft or third parties.</p>
    <h3 id="_idParaDest-428" class="heading-3">Managing memory with reference and value types</h3>
    <p class="normal">Read the following online-only section to learn how to manage memory with reference and value types:</p>
    <p class="normal"><a href="https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md">https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md</a></p>
    <h3 id="_idParaDest-429" class="heading-3">Writing better code</h3>
    <p class="normal">Read the following online-only section to learn how to use analyzers to write better code:</p>
    <p class="normal"><a href="https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md">https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md</a></p>
    <h2 id="_idParaDest-430" class="heading-2">Exercise 6.2 – Practice creating an inheritance hierarchy</h2>
    <p class="normal">Explore inheritance hierarchies by following these steps:</p>
    <ol>
      <li class="numberedList" value="1">Add a new console app named <code class="inlineCode">Exercise_Inheritance</code> to your <code class="inlineCode">Chapter06</code> solution.</li>
      <li class="numberedList">Create a class named <code class="inlineCode">Shape</code> with properties named <code class="inlineCode">Height</code>, <code class="inlineCode">Width</code>, and <code class="inlineCode">Area</code>.</li>
      <li class="numberedList">Add three classes that derive from it—<code class="inlineCode">Rectangle</code>, <code class="inlineCode">Square</code>, and <code class="inlineCode">Circle</code>—with any additional members you feel are appropriate and that override and implement the <code class="inlineCode">Area</code> property correctly.</li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to create one instance of each shape, as shown in the following code:
        <pre class="programlisting code-one"><code class="hljs-code">Rectangle r = new(height: 3, width: 4.5);
WriteLine($"Rectangle H: {r.Height}, W: {r.Width}, Area: {r.Area}");
Square s = new(5);
WriteLine($"Square H: {s.Height}, W: {s.Width}, Area: {s.Area}");
Circle c = new(radius: 2.5);
WriteLine($"Circle H: {c.Height}, W: {c.Width}, Area: {c.Area}");
</code></pre>
      </li>
      <li class="numberedList">Run the console app and ensure that the result looks like the following output:
        <pre class="programlisting con-one"><code class="hljs-con">Rectangle H: 3, W: 4.5, Area: 13.5
Square H: 5, W: 5, Area: 25
Circle H: 5, W: 5, Area: 19.6349540849362
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-431" class="heading-2">Exercise 6.3 – Test your knowledge</h2>
    <p class="normal">Answer the following questions:</p>
    <ol>
      <li class="numberedList" value="1">What is a delegate?</li>
      <li class="numberedList">What is an event?</li>
      <li class="numberedList">How are a base class and a derived class related, and how can the derived class access the base class?</li>
      <li class="numberedList">What is the difference between the <code class="inlineCode">is</code> and <code class="inlineCode">as</code> operators?</li>
      <li class="numberedList">Which keyword is used to prevent a class from being derived from or a method from being further overridden?</li>
      <li class="numberedList">Which keyword is used to prevent a class from being instantiated with the <code class="inlineCode">new</code> keyword?</li>
      <li class="numberedList">Which keyword is used to allow a member to be overridden?</li>
      <li class="numberedList">What’s the difference between a destructor and a deconstruct method?</li>
      <li class="numberedList">What are the signatures of the constructors that all exceptions should have?</li>
      <li class="numberedList">What is an extension method, and how do you define one?</li>
    </ol>
    <h2 id="_idParaDest-432" class="heading-2">Exercise 6.4 – Explore topics</h2>
    <p class="normal">Use the links on the following page to learn more about the topics covered in this chapter:</p>
    <p class="normal"><a href="https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes">https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes</a></p>
    <h1 id="_idParaDest-433" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about:</p>
    <ul>
      <li class="bulletList">Operators</li>
      <li class="bulletList">Generic types</li>
      <li class="bulletList">Delegates and events</li>
      <li class="bulletList">Implementing interfaces</li>
      <li class="bulletList">Memory usage differences between reference and value types</li>
      <li class="bulletList">Working with null values</li>
      <li class="bulletList">Deriving and casting types using inheritance</li>
      <li class="bulletList">Base and derived classes, how to override a type member, and using polymorphism</li>
    </ul>
    <p class="normal">In the next chapter, you will learn how .NET is packaged and deployed, and in subsequent chapters, the types that it provides you with to implement common functionality, such as file handling and database access.</p>
  </div>
</div></div></body></html>