<html><head></head><body>
		<div id="_idContainer030">
			<h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor146"/>9</h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor147"/>Taking Advantage of the Dynamic Language Runtime</h1>
			<p>C# is a statically typed language, which means we take our code in text form and run it through a compiler, and it produces a binary that is then executed later. The code does not change after the compiler is done. Not all languages are like this; languages such as Ruby, Python, and JavaScript are dynamic languages and do not compile to binary before execution. They are interpreted at runtime, meaning that they can also change gradually during runtime. This is a very <span class="No-Break">powerful trait.</span></p>
			<p>In this chapter, we will look into how we can make use of the dynamic language runtime part of the .NET runtime and create code dynamically and differently from how we’ve done it <span class="No-Break">thus far.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">the DLR</span></li>
				<li>Reasoning about a <span class="No-Break">dynamic type</span></li>
				<li>Creating a DynamicObject and <span class="No-Break">providing metadata</span></li>
			</ul>
			<p>By the end of the chapter, you will understand what the dynamic language runtime is and how you can make use of it to dynamically create types and reason <span class="No-Break">about them.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor149"/>Understanding the DLR</h1>
			<p>The <strong class="bo d">Dynamic Language Runtime</strong> (<strong class="bo d">DLR</strong>) was<a id="_idIndexMarker297"/> introduced in .NET 4 back in 2010. It runs on top of the .NET runtime, <strong class="bo d">Common Language Runtime</strong> (<strong class="bo d">CLR</strong>), providing <a id="_idIndexMarker298"/>language services for dynamic languages such as Python and Ruby through the IronPython and IronRuby implementations. With the DLR, it is also possible to interop between the different languages, effectively making it possible to have C# and Python, Ruby, or any other dynamic language that is supported run side by side in the <span class="No-Break">same process.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor150"/>The CLR at a glance</h2>
			<p>Before diving<a id="_idIndexMarker299"/> into <a id="_idIndexMarker300"/>the DLR, it’s helpful to understand the constraints it has to work with. The CLR is at the heart of everything .NET, which means that everything running has to abide by the rules of the CLR. That becomes very interesting when looking at the traits of <span class="No-Break">the CLR.</span></p>
			<h3>Just-in-Time (JIT) compilation</h3>
			<p>The CLR <a id="_idIndexMarker301"/>compiles <a id="_idIndexMarker302"/>the <strong class="bo d">Intermediate Language</strong> (<strong class="bo d">IL</strong>) code into native <a id="_idIndexMarker303"/>code for the specific machine and operating system at runtime, using the JIT compiler. This process enables better optimization, faster execution, and <span class="No-Break">cross-platform compatibility.</span></p>
			<h3>Automatic memory management</h3>
			<p>The CLR manages<a id="_idIndexMarker304"/> memory allocation and deallocation using garbage collection, which automatically frees up memory occupied by objects that are no longer in use. This helps prevent memory leaks and optimizes <span class="No-Break">memory usage.</span></p>
			<h3>Type safety</h3>
			<p>The CLR ensures<a id="_idIndexMarker305"/> type safety by enforcing strict rules during code execution. This helps prevent invalid memory operations, such as accessing a memory location that has not been initialized or using an object of one type as <span class="No-Break">another type.</span></p>
			<h3>Exception handling</h3>
			<p>The CLR provides <a id="_idIndexMarker306"/>a consistent and robust exception-handling mechanism across all .NET languages, allowing developers to handle runtime errors gracefully and maintain <span class="No-Break">application stability.</span></p>
			<h3>Cross-language Interoperability</h3>
			<p>The CLR supports <a id="_idIndexMarker307"/>interoperability between .NET languages, allowing developers to use components written in different languages within the same application. This promotes code reusability and simplifies the <span class="No-Break">development process.</span></p>
			<h3>Versioning and assembly management</h3>
			<p>The CLR manages <a id="_idIndexMarker308"/>the versioning of assemblies (compiled <a id="_idIndexMarker309"/>code units), helping to prevent issues such as “DLL hell,” where conflicting versions of shared libraries cause application instability. It also provides features such as side-by-side execution, allowing multiple versions of an assembly to coexist on the <span class="No-Break">same system.</span></p>
			<h3>Reflection</h3>
			<p>The CLR enables<a id="_idIndexMarker310"/> developers to inspect and interact with metadata about types, objects, and assemblies at runtime. This allows dynamic type creation, method invocation, and other advanced <span class="No-Break">programming techniques.</span></p>
			<h3>Debugging and profiling</h3>
			<p>The CLR <a id="_idIndexMarker311"/>provides<a id="_idIndexMarker312"/> integrated support for debugging and profiling .NET applications, enabling developers to diagnose and optimize <span class="No-Break">code efficiently.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor151"/>The DLR building blocks</h2>
			<p>For any of the<a id="_idIndexMarker313"/> dynamic languages to work, the DLR needs to support a few things that are very different from the more static world of the CLR. The following traits <span class="No-Break">are needed.</span></p>
			<h3>Dynamic type system</h3>
			<p>A dynamic<a id="_idIndexMarker314"/> runtime needs to be able to create types on the fly. A type is never static and should be able to be <span class="No-Break">expanded on.</span></p>
			<h3>Dynamic dispatching of methods</h3>
			<p>A dynamic <a id="_idIndexMarker315"/>runtime should allow calling methods that aren’t <span class="No-Break">known beforehand.</span></p>
			<h3>Dynamic code generation</h3>
			<p>A dynamic<a id="_idIndexMarker316"/> runtime should allow for code generation at runtime, allowing you to add code based on input or the result of other code dynamically. It should also allow you to <span class="No-Break">modify code.</span></p>
			<p>From a CLR perspective, these types of traits seem very unaligned. The engineers at Microsoft extended the core functionality and put in place a dynamic runtime that works well with <span class="No-Break">the CLR.</span></p>
			<p>From a metaprogramming perspective, the traits of a dynamic runtime are perfect. As part of the DLR, there is a collection of constructs and APIs that enables you to dynamically create types and also reason about any dynamic type that fulfills the traits we’re <span class="No-Break">looking for.</span></p>
			<p>Since the .NET runtime itself is a static runtime and relies on well-known types with fixed members, the DLR needs to work with this constraint. The DLR, therefore, provides a set of classes and interfaces to represent dynamic objects, their properties, and operations, such as <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, <strong class="source-in ine">DynamicMetaObject</strong>, <strong class="source-in ine">DynamicObject</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-in ine">ExpandoObject</strong></span><span class="No-Break">.</span></p>
			<p>For the DLR to work with dynamic languages, it needs a way to represent the language semantics. The DLR uses expression trees, which we looked at in more detail in <a href="B19418_07.xhtml#_idTextAnchor118"><span class="No-Break"><em class="ita ic">Chapter 7</em></span></a>, <em class="ita ic">Reasoning about Expressions</em>, and <a href="B19418_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="ita ic">Chapter 8</em></span></a>, <em class="ita ic">Building and Executing Expressions</em>. With the DLR comes a set of extensions to LINQ expressions that give us control flow, assignment, and other <span class="No-Break">language-modeling nodes.</span></p>
			<p>From a compiler perspective, the C# compiler has a keyword called <strong class="source-in ine">dynamic</strong> that lets you say that a particular variable or argument is of a dynamic type. That tells the compiler to not evaluate any member accesses during compile time for the instance. Instead, it translates all this into the appropriate <strong class="source-in ine">Expression</strong> that <span class="No-Break">will execute.</span></p>
			<p>To get started with leveraging the DLR and its dynamic capabilities, the easiest way is to use the <strong class="source-in ine">ExpandoObject</strong> type. <strong class="source-in ine">ExpandoObject</strong> provides a type that can be dynamically expanded on; it will hold anything you tell it to and can expand as <span class="No-Break">you proceed:</span></p>
			<pre class="source-code">
dynamic person = new ExpandoObject();
person.FirstName = "Jane";
person.LastName = "Doe";</pre>
			<p>The code<a id="_idIndexMarker317"/> creates an instance of <strong class="source-in ine">ExpandoObject</strong> and then starts setting values on it. <strong class="source-in ine">ExpandoObject</strong> does not have <strong class="source-in ine">FirstName</strong> or <strong class="source-in ine">LastName</strong> as part of its type, but by setting them, the values will <span class="No-Break">be there.</span></p>
			<p>Accessing these members will be the same; the compiler understands that <strong class="source-in ine">ExpandoObject</strong> is <strong class="source-in ine">dynamic</strong> and will try to bind to the members at runtime rather than at compile time. The following code will be <span class="No-Break">completely valid:</span></p>
			<pre class="source-code">
Console.WriteLine($"{person.FirstName} {person.LastName}");</pre>
			<p>The result will be <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
Jane Doe</pre>
			<p><strong class="source-in ine">ExpandoObject</strong> does this by implementing the <strong class="source-in ine">IDynamicMetaObjectProvider</strong> interface. With <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, it provides its own implementation of <strong class="source-in ine">DynamicMetaObject</strong> that really holds all the magic of doing the actual binding of the operations we tell it <span class="No-Break">to do.</span></p>
			<p>The <strong class="source-in ine">ExpandoObject</strong> type also implements the <strong class="source-in ine">IDictionary&lt;string, object?&gt;</strong> interface, which is how it represents all the members given to it and also how it can dynamically grow. Through its implementation of <strong class="source-in ine">DynamicMetaObject</strong>, it basically just works on the internal dictionary. In fact, it is fully possible to work with <strong class="source-in ine">ExpandoObject</strong> as a dictionary if <span class="No-Break">you want:</span></p>
			<pre class="source-code">
var person = new ExpandoObject() as IDictionary&lt;string, object?&gt;;
person["FirstName"] = "Jane";
person["LastName"] = "Doe";</pre>
			<p>If you’re using <strong class="source-in ine">dynamic</strong> for data objects, this can be really handy, as it gives you a simple way <a id="_idIndexMarker318"/>to reason about an object and its content and, at the same time, a convenient programming experience by treating it as a dynamic ob<a id="_idTextAnchor152"/>ject <span class="No-Break">with properties.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor153"/>Call sites and binders</h2>
			<p>Whenever <a id="_idIndexMarker319"/>you want to perform an operation<a id="_idIndexMarker320"/> on a dynamic object – for instance, a<a id="_idIndexMarker321"/> get <a id="_idIndexMarker322"/>or set property or a method call – it goes through something called a <strong class="bo d">call site</strong>. A call site is effectively the location at runtime of the code that will execute. For compiled C#, this will be the memory location where the IL code typically resides. For other languages, such as Ruby or Python, this would be the location in the textual code. Every language has its own call <span class="No-Break">site representation.</span></p>
			<p>The big difference between static languages and dynamic languages is that the static languages are compiled, and at runtime, they’re either executing some sort of intermediate language or actual machine language. Alternatively, a dynamic language will interpret code at runtime and execute the result. The benefit of a dynamic language then is that it can change its own code dynamically, obviously with the downside of a loss <span class="No-Break">in performance.</span></p>
			<p>Once you have the location, or the call site, you can bind to the member and then perform the operation <span class="No-Break">you want.</span></p>
			<p>There are binders for the typical operations you want to perform on an object – the get and set properties, invoke methods, indexing, and so on. Throughout the book, we’ve looked at the power of metadata and how we can reason about the running code; the DLR poses some challenges <span class="No-Break">with this.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor154"/>Reasoning about a dynamic type</h1>
			<p>The DLR is very<a id="_idIndexMarker323"/> limited in <a id="_idIndexMarker324"/>what it is possible to reason about for a dynamic type. Primarily, the DLR is built to be able to host dynamic languages. Naturally with dynamic languages, you don’t really know what’s going on with a dynamic type, and it can change over time, so even though a member is already there, the DLR can’t provide you a reflective experience by giving you any details, such as type information, about <span class="No-Break">the member.</span></p>
			<p>One thing we can do, however, is ask it what members it has. Every dynamic object implements an interface called <strong class="source-in ine">IDynamicMetaObjectProvider</strong>. On this, you can call the <strong class="source-in ine">GetMetaObject()</strong> method to get an object that allows us to interact with the <span class="No-Break">dynamic object.</span></p>
			<p>Let’s look at <strong class="source-in ine">ExpandoObject</strong> with the <span class="No-Break">following properties:</span></p>
			<pre class="source-code">
dynamic person = new ExpandoObject();
person["FirstName"] = "Jane";
person["LastName"] = "Doe";</pre>
			<p>Since <strong class="source-in ine">ExpandoObject</strong> does, in fact, implement <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, we can ask it for its meta-object and then <span class="No-Break">its members:</span></p>
			<pre class="source-code">
var provider = (person as IDynamicMetaObjectProvider)!;
var meta = provider.GetMetaObject(Expression.Constant(person));
var members = string.Join(',', meta.GetDynamicMemberNames());
Console.WriteLine(members);</pre>
			<p>Running this code will give you the <span class="No-Break">following result:</span></p>
			<pre class="source-code">
FirstName,LastName</pre>
			<p>The code itself assumes it is <strong class="source-in ine">IDynamicMetaObjectProvider</strong> by casting it to a type, in order for us to call <strong class="source-in ine">GetMetaObject()</strong>. The <strong class="source-in ine">Expression</strong> we create represents the instance of the person that we’re getting the meta-object for. Then, we call <strong class="source-in ine">GetDynamicMemberNames()</strong>, which returns a collection of strings with all its <span class="No-Break">member names.</span></p>
			<p>This is the extent of what it is possible to <span class="No-Break">reason about.</span></p>
			<p>However, we can dynamically invoke the members, which comes in handy when you don’t know the shape of the object. It can be a bit challenging to invoke when you don’t really know what the object holds, and if you want to support everything, you’ll need fallback mechanisms, as the runtime will throw <strong class="source-in ine">RuntimeBinderException</strong> if it can’t bind the way you <span class="No-Break">want to.</span></p>
			<p><strong class="source-in ine">DynamicMetaObject</strong> has a set of methods with all the binding you can do. These <em class="ita ic">bind</em> methods require an actual binder, which you can get from the call site. After bind, you will get a new <strong class="source-in ine">DynamicMetaObject</strong>. It is possible to use all of these things to get to the actual value, but let’s jump directly to the C# binder, get the binder we want, and use <span class="No-Break">that instead.</span></p>
			<p>In the <strong class="source-in ine">Microsoft.CSharp.RuntimeBinder</strong> namespace, there is a class called <strong class="source-in ine">Binder</strong>. This<a id="_idIndexMarker325"/> class holds a set of <a id="_idIndexMarker326"/>static methods to get specific binders. The types of binders you can use are <span class="No-Break">as follows:</span></p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">BinaryOperation</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used for <span class="No-Break">binary operations</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">Convert</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to convert to a <span class="No-Break">specific type</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">GetIndex</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to get <span class="No-Break">an index</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">GetMember</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to get a <span class="No-Break">member’s value</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">Invoke</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to invoke <span class="No-Break">a method</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">InvokeConstructor</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to invoke/construct <span class="No-Break">a constructor</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">SetIndex</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to set <span class="No-Break">an index</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">SetMember</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to set a member to <span class="No-Break">a value</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-in ine">UnaryOperation</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used for <span class="No-Break">unary operations</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Since the object we have only has properties, we will use the <strong class="source-in ine">GetMember</strong> binder to get the property value and, ultimately, the actual value through the <span class="No-Break">call site:</span></p>
			<pre class="source-code">
foreach (var member in meta.GetDynamicMemberNames())
{
    var binder = Binder.GetMember(
        CSharpBinderFlags.None,
        member,
        person.GetType(),
        new[] {
          CSharpArgumentInfo.Create(CsharpArgumentInfoFlags
          .None, null) });
    var site = CallSite&lt;Func&lt;CallSite, object,
      object&gt;&gt;.Create(binder);
    var propertyValue = site.Target(site, person);
    Console.WriteLine($"{member} = {propertyValue}");
}</pre>
			<p>The code <a id="_idIndexMarker327"/>builds on the <strong class="source-in ine">meta</strong> instance<a id="_idIndexMarker328"/> we got from <strong class="source-in ine">GetMetaObject()</strong> and iterates through the member names returned by <strong class="source-in ine">GetDynamicMemberNames()</strong>. For each member, you can then get the binder for it – in our case, the <strong class="source-in ine">GetMember</strong> binder – passing default values to it with <strong class="source-in ine">member</strong> and the <span class="No-Break"><strong class="source-in ine">person</strong></span><span class="No-Break"> type.</span></p>
			<p>In the <strong class="source-in ine">System.Runtime.CompilerService</strong> namespace, you’ll find a class called <strong class="source-in ine">CallSite&lt;&gt;</strong>. This is a dynamic site type that can be used to create a call site for the binder dynamically. In our case, the dynamic site will be a delegate, <strong class="source-in ine">Func&lt;&gt;</strong>, that allows us to call it with <strong class="source-in ine">person</strong> and get a value back. The types going in and out are both <strong class="source-in ine">object</strong>, since the actual type <span class="No-Break">is unknown.</span></p>
			<p>Running this code should give <span class="No-Break">you this:</span></p>
			<pre class="source-code">
FirstName = Jane
LastName = Doe</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The code assumes that all members are properties, which can fail <span class="No-Break">with </span><span class="No-Break"><strong class="source-in ine">RuntimeBinder</strong></span><strong class="source-in ine">
Exception</strong>. If you need to support more member types, you would need to handle that exception and fall back to the ones you want <span class="No-Break">to support.</span></p>
			<p>Another approach you could use is to use expressions. The <strong class="source-in ine">Expression</strong> class has a <strong class="source-in ine">Dynamic</strong> method that lets you pass in the binder and then create a <strong class="source-in ine">Lambda</strong> expression, which gives you a similar <strong class="source-in ine">Func&lt;&gt;</strong> delegate that can <span class="No-Break">be invoked.</span></p>
			<p>The following gives you a method that can be called to create <strong class="source-in ine">Func&lt;&gt;</strong>, which we can call to get<a id="_idIndexMarker329"/> the <a id="_idIndexMarker330"/>values <span class="No-Break">of members:</span></p>
			<pre class="source-code">
Func&lt;object, object&gt; BuildDynamicGetter(Type type, string propertyName)
{
    var binder = Binder.GetMember(
        CSharpBinderFlags.None,
        propertyName,
        type,
        new[] {
          CSharpArgumentInfo.Create(CsharpArgumentInfoFlags
          .None, null) });
    var rootParameter =
      Expression.Parameter(typeof(object));
    var binderExpression = Expression.Dynamic(binder,
      typeof(object), Expression.Convert(rootParameter,
      type));
    var getterExpression = Expression.Lambda&lt;Func&lt;object,
      object&gt;&gt;(binderExpression, rootParameter);
    return getterExpression.Compile();
}</pre>
			<p>The code gets the <strong class="source-in ine">GetMember</strong> binder and then creates <strong class="source-in ine">DynamicExpression</strong>, which involves a conversion of the instance we will pass to <strong class="source-in ine">object</strong>. Then, the code creates a <strong class="source-in ine">Lambda</strong> expression, which we then compile for more <span class="No-Break">performant execution.</span></p>
			<p>This new method can then be used in the <span class="No-Break">following way:</span></p>
			<pre class="source-code">
var firstNameExpression = BuildDynamicGetter(person.GetType(), "FirstName");
var lastNameExpression = BuildDynamicGetter(person.GetType(), "LastName");
Console.WriteLine($"{firstNameExpression(person)} {lastNameExpression(person)}");</pre>
			<p>The output of this would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Jane Doe</pre>
			<p>Since the<a id="_idIndexMarker331"/> DLR itself is limited in <a id="_idIndexMarker332"/>discoverability and reasoning about what is there, it might be a good idea in some use cases to provide the metadata yourself, using other formats <span class="No-Break">and appro<a id="_idTextAnchor155"/>aches.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor156"/>Creating DynamicObject and providing metadata</h1>
			<p>Sometimes, you <a id="_idIndexMarker333"/>don’t <a id="_idIndexMarker334"/>have the luxury of having your types represented in code. This could be if you’re calling an external API of some sort, be it a REST API, SOAP service, or similar. However, the third party you’re calling might have a representation of the type in a standard format, such as a WSDL or <span class="No-Break">JSON schema.</span></p>
			<p>Even though dynamic objects can be very flexible, in the real world the shape of data tends to be stricter. So, instead of using <strong class="source-in ine">ExpandoObject</strong> for everything, you could represent these types with a custom dynamic object that gets its metadata from a well-known format. It’s very common today to use JSON as a data carrier, and it’s also common to represent the shape of data by leveraging JSON schemas. Let’s look at how that could be a provider <span class="No-Break">of me<a id="_idTextAnchor157"/>tadata.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor158"/>Building a JSON schema type</h2>
			<p>Start by creating<a id="_idIndexMarker335"/> a folder called <strong class="source-in ine">Chapter9</strong>. Change into this folder in your command-line interface and create a new <span class="No-Break">console project:</span></p>
			<pre class="source-code">
dotnet new console</pre>
			<p>We will rely on a third-party library, giving us an easy way of working with JSON schemas. Add the package to the project by running <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add package NJsonSchema</pre>
			<p>A JSON schema is a simple structure that describes a type, its properties, and the type of every property. It is, however, limited to the types available <span class="No-Break">to JSON:</span></p>
			<ul>
				<li><span class="No-Break">String</span></li>
				<li><span class="No-Break">Number</span></li>
				<li><span class="No-Break">Boolean</span></li>
				<li><span class="No-Break">Array</span></li>
				<li><span class="No-Break">Object</span></li>
			</ul>
			<p>However, a JSON schema does support a concept of <em class="ita ic">format</em> that can be used as a sub-type for types. For instance, dates are not part of the JSON type system, but having a property of type <strong class="source-in ine">string</strong> and a format of type <strong class="source-in ine">date</strong> would allow you to support any type you want, since strings can <span class="No-Break">hold anything.</span></p>
			<p>JSON schemas can also hold sub-schemas, which makes it possible to have strongly typed object definitions within <span class="No-Break">an object.</span></p>
			<p>For this sample, we’re going to keep it very simple and stick with <span class="No-Break">simple types.</span></p>
			<p>Add a file called <strong class="source-in ine">person.json</strong> to your project and add the following <span class="No-Break">to it:</span></p>
			<pre class="source-code">
{
  „$schema": „http://json-schema.org/draft-04/schema#",
  "title": "Person",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "FirstName": {
      "type": "string"
    },
    "LastName": {
      "type": "string"
    },
    "Birthdate": {
      "type": "string",
      "format": "date"
    }
  }
}</pre>
			<p>In the JSON, you’ll find the <strong class="source-in ine">title</strong> property, which is the name of the type, and the <strong class="source-in ine">type</strong> property is set to <strong class="source-in ine">object</strong>, since it describes an object. The schema then contains three properties<a id="_idIndexMarker336"/> with the <span class="No-Break">following types:</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bo d">Property</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bo d">Type</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">FirstName</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">String</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">LastName</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">String</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Birthdate</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Date</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – A schema for a person</p>
			<p>Add a file called <strong class="source-in ine">JsonSchemaType.cs</strong>, and add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
using System.Dynamic;
using NJsonSchema;
namespace Chapter9;
public class JsonSchemaType : DynamicObject
{
    readonly IDictionary&lt;string, object?&gt; _values = new
      Dictionary&lt;string, object?&gt;();
    readonly JsonSchema _schema;
    public JsonSchemaType(JsonSchema schema)
    {
        _schema = schema;
    }</pre>
			<p>The code creates a new type called <strong class="source-in ine">JsonSchemaType</strong> that inherits from the <strong class="source-in ine">DynamicObject</strong> type found in the <strong class="source-in ine">System.Dynamic</strong> namespace. This particular type is a helper type, created to make it easier to implement dynamic objects. To represent the actual content of the type, the code adds <strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong>. This gives you the flexibility of putting anything into it, much like <strong class="source-in ine">ExpandoObject</strong> does. The reason for <strong class="source-in ine">object?</strong> as the value type is to allow anything and also make it<a id="_idIndexMarker337"/> explicit that we allow null values in it. The constructor takes a <strong class="source-in ine">JsonSchema</strong> type from the <strong class="source-in ine">NJsonSchema</strong> dependency you <span class="No-Break">added earlier.</span></p>
			<h3>Validating properties</h3>
			<p>Since JSON <a id="_idIndexMarker338"/>schemas give you a full description of a type, its properties, and the types for the properties, it gives you an opportunity to validate the values being set on <span class="No-Break">the object.</span></p>
			<p>Let’s introduce some basic validation into the object. Start by adding a new file that will give us an explicit exception describing the problem that can occur. Add a file called <strong class="source-in ine">InvalidTypeForProperty.cs</strong>, and add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
public class InvalidTypeForProperty : Exception
{
    public InvalidTypeForProperty(string type, string
      property) : base($"Property '{property}' on '{type}'
      is invalid.")
    {
    }
}</pre>
			<p>The custom exception takes two properties – the name of the type that owns the errored property and then the actual property that was wrong. You could also include for good measure the type it was trying to set and what was expected, but to keep the sample simple, let’s just go <span class="No-Break">with this.</span></p>
			<p>To do the actual validation, you’ll need something that translates from the .NET type to <strong class="source-in ine">JsonObjectType</strong>. Go back to the <strong class="source-in ine">JsonSchemaType.cs</strong> file and add a method that does the necessary translations from the .NET type to a <strong class="source-in ine">JsonObjectType</strong>. Add the following <a id="_idIndexMarker339"/>method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
JsonObjectType GetSchemaTypeFrom(Type type)
{
    return type switch
    {
        Type _ when type == typeof(string) =&gt;
          JsonObjectType.String,
        Type _ when type == typeof(DateOnly) =&gt;
          JsonObjectType.String,
        Type _ when type == typeof(int) =&gt;
          JsonObjectType.Integer,
        Type _ when type == typeof(float) =&gt;
          JsonObjectType.Number,
        Type _ when type == typeof(double) =&gt;
          JsonObjectType.Number,
        _ =&gt; JsonObjectType.Object
    };
}</pre>
			<p>The code uses a simple pattern matching and converts from the .NET type to <strong class="source-in ine">JsonObjectType</strong>. It defaults to <strong class="source-in ine">JsonObjectType.Object</strong> for anything it doesn’t have an explicit <span class="No-Break">conversion for.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">This implementation is very simplistic and does not cover all the .NET types, and you should probably make it a bit more sophisticated for production. Hopefully, though, it gives you a <span class="No-Break">general idea.</span></p>
			<p>Now that you<a id="_idIndexMarker340"/> have a way of converting from a CLR type to <strong class="source-in ine">JsonObjectType</strong>, you need a way to actually do the validation. Add the following method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
void ValidateType(string property, object? value)
{
    if (value is not null)
    {
        var schemaType = GetSchemaTypeFrom(
          value.GetType());
        if (!_schema.ActualProperties[property]
          .Type.HasFlag(schemaType))
        {
            throw new InvalidTypeForProperty(_schema.Title,
              property);
        }
    }
}</pre>
			<p>The code only validates a value if it is not null, since you wouldn’t be able to know its type unless it has a value. With the type, it gets the actual schema type and then checks whether or not the property has this type. <strong class="source-in ine">JsonObjectType</strong> is an enum of flags, and combinations are allowed, which is why you have to use the <strong class="source-in ine">HasFlag</strong> method. If it’s not the correct <a id="_idIndexMarker341"/>type, the code throws the <span class="No-Break"><strong class="source-in ine">InvalidTypeForProperty</strong></span><span class="No-Break"> exception.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">A tip here would be to also validate whether null is allowed or not. This information is also supported by JSON schemas. Some types also inherently don’t allow nulls, such as integers or Booleans, and you should probably not <span class="No-Break">allow that.</span></p>
			<h3>Implementing getting and setting properties</h3>
			<p>With the<a id="_idIndexMarker342"/> constructor and validation in place, you’re now ready to override some of the default behavior of the <strong class="source-in ine">DynamicObject</strong> type. The <strong class="source-in ine">DynamicObject</strong> type offers a set of virtual methods that can be overridden for the different operations that can be performed, such as getting or setting properties and <span class="No-Break">invoking methods.</span></p>
			<p>In this sample, we will focus primarily on properties. Add the following method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public override bool TrySetMember(SetMemberBinder binder, object? value)
{
    if (!_schema.ActualProperties.ContainsKey(binder.Name))
    {
        return false;
    }
    ValidateType(binder.Name, value);
    _values[binder.Name] = value;
    return true;
}</pre>
			<p>The <strong class="source-in ine">TrySetMember</strong> signature takes <strong class="source-in ine">SetMemberBinder</strong>, which holds the information about the property being set. It also gets the value, which can be null. The code then first validates whether or not the property actually exists in the schema by looking into the <strong class="source-in ine">ActualProperties</strong> dictionary. If it does not exist, it immediately returns <strong class="source-in ine">false</strong>, and if you were to try to set an unknown property, you would then get <strong class="source-in ine">RuntimeBinderException</strong>. When the property exists, the code validates the type of the value. If the type is correct, the code then sets the value in its <span class="No-Break">private dictionary.</span></p>
			<p>Once you have set a<a id="_idIndexMarker343"/> property, you also want to read it. Add the following method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public override bool TryGetMember(GetMemberBinder binder, out object? result)
{
    if (!_schema.ActualProperties.ContainsKey(binder.Name))
    {
        result = null!;
        return false;
    }
    result = _values.ContainsKey(binder.Name)
        ? result = _values[binder.Name] : result = null!;
    return true;
}</pre>
			<p>Similar to the <strong class="source-in ine">TrySetMember</strong>, the code adds a check on whether or not the schema has the property. However, since this<a id="_idIndexMarker344"/> is a <strong class="bo d">get</strong> operation and the signature of the method dictates that the result should be given as an <strong class="source-in ine">out</strong> parameter, we need to explicitly set it to <strong class="source-in ine">null!</strong>. The code then checks whether the private dictionary contains a value for the property and returns it if it does or returns a <strong class="source-in ine">null!</strong> value <span class="No-Break">if not.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In a production system, you would typically not want to return just <strong class="source-in ine">null</strong> if the value is not set. It should be set to either the default value of the type or, if the JSON schema holds additional metadata with a default value, you should <span class="No-Break">use that.</span></p>
			<p>As a <em class="ita ic">nice-to-have</em> feature, we want to allow this type to be converted to another type – in our case, <span class="No-Break"><strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong></span><span class="No-Break">.</span></p>
			<p>One of the methods that <strong class="source-in ine">DynamicObject</strong> provides that can be overridden is the <strong class="source-in ine">TryConvert</strong> method. This method will be called if an explicit cast is done from the type to a different<a id="_idIndexMarker345"/> target type. Add the following method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public override bool TryConvert(ConvertBinder binder, out object? result)
{
    if (binder.Type.Equals(typeof(Dictionary&lt;string,
      object?&gt;)))
    {
        var returnValue = new Dictionary&lt;string,
          object?&gt;(_values);
        var missingProperties =
          _schema.ActualProperties.Where(_ =&gt;
          !_values.Any(kvp =&gt; _.Key == kvp.Key));
        foreach (var property in missingProperties)
        {
            object defaultValue = property.Value.Type
              switch
            {
                JsonObjectType.Array =&gt;
                  Enumerable.Empty&lt;object&gt;(),
                JsonObjectType.Boolean =&gt; false,
                JsonObjectType.Integer =&gt; 0,
                JsonObjectType.Number =&gt; 0,
                _ =&gt; null!
            };
            returnValue[property.Key] = defaultValue;
        }
        result = returnValue;
        return true;
    }
    return base.TryConvert(binder, out result);
}</pre>
			<p>The code only allows conversion to <strong class="source-in ine">Dictionary&lt;string, object?&gt;</strong>, so it checks for this first by looking at the <strong class="source-in ine">Type</strong> property of the <strong class="source-in ine">ConvertBinder</strong> type being passed in. It is a good practice to return values for all properties in the schema and not leave out any properties, and since all properties might be set, the code creates a new dictionary from the existing <strong class="source-in ine">_values</strong> dictionary and then finds any properties that are missing. For <a id="_idIndexMarker346"/>every property that is missing, it sets a <span class="No-Break">default value.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The default values have been simplified. As mentioned earlier, for production you should consider a more sophisticated approach to default values and look at possible additional metadata in the <span class="No-Break">JSON schema.</span></p>
			<p>The last piece of the puzzle we want to add is the ability for outsiders to reason about what members are available. The <strong class="source-in ine">DynamicObject</strong> type gives us a method that can be overridden for this. Add the following method to the <span class="No-Break"><strong class="source-in ine">JsonSchemaType</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public override IEnumerable&lt;string&gt; GetDynamicMemberNames() =&gt; _schema.ActualProperties.Keys;</pre>
			<p>This method will be called by <strong class="source-in ine">DynamicMetaObject</strong> that <strong class="source-in ine">DynamicObject</strong> produces. <strong class="source-in ine">DynamicObject</strong> is also <strong class="source-in ine">IDynamicMetaObjectProvider</strong> and implements the <span class="No-Break"><strong class="source-in ine">GetMetaObject()</strong></span><span class="No-Break"> method.</span></p>
			<p><strong class="source-in ine">DynamicObject</strong> has more methods that can be overridden to invoke methods, perform binary<a id="_idIndexMarker347"/> operations, and so on. However, for this sample, we will focus on the data aspects <span class="No-Break">with properties.</span></p>
			<h3>Using the schema infrastructure</h3>
			<p>What you’ve<a id="_idIndexMarker348"/> built so far is an infrastructure to work with JSON schemas, together with the DLR. Let’s take <strong class="source-in ine">JsonSchemaType</strong> out for a spin. Open the <strong class="source-in ine">Program.cs</strong> file and take out all its content. Add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using NJsonSchema;
using Chapter9;
var schema = await JsonSchema.FromFileAsync("person.json");
dynamic personInstance = new JsonSchemaType(schema);
var personMetaObject = personInstance.GetMetaObject(Expression.Constant(personInstance));
var personProperties = personMetaObject.GetDynamicMemberNames();
Console.WriteLine(string.Join(',', personProperties));</pre>
			<p>The code reads the JSON schema from the <strong class="source-in ine">person.json</strong> file you created earlier. Then, it creates an instance of <strong class="source-in ine">JsonSchemaType</strong> and hands it the schema. Since <strong class="source-in ine">JsonSchemaType</strong> is a dynamic object, it implements <strong class="source-in ine">IDynamicMetaObjectProvider</strong>, and we can call the <strong class="source-in ine">GetMetaObject()</strong> method with the instance of the object and then get <span class="No-Break">its members.</span></p>
			<p>When run, the code should produce <span class="No-Break">the following:</span></p>
			<pre class="source-code">
FirstName,LastName</pre>
			<p>Setting and getting properties should work <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
personInstance.FirstName = "Jane";
Console.WriteLine($"FirstName : '{personInstance.FirstName}'");</pre>
			<p>Running the code should give you the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
FirstName : 'Jane'</pre>
			<p>Since the implementation of <strong class="source-in ine">JsonSchemaType</strong> supports default values for properties that have not been set, you can get a valid property without <span class="No-Break">any problems:</span></p>
			<pre class="source-code">
Console.WriteLine($"LastName : '{personInstance.LastName}'");</pre>
			<p>The result of this should be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
LastName : ''</pre>
			<p>Converting this <a id="_idIndexMarker349"/>property to a dictionary should also work out of the box through an <span class="No-Break">explicit cast:</span></p>
			<pre class="source-code">
var dictionary = (Dictionary&lt;string, object&gt;)personInstance;
Console.WriteLine(JsonSerializer.Serialize(dictionary));</pre>
			<p>The result of this should be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{"FirstName":"Jane","LastName":null}</pre>
			<p>To test the validation, you can try to set the <strong class="source-in ine">LastName</strong> property to an <span class="No-Break">unsupported type:</span></p>
			<pre class="source-code">
personInstance.LastName = 42;</pre>
			<p>The result of this should be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Unhandled exception. Chapter9.InvalidTypeForProperty: Property 'LastName' on 'Person' is invalid.</pre>
			<p>The last thing we can do to verify that all is working as expected is to set a property that does not exist in <span class="No-Break">the schema:</span></p>
			<pre class="source-code">
personInstance.FullName = "Jane Doe";</pre>
			<p>This should produce the <span class="No-Break">following result:</span></p>
			<pre class="source-code">
Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: 'Chapter9.JsonSchemaType' does not contain a definition for 'FullName'</pre>
			<p>Working with the <strong class="source-in ine">DynamicObject</strong> helper type eases the development of dynamic objects, as you don’t have to worry about the complexity of the moving parts and can focus on the<a id="_idIndexMarker350"/> actual shape and capabilities of the dynamic object you wan<a id="_idTextAnchor159"/>t <span class="No-Break">to provide.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor160"/>Summary</h1>
			<p>This chapter explored the dynamic realm of the .NET runtime and how you can take advantage of it to create dynamic types that have its types defined outside of C# code. When working with third parties through APIs, this approach can be very handy. If you look at REST APIs and the OpenAPI standard, you’ll see extensive use of JSON schemas, and marrying the approach in this chapter with such standards can provide you a powerful mechanism to dynamically integrate with third parties, and at the same time, you can be strict about <span class="No-Break">the shape.</span></p>
			<p>The DLR can be a powerful tool in your toolbox. It provides another approach to dynamically create types and code. Compared to generating intermediate language code, it can come across as <span class="No-Break">more intuitive.</span></p>
			<p>One of the downsides of the DLR is that the types generated can be hard to work with in a modern IDE or code editor, as it does not know about the types and can’t offer services such as IntelliSense <span class="No-Break">for members.</span></p>
			<p>Another aspect of using the DLR and a dynamic approach can be performance. It will not be as performant as generating intermediate language code. This is one of the trade-offs you will have to make, but for specific scenarios, that might not be an issue <span class="No-Break">at all.</span></p>
			<p>In the next chapter, we will shift gears a little bit and look at how we can take advantage of some of the techniques we’ve discussed so far in the book and start thinking in terms of <strong class="bo d">convention </strong><span class="No-Break"><strong class="bo d">over configuration</strong></span><span class="No-Break">.</span></p>
		</div>
	

		<div id="_idContainer031" class="Content">
			<h1 id="_idParaDest-110"><a id="_idTextAnchor161"/>Part 3:Increasing Productivity, Consistency, and Quality</h1>
			<p>In this part, you will see how metaprogramming can be used to improve code quality and leave you with a more maintainable and consistent code base. At the same time, this part gives you ideas on how techniques can improve the productivity of you and your developers. The different chapters touch on principles and software design patterns and how they can be used in <span class="No-Break">real life.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19418_10.xhtml#_idTextAnchor162"><em class="ita ic">Chapter 10</em></a>, <em class="ita ic">Convention over Configuration</em></li>
				<li><a href="B19418_11.xhtml#_idTextAnchor177"><em class="ita ic">Chapter 11</em></a>, <em class="ita ic">Applying the Open-Closed Principle</em></li>
				<li><a href="B19418_12.xhtml#_idTextAnchor196"><em class="ita ic">Chapter 12</em></a>, <em class="ita ic">Go Beyond Inheritance</em></li>
				<li><a href="B19418_13.xhtml#_idTextAnchor206"><em class="ita ic">Chapter 13</em></a>, <em class="ita ic">Applying Cross-Cutting Concerns</em></li>
				<li><a href="B19418_14.xhtml#_idTextAnchor219"><em class="ita ic">Chapter 14</em></a>, <em class="ita ic">Aspect-Oriented Programming</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer032" class="IMG---Figure">
			</div>
		</div>
		<div>
			<div id="_idContainer033" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer034">
			</div>
		</div>
	</body></html>