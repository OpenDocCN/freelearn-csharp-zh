- en: Chapter 10. Parallel LINQ – PLINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。并行 LINQ – PLINQ
- en: In this chapter, we will learn about declarative data parallelism using **Parallel
    Language Integrated Query** (**PLINQ**). In [Chapter 7](ch07.html "Chapter 7. Data
    Parallelism"), *Data Parallelism*, we discussed data parallelism using the `Parallel`
    library and the `Parallel.For` and `Parallel.ForEach` loops. PLINQ is a parallel
    version of LINQ to Objects. **LINQ to Objects** allows for LINQ queries on in-memory
    data collections such as `List` and `DataTable` that implement the `IEnumerable`
    or `IEnumerable<T>` interface. Unlike a sequential LINQ, PLINQ tries to use all
    of the processors in the computer it is running on by dividing the data collections
    into segments and creating a task to process each segment of the data collection.
    PLINQ and the **Common Language Runtime** (**CLR**) are smart enough to evaluate
    the query and determine if it will benefit from a multithreaded execution. If
    not, then it will run sequentially like a normal LINQ. It is the best of both
    worlds. .NET figures out whether it can gain performance improvements by operating
    concurrently or not and makes the decision for you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用 **Parallel Language Integrated Query**（**PLINQ**）进行声明式数据并行。在 [第
    7 章](ch07.html "第 7 章。数据并行") *数据并行* 中，我们讨论了使用 `Parallel` 库和 `Parallel.For` 以及
    `Parallel.ForEach` 循环进行数据并行。PLINQ 是 LINQ to Objects 的并行版本。**LINQ to Objects**
    允许对实现 `IEnumerable` 或 `IEnumerable<T>` 接口的内存中数据集合（如 `List` 和 `DataTable`）进行 LINQ
    查询。与顺序 LINQ 不同，PLINQ 尝试通过将数据集合划分为段并创建处理每个数据段的任务来使用运行在其上的计算机上的所有处理器。PLINQ 和 **Common
    Language Runtime**（**CLR**）足够智能，可以评估查询并确定它是否会从多线程执行中受益。如果不，则它将像正常的 LINQ 一样顺序执行。这是两者的最佳结合。.NET
    通过并发操作来确定是否可以获得性能改进，并为您做出决定。
- en: The parallel extension methods were added to the `System.Linq` namespace in
    .NET 4.5\. It includes extension methods for all standard LINQ operators as well
    as some extra ones for parallel operators. Almost all of the PLINQ methods are
    implemented in the `System.Linq.ParallelEnumerable` namespace.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 4.5 中，并行扩展方法被添加到了 `System.Linq` 命名空间。它包括所有标准 LINQ 操作的扩展方法，以及一些额外的并行操作扩展方法。几乎所有
    PLINQ 方法都是在 `System.Linq.ParallelEnumerable` 命名空间中实现的。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Executing a PLINQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 PLINQ
- en: Ordering in PLINQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ 中的排序
- en: Merging in PLINQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ 中的合并
- en: Canceling a PLINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消 PLINQ
- en: Understanding performance improvements in PLINQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 PLINQ 的性能改进
- en: Executing a PLINQ
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 PLINQ
- en: Now, let's take a look at a basic PLINQ and syntax. We will use three different
    methods to perform the PLINQ and then examine the results. The first will use
    the `ForAll` method of the `ParallelQuery` class. The next one will use the `AsParallel`
    method of the LINQ library on the `Enumerable` collection. The final way will
    use the standard LINQ method syntax.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个基本的 PLINQ 和语法。我们将使用三种不同的方法来执行 PLINQ 并检查结果。第一种方法将使用 `ParallelQuery`
    类的 `ForAll` 方法。下一种方法将使用 LINQ 库中的 `AsParallel` 方法对 `Enumerable` 集合进行操作。最后一种方法将使用标准的
    LINQ 方法语法。
- en: We will then display the results of the three queries in three listboxes and
    also display the time it took to execute each query.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将显示三个查询的结果，并在三个列表框中显示，同时显示每个查询的执行时间。
- en: How to do it
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s start by opening up Visual Studio and creating a new WPF application
    project named `WpfPLINQQuery`. Once this project is open, let''s perform the following
    steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开 Visual Studio 并创建一个名为 `WpfPLINQQuery` 的新 WPF 应用程序项目开始。一旦该项目打开，让我们执行以下步骤：
- en: In the `MainWindow.xaml` file in design mode add three button controls and name
    them `btnMethod1`, `btnMethod2`, and `btnMethod3`. Set the `Content` property
    of each to `Execute Method 1`, `Execute Method 2`, and `Execute Method 3,` respectively.
    Next, create a click event handler for each in the `MainWindow.xaml.cs` file and
    name these three methods `btnMethod1_Click`, `btnMethod2_Click`, and `btnMethod3_Click,`
    respectively.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计模式下打开 `MainWindow.xaml` 文件，添加三个按钮控件，并分别命名为 `btnMethod1`、`btnMethod2` 和 `btnMethod3`。将每个按钮的
    `Content` 属性分别设置为 `执行方法 1`、`执行方法 2` 和 `执行方法 3`。接下来，在 `MainWindow.xaml.cs` 文件中为每个按钮创建一个点击事件处理程序，并分别命名为
    `btnMethod1_Click`、`btnMethod2_Click` 和 `btnMethod3_Click`。
- en: 'In the `btnMethod1_Click` event handler method, place the following code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `btnMethod1_Click` 事件处理程序方法中，放置以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `btnMethod2_Click` event handler method, place the following code:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `btnMethod2_Click` 事件处理程序方法中，放置以下代码：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `btnMethod3_Click` event handler method, place the following code. Also,
    let's add three listboxes and name them `lb1`, `lb2`, and `lb3`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`btnMethod3_Click`事件处理方法中，放置以下代码。同时，让我们添加三个列表框，并分别命名为`lb1`、`lb2`和`lb3`。
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then add three textboxes and name them `tbTime1`, `tbTime2`, and `tbTime3`.
    Also, clear their `Text` properties.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加三个文本框，并分别命名为`tbTime1`、`tbTime2`和`tbTime3`。同时，清除它们的`Text`属性。
- en: 'In the `MainWindow.xaml.cs` file, we will need to add a `using` statement so
    that the `Stopwatch` class is available to us. So, add the following statement
    at the top of the file with the rest of the `using` statements:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml.cs`文件中，我们需要添加一个`using`语句，以便`Stopwatch`类对我们可用。因此，在文件顶部添加以下语句，与其他`using`语句一起：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we need to add an empty method to serve as our delegate for the lambda
    expression. We will call it `DoWork`. Add it to the bottom of the `MainWindow`
    class with the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一个空方法作为lambda表达式的委托。我们将称之为`DoWork`。将其添加到`MainWindow`类的底部，以下代码：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That is all the code we need to add to our `MainWindow.xaml.cs` file. Our `MainWindow.xaml`
    file should now contain the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就是我们需要添加到`MainWindow.xaml.cs`文件中的所有代码。现在，我们的`MainWindow.xaml`文件应该包含以下代码：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now our project is completed. Let''s build and run the project. The program
    should look like this when it runs:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已经完成。让我们构建并运行项目。程序运行时应该看起来像这样：
- en: '![How to do it](img/8321EN_10_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_01.jpg)'
- en: 'Now, let''s click on the **Execute Method 1** button. We should see results
    like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们点击**执行方法1**按钮。我们应该看到以下结果：
- en: '![How to do it](img/8321EN_10_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_02.jpg)'
- en: 'Now, let''s click on the next two buttons, **Execute Method 2** and **Execute
    Method 3** and see what the program looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们点击下一个两个按钮，**执行方法2**和**执行方法3**，看看程序看起来像什么：
- en: '![How to do it](img/8321EN_10_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_03.jpg)'
- en: As you can see, we executed the PLINQ parallel query using three different methods
    and the results are different each time. The first thing you'll notice if you
    scroll through the results is that the numbers in the listbox are not ordered.
    The next thing you will notice is that the runtime of each is not exactly the
    same. Granted, the first one will take longer to display because we divide by
    5 instead of 10, so there are more results. But the query itself should take roughly
    the same time. You can play with this by moving the command to stop the `Stopwatch`
    object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了三种不同的方法执行了PLINQ并行查询，每次的结果都不同。如果您浏览结果，首先会注意到列表框中的数字没有排序。接下来您会注意到，每个查询的运行时间并不完全相同。当然，第一个查询将需要更长的时间来显示，因为我们除以5而不是10，所以结果更多。但查询本身应该花费大致相同的时间。您可以通过移动停止`Stopwatch`对象的命令来尝试这个操作。
- en: Now let's examine how this works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来分析这是如何工作的。
- en: How it works
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In this project, we performed a PLINQ parallel query using three different
    methods. In the first one, we defined a `ParallelQuery` object using this line
    of code, but didn''t execute it yet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用了三种不同的方法执行了PLINQ并行查询。在第一种方法中，我们使用此行代码定义了一个`ParallelQuery`对象，但尚未执行：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We add the `AsParallel` method to the `IEnumerable` collection with the following
    command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令将`AsParallel`方法添加到`IEnumerable`集合中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells .NET to try and execute this query concurrently if it determines
    that it will improve performance. We can force .NET to operate this query concurrently
    using the parallel extension method `WithExecutionMode(ParallelExecutionMode.ForceParallelism)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉.NET尝试并发执行此查询，如果它确定这将提高性能。我们可以使用并行扩展方法`WithExecutionMode(ParallelExecutionMode.ForceParallelism)`强制.NET并发执行此查询。
- en: 'Then we actually ran the query using the `ForAll` method of the `ParallelQuery`
    class. We did this using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实际上使用了`ParallelQuery`类的`ForAll`方法来执行查询。我们使用以下命令来完成：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use this command, we need to pass it a lambda expression. We are just using
    a lambda expression that passes a delegate to a method that does nothing. We do
    not need to do work in the delegate method because we are doing all of the work
    in the parallel query.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此命令，我们需要传递一个lambda表达式。我们只是使用一个lambda表达式，它传递一个委托到执行无操作的方法。我们不需要在委托方法中执行工作，因为我们已经在并行查询中完成了所有工作。
- en: 'In the second method, we create a parallel query that executes when the command
    is processed and returns an array. This command is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，我们创建了一个并行查询，它在命令处理时执行并返回一个数组。此命令如下：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that here we have added the `ToArray()` method to the results of the
    query. By implementing the parallel query this way we ensure that the query is
    executing during this command. In the first method, we create the query but do
    not execute it until the `ForAll` command is executed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里已经将 `ToArray()` 方法添加到了查询的结果中。通过这种方式实现并行查询，我们确保查询在执行此命令期间正在执行。在第一个方法中，我们创建了查询，但直到
    `ForAll` 命令执行之前不会执行它。
- en: 'In the final method, we use the LINQ method syntax. Here is the statement that
    performs the query using this syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的方法中，我们使用 LINQ 方法语法。以下是使用此语法执行查询的语句：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we return a `ParallelQuery` object instead of an array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回一个 `ParallelQuery` 对象而不是数组。
- en: Also, notice that in all three methods the results are not returned in order.
    We will see later in the chapter how to ensure the order of the results if that
    is necessary. For now, we are just trying to run a parallel query. We will let
    .NET determine how to run the query (concurrently or sequentially), and in whatever
    order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在这三种方法中，结果都不是按顺序返回的。我们将在本章后面看到如何确保结果的顺序，如果这是必要的。现在，我们只是在尝试运行一个并行查询。我们将让
    .NET 决定如何运行查询（并发或顺序），以及以何种顺序。
- en: Ordering in PLINQ
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PLINQ 中的排序
- en: Now, what if the order of our results matters? In a lot of cases, we will want
    the results to come back in a certain order. Let's examine how we can accomplish
    this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的结果顺序很重要呢？在许多情况下，我们希望结果以特定的顺序返回。让我们看看我们如何实现这一点。
- en: There are several methods contained in the parallel extension methods of the
    `IEnumerable` interface. The two we use the most are `AsOrdered()` and `AsOrderedBy()`.
    These two methods guarantee order preservation in the results of the parallel
    query. This does add some cost and overhead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable` 接口的并行扩展方法中包含了几种方法。我们使用最多的两种方法是 `AsOrdered()` 和 `AsOrderedBy()`。这两种方法保证了并行查询结果中的顺序保持。这确实会增加一些成本和开销。'
- en: Let's take our project from the last section and update it to return the ordered
    results.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的项目从上一节更新到返回有序结果。
- en: How to do it
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s open up our `PLINQQuery` project and make the following changes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的 `PLINQQuery` 项目并做出以下更改：
- en: 'Change the parallel query statement in the `btnMethod1_Click` method to look
    like the following by adding the `AsOrdered` method to the query:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `btnMethod1_Click` 方法中的并行查询语句修改如下，通过向查询中添加 `AsOrdered` 方法：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, make a similar change to the statement in the `btnMethod2_Click` method.
    Make its parallel query statement look like the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `btnMethod2_Click` 方法中的语句进行类似的修改。使其并行查询语句看起来如下：
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s make a similar change to the `btn3Method_Click` method and
    its query statement:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们对 `btn3Method_Click` 方法及其查询语句进行类似的修改：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That is all of the changes; seems simple enough. Now, let''s build and run
    our application. You should get a program that looks like the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有的更改；看起来很简单。现在，让我们构建并运行我们的应用程序。你应该得到一个看起来像以下截图的程序。
- en: '![How to do it](img/8321EN_10_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_04.jpg)'
- en: 'Now, let''s click on each of the three buttons to run all the three queries.
    Your program should now look like the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们点击这三个按钮中的每一个来运行所有三个查询。你的程序现在应该看起来像以下截图：
- en: '![How to do it](img/8321EN_10_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_05.jpg)'
- en: As you can see, the results are now ordered. This is a simple example; however,
    in a more complex example, you will also see that the runtimes are longer. As
    you would expect, ordering the results will slow down the query processing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果现在是排序的。这是一个简单的例子；然而，在一个更复杂的例子中，你也会看到运行时间更长。正如你所预期的，排序结果会减慢查询处理速度。
- en: Also, did you notice that if you execute the queries in the application in a
    different order you will see that typically the first one takes longer than the
    last one? There are two explanations for why the last one to run is usually faster.
    .NET has run the query, so it has also taken time to determine the best execution
    method. Also, if it chooses to run the query concurrently, it has already taken
    the overhead of creating the tasks in the threadpool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你是否注意到，如果你以不同的顺序在应用程序中执行查询，你通常会看到第一个查询比最后一个查询耗时更长？最后一个运行的查询通常更快有两个解释。.NET
    已经运行了查询，因此它也花费了一些时间来确定最佳执行方法。此外，如果它选择并发运行查询，它已经承担了在线程池中创建任务的开销。
- en: How it works
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The change from the first project to this one is a simple one. We just added
    the `AsOrdered()` method to the parallel extension method, `AsParallel()`, that
    we execute against the `IEnumerable` collection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个项目到这个项目的更改很简单。我们只是将 `AsOrdered()` 方法添加到了我们针对 `IEnumerable` 集合执行的并行扩展方法 `AsParallel()`
    中。
- en: 'This forces .NET to order the results. We can also order the results with the
    `OrderBy` query syntax. It should be noted that `OrderBy` is done sequentially,
    not in parallel. The following screenshot explains items in the query itself that
    will order the results:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使 .NET 对结果进行排序。我们还可以使用 `OrderBy` 查询语法对结果进行排序。需要注意的是，`OrderBy` 是顺序执行的，而不是并行执行的。以下截图解释了查询本身中的项目，这些项目将排序结果：
- en: '![How it works](img/8321EN_10_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的](img/8321EN_10_06.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd460677(v=vs.110).aspx
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/dd460677(v=vs.110).aspx
- en: Merging in PLINQ
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PLINQ 中的合并
- en: We have learned how to perform a parallel query and how to order the results.
    Now, let's examine merging with our parallel queries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何执行并行查询以及如何排序结果。现在，让我们检查我们的并行查询中的合并。
- en: When a parallel query is performed, the .NET CLR partitions the source collection
    so that several tasks can work sections of the collection concurrently. Once this
    is completed, the results need to be merged into a result collection for processing.
    Depending on the query operators used, the results can be merged in different
    ways. Query operators that dictate a new order on the result collection will buffer
    all items from the separate threads before merging them together again. Other
    query operators are partially buffered, while the query operator, `ForAll<TSource>`,
    is not buffered. It produces all items from all tasks as soon as they are processed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行并行查询时，.NET CLR 将源集合分区，以便多个任务可以并发地处理集合的各个部分。一旦完成，结果需要合并到一个结果集合中进行处理。根据使用的查询运算符，结果可以以不同的方式合并。指示结果集合新顺序的查询运算符将在合并之前缓冲来自各个线程的所有项目。其他查询运算符是部分缓冲的，而
    `ForAll<TSource>` 查询运算符则不缓冲。它一旦处理完所有任务的所有项目，就会立即生成所有项目。
- en: The `WithMergeOptions<TSource>` method can tell PLINQ how to perform the merging
    process of a concurrent query.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithMergeOptions<TSource>` 方法可以告诉 PLINQ 如何执行并发查询的合并过程。'
- en: If a query cannot perform the merge option specified, .NET will ignore it. So,
    you can see that .NET treats merge options as suggestions and will not throw an
    error if the merge option is not compatible; it will just ignore it. Likewise,
    if you do not specify a merge option, .NET will select one for you. So, you can
    use a merge option if you have determined that a specific merge is best for your
    performance or just let .NET decide for you. This is one of the beautiful things
    of the TPL. It handles a lot of the thinking for you when it comes to common concurrent
    issues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个查询无法执行指定的合并选项，.NET 将忽略它。因此，你可以看到 .NET 将合并选项视为建议，如果合并选项不兼容，它不会抛出错误；它只会忽略它。同样，如果你没有指定合并选项，.NET
    会为你选择一个。因此，如果你确定特定的合并对你的性能最好，你可以使用合并选项，或者让 .NET 为你决定。这是 TPL 的美妙之处之一。它在处理常见的并发问题时为你做了很多思考。
- en: 'The different options with which the parallel merge can be set up are listed
    in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图列出了可以设置并行合并的不同选项：
- en: '![Merging in PLINQ](img/8321EN_10_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![PLINQ 中的合并](img/8321EN_10_07.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
- en: 'The following are the parallel query operators that support merging:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下支持合并的并行查询运算符：
- en: '![Merging in PLINQ](img/8321EN_10_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![PLINQ 中的合并](img/8321EN_10_08.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
- en: How to do it
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: Now, let's go back to our project and try changing our program to use the `NotBuffered`,
    `AutoBuffered`, and `FullyBuffered` merging options.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的项目，尝试更改我们的程序以使用 `NotBuffered`、`AutoBuffered` 和 `FullyBuffered` 合并选项。
- en: 'To do this, let''s open our `PLINQQuery` project and change the parallel query
    statement in the `btnMethod1_Click` method to look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们打开我们的 `PLINQQuery` 项目，并将 `btnMethod1_Click` 方法中的并行查询语句更改为以下内容：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s build and run the program and click on the **Execute Method 1**
    button. You should see the following results:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行程序，然后单击 **执行方法 1** 按钮。你应该看到以下结果：
- en: '![How to do it](img/8321EN_10_09.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何做](img/8321EN_10_09.jpg)'
- en: 'Now, let''s try to use the `AutoBuffered` method. To do this, in the `btnMethod1_Click`
    method, change the parallel query statement to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`AutoBuffered`方法。为此，在`btnMethod1_Click`方法中，将并行查询语句更改为以下内容：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, build and run the program again. Click on the **Execute Method 1** button
    and you should get the following results:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次构建并运行程序。点击**执行方法1**按钮，你应该得到以下结果：
- en: '![How to do it](img/8321EN_10_10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_10.jpg)'
- en: 'Now, let''s make one final change to the parallel query in this method to use
    the `AutoBuffered` option. Change the `btnMethod1_click` method to have the following
    parallel query statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对这个方法中的并行查询进行最后一次更改，以使用`AutoBuffered`选项。将`btnMethod1_click`方法更改为以下并行查询语句：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s build and run this application one final time and click on the
    **Execute Method 1** button. The results should look like the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次构建并运行这个应用程序，并点击**执行方法1**按钮。结果应该看起来像以下截图：
- en: '![How to do it](img/8321EN_10_11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_11.jpg)'
- en: How it works
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: As you can see, to dictate to .NET on how to merge the results of a buffered
    query is as easy as calling the `WithMergeOptions()` parallel extension method;
    just like ordering the results is as easy as calling the `AsOrdered()` parallel
    extension method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要告诉.NET如何合并缓冲查询的结果，就像调用`WithMergeOptions()`并行扩展方法一样简单；就像按顺序排序结果一样简单，只需调用`AsOrdered()`并行扩展方法。
- en: But you will also notice that the best results come from using the `AutoBuffered`
    or no-merge option. Even though PLINQ gives you these options to dictate how the
    parallel query is merged, if we let .NET determine how to do it, the results are
    often far better.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也会注意到，使用`AutoBuffered`或无合并选项可以获得最佳结果。尽管PLINQ提供了这些选项来指定并行查询的合并方式，但如果让.NET决定如何做，结果通常会更好。
- en: For complex examples, it might be beneficial to tell .NET how to merge the results,
    but often it is best to let the CLR determine this itself. This is one of the
    benefits of using PLINQ and the TPL—a lot of the complex work and thinking are
    handled for you. You can concentrate your coding time on the functionality and
    not the performance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂示例，可能有益于告诉.NET如何合并结果，但通常最好是让CLR自己决定。这是使用PLINQ和TPL的好处之一——许多复杂的工作和思考都由你处理。你可以将你的编码时间集中在功能上，而不是性能上。
- en: Canceling a PLINQ
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消PLINQ
- en: Canceling a parallel query is very similar to canceling a task using TPL. First,
    we create a cancellation token and then we issue a cancel request to the cancellation
    token. This will create an operation cancellation exception. Then when we execute
    our parallel query, add the parallel extension method `WithCancellation()`, and
    pass it the cancellation token. Then, finally, we catch the operation cancellation
    request and process it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 取消并行查询与使用TPL取消任务非常相似。首先，我们创建一个取消令牌，然后向取消令牌发出取消请求。这将创建一个操作取消异常。然后，当我们执行并行查询时，添加并行扩展方法`WithCancellation()`，并传递取消令牌。最后，我们捕获操作取消请求并处理它。
- en: The .NET framework does not pass a single `OperationCanceledException` into
    a `System.AggregateException`; the `OperationCanceledException` must be processed
    in a separate `catch` block.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架不会将单个`OperationCanceledException`传递到`System.AggregateException`中；`OperationCanceledException`必须在单独的`catch`块中处理。
- en: How to do it
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, let''s open our `PLINQQuery` project again and this time we will add a
    Cancel button and work with the `btnMethod2_Click` event handler method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次打开我们的`PLINQQuery`项目，这次我们将添加一个取消按钮并处理`btnMethod2_Click`事件处理方法：
- en: First, add a new button control to our `MainWindow.xaml.cs` file and set its
    `Content` property to `Cancel` and name the control `btnCancel`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将一个新的按钮控件添加到我们的`MainWindow.xaml.cs`文件中，将其`Content`属性设置为`取消`，并将控件命名为`btnCancel`。
- en: 'Next, we need to add a `using` statement for the `Threading` namespace so we
    can create a cancellation token object. Add the following `using` statement:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`Threading`命名空间添加一个`using`语句，以便我们可以创建一个取消令牌对象。添加以下`using`语句：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let''s create a cancellation token at the top of our `MainWindow` class
    with the following statement:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`MainWindow`类的顶部创建一个取消令牌，如下所示：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s add a `btnCancel_Click` click event handler method for our **Cancel**
    button. It should have the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的**取消**按钮添加一个`btnCancel_Click`点击事件处理方法。它应该有以下的代码：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, let''s change our `IEnumerable` collection to have 500,000 items, so
    it will run longer and give us a chance to cancel the operation:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们将我们的 `IEnumerable` 集合更改为包含 500,000 个项目，这样它就会运行得更长，给我们一个取消操作的机会：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, let''s change the `btnMethod2_Click` event handler to have the following
    code for the parallel query:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将 `btnMethod2_Click` 事件处理程序更改为以下代码以执行并行查询：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s build and run our program. Click on the **Execute Method 2** button
    and immediately click on the **Cancel** button. You should see the following output
    in your application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行我们的程序。点击 **执行方法 2** 按钮，然后立即点击 **取消** 按钮。你应该会在你的应用程序中看到以下输出：
- en: '![How to do it](img/8321EN_10_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_10_12.jpg)'
- en: You can see that we have canceled the parallel query before its completion.
    Now, let's now take a look at how it was performed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在查询完成之前已经取消了并行查询。现在，让我们看看它是如何执行的。
- en: How it works
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We performed this very simply. First, we created a cancellation token to use
    with this command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常简单地执行了这项操作。首先，我们创建了一个取消令牌来与这个命令一起使用：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we created a **Cancel** button. and when it is pressed, we execute the
    `Cancel()` method of the cancellation token object. This is done here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个 **取消** 按钮。当它被按下时，我们执行取消令牌对象的 `Cancel()` 方法。这是在这里完成的：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, in our parallel query, we add the `WithCancellation()` method and
    pass it the cancellation token. Then we add a `catch` block and catch any `OperationCanceledException`
    exceptions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的并行查询中，我们添加了 `WithCancellation()` 方法，并将取消令牌传递给它。然后我们添加了一个 `catch` 块来捕获任何
    `OperationCanceledException` 异常：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That is all there is to it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: Understanding performance improvements in PLINQ
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 PLINQ 性能提升
- en: We have seen how we can implement PLINQ queries and specify ordering, merging,
    and parallel execution options. We have also seen how to execute a PLINQ with
    the `ForAll()` method and as a `foreach` loop. All of these factor into the performance
    of the query. It is also important to examine how .NET decides to partition a
    source data collection when it decides to execute a PLINQ in parallel. Remember,
    a PLINQ executed in parallel is just a LINQ where a data collection is partitioned
    into groups and a task is created to process the `Where` action of the query on
    each partition of data. The following diagrams depict the differences between
    LINQ processing and PLINQ processing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何实现 PLINQ 查询并指定排序、合并和并行执行选项。我们还看到了如何使用 `ForAll()` 方法以及作为 `foreach` 循环来执行
    PLINQ。所有这些因素都会影响查询的性能。同时，也很重要地考察了当 .NET 决定并行执行 PLINQ 时，它如何决定对源数据集合进行分区。记住，并行执行的
    PLINQ 只是一个 LINQ，其中数据集合被分成组，并为处理每个数据分区的 `Where` 操作创建一个任务。以下图表展示了 LINQ 处理和 PLINQ
    处理之间的差异。
- en: 'The following diagram shows the process of the LINQ:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 LINQ 的过程：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![理解 PLINQ 性能提升](img/8321EN_10_13.jpg)'
- en: 'The following diagram shows the process of PLINQ. Notice how the data is partitioned
    and the `Where` clause is executed concurrently on each partition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 PLINQ 的过程。注意数据是如何分区的，以及 `Where` 子句是如何在每个分区上并发执行的：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![理解 PLINQ 性能提升](img/8321EN_10_14.jpg)'
- en: Also, when we perform a query using a `ForAll` versus a `foreach` loop, the
    processing is different. We can determine which of these are the best methods,
    usually by finding out whether or not the order of the results matter. If the
    order of the results is important, then `foreach` is the better processing method
    because the results are merged after the loop processes. Using the `ForAll` loop,
    the whole query is processed on each data partition individually so that there
    is no merging of the results in the correct order. You can place the `AsOrdered`
    method on the `IEnumerable` collection for the query, but it then basically buffers
    all results to merge them so you lose the performance gains the `ForAll` loop
    gives you. The following diagrams depict the differences in the way each of these
    is processed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们使用 `ForAll` 与 `foreach` 循环执行查询时，处理方式不同。我们可以通过找出结果顺序是否重要来确定哪种方法更好。如果结果顺序很重要，那么
    `foreach` 是更好的处理方法，因为结果是在循环处理之后合并的。使用 `ForAll` 循环，整个查询在每个数据分区上单独处理，因此不会在正确的顺序中合并结果。你可以在查询的
    `IEnumerable` 集合上放置 `AsOrdered` 方法，但这样它基本上会缓冲所有结果以合并它们，这样你就失去了 `ForAll` 循环带来的性能提升。以下图表展示了这些处理方式之间的差异。
- en: 'First, we''ll have a look at the `ForAll` processing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看`ForAll`处理：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![理解PLINQ的性能提升](img/8321EN_10_15.jpg)'
- en: 'Second, let''s look at the process of the `foreach` processing. Notice in the
    following diagram that the merge happens before the `foreach` loop processing,
    so the `foreach` processing is done sequentially:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，让我们看看`foreach`处理的过程。注意在下面的图中，合并发生在`foreach`循环处理之前，因此`foreach`处理是顺序执行的：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![理解PLINQ的性能提升](img/8321EN_10_16.jpg)'
- en: 'Now, let''s take a look at the algorithms PLINQ (or more aptly the .NET CLR)
    uses to partition a data collection into groups for parallel processing. .NET
    uses four different algorithms to partition data based on the collection and the
    query. The following screenshot details the first two algorithms:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看PLINQ（或者更确切地说，.NET CLR）用来将数据集合分区成组以进行并行处理所使用的算法。.NET使用四种不同的算法根据集合和查询来分区数据。以下屏幕截图详细说明了前两种算法：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_17.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![理解PLINQ的性能提升](img/8321EN_10_17.jpg)'
- en: Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
- en: 'The details of the other two algorithms are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个算法的详细信息如下：
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_18.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![理解PLINQ的性能提升](img/8321EN_10_18.jpg)'
- en: Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
- en: As you can see from the previous screenshot, PLINQ partitions the source data
    collection based on the type of data and the type of query. This is all part of
    the logic that .NET performs so we do not have to. Just like determining if a
    query should be run concurrently or sequentially, it also determines if concurrent
    is the best way to partition the data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，PLINQ根据数据类型和查询类型对源数据集合进行分区。这完全是.NET执行的逻辑，我们不需要做。就像确定查询是否应该并发运行或顺序运行一样，它还确定并发是否是分区数据最佳的方式。
- en: As we also saw, based on whether or not you need the results ordered either
    a `ForAll` or a `foreach` statement can yield better performance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，根据是否需要有序结果，使用`ForAll`或`foreach`语句可以带来更好的性能。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to change an ordinary LINQ to Objects query
    into a concurrent PLINQ. You also learned how to order results, merge results,
    and cancel queries. PLINQ makes it very easy to concurrently process queries on
    any memory data collection that supports `IEnumerable`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将普通的LINQ to Objects查询转换为并发PLINQ。你还学习了如何排序结果、合并结果以及取消查询。PLINQ使得在支持`IEnumerable`的任何内存数据集合上并发处理查询变得非常容易。
- en: It is also important to remember that PLINQ only supports LINQ to Objects and
    not the other forms of LINQ such as LINQ to SQL or LINQ to XML.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要记住的是，PLINQ只支持LINQ to Objects，而不支持LINQ的其他形式，如LINQ to SQL或LINQ to XML。
- en: PLINQ is as easy to implement as adding a parallel extension method to a source
    data collection in a LINQ query—it is really that simple. Then .NET can determine
    if the query will have better performance running concurrently by partitioning
    the data collection into pieces, and if so, how to partition it. You as the programmer
    do not have to worry about any of this through your source code. PLINQ is really
    a no-brainer when performing a LINQ query because if .NET cannot improve performance
    making the query concurrent, it will just run the query sequentially.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ的实现与在LINQ查询中向源数据集合添加并行扩展方法一样简单——它真的就这么简单。然后.NET可以确定查询是否通过分区数据集合为多个部分来运行并发查询会有更好的性能，以及如何进行分区。作为程序员，你不需要通过源代码担心任何这些问题。当执行LINQ查询时，PLINQ真的是一件无需费脑力的事情，因为如果.NET不能通过使查询并发来提高性能，它将只按顺序运行查询。
- en: In the next chapter, we will examine the new `async` and `await` keywords and
    how to easily implement asynchronous methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨新的`async`和`await`关键字以及如何轻松实现异步方法。
