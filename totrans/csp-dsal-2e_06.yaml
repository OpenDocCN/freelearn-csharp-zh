- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries and Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on data structures related to dictionaries and sets. Applying
    these data structures makes it possible **to map keys to values and perform fast
    lookup**, as well as **to make various operations on sets**. To simplify your
    understanding of dictionaries and sets, this chapter contains illustrations and
    code snippets, along with detailed descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will learn about both non-generic and generic versions of a **dictionary**,
    which is a collection of pairs, each consisting of a key and a value. Then, a
    **sorted variant** of a dictionary will be presented. The remaining part of this
    chapter will show you how to use **hash sets**, together with a **“sorted” set**
    variant. Is it possible to have a “sorted” set? You’ll learn more later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Sorted” sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with the first data structure, which is a **hash table**, also known
    as a **hash map**. **It allows you to** **map** **keys to particular values**.
    One of the most important assumptions of the hash table is the possibility of
    **a very fast lookup for a** **value** **based on the** **key**, which should
    be the *O(1)* operation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a hash table or a dictionary
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a hash table or a dictionary, it would be worth
    thinking about a collection containing a lot of data, where it is crucial to quickly
    check whether the dictionary contains a specific key, as well as quickly retrieve
    the value assigned to a given key. So, think about a system that allows you to
    determine which country a specific IP address comes from. As you know, there are
    many possible IP addresses, and your system must quickly obtain information from
    which country the user’s request comes to select the default language version
    of the application. This is how a hash table and dictionary work! You use an IP
    address as a key (for example, 50.50.50.50) and a country code as a value (for
    example, PL). Thus, you can quickly find out from which country the user came
    to you, without manually browsing the entire collection. I come to you from Poland,
    which I cordially invite you to visit! It contains mountains, sea, lakes, and
    cities with a rich history. All this is waiting here for you!
  prefs: []
  type: TYPE_NORMAL
- en: To achieve a very fast lookup, a **hash function** is used. It takes the key
    to generate an index of a bucket, where the value can be found. For this reason,
    if you need to find a value of the key, you do not need to iterate through all
    the items in the collection since you can just use the hash function to easily
    locate a proper bucket and get the value. As you can see, the role of the hash
    function is critical and ideally, it should generate a unique result for all keys.
    However, the same result may be generated for different keys. Such a situation
    is called a **hash collision** and should be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way of mapping keys to particular values is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Illustration of mapping keys to particular values](img/B18069_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Illustration of mapping keys to particular values
  prefs: []
  type: TYPE_NORMAL
- en: Due to the great performance of hash tables, they are frequently used in many
    real-world applications, such as for **associative arrays**, **database indices**,
    and **cache systems**.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of implementing hash tables from scratch seems to be quite difficult,
    especially when it comes to using the hash function, handling hash collisions,
    as well as assigning particular keys to buckets. Fortunately, a suitable implementation
    is available while developing applications in the C# language, and its usage is
    very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Non-generic and generic versions
  prefs: []
  type: TYPE_NORMAL
- en: There are two variants of the hash table-related classes, namely non-generic
    (`Hashtable`) and generic (`Dictionary`). The first will be described in this
    section, while the other will be described in the following section. If you can
    use the strongly typed generic version, I strongly recommend using it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the `Hashtable` class from the `System.Collections` namespace.
    As mentioned previously, it stores a collection of pairs, where each contains
    a key and a value. A pair is represented by the `DictionaryEntry` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some example code that uses the `Hashtable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'string value = foreach loop to iterate through all pairs stored in the collection,
    as presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The variable that’s used in the loop is of the `DictionaryEntry` type. Therefore,
    you can use its `Key` and `Value` properties to access the key and the value,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Hashtable` class is equipped with a few properties, such as those for
    getting the number of stored elements (`Count`), as well as returning the collection
    of keys and values (`Keys` and `Values`). You can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add`, which adds a new element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove`, which removes an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`, which removes all elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsKey`, which checks whether the collection contains a given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsValue`, which checks whether the collection contains a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about performance?
  prefs: []
  type: TYPE_NORMAL
- en: A hash table is an efficient data structure. Retrieving a value by a key, checking
    whether the collection contains a given key, and removing an item by a key are
    the *O(1)* operations. As for addition, if the capacity does not need to be increased,
    it is the *O(1)* operation as well. Otherwise, it is the *O(n)* operation, where
    *n* is the number of items.
  prefs: []
  type: TYPE_NORMAL
- en: With this short introduction, let’s take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find content regarding a hash table at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable).
  prefs: []
  type: TYPE_NORMAL
- en: Example – phone book
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s say you create an application for a phone book. The `Hashtable`
    class is used to store entries where the person’s name is a key and the phone
    number is a value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This program demonstrates how to add elements to the collection, get the number
    of stored items, iterate through all of them, check whether an element with a
    given key exists, as well as how to get a value based on the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new instance of the `Hashtable` class, as well as initialize
    it with some entries, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Console.WriteLine("Phone numbers:");
  prefs: []
  type: TYPE_NORMAL
- en: if (phoneBook.Count == 0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Empty list.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: foreach (DictionaryEntry entry in phoneBook)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{entry.Key}: {entry.Value}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Console.Write("\nSearch by name: ");'
  prefs: []
  type: TYPE_NORMAL
- en: string name = Console.ReadLine() ?? string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: if (phoneBook.ContainsKey(name))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string number = (string)phoneBook[name]!;
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"Phone number: {number}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Does not exist.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Marcin: 101-202-303'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aline: 303-404-505'
  prefs: []
  type: TYPE_NORMAL
- en: 'John: 202-303-404'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search by name: Aline'
  prefs: []
  type: TYPE_NORMAL
- en: 'Phone number: 303-404-505'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary<string, string> dictionary = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #1", "Value #1" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #2", "Value #2" }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: string value = dictionarystring type is unnecessary because Dictionary is the
    strongly typed version of the hash table-related classes. Therefore, the returned
    value already has the proper type. If an element with the given key does not exist
    in the collection, KeyNotFoundException is thrown. To avoid problems, you can
    either check whether the element exists (by calling ContainsKey) or use the TryGetValue
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a new element or update a value of the existing one using the indexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: foreach (KeyValuePair<string, string> pair in dictionary)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{pair.Key}: {pair.Value}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: foreach ((string k, string v) in dictionary)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{k}: {v}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: BARCODE -------> AREA
  prefs: []
  type: TYPE_NORMAL
- en: 5901020304050 -> A1
  prefs: []
  type: TYPE_NORMAL
- en: 5910203040506 -> B5
  prefs: []
  type: TYPE_NORMAL
- en: 5920304050607 -> C9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary<string, string> products = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5901020304050", "A1" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5910203040506", "B5" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "5920304050607", "C9" }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: products["5930405060708"] = "D7";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: string key = "5940506070809";
  prefs: []
  type: TYPE_NORMAL
- en: if (!products.ContainsKey(key))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: products.Add(key, "A3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: if (!products.TryAdd(key, "B4"))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Cannot add.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Console.WriteLine("All products:");
  prefs: []
  type: TYPE_NORMAL
- en: if (products.Count == 0) { Console.WriteLine("Empty."); }
  prefs: []
  type: TYPE_NORMAL
- en: foreach ((string k, string v) in products)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{k}: {v}");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Console.Write("\nSearch by barcode: ");'
  prefs: []
  type: TYPE_NORMAL
- en: string barcode = Console.ReadLine() ?? string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: if (products.TryGetValue(barcode, out string? location))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"The product is in: {location}.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("The product does not exist.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Cannot add.
  prefs: []
  type: TYPE_NORMAL
- en: 'All products:'
  prefs: []
  type: TYPE_NORMAL
- en: '5901020304050: A1'
  prefs: []
  type: TYPE_NORMAL
- en: '5910203040506: B5'
  prefs: []
  type: TYPE_NORMAL
- en: '5920304050607: C9'
  prefs: []
  type: TYPE_NORMAL
- en: '5930405060708: D7'
  prefs: []
  type: TYPE_NORMAL
- en: '5940506070809: A3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search by barcode: 5901020304050'
  prefs: []
  type: TYPE_NORMAL
- en: 'The product is in: A1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ID   ->  FIRST NAME | LAST NAME | PHONE NUMBER
  prefs: []
  type: TYPE_NORMAL
- en: 100  ->  Marcin     | Jamro     | 101-202-303
  prefs: []
  type: TYPE_NORMAL
- en: 210  ->  John       | Smith     | 202-303-404
  prefs: []
  type: TYPE_NORMAL
- en: 303  ->  Aline      | Weather   | 303-404-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: public record Employee(string FirstName, string LastName,
  prefs: []
  type: TYPE_NORMAL
- en: string PhoneNumber);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary<int, Employee> employees = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 100, new Employee("Marcin", "Jamro", "101-202-303") },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 210, new Employee("John", "Smith", "202-303-404") },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 303, new Employee("Aline", "Weather", "303-404-505") }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.Write("Enter the identifier: ");'
  prefs: []
  type: TYPE_NORMAL
- en: string idString = Console.ReadLine() ?? string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: if (!int.TryParse(idString, out int id)) { break; }
  prefs: []
  type: TYPE_NORMAL
- en: if (employees.TryGetValue(id, out Employee? Employee))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"Full name: {0} {1}\nPhone number: {2}\n",'
  prefs: []
  type: TYPE_NORMAL
- en: employee.FirstName,
  prefs: []
  type: TYPE_NORMAL
- en: employee.LastName,
  prefs: []
  type: TYPE_NORMAL
- en: employee.PhoneNumber);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else { Console.WriteLine("Does not exist.\n"); }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: while (true);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the identifier: 100'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full name: Marcin Jamro'
  prefs: []
  type: TYPE_NORMAL
- en: 'Phone number: 101-202-303'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the identifier: 101'
  prefs: []
  type: TYPE_NORMAL
- en: Does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: SortedDictionary<string, string> dictionary = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #1", "Value #1" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Key #2", "Value #2" }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary.Add("Key #3", "Value #3");'
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary["Key #4"] = "Value #4";'
  prefs: []
  type: TYPE_NORMAL
- en: 'string value = dictionary["Key #1"];'
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary.Count), as well as returning the collection of keys and values (Keys
    and Values, respectively). Moreover, you can use the available methods, which
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add`, which adds a new element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove`, which removes an item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`, which removes all elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsKey`, which checks whether the collection contains a particular key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsValue`, which checks whether the collection contains a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryGetValue`, which tries to get a value for a given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to iterate through all the pairs stored in the collection, you can
    use the `foreach` loop. The variable that’s used in the loop is an instance of
    `KeyValuePair` with `Key` and `Value` properties, allowing you to access the key
    and the value.
  prefs: []
  type: TYPE_NORMAL
- en: What about performance?
  prefs: []
  type: TYPE_NORMAL
- en: Despite the automatic sorting advantages, the `SortedDictionary` class has some
    performance drawbacks compared to `Dictionary` because retrieval, insertion, and
    removal are the *O(log n)* operations, where *n* is the number of elements in
    the collection, instead of *O(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `SortedDictionary` is quite similar to `SortedList`, as described
    in [*Chapter 3*](B18069_03.xhtml#_idTextAnchor088), *Arrays and Sorting*. However,
    it differs in memory-related and performance-related results. The retrieval for
    both these classes is the *O(log n)* operation, but insertion and removal for
    unsorted data is *O(log n)* for `SortedDictionary` and *O(n)* for `SortedList`.
    Of course, more memory is necessary for `SortedDictionary` than for `SortedList`.
    As you can see, choosing a proper data structure is not an easy task and you should
    think carefully about the scenarios in which data structures are used and take
    into account both the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: With this short introduction, let’s see the sorted dictionary in action.
  prefs: []
  type: TYPE_NORMAL
- en: Example – encyclopedia
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s create a simple encyclopedia where you can add entries
    and show their full content. The encyclopedia can contain millions of entries,
    so it is crucial to provide its users with the possibility of browsing entries
    in the correct order, alphabetically by keys, as well as finding entries quickly.
    For this reason, the sorted dictionary is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of the encyclopedia is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the program is launched, it presents a simple menu with two options, namely
    `[A]dd` and `[L]ist`. After pressing *A*, the application asks you to enter the
    key and explanation for the entry. If the provided data is correct, a new entry
    is added to the encyclopedia. If the user presses *L*, data of all entries, sorted
    by keys, is presented in the console. When any other key is pressed, additional
    confirmation is shown and, if confirmed, the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, a new instance of the `SortedDictionary` class is created, which represents
    a collection of pairs with `string`-based keys and `string`-based values. Then,
    the infinite `do-while` loop is used. Within it, the program waits until the user
    presses any key. If it is the *A* key, a key and an explanation of the entry are
    obtained from the values entered by the user. Then, a new entry is added to the
    dictionary using the indexer. Thus, if the entry with the same key already exists,
    it will be updated. In the case of pressing the *L* key, a `foreach` loop is used
    to show all entered entries. When any other key is pressed, another question is
    presented to the user and the program waits for confirmation. If the user presses
    *Y*, you break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, you can enter a few entries, as well as present them.
    The result from the console can be similar to what’s shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So far, you’ve learned about three dictionary-related classes, namely `Hashtable`,
    `Dictionary`, and `SortedDictionary`. To make understanding them easier, a few
    examples were presented, together with detailed explanations.
  prefs: []
  type: TYPE_NORMAL
- en: However, do you know that some other data structures store just keys, without
    values? You will learn about these in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Hash sets
  prefs: []
  type: TYPE_NORMAL
- en: In many algorithms, it is necessary to perform operations on sets with various
    data. However, what is a **set**? **A set is a collection of distinct objects
    without duplicated elements and without a particular order.** Therefore, you can
    only get to know whether a given element is in the set or not. These sets are
    strictly connected with mathematical models and operations, such as union, intersection,
    subtraction, and symmetric difference. A set can store various data, such as integer
    or string values. Of course, you can also create a set with instances of a user-defined
    class or record, as well as add and remove elements from the set at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a hash set
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a hash set, think for a moment about the game
    of chance, which is popular in many countries and involves selecting a few numbers
    that are then drawn from among many available ones. Depending on how many numbers
    you got from those drawn, you receive a prize. Of course, the chance of matching
    all the drawn numbers is very, very small. Now, you may be wondering where these
    collections are here. I’m in a hurry to answer this! There are three sets here,
    namely a set of all available numbers, a set of randomly drawn numbers, and a
    set of numbers selected by you. Each set cannot contain any duplicates. Of course,
    both the set of randomly drawn numbers and the set of numbers you choose are subsets
    of the set of all available numbers. How can you check how many numbers you have
    chosen correctly? It is very easy! Just perform the “intersection” operation on
    two sets, namely the set of randomly selected numbers and the set of numbers you
    selected, to obtain the result set. Now, all you have to do is keep your fingers
    crossed that the number of elements in this result set matches the number of elements
    in the set of drawn numbers. If that happens, then... you may become very rich
    because you matched all the drawn numbers. If so, congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: 'Two exemplary sets are presented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Illustration of sets with integer and string values](img/B18069_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Illustration of sets with integer and string values
  prefs: []
  type: TYPE_NORMAL
- en: Before seeing sets in action, it is a good idea to remind you of some basic
    operations that can be performed on two sets, named **A** and **B**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **union** (shown on the left of the following figure as **A****∪****B**)
    is **a set with all elements that** **belong to A or B**. The **intersection**
    (presented on the right as **A****∩****B**) **contains only the elements that
    belong to both A** **and B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Illustration of set union and intersection](img/B18069_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Illustration of set union and intersection
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common operation is set **subtraction**. **The result set of A \ B
    contains elements that are the members of A and not the members of B**. In the
    following figure, two examples are shown, namely **A \ B** and **B \** **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Illustration of set subtraction](img/B18069_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Illustration of set subtraction
  prefs: []
  type: TYPE_NORMAL
- en: 'While performing various operations on sets, it is also worth mentioning the
    **symmetric difference**, shown in the following figure as **A ∆ B**. The final
    set can be interpreted as a union of two sets, namely (**A \ B**) and (**B \ A**).
    Therefore, **it contains elements that belong to only one set, either A or B**.
    The elements that belong to both sets are excluded from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Illustration of set symmetric difference and the relationships
    between sets](img/B18069_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Illustration of set symmetric difference and the relationships
    between sets
  prefs: []
  type: TYPE_NORMAL
- en: Another important topic is the **relationship** between sets. **If every element
    of B belongs to A, this means that B is a** **subset** **of A**. This is shown
    in the preceding diagram, on the right. At the same time, **A is a** **superset**
    **of B**. Moreover, **if B is a subset of A, but B is not equal to A, B is a**
    **proper subset** **of A**, and **A is a** **proper superset****of B**.
  prefs: []
  type: TYPE_NORMAL
- en: While developing various kinds of applications in the C# language, you can benefit
    from high-performance operations provided by the `HashSet` class from the `System.Collections.Generic`
    namespace. The class contains a few properties, including `Count`, which returns
    the number of elements in the set.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find content regarding a hash set at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you can use many methods to perform operations of sets. The first
    group of methods makes it possible to modify the current set (on which the method
    is called) to create the union (`UnionWith`), the intersection (`IntersectWith`),
    the subtraction (`ExceptWith`), and the symmetric difference (`SymmetricExceptWith`)
    with the set passed as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also check the relationship between two sets, such as checking whether
    the current set (on which the method is called) is a subset (`IsSubsetOf`), a
    superset (`IsSupersetOf`), a proper subset (`IsProperSubsetOf`) or a proper superset
    (`IsProperSupersetOf`) of the set passed as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you can verify whether two sets contain the same elements (`SetEquals`)
    or whether two sets have at least one common element (`Overlaps`).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these operations, you can add a new element to the set (`Add`), remove
    a particular element (`Remove`), remove all elements (`Clear`), and check whether
    the given element exists in the set (`Contains`).
  prefs: []
  type: TYPE_NORMAL
- en: What about performance?
  prefs: []
  type: TYPE_NORMAL
- en: Hash sets make it possible to perform a quick lookup for a given item. Thus,
    checking whether the set contains an item and removing an item are *O(1)* operations.
    As for addition, it is an *O(1)* operation if it does not need to increase the
    internal array. If resizing is necessary, it turns out to be the *O(n)* operation,
    where *n* is the number of items.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction, try to put what you’ve learned into practice. Now, let’s
    proceed to two examples that show how you can apply hash sets in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Example – coupons
  prefs: []
  type: TYPE_NORMAL
- en: The first example represents a system that checks whether a one-time coupon
    has already been used. If so, a suitable message is presented to the user. Otherwise,
    the system informs the user that the coupon is valid. It is then marked as used
    and cannot be used again. Due to the high number of coupons, it is necessary to
    choose a data structure that allows you to quickly check whether an element exists
    in a collection. For this reason, a hash set has been chosen as a data structure
    for storing identifiers of used coupons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, a new instance of `HashSet` that stores integer values is created. Then,
    the majority of operations are performed within the `do-while` loop. Here, the
    program waits until the user enters the coupon identifier. If it cannot be parsed
    to the integer value, you break out of the loop. Otherwise, you check whether
    the set already contains the coupon identifier (using the `Contains` method).
    If so, the suitable information is presented in the console. If it does not exist,
    you add it to the collection of used coupons (using the `Add` method) and inform
    the user about the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you break out of the loop, you just need to show the complete list of
    identifiers of the used coupons. You can do so using a `foreach` loop, iterating
    over the set, and writing its elements in the console, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can launch the application, enter some data, and see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is the end of the first example. Let’s proceed to the next one, where you
    will see a more complex solution that uses a hash set.
  prefs: []
  type: TYPE_NORMAL
- en: Example – swimming pools
  prefs: []
  type: TYPE_NORMAL
- en: This example presents the system for a SPA center with four swimming pools,
    namely recreation, competition, thermal, and for kids. Each visitor receives a
    special wristband that allows them to enter all the pools. However, it is necessary
    to scan the wristband upon each user entering any pool. Your program uses such
    data to create various statistics.
  prefs: []
  type: TYPE_NORMAL
- en: A hash set has been chosen as a data structure for storing unique numbers of
    wristbands that are scanned at the entrance to each swimming pool. Four sets are
    used, one per pool. Moreover, they are grouped in the dictionary to simplify and
    shorten the code, as well as make future modifications easier. To simplify testing
    the application, the initial data is set randomly. Then, you create statistics,
    namely the number of visitors by pool type, the most popular pool, the number
    of people who visited at least one pool, as well as the number of people who visited
    all the pools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `PoolTypeEnum` enumeration, which represents possible
    types of swimming pools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `Program.cs` and add the `random` variable. This will be used to
    fill the hash set with some random values. The line of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next part of the code, you create a new instance of `Dictionary`. This
    contains four entries. Each key is of the `PoolTypeEnum` type and each value is
    of the `HashSet<int>` type – that is, a set with integer values. The code is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you fill the sets with random values, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To do so, you use two loops, namely `for` and `foreach`. The first iterates
    `100` times and simulates `100` wristbands. Within it, there is a `foreach` loop,
    which iterates through all available pool types. For each of them, you randomly
    check whether a visitor entered a particular swimming pool. If so, the identifier
    is added to the proper set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code is related to generating various statistics. First, let’s
    present the number of visitors by pool type. Such a task is very easy because
    you just need to iterate through the dictionary, as well as write the pool type
    and the number of elements in the set (using the `Count` property), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part finds the swimming pool with the maximum number of visitors.
    This is done using a few extension methods, namely to order the results by the
    number of elements in the set, in descending order (`OrderByDescending`), to choose
    only a pool type (`Select`), and to take only the first element (`FirstOrDefault`).
    Then, you just present the result. The code for doing this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you want to get the number of people who visited at least one pool. You
    perform this task by creating a union of all sets and getting the count of the
    final set. First, you create a new set and fill it with identifiers regarding
    the recreation swimming pool. In the following lines of code, you call the `UnionWith`
    method to create a union with the following three sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The last statistic is the number of people who visited all pools during one
    visit to the SPA center. You just need to create the intersection of all sets
    and get the count of the final set. To do so, you create a new set and fill it
    with identifiers regarding the recreation swimming pool. Then, you call the `IntersectWith`
    method to create an intersection with the following three sets. Finally, you get
    the number of elements in the set using the `Count` property and present the results,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all! When you run the application, you may receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just completed two examples regarding hash sets. It’s a good idea to
    try to modify the code and add new features on your own to learn more about this
    data structure. In the next section, we’ll look at “sorted” sets.
  prefs: []
  type: TYPE_NORMAL
- en: “Sorted” sets
  prefs: []
  type: TYPE_NORMAL
- en: The previously described `HashSet` class can be understood as a dictionary that
    stores only keys, without values. So, if there is the `SortedDictionary` class,
    maybe there is also the `SortedSet` class? There is! However, can a set be “sorted”?
    Why is “sorted” written with quotation marks? The answer turns out to be very
    simple. By definition, a set stores a collection of distinct objects without duplicated
    elements and without a particular order. If a set does not support order, how
    can it be “sorted”? For this reason, **a “sorted” set can be understood as a combination
    of** **HashSet** **and** **SortedList****, not a** **set itself.**
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a “sorted” set
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a “sorted” set, recall the previous example related
    to the game of chance. To facilitate manual comparison of results, both the set
    of randomly drawn numbers and the set of numbers selected by you can be “sorted”
    and shown in ascending order. This is where a “sorted” set comes in handy. It’s
    very simple and clear, don’t you think?
  prefs: []
  type: TYPE_NORMAL
- en: A “sorted” set can be used if you want to have a `SortedSet` and is available
    in the `System.Collections.Generic` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find content regarding a "sorted" set at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1).
  prefs: []
  type: TYPE_NORMAL
- en: It has a set of methods, similar to those already described in the case of the
    `HashSet` class, including `UnionWith`, `IntersectWith`, `ExceptWith`, `SymmetricExceptWith`,
    `Overlaps`, `IsSubsetOf`, `IsSupersetOf`, `IsProperSubsetOf`, and `IsProperSupersetOf`.
  prefs: []
  type: TYPE_NORMAL
- en: It contains additional properties for returning the minimum and maximum values
    (`Min` and `Max`, respectively). It is also worth mentioning the `GetViewBetween`
    method since it returns a `SortedSet` instance with values from the given range.
  prefs: []
  type: TYPE_NORMAL
- en: What about performance?
  prefs: []
  type: TYPE_NORMAL
- en: The “sorted” set is an interesting data structure in terms of its performance.
    It is a kind of a trade-off between functionalities and performance. Thus, checking
    whether the collection contains an item as well as removing any item from the
    collection are *O(log n)* operations. For this reason, you should expect worse
    performance results compared to the data structures described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to a simple example to see how to use a “sorted” set in code.
  prefs: []
  type: TYPE_NORMAL
- en: Example – removing duplicates
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you will create a simple application that removes duplicates
    from the list of names. Of course, the comparison of names should be case-insensitive,
    so it is not allowed to have both `Marcin` and `marcin` in the same collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, a list of names is created and initialized with nine elements, including
    `Marcin` and `marcin`. Then, a new instance of the `SortedSet` class is created
    and two parameters are passed to the constructor, namely the list of names and
    the case-insensitive comparer. Finally, the collection is iterated through so
    that you can write names in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you’ll see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Do you know that you can use another variant of the `SortedSet` constructor
    and pass only the first parameter, namely the list, without the comparer? In such
    a case, the default comparer will be used and will be case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you’ve just completed the last example shown in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focused on hash tables, dictionaries, and sets. All of these collections
    are interesting data structures that can be used in various scenarios during the
    development of many applications. By presenting such collections with detailed
    descriptions, performance explanations, and examples, you saw that choosing a
    proper data structure is not a trivial task and requires analyzing performance-related
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: First, you learned how to use two variants of a **hash table**, namely non-generic
    and generic. The huge advantage of these is a very fast lookup for a value based
    on the key, which is the close *O(1)* operation. To achieve this goal, the hash
    function is used. Moreover, the **sorted dictionary** was introduced as an interesting
    solution to solve the problem of unsorted items in the collection and to keep
    keys sorted all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, the high-performance solution to **set operations** was presented.
    A set can be understood as a collection of distinct objects without duplicated
    elements and without a particular order. The class that was shown makes it possible
    to perform various operations on sets, such as union, intersection, subtraction,
    and symmetric difference. Then, the concept of the **“sorted” set** was introduced
    as a sorted collection of distinct objects without duplicated elements.
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to dive deeper into the topic of data structures and algorithms
    while developing applications in the C# language? If so, proceed to the next chapter,
    where **trees** are presented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
