<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing JavaScript Applications</h1>
                
            
            <article>
                
<p class="calibre2">To get started testing in JavaScript, we will need to create a ReactJS application and configure it for testing using the Mocha, Chai, Enzyme, and Sinon libraries.</p>
<p class="calibre2">These steps were discussed in detail in <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>, <em class="calibre12">Setting up the JavaScript Environment</em>, so here, we will simply walk through the steps and not explain them in detail.</p>
<p class="calibre2">The goals for this chapter are:</p>
<ul class="calibre7">
<li class="calibre8">Create the Speaker Meet React application</li>
<li class="calibre8">Talk through our plan of attack for testing the application:
<ul class="calibre43">
<li class="calibre8">What is our approach?</li>
<li class="calibre8">What parts of the app can we even test?</li>
<li class="calibre8">What part of the app do we start with?</li>
</ul>
</li>
<li class="calibre8">Write tests and complete a couple of features for the application:
<ul class="calibre43">
<li class="calibre8">Speaker listing</li>
<li class="calibre8">Speaker detail</li>
</ul>
</li>
</ul>
<p class="calibre2">Once this chapter is finished, you should be capable of unit-testing any  React-based application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a React app</h1>
                
            
            <article>
                
<p class="calibre2">For the application in this book, to maintain compatibility, you will want to use Node.js version 8.5.0, NPM version 5.4.2, and create-react-app version 1.4.0.</p>
<p class="calibre2">Execute the following commands to install and execute the app:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm test</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm start</strong></pre>
<p class="calibre2">All three commands should run successfully. After running <kbd class="calibre11">npm test</kbd>, you will need to exit the test run by hitting <kbd class="calibre11">&lt;q&gt;</kbd>. After running <kbd class="calibre11">npm start</kbd>, you will need to exit the server by hitting <em class="calibre12">Ctrl</em> + <em class="calibre12">C</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ejecting the app</h1>
                
            
            <article>
                
<p class="calibre2">Assuming the previous step went without a hitch, we can proceed to eject the React app. Again, as it has already been explained in detail in <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>, <em class="calibre12">Setting up the JavaScript Environment</em>, we will only do a short review here.</p>
<p class="calibre2">There is only a single command to eject the application. After ejection, we will want to rerun the commands in the previous section to ensure that the application still works as expected.</p>
<p class="calibre2">Execute the following command to eject:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm run eject</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring Mocha, Chai, Enzyme, and Sinon </h1>
                
            
            <article>
                
<p class="calibre2">Now, we are ready to add the testing facilities that we would like to use for this app. As before, the addition of these utilities has been covered in detail in a previous chapter. So, we will only be providing the commands to execute and the versions of the packages to install.</p>
<p class="calibre2">Execute the following commands to install the libraries we are going to use:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install mocha@3.5.3</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install chai@4.1.2</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install enzyme@2.9.1</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install sinon@3.2.1</strong></pre>
<p class="calibre2">There are also a few other libraries we will be using as part of our Redux workflow:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install nock@9.0.1</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install react-router-dom@4.2.2</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install redux@3.7.2</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install redux-mock-store@1.3.0</strong><br class="title-page-name"/><strong class="calibre1">&gt;npm install redux-thunk@2.2.0</strong></pre>
<p class="calibre2">Including the version in the install command will ensure that you are using the same version of the libraries that we are and will reduce the number of potential issues.</p>
<p class="calibre2">To use the libraries we have just installed, we will also need to install an extra preset for babel:</p>
<pre class="calibre19"><strong class="calibre1">&gt;npm install babel-preset-es2015@6.24.1</strong></pre>
<p class="calibre2">Update your babel config in <kbd class="calibre11">package.json</kbd> to remove react-app and include <kbd class="calibre11">react</kbd> and <kbd class="calibre11">es2015</kbd>.</p>
<pre class="calibre19">"babel": {<br class="title-page-name"/>   "presets": [<br class="title-page-name"/>     "react",<br class="title-page-name"/>     "es2015"<br class="title-page-name"/>   ]<br class="title-page-name"/> },</pre>
<p class="calibre2">As described in <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>, <em class="calibre12">Setting up the JavaScript Environment</em>, delete the test configuration section from <kbd class="calibre11">package.json</kbd>. Then, update the test script to:</p>
<pre class="calibre19">"test": "mocha --require ./scripts/test.js --compilers babel-core/register ./src/**/*.spec.js"</pre>
<p class="calibre2">And add a test watch script:</p>
<pre class="calibre19">"test:watch": "npm test -- -w"</pre>
<p class="calibre2">We are now ready to update the test execution file <kbd class="calibre11">test.js</kbd> in the scripts folder so it's compatible with Mocha. Change all the contents of the file to:</p>
<pre class="calibre19">'use strict'; <br class="title-page-name"/><br class="title-page-name"/>import jsdom from 'jsdom'; <br class="title-page-name"/>global.document = jsdom.jsdom('&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'); <br class="title-page-name"/>global.window = document.defaultView; <br class="title-page-name"/>global.navigator = window.navigator; <br class="title-page-name"/><br class="title-page-name"/>function noop() { <br class="title-page-name"/>  return {}; <br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// prevent mocha tests from breaking when trying to require a css file <br class="title-page-name"/>require.extensions['.css'] = noop; <br class="title-page-name"/>require.extensions['.svg'] = noop;</pre>
<p class="calibre2">The last step before we can use our new testing libraries is to update the <kbd class="calibre11">App.test.js</kbd> file to match the conventions used with Mocha and Chai. So, change the filename to <kbd class="calibre11">App.spec.js</kbd> and update the contents to match the code shown here:</p>
<pre class="calibre19">import React from 'react'; <br class="title-page-name"/>import ReactDOM from 'react-dom'; <br class="title-page-name"/>import { expect } from 'chai'; <br class="title-page-name"/>  <br class="title-page-name"/>import App from './App'; <br class="title-page-name"/>  <br class="title-page-name"/>describe('(Component) App', () =&gt; { <br class="title-page-name"/>  it('renders without crashing', () =&gt; { <br class="title-page-name"/>        const div = document.createElement('div'); <br class="title-page-name"/>        ReactDOM.render(&lt;App /&gt;, div); <br class="title-page-name"/>    }); <br class="title-page-name"/>}); </pre>
<p class="calibre2">Now, as before, execute the test script and start the application to make sure nothing broke during our transformation to Mocha.</p>
<pre class="calibre19">&gt;npm test<br class="title-page-name"/>&gt;npm run test:watch<br class="title-page-name"/>&gt;npm start</pre>
<p class="calibre2">All three of those commands should work. If you have an issue, check all the steps we have just discussed and look to <a target="_blank" href="part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 3</a>, <em class="calibre12">Setting Up a JavaScript Environment</em>, for a more detailed explanation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The plan</h1>
                
            
            <article>
                
<p class="calibre2">Now that our testing config has been updated and is working correctly, we can begin thinking about test-driving our first feature.</p>
<p class="calibre2">In earlier chapters, we discussed where to start testing and decided that if possible an inside-out approach is preferred. To keep with that approach, we want to determine the different parts of our React app so that we can target the purest business logic we can.</p>
<p class="calibre2">Right off the bat, regardless of any other architectural choices, we can identify the React component and a service representing communication with our data source. We are planning to use Redux in this app so that makes up the missing piece and connects our component with our data.</p>
<p class="calibre2">Which one of these is the business logic though? Out of those base options, what would we even test? Let's examine each one a little more closely and see what we could test that would be considered a unit test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Considering the React component</h1>
                
            
            <article>
                
<p class="calibre2">Generally, we want to avoid unit-testing third-party libraries. So, let's separate the third-party aspects of a React component from the parts that we would potentially unit-test.</p>
<p class="calibre2">The third-party aspects include any inherited features and functionality; this includes to some degree any life cycle methods and the JSX. So, what's left? The answer to this question depends on whether the component in question is a presentational component or a container component.</p>
<p class="calibre2">Presentational components are almost pure HTML and view mechanisms. There is almost no traditionally unit-testable behavior. Certainly, there is no real business logic.</p>
<p class="calibre2">Container components are where the real action happens in a React application. These components can manipulate data and make business decisions that can control the flow of the application. So, let's keep container components in the list of possible places to start our unit-testing efforts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking at Redux testability</h1>
                
            
            <article>
                
<p class="calibre2">Redux is a third-party library, that controls data flow throughout the application and manages quite a bit of the normal data shuffling that we may want to unit test. Because it is third-party though, on the surface there doesn't seem to be too much that we can unit test. Let's take a closer look at the aspects of the Redux data flow to determine if there really is nothing to test or if we still need to unit test parts of Redux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The store</h1>
                
            
            <article>
                
<p class="calibre2">The Redux store is where all the data lives after it has been acquired by the application. Typically, there is only one store for each application using Redux. The store is almost completely contained within the Redux library and we have very few direct interactions with it. For this reason, there doesn't seem to be much we would or could test for the store and it falls squarely in the realm of third-party code that we must simply trust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Actions</h1>
                
            
            <article>
                
<p class="calibre2">Actions in Redux represent an event carrying a data packet. The event is usually a command to either retrieve or update data within the data source which should be reflected by the store. Because actions are just a key with some data attached, there doesn't seem to be much to test here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reducers</h1>
                
            
            <article>
                
<p class="calibre2">If there is anything to test within the Redux interactions, it is likely in the reducers. Reducers receive the actions and determine what to do, if anything, based on the actions requested and the data provided as part of those actions.</p>
<p class="calibre2">Typically, the reducer is going to simply call the API service once the appropriate service call is determined. It is possible that a reducer might also map the received data into a format that is more appropriate to the service call that must be made.</p>
<p class="calibre2">So, if the reducer is, in all reality, just going to call the service, what would we test for the reducer? Other than ensuring that the appropriate service method is called with the appropriate data there doesn't seem to be much. For completeness, we would want to test those things, but they do not represent the core of our business logic.</p>
<p class="calibre2">In conclusion, it doesn't appear that much is testable in Redux and what is testable doesn't represent the core of our business logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing an API service</h1>
                
            
            <article>
                
<p class="calibre2">Lastly, let's look at the API service. Normally, the service in a front-end application behaves much like the repository in a back-end application. The service's main function is to abstract data interactions with some data source. Those interactions don't necessarily contain any definable business logic. The real logic, if any, for a service exists on the server and doesn't need to be tested as part of a front-end application. At least it doesn't need to be tested the way you might think it does.</p>
<p class="calibre2">So, if the service doesn't contain any business logic, and Redux doesn't contain much business logic, and the components don't contain much business logic, what do we test and how can it be unit-tested?</p>
<p class="calibre2">The short answer is that we are not off the hook for testing, but we will have to jump through some hoops to do any testing because it is difficult to remove ourselves from integration testing. In a typical front-end application, unlike in C#, there is no clear division between our code and their code. So, we will have to make some concessions and write quite a bit of code to abstract parts of third-party code to allow us to test what we need to be testing.</p>
<p class="calibre2">So, where does this leave us when it comes to a testing direction?  Unfortunately, there doesn't seem to be a clear winner. For the purposes of this application, we will work from the data source up so that we have a clear understanding of the data manipulations available to us while we write user interface aspects of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Speaker listing</h1>
                
            
            <article>
                
<p class="calibre2">Following the functionality in our C# backend, we will start by testing a listing of the speakers available. We are not yet ready to connect to the backend and, for any of the tests we will write here as unit tests, we will need to mock the behaviors that the backend would normally present.</p>
<p class="calibre2">For the moment, we are not going to concern ourselves with any kind of authentication. So, the important functionality we will be looking to implement is that when no speakers exist we should let the user know, and when speakers do exist we should list them.</p>
<p class="calibre2">The way that we will produce both situations is through a mock API. As strange as it may seem, most of our business logic will be in the mock API. Because it will be crucial to all of the other tests we will write, we must unit test the mock API as if it were production code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A mock API service</h1>
                
            
            <article>
                
<p class="calibre2">To begin testing the mock API service, let's create a new services folder and add a <kbd class="calibre11">mockSpeakerService.spec.js</kbd> file.</p>
<p class="calibre2">Inside that file, we need to import our assertion library, create our initial describe, and write an existence test.</p>
<pre class="calibre19">import { expect } from 'chai';<br class="title-page-name"/> <br class="title-page-name"/>describe('Mock Speaker Service', () =&gt; {<br class="title-page-name"/>  it('exits', () =&gt; {<br class="title-page-name"/>    expect(MockSpeakerService).to.exist;<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">Start the npm test script with watch. The test we just wrote should fail. To make the test pass, we must create a <kbd class="calibre11">MockSpeakerService</kbd> object. Let's play devil's advocate a little and create an object in this file, but only enough of an object to make the test pass.</p>
<pre class="calibre19">let MockSpeakerService = {};</pre>
<p class="calibre2">This line passes the currently failing test, but clearly isn't what we are after. It does, however, force us to write more robust tests. The next test we can write is one that proves that the <kbd class="calibre11">MockSpeakerService</kbd> can be constructed. This test should ensure that we have defined the <kbd class="calibre11">MockSpeakerService</kbd> as a class.</p>
<pre class="calibre19">it('can be constructed', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  let service = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>  // assert<br class="title-page-name"/>  expect(service).to.be.an.instanceof(MockSpeakerService);<br class="title-page-name"/>});</pre>
<p class="calibre2">This test fails, stating that <kbd class="calibre11">MockSpeakerService</kbd> is not a constructor. The way to fix this is to change <kbd class="calibre11">MockSpeakerService</kbd> into a class.</p>
<pre class="calibre19">class MockSpeakerService {<br class="title-page-name"/>}</pre>
<p class="calibre2">Now that we have a class that can be instantiated, the next test we write can start to test actual functionality. So, what functionality are we going to test? Looking at the requirements, we can see that the first scenario involves requesting all the speakers and receiving no speakers. That's a reasonably simple scenario to test. What would we call the function in the <kbd class="calibre11">MockSpeakerService</kbd> that would get all the speakers? Because we are trying to get all the speakers, a simple name that would not be redundant and fits the repository pattern we discussed in the C# backend is simply <kbd class="calibre11">getAll</kbd>. Let's create a nested describe and an existence test for a <kbd class="calibre11">getAll</kbd> class method.</p>
<pre class="calibre19">describe('Get All', () =&gt; {<br class="title-page-name"/>  it('exists', () =&gt; {<br class="title-page-name"/>    // arrange<br class="title-page-name"/>    let service = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>    // assert<br class="title-page-name"/>    expect(service.getAll).to.exist;<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">As per usual, this test should fail and it should fail with <kbd class="calibre11">expected undefined to exist</kbd>. Making this test pass is relatively simple, just add a <kbd class="calibre11">getAll</kbd> method to the <kbd class="calibre11">MockSpeakerService</kbd> class.</p>
<pre class="calibre19">class MockSpeakerService {<br class="title-page-name"/>  getAll() {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The next thing we need to decide is the result we should expect when there are no speakers. Looking back at the backend, we should be receiving an empty array when no speakers are present. Looking at the requirements, the system should present a <kbd class="calibre11">NO_SPEAKERS_AVAILABLE</kbd> message. Should the service be responsible for displaying that message? In this case, the answer is no. The react component should be responsible for displaying the <kbd class="calibre11">NO_SPEAKERS_AVAILABLE</kbd> message when we get to that portion of the code. For now, we should expect, when no speakers exist, to receive an empty data set.</p>
<p class="calibre2">Because we are extending the context of the test, let's create another describe for that context extension.</p>
<pre class="calibre19">describe('No Speakers Exist', () =&gt; {<br class="title-page-name"/>  it('returns an empty array', () =&gt; {<br class="title-page-name"/>    // arrange<br class="title-page-name"/>    let service = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>    // act<br class="title-page-name"/>    let promise = service.getAll();<br class="title-page-name"/>  <br class="title-page-name"/>    // assert<br class="title-page-name"/>    return promise.then((result) =&gt; {<br class="title-page-name"/>      expect(result).to.have.lengthOf(0);<br class="title-page-name"/>    });      <br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">Notice the syntax we used for this test. We return the promise and make our assertions inside the then function. This is because we want our test to operate on asynchronous code from our service. The majority of backend operations will need to be asynchronous and one convention for dealing with that asynchronicity is to use promises. Asynchronous tests, that is, tests dealing with promises, in Mocha require that the promise be returned from the test so that Mocha can know to wait for the promise to resolve before closing out the test.</p>
<p class="calibre2">And now, to make the test pass, all we need to do is return a promise that resolves with an empty array from the <kbd class="calibre11">getAll</kbd> method. We are going to use a zero delay <kbd class="calibre11">setTimeout</kbd> here which will set us up to implement some kind of delay for development purposes later on. The reason we want a delay is so that we can test the operation of the UI in the event of a slow network response.</p>
<pre class="calibre19">getAll() {<br class="title-page-name"/>  return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>    setTimeout(() =&gt; {<br class="title-page-name"/>      resolve(Object.assign([], this._speakers));<br class="title-page-name"/>    }, 0);<br class="title-page-name"/>  });<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we have the first scenario passing and enough code to warrant a refactoring. We are declaring the service variable in multiple places and we don't have a context that represents a baseline instantiation of that variable. Let's create a describe to wrap all the post instantiation tests and add a <kbd class="calibre11">beforeEach</kbd> to initialize a service variable scoped to that describe and available to all the tests within it.</p>
<p class="calibre2">Here are the tests after the refactoring:</p>
<pre class="calibre19">describe('Mock Speaker Service', () =&gt; {<br class="title-page-name"/>   it('exits', () =&gt; {<br class="title-page-name"/>     expect(MockSpeakerService).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> <br class="title-page-name"/>   it('can be constructed', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     let service = new MockSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(service).to.be.an.instanceof(MockSpeakerService);<br class="title-page-name"/>   });<br class="title-page-name"/> <br class="title-page-name"/>   describe('After Initialization', () =&gt; {<br class="title-page-name"/>     let service = null;<br class="title-page-name"/> <br class="title-page-name"/>     beforeEach(() =&gt; {<br class="title-page-name"/>       service = new MockSpeakerService();<br class="title-page-name"/>     });<br class="title-page-name"/> <br class="title-page-name"/>     describe('Get All', () =&gt; {<br class="title-page-name"/>       it('exists', () =&gt; {<br class="title-page-name"/>         // assert<br class="title-page-name"/>         expect(service.getAll).to.exist;<br class="title-page-name"/>       });<br class="title-page-name"/> <br class="title-page-name"/>       describe('No Speakers Exist', () =&gt; {<br class="title-page-name"/>         it('returns an empty array', () =&gt; {<br class="title-page-name"/>           // act<br class="title-page-name"/>           let promise = service.getAll();<br class="title-page-name"/> <br class="title-page-name"/>           // assert<br class="title-page-name"/>           return promise.then((result) =&gt; {<br class="title-page-name"/>             expect(result).to.have.lengthOf(0);<br class="title-page-name"/>           });<br class="title-page-name"/>         });<br class="title-page-name"/>       });<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">The next scenario, the speaker listing, is for when speakers do exist. The first test for this scenario will need to add at least one speaker to the mock API. Let's create a new describe inside <kbd class="calibre11">GetAll</kbd> but separate from <kbd class="calibre11">No Speakers Exist</kbd>.</p>
<pre class="calibre19">describe('Speaker Listing', () =&gt; {<br class="title-page-name"/>   it('returns speakers', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     service.create({});<br class="title-page-name"/> <br class="title-page-name"/>     // act<br class="title-page-name"/>     let promise = service.getAll();<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     return promise.then((result) =&gt; {<br class="title-page-name"/>       expect(result).to.have.lengthOf(1);<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">We have added, as part of the setup for this test, a reference to a <kbd class="calibre11">Create</kbd> method. This method does not yet exist and our test can't pass without it. So, we need to temporarily ignore this test and write tests for <kbd class="calibre11">Create</kbd>. We can ignore this test by skipping it.</p>
<pre class="calibre19">it.skip('returns speakers', () =&gt; {</pre>
<p class="calibre2">Now, we can write a new describe block inside the <kbd class="calibre11">After Initialization</kbd> block for <kbd class="calibre11">Create</kbd>.</p>
<pre class="calibre19">describe('Create', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(service.create).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">And to make the test pass we add the <kbd class="calibre11">Create</kbd> method to the mock service class.</p>
<pre class="calibre19">class MockSpeakerService {<br class="title-page-name"/>   create() {<br class="title-page-name"/>     <br class="title-page-name"/>   }<br class="title-page-name"/> …</pre>
<p class="calibre2">We could, from this point, write a few tests to add validation logic to the <kbd class="calibre11">Create</kbd> method. However, we don't currently have any scenarios that reference a <kbd class="calibre11">Create</kbd> method on the API. Since this method exists only for testing purposes, we are going to leave it alone with just an exists test. Let's move back to our scenario test.</p>
<p class="calibre2">Now that <kbd class="calibre11">Create</kbd> exists, we should receive the failure that the test is expecting, which is that we expected a length of 1 but instead we have a length of 0. Remove skip from the test and verify.</p>
<p class="calibre2">To make this test pass, we essentially have to implement the basic logic for create and make a modification to <kbd class="calibre11">getAll</kbd>.</p>
<pre class="calibre19">class MockSpeakerService {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     this._speakers = [];<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   create(speaker) {<br class="title-page-name"/>     this._speakers.push(speaker);<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getAll() {<br class="title-page-name"/>     return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>       setTimeout(() =&gt; {<br class="title-page-name"/>         resolve(Object.assign([], this._speakers));<br class="title-page-name"/>       }, 0);<br class="title-page-name"/>     });<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">We can consider the current tests sufficient to move forward and start testing our data flow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Get All Speakers action</h1>
                
            
            <article>
                
<p class="calibre2">To begin testing with Redux, there are a few testing entry points we could start with. We could begin by testing actions, reducers, or even interactions with the store. The store tests would be more integration tests and we want to concentrate on unit tests in this chapter. That leaves actions and reducers. Either is a fine place to start, but we will start with actions because they are extremely simple and uncomplicated as a concept for testing.</p>
<p class="calibre2">The action that we need right now is one to request the retrieval of speaker information; in essence, a get all speakers action. As stated earlier, actions can be extremely simple; however, we have an issue in that our get all speakers service call is asynchronous. Actions were not really designed to handle asynchronous calls. For that reason, let’s start with something a little bit simpler and we will come back to this problem after we understand how to test a normal action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing a standard action</h1>
                
            
            <article>
                
<p class="calibre2">We will need an action to notify Redux that we have the speakers after they have been loaded. There is no reason why we can't start there. So, let's write a test for the successful retrieval of speakers.</p>
<pre class="calibre19">import { expect } from 'chai';<br class="title-page-name"/> <br class="title-page-name"/> describe('Speaker Actions', () =&gt; {<br class="title-page-name"/>   describe('Sync Actions', () =&gt; {<br class="title-page-name"/>     describe('Get Speakers Success', () =&gt; {<br class="title-page-name"/>       it('exists', () =&gt; {<br class="title-page-name"/>         expect(getSpeakersSuccess).to.exist;<br class="title-page-name"/>       });<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Running this test should fail. To make the test pass, define a function named <kbd class="calibre11">getSpeakersSuccess</kbd>.</p>
<pre class="calibre19">function getSpeakersSuccess() {<br class="title-page-name"/> }</pre>
<p class="calibre2">Because of the simplicity of a typical action, our next test will essentially test the functionality of the action. We could break this into multiple tests, but all we are really doing is asserting on the structure of the data returned. Concerning the single assert rule, we are still only asserting one thing.</p>
<pre class="calibre19">it('is created with correct data', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const speakers = [{<br class="title-page-name"/>     id: 'test-speaker',<br class="title-page-name"/>     firstName: 'Test',<br class="title-page-name"/>     lastName: 'Speaker'<br class="title-page-name"/>   }];<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const result = getSpeakersSuccess(speakers);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(result.type).to.equal(GET_SPEAKERS_SUCCESS);<br class="title-page-name"/>   expect(result.speakers).to.have.lengthOf(1);<br class="title-page-name"/>   expect(result.speakers).to.deep.equal(speakers);<br class="title-page-name"/> });</pre>
<p class="calibre2">To make this test pass, we need to make significant changes to our current implementation of the <kbd class="calibre11">getSpeakersSuccess</kbd> function.</p>
<pre class="calibre19">const GET_SPEAKERS_SUCCESS = 'GET_SPEAKERS_SUCCESS';<br class="title-page-name"/> <br class="title-page-name"/> function getSpeakersSuccess(speakers) {<br class="title-page-name"/>   return { type: GET_SPEAKERS_SUCCESS, speakers: speakers };<br class="title-page-name"/> }</pre>
<p class="calibre2">In Redux, actions have an expected format. They must contain a type property and usually contain some data structure. In the case of <kbd class="calibre11">getSpeakersSuccess,</kbd> our type is a constant, <kbd class="calibre11">GET_SPEAKERS_SUCCESS</kbd>, and the data is an array of speakers passed into the action. To make them available to the application, let's move the action and the constant into their own files. We need a <kbd class="calibre11">speakerActions</kbd> file and an <kbd class="calibre11">actionTypes</kbd> file,</p>
<p class="calibre2"><kbd class="calibre11">src/actions/speakerActions.js</kbd>:</p>
<pre class="calibre19">import * as types from '../reducers/actionTypes';<br class="title-page-name"/> <br class="title-page-name"/> export function getSpeakersSuccess(speakers) {<br class="title-page-name"/>   return { type: types.GET_SPEAKERS_SUCCESS, speakers: speakers };<br class="title-page-name"/> }</pre>
<p class="calibre2"><kbd class="calibre11">src/reducers/actionTypes.js</kbd>:</p>
<pre class="calibre19">export const GET_SPEAKERS_SUCCESS = 'GET_SPEAKERS_SUCCESS';</pre>
<p class="calibre2">Add import statements to the test and all the tests should pass. For a typical action, this is the format for testing. The placement of the action types in the reducers folder is for dependency inversion reasons. From a SOLID standpoint, the reducers are defining a contract of interaction, which is represented by the action types. The actions are fulfilling that contract.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing a thunk</h1>
                
            
            <article>
                
<p class="calibre2">Because the <kbd class="calibre11">getSpeakersSuccess</kbd> action is intended to be the resulting action of a successful service call, we need a special kind of action to represent the service call itself. Redux does not inherently support asynchronous actions, as stated before. So, we need some other way to accomplish communication with the backend. Thankfully, Redux does support middleware and much middleware has been designed to add asynchronous capability to Redux. We are going to use <kbd class="calibre11">redux-thunk</kbd> for simplicity.</p>
<p class="calibre2">To start the next test, we need to first import <kbd class="calibre11">redux-thunk</kbd> and <kbd class="calibre11">redux-mock-store</kbd> to our speaker action tests.</p>
<pre class="calibre19">import thunk from 'redux-thunk';<br class="title-page-name"/> import configureMockStore from 'redux-mock-store';</pre>
<p class="calibre2">Then we can test the getting speakers.</p>
<pre class="calibre19">describe('Async Actions', () =&gt; {<br class="title-page-name"/>   describe('Get Speakers', () =&gt; {<br class="title-page-name"/>     it('exists', () =&gt; {<br class="title-page-name"/>       expect(speakerActions.getSpeakers).to.exist;<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">As usual, we start with a test for existence. And, as usual, it is fairly easy to make this test pass. In the speaker actions file, add a definition for the <kbd class="calibre11">getSpeakers</kbd> function and export it.</p>
<pre class="calibre19">export function getSpeakers() {<br class="title-page-name"/> }</pre>
<p class="calibre2">The next test is slightly more complicated than the tests we have been working on, so we will explain it in rather more detail.</p>
<p class="calibre2">The first thing we will need to do is configure a mock store and add the thunk middleware. We need to do this because to properly test a thunk we will have to pretend that Redux is actually running so that we can dispatch our new action and retrieve the results. So, let's add our mock store configuration to the <kbd class="calibre11">Async Actions</kbd> <kbd class="calibre11">describe</kbd>:</p>
<pre class="calibre19">const middleware = [thunk];<br class="title-page-name"/> let mockStore;<br class="title-page-name"/> <br class="title-page-name"/> beforeEach(() =&gt; {<br class="title-page-name"/>   mockStore = configureMockStore(middleware);<br class="title-page-name"/> });</pre>
<p class="calibre2">Now that we have a store available to us, we are ready to begin writing the test.</p>
<pre class="calibre19">it('creates GET_SPEAKERS_SUCCESS when loading speakers', () =&gt; {<br class="title-page-name"/>  // arrange<br class="title-page-name"/>  const speaker = {<br class="title-page-name"/>    id: 'test-speaker',<br class="title-page-name"/>    firstName: 'Test',<br class="title-page-name"/>    lastName: 'Speaker'<br class="title-page-name"/>  };<br class="title-page-name"/> <br class="title-page-name"/>  const expectedActions = speakerActions.getSpeakersSuccess([speaker]);<br class="title-page-name"/>  const store = mockStore({<br class="title-page-name"/>    speakers: []<br class="title-page-name"/>  });</pre>
<p class="calibre2">In the arrange, we are configuring a bare minimum speaker. Then, we call the action we previously tested to build the proper data structure. Finally, we define a mock store and its initial state.</p>
<pre class="calibre19">  // act<br class="title-page-name"/>   return store.dispatch(speakerActions.getSpeakers()).then(() =&gt; {<br class="title-page-name"/>     const actions = store.getActions();<br class="title-page-name"/>  <br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(actions[0].type).to.equal(types.GET_SPEAKERS_SUCCESS);<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Now, when testing asynchronously in Mocha, we can return a promise and Mocha will automatically know that test is asynchronous. Our assertions, for asynchronous tests, go in the resolve or the reject function of the promise. In the case of the get speaker action, we are going to assume a successful server interaction and test the resolved promise.</p>
<p class="calibre2">Because we are not returning anything from our <kbd class="calibre11">getSpeakers</kbd> action, the <kbd class="calibre11">mockStore</kbd> throws an error stating that the action may not be an undefined. To move the test forward, we must return something. To move in the direction of using a <kbd class="calibre11">thunk</kbd>, we need to return a function.</p>
<pre class="calibre19">export function getSpeakers() {<br class="title-page-name"/>   return function(dispatch) {<br class="title-page-name"/>   };<br class="title-page-name"/> };</pre>
<p class="calibre2">Adding the return of a function that does nothing else moves the test failure message forward and now presents us with a failure to read the property <kbd class="calibre11">then</kbd> of undefined. So, now we need to return a promise from our action. We already have the service endpoint built in the mock API service, so let's call that now.</p>
<pre class="calibre19">export function getSpeakers() {<br class="title-page-name"/>   return function(dispatch) {<br class="title-page-name"/>     return new MockSpeakerService().getAll().then(speakers =&gt; {<br class="title-page-name"/>       dispatch(getSpeakersSuccess(speakers))<br class="title-page-name"/>     }).catch(err =&gt; {<br class="title-page-name"/>       throw(err);<br class="title-page-name"/>     });<br class="title-page-name"/>   };<br class="title-page-name"/> }</pre>
<p class="calibre2">Now the test passes and we have written our first test dealing with thunks. As you can see, both the test and the code to pass the test are fairly easy to write.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Get All Speakers reducer</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have tested the actions related to getting all the speakers, it's time to move on to testing the reducers. As usual, let's begin with an exists test.</p>
<pre class="calibre19">describe('Speaker Reducers', () =&gt; {<br class="title-page-name"/>   describe('Speakers Reducer', () =&gt; {<br class="title-page-name"/>     it('exists', () =&gt; {<br class="title-page-name"/>       expect(speakersReducer).to.exist;<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">To make this test pass, all we need to do is define a function named <kbd class="calibre11">speakersReducer</kbd>.</p>
<pre class="calibre19">function speakersReducer() {<br class="title-page-name"/> }</pre>
<p class="calibre2">Our next test will check the functionality of the reducer.</p>
<pre class="calibre19">it('Loads Speakers', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const initialState = [];<br class="title-page-name"/> <br class="title-page-name"/>   const speaker = {<br class="title-page-name"/>     id: 'test-speaker',<br class="title-page-name"/>     firstName: 'Test',<br class="title-page-name"/>     lastName: 'Speaker'<br class="title-page-name"/>   };<br class="title-page-name"/>   const action = actions.getSpeakersSuccess([speaker]);<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const newState = speakersReducer(initialState, action);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(newState).to.have.lengthOf(1);<br class="title-page-name"/>   expect(newState[0]).to.deep.equal(speaker);<br class="title-page-name"/> });</pre>
<p class="calibre2">This test is larger than we normally prefer, so let's walk through it. In the arrange, we configure the initial state and create an action result consisting of an array of a single speaker. When a reducer is called, the previous state of the application and the result of an action are passed to it. In this case, we start with an empty array and the modification is the addition of a single speaker.</p>
<p class="calibre2">Next, in the <em class="calibre12">Act</em> section of the test, we call the reducer passing in the <kbd class="calibre11">initialState</kbd> and the result of our action call. The reducer returns a new state for us to use in the application.</p>
<p class="calibre2">Lastly, in the assert, we expect that the new state consists of a single speaker and that the speaker has the same data as the speaker we created for the action.</p>
<p class="calibre2">To make the test pass we need to handle the action being passed into the reducer.</p>
<pre class="calibre19">function speakersReducer(state = [], action) {<br class="title-page-name"/>   switch(action.type) {<br class="title-page-name"/>     case types.GET_SPEAKERS_SUCCESS:<br class="title-page-name"/>       return action.speakers;<br class="title-page-name"/>     default:<br class="title-page-name"/>       return state;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">Because, in an application using Redux, reducers are called for every action, we need to determine what to do for any action that is not the action we want to handle. The proper response in those cases is to simply return the state with no modification.</p>
<p class="calibre2">For the action type that we do want to handle, in this case we are returning the actions speakers array. In other reducers, we might combine the initial state with the actions result, but for get speakers success we want to replace the state with the value we receive.</p>
<p class="calibre2">The last step, now that all our tests are passing, is to extract the speaker reducer from the test file and move it to <kbd class="calibre11">speakerReducer.js</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Speaker listing component</h1>
                
            
            <article>
                
<p class="calibre2">Another piece of the application that we can test is the components. There are two types of component in a typical React + Redux application. We have container and presentational components.</p>
<p class="calibre2">Container components don't typically hold any real HTML in them. The render function for a container component simply references a single presentational component.</p>
<p class="calibre2">Presentational components don't typically have any business logic in them. They receive properties and display those properties.</p>
<p class="calibre2">In our journey from the back-end to the front-end, we have been covering the retrieval and updating of data. Next, let's look at the container component that will use this data.</p>
<p class="calibre2">Our container component is going to be a simple one. Let's start with the typical existence test.</p>
<pre class="calibre19">import { expect } from 'chai';<br class="title-page-name"/>import { SpeakersPage } from './SpeakersPage';<br class="title-page-name"/> <br class="title-page-name"/> describe('Speakers Page', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(SpeakersPage).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Simple and straightforward; now to make it pass.</p>
<pre class="calibre19">export class SpeakersPage {<br class="title-page-name"/> }</pre>
<p class="calibre2">Next is the render function of the component.</p>
<pre class="calibre19">import React from 'react';<br class="title-page-name"/>import Enzyme, { mount, shallow } from 'enzyme';<br class="title-page-name"/>import Adapter from 'enzyme-adapter-react-16';<br class="title-page-name"/>import { SpeakersPage } from './SpeakersPage';<br class="title-page-name"/> <br class="title-page-name"/> describe('Render', () =&gt; {<br class="title-page-name"/>   beforeEach(() =&gt; {<br class="title-page-name"/>      Enzyme.configure({ adapter: new Adapter() });<br class="title-page-name"/>   });<br class="title-page-name"/><br class="title-page-name"/>   it('renders', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     const props = {<br class="title-page-name"/>       speakers: [{ <br class="title-page-name"/>         id: 'test-speaker', <br class="title-page-name"/>         firstName:'Test', <br class="title-page-name"/>         lastName:'Speaker' <br class="title-page-name"/>       }]<br class="title-page-name"/>     };<br class="title-page-name"/> <br class="title-page-name"/>     // act  <br class="title-page-name"/>     const component = shallow(&lt;SpeakersPage { ...props } /&gt;);<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(component.find('SpeakerList')).to.exist;                 <br class="title-page-name"/>     expect(component.find('SpeakerList').props().speakers)<br class="title-page-name"/>       .to.deep.equal(props.speakers);<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">This test introduces some new concepts. Starting at the act portion of the test. We are using Enzyme's shallow render. A shallow render will render the React component but not the component's children. In this case, we are expecting that a <kbd class="calibre11">SpeakerList</kbd> component exists and that this component is rendering it. The Enzyme adapter configuration is shown here, but it can also be moved to <kbd class="calibre11">test.js</kbd> after the tests pass.</p>
<p class="calibre2">We are also checking the props to make sure we pass the speakers into the presentational component. To make this test pass, we must make modifications to the <kbd class="calibre11">SpeakersPage</kbd> component, but we must also create a <kbd class="calibre11">SpeakerList</kbd> component. Let's do that now.</p>
<pre class="calibre19">export class SpeakersPage extends Component {<br class="title-page-name"/>   render() {<br class="title-page-name"/>     return (<br class="title-page-name"/>       &lt;SpeakerList speakers={this.props.speakers} /&gt;<br class="title-page-name"/>     );<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">And then in a new file, we need to add the <kbd class="calibre11">SpeakerList</kbd>.</p>
<pre class="calibre19">export const SpeakerList = ({speakers}) =&gt; {}</pre>
<p class="calibre2">You may have noticed that our container component doesn't have any logic. In fact, all it does is render the <kbd class="calibre11">SpeakerList</kbd> component. If that is all it does, why is it a container component? The reason is that this component is going to be a Redux-connected component. We want to keep the Redux code in our business logic and out of our display components. So, we are treating this as a higher order component and just using it to pass data through to the presentational components. Later, when we get to the speaker detail component you will see a container component with a little business logic.</p>
<p class="calibre2">For now, our <kbd class="calibre11">SpeakerList</kbd> component looks a little anemic and doesn't really work as part of a React Redux app. Time to test our presentational components.</p>
<pre class="calibre19">describe('Speaker List', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(SpeakerList).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Because of the last test, this test will automatically pass. Normally we would not write this test if we followed to progression what we just did. In reality, what we should have done is ignore the previous test, create this test, and then create the <kbd class="calibre11">SpeakerList</kbd> component. After which, we could have re-enabled the previous test and gotten it to pass.</p>
<p class="calibre2">The next step is to test that a message of no speakers available is rendered when the speakers array is empty.</p>
<pre class="calibre19">function setup(props) {<br class="title-page-name"/>   const componentProps = {<br class="title-page-name"/>     speakers: props.speakers || []<br class="title-page-name"/>   };<br class="title-page-name"/> <br class="title-page-name"/>   return shallow(&lt;SpeakerList {...componentProps} /&gt;);<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> describe('On Render', () =&gt; {<br class="title-page-name"/>   describe('No Speakers Exist', () =&gt; {<br class="title-page-name"/>     it('renders no speakers message', () =&gt; {<br class="title-page-name"/>       // arrange<br class="title-page-name"/>       const speakers = [];<br class="title-page-name"/> <br class="title-page-name"/>       // arrange<br class="title-page-name"/>       const component = setup({speakers});<br class="title-page-name"/> <br class="title-page-name"/>       // assert<br class="title-page-name"/>       expect(component.find('#no-speakers').text())<br class="title-page-name"/>         .to.equal('No Speakers Available.');<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">For this test, we created a helper function to initialize the component with the props that we need. To make the test pass we just need to return a <kbd class="calibre11">div</kbd> with the correct text.</p>
<pre class="calibre19">export const SpeakerList = ({speakers}) =&gt; {<br class="title-page-name"/>   return (<br class="title-page-name"/>     &lt;div&gt;<br class="title-page-name"/>     &lt;h1&gt;Speakers&lt;/h1&gt;<br class="title-page-name"/>     &lt;div id="no-speakers"&gt;No Speakers Available.&lt;/div&gt;<br class="title-page-name"/>     &lt;/div&gt;<br class="title-page-name"/>   );<br class="title-page-name"/> };</pre>
<p class="calibre2">While we are only testing for the <kbd class="calibre11">no-speakers</kbd> <kbd class="calibre11">div</kbd>, we can have decoration that we decide not to test. In this case, we want a header on the page. Our tests should pass regardless.</p>
<p class="calibre2">So, now we are ready to test for when speakers do exist.</p>
<pre class="calibre19">describe('Speakers Exist', () =&gt; {<br class="title-page-name"/>   it('renders a table when speakers exist', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     const speakers = [{<br class="title-page-name"/>       id: 'test-speaker-1',<br class="title-page-name"/>       firstName: 'Test',<br class="title-page-name"/>       lastName: 'Speaker 1'<br class="title-page-name"/>     }, {<br class="title-page-name"/>       id: 'test-speaker-2',<br class="title-page-name"/>       firstName: 'Test',<br class="title-page-name"/>       lastName: 'Speaker 2'<br class="title-page-name"/>     }];<br class="title-page-name"/> <br class="title-page-name"/>     // act<br class="title-page-name"/>     const component = setup({speakers});<br class="title-page-name"/> <br class="title-page-name"/>     // assert        <br class="title-page-name"/>     expect(component.find('.speakers')<br class="title-page-name"/>       .children()).to.have.lengthOf(2);<br class="title-page-name"/>     expect(component.find('.speakers')<br class="title-page-name"/>       .childAt(0).type().name).to.equal('SpeakerListRow');<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">In this test, we check for two things. We want the correct number of speaker rows to display and we want them to be rendered by a new <kbd class="calibre11">SpeakerListRow</kbd> component.</p>
<pre class="calibre19">export const SpeakerList = ({speakers}) =&gt; {<br class="title-page-name"/>   let contents = &lt;div&gt;Error!&lt;/div&gt;;<br class="title-page-name"/> <br class="title-page-name"/>   if(speakers.length === 0) {<br class="title-page-name"/>     contents = &lt;div id="no-speakers"&gt;No Speakers Available.&lt;/div&gt;;<br class="title-page-name"/>   } else {<br class="title-page-name"/>     contents = (<br class="title-page-name"/>       &lt;table className="table"&gt;<br class="title-page-name"/>         &lt;thead&gt;<br class="title-page-name"/>           &lt;tr&gt;<br class="title-page-name"/>             &lt;th&gt;Name&lt;/th&gt;<br class="title-page-name"/>             &lt;th&gt;&lt;/th&gt;<br class="title-page-name"/>           &lt;/tr&gt;<br class="title-page-name"/>         &lt;/thead&gt;<br class="title-page-name"/>         &lt;tbody className="speakers"&gt;<br class="title-page-name"/>           { <br class="title-page-name"/>             speakers.map(speaker =&gt; <br class="title-page-name"/>               &lt;SpeakerListRow key={speaker.id} speaker={speaker} /&gt;) <br class="title-page-name"/>           }<br class="title-page-name"/>         &lt;/tbody&gt;<br class="title-page-name"/>       &lt;/table&gt;<br class="title-page-name"/>     );<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   return (<br class="title-page-name"/>     &lt;div&gt;<br class="title-page-name"/>     &lt;h1&gt;Speakers&lt;/h1&gt;<br class="title-page-name"/>     { contents }<br class="title-page-name"/>     &lt;/div&gt;<br class="title-page-name"/>   );<br class="title-page-name"/> };</pre>
<p class="calibre2">The component code has changed significantly because of our latest test. We had to add some logic, and we also added a default error case if somehow the content were to make it through without being assigned.</p>
<p class="calibre2">There is one more component to make the code work correctly for this section. We are not going to test that component in this book, though. The component has no logic inside it and is left as an exercise to you to create.</p>
<p class="calibre2">In order to create that component, it would be nice if the application ran. Right now, we have not wired up Redux so the application won't render anything. Let's walk through the configuration we are using for Redux now.</p>
<p class="calibre2">Inside <kbd class="calibre11">index.js</kbd>, we need to add a few items to let Redux work. Your index should look similar to this:</p>
<pre class="calibre19"> import React from 'react';<br class="title-page-name"/> import ReactDOM from 'react-dom';<br class="title-page-name"/> import {BrowserRouter} from 'react-router-dom';<br class="title-page-name"/> import {Provider} from 'react-redux';<br class="title-page-name"/> import registerServiceWorker from './registerServiceWorker';<br class="title-page-name"/> import configureStore from './store/configureStore';<br class="title-page-name"/> import { getSpeakers } from './actions/speakerActions';<br class="title-page-name"/> import 'bootstrap/dist/css/bootstrap.min.css';<br class="title-page-name"/> import './index.css';<br class="title-page-name"/> import App from './components/App.js';<br class="title-page-name"/> <br class="title-page-name"/> const store = configureStore();<br class="title-page-name"/> store.dispatch(getSpeakers());<br class="title-page-name"/> <br class="title-page-name"/> ReactDOM.render(<br class="title-page-name"/>   &lt;Provider store={store}&gt;<br class="title-page-name"/>     &lt;BrowserRouter&gt;<br class="title-page-name"/>       &lt;App/&gt;<br class="title-page-name"/>     &lt;/BrowserRouter&gt;<br class="title-page-name"/>   &lt;/Provider&gt;,<br class="title-page-name"/>   document.getElementById('root')<br class="title-page-name"/> );<br class="title-page-name"/> <br class="title-page-name"/> registerServiceWorker();</pre>
<p class="calibre2">The two parts that we have added are the Redux store including an initial call to dispatch the load speakers action, and markup to add the Redux provider.</p>
<p class="calibre2">Where your other routes are defined, you will need to add routes for the speaker section. We are placing the Routes in <kbd class="calibre11">App.js</kbd>.</p>
<pre class="calibre19">&lt;Route exact path='/speakers/:id' component={SpeakerDetailPage}/&gt;<br class="title-page-name"/>&lt;Route exact path='/speakers' component={SpeakersPage}/&gt;</pre>
<p class="calibre2">Lastly, we have to convert our component to a Redux component. Add the following lines to the bottom of your speaker's page component file.</p>
<pre class="calibre19">import { connect } from 'react-redux';<br class="title-page-name"/><br class="title-page-name"/>function mapStateToProps(state) {<br class="title-page-name"/>   return {<br class="title-page-name"/>     speakers: state.speakers<br class="title-page-name"/>   };<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> function mapDispatchToProps(dispatch) {<br class="title-page-name"/>   return bindActionCreators(speakerActions, dispatch);<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> export default connect(mapStateToProps, mapDispatchToProps)(SpeakersPage);</pre>
<p class="calibre2">Starting at the bottom of the code sample, the connect function is provided by Redux and will wire up all the Redux functionality into our component. The two functions passed in, <kbd class="calibre11">mapStateToProps</kbd> and <kbd class="calibre11">mapDispatchToProps</kbd>, are passed in as a way to populate state and provide actions for our component to execute.</p>
<p class="calibre2">Inside <kbd class="calibre11">mapDispatchToProps</kbd> we are calling <kbd class="calibre11">bindActionCreators</kbd>; this is another Redux-provided function and will give us an object containing all the actions. By returning that object directly from <kbd class="calibre11">mapDispatchToProps,</kbd> we are adding the actions directly to props. We could also create our own object containing an actions property and then assign the result of the <kbd class="calibre11">bindActionCreators</kbd> to that property.</p>
<p class="calibre2">Anywhere inside the application that references <kbd class="calibre11">SpeakersPage</kbd> can now be changed to just <kbd class="calibre11">SpeakersPage</kbd>, which will grab our new default export. Do not make this change in the tests. Inside the tests we still want the named import.</p>
<p class="calibre2">With those things done, we should be able to run the application and navigate to the speakers route. If you have not added a link to the speakers route, now would be a good time so that you don't have to type the route directly in the URL every time.</p>
<p class="calibre2">Once you arrive at the speakers route, you should see that there are no speakers and we receive our message. We need some way to populate the speakers so that we can test the listing. We will cover a way to populate speakers in the next section. For now, in the mock API modify the constructor to contain a couple of speakers. Modifying the service in this way will cause a few tests to break, so after you have visually verified that everything is looking good, be sure to remove or at least comment out the code you added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Speaker detail</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have our speakers listing nicely, it would be nice to be able to view a bit more information about a specific speaker. Let's look at the tests involved in retrieving and viewing a speakers-detailed information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding to the mock API Service</h1>
                
            
            <article>
                
<p class="calibre2">In the mock API, we need to add a call to get the details for a specific speaker. We can assume that the speaker has an ID field that we can use to gather that information. As usual, let's start our tests with a simple exists check. We will need to add a new describe inside the <kbd class="calibre11">After Initialization</kbd> describe for getting a speaker by ID.</p>
<pre class="calibre19">describe('Get Speaker By Id', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(service.getById).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">To make this test pass, we need to add a method to the mock API.</p>
<pre class="calibre19">getById() {<br class="title-page-name"/> }</pre>
<p class="calibre2">Now, we can write a test to verify the functionality we expect when a matching speaker cannot be found. The functionality we want in this case is for a <kbd class="calibre11">SPEAKER_NOT_FOUND</kbd> message to be shown once we get to the user interface. At the mock API level, we could assume that a 404 will be sent from the server. We can respond from the mock API with an error containing the <kbd class="calibre11">SPEAKER_NOT_FOUND</kbd> type. This is similar to the way an action would be used.</p>
<p class="calibre2">Let’s create another describe for our speaker not found scenario.</p>
<pre class="calibre19">describe('Speaker Does Not Exist', () =&gt; {<br class="title-page-name"/>   it('SPEAKER_NOT_FOUND error is generated', () =&gt; {<br class="title-page-name"/>     // act<br class="title-page-name"/>     const promise = service.getById('fake-speaker');<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     return promise.catch((error) =&gt; {<br class="title-page-name"/>       expect(error.type).to.equal(errorTypes.SPEAKER_NOT_FOUND);<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">You may have noticed that we snuck in <kbd class="calibre11">errorTypes</kbd>. The <kbd class="calibre11">errorTypes</kbd> are in their own folder, but build exactly like <kbd class="calibre11">actionTypes</kbd>.</p>
<p class="calibre2">To make this test pass, we must add a rejected promise to our mock API.</p>
<pre class="calibre19">getById(id) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     setTimeout(() =&gt; {<br class="title-page-name"/>         reject({ type: errorTypes.SPEAKER_NOT_FOUND });<br class="title-page-name"/>     }, 0);<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">We don't have any tests that enforce a positive result from this method, so we can reject every time for now.</p>
<p class="calibre2">That brings us to our next test. What happens if the speaker is found? Ideally, the speaker and all the speakers details would be delivered back to the caller. Let's write that test now.</p>
<pre class="calibre19">describe('Speaker Exists', () =&gt; {<br class="title-page-name"/>   it('returns the speaker', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     const speaker = { id: 'test-speaker' };<br class="title-page-name"/>     service.create(speaker);<br class="title-page-name"/> <br class="title-page-name"/>     // act<br class="title-page-name"/>     let promise = service.getById('test-speaker');<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     return promise.then((speaker) =&gt; {<br class="title-page-name"/>       expect(speaker).to.not.be.null;<br class="title-page-name"/>       expect(speaker.id).to.equal('test-speaker');<br class="title-page-name"/>     });<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">To pass this test we will have to add some logic to the production code.</p>
<pre class="calibre19">getById(id) {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     setTimeout(() =&gt; {<br class="title-page-name"/>       let speaker = this._speakers.find(x =&gt; x.id === id);<br class="title-page-name"/>       if(speaker) {<br class="title-page-name"/>         resolve(Object.assign({}, speaker));<br class="title-page-name"/>       } else {<br class="title-page-name"/>         reject({ type: errorTypes.SPEAKER_NOT_FOUND });<br class="title-page-name"/>       }<br class="title-page-name"/>     }, 0);<br class="title-page-name"/>   });<br class="title-page-name"/> }</pre>
<p class="calibre2">To make the test pass, we need to first check to see if the speaker exists. If the speaker does exist, we return that speaker. If the speaker does not exist, we reject the promise and provide our error result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Get Speaker action</h1>
                
            
            <article>
                
<p class="calibre2">We now have a mock API to call that behaves the way we want it to. Next on our list is creating the actions that will handle the results from our mock API. For the process of getting a speaker, we will need two actions. One of the actions will notify the application about a successful find and provide the found speaker to the reducers. The other action will notify the application about the failure to find the requested speaker.</p>
<p class="calibre2">Let's write a test to confirm its existence. This test should be inside the synchronous tests section of the speaker actions tests. We will also want to create a new describe for the get speaker success action.</p>
<pre class="calibre19">describe('Find Speaker Success', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(speakerActions.getSpeakerSuccess).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">To make this test pass, we just create the action function.</p>
<pre class="calibre19">export function getSpeakerSuccess() {<br class="title-page-name"/> }</pre>
<p class="calibre2">Now we need to verify the return value of the action. Just like our get all speakers success action, the get speaker success action will receive the found speaker and return an object containing a type and the speaker data. Let's write the test for that now.</p>
<pre class="calibre19">it('is created with correct data', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const speaker = {<br class="title-page-name"/>     id: 'test-speaker',<br class="title-page-name"/>     firstName: 'Test',<br class="title-page-name"/>     lastName: 'Speaker'<br class="title-page-name"/>   };<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const result = speakerActions.getSpeakerSuccess(speaker);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(result.type).to.equal(types.GET_SPEAKER_SUCCESS);<br class="title-page-name"/>   expect(result.speaker).to.deep.equal(speaker);<br class="title-page-name"/> });</pre>
<p class="calibre2">This test is fairly straightforward so let's look at the production code to pass it.</p>
<pre class="calibre19">export function getSpeakerSuccess(speaker) {<br class="title-page-name"/>   return { type: types.GET_SPEAKER_SUCCESS, speaker: speaker };<br class="title-page-name"/> }</pre>
<p class="calibre2">Again, this code is straightforward. Next, let's handle the failure action. We will need to create a new describe for this test as well.</p>
<pre class="calibre19">describe('Get Speaker Failure', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(speakerActions.getSpeakerFailure).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Nothing new here, you should be starting to get a feel for the flow by now. Let's keep going and make this test pass.</p>
<pre class="calibre19">export function getSpeakerFailure() {<br class="title-page-name"/> }</pre>
<p class="calibre2">The data we should be getting back for a failure to retrieve a speaker should be the <kbd class="calibre11">SPEAKER_NOT_FOUND</kbd> error type. In our next test, we will receive that error and create the action type from it.</p>
<pre class="calibre19">it('is created with correct data', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const error = {<br class="title-page-name"/>     type: errorTypes.SPEAKER_NOT_FOUND<br class="title-page-name"/>   };<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const result = speakerActions.getSpeakerFailure(error);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(result.type).to.equal(types.GET_SPEAKER_FAILURE);<br class="title-page-name"/>   expect(result.error).to.deep.equal(error);<br class="title-page-name"/> });</pre>
<p class="calibre2">Making this test pass is very similar to the implementation for the other synchronous actions.</p>
<pre class="calibre19">export function getSpeakerFailure(error) {<br class="title-page-name"/>   return { type: types.GET_SPEAKER_FAILURE, error: error }<br class="title-page-name"/> }</pre>
<p class="calibre2">Looking at the code, there is one important difference. This code doesn't have speaker data. The reason is because this action will need to be handled by a different reducer, an error reducer. We will create the error reducer and error component shortly. But first, we need to create the asynchronous action that will make the call to the mock API.</p>
<p class="calibre2">In testing the asynchronous action to get speakers, we should start with the failure case. In this case, the failure case is <kbd class="calibre11">GET_SPEAKER_FAILURE</kbd>. Here is a test to ensure the correct secondary action is triggered.</p>
<pre class="calibre19">it('creates GET_SPEAKER_FAILURE when speaker is not found', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const speakerId= 'not-found-speaker';<br class="title-page-name"/>   const store = mockStore({<br class="title-page-name"/>     speaker: {}<br class="title-page-name"/>   });<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   return (<br class="title-page-name"/>     store.dispatch(speakerActions.getSpeaker(speakerId)).then(() =&gt; {<br class="title-page-name"/>       const actions = store.getActions();<br class="title-page-name"/> <br class="title-page-name"/>       // assert<br class="title-page-name"/>       console.log(actions);<br class="title-page-name"/>       expect(actions[0].type).to.equal(types.GET_SPEAKER_FAILURE);<br class="title-page-name"/>     })<br class="title-page-name"/>   );<br class="title-page-name"/> });</pre>
<p class="calibre2">The code to make this test pass is similar to the code we have for getting all the speakers.</p>
<pre class="calibre19">export function getSpeaker(speakerId) {<br class="title-page-name"/>   return function(dispatch) {<br class="title-page-name"/>     return new MockSpeakerService().getById(speakerId).catch(err =&gt; {<br class="title-page-name"/>       dispatch(getSpeakerFailure(err));<br class="title-page-name"/>     });<br class="title-page-name"/>   };<br class="title-page-name"/> }</pre>
<p class="calibre2">Here, we have called the mock API and we expect it to reject the promise, resulting in the dispatching of the <kbd class="calibre11">getSpeakerFailure</kbd> action.</p>
<p class="calibre2">Our next test is the successful retrieval of a specific speaker. We do have a problem though. You may have noticed that we are creating a new <kbd class="calibre11">MockSpeakerService</kbd> for each asynchronous action. This is problematic because it prevents us from pre-populating our mock API with values for the test. Later in the development of this application, the back-end will be ready and we will want to point our front-end code to a real back-end. We can't do that as long as we are directly referencing and creating a mock API service.</p>
<p class="calibre2">There are many solutions for the problem that we are facing. We will explore making a factory to decide what back-end to provide for us. A factory will also allow us to treat the mock API as a singleton. Treating the service as a singleton will allow us to prepopulate the service as part of the test setup.</p>
<p class="calibre2">In the services folder, let's create a new set of tests for creating the factory class and functionality.</p>
<pre class="calibre19">import { expect } from 'chai';<br class="title-page-name"/>import { ServiceFactory as factory } from './serviceFactory';<br class="title-page-name"/> <br class="title-page-name"/>describe('Service Factory', () =&gt; {<br class="title-page-name"/>  it('exits', () =&gt; {<br class="title-page-name"/>    expect(factory).to.exist;<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre2">All we need to make this test pass is a class definition.</p>
<pre class="calibre19">export class ServiceFactory {<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we want a method to create a speaker service. Add a new describe to the factory tests.</p>
<pre class="calibre19">describe('Create Speaker Service', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(factory.createSpeakerService).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Notice the way we are using the factory, we are not initializing it. We want the factory to be a class with static methods. Having static functions will give us the singleton ability we want.</p>
<pre class="calibre19">static createSpeakerService() {<br class="title-page-name"/> }</pre>
<p class="calibre2">Next up, we want to ensure that the <kbd class="calibre11">createSpeakerService</kbd> factory method will provide us with an instance of the mock API.</p>
<pre class="calibre19">it('returns a speaker service', () =&gt; {<br class="title-page-name"/>   // act<br class="title-page-name"/>   let result = factory.createSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(result).to.be.an.instanceof(MockSpeakerService);<br class="title-page-name"/> });</pre>
<p class="calibre2">Making this test pass is easy, just return a new mock speaker service from the factory method.</p>
<pre class="calibre19">static createSpeakerService() {<br class="title-page-name"/>   return new MockSpeakerService();<br class="title-page-name"/> }</pre>
<p class="calibre2">This isn't a singleton though. So, we still have some more work to do here. Let's write one more test in the factory before we swap out all the service calls in the application for factory calls. To verify that something is a singleton, we have to make sure it is the same throughout the application. We can do that by doing reference comparisons on successive calls. Another option is to create the speaker service, add a speaker to it, create a new speaker service, and try to pull the speaker from the second service. If we have done things correctly, the second option is the most thorough. We will do the first option here, but it would be a good exercise to do the second option on your own.</p>
<pre class="calibre19">it('returns the same speaker service', () =&gt; {<br class="title-page-name"/>   // act<br class="title-page-name"/>   let service1 = factory.createSpeakerService();<br class="title-page-name"/>   let service2 = factory.createSpeakerService();<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(service1).to.equal(service2);<br class="title-page-name"/> });</pre>
<p class="calibre2">To pass the test, we must ensure that the same instance of the speaker service is returned every time.</p>
<pre class="calibre19">export default class ServiceFactory {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     this._speakerService = null;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   static createSpeakerService() {<br class="title-page-name"/>     return this._speakerService = this._speakerService || <br class="title-page-name"/>                                   new MockSpeakerService();<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">The factory will now return the current value or create a new speaker service if the current value is <kbd class="calibre11">null</kbd>.</p>
<p class="calibre2">The next step is to go to each place where we are directly instantiating a mock speaker service and swap it out with a factory call. We will leave that as an exercise for you to do, but know that going forward we will assume that it has been done.</p>
<p class="calibre2">Now that we have the factory swapped out and it is generating a singleton, we can write the next action test. We want to test a successful retrieval of a speaker.</p>
<pre class="calibre19">it('creates GET_SPEAKER_SUCCESS when speaker is found', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const speaker = {<br class="title-page-name"/>     id: 'test-speaker',<br class="title-page-name"/>     firstName: 'Test',<br class="title-page-name"/>     lastName: 'Speaker'<br class="title-page-name"/>   };<br class="title-page-name"/>   const store = mockStore({ speaker: {} });<br class="title-page-name"/>   const expectedActions = [<br class="title-page-name"/>     speakerActions.getSpeakerSuccess([speaker.id])<br class="title-page-name"/>   ];<br class="title-page-name"/>   let service = factory.createSpeakerService();<br class="title-page-name"/>   service.create(speaker);<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   return store.dispatch(<br class="title-page-name"/>     speakerActions.getSpeaker('test-speaker')).then(() =&gt; {<br class="title-page-name"/>       const actions = store.getActions();<br class="title-page-name"/> <br class="title-page-name"/>       // assert<br class="title-page-name"/>       expect(actions[0].type).to.equal(types.GET_SPEAKER_SUCCESS);<br class="title-page-name"/>       expect(actions[0].speaker.id).to.equal('test-speaker');<br class="title-page-name"/>       expect(actions[0].speaker.firstName).to.equal('Test');<br class="title-page-name"/>       expect(actions[0].speaker.lastName).to.equal('Speaker');<br class="title-page-name"/>     });<br class="title-page-name"/> });</pre>
<p class="calibre2">There is a lot going on in this test; let's walk through it. First in the arrange, we create a speaker object to be placed in the service, and used for the assertions. Next, still in the arrange, we create and configure the mock store. Lastly, in the arrange, we create the speaker service and we create our test speaker using the service.</p>
<p class="calibre2">Next, in the act, we dispatch a call to get the test speaker. Remember, this call is asynchronous. So, we must subscribe to then.</p>
<p class="calibre2">When the promise is resolved, we store the actions in a variable and assert that the first action has the correct type and payload.</p>
<p class="calibre2">Now to make this test pass we need to make some modifications to the <kbd class="calibre11">getById</kbd> method on the service.</p>
<pre class="calibre19">export function getSpeaker(speakerId) {<br class="title-page-name"/>   return function(dispatch) {<br class="title-page-name"/>     return factory.createSpeakerService().getById(speakerId).then(<br class="title-page-name"/>       speaker =&gt; {<br class="title-page-name"/>         dispatch(getSpeakerSuccess(speaker));<br class="title-page-name"/>       }).catch(err =&gt; {<br class="title-page-name"/>         dispatch(getSpeakerFailure(err));<br class="title-page-name"/>       });<br class="title-page-name"/>   };<br class="title-page-name"/> }</pre>
<p class="calibre2">All we have really done here is add a then to handle the resolving of the promise. We now have, for all current intents and purposes, a working speaker service. Let's move on to creating the reducers for handling the get speaker actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Get Speaker reducer</h1>
                
            
            <article>
                
<p class="calibre2">To handle the actions related to getting a speaker, we must create two reducers. The first reducer is extremely similar to the reducer we made for the get speakers actions. The second is going to need to be slightly different and is for handling the error case.</p>
<p class="calibre2">Let's begin with the simplest of the two and create the speaker reducer.</p>
<pre class="calibre19">describe('Speaker Reducer', () =&gt; {<br class="title-page-name"/>     it('exists', () =&gt; {<br class="title-page-name"/>       expect(speakerReducer).to.exist;<br class="title-page-name"/>     });<br class="title-page-name"/> });</pre>
<p class="calibre2">Our typical existence test is easily passed.</p>
<pre class="calibre19">export function speakerReducer() {<br class="title-page-name"/> }</pre>
<p class="calibre2">The next test ensures that the reducer updates state properly, and will close out the tests needed for this reducer.</p>
<pre class="calibre19">it('gets a speaker', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const initialState = { id: '', firstName: '', lastName: '' };<br class="title-page-name"/>   const speaker = { id: 'test-speaker', firstName: 'Test', lastName: 'Speaker'};<br class="title-page-name"/>   const action = actions.getSpeakerSuccess(speaker);<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const newState = speakerReducer(initialState, action);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(newState).to.deep.equal(speaker);<br class="title-page-name"/> });</pre>
<p class="calibre2">The changes from this test are the inputs to the reducer, and the output of a state. Let's make this test pass by modeling our reducer after the speakers reducer.</p>
<pre class="calibre19">export function speakerReducer(state = { <br class="title-page-name"/>   id: '', <br class="title-page-name"/>   firstName: '', <br class="title-page-name"/>   lastName: ''<br class="title-page-name"/> }, action) {<br class="title-page-name"/>   switch(action.type) {<br class="title-page-name"/>     case types.GET_SPEAKER_SUCCESS:<br class="title-page-name"/>       return action.speaker;<br class="title-page-name"/>     default:<br class="title-page-name"/>       return state;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">Similar to the speakers reducer, this reducer simply checks the action type for <kbd class="calibre11">GET_SPEAKER_SUCCESS</kbd> and, if found, returns the speaker attached to the action as the new state. Otherwise, we just return the state object we received.</p>
<p class="calibre2">Next up, we need an error reducer.</p>
<pre class="calibre19">describe('Error Reducer', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(errorReducer).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Passing this test is just as easy as all the other existence tests.</p>
<pre class="calibre19">import * as types from './actionTypes';<br class="title-page-name"/>import * as errors from './errorTypes';<br class="title-page-name"/> <br class="title-page-name"/>export function errorReducer() {<br class="title-page-name"/>}</pre>
<p class="calibre2">The error reducer will have some interesting functionality. In the event that an error is received, we want multiple errors to stack up so we won't be replacing the state. Instead, we will be cloning and adding to the state. However, when an action is received that is not an error we will want to clear the errors and allow normal program execution to continue. We will also want to ignore duplicate errors. First, we will handle the error we know about.</p>
<pre class="calibre19">it('returns error state', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const initialState = [];<br class="title-page-name"/>   const error = { type: errorTypes.SPEAKER_NOT_FOUND };<br class="title-page-name"/>   const action = actions.getSpeakerFailure(error);<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const newState = errorReducer(initialState, action);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(newState).to.deep.equal([error]);<br class="title-page-name"/> });</pre>
<p class="calibre2">Our test is slightly different from the previous reducer test. The main difference is that we are wrapping our expected value in an array. We are doing this to meet the need for having multiple errors potentially stack up and display for the user.</p>
<p class="calibre2">To make this test pass we follow the familiar reducer pattern we have been using.</p>
<pre class="calibre19">export function errorReducer(state = [], action) {<br class="title-page-name"/>   switch(action.type) {<br class="title-page-name"/>     case types.GET_SPEAKER_FAILURE:<br class="title-page-name"/>       return [...state, action.error];<br class="title-page-name"/>     default:<br class="title-page-name"/>       return state;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">For the same reasons as stated previously, notice how we use the rest of the parameter syntax to spread the existing state into a new array, effectively cloning state.</p>
<p class="calibre2">We have two more tests for the error reducer; the first is to ensure duplicate errors are not added. The second test will be to clear the errors when a non-error action is called.</p>
<pre class="calibre19">it('ignores duplicate errors', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const error = { type: errorTypes.SPEAKER_NOT_FOUND };<br class="title-page-name"/>   const initialState = [error];<br class="title-page-name"/>   const action = actions.getSpeakerFailure(error);<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const newState = errorReducer(initialState, action);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(newState).to.deep.equal([error]);<br class="title-page-name"/> });</pre>
<p class="calibre2">In the test, to set the condition of having a prepopulated state, all we had to do was modify the <kbd class="calibre11">initialState</kbd> parameter.</p>
<pre class="calibre19">export function errorReducer(state = [], action) {<br class="title-page-name"/>   switch(action.type) {<br class="title-page-name"/>     case types.GET_SPEAKER_FAILURE:<br class="title-page-name"/>       let newState = [...state];<br class="title-page-name"/> <br class="title-page-name"/>       if(newState.every(x =&gt; x.type !== action.error.type)) {<br class="title-page-name"/>         newState.push(action.error);<br class="title-page-name"/>       }<br class="title-page-name"/> <br class="title-page-name"/>       return newState;<br class="title-page-name"/>     default:<br class="title-page-name"/>       return state;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">All we must do to make this test pass is make sure that the error type is not already present in the state array. There are many ways to do this; we have chosen to use the <kbd class="calibre11">every</kbd> function as a check that none of the existing errors match. It is likely that this method is not extremely performant, but there should only be a couple errors at most so it shouldn't be a performance issue.</p>
<p class="calibre2">The next test is to clear the error state when a non-error is received.</p>
<pre class="calibre19">it('clears when a non-error action is received', () =&gt; {<br class="title-page-name"/>   // arrange<br class="title-page-name"/>   const error = { type: errorTypes.SPEAKER_NOT_FOUND };<br class="title-page-name"/>   const initialState = [error];<br class="title-page-name"/>   const action = { type: 'ANY_NON_ERROR' };<br class="title-page-name"/> <br class="title-page-name"/>   // act<br class="title-page-name"/>   const newState = errorReducer(initialState, action);<br class="title-page-name"/> <br class="title-page-name"/>   // assert<br class="title-page-name"/>   expect(newState).to.deep.equal([]);<br class="title-page-name"/> });</pre>
<p class="calibre2">Making this test pass is exceedingly simple. All we have to do is replace the default functionality where the existing state is returned.</p>
<pre class="calibre19">default:<br class="title-page-name"/>   return [];</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Speaker Detail component</h1>
                
            
            <article>
                
<p class="calibre2">We are now ready to create our <kbd class="calibre11">SpeakerDetailPage</kbd>. There isn't much to this component. It will need to be another container component so that it can use the get speaker action. Because it is a container component, we will not be placing any markup directly into this component. The good news for us is that it means our tests will be short and simple.</p>
<p class="calibre2">To get the tests started, create an existence test.</p>
<pre class="calibre19">describe('Speaker Detail Page', () =&gt; {<br class="title-page-name"/>   it('exists', () =&gt; {<br class="title-page-name"/>     expect(SpeakerDetailPage).to.exist;<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">Create a <kbd class="calibre11">SpeakerDetailPage</kbd> file and add a component to it.</p>
<pre class="calibre19">export class SpeakerDetailPage extends Component {<br class="title-page-name"/>   render() {<br class="title-page-name"/>     return (&lt;div&gt;&lt;/div&gt;);<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">The next thing we want to test, the only other thing we can test without directly specifying the design, is that the model is received and somehow makes it to the screen. We only need to test one property of the model for now. We will write a test that shows that the first name of the speaker is displayed.</p>
<pre class="calibre19">describe('Render', () =&gt; {<br class="title-page-name"/>   it('renders', () =&gt; {<br class="title-page-name"/>     // arrange<br class="title-page-name"/>     const props = {<br class="title-page-name"/>       match: { params: { id: 'test-speaker' } },<br class="title-page-name"/>       actions: { getSpeaker: (id) =&gt; { return Promise.resolve(); } },<br class="title-page-name"/>       speaker: { firstName: 'Test' } <br class="title-page-name"/>     };<br class="title-page-name"/> <br class="title-page-name"/>     // act<br class="title-page-name"/>     const component = mount(&lt;SpeakerDetailPage { ...props } /&gt;);<br class="title-page-name"/> <br class="title-page-name"/>     // assert<br class="title-page-name"/>     expect(component.find('first-name').text()).to.contain('Test');<br class="title-page-name"/>   });<br class="title-page-name"/> });</pre>
<p class="calibre2">If you are paying attention, you might have wondered why the get speaker action is just returning an empty resolved promise. We are not attached to Redux, so kicking off the action doesn't trigger a reducer, which doesn't update the store and doesn't trigger a refresh of the component state. We still want to complete the contract of the component in the test setup though and this component will call that function. We could leave this line out, but we will be adding it back as soon as we wire up Redux.</p>
<p class="calibre2">To make the test pass, we will need to make a couple of simple changes in the <kbd class="calibre11">SpeakerDetailPage</kbd> component, and create a whole new component. Following are the changes to this component, but it will be an exercise for you to create the next component. It is only for display and we are testing that it gets populated here so all you have to do is write the presentational component.</p>
<pre class="calibre19">export class SpeakerDetailPage extends Component {<br class="title-page-name"/>   constructor(state, context) {<br class="title-page-name"/>     super(state, context);<br class="title-page-name"/> <br class="title-page-name"/>     this.state = {<br class="title-page-name"/>       speaker: Object.assign({}, this.props.speaker)<br class="title-page-name"/>     };<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   render() {<br class="title-page-name"/>     return (<br class="title-page-name"/>       &lt;SpeakerDetail speaker={this.state.speaker} /&gt;<br class="title-page-name"/>     );<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">The previous code will make the test pass, but now we have to connect the component to Redux. We will be adding a call to the <kbd class="calibre11">getSpeaker</kbd> action, binding to the <kbd class="calibre11">componentWillReceiveProps</kbd> life cycle event, and mapping props and dispatch using the connect function. Here is the final <kbd class="calibre11">SpeakerDetailPage</kbd> component.</p>
<pre class="calibre19">export class SpeakerDetailPage extends Component {<br class="title-page-name"/>   constructor(state, context) {<br class="title-page-name"/>     super(state, context);<br class="title-page-name"/> <br class="title-page-name"/>     this.state = {<br class="title-page-name"/>       speaker: Object.assign({}, this.props.speaker)<br class="title-page-name"/>     };<br class="title-page-name"/> <br class="title-page-name"/>     this.props.actions.getSpeaker(this.props.match.params.id)<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   componentWillReceiveProps(nextProps) {<br class="title-page-name"/>     if(this.props.speaker.id !== nextProps.speaker.id) {<br class="title-page-name"/>       this.setState({ speaker: Object.assign({}, nextProps.speaker) });<br class="title-page-name"/>     }<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   render() {<br class="title-page-name"/>     return (<br class="title-page-name"/>       &lt;SpeakerDetail speaker={this.state.speaker} /&gt;<br class="title-page-name"/>     );<br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> function mapStateToProps(state, ownProps) {<br class="title-page-name"/>   let speaker = { id: '', firstName: '', lastName: '' }<br class="title-page-name"/> <br class="title-page-name"/>   return {<br class="title-page-name"/>     speaker: state.speaker || speaker<br class="title-page-name"/>   };<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> function mapDispatchToProps(dispatch) {<br class="title-page-name"/>   return {<br class="title-page-name"/>     actions: bindActionCreators(speakerActions, dispatch)<br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/> <br class="title-page-name"/> export default  connect(<br class="title-page-name"/>   mapStateToProps,<br class="title-page-name"/>   mapDispatchToProps<br class="title-page-name"/> )(SpeakerDetailPage);</pre>
<p class="calibre2">Now that everything passes the tests, we have one last thing we need to do before we can properly develop further. Earlier we replaced the mock API with a call to a factory. We did this so that the tests could affect the state of the mock API in the actions. That same modification has made it possible to configure a starting point for our application. In the <kbd class="calibre11">index.js</kbd> file, add the following code after the store has been configured; now, when you run the app, you will have speakers available to test the UI with.</p>
<pre class="calibre19">const speakers = [{<br class="title-page-name"/>   id: 'clayton-hunt',<br class="title-page-name"/>   firstName: 'Clayton',<br class="title-page-name"/>   lastName: 'Hunt'<br class="title-page-name"/> }, {<br class="title-page-name"/>   id: 'john-callaway',<br class="title-page-name"/>   firstName: 'John',<br class="title-page-name"/>   lastName: 'Callaway'<br class="title-page-name"/> }];<br class="title-page-name"/> <br class="title-page-name"/> let service = factory.createSpeakerService();<br class="title-page-name"/> speakers.forEach((speaker) =&gt; {<br class="title-page-name"/>   service.create(speaker);<br class="title-page-name"/> });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">That does it for unit-testing a React application, for now. We still don't have an example of testing some kind of input. Try to test and implement a <kbd class="calibre11">CreateSpeakerPage</kbd>. What would you need to do from a React standpoint? What would Redux cause you to do? In this chapter, we have attacked the React components as if they were components. For display-only components, which is what these have been, this approach is probably better. However, for a component with some real functionality you might want to try testing the functionality as a plain old JavaScript class before even attaching it to React. We also left quite a bit of work for you to do in this chapter. Don't be shy about looking at the source related to this chapter if you get lost or need a hint while you are filling in the blanks to complete the code. </p>


            </article>

            
        </section>
    </body></html>