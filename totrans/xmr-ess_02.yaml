- en: Chapter 2. Demystifying Xamarin.iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 消除对 Xamarin.iOS 的神秘感
- en: 'Now that we have a little background on Mono and Xamarin, let''s dive in and
    see how Xamarin.iOS works. This chapter covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Mono 和 Xamarin 有了基本的了解，让我们深入探讨一下 Xamarin.iOS 的工作原理。本章涵盖了以下主题：
- en: Xamarin.iOS and AOT compilation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.iOS 和 AOT 编译
- en: Mono assemblies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono 组件
- en: Xamarin.iOS bindings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.iOS 绑定
- en: Memory management for Xamarin.iOS apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.iOS 应用的内存管理
- en: XIB and storyboard code generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XIB 和故事板代码生成
- en: Xamarin.iOS Designer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.iOS 设计器
- en: Xamarin.iOS and Ahead-of-Time compilation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.iOS 和即时编译
- en: Unlike most Mono or .NET apps, Xamarin.iOS apps are statically compiled, where
    compilation is accomplished through the Mono **Ahead-of-Time** (**AOT**) compilation
    facilities. AOT is used to comply with Apple's requirements, for example, the
    use of iOS apps to compile, refraining from Just-in-Time compilation facilities,
    or running on virtual machines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Mono 或 .NET 应用不同，Xamarin.iOS 应用是静态编译的，编译是通过 Mono 的 **即时编译**（**AOT**）功能完成的。AOT
    用于满足苹果的要求，例如，iOS 应用用于编译，避免使用即时编译功能或在虚拟机上运行。
- en: Use of AOT compilation comes with some limitations regarding the C# language.
    These limitations will be easier to discuss after discussing the approach to binding
    iOS to C# and .NET. This is why we have pushed this topic to the *Limitations
    of using the AOT compilation* section in the later part of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AOT 编译在 C# 语言方面带来了一些限制。在讨论了将 iOS 绑定到 C# 和 .NET 的方法之后，这些限制将更容易讨论。这就是为什么我们将这个主题推到了本章后部分的
    *使用 AOT 编译的限制* 部分。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Additional information about Mono AOT compilation can be found at the following
    link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Mono AOT 编译的更多信息，请参阅以下链接：
- en: '[http://www.mono-project.com/AOT#Full_AOT](http://www.mono-project.com/AOT#Full_AOT)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.mono-project.com/AOT#Full_AOT](http://www.mono-project.com/AOT#Full_AOT)'
- en: Understanding Mono assemblies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Mono 组件
- en: Xamarin.iOS ships with an extended subset of Silverlight and desktop .NET assemblies.
    These libraries provide the .NET runtime library support for developers, including
    namespaces such as `System.IO` and `System.Threading`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 随带一个扩展的 Silverlight 和桌面 .NET 组件集。这些库为开发者提供了 .NET 运行时库支持，包括 `System.IO`
    和 `System.Threading` 等命名空间。
- en: Xamarin.iOS is not binary compatible with assemblies compiled for a different
    profile, meaning your code must be recompiled to generate assemblies that specifically
    target the Xamarin.iOS profile. This is essentially the same thing you have to
    do if you are targeting other profiles such as Silverlight or .NET 4.5.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 与为不同配置编译的组件不兼容，这意味着您的代码必须重新编译以生成针对 Xamarin.iOS 配置的组件。如果您针对其他配置，如
    Silverlight 或 .NET 4.5，也需要做同样的事情。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For a complete list of assemblies that ship with Xamarin.iOS, please refer
    to the following link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关随 Xamarin.iOS 一起提供的组件集的完整列表，请参阅以下链接：
- en: '[http://docs.xamarin.com/guides/ios/under_the_hood/assemblies](http://docs.xamarin.com/guides/ios/under_the_hood/assemblies)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.xamarin.com/guides/ios/under_the_hood/assemblies](http://docs.xamarin.com/guides/ios/under_the_hood/assemblies)'
- en: Xamarin.iOS bindings
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.iOS 绑定
- en: In this section, you will discover one of the main sources of power behind Xamarin.iOS.
    This ships with a set of binding libraries that provides support for iOS development.
    What will follow are some details into each of these bindings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将发现支撑 Xamarin.iOS 的主要力量之一。它附带了一套绑定库，为 iOS 开发提供支持。接下来，我们将详细介绍这些绑定的一些细节。
- en: The design principles
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原则
- en: 'A number of goals or design principles guided the development of the binding
    libraries. These principles are critical to make C# developers productive in an
    iOS development. The following represents a summary of the design principles:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列目标或设计原则指导了绑定库的开发。这些原则对于使 C# 开发者在 iOS 开发中保持高效至关重要。以下是对设计原则的总结：
- en: Allow developers to subclass Objective-C classes in the same way as they subclass
    other .NET classes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发者以与其他 .NET 类相同的方式子类化 Objective-C 类
- en: Provide a way to call arbitrary Objective-C libraries
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供调用任意 Objective-C 库的方法
- en: Transform the common Objective-C tasks into something much easier while making
    the difficult Objective-C tasks possible to complete
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常见的 Objective-C 任务转化为更简单的事情，同时使困难的 Objective-C 任务变得可完成
- en: Expose Objective-C properties as C# properties as well as expose a strongly
    typed API
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Objective-C 属性暴露为 C# 属性，同时暴露强类型 API
- en: Use Native C# types in lieu of Objective-C types when possible
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可能时，使用原生 C# 类型代替 Objective-C 类型
- en: Support both C# events and Objective-C Delegation as well as expose C# delegates
    to Object-C APIs
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 C# 事件和 Objective-C 委托，并将 C# 委托暴露给 Objective-C API
- en: Tip
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This section has provided you with a general idea of the principles to bear
    in mind. If you are curious to find a complete discussion, you can refer to the
    official documentation available at the following link:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节为您提供了需要牢记的原则的一般概念。如果您想找到完整的讨论，可以参考以下链接提供的官方文档：
- en: '[http://docs.xamarin.com/guides/ios/under_the_hood/api_design/](http://docs.xamarin.com/guides/ios/under_the_hood/api_design/)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.xamarin.com/guides/ios/under_the_hood/api_design/](http://docs.xamarin.com/guides/ios/under_the_hood/api_design/)'
- en: C# types and type safety
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 类型与类型安全性
- en: The Xamarin.iOS bindings are designed to use types familiar to C# developers
    and to increase type safety when possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 绑定旨在使用 C# 开发者熟悉的类型，并在可能的情况下提高类型安全性。
- en: 'For example, the API uses C# string instead of `NSString`, meaning the text
    property in `UILabel` is defined in the iOS SDK in the following manner:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，API 使用 C# 字符串而不是 `NSString`，这意味着 `UILabel` 中的文本属性在 iOS SDK 中定义如下：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, this is exposed in Xamarin.iOS as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Xamarin.iOS 中是这样暴露的：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Behind the scenes, the framework takes care of marshaling C# types to the appropriate
    type expected by the iOS SDK.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，框架负责将 C# 类型映射到 iOS SDK 所期望的适当类型。
- en: 'Another example is the treatment of `NSArray`. Rather than exposing weakly
    typed arrays, Xamarin.iOS exposes strongly typed arrays to the following Object-C
    property on `UIView`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是 `NSArray` 的处理。Xamarin.iOS 不是暴露弱类型数组，而是向 `UIView` 的以下 Objective-C 属性暴露强类型数组：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is exposed as a C# property in the following manner:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这以下列方式暴露为 C# 属性：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use of inheritance
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的使用
- en: Xamarin.iOS allows you to extend any Objective-C type in the same manner you
    will extend any C# type and features like calling "base" from overridden methods
    work as predicted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 允许你以扩展任何 C# 类型的方式扩展任何 Objective-C 类型，并且像从重写方法中调用 "base" 这样的功能按预期工作。
- en: Mapping Objective-C delegates
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射 Objective-C 委托
- en: In Objective-C, the delegation design pattern is used extensively to allocate
    responsibility to various objects. Xamarin faced a few inherent challenges in
    mapping iOS delegates to C# and .NET.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，委托设计模式被广泛用于将责任分配给各种对象。Xamarin 在将 iOS 委托映射到 C# 和 .NET 时面临了一些固有的挑战。
- en: 'In Objective-C, delegates in Objective-C are implemented as objects that respond
    to a set of methods. This set of methods is generally defined as a protocol, and
    although it resembles a C# interface, there is in fact a significant difference
    between a C# interface and an Objective-C protocol:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，委托作为响应一组方法的对象来实现。这组方法通常定义为协议，尽管它与 C# 接口相似，但实际上 C# 接口和 Objective-C
    协议之间存在显著差异：
- en: In C#, an object that *implements* an interface is required to implement all
    the methods defined on the interface
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中，实现接口的对象必须实现接口上定义的所有方法
- en: On the other hand, objects in Objective-C that *adopt* a protocol are not required
    to implement the methods of the protocol for the given circumstance
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，在 Objective-C 中，采用协议的对象不需要在给定情况下实现协议的方法
- en: Another challenge is that, in many ways, traditional .NET frameworks have relied
    more heavily on events to accomplish similar capabilities, and the event model
    is much more familiar to .NET developers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是，在许多方面，传统的 .NET 框架更多地依赖于事件来实现类似的功能，并且事件模型对 .NET 开发者来说更为熟悉。
- en: 'With these differences in mind and hoping to make Xamarin.iOS as intuitive
    to C# developers as possible without compromising the iOS architecture, Xamarin.iOS
    provides four different ways to implement delegate functionality:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些差异，并希望尽可能使 Xamarin.iOS 对 C# 开发者来说直观，同时不妥协 iOS 架构，Xamarin.iOS 提供了四种不同的方式来实现委托功能：
- en: Via .NET events
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 .NET 事件
- en: Via .NET properties
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 .NET 属性
- en: Via strongly typed delegates
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过强类型委托
- en: Via weakly typed delegates
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过弱类型委托
- en: Via .NET events
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 .NET 事件
- en: For many types, Xamarin.iOS automatically creates an appropriate delegate and
    forwards delegate calls to corresponding .NET events. This makes the development
    experience very natural to C# and .NET developers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多类型，Xamarin.iOS 自动创建适当的委托并将委托调用转发到相应的 .NET 事件。这使得开发体验对 C# 和 .NET 开发者来说非常自然。
- en: '`UIWebView` is a good example of this. iOS defines `UIWebViewDelegate`, which
    contains a number of methods that a `UIWebView` will forward if a delegate is
    assigned that includes the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`是这一点的良好示例。iOS定义了`UIWebViewDelegate`，其中包含了一系列方法，如果分配了包含以下内容的委托，`UIWebView`将转发这些方法：'
- en: '`webViewDidStartLoad`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webViewDidStartLoad`'
- en: '`webViewDidFinishLoad`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webViewDidFinishLoad`'
- en: '`webView:didFailLoadWithError`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webView:didFailLoadWithError`'
- en: 'What we find in the Xamarin.iOS class `MonoTouch.UIKit.UIWebView` are three
    events that correspond to the following methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS类`MonoTouch.UIKit.UIWebView`中，我们发现有三个事件对应以下方法：
- en: '`LoadStarted`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadStarted`'
- en: '`LoadFinished`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadFinished`'
- en: '`LoadError`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadError`'
- en: Via .NET properties
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过.NET属性
- en: 'Although events have the advantage of having multiple subscribers, they come
    with their own limitations. Specifically, this could be where events cannot have
    a return type. In situations where a delegate method must return a value, delegate
    properties are used. The following example shows you how to use a delegate property
    for `UITextField`. In this example, an anonymous method is assigned to the delegate
    property `ShouldReturn` on `UITextField`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管事件具有拥有多个订阅者的优势，但它们也带来自己的限制。具体来说，这可能就是事件不能有返回类型的地方。在需要返回值的委托方法的情况下，使用委托属性。以下示例展示了如何使用委托属性`UITextField`。在这个例子中，一个匿名方法被分配给`UITextField`上的委托属性`ShouldReturn`：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Via strongly typed delegates
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过强类型委托
- en: If events or delegate properties have not been provided or if you would just
    rather work with a delegate, you will be pleased to hear that Xamarin.iOS provides
    a set of .NET classes that correspond to each iOS delegate. These classes contain
    a definition for each method defined on the corresponding protocol. Methods that
    require implementations are defined as abstract and methods that are optional
    are defined as virtual. To use one of these delegates, a developer simply creates
    a new class that inherits from the desired delegate and overrides the methods
    that need to be implemented.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供事件或委托属性，或者你更愿意使用委托，你将很高兴地听到Xamarin.iOS提供了一套.NET类，对应于每个iOS委托。这些类包含对应协议上定义的每个方法的定义。需要实现的方法被定义为抽象的，而可选的方法被定义为虚拟的。要使用这些委托之一，开发者只需创建一个新的类，继承自所需的委托，并重写需要实现的方法。
- en: 'For an example of using strongly typed delegate, we will turn to `UITableViewDataSource`.
    This is the protocol iOS defines to populate a `UITableView` instance. The following
    example demonstrates a data source that can be used to populate `UITableView`
    with phone numbers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明如何使用强类型委托，我们将转向`UITableViewDataSource`。这是iOS定义的用于填充`UITableView`实例的协议。以下示例演示了一个可以用于用电话号码填充`UITableView`的数据源：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have created the delegate, we need to assign it to a `UITableView`
    instance. The property for the `UITableViewDataSource` delegate is named `Source`
    with the following code that shows you how to make the assignment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了委托，我们需要将其分配给一个`UITableView`实例。`UITableViewDataSource`委托的属性名为`Source`，以下代码展示了如何进行分配：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Via weakly typed delegates
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过弱类型委托
- en: Lastly, Xamarin.iOS provides you with a way to use weakly typed delegates. Unfortunately,
    this method requires a bit more work for the developer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Xamarin.iOS为你提供了一种使用弱类型委托的方法。不幸的是，这种方法需要开发者做更多的工作。
- en: 'In Xamarin.iOS, weak delegates can be created using any class that inherits
    from `NSObject`. When creating a weak delegate, you are being handed the responsibility
    to properly decorate your class using the `Export` attribute, which effectively
    teaches iOS how the methods are mapped. The following example shows a weak delegate
    with the appropriate attribute specifications:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS中，可以使用继承自`NSObject`的任何类创建弱委托。在创建弱委托时，你将负责使用`Export`属性正确装饰你的类，这实际上教会iOS如何映射方法。以下示例展示了具有适当属性规范的弱委托：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last few steps assign the weak delegate to a `UITableView` instance. By
    Xamarin.iOS convention, weak delegate property names always begin with `Weak`.
    The following example shows you how to assign the weak data source delegate:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个步骤将弱委托分配给一个`UITableView`实例。按照Xamarin.iOS的约定，弱委托属性名称总是以`Weak`开头。以下示例展示了如何分配弱数据源委托：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once a weak delegate has been assigned, any assigned strong delegates will cease
    to receive calls.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦弱委托被分配，任何已分配的强委托将不再接收调用。
- en: Creating binding libraries
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建绑定库
- en: 'There might be times when you are required to create your own binding library
    for an Objective-C library that is not delivered as part of Xamarin.iOS and can''t
    be found in the Xamarin component store. Xamarin provides a great deal of guidance
    to create bindings as well as an automated tool to help with some of the drudgery
    work. The following links provide guidance to create custom bindings for Objective-C
    libraries:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，你需要为Xamarin.iOS未提供且在Xamarin组件商店找不到的Objective-C库创建自己的绑定库。Xamarin提供了大量的指导来创建绑定，以及一个自动化的工具来帮助处理一些繁琐的工作。以下链接提供了创建Objective-C库自定义绑定的指导：
- en: '| Type of information | URL to access it |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 信息类型 | 访问它的URL |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| General binding information | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/)
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 一般绑定信息 | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/)
    |'
- en: '| Use of the Objective Sharpie automation tool | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/)
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| Objective Sharpie自动化工具的使用 | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/)
    |'
- en: '| Binding types reference | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/)
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 绑定类型参考 | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/)
    |'
- en: Memory management
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: When it comes to releasing resources, Xamarin.iOS has this covered for you through
    **garbage collector** (**GC**), which does this on your behalf. On top of this,
    all objects that are derived from `NSObject` utilize the `System.IDisposable`
    interface so that developers have some control over it when the memory is released.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到释放资源时，Xamarin.iOS通过**垃圾回收器**（**GC**）为你处理这些，它代表你完成这些工作。除此之外，所有从`NSObject`派生的对象都利用`System.IDisposable`接口，这样当内存释放时，开发者可以对其有所控制。
- en: '`NSObject` not only implements the `IDisposable` interface, but also follows
    the .NET dispose pattern. The `IDisposable` interface only requires a single method
    to be implemented, `Dispose()`. The dispose pattern requires an additional method
    to be implemented, `Dispose(bool disposing)`. The disposing parameter indicates
    whether the method is being called from the `Dispose()` method, in which case
    the value is `true`, or from the `Finalize` method, in which case the value is
    `false`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSObject`不仅实现了`IDisposable`接口，还遵循.NET销毁模式。`IDisposable`接口只需要实现一个方法，即`Dispose()`。销毁模式需要实现一个额外的`Dispose(bool
    disposing)`方法。销毁参数指示该方法是否从`Dispose()`方法调用，在这种情况下值为`true`，或者从`Finalize`方法调用，在这种情况下值为`false`。'
- en: 'The disposing parameter is intended to be used to determine if managed objects
    should be freed. If the value is `true`, the managed objects should be released.
    Unmanaged objects should be released regardless of the value. The following code
    demonstrates what should be present in the `Dispose()` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁参数旨在用于确定是否应该释放托管对象。如果值为`true`，则应释放托管对象。无论值如何，都应释放非托管对象。以下代码演示了`Dispose()`方法中应该包含的内容：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take note of the call to `Dispose(bool disposing)` with a value of `true`.
    Conveniently, the `Dispose()` method is implemented for you by the framework as
    a virtual method on `NSObject`. The following code demonstrates an implementation
    of the `Dispose(bool disposing)` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Dispose(bool disposing)`的调用，其值为`true`。方便的是，框架为你实现了`Dispose()`方法，作为`NSObject`上的虚拟方法。以下代码演示了`Dispose(bool
    disposing)`方法的实现：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, notice the call to `base.Dispose(disposing)`. This call is very important
    as it deals with resources managed within the framework itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意对`base.Dispose(disposing)`的调用。这个调用非常重要，因为它处理框架内部管理的资源。
- en: Why the fuss? Why not clean up everything in `Dispose()`? The answer lies in
    the garbage collector. The order in which the garbage collector destroys objects
    is not defined and thus is unpredictable and subject to change. The .NET dispose
    pattern helps prevent the finalizer from calling `Dispose()` on objects that have
    already been disposed of.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这么大的麻烦？为什么不在 `Dispose()` 中清理一切？答案在于垃圾回收器。垃圾回收器销毁对象的顺序未定义，因此不可预测且可能发生变化。.NET
    释放模式有助于防止终结器在已释放的对象上调用 `Dispose()`。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can read more about the .NET dispose pattern at the following link:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于 .NET 释放模式的信息：
- en: '[http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx](http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx](http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx)'
- en: Disposing of a managed object renders it useless. Even though references to
    the object might still exist, you need to structure your software with the assumption
    that an object that has been disposed of is no longer valid. In some cases, an
    `ObjectDisposedException` will be thrown when accessing methods of a disposed
    object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 释放托管对象使其变得无用。即使该对象的引用可能仍然存在，您也需要以假设已释放的对象不再有效的方式来构建您的软件。在某些情况下，当访问已释放对象的成员方法时，将抛出
    `ObjectDisposedException`。
- en: Disposing of objects
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的释放
- en: Anytime you have an object that is holding substantial resources and is no longer
    required, call the `Dispose()` method. The GC is convenient and fairly sophisticated
    but might not have a complete picture as to the amount of resources a specific
    object has allocated, particularly if those resources are associated with unmanaged
    objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候您有一个持有大量资源且不再需要的对象，请调用 `Dispose()` 方法。GC 很方便且相当复杂，但可能无法完全了解特定对象分配的资源量，尤其是如果这些资源与非托管对象相关。
- en: Keeping objects around
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持对象
- en: To prevent an object from being destroyed, you simply need to be sure there
    is at least one reference to the object maintained. Once an object's reference
    count reaches `0`, the GC is all happy to call the `Dispose()` method on it and
    the object is no longer usable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止对象被销毁，您只需确保至少有一个对象引用被维护。一旦对象的引用计数达到 `0`，GC 就会高兴地调用其上的 `Dispose()` 方法，并且对象将不再可用。
- en: Limitations of using the AOT compilation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AOT 编译的限制
- en: 'As we mentioned earlier in this chapter, some limitations come with the use
    of the AOT compilation. The following sections outline the limitations imposed
    by Xamarin.iOS due to the use of the AOT compilation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提到的，使用 AOT 编译有一些限制。以下各节概述了由于使用 AOT 编译而由 Xamarin.iOS 施加的限制：
- en: 'No generic subclasses of `NSObject` are allowed. The following will not be
    allowed since `UIViewController` is a subclass of `NSObject`:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许 `NSObject` 的泛型子类。以下将不允许，因为 `UIViewController` 是 `NSObject` 的子类：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'P/Invoke is not supported in generic classes, so the following is not supported
    in Xamarin.iOS:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P/Invoke 在泛型类中不受支持，因此以下在 Xamarin.iOS 中不受支持：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Property.SetInfo()` on `a Nullable<T> Type` is not supported. Using Reflection''s
    `Property.SetInfo()` to set the value on a `Nullable<T>` is not currently supported.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Nullable<T> 类型` 上不支持 `Property.SetInfo()`。使用反射的 `Property.SetInfo()` 在 `Nullable<T>`
    上设置值目前不受支持。
- en: 'No dynamic code generation. The iOS kernel prevents an app from generating
    code dynamically and thus Xamarin.iOS imposes the following limitations:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许动态代码生成。iOS 内核阻止应用程序动态生成代码，因此 Xamarin.iOS 强制实施以下限制：
- en: Neither `System.Reflection.Emit` nor `System.Runtime.Remoting` is available
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是 `System.Reflection.Emit` 还是 `System.Runtime.Remoting` 都不可用
- en: No support to create types dynamically
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持动态创建类型
- en: Reverse callbacks must be registered with the runtime at compile time
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向回调必须在编译时在运行时注册
- en: 'There is a further limitation for reverse callbacks. In Mono, you can pass
    C# delegates to unmanaged code rather than passing a function pointer. Use of
    AOT imposes some limitations on this:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于反向回调，还有进一步的限制。在 Mono 中，您可以将 C# 委托传递给非托管代码，而不是传递函数指针。AOT 的使用对此施加了一些限制：
- en: Callback methods must be flagged with the Mono attribute `MonoPInvokeCallbackAttribute`
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调方法必须使用 Mono 属性 `MonoPInvokeCallbackAttribute` 标记
- en: Callback methods must be static; there is no support for instance methods
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调方法必须是静态的；不支持实例方法
- en: Runtime features disabled
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用的运行时功能
- en: 'The following features are disabled in Xamarin.iOS:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin.iOS 中禁用了以下功能：
- en: Profiler
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器
- en: The `Reflection.Emit` functionality
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflection.Emit` 功能'
- en: The `Reflection.Emit.Save` functionality
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflection.Emit.Save`功能'
- en: COM bindings
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COM绑定
- en: The JIT engine
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT引擎
- en: The metadata verifier (since there is no JIT)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据验证器（由于没有JIT）
- en: Generating code for XIB and storyboard files
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为XIB和Storyboard文件生成代码
- en: The Apple Interface Builder is a designer built into Xcode that allows for visual
    design of a user interface. The use of the Interface Builder is optional; user
    interfaces can be completely built using iOS APIs. The definitions created by
    the Interface Builder are saved in either XIB or storyboard files with the difference
    being that the XIB files tend to contain a single view. Storyboards, on the other
    hand, contain a set of views along with the transitions or segues between the
    views.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Apple Interface Builder是Xcode中内置的设计器，允许进行用户界面的可视化设计。使用Interface Builder是可选的；用户界面可以完全使用iOS
    API构建。Interface Builder创建的定义保存在XIB或Storyboard文件中，区别在于XIB文件通常包含单个视图。另一方面，Storyboard包含一组视图以及视图之间的过渡或segues。
- en: Xamarin Studio works in conjunction with Xcode to support the UI design. When
    a storyboard or XIB file is double-clicked on within Xamarin Studio, Xcode is
    launched to facilitate the design of the UI. Once the changes are saved in Xcode
    and you switched back to Xamarin Studio, C# code is generated to support the UI
    design captured in Xcode. The following sections describe this process in more
    detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio与Xcode协同工作以支持UI设计。当在Xamarin Studio中双击Storyboard或XIB文件时，将启动Xcode以方便设计UI。一旦在Xcode中保存更改并切换回Xamarin
    Studio，就会生成C#代码以支持在Xcode中捕获的UI设计。以下各节将更详细地描述此过程。
- en: Generated classes
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成的类
- en: 'Xamarin Studio generates two files for each custom class found in an XIB file
    or a storyboard file, a designer file, and a non-designer file. For instance,
    a view controller named `LoginViewController` will cause the following files to
    be generated:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio为XIB文件或Storyboard文件中找到的每个自定义类生成两个文件，一个设计器文件和一个非设计器文件。例如，名为`LoginViewController`的视图控制器将导致以下文件生成：
- en: '`LoginViewController.cs`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginViewController.cs`'
- en: '`LoginViewController.designer.cs`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginViewController.designer.cs`'
- en: These files are generated after the changes have been saved in Xcode, and Xamarin
    Studio gains focus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是在Xcode中保存更改后生成的，并且Xamarin Studio获得焦点。
- en: Designer files
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计器文件
- en: 'Designer files contain a partial class definition for custom classes found
    in the XIB or storyboard file with properties being created for outlets and partial
    methods for the actions that are found. The following example is for a view controller
    with two `UITextField` controls and a single `UIButton` control:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器文件包含在XIB或Storyboard文件中找到的自定义类的部分类定义，为输出创建属性，并为找到的操作创建部分方法。以下示例是一个具有两个`UITextField`控件和一个单个`UIButton`控件的视图控制器：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Designer files are automatically updated once an XIB or storyboard file has
    been altered. As a result, they should not be modified manually because any changes
    will be lost once Xamarin Studio updates them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦修改了XIB或Storyboard文件，设计器文件将自动更新。因此，不应手动修改它们，因为任何更改在Xamarin Studio更新它们时都将丢失。
- en: Non-designer files
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非设计器文件
- en: 'Designer files are used alone but in conjunction with a non-designer file.
    The non-designer file contains a partial class specification, which completes
    the class defined in its corresponding designer file. The non-designer files identify
    the base class, defines constructors that are required to instantiate the class,
    and provides a place to implement functionality either by providing implementations
    for partial methods or by overriding virtual methods on the base class. The following
    example shows a non-designer file with an override and partial method implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器文件单独使用，但与一个非设计器文件结合使用。非设计器文件包含部分类规范，它完成了其对应设计器文件中定义的类。非设计器文件标识基类，定义了实例化类所需的构造函数，并提供了一个位置来实现功能，无论是通过为部分方法提供实现，还是通过在基类上重写虚拟方法。以下示例显示了一个具有重写和部分方法实现的非设计器文件：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the partial method implementation in this file is for a method generated
    in the designer file in response to find an action defined in the corresponding
    XIB or storyboard files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此文件中部分方法的实现是为了响应在相应的XIB或Storyboard文件中定义的操作而生成的设计器文件中的方法。
- en: Changes made to the non-designer file will not be lost as these files are only
    created the first time Xamarin Studio encounters the new custom class and are
    not subsequently updated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对非设计器文件所做的更改不会丢失，因为这些文件仅在Xamarin Studio首次遇到新自定义类时创建，并且随后不会更新。
- en: Outlets properties
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出属性
- en: Designer classes contain private properties, which correspond to outlets defined
    on the custom class that can then be used from the `CodeBehind` class found in
    the non-designer file. If you need to make these properties public, all you need
    to do is add the accessor properties to the non-designer file similar to how you
    will for any given private field.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器类包含私有属性，这些属性对应于在自定义类上定义的输出，然后可以从非设计器文件中找到的 `CodeBehind` 类中使用。如果你需要将这些属性设置为公共的，你只需要将访问器属性添加到非设计器文件中，就像为任何给定的私有字段做的那样。
- en: Action properties
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作属性
- en: 'Designer files have the property of containing partial methods that are associated
    to all of the actions defined on the custom class. You should note that these
    methods do not contain an implementation and they serve a dual purpose:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器文件具有包含与自定义类上定义的所有动作相关联的部分方法的属性。你应该注意，这些方法不包含实现，它们具有双重作用：
- en: Their first purpose is that when you insert partial into the class body of the
    non-designer file, Xamarin Studio will offer to autocomplete the signatures of
    all non-implemented partial methods, which allows developers to implement logic
    for actions.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的第一个目的是，当你将部分代码插入非设计器文件的类体中时，Xamarin Studio 将会提供自动完成所有未实现的部分方法签名，这允许开发者实现动作的逻辑。
- en: Their other purpose is that their signatures have an attribute applied to them,
    exposing them to the Objective-C world. Consequently, they can be invoked once
    the corresponding action is triggered in iOS.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的另一个目的是它们的签名上应用了一个属性，使它们暴露给 Objective-C 世界。因此，一旦在 iOS 中触发相应的动作，它们就可以被调用。
- en: Xamarin.iOS Designer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.iOS 设计器
- en: 'Xamarin provides an alternative to Apple''s Interface Builder. Xamarin.iOS
    Designer is an add-in for the Xamarin Studio environment that adds full drag-and-drop
    user interface design for iOS storyboards all from within Xamarin Studio. Xamarin.iOS
    Designer provides the following key features:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 提供了 Apple 的 Interface Builder 的替代方案。Xamarin.iOS 设计器是用于 Xamarin Studio
    环境的一个插件，它为 iOS storyboards 添加了全功能的拖放用户界面设计，所有操作都可以在 Xamarin Studio 内完成。Xamarin.iOS
    设计器提供了以下关键特性：
- en: '**Compatible storyboard format**: As you will expect, Xamarin.iOS Designer
    creates storyboards in the same format used by Xcode and the iOS SDK, so switching
    back to Xcode at some point is allowed'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容的 storyboard 格式**：正如你所期望的，Xamarin.iOS 设计器创建的 storyboards 使用的是与 Xcode 和
    iOS SDK 相同的格式，因此在某些时候切换回 Xcode 是允许的'
- en: '**Eliminates syncing with Xcode**: Using Xamarin.iOS Designer eliminates the
    need to use Xcode in the development process along with the synchronization problems
    that can occur between Xamarin Studio and Xcode'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除与 Xcode 的同步**：使用 Xamarin.iOS 设计器消除了在开发过程中使用 Xcode 的需要，以及可能发生在 Xamarin Studio
    和 Xcode 之间的同步问题'
- en: '**Easy properties**: Xamarin.iOS Designer automatically creates properties
    that reference controls as they are dropped on a view'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单属性**：Xamarin.iOS 设计器在控件被拖放到视图中时自动创建引用控件的属性'
- en: '**Easy event handlers**: Xamarin.iOS Designer provides a more intuitive means
    to create event handlers, which work in a very similar way as Visual Studio works
    on other UI frameworks such as Silverlight and WPF'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的事件处理程序**：Xamarin.iOS 设计器提供了一个更直观的方式来创建事件处理程序，它们的工作方式与 Visual Studio 在其他
    UI 框架（如 Silverlight 和 WPF）上的工作方式非常相似'
- en: '**Custom controls**: User can create their own custom UI controls that are
    accessible from within the toolbox panel'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义控件**：用户可以在工具箱面板中创建自己的自定义 UI 控件'
- en: Xamarin.iOS Designer can only be used to create storyboards. If you prefer or
    need to work with XIB files, you will need to continue to work with Xcode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 设计器只能用于创建 storyboards。如果你更喜欢或需要处理 XIB 文件，你将需要继续使用 Xcode。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we presented the essentials of Xamarin.iOS architecture and
    tried to demystify the way Xamarin.iOS allows developers to create great native
    apps for iOS using C# and Mono. While we have obviously not covered the entire
    iOS SDK, we have described the approach and principles used to build Xamarin.iOS.
    With this knowledge in place, you should be in a good position to move forward
    with Xamarin.iOS development and resolve issues as they arise.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Xamarin.iOS 架构的要点，并试图揭示 Xamarin.iOS 允许开发者使用 C# 和 Mono 为 iOS 创建优秀原生应用的方式。虽然我们显然没有涵盖整个
    iOS SDK，但我们已经描述了构建 Xamarin.iOS 所使用的方法和原则。有了这些知识，你应该能够顺利地继续进行 Xamarin.iOS 开发，并在出现问题时解决它们。
- en: In the next chapter, we will try to accomplish the same goals for Xamarin.Android.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试为 Xamarin.Android 实现相同的目标。
