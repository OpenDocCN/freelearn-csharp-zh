- en: Working with Animations
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 与动画一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Scaling an element while rendering
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染时缩放元素
- en: Rotating an element while rendering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染时旋转元素
- en: Skewing an element while rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染时倾斜元素
- en: Moving an element while rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染时移动元素
- en: Grouping multiple transforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对多个变换进行分组
- en: Creating property-based animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于属性的动画
- en: Creating path-based animations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于路径的动画
- en: Creating key-frame-based animations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于关键帧的动画
- en: Adding easing effects to animations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为动画添加缓动效果
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Windows Presentation Foundation** (**WPF**) is well-known for its rich **graphical
    user interface** (**GUI**) and layout features, which enables you to create stunning
    desktop applications. Animations can be used to create an attractive **user interface**
    (**UI**) by just animating UI elements, transformations, screen transitions, and
    more.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows Presentation Foundation** (**WPF**) 因其丰富的 **图形用户界面** (**GUI**) 和布局功能而闻名，这使得您能够创建令人惊叹的桌面应用程序。只需通过动画化UI元素、变换、屏幕过渡等，就可以使用动画来创建吸引人的
    **用户界面** (**UI**)。'
- en: In this chapter, we will learn how to create animations using **storyboards**.
    We will first start with recipes that will help you to understand various transformations,
    such as `ScaleTransform`, `RotateTransform`, `SkewTransform`, and `TranslateTransform`.
    Then we will proceed towards recipes to learn various kinds of animations, such
    as property-based animations, path-based animations, and key-frame-based animations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用**故事板**创建动画。我们首先从帮助您理解各种变换的食谱开始，例如`ScaleTransform`、`RotateTransform`、`SkewTransform`和`TranslateTransform`。然后我们将继续学习各种类型的动画，例如基于属性的动画、基于路径的动画和基于关键帧的动画。
- en: At the end, we will learn various easing functions introduced in WPF 4, which
    can be used to create easing effects on your linear animations to give them a
    non-linear look.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习WPF 4中引入的各种缓动函数，这些函数可用于在您的线性动画上创建缓动效果，使其看起来非线性。
- en: Scaling an element while rendering
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在渲染时缩放元素
- en: The `ScaleTransform` is used to scale (stretch or shrink) an object horizontally
    or vertically. The `ScaleX` property is used to specify how much to stretch or
    shrink the object along the *X* axis, whereas the `ScaleY` property is used to
    specify how much to stretch or shrink the object along the *Y* axis. Using the
    `CenterX` and `CenterY` properties, the operations are performed based on the
    center pointing at certain coordinate points.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScaleTransform`用于水平或垂直缩放（拉伸或缩小）对象。`ScaleX`属性用于指定沿 *X* 轴拉伸或缩放对象的程度，而`ScaleY`属性用于指定沿
    *Y* 轴拉伸或缩放对象的程度。使用`CenterX`和`CenterY`属性，操作基于指向特定坐标点的中心点。'
- en: In this recipe, we will learn how to stretch or shrink an element using the
    scale transform.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用缩放变换拉伸或缩小元素。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, open your Visual Studio instance and create a new WPF App project named
    `CH08.ScaleTransformDemo`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您的Visual Studio实例，创建一个名为`CH08.ScaleTransformDemo`的新WPF App项目。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to add `Image` controls to the application UI, and apply
    `ScaleTransform` to scale the image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`Image`控件添加到应用程序UI中，并应用`ScaleTransform`以缩放图像：
- en: From the Solution Explorer, right-click on the project node and create a new
    folder. Name it as `Images`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击项目节点，创建一个新的文件夹。将其命名为`Images`。
- en: 'Now, right-click on the `Images` folder and add an existing image from your
    system. Name it as `image1.png`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击`Images`文件夹，并从您的系统中添加一个现有的图片。将其命名为`image1.png`：
- en: '![](img/367d1722-3e93-4762-a52a-2986094fb139.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/367d1722-3e93-4762-a52a-2986094fb139.png)'
- en: Navigate to the `MainWindow.xaml` page and replace the default `Grid` with a
    horizontal `StackPanel`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MainWindow.xaml`页面，并将默认的`Grid`替换为水平`StackPanel`。
- en: 'Inside the `StackPanel`, add the following `Grid` with two image controls.
    Both, the image controls should be pointing to the `Images/image1.png` image file.
    The second image will have a transform set to it to scale the image to 80%, as
    shown in the following code snippet:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StackPanel`内部，添加以下`Grid`，包含两个图像控件。两个图像控件都应该指向`Images/image1.png`图像文件。第二个图像将设置一个变换以将图像缩放到80%，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s add one more `Grid` inside the `StackPanel` with the following XAML
    mark-up, where the two images are scaled to 50% and mark the scaling center position
    to (`0`,`0`) and (`100`,`100`), respectively:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `StackPanel` 内添加一个额外的 `Grid`，使用以下 XAML 标记，其中两个图片缩放至 50%，并分别标记缩放中心位置为 (`0`,`0`)
    和 (`100`,`100`)：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's run the application now and check the scaling behavior of the various
    images on the screen.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行应用程序并检查屏幕上各种图片的缩放行为。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `RenderTransform` attribute helps you to set runtime transformation to any
    UI Element. In this example, we used `ScaleTransform` to scale the image on the
    application window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderTransform` 属性可以帮助你为任何 UI 元素设置运行时转换。在这个例子中，我们使用了 `ScaleTransform` 来缩放应用程序窗口上的图片。'
- en: 'When you run the application, the first one is the default image with an opacity
    set to 20%, whereas the second one is scaled to 80% with an opacity of 100%. The
    `ScaleX` and `ScaleY` properties are used to scale an element, which takes a decimal
    value to represent the ratio. For example, 0.8 denotes 80%, whereas 1.2 denotes
    120% of the scaling:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，第一个是默认图片，透明度设置为 20%，而第二个图片则缩放至 80%，透明度为 100%。`ScaleX` 和 `ScaleY` 属性用于缩放元素，它使用小数表示比例。例如，0.8
    表示 80%，而 1.2 表示缩放 120%：
- en: '![](img/4e7f79b7-1bf8-4871-9477-bed7ebb260c5.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e7f79b7-1bf8-4871-9477-bed7ebb260c5.png)'
- en: 'For the third and fourth images, both are scaled to 50%. But, as you see on
    the UI, the positions of the said images are different. The properties `CenterX`
    and `CenterY` are used to set the scaling center position. The third image has
    the scaling center set at (`0`,`0`), whereas the fourth one has its center position
    set at (`100`,`100`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三张和第四张图片，两者都缩放至 50%。但是，正如你在 UI 上看到的那样，这些图片的位置不同。`CenterX` 和 `CenterY` 属性用于设置缩放中心位置。第三张图片的缩放中心设置为
    (`0`,`0`)，而第四张图片的中心位置设置为 (`100`,`100`)：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rotating an element while rendering
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在渲染时旋转元素
- en: When you want to rotate an element at runtime, the `RotateTransform` is used.
    It rotates the element around a center position denoted by `CenterX` and `CenterY`,
    at an angle in degrees specified by the `Angle` property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在运行时想要旋转一个元素时，使用 `RotateTransform`。它围绕由 `CenterX` 和 `CenterY` 表示的中心位置旋转元素，角度由
    `Angle` 属性指定的度数。
- en: Let's learn how to use `RotateTransform` to rotate a UI element at a specified
    angle. In this recipe, we are going to discuss this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用 `RotateTransform` 在指定角度旋转 UI 元素。在这个菜谱中，我们将讨论这一点。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open Visual Studio and create a new project named `CH08.RotateTransformDemo`.
    Make sure to select the WPF App template while creating the project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个名为 `CH08.RotateTransformDemo` 的新项目。确保在创建项目时选择 WPF App
    模板。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps mentioned here to apply rotation to an `Image` control:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此处提到的步骤应用旋转到 `Image` 控件：
- en: From Solution Explorer, right-click on the project node and create a new folder.
    Name it as `Images`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击项目节点并创建一个新的文件夹。将其命名为 `Images`。
- en: Now right-click on the Images folder and add an existing image from your system.
    Name it `image1.png`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击 `Images` 文件夹并从你的系统中添加一个现有图片。命名为 `image1.png`。
- en: Open the `MainWindow.xaml` file and replace the existing `Grid` with a horizontal
    `StackPanel`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件并将现有的 `Grid` 替换为一个水平的 `StackPanel`。
- en: 'Insert the following XAML mark-up inside the `StackPanel` to add two images
    the application window. The first image will have an opacity set to 20%, and the
    second image will have a `RotateTransform` set at an angle of 45 degrees:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 内插入以下 XAML 标记来添加两个图片到应用程序窗口。第一个图片的透明度设置为 20%，第二个图片将 `RotateTransform`
    设置为 45 度角：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's add one more `Grid` inside the `StackPanel`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `StackPanel` 内添加一个额外的 `Grid`。
- en: Add two more images into the new `Grid` panel. Set the `RenderTransform` attribute
    of both the images to have a `RotateTransform` set to it at an angle of `45` degrees.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另外两张图片添加到新的 `Grid` 面板中。将两张图片的 `RenderTransform` 属性设置为具有 `RotateTransform`，角度为
    `45` 度。
- en: 'As shown in the following XAML snippet, set the center position of the rotation
    of the images using the `CenterX` and `CenterY` properties. In this demonstration,
    we will set (`0`,`0`) and (`30`,`30`) as the rotation center of the respective
    images:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下 XAML 片段所示，使用 `CenterX` 和 `CenterY` 属性设置图像旋转的中心位置。在这个演示中，我们将设置 (`0`,`0`)
    和 (`30`,`30`) 作为相应图像的旋转中心：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once this is done, build the project and run it. You will see four images on
    the screen, which will look like the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，构建项目并运行它。你将在屏幕上看到四张图像，如下面的截图所示：
- en: '![](img/9d35d641-4068-452c-9c5c-ae8c2572d7ad.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d35d641-4068-452c-9c5c-ae8c2572d7ad.png)'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`RotateTransform` allows you to rotate an element at a certain degree specified
    by the `Angle` property. In the first image, no transformation was applied and
    thus it will look as default. If you compare this with the other images on the
    screen, the second image is rotated clockwise at an angle of `45` degrees. The
    third and fourth images are also rotated at an angle of `45` degrees, but with
    a small difference.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotateTransform` 允许你通过 `Angle` 属性指定的一定角度旋转一个元素。在第一张图像中，没有应用任何转换，因此它将显示默认效果。如果你与其他屏幕上的图像进行比较，第二张图像是顺时针旋转了
    `45` 度。第三张和第四张图像也是以 `45` 度的角度旋转，但有一些细微的差别。'
- en: 'For the third image, the rotation was done at the center position (`0`,`0`).
    For the fourth image, it was done at the center position (`30`,`30`). Here''s
    how the difference will look:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三张图像，旋转是在中心位置（`0`,`0`）进行的。对于第四张图像，它是在中心位置（`30`,`30`）进行的。以下是差异的展示：
- en: '![](img/18936217-fe66-4463-a564-32de3e08e231.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18936217-fe66-4463-a564-32de3e08e231.png)'
- en: Skewing an element while rendering
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染时倾斜元素
- en: '`SkewTransform` is used in a WPF platform to shear an element so that it has
    a 3D look in a 2D plate by adding depth to it. The `AngleX` and `AngleY` properties
    are used to specify the skew angle of the *X* axis and the *Y* axis, while the
    `CenterX` and `CenterY` properties are used to specify the *X* and *Y* coordinates
    of the center point.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 平台上，`SkewTransform` 用于剪切一个元素，使其在 2D 平面上通过添加深度来获得 3D 视觉效果。`AngleX` 和 `AngleY`
    属性用于指定 *X* 轴和 *Y* 轴的倾斜角度，而 `CenterX` 和 `CenterY` 属性用于指定中心点的 *X* 和 *Y* 坐标。
- en: In this recipe, we will learn how to apply skew transform to an image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何将倾斜变换应用于图像。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open your Visual Studio IDE and create a new project named `CH08.SkewTransformDemo`,
    based on the WPF application template.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开你的 Visual Studio IDE 并创建一个名为 `CH08.SkewTransformDemo` 的新项目，基于 WPF 应用程序模板。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s add some images to the application window and apply skew to those at
    a certain angle and certain center positions. Follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序窗口中添加一些图像，并在特定的角度和中心位置上对这些图像应用倾斜。按照以下步骤操作：
- en: From Solution Explorer, right-click on the project node and create a new folder.
    Name it `Images`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击项目节点并创建一个新的文件夹。将其命名为 `Images`。
- en: Now right-click on the `Images` folder and add an existing image from your system.
    Name it as `image1.png`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键单击 `Images` 文件夹并从你的系统中添加一个现有图像。将其命名为 `image1.png`。
- en: Open the `MainWindow.xaml` file and replace the existing `Grid` with a horizontal
    `StackPanel`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件并将现有的 `Grid` 替换为一个水平的 `StackPanel`。
- en: 'Insert the following `Grid` inside the `StackPanel` to have two images. The
    first one will have opacity set to 20%, whereas the other will have a Skew applied
    to it at an angle of `50` degrees and `5` degrees on the *X* and *Y* axes. To
    set these, use the `AngleX` and `AngleY` properties, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 内插入以下 `Grid` 以显示两张图像。第一张图像的透明度设置为 20%，而另一张图像将在 *X* 和 *Y* 轴上应用一个
    `50` 度和 `5` 度的倾斜。为了设置这些，请使用 `AngleX` 和 `AngleY` 属性，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add one more `Grid` inside the `StackPanel` and insert two images inside the
    new `Grid`. Set `SkewTransform` to both of the images at the *X* and *Y* axes
    as `30` degrees and `5` degrees, respectively. For one of the images, set the
    skew center position at (`0`,`0`), and for the other image, set the skew center
    position at (`200`,`-100`) by specifying the `CenterX` and `CenterY` properties
    as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 内再添加一个 `Grid`，并在新的 `Grid` 内插入两张图像。将 `SkewTransform` 应用于两张图像的
    *X* 和 *Y* 轴，分别为 `30` 度和 `5` 度。对于其中一张图像，将倾斜中心位置设置为（`0`,`0`），而对于另一张图像，通过指定 `CenterX`
    和 `CenterY` 属性将其设置为（`200`,`-100`），如下所示：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s run the application. You will see images on the screen, such as the
    following ones:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。你将在屏幕上看到图像，如下所示：
- en: '![](img/c9ed747f-bf86-4bf2-bd2a-67cb8927f455.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9ed747f-bf86-4bf2-bd2a-67cb8927f455.png)'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you set `AngleX` and `AngleY` to a `SkewTransform`, the associated element
    skews/shears counterclockwise from the *Y* axis and the *X* axis, respectively,
    at an angle specified, which is measured in degrees.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `AngleX` 和 `AngleY` 设置为 `SkewTransform` 时，相关元素将分别从 *Y* 轴和 *X* 轴逆时针倾斜到指定的角度，该角度以度为单位。
- en: 'The `CenterX` property is used to set the *X* coordinate of the transform center,
    whereas the `CenterY` property is used to set the *Y* coordinate of the transform
    center. In the preceding example, when we specified `CenterX` and `CenterY` to
    the image, it changed the skew position centered at (`200`,`-100`) coordinate
    point, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`CenterX`属性用于设置转换中心的*X*坐标，而`CenterY`属性用于设置转换中心的*Y*坐标。在前面的例子中，当我们指定`CenterX`和`CenterY`到图片上时，它改变了以（`200`，`-100`）坐标点为中心的倾斜位置，如下面的截图所示：'
- en: '![](img/242686f9-efae-441c-9d4c-c33dbfd458f4.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/242686f9-efae-441c-9d4c-c33dbfd458f4.png)'
- en: Moving an element while rendering
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在渲染时移动元素
- en: '`TranslateTransform` is used to move an element from one position to another
    in the 2D interface. The `X` and `Y` properties are used to move an element towards
    the *X* and *Y* axes. In this recipe, we will learn how to apply this transforming
    to an element.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`TranslateTransform`用于在2D界面中将一个元素从一个位置移动到另一个位置。`X`和`Y`属性用于将元素移动到*X*和*Y*轴。在本教程中，我们将学习如何将这种转换应用于一个元素。'
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open Visual Studio and create a project named `CH08.TranslateTransformDemo`
    based on the WPF application template.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio并创建一个基于WPF应用程序模板的项目，命名为`CH08.TranslateTransformDemo`。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these simple steps to move an image from a certain coordinate location
    specified by the `X` and `Y` properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤，通过`X`和`Y`属性指定的坐标位置移动一个图片：
- en: Before working on this, we need to add an image file to the project. From Solution
    Explorer, right-click on the project node and create a new folder. Name it `Images`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这项工作之前，我们需要将一个图片文件添加到项目中。从解决方案资源管理器中，右键点击项目节点并创建一个新文件夹。将其命名为`Images`。
- en: Now right-click on the `Images` folder and add an existing image from your system.
    Name it `image1.png`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键点击`Images`文件夹，并从您的系统中添加一个现有的图片。将其命名为`image1.png`。
- en: 'Open the `MainWindow.xaml` file and add two images inside the `Grid` panel.
    Set the first one with a transparency of 30%. For the second image, add a `TranslateTransform`
    to it at a (`300`,`80`) location specified by the `X` and `Y` properties, as shared
    in the following screenshot:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件，并在`Grid`面板内添加两个图片。第一个图片的透明度为30%。对于第二个图片，在由`X`和`Y`属性指定的（`300`，`80`）位置添加一个`TranslateTransform`，如下面的截图所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's it! Let's build and run the application.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！让我们构建并运行应用程序。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When you run the application, you will see two images on the screen. The first
    one, which has a 20% opacity level, is placed at the far left of the window. The
    second image, which was placed on top of it, has been moved to a coordinate point
    (`300`, `80`), as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您将在屏幕上看到两个图片。第一个图片，其不透明度为20%，放置在窗口的左侧。第二个图片，放置在第一个图片上方，已移动到坐标点（`300`，`80`），如下面的截图所示：
- en: '![](img/adc4c088-b021-40ed-86fa-0e5408a390f5.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adc4c088-b021-40ed-86fa-0e5408a390f5.png)'
- en: To set the distance to translate along the *X* axis, the `X` property of the
    `TranslateTransform` is used, which is `300` here. Similarly, to set the distance
    to translate along the *Y* axis, the `Y` property of the `TranslateTransform`
    is used. It is `80` in our case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置沿*X*轴的平移距离，使用`TranslateTransform`的`X`属性，这里为`300`。同样，要设置沿*Y*轴的平移距离，使用`TranslateTransform`的`Y`属性。在我们的例子中为`80`。
- en: Grouping multiple transforms
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合多个转换
- en: It is not mandatory to have a single transform to a single element. You can
    group multiple transforms to it, by using the `<TransformGroup></TransformGroup>`
    tag. In this recipe, we will learn how to group multiple transforms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将单个转换应用于单个元素。您可以使用`<TransformGroup></TransformGroup>`标签将多个转换组合到它上面。在本教程中，我们将学习如何组合多个转换。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open Visual Studio and create a new project named `CH08.GroupedTransformsDemo`
    based on the WPF application template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开Visual Studio并创建一个基于WPF应用程序模板的新项目，命名为`CH08.GroupedTransformsDemo`。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to add two images to the application window and flip
    the second image to give a reflection effect. This will be done by grouping multiple
    transforms to that image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤将两个图片添加到应用程序窗口中，并将第二个图片翻转以产生反射效果。这将通过将多个转换组合到该图片上完成：
- en: First, we need to add an image to the project. To do this, create a folder named
    `Images` in the project root directory.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要向项目中添加一个图片。为此，在项目根目录下创建一个名为`Images`的文件夹。
- en: Right-click on the `Images` folder and add an existing image to it. Name it
    `image1.png`, which will be accessible from XAML as `Images/image1.png`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“图像”文件夹，并将现有图像添加到其中。命名为 `image1.png`，它将在 XAML 中作为 `Images/image1.png` 可访问。
- en: From the Solution Explorer, navigate to the `MainWindow.xaml` file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，导航到 `MainWindow.xaml` 文件。
- en: Replace the existing `Grid` panel with a horizontal `StackPanel`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 面板替换为水平 `StackPanel`。
- en: Insert two `Image` controls inside it and set their names as `originalImage`
    and `flippedImage`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中插入两个 `Image` 控件，并将它们的名称设置为 `originalImage` 和 `flippedImage`。
- en: 'Now set the image source of both the controls to `Images/image1.png` and then
    set their size. This is how the XAML will look:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将两个控件的控制图像源设置为 `Images/image1.png`，然后设置它们的大小。这将使 XAML 看起来如下：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the application, which will give the following output:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，将得到以下输出：
- en: '![](img/d48f1a02-d776-4077-b41b-f86478da9ba7.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d48f1a02-d776-4077-b41b-f86478da9ba7.png)'
- en: Close the application and return to the `MainWindow.xaml` file.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序并返回到 `MainWindow.xaml` 文件。
- en: Now we will flip the second image (`flippedImage`) to give a reflection effect.
    To do so, first set the `RenderTransformOrigin` of the `Image` control to `0.5,0.5`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将翻转第二个图像（`flippedImage`）以产生反射效果。为此，首先将 `Image` 控件的 `RenderTransformOrigin`
    设置为 `0.5,0.5`。
- en: Now add `<Image.RenderTransform>` to add the transforms mark-up. In this case,
    as we are going to add multiple transforms, add a `<TransformGroup>` tag inside
    it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `<Image.RenderTransform>` 以添加转换标记。在这种情况下，因为我们将要添加多个转换，所以在其中添加一个 `<TransformGroup>`
    标签。
- en: 'Let''s add `ScaleTransform`, `SkewTransform`, `RotateTransform`, and `TranslateTransform`
    inside the `<TransformGroup>` tag to flip the image. This is how the `RenderTransform`
    of the `Image` will look:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `<TransformGroup>` 标签内添加 `ScaleTransform`、`SkewTransform`、`RotateTransform`
    和 `TranslateTransform`，以翻转图像。这是 `Image` 的 `RenderTransform` 将看起来：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once done with the changes, your XAML will look as the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成更改后，你的 XAML 将看起来如下代码：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s build the project and run the application again. What did you see? There''s
    a reflection of the first image created by flipping the second image. Here''s
    a screenshot of the output:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建项目并再次运行应用程序。你看到了什么？有一个由翻转第二个图像创建的第一图像的反射。以下是输出截图：
- en: '![](img/7f95dc29-e35d-445c-a828-3f1403d9df41.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f95dc29-e35d-445c-a828-3f1403d9df41.png)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It works by defining the transformation mark-up inside the `<TransformGroup>`
    tag. In our example, we applied the `ScaleTransform`, which created a flip effect.
    The rest of the other transforms that we applied here use default values. You
    can modify their values and check how this works in the UI.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过在 `<TransformGroup>` 标签内定义转换标记来实现。在我们的例子中，我们应用了 `ScaleTransform`，这创建了一个翻转效果。我们在这里应用的其余其他转换使用默认值。你可以修改它们的值，并检查这在
    UI 中的效果。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Visual Studio provides you with a straightforward way to add transforms to any
    UI element. From the designer view, select the element for which you want to apply
    the transform and navigate to its Properties pane. Here, you can find an expander
    pane with the title Transform. This is used to set various values to different
    transforms available in XAML.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 提供了一种简单的方法来向任何 UI 元素添加转换。从设计视图中，选择要应用转换的元素，并导航到其属性面板。在这里，你可以找到一个标题为“转换”的展开面板。这用于设置
    XAML 中可用的各种转换的值。
- en: 'As shown in the following screenshot, you can define `TranslateTransform`,
    `RotateTransform`, `ScaleTransform`, `SkewTransform`, and `Flip`. Each tab/section
    consists of different values that it can accept:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，你可以定义 `TranslateTransform`、`RotateTransform`、`ScaleTransform`、`SkewTransform`
    和 `Flip`。每个选项卡/部分都包含它可以接受的不同值：
- en: '![](img/4e62bc3c-c59d-4ab4-99b5-02dfb56950cb.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e62bc3c-c59d-4ab4-99b5-02dfb56950cb.png)'
- en: Creating property-based animations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于属性的动画
- en: '**Property-based animations** are used to change a dependency property from
    one value to another in a duration specified. There exists various animation classes
    under the namespace `System.Windows.Media.Animation`, which includes `DoubleAnimation`,
    `ColorAnimation`, and `PointAnimation`. These are used to create animation based
    on the type of property being animated.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于属性的动画**用于在指定的时间内将依赖属性从一个值更改为另一个值。在命名空间 `System.Windows.Media.Animation`
    下存在各种动画类，包括 `DoubleAnimation`、`ColorAnimation` 和 `PointAnimation`。这些用于根据正在动画化的属性类型创建动画。'
- en: In this recipe, we will learn how to create property-based animations. Keep
    in mind that only Dependency Properties can be modifiable during an animation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何创建基于属性的动画。请记住，只有依赖属性可以在动画期间进行修改。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, let's first create a project. Open Visual Studio
    IDE and create a project named `CH08.PropertyBasedAnimationDemo`, based on the
    WPF application template.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个食谱，我们首先创建一个项目。打开 Visual Studio IDE 并创建一个基于 WPF 应用程序模板的项目，命名为 `CH08.PropertyBasedAnimationDemo`。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this demonstration, we will add a square box to the application window.
    On mouse hover, we will run a storyboard to change the size and color of the box
    and then reset it to the initial value on mouse leave. Follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将向应用程序窗口添加一个正方形框。在鼠标悬停时，我们将运行一个故事板来更改框的大小和颜色，然后在鼠标离开时将其重置到初始值。按照以下步骤操作：
- en: From Solution Explorer, navigate to the `MainWindow.xaml` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器，导航到 `MainWindow.xaml` 文件。
- en: Inside the XAML file, you will find a `Grid` panel placed by default. Let's
    add a `Rectangle` control inside it and set its `Height` and `Width` properties
    to `100` to give it a square look.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XAML 文件中，您将找到一个默认放置的 `Grid` 面板。让我们在其中添加一个 `Rectangle` 控件，并将其 `Height` 和 `Width`
    属性设置为 `100` 以使其看起来像一个正方形。
- en: Give the rectangle the name `squareBox` so that we can identify it from our
    `Storyboard`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给矩形命名为 `squareBox`，这样我们就可以从我们的 `Storyboard` 中识别它。
- en: 'Add a `SolidColorBrush` to fill the background of the `Rectangle`. Set a color
    to the brush and name it `squareBoxFillBrush`. Here''s the XAML snippet:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Rectangle` 的背景添加一个 `SolidColorBrush`。设置画笔的颜色并将其命名为 `squareBoxFillBrush`。以下是一个
    XAML 片段：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we need to add a `Storyboard` animation to the `MouseEnter` and `MouseLeave`
    events of the `Rectangle`, let''s control these using triggers. As shown, add
    a `<Rectangle.Triggers></Rectangle.Triggers>` element to our `Rectangle` control:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要向 `Rectangle` 的 `MouseEnter` 和 `MouseLeave` 事件添加 `Storyboard` 动画，让我们使用触发器来控制这些。如图所示，向我们的
    `Rectangle` 控件添加一个 `<Rectangle.Triggers></Rectangle.Triggers>` 元素：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we will be triggering the animation on `MouseEnter` and `MouseLeave` events,
    add an `EventTrigger` inside the `<Rectangle.Triggers></Rectangle.Triggers>` element
    that we have added.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将触发动画在 `MouseEnter` 和 `MouseLeave` 事件上，请在我们添加的 `<Rectangle.Triggers></Rectangle.Triggers>`
    元素内添加一个 `EventTrigger`。
- en: 'Now expand the trigger to have `Actions` to begin a `Storyboard` animation.
    Modify your XAML mark-up as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在展开触发器以包含 `Actions` 以开始一个 `Storyboard` 动画。按照以下方式修改您的 XAML 标记：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `Storyboard` animation for the `MouseEnter` event, we will be changing
    the size and color of the `squareBox` rectangle control. By using `DoubleAnimation`,
    we will be changing the `Height` and `Width` properties of the rectangle, and
    by using the `ColorAnimation` we will be changing the `Fill` color. Update the
    `Storyboard` as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MouseEnter` 事件的 `Storyboard` 动画中，我们将更改 `squareBox` 矩形控件的大小和颜色。通过使用 `DoubleAnimation`，我们将更改矩形的
    `Height` 和 `Width` 属性，并通过使用 `ColorAnimation` 我们将更改 `Fill` 颜色。按照以下方式更新 `Storyboard`：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, add another `EventTrigger` to the `Rectangle` control to trigger
    another `Storyboard` on the `MouseLeave` event to reset the size and the color.
    This new mark-up will look as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，向 `Rectangle` 控件添加另一个 `EventTrigger`，在 `MouseLeave` 事件上触发另一个 `Storyboard`
    以重置大小和颜色。新的标记将如下所示：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the application now. You will see a square with a `Black` background, as
    shown in the following screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。您将看到一个黑色背景的正方形，如下面的截图所示：
- en: '![](img/1935020f-19bc-470c-9d93-ccaeccc31b9e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1935020f-19bc-470c-9d93-ccaeccc31b9e.png)'
- en: 'Mouse hover on the square. This will resize the square to a rectangle and change
    the color to `OrangeRed`. Check the transition of the size and color, which will
    have a nice animation:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在正方形上。这将使正方形变为矩形，并将颜色更改为 `OrangeRed`。检查大小和颜色的过渡，这将有一个漂亮的动画：
- en: '![](img/533e41c5-8a5c-4f35-8622-64d4079933af.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/533e41c5-8a5c-4f35-8622-64d4079933af.png)'
- en: Now hover out your mouse cursor from the rectangle. What happens now? With a
    nice animation, the rectangle will reset back to a square. Also, the background
    color will change from `OrangeRed` to `Black`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将鼠标光标从矩形移出。现在会发生什么？矩形将通过一个漂亮的动画重置为正方形。此外，背景颜色将从 `OrangeRed` 更改为 `Black`。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Animations may be created manually by constructing the appropriate animation
    type, specifying properties, and then calling `BeginStoryboard` on the element
    to animate. The properties must be of type dependency property, which you want
    to animate on the animation object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过构造适当的动画类型、指定属性，然后在要动画化的元素上调用`BeginStoryboard`来手动创建动画。这些属性必须是依赖属性，你想要在动画对象上动画化。
- en: 'In this example, when the `MouseEnter` event triggers, the following `Storyboard`
    animation runs. `DoubleAnimation` and `ColorAnimation` accepts the attached properties,
    `Storyboard.TargetName` and `Storyboard.TargetProperty`, which allows the `Storyboard`
    to change the said property of the targeted element at runtime:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`MouseEnter`事件触发时，以下`Storyboard`动画将运行。`DoubleAnimation`和`ColorAnimation`接受附加属性`Storyboard.TargetName`和`Storyboard.TargetProperty`，这使得`Storyboard`能够在运行时更改目标元素的指定属性：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`From` and `To` properties are used to change the property from a specified
    value to another. Though it is optional to set the `From` field, you need to specify
    the `To` field in order to have the change in effect for the `Storyboard`. In
    the preceding example, the animation will change the `Height`, `Width`, and `Color`
    from its initial value.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`From`和`To`属性用于将属性从指定的值更改为另一个值。尽管设置`From`字段是可选的，但你需要指定`To`字段，以便`Storyboard`能够产生变化。在先前的例子中，动画将从其初始值改变`Height`、`Width`和`Color`。'
- en: You can also set a `TimeSpan` to the animation to set the time for the transition
    to occur. You can use the `Duration` property to set the value. In the preceding
    example, it will take `1` second for the transition to happen from a `Black` color
    to an `OrangeRed` color.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为动画设置一个`TimeSpan`来设定过渡发生的时间。你可以使用`Duration`属性来设置值。在先前的例子中，从`Black`颜色过渡到`OrangeRed`颜色将需要`1`秒。
- en: 'Similarly, when the `MouseLeave` event triggers, the following `Storyboard`
    responsible for resetting the value will trigger, which will set the `To` field
    to its initial value. When the `Storyboard` runs, you will see a nice transitional
    animation on the screen:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当`MouseLeave`事件触发时，以下负责重置值的`Storyboard`将触发，它将`To`字段设置为其初始值。当`Storyboard`运行时，你将在屏幕上看到漂亮的过渡动画：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These are some common properties that you will find in most of the animation
    types:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在大多数动画类型中都会找到的一些常见属性：
- en: '`From`: It is used to indicate the starting value of the animation. If you
    omit the `From` field, it will use the current value of the dependency property.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`From`: 它用于指示动画的起始值。如果你省略了`From`字段，它将使用依赖属性的当前值。'
- en: '`To`: It is the target value of the animation, which you should fill. If you
    omit it or put the current value, the said animation will have no effect.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`To`: 这是动画的目标值，你应该填写它。如果你省略它或放入当前值，该动画将没有效果。'
- en: '`Duration`: It is the duration of the animation. Apart from a `TimeSpan` type
    value in `hh:mm:ss.ms` format, it can also contain two special values—`Duration.Automatic`
    (default value) and `Duration.Forever`. When you specify `Duration.Forever`, it
    will run for an infinite length. In XAML, `hh:mm:ss.ms` format is mostly used.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`: 这是动画的持续时间。除了`hh:mm:ss.ms`格式的`TimeSpan`类型值之外，它还可以包含两个特殊值——`Duration.Automatic`（默认值）和`Duration.Forever`。当你指定`Duration.Forever`时，它将无限期运行。在XAML中，`hh:mm:ss.ms`格式通常使用。'
- en: '`FillBehavior`: It indicates the animation''s behavior when it ends. The default
    value `FillEnd` asks to keep the last animation value; the previous value, which
    was used before the animation, will have no effect. The other value, `Stop`, destroys
    the animation and reverts the property to its value without the animation.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FillBehavior`: 它表示动画结束时动画的行为。默认值`FillEnd`要求保持最后一个动画值；在动画之前使用的上一个值将没有效果。另一个值`Stop`将销毁动画并将属性还原到没有动画的值。'
- en: '`BeginTime`: When you want to set a delay before the animation begins, you
    can use this attribute to define the delay time.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginTime`: 当你想要在动画开始前设置延迟时，你可以使用此属性来定义延迟时间。'
- en: '`AutoReverse`: If you want to automatically reverse the animation, after it
    ends, you can set it to `true`. The total animation duration will be effectively
    doubled when enabled.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoReverse`: 如果你想要动画自动反转，在动画结束后，你可以将其设置为`true`。当启用时，动画的总持续时间将有效加倍。'
- en: '`SpeedRatio`: It allows you to speed up or slow down the animation duration.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpeedRatio`: 它允许你加快或减慢动画持续时间。'
- en: '`RepeatBehavior`: This attribute specifies the count or the time you want to
    repeat the animation, after it ends. This is often useful when you set `AutoReverse`
    to `true`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepeatBehavior`：此属性指定动画结束后要重复的次数或时间。当将`AutoReverse`设置为`true`时，这通常很有用。'
- en: Creating path-based animations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路径动画
- en: Along with property-based animations, which we learned about in the previous
    recipe, WPF also supports **path-based animations** that run along a path specified
    by the `PathGeometry`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一个菜谱中学到的基于属性的动画外，WPF还支持沿由`PathGeometry`指定的路径运行的**路径动画**。
- en: In this recipe, we will learn how to use a `PathGeometry` to animate an element
    along its way.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`PathGeometry`来沿路径动画化一个元素。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with creating a new WPF application project. Name it `CH08.PathBasedAnimationDemo`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的WPF应用程序项目开始。命名为`CH08.PathBasedAnimationDemo`。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this demonstration, we will use a circle to animate it on the click of a
    button. The animation will be performed based on a path specified by a set of
    geometry coordinates. Let''s build this by following the steps mentioned here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将使用一个圆形在按钮点击时进行动画。动画将基于由一组几何坐标指定的路径执行。让我们按照以下步骤构建它：
- en: From Solution Explorer, navigate to the `MainWindow.xaml` file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，导航到`MainWindow.xaml`文件。
- en: 'A default `Grid` panel will be present inside the file. Let''s divide it into
    two rows by specifying the row definition as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件中会存在一个默认的`Grid`面板。让我们通过指定以下行定义将其分为两行：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's place a `Canvas` panel inside the first row. Add an `Ellipse` of `Height="30"`
    and `Width="30"` to form the circle. Give it a name `circle`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在第一行内放置一个`Canvas`面板。添加一个`Ellipse`，其`Height="30"`和`Width="30"`以形成圆形。给它命名为`circle`。
- en: 'Set the fill color of the `Ellipse` and position it at the (`100`, `100`) coordinate
    location of the canvas. Here''s the complete mark-up for your reference:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Ellipse`的填充颜色并将其放置在画布的（`100`，`100`）坐标位置。以下是完整的标记供您参考：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will be using this `Ellipse` to animate inside the canvas along a path.
    For this, we will need a `PathGeometry` defined. To do so, add the following inside
    the `Window` tag as `Resources` to define the `PolyLineSegment` points as a collection
    of coordinates:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用这个`Ellipse`在画布中沿着路径进行动画。为此，我们需要定义一个`PathGeometry`。要做到这一点，请在`Window`标签内作为`Resources`添加以下内容，以定义`PolyLineSegment`点作为坐标集合：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add a `Button` control inside the `Window`, which will be used to trigger
    the animation. Surround the button with a horizontal `StackPanel` and place it
    inside the second row of the `Grid`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Window`内添加一个`Button`控件，它将被用来触发动画。将按钮包裹在一个水平`StackPanel`中，并将其放置在`Grid`的第二行中：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to catch the `Button.Click` event. For this, we will need an `EventTrigger`
    to define against the `Button` control. And, once the trigger fires, the action
    is to begin a `Storyboard` to perform an animation. Let''s modify the `Button`
    control to have this trigger set to start a storyboard. Here''s the code to refer
    to:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要捕获`Button.Click`事件。为此，我们需要一个`EventTrigger`来定义针对`Button`控件。一旦触发器被触发，动作就是开始一个`Storyboard`来执行动画。让我们修改`Button`控件以设置此触发器以启动故事板。以下是参考代码：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now it's time to add some path animations to the `Storyboard` that we have added
    inside the `Button.Click` event handler. Let's use `DoubleAnimationUsingPath`
    to bind the `PathGeometry` that we added to the `Window.Resources` tag.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候给我们在`Button.Click`事件处理器中添加的`Storyboard`添加一些路径动画了。让我们使用`DoubleAnimationUsingPath`来绑定我们添加到`Window.Resources`标签中的`PathGeometry`。
- en: 'Set the `Storyboard.TargetName` to `circle` and the `Storyboard.TargetProperty`
    to `(Canvas.Left)` and `(Canvas.Top)` to create an animation in both the *X* and
    *Y* axes. Here''s the code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Storyboard.TargetName`设置为`circle`，将`Storyboard.TargetProperty`设置为`(Canvas.Left)`和`(Canvas.Top)`以在X和Y轴上创建动画。以下是代码：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s build the application and run it. You will see the following UI with
    a circle and a button:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建应用程序并运行它。您将看到以下带有圆形和按钮的UI：
- en: '![](img/fb9dc284-e516-4edc-b560-75406166e27c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb9dc284-e516-4edc-b560-75406166e27c.png)'
- en: 'Click on the Animate button and observe the positions of the circle. You will
    see a nice animated flow on the screen:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击动画按钮并观察圆形的位置。您将在屏幕上看到一个漂亮的动画流程：
- en: '![](img/1f8d3070-7d43-4f4c-bdba-70e7129a234a.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f8d3070-7d43-4f4c-bdba-70e7129a234a.png)'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The path-based animations use a `PathGeometry` as a path to create the animation.
    In our example, we defined it under the `Window.Resources` tag as an `animationPath`,
    which represents the path in a 2D interface as a collection of coordinate points.
    See the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基于路径的动画使用`PathGeometry`作为路径来创建动画。在我们的示例中，我们将其定义在`Window.Resources`标签下作为`animationPath`，它表示一个2D界面中的路径，作为一个坐标点的集合。请参阅以下代码片段：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DoubleAnimationUsingPath` that we used in our storyboard animation uses
    `Canvas.Left` and `Canvas.Top` as the target properties to animate along the *X*
    and *Y* axes. When the `Storyboard` plays, the target element moves from one coordinate
    point to another, having a smooth animation between the two points.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在故事板动画中使用的`DoubleAnimationUsingPath`使用`Canvas.Left`和`Canvas.Top`作为沿*X*和*Y*轴动画的目标属性。当`Storyboard`播放时，目标元素从一个坐标点移动到另一个坐标点，在两点之间有一个平滑的动画。
- en: Creating key-frame-based animations
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于关键帧的动画
- en: Key frame animations in WPF enable you to animate an element using more than
    two target-values and control an animation's interpolation method. A key frame
    animation has no `From`/`To` properties with which we can set its target values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的关键帧动画允许您使用超过两个目标值来动画化一个元素，并控制动画的插值方法。关键帧动画没有`From`/`To`属性，我们可以用它们来设置其目标值。
- en: The animation's target values are described using key frame objects, which you
    need to add to the animation's `KeyFrames` collection. When the animation runs,
    it transitions between the key frames that you specified.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的目标值使用关键帧对象来描述，您需要将它们添加到动画的`KeyFrames`集合中。当动画运行时，它会在您指定的关键帧之间进行转换。
- en: In this recipe, we will learn how to create a key-frame-based animation and
    use it in our application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建基于关键帧的动画，并将其用于我们的应用程序。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create a project first. Open Visual Studio IDE and create a new project
    named `CH08.KeyFrameBasedAnimationDemo`, based on the WPF application template.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个项目。打开Visual Studio IDE，并基于WPF应用程序模板创建一个名为`CH08.KeyFrameBasedAnimationDemo`的新项目。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to create a key-frame-based animation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个基于关键帧的动画：
- en: Open the `MainWindow.xaml` file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件。
- en: 'Add two rows inside the `Grid`, by specifying `RowDefinitions`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`内部添加两行，通过指定`RowDefinitions`：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add a `Canvas` panel at 0^(th) row of the `Grid`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`的第0行添加一个`Canvas`面板。
- en: Insert an `Ellipse` inside the canvas and set its `Height` and `Width` properties
    to `30`, so that it displays as a circle.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布内插入一个`Ellipse`，并将其`Height`和`Width`属性设置为`30`，以便它显示为一个圆圈。
- en: Provide a name to the `Ellipse`, and position it to the (`50`,`100`) coordinate
    position on the `Canvas` panel, and fill the background with an `OrangeRed` color.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为椭圆提供名称，并将其定位到`Canvas`面板上的(`50`,`100`)坐标位置，然后用`OrangeRed`颜色填充背景。
- en: 'Insert a `Button` control inside a horizontal `StackPanel`, and place the panel
    inside the second row. Here''s the complete XAML of the UI that we have generated
    for this demonstration:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个水平`StackPanel`内部插入一个`Button`控件，并将面板放置在第二行。以下是为此演示生成的UI的完整XAML：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On pressing the button, we need to animate the circle around the application
    window. To do this, we will be using an `EventTrigger`. Define the trigger for
    a `Button.Click` event and set its action to begin a storyboard.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下按钮时，我们需要围绕应用程序窗口动画化圆圈。为此，我们将使用一个`EventTrigger`。定义一个`Button.Click`事件的触发器，并将其操作设置为开始一个故事板。
- en: 'Set the `AutoReverse` property of the `Storyboard` to `True`. Here''s the code
    for launching the storyboard when a user triggers the button click event:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Storyboard`的`AutoReverse`属性设置为`True`。以下是当用户触发按钮点击事件时启动故事板的代码：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside the storyboard, we need to define an animation that will run based on
    the key frame specified. This is done by adding one or more `LinearDoubleKeyFrame`(s)
    inside a `DoubleAnimationUsingKeyFrames` element. Insert two instances of `DoubleAnimationUsingKeyFrames`
    inside the `Storyboard` definition.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板内部，我们需要定义一个基于关键帧运行的动画。这是通过在`DoubleAnimationUsingKeyFrames`元素内部添加一个或多个`LinearDoubleKeyFrame`(s)来完成的。在`Storyboard`定义内部插入两个`DoubleAnimationUsingKeyFrames`实例。
- en: Set the `Storyboard.TargetName` property of `DoubleAnimationUsingKeyFrames`
    to `circle`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DoubleAnimationUsingKeyFrames`的`Storyboard.TargetName`属性设置为`circle`。
- en: Set `AutoReverse` to `True` and `RepeatBehavior` to `Forever`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AutoReverse`设置为`True`，将`RepeatBehavior`设置为`Forever`。
- en: For the first `DoubleAnimationUsingKeyFrames`, set the `Storyboard.TargetProperty`
    to `(Canvas.Left)`. For the other one, set it to `(Canvas.Top)`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个`DoubleAnimationUsingKeyFrames`，将`Storyboard.TargetProperty`设置为`(Canvas.Left)`。对于另一个，将其设置为`(Canvas.Top)`。
- en: 'Define key frames by adding one or more `LinearDoubleKeyFrame` instances to
    the `DoubleAnimationUsingKeyFrames`. Set their `KeyTime` and `Value`. Here''s
    the complete code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向`DoubleAnimationUsingKeyFrames`添加一个或多个`LinearDoubleKeyFrame`实例来定义关键帧。设置它们的`KeyTime`和`Value`。以下是完整的代码：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once done, let''s run the application. You will see a circle on the screen
    at the (`50`, `100`) coordinate point. There also exists a button labeled Animate,
    as shown in the following screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，让我们运行应用程序。您将在屏幕上的(`50`, `100`)坐标点看到一个圆。还有一个标记为动画的按钮，如下面的截图所示：
- en: '![](img/080c21ef-7ee7-4a5a-8bc3-946293c5a839.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/080c21ef-7ee7-4a5a-8bc3-946293c5a839.png)'
- en: 'Click on the Animate button to start the defined storyboard. See the movement
    and the speed of the circle:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击动画按钮以启动定义的故事板。查看圆的运动和速度：
- en: '![](img/ffa3ac35-4712-45d0-b494-5264fee82e63.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffa3ac35-4712-45d0-b494-5264fee82e63.png)'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a key frame animation begins, it iterates through the specified key frames
    in the order they were defined by their `KeyTime` properties. If there exists
    no key frame at time `0` (initial point), the animation creates a transition between
    the target property's current value and the `Value` of the first key frame defined
    in the collection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当关键帧动画开始时，它将按照它们根据`KeyTime`属性定义的顺序遍历指定的关键帧。如果不存在时间`0`（初始点）的关键帧，动画将在目标属性的当前值和集合中定义的第一个关键帧的`Value`之间创建过渡。
- en: If the animation's `Duration` is `Automatic` or set to the time of the last
    key frame, the animation ends.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画的`Duration`设置为`Automatic`或设置为最后一个关键帧的时间，则动画结束。
- en: In the preceding demonstration, the first key frame (at time `0`) sets the animation's
    output value to `Canvas.Left="50"` and `Canvas.Top="100"`. In the next key frame
    (at time `1 sec`), the output value sets to the (`450`,`200`) coordinate point,
    and you will see a smooth transition between the (`50`,`100`) and the (`450`,`200`)
    points. Similarly, in the third and fourth seconds, the circle transitions from
    (`450`,`200`) to (`450`,`50`) and then to the (`250`,`150`) coordinate points.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的演示中，第一个关键帧（在时间`0`）将动画的输出值设置为`Canvas.Left="50"`和`Canvas.Top="100"`。在下一个关键帧（在`1
    sec`时），输出值设置为坐标点(`450`,`200`)，您将看到在(`50`,`100`)和(`450`,`200`)点之间的平滑过渡。同样，在第三秒和第四秒，圆从(`450`,`200`)过渡到(`450`,`50`)，然后过渡到坐标点(`250`,`150`)。
- en: As the defined `Storyboard` has an `AutoReverse` property set to `True`, the
    animation will have a reverse transition to move the circle from the end point
    (`250`,`150`) to the initial start point (`50`,`100`) via the (`450`,`50`) and
    the (`450`,`200`) coordinate points.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定义的`Storyboard`具有设置为`True`的`AutoReverse`属性，动画将有一个反向过渡，将圆从终点(`250`,`150`)移动到初始起点(`50`,`100`)，经过坐标点(`450`,`50`)和(`450`,`200`)。
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The key-frame-based animation class type is not limited to only `DoubleAnimationUsingKeyFrames`.
    You can use any of the following key frame animation classes to construct your
    storyboard:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基于关键帧的动画类类型不仅限于`DoubleAnimationUsingKeyFrames`。您可以使用以下任何关键帧动画类来构建您的故事板：
- en: 'Boolean: `BooleanAnimationUsingKeyFrames`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`BooleanAnimationUsingKeyFrames`
- en: 'Byte: `ByteAnimationUsingKeyFrames`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节：`ByteAnimationUsingKeyFrames`
- en: 'Color: `ColorAnimationUsingKeyFrames`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色：`ColorAnimationUsingKeyFrames`
- en: 'Decimal: `DecimalAnimationUsingKeyFrames`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制：`DecimalAnimationUsingKeyFrames`
- en: 'Double: `DoubleAnimationUsingKeyFrames`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双精度浮点数：`DoubleAnimationUsingKeyFrames`
- en: 'Int16: `Int16AnimationUsingKeyFrames`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int16：`Int16AnimationUsingKeyFrames`
- en: 'Int32: `Int32AnimationUsingKeyFrames`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int32：`Int32AnimationUsingKeyFrames`
- en: 'Int64: `Int64AnimationUsingKeyFrames`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int64：`Int64AnimationUsingKeyFrames`
- en: 'Matrix: `MatrixAnimationUsingKeyFrames`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵：`MatrixAnimationUsingKeyFrames`
- en: 'Object: `ObjectAnimationUsingKeyFrames`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：`ObjectAnimationUsingKeyFrames`
- en: 'Point: `PointAnimationUsingKeyFrames`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点：`PointAnimationUsingKeyFrames`
- en: 'Quaternion: `QuaternionAnimationUsingKeyFrames`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四元数：`QuaternionAnimationUsingKeyFrames`
- en: 'Rect: `RectAnimationUsingKeyFrames`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形：`RectAnimationUsingKeyFrames`
- en: 'Rotation3D: `Rotation3DAnimationUsingKeyFrames`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D旋转：`Rotation3DAnimationUsingKeyFrames`
- en: 'Single: `SingleAnimationUsingKeyFrames`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单精度浮点数：`SingleAnimationUsingKeyFrames`
- en: 'String: `StringAnimationUsingKeyFrames`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`StringAnimationUsingKeyFrames`
- en: 'Size: `SizeAnimationUsingKeyFrames`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小：`SizeAnimationUsingKeyFrames`
- en: 'Thickness: `ThicknessAnimationUsingKeyFrames`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厚度：`ThicknessAnimationUsingKeyFrames`
- en: 'Vector3D: `Vector3DAnimationUsingKeyFrames`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D向量：`Vector3DAnimationUsingKeyFrames`
- en: 'Vector: `VectorAnimationUsingKeyFrames`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量：`VectorAnimationUsingKeyFrames`
- en: Adding easing effects to animations
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为动画添加缓动效果
- en: Property-based animations are linear, whereas the key-frame-based animations
    are non-linear and are used to create **Beizer**-based interpolations. But creation
    of such effects is not so easy. To overcome this, WPF 4 introduces **easing functions**
    to turn a linear animation into a non-linear one and add some easing effects to
    those animation objects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的动画是线性的，而基于关键帧的动画是非线性的，用于创建**贝塞尔**插值。但创建此类效果并不容易。为了克服这一点，WPF 4引入了**缓动函数**，将线性动画转换为非线性动画，并为这些动画对象添加一些缓动效果。
- en: In this recipe, we will learn how to do this with a suitable example.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过一个合适的示例学习如何做到这一点。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with adding easing effects to an animation, let's open Visual
    Studio and create a new project named `CH08.EasingEffectDemo`. Select a WPF application
    template while creating the project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始向动画添加缓动效果，让我们打开Visual Studio并创建一个名为`CH08.EasingEffectDemo`的新项目。在创建项目时选择WPF应用程序模板。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to create an animation with various kinds of easing
    effects:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建具有各种缓动效果的动画：
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开`MainWindow.xaml`文件。
- en: 'Divide the existing `Grid` panel into two columns, by applying `ColumnDefinition`
    to it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对现有`Grid`面板应用`ColumnDefinition`将其分为两列：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, inside the `Grid`, place a `Canvas` panel, and set its `Grid.Column` attribute
    to `0` (zero).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Grid`内部放置一个`Canvas`面板，并将其`Grid.Column`属性设置为`0`（零）。
- en: 'Inside the canvas, add an `Ellipse` (name it as `circle`) and set its `Height`
    and `Width` properties to `80` to give it a circular look. Set its `Fill` color
    property, and position it to a (`150`,`80`) location. Here''s the code snippet:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布内部添加一个`Ellipse`（命名为`circle`），并将其`Height`和`Width`属性设置为`80`以使其看起来是圆形的。设置其`Fill`颜色属性，并将其定位到（`150`,`80`）位置。以下是代码片段：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now add a vertical `StackPanel` inside the `Grid` and set its `Grid.Column`
    attribute to `1`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`Grid`内部添加一个垂直的`StackPanel`，并将其`Grid.Column`属性设置为`1`。
- en: Add three radio buttons (`GroupName="AnimationSelector"`) inside the `StackPanel`,
    and add a `Storyboard` animation to fire when the `RadioButton.Checked` event
    is triggered.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StackPanel`内部添加三个单选按钮（`GroupName="AnimationSelector"`），并在`RadioButton.Checked`事件触发时添加一个`Storyboard`动画。
- en: Add a simple `DoubleAnimation` to move the circle horizontally by setting its
    `Storyboard.TargetProperty` to `(Canvas.Left)`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个简单的`DoubleAnimation`来水平移动圆圈，通过将其`Storyboard.TargetProperty`设置为`(Canvas.Left)`。
- en: Now expand the animation to add an easing effect to it. Insert a `<DoubleAnimation.EasingFunction></DoubleAnimation.EasingFunction>`
    attribute to hold the effect that we are going to add.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将动画扩展以添加缓动效果。插入一个`<DoubleAnimation.EasingFunction></DoubleAnimation.EasingFunction>`属性来保存我们即将添加的效果。
- en: 'Let''s add a `BackEase` effect to the three radio buttons. This type of effect
    represents an easing function that retracts the motion of an animation slightly
    before it begins to animate in the path indicated, and is denoted by the following
    function—`f(t) = t3 - t * a * sin(t * pi)`. Set the `Amplitude` property of the
    function to `0.3` and the `EasingMode` property to `EaseIn`, `EaseOut`, and `EaseInOut`,
    respectively. The complete code will look as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在三个单选按钮上添加一个`BackEase`效果。此类效果表示一个在动画开始之前稍微收缩运动并在指定路径中动画化的缓动函数，表示为以下函数——`f(t)
    = t3 - t * a * sin(t * pi)`。将函数的`Amplitude`属性设置为`0.3`，将`EasingMode`属性分别设置为`EaseIn`、`EaseOut`和`EaseInOut`。完整的代码如下：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s run the application. You will see the following UI on the screen:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。您将在屏幕上看到以下UI：
- en: '![](img/bd5160b5-c666-4043-814f-550ce423786f.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd5160b5-c666-4043-814f-550ce423786f.png)'
- en: Now change the selection of the radios and observe the effects added to the
    animation of the circular object.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改单选按钮的选择，并观察添加到圆形对象动画中的效果。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Animation easing applies a function to the animation value to alter a linear
    animation to form a non-linear one. A mode option, defined by the `EasingMode`
    property, allows you to set when to apply the easing function. This could be at
    the beginning (`EaseIn`), at the end (`EaseOut`), or both (`EaseInOut`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 动画缓动将一个函数应用于动画值，以将线性动画转换为非线性动画。一个由`EasingMode`属性定义的模式选项允许您设置何时应用缓动函数。这可以是开始时（`EaseIn`）、结束时（`EaseOut`）或两者（`EaseInOut`）。
- en: In the preceding example, we defined a `BackEase` function to the animation
    with different easing modes, which will animate when the `Checked` event of the
    radio buttons trigger.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为动画定义了一个具有不同缓动模式的`BackEase`函数，当单选按钮的`Checked`事件触发时，它将进行动画处理。
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `BackEase` effect:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了不同`EasingMode`值的`BackEase`效果：
- en: '![](img/a5bad042-6e0a-4aef-af32-0a1e75a7eac8.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5bad042-6e0a-4aef-af32-0a1e75a7eac8.png)'
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s not limited to only the `BackEase` function, but it can have any of the
    11 built-in easing functions defined in WPF. The complete list is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅限于`BackEase`函数，还可以是WPF中定义的11个内置缓动函数中的任何一个。完整的列表如下：
- en: '`BackEase`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackEase`'
- en: '`BounceEase`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BounceEase`'
- en: '`CircleEase`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CircleEase`'
- en: '`CubicEase`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CubicEase`'
- en: '`ElasticEase`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElasticEase`'
- en: '`ExponentialEase`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExponentialEase`'
- en: '`PowerEase`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PowerEase`'
- en: '`QuadraticEase`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuadraticEase`'
- en: '`QuarticEase`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuarticEase`'
- en: '`QuinticEase`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuinticEase`'
- en: '`SineEase`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SineEase`'
- en: All these listed easing functions derive from the abstract class `EasingFunctionBase`,
    which implements the `IEasingFunction` interface. It contains an `Ease` method
    and adds the `EasingMode` property, which indicates whether the function should
    be applied at the start of the animation (`EaseIn`), the end of the animation
    (`EaseOut`), or both ways (`EaseInOut`).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些列出的缓动函数都源自抽象类`EasingFunctionBase`，该类实现了`IEasingFunction`接口。它包含一个`Ease`方法并添加了`EasingMode`属性，该属性指示函数是否应用于动画的开始（`EaseIn`）、结束（`EaseOut`）或两者（`EaseInOut`）。
- en: Let's modify our existing UI to have some more built-in easing functions added
    to the animation. To demonstrate this, we are going to add 10 more radio buttons
    inside the `StackPanel` and apply the easing functions to each one of them, as
    discussed in the following section.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改现有的UI，向动画添加更多内置的缓动函数。为了演示这一点，我们将在`StackPanel`内添加10个更多的单选按钮，并将缓动函数应用于每个单选按钮，如以下章节所述。
- en: BounceEase
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BounceEase
- en: This type of function creates an animated bouncing effect to the target. The
    `Bounces` and `Bounciness` properties can be used to control the bounces. The
    `Bounces` property denotes the number of bounces and the `Bounciness` property
    defines how bouncy the bounce animation is. The lower the value of `Bounciness`,
    the higher the bouncing animation; the higher the value of `Bounciness`, the lower
    the bounces of the animation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的函数为目标创建一个动画弹跳效果。可以使用`Bounces`和`Bounciness`属性来控制弹跳。`Bounces`属性表示弹跳次数，而`Bounciness`属性定义了弹跳动画的弹跳程度。`Bounciness`的值越低，弹跳动画越高；`Bounciness`的值越高，动画的弹跳越低。
- en: 'In the following example, let''s apply a `BounceEase` function to the `DoubleAnimation`
    to create a bouncing effect. Let''s add the following `RadioButton` inside the
    `StackPanel`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，让我们将`BounceEase`函数应用于`DoubleAnimation`以创建弹跳效果。让我们在`StackPanel`内添加以下`RadioButton`：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `BounceEase` effect:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了不同`EasingMode`值的`BounceEase`效果：
- en: '![](img/3fec5c15-2d6f-47d1-9b46-2d261965ab46.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3fec5c15-2d6f-47d1-9b46-2d261965ab46.png)'
- en: CircleEase
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CircleEase
- en: This represents an easing function that creates an animation that accelerates/decelerates
    using a `circular` function, and is denoted by the following function `f(t) =
    1 - sqrt(1 - t2)`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个创建动画，使用`圆形`函数加速/减速的缓动函数，表示为以下函数`f(t) = 1 - sqrt(1 - t2)`。
- en: 'Let''s add the following `RadioButton` inside the `StackPanel` to create an
    animation with a circular easing effect:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`StackPanel`内添加以下`RadioButton`以创建具有圆形缓动效果的动画：
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `CircleEase` effect:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了不同`EasingMode`值的`CircleEase`效果：
- en: '![](img/10c4a73e-008e-492b-b48d-53f56249901a.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10c4a73e-008e-492b-b48d-53f56249901a.png)'
- en: CubicEase
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CubicEase
- en: This creates an animation that accelerates/decelerates using the formula `f(t)
    = t3`, where `EasingMode` can be applied to control acceleration, deceleration,
    or both, by setting the value `EaseIn`, `EaseOut`, or `EasInOut`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个使用公式`f(t) = t3`加速/减速的动画，其中`EasingMode`可以通过设置`EaseIn`、`EaseOut`或`EaseInOut`的值来应用于控制加速、减速或两者，以控制动画的开始（`EaseIn`）、结束（`EaseOut`）或两者（`EaseInOut`）。
- en: 'Let''s add the following `RadioButton` inside the `StackPanel` to create an
    animation with an accelerating `CubicEase` function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`StackPanel`内添加以下`RadioButton`以创建具有加速`CubicEase`函数的动画：
- en: '[PRE35]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `CubicEase` effect:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了不同`EasingMode`值的`CubicEase`效果：
- en: '![](img/64bcf1a9-75cd-42d1-89d8-d0ef79f52800.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64bcf1a9-75cd-42d1-89d8-d0ef79f52800.png)'
- en: ElasticEase
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ElasticEase
- en: As the name says, it represents an easing function that creates an animation
    that resembles a spring oscillating back and forth until it comes to rest. The
    `Oscillations` property can be used to get/set the number of times the target
    slides back and forth over the animation destination. The `Springiness` property
    can be used to define the stiffness of the spring. The smaller the value of `Springiness`,
    means a stiffer spring in action.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，它代表一个创建动画的缓动函数，该动画类似于弹簧来回振荡直到静止。`Oscillations` 属性可以用来获取/设置目标在动画目的地来回滑动的次数。`Springiness`
    属性可以用来定义弹簧的刚度。`Springiness` 的值越小，表示作用中的弹簧越硬。
- en: 'To demonstrate, let''s add the following `RadioButton` inside the `StackPanel`
    to create an animation with `ElasticEase`, having `Oscillations="3"` and `Springiness="1"`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们在 `StackPanel` 内添加以下 `RadioButton` 来创建一个具有 `Oscillations="3"` 和 `Springiness="1"`
    的 `ElasticEase` 动画：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `ElasticEase` effect:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `EasingMode` 的不同值，用于 `ElasticEase` 效果：
- en: '![](img/a0c8a3a2-0b6c-4b86-8e56-8aa247bebfac.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0c8a3a2-0b6c-4b86-8e56-8aa247bebfac.png)'
- en: ExponentialEase
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExponentialEase
- en: This type of easing function creates an animation that accelerates/decelerates
    using an exponential formula `f(t) = [[e(at) - 1] / [e(a) - 1]]`. The `Exponent`
    property is used to determine the interpolation of the animation; whereas the
    `EasingMode` property is used to accelerate and decelerate the animation of the
    target control.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的缓动函数通过指数公式 `f(t) = [[e(at) - 1] / [e(a) - 1]]` 创建动画，加速/减速。`Exponent` 属性用于确定动画的插值；而
    `EasingMode` 属性用于加速和减速目标控件的动画。
- en: 'To demonstrate this, add the following `RadioButton` control inside the `StackPanel`,
    which will create a decelerate exponential easing effect with the interpolation
    value `5`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，在 `StackPanel` 内添加以下 `RadioButton` 控件，这将创建一个具有插值值 `5` 的减速指数缓动效果：
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `ExponentialEase` effect:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `EasingMode` 的不同值，用于 `ExponentialEase` 效果：
- en: '![](img/5141208a-c2db-4f71-a24a-7440aab2ec36.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5141208a-c2db-4f71-a24a-7440aab2ec36.png)'
- en: PowerEase
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerEase
- en: It defines an easing function that creates an animation that accelerates/decelerates
    using the formula `f(t) = tp`, where `p` is equal to the value of the `Power`
    property. As with other easing functions, you can add an easing mode to specify
    whether the animation will accelerate or decelerate.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个缓动函数，该函数通过公式 `f(t) = tp` 创建动画，其中 `p` 等于 `Power` 属性的值。与其他缓动函数一样，你可以添加一个缓动模式来指定动画是加速还是减速。
- en: 'In this demonstration, add the following `RadioButton` that defines the `PowerEase`
    easing function to the `DoubleAnimation` specified:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，将以下定义 `PowerEase` 缓动函数的 `RadioButton` 添加到指定的 `DoubleAnimation` 中：
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can use `PowerEase` to substitute `QuadraticEase` [`f(t) = t2`], `CubicEase`
    [`f(t) = t3`], `QuarticEase` [`f(t) = t4`], and `QuinticEase` [`f(t) = t5`] type
    of easing functions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `PowerEase` 来替代 `QuadraticEase` [f(t) = t^2]，`CubicEase` [f(t) = t^3]，`QuarticEase`
    [f(t) = t^4]，和 `QuinticEase` [f(t) = t^5] 类型的缓动函数。
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `PowerEase` effect:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `EasingMode` 的不同值，用于 `PowerEase` 效果：
- en: '![](img/3fffc620-49dc-4af9-995f-d601a9051ed0.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fffc620-49dc-4af9-995f-d601a9051ed0.png)'
- en: QuadraticEase
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QuadraticEase
- en: 'It creates an animation that accelerates/decelerates using the formula `f(t)
    = t2`. You can use `PowerEase` to create the same behavior by specifying `Power="2"`.
    In this example, we will learn how to add the `QuadraticEase` function to an animation.
    Add the following mark-up inside the `StackPanel` that we have defined:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过公式 `f(t) = t^2` 创建一个加速/减速的动画。你可以通过指定 `Power="2"` 来使用 `PowerEase` 创建相同的行为。在这个例子中，我们将学习如何将
    `QuadraticEase` 函数添加到动画中。在定义的 `StackPanel` 内添加以下标记：
- en: '[PRE39]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuadraticEase` effect:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `EasingMode` 的不同值，用于 `QuadraticEase` 效果：
- en: '![](img/ea56386b-65d1-4321-8184-7c5a77f1e7b3.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea56386b-65d1-4321-8184-7c5a77f1e7b3.png)'
- en: QuarticEase
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QuarticEase
- en: 'Like `QuadraticEase`, you can also define `QuarticEase` to create an animation
    that accelerates/decelerates using the formula `f(t) = t4`. You can use `PowerEase`
    to create the same behavior by specifying `Power="4"`. Let''s add the following
    mark-up inside our `StackPanel` to define the animation with the said easing function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QuadraticEase`类似，你也可以定义`QuarticEase`来创建一个使用公式`f(t) = t4`进行加速/减速的动画。你可以通过指定`Power="4"`使用`PowerEase`来创建相同的行为。让我们在我们的`StackPanel`中添加以下标记来定义具有所述缓动函数的动画：
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuarticEase` effect:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了`QuarticEase`效果的`EasingMode`的不同值：
- en: '![](img/c39fa632-f23d-44ab-af62-35b387bfcea7.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c39fa632-f23d-44ab-af62-35b387bfcea7.png)'
- en: QuinticEase
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QuinticEase
- en: 'If you want to add the `QuinticEase` effect to your easing function, add it
    to your animation. It accelerates/decelerates using the formula `f(t) = t5`. You
    can use `PowerEase` to create the same by specifying `Power="5"`. Add the following
    `RadioButton` to define an animation with the `QuinticEase` easing function in
    our `StackPanel`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将`QuinticEase`效果添加到你的缓动函数中，请将其添加到你的动画中。它使用公式`f(t) = t5`进行加速/减速。你可以通过指定`Power="5"`使用`PowerEase`来创建相同的效果。将以下`RadioButton`添加到我们的`StackPanel`中，以定义具有`QuinticEase`缓动函数的动画：
- en: '[PRE41]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuinticEase` effect:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了`QuinticEase`效果的`EasingMode`的不同值：
- en: '![](img/3027a6c0-de5b-4766-9371-06db49cfde58.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3027a6c0-de5b-4766-9371-06db49cfde58.png)'
- en: SineEase
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SineEase
- en: 'This represents an easing function that creates an animation that accelerates
    and/or decelerates using a sine formula `f(t) = [1 - [sin(1 - t) * [pi / 2]]]`.
    Add the `EasingMode` property to accelerate and/or decelerate the effect. Let''s
    add the following code inside the `StackPanel`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表一个创建动画的缓动函数，该动画使用正弦公式`f(t) = [1 - [sin(1 - t) * [pi / 2]]]`进行加速和/或减速。将`EasingMode`属性添加到`StackPanel`中，以加速和/或减速效果。让我们添加以下代码：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `SineEase` effect:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了`SineEase`效果的`EasingMode`的不同值：
- en: '![](img/490dbba7-b709-4781-8889-df4cddf4139a.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/490dbba7-b709-4781-8889-df4cddf4139a.png)'
- en: 'Once you are ready, let''s build the project and run it. You will now see the
    following UI, which contains additional radio buttons inside the right-hand panel:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，让我们构建项目并运行它。你现在将看到以下UI，其中在右侧面板内包含额外的单选按钮：
- en: '![](img/99b9771d-cb86-4ccb-9f91-f4957d54ec4e.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99b9771d-cb86-4ccb-9f91-f4957d54ec4e.png)'
- en: Change the selection of the radios to see the animations for each easing function
    associated with them.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 更改单选按钮的选择，以查看与每个缓动函数关联的动画。
