- en: Chapter 8. Positions, Movement and Navigation for Character GameObjects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.角色GameObject的位置、移动和导航
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家对2D GameObject的控制（以及限制在矩形内的移动）
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家对3D GameObject的控制（以及限制在矩形内的移动）
- en: Choosing destinations – find the nearest (or a random) spawn point
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择目的地——找到最近的（或随机的）出生点
- en: Choosing destinations – respawn to the most recently passed checkpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择目的地——重生到最近通过的检查点
- en: NPC NavMeshAgent to seek or flee destination while avoiding obstacles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC NavMeshAgent在寻找或逃离目的地的同时避开障碍物
- en: NPC NavMeshAgent to follow waypoints in sequence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPC NavMeshAgent按顺序跟随航点
- en: Controlling the object group movement through flocking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集群控制对象组移动
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Many GameObjects in games move! Movement can be controlled by the player, by
    the (simulated) laws of physics in the environment, or by the **Non-Player Character**
    (**NPC**) logic; for example, objects that follow a path of waypoints, or seek
    (move towards) or flee (away) from the current position of a character. Unity
    provides several controllers, for first and third-person characters, and for vehicles
    such as cars and airplanes. GameObject movement can also be controlled through
    the state machines of the Unity Mecanim animation system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的许多GameObject都在移动！移动可以由玩家控制，由环境中的（模拟）物理定律控制，或者由**非玩家角色**（**NPC**）逻辑控制；例如，跟随路径上的航点、朝向（移动到）或逃离（远离）角色的当前位置的对象。Unity提供了多个控制器，用于第一人称和第三人称角色，以及汽车和飞机等车辆。GameObject的移动也可以通过Unity
    Mecanim动画系统的状态机来控制。
- en: However, there maybe times when you wish to tweak the Player character controllers
    from Unity, or write your own. You might wish to write directional logic—simple
    or sophisticated **Artificial Intelligence** (**AI**) to control the game's NPC
    and enemy characters. Such AI might involve your computer program making objects
    orient and move towards or away from characters or other game objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能有时你希望调整Unity中的玩家角色控制器，或者编写自己的控制器。你可能希望编写方向逻辑——简单或复杂的**人工智能**（**AI**）来控制游戏中的NPC和敌人角色。这种AI可能涉及你的计算机程序使对象朝向或远离角色或其他游戏对象。
- en: This chapter presents a range of such directional recipes, from which many games
    can benefit in terms of a richer and more exciting user experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列这样的方向性食谱，许多游戏可以从更丰富和更令人兴奋的用户体验中获得益处。
- en: Unity provides sophisticated classes and components including the Vector3 class
    and rigid body physics for modeling realistic movements, forces, and collisions
    in games. We make use of these game engine features to implement some sophisticated
    NPC and enemy character movements in the recipes of this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了包括Vector3类和刚体物理在内的复杂类和组件，用于在游戏中建模真实的移动、力和碰撞。我们利用这些游戏引擎功能来实现本章食谱中的一些复杂的NPC和敌人角色移动。
- en: The big picture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体概念
- en: For 3D games (and to some extent, 2D games as well), a fundamental class of
    object is the Vector3 class—objects that store and manipulate (x,y,z) values representing
    locations in 3D space. If we draw an imaginary arrow from the origin (0,0,0) to
    a point on space, then the direction and length of this arrow (vector) can represent
    a velocity or force (that is, a certain amount of magnitude in a certain direction).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3D游戏（以及在一定程度上，2D游戏），一个基本的对象类是Vector3类——存储和操作代表3D空间中位置的（x,y,z）值的对象。如果我们从一个假想的箭头从原点（0,0,0）到空间中的一个点，那么这个箭头的方向和长度（向量）可以表示速度或力（即，在某个方向上的一定量的幅度）。
- en: If we ignore all the character controller components, colliders, and the physics
    system in Unity, we can write code that teleports objects directly to a particular
    (x, y, z) location in our scene. And sometimes this is just what we want to do;
    for example, we may wish to spawn an object at a location. However, in most cases,
    if we want objects to move in more physically realistic ways, then we either apply
    a force to the object, or change its velocity component. Or if it has a Character
    Controller component, then we can send it a `Move()` message. With the introduction
    of Unity NavMeshAgents (and associated Navigation Meshes), we can now set a destination
    for an object with a NavMeshAgent, and then the built-in pathfinding logic will
    do the work of moving our NPC object on a path towards the given (x, y, z) destination
    location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略Unity中的所有角色控制器组件、碰撞器和物理系统，我们可以编写代码将对象直接传送到场景中的特定(x, y, z)位置。有时这正是我们想要的；例如，我们可能希望在一个位置生成一个对象。然而，在大多数情况下，如果我们想让对象以更物理现实的方式移动，那么我们要么对对象施加力，要么改变其速度分量。或者如果它有一个角色控制器组件，那么我们可以发送一个`Move()`消息给它。随着Unity
    NavMeshAgents（以及相关的导航网格）的引入，我们现在可以为具有NavMeshAgent的对象设置目的地，然后内置的路径查找逻辑将完成将我们的NPC对象沿着给定(x,
    y, z)目的地位置的路径移动的工作。
- en: As well as deciding which technique will be used to move an object, our game
    must also do the work of deciding how to choose the destination locations, or
    the direction and magnitude of changes to movement. This can involve logic to
    tell an NPC or enemy object the destination of the Player's character (to be moved
    towards, and then perhaps attacked when close enough). Or perhaps shy NPC objects
    will be given the direction to the Player's character, so that they can flee in
    the opposite direction, until they are a safe distance away.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了决定使用哪种技术来移动对象外，我们的游戏还必须决定如何选择目的地位置，或者移动方向和大小的变化。这可能涉及到逻辑，告诉NPC或敌人对象玩家的角色目的地（要移动到，然后在足够接近时攻击）。或者，可能害羞的NPC对象会被给予指向玩家角色的方向，这样它们就可以朝相反方向逃跑，直到它们到达一个安全距离。
- en: 'Other core concepts in the NPC object movement and creation (instantiation)
    include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: NPC对象移动和创建（实例化）的其他核心概念包括：
- en: Spawn points
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成点
- en: Specific locations in the scene where objects are to be created, or moved to
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中对象要创建或移动到的特定位置
- en: Waypoints
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路标
- en: The sequence of locations to define a path for NPCs or perhaps, the Player's
    character to follow
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义NPC或玩家角色要遵循的路径的位置序列
- en: Checkpoints
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查点
- en: Locations (or colliders) that, once passed through, change what happens in the
    game (for example, extra time, or if a Player's character gets killed, they respawn
    to the last crossed checkpoint, and so on)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（或碰撞器），一旦通过，就会改变游戏中的事件（例如，额外时间，或者如果玩家的角色被杀死，他们将在最后一个通过的检查点重生，等等）
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家控制2D游戏对象（以及限制其在矩形内的移动）
- en: While the rest of the recipes in this chapter are demonstrated in 3D projects,
    basic character movement in 2D, and also limiting the movement to a bounding rectangle,
    are core skills for many 2D games, and so this first recipe illustrates how to
    achieve these features for a 2D game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章中的其余食谱都是在3D项目中演示的，但2D中的基本角色移动以及限制移动到边界矩形是许多2D游戏的核心技能，因此这个第一个食谱说明了如何为2D游戏实现这些功能。
- en: Since in [Chapter 3](ch03.html "Chapter 3. 2D Animation"), *Inventory GUI*,
    we already have a basic 2D game, we'll adapt this game to restrict the movement
    to a bounding rectangle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在[第3章](ch03.html "第3章。2D动画"，*库存GUI*）中，我们已经有了一个基本的2D游戏，我们将适应这个游戏以限制移动到边界矩形。
- en: '![Player control of a 2D GameObject (and limiting the movement within a rectangle)](img/1362OT_08_11.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![玩家控制2D游戏对象（以及限制其在矩形内的移动）](img/1362OT_08_11.jpg)'
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on a simple 2D game called *Creating the Simple2DGame_SpaceGirl*
    mini-game from [Chapter 3](ch03.html "Chapter 3. 2D Animation"), *Inventory GUI*.
    Start with a copy of this game, or use the provided completed recipe project as
    the basis for this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基于一个简单的2D游戏，称为*Creating the Simple2DGame_SpaceGirl*迷你游戏，来自[第3章](ch03.html
    "第3章。2D动画"，*库存GUI*）。从这个游戏的副本开始，或者使用提供的完成食谱项目作为这个食谱的基础。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a 2D sprite controlled by the user with the movement that is limited
    within a rectangle, follow these steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用户控制的、在矩形内受限移动的2D精灵，请按照以下步骤操作：
- en: Create a new empty GameObject named **corner_max**, and position it somewhere
    above and to the right of the GameObject called **Player-girl1**. With this GameObject
    selected in the **Hierarchy** view, choose the large yellow oblong icon, highlighted
    in the **Inspector** panel.![How to do it...](img/1362OT_08_18.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空GameObject，命名为**corner_max**，并将其放置在名为**Player-girl1**的GameObject上方和右侧的位置。在**层次结构**视图中选择此GameObject，然后在**检查器**面板中选择大型的黄色椭圆形图标![如何操作...](img/1362OT_08_18.jpg)
- en: Duplicate the **corner_max** GameObject by naming the clone as **corner_min**,
    and position this clone somewhere below and to the left of the **player-spaceGirl1**
    GameObject. The coordinates of these two GameObjects will determine the maximum
    and minimum bounds of movement, permitted for the player's character.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**corner_max**GameObject，并将其克隆命名为**corner_min**，然后将此克隆放置在**player-spaceGirl1**GameObject下方和左侧的位置。这两个GameObject的坐标将确定玩家角色允许的最大和最小移动边界。
- en: 'Modify the C# Script called `PlayerMove` to declare some new variables at the
    beginning of the class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`PlayerMove`的C#脚本，在类开始处声明一些新的变量：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify the C# Script called `PlayerMove` so that the `Awake()` method now gets
    a reference to the SpriteRenderer, and uses this object to help setup the maximum
    and minimum X and Y movement limits:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`PlayerMove`的C#脚本，使`Awake()`方法现在获取SpriteRenderer的引用，并使用此对象来帮助设置最大和最小X和Y移动限制：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modify the C# Script called `PlayerMove` to declare a new method called `KeepWithinMinMaxRectangle()`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`PlayerMove`的C#脚本，声明一个新的方法，名为`KeepWithinMinMaxRectangle()`：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Modify the C# Script called `PlayerMove` so that, after having done everything
    else in the `FixedUpdate()`method, a call will finally be made to the `KeepWithinMinMaxRectangle()`
    method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`PlayerMove`的C#脚本，以便在`FixedUpdate()`方法中的所有其他操作完成后，最终调用`KeepWithinMinMaxRectangle()`方法：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the **player-SpaceGirl1** GameObject in the **Hierarchy** view, drag the
    **corner_max** and **corner_min** GameObjects over the public variables called
    `corner_max` and `corner_min` in the **Inspector**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择**player-SpaceGirl1**GameObject，将**corner_max**和**corner_min**GameObject拖放到**检查器**中的公共变量`corner_max`和`corner_min`上。
- en: Before running the scene in the **Scene** panel, try repositioning the **corner_max**
    and **corner_min** GameObjects. When you run the scene, the positions of these
    two GameObjects (max and min, and X and Y) will be used as the limits of movement
    for the Player's **player-SpaceGirl1** character.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板中运行场景之前，尝试重新定位**corner_max**和**corner_min**GameObject。当运行场景时，这两个GameObject（最大和最小，以及X和Y）的位置将被用作玩家**player-SpaceGirl1**角色的移动限制。
- en: 'While all this works fine, let''s make the rectangular bounds of the movement
    visually explicit in the **Scene** panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# script class called `PlayerMove`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然这一切都运行得很好，但让我们通过在**场景**面板中绘制一个黄色的“小工具”矩形来使运动的矩形边界在视觉上更加明确。向名为`PlayerMove`的C#脚本类中添加以下方法：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added the empty GameObjects called **corner_max** and **corner_min** to
    the scene. The X- and Y- coordinates of these GameObjects will be used to determine
    the bounds of movement that we will permit for the character called **player-SpaceGirl1**.
    Since these are the empty GameObjects, they will not be seen by the player when
    in the play-mode. However, we can see and move them in the **Scene** panel, and
    having added the yellow oblong icons, we can see their positions and names very
    easily.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将名为**corner_max**和**corner_min**的空GameObject添加到场景中。这些GameObject的X和Y坐标将用于确定允许名为**player-SpaceGirl1**的角色进行的移动边界。由于这些是空GameObject，因此在播放模式中玩家将看不到它们。然而，我们可以在**场景**面板中看到并移动它们，并且添加了黄色的椭圆形图标后，我们可以很容易地看到它们的位置和名称。
- en: Upon `Awake()` the `PlayerMoveWithLimits` object, inside the **player-SpaceGirl1**
    GameObject, records the maximum and minimum X- and Y- values of the GameObjects
    called **corner_max** and **corner_min**. Each time the physics system is called
    via the `FixedUpdate()` method, the velocity of the **player-SpaceGirl1** character
    is set according to the horizontal and vertical keyboard/joystick inputs. However,
    the final action of the `FixedUpdate()` method is to call the `KeepWithinMinMaxRectangle()`
    method, which uses the `Math.Clamp(…)` function to move the character back inside
    the X- and Y- limits. This happens so that the player's character is not permitted
    to move outside the area defined by the **corner_max** and **corner_min** GameObjects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `Awake()` 方法激活 `PlayerMoveWithLimits` 对象后，位于 **player-SpaceGirl1** GameObject
    内部记录了被称作 **corner_max** 和 **corner_min** 的 GameObject 的最大和最小 X- 和 Y- 值。每次通过 `FixedUpdate()`
    方法调用物理系统时，**player-SpaceGirl1** 角色的速度会根据水平方向和垂直方向的键盘/摇杆输入进行调整。然而，`FixedUpdate()`
    方法的最终操作是调用 `KeepWithinMinMaxRectangle()` 方法，该方法使用 `Math.Clamp(…)` 函数将角色移动回 X-
    和 Y- 的限制范围内。这样做是为了确保玩家的角色不被允许移动到由 **corner_max** 和 **corner_min** GameObjects
    定义的区域之外。
- en: The `OnDrawGizmos() m`ethod tests that the references to the **corner_max**
    and **corner_min** GameObjects are not null, and then sets the positions of the
    four Vector3 objects, representing the four corners defined by the rectangle with
    **corner_max** and **corner_min** at the opposite corners. It then sets the Gizmo
    color to yellow, and draws lines, connecting the four corners in the **Scene**
    panel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos()` 方法会检查对 **corner_max** 和 **corner_min** GameObjects 的引用是否不为空，然后设置代表由
    **corner_max** 和 **corner_min** 在对角处定义的矩形的四个角的四个 Vector3 对象的位置。然后设置 Gizmo 颜色为黄色，并在
    **场景** 面板中绘制连接四个角的线条。'
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the next recipe for more information about limiting player controlled
    character movements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下一菜谱以获取有关限制玩家控制的字符移动的更多信息。
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D GameObject 的玩家控制（以及限制矩形内的移动）
- en: Many of the 3D recipes in this chapter are built on this basic project, which
    constructs a scene with a textured terrain, a **Main Camera**, and a red cube
    that can be moved around by the user with the four directional arrow keys. The
    bounds of movement of the cube are constrained using the same technique as in
    the previous 2D recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多 3D 菜谱都是基于这个基本项目构建的，该项目构建了一个包含纹理地形、**主相机**和可以由用户使用四个方向箭头键移动的红色立方体的场景。立方体的移动范围使用与上一个
    2D 菜谱中相同的技术进行限制。
- en: '![Player control of a 3D GameObject (and limiting the movement within a rectangle)](img/1362OT_08_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![3D GameObject 的玩家控制（以及限制矩形内的移动）](img/1362OT_08_01.jpg)'
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a basic 3D cube controlled game, follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基本的 3D 立方体控制游戏，请按照以下步骤操作：
- en: Create a new, empty 3D project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 3D 项目。
- en: 'Once the project has been created, import the single Terrain Texture named
    `SandAlbedo` (it was named `GoodDirt` in Unity 4). Choose menu: **Assets | Import
    Package | Environments**, deselect everything, and then locate and tick the asset:
    `Assets/Environment/TerrainAssets/SurfaceTextures/ SandAlbedo.psd`.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建项目，导入名为 `SandAlbedo` 的单个地形纹理（在 Unity 4 中名为 `GoodDirt`）。选择菜单：**资产 | 导入包 |
    环境**，取消选择所有选项，然后定位并勾选资产：`Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd`。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You could have just added the Environment Asset Package when creating the project—but
    this would have imported 100s of files, and we only needed this one. Starting
    a project in Unity, then selectively importing just what we need is the best approach
    to take, if you want to keep the project's Asset folders to small sizes.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你本可以在创建项目时直接添加环境资产包——但这会导入 100 多个文件，而我们只需要这一个。如果你想要保持项目资产文件夹的大小尽可能小，那么在 Unity
    中开始项目然后只选择性地导入所需内容是最佳做法。
- en: Create a terrain positioned at (-15, 0, -10) and sized 30 by 20.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个位于 (-15, 0, -10) 且大小为 30x20 的地形。
- en: Note
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The transform position for the terrains relates to their corner and not their
    center.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 地形的变换位置与其角落相关，而不是中心。
- en: Since the Transform position of the terrains relates to the corner of the object,
    we center such objects at (0,0,0) by setting the X-coordinate equal to ( -1*width/2),
    and the Z-coordinate equal to (-1*length/2). In other words, we slide the object
    by half its width and half its height to ensure that its center is just where
    we want it.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于地形的变换位置与对象角落相关，我们通过将X坐标设置为(-1*width/2)和Z坐标设置为(-1*length/2)来将此类对象居中在(0,0,0)。换句话说，我们通过对象宽度的一半和高度的一半滑动对象，以确保其中心正好在我们想要的位置。
- en: In this case, the width is 30 and the length is 20, hence we get -15 for X (-1
    * 30/2), and -10 for Z (-1 * 20/2).
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，宽度为30，长度为20，因此我们得到X轴为-15（-1 * 30/2），Z轴为-10（-1 * 20/2）。
- en: Texture paint this terrain with your texture called `SandAlbedo`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的纹理`SandAlbedo`对地形进行纹理绘制。
- en: Create a directional light (it should face downwards to the terrain with the
    default settings—but if it doesn't for some reason, then rotate it so that the
    terrain is well lit).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方向光（它应该向下面对地形，使用默认设置——但如果由于某种原因没有这样做，则旋转它，以便地形得到良好的照明）。
- en: 'Make the following changes to the Main Camera:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对主摄像机进行以下修改：
- en: position = (0, 20, -15)
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置 = (0, 20, -15)
- en: rotation = (60, 0, 0)
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转 = (60, 0, 0)
- en: Change the **Aspect Ratio** of the **Game Panel** from **Free Aspect** to **4:3**.
    You will now see the whole of the **Terrain** in the **Game Panel**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**游戏面板**的**纵横比**从**自由纵横比**更改为**4:3**。现在您将在**游戏面板**中看到整个**地形**。
- en: Create a new empty GameObject named **corner_max**, and position it at (14,
    0, 9). With this GameObject selected in the **Hierarchy,** choose the large, yellow
    oblong icon, highlighted in the **Inspector** panel.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空GameObject，命名为**corner_max**，并将其放置在(14, 0, 9)。在**层次结构**中选择此GameObject，然后在**检查器**面板中选择大型的黄色椭圆形图标。
- en: Duplicate the **corner_max** GameObject, naming the clone as **corner_min**,
    and position this clone at (-14, 0, -9). The coordinates of these two GameObjects
    will determine the maximum and minimum bounds of the movement permitted for the
    player's character.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**corner_max** GameObject，将其克隆命名为**corner_min**，并将此克隆放置在(-14, 0, -9)。这两个GameObject的坐标将确定玩家角色允许的最大和最小移动范围。
- en: Create a new **Cube** GameObject named **Cube-player** at a position called
    (0, 0.5, 0), and size it as (1,1,1).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位置(0, 0.5, 0)创建一个新的名为**Cube-player**的**Cube** GameObject，并调整其大小为(1,1,1)。
- en: Add to the **Cube-player** GameObject, apply a component called **Physics |
    RigidBody**, and uncheck the **RigidBody** property **Use Gravity**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为**Physics | RigidBody**的组件添加到**Cube-player** GameObject中，并取消选中**RigidBody**属性的**Use
    Gravity**选项。
- en: Create a red **Material** named **m_red**, and apply this **Material** to **Cube-player**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**m_red**的红色**材质**，并将其应用到**Cube-player**上。
- en: 'Add the following C# script class called `PlayerControl` to the **Cube-player**:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下名为`PlayerControl`的C#脚本类添加到**Cube-player**：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the **Cube-player** GameObject selected in the **Hierarchy,** drag the
    GameObjects called **corner_max** and **corner_min** over the public variables
    called `corner_max` and `corner_min` in the **Inspector** panel.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**Cube-player** GameObject，将名为**corner_max**和**corner_min**的GameObject拖动到**检查器**面板中名为`corner_max`和`corner_min`的公共变量上。
- en: When you run the scene, the positions of the **corner_max** and **corner_min**
    GameObjects will define the bounds of movement for the Player's **Cube-player**
    character.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行场景时，**corner_max**和**corner_min** GameObject的位置将定义玩家**Cube-player**角色的移动范围。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The scene contains a positioned terrain so that its center is `(0,0,0)`. The
    red cube is controlled by the user's arrow keys through the `PlayerControl` script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 场景包含一个定位的地形，使其中心为`(0,0,0)`。红色立方体通过`PlayerControl`脚本来控制用户的箭头键。
- en: Just as with the previous 2D recipe, a reference to the (3D) RigidBody component
    is stored when the `Awake()` method executes, and the maximum and minimum X- and
    Z- values are retrieved from the two corner GameObjects, and is stored in the
    `x_min`, `x_max`, `z_min`, and `z_max` variables. Note that for this basic 3D
    game, we won't allow any Y-movement, although such movement (and bounding limits
    by adding a third 'max-height' corner GameObject) can be easily added by extending
    the code in this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的2D配方一样，当`Awake()`方法执行时，会存储(3D) RigidBody组件的引用，并从两个角落GameObject中检索最大和最小的X-和Z-值，存储在`x_min`、`x_max`、`z_min`和`z_max`变量中。请注意，对于这个基本的3D游戏，我们不会允许任何Y轴移动，尽管可以通过扩展这个配方中的代码轻松添加这种移动（以及通过添加第三个“最大高度”角落GameObject来设置边界限制）。
- en: The `KeyboardMovement() m`ethod reads the horizontal and vertical input values
    (which the Unity default settings read from the four directional arrow keys).
    Based on these left-right and up-down values, the velocity of the cube is updated.
    The amount it will move depends on the speed variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardMovement()`方法读取水平和垂直输入值（Unity默认设置从四个方向箭头键读取）。根据这些左右和上下值，更新立方体的速度。移动的量取决于速度变量。'
- en: The `KeepWithinMinMaxRectangle()` method uses the `Math.Clamp(…)` function to
    move the character back inside the X and Z limits, so that the player's character
    is not permitted to move outside the area defined by the **corner_max** and **corner_min**
    GameObjects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeepWithinMinMaxRectangle()`方法使用`Math.Clamp(…)`函数将角色移动回X和Z限制内，这样玩家角色就不被允许移动到由**corner_max**和**corner_min**GameObject定义的区域之外。'
- en: The `OnDrawGizmos()` method tests that the references to the **corner_max**
    and **corner_min** GameObjects are not null, and then sets the positions of the
    four Vector3 objects, representing the four corners defined by the rectangle with
    the **corner_max** and **corner_min** GameObjects at the opposite corners. It
    then sets the Gizmo color to **yellow**, and draws lines connecting the four corners
    in the **Scene** panel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos()`方法检查对**corner_max**和**corner_min**GameObject的引用是否不为null，然后设置四个Vector3对象的位置，这些对象代表由**corner_max**和**corner_min**GameObject在相对角落定义的矩形的四个角落。然后，将Gizmo颜色设置为**黄色**，并在**场景**面板中绘制连接四个角落的线条。'
- en: Choosing destinations – find the nearest (or a random) spawn point
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择目的地 – 找到最近的（或随机的）出生点
- en: Many games make use of spawn points and waypoints. This recipe demonstrates
    two very common examples of spawning—the choosing of either a random spawn point,
    or the nearest one to an object of interest (such as the Player's character),
    and then the instantiation of an object at that chosen point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏都使用出生点和航点。本食谱演示了两种非常常见的出生示例——选择随机出生点或选择一个感兴趣对象（如玩家角色）最近的出生点，然后在所选位置实例化一个对象。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the next steps.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于之前的食谱。因此，复制此项目，打开它，然后按照以下步骤操作。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find a random spawn point, follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到随机的出生点，请按照以下步骤操作：
- en: Create a **Sphere** sized as (1,1,1) at (2,2,2) position, and apply the `m_red`
    Material.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（2,2,2）位置创建一个大小为（1,1,1）的**Sphere**，并应用`m_red`材质。
- en: Create a new Prefab named `Prefab-ball`, and drag your **Sphere** into it (and
    then delete the **Sphere** from the **Hierarchy** panel).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Prefab，命名为`Prefab-ball`，并将你的**Sphere**拖放到其中（然后从**Hierarchy**面板中删除**Sphere**）。
- en: Create a new capsule object named `Capsule-spawnPoint` at (3, 0.5, 3), give
    it the tag as `Respawn` (this is one of the default tags that Unity provides).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（3, 0.5, 3）位置创建一个新的胶囊对象，命名为`Capsule-spawnPoint`，将其标签设置为`Respawn`（这是Unity提供的默认标签之一）。
- en: Note
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For testing, we'll leave these Respawn points visible. For the final game, we'll
    then uncheck the Mesh Rendered of each Respawn GameObject, so that they are not
    visible to the Player.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了测试，我们将保留这些重生点可见。对于最终游戏，我们将取消选中每个重生GameObject的Mesh Rendered，这样它们就不会对玩家可见。
- en: Make several copies of your **Capsule-spawnPoint** by moving them to different
    locations on the terrain.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的**胶囊-spawnPoint**复制到地形上的不同位置，以创建多个副本。
- en: 'Add an instance of the following C# script class called `SpawnBall` to the
    **Cube-the player** GameObject:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`SpawnBall`的以下C#脚本类的一个实例添加到**立方体-玩家**GameObject中：
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add an instance of the following C# script class called `SpawnPointManager`
    to the `Cube-player` GameObject:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`SpawnPointManager`的以下C#脚本类的一个实例添加到`Cube-player`GameObject中：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ensure that **Cube-player** is selected in the **Inspector** for the `SpawnBall`
    scripted component. Then, drag **Prefab-ball** over the public variable projectile
    called **Prefab Ball**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`SpawnBall`脚本组件中选择了**Cube-player**。然后，将**Prefab-ball**拖放到公共变量projectile的**Prefab
    Ball**上。
- en: Now, run your game. When you click on the mouse (fire) button, a sphere will
    be instantiated randomly to one of the capsule locations.![How to do it...](img/1362OT_08_04.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。当你点击鼠标（射击）按钮时，一个球体将以随机方式实例化到胶囊位置之一。![如何操作...](img/1362OT_08_04.jpg)
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The **Capsule-spawnPoint** objects represent candidate locations, where we might
    wish to create an instance of our ball Prefab. When our `SpawnPointManager` object,
    inside the **Cube-player** GameObject, receives the `Start()` message, the **respawns**
    GameObject array is set to the array, which is returned from the call to `FindGameObjectsWithTag("Respawn")`.
    This creates an array of all the objects in the scene with the tag called `Respawn`
    — that is, all our **Capsule-spawnPoint** objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Capsule-spawnPoint** 对象代表可能创建我们的球体 Prefab 的候选位置。当我们的 `SpawnPointManager`
    对象在 **Cube-player** GameObject 内接收到 `Start()` 消息时，**respawns** GameObject 数组被设置为从调用
    `FindGameObjectsWithTag("Respawn")` 返回的数组。这创建了一个包含场景中所有带有标签 `Respawn` 的对象的数组——即，所有我们的
    **Capsule-spawnPoint** 对象。'
- en: When our `SpawnBall` object GameObject **Cube-player** receives the `Start()`
    message, it sets the `spawnPointManager` variable to be a reference to its sibling
    `SpawnPointManager` script component. Next, we start the **coroutine** method
    called `CheckFireKeyAfterShortDelay()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `SpawnBall` 对象 GameObject **Cube-player** 接收到 `Start()` 消息时，它将 `spawnPointManager`
    变量设置为对其兄弟 `SpawnPointManager` 脚本组件的引用。接下来，我们开始名为 `CheckFireKeyAfterShortDelay()`
    的 **协程** 方法。
- en: The `CheckFireKeyAfterShortDelay()` method uses a typical Unity coroutine technique
    that goes into an infinite loop using a delay controlled by the value of the `testFireKeyDelay`
    variable. The delay is to make Unity wait before calling `CheckFireKey()` to test
    if the user wants a new sphere to be spawned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckFireKeyAfterShortDelay()` 方法使用典型的 Unity 协程技术，通过由 `testFireKeyDelay` 变量控制的延迟进入无限循环。这个延迟是为了让
    Unity 等待，然后再调用 `CheckFireKey()` 来测试用户是否想要生成一个新的球体。'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Coroutines are an advanced technique, where execution inside the method can
    be paused, and resumed from the same point. The `Yield` command temporarily halts
    the execution of code in the method, allowing Unity to go off and execute code
    in the other GameObjects and undertake physics and rendering work and more. They
    are perfect for situations where, at regular intervals, we wish to check whether
    something has happened (such as testing for the Fire key, or whether a response
    message has been received from an Internet request and so on).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种高级技术，其中方法内的执行可以暂停，并从相同点恢复。`Yield` 命令暂时暂停方法中的代码执行，允许 Unity 去执行其他 GameObject
    中的代码，以及执行物理和渲染工作等。它们非常适合在固定间隔检查是否发生了某些情况（例如测试 Fire 键，或者是否收到了来自互联网请求的响应等）的情况。
- en: Learn more about the Unity coroutines at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html)
    了解更多关于 Unity 协程的信息。
- en: The `SpawnBall` method `CheckFireKey()` tests whether, at that instant, the
    user is pressing the **Fire** button. If the **Fire** button is pressed, then
    the `CreateSphere()`method is called. Also, the `testFireKeyDelay` variable is
    set to 0.5\. This ensures that we won't test the **Fire** button again for half
    a second.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnBall` 方法 `CheckFireKey()` 测试在那个瞬间用户是否按下了 **Fire** 按钮。如果按下了 **Fire** 按钮，则调用
    `CreateSphere()` 方法。同时，将 `testFireKeyDelay` 变量设置为 0.5。这确保了我们在半秒内不会再次测试 **Fire**
    按钮。'
- en: The `SpawnBall` method `CreateSphere()`assigns variable `spawnPoint` to the
    `GameObject` returned by a call to the `RandomSpawnpoint(…)` method of our `spawnPointManager`.
    Then it creates a new instance of `prefab_Ball` (via the public variable) at the
    same position as the `spawnPoint` GameObject.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnBall` 方法 `CreateSphere()` 将变量 `spawnPoint` 赋值给由 `spawnPointManager` 的
    `RandomSpawnpoint(…)` 方法返回的 `GameObject`。然后，它在 `spawnPoint` GameObject 的相同位置创建
    `prefab_Ball` 的新实例（通过公共变量）。'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Choosing the nearest spawn point
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择最近的出生点
- en: Rather than just choosing a random spawn point, let's search through array spawnpoints,
    and choose the closest one to our player.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅选择一个随机的出生点，让我们遍历数组中的出生点，并选择离玩家最近的那个。
- en: 'To find the nearest spawn point, we need to do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最近的出生点，我们需要做以下几步：
- en: 'Add the following method to the C# script class called `SpawnPointManager`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到名为 `SpawnPointManager` 的 C# 脚本类中：
- en: '[PRE8]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to change the first line in the C# class called `SpawnBall` so
    that the `spawnPoint` variable is set by a call to our new method called `NearestSpawnpoint(…)`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更改名为 `SpawnBall` 的 C# 类中的第一行，以便通过调用我们新方法 `NearestSpawnpoint(…)` 来设置 `spawnPoint`
    变量：
- en: '[PRE9]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `NearestSpawnpoint(…)` method, we set `nearestSpawnpoint` to the first
    (array index 0) GameObject in the array as our default. We then loop through the
    rest of the array (array index 1 up to `spawnPoints.Length`). For each GameObject
    in the array, we test to see if its distance is less than the shortest distance
    so far, and if it is, then we update the shortest distance, and also set `nearestSpawnpoint`
    to the current element. When the array has been searched, we return the GameObject
    that the `nearestSpawnpoint` variable refers to.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NearestSpawnpoint(…)`方法中，我们将`nearestSpawnpoint`设置为数组中的第一个（数组索引0）游戏对象作为我们的默认值。然后我们遍历数组的其余部分（数组索引1到`spawnPoints.Length`）。对于数组中的每个游戏对象，我们测试其距离是否小于迄今为止的最短距离，如果是，则更新最短距离，并将`nearestSpawnpoint`设置为当前元素。当数组搜索完毕后，我们返回`nearestSpawnpoint`变量引用的游戏对象。
- en: Avoiding errors due to an empty array
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免因空数组导致的错误
- en: Let's make our code a little more robust, so that it can cope with the issue
    of an empty `spawnPoints` array—that is, when there are no objects tagged **Respawn**
    in the scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的代码更加健壮，以便它可以应对空`spawnPoints`数组的问题——即场景中没有标记为**Respawn**的对象。
- en: 'To cope with the no objects tagged **Respawn** we need to do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对没有标记为**Respawn**的对象，我们需要做以下操作：
- en: 'Improve our `Start()` method in the C# script class called `SpawnPointManager`,
    so that an ERROR is logged if the array of objects tagged **Respawn** is empty:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`SpawnPointManager`的C#脚本类中改进我们的`Start()`方法，以便如果标记为**Respawn**的对象数组为空，则记录一个ERROR：
- en: '[PRE10]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Improve the `RandomSpawnPoint()` and `NearestSpawnpoint()`methods in the C#
    script class called `SpawnPointManager`, so that they still return a GameObject
    even if the array is empty:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`SpawnPointManager`的C#脚本类中改进`RandomSpawnPoint()`和`NearestSpawnpoint()`方法，以便即使在数组为空的情况下也能返回一个游戏对象：
- en: '[PRE11]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Improve the `CreateSphere()`method in the C# class called `SpawnBall`, so that
    we only attempt to instantiate a new GameObject if the `RandomSpawnPoint()` and
    `NearestSpawnpoint()`methods have returned a non-null object reference:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`SpawnBall`的C#类中改进`CreateSphere()`方法，以便只有在`RandomSpawnPoint()`和`NearestSpawnpoint()`方法返回非空对象引用时，我们才尝试实例化一个新的游戏对象：
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC NavMeshAgent control to follow waypoints in sequence* recipe
    in this chapter for more information about waypoints.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的技术和代码可以用于选择重生点或航点。有关航点的更多信息，请参阅本章中的*NPC NavMeshAgent控制按顺序跟随航点*配方。
- en: Choosing destinations – respawn to the most recently passed checkpoint
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择目的地 – 重生到最近通过的检查点
- en: A **checkpoint** usually represents a certain distance through the game (or
    perhaps a **track**) in which an agent (user or NPC) has succeeded reaching. Reaching
    (or passing) checkpoints often results in bonus awards, such as *extra time*,
    *points*, *ammo*, and so on. Also, if a player has multiple lives, then often
    a player will be respawned only back as far as the most recently passed checkpoint,
    rather than right to the beginning of the level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查点**通常表示游戏中一定距离（或可能是一条**轨道**），其中代理（用户或NPC）成功到达。达到（或通过）检查点通常会带来奖励，如*额外时间*、*分数*、*弹药*等。此外，如果玩家有多个生命，那么通常玩家只会重生到最近通过的检查点，而不是直接回到关卡开始处。'
- en: This recipe demonstrates a simple approach to the checkpoints, whereby once
    the player's character has passed a checkpoint, if they die they are moved back
    only to the most recently passed checkpoint.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了一种简单的检查点方法，即一旦玩家的角色通过检查点，如果他们死亡，他们将被移回最近通过的检查点。
- en: '![Choosing destinations – respawn to the most recently passed checkpoint](img/1362OT_08_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![选择目的地 – 重生到最近通过的检查点](img/1362OT_08_09.jpg)'
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于您在本章开头创建的玩家控制的3D立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行操作。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To have the respawn position upon losing a life change depending on the checkpoints
    passed, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要使失去生命后的重生位置根据通过的检查点而变化，请按照以下步骤操作：
- en: Move the **Cube-player** GameObject to the (12, 0.5, 0) position.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Cube-player**游戏对象移动到(12, 0.5, 0)位置。
- en: Select **Cube-player** in the **Inspector** panel and add a **Character Controller**
    component by clicking on **Add Component** | **Physics** | **Character Controller**
    (this is to enable the `OnTriggerEnter` collision messages to be received).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**面板中选择**Cube-player**，通过点击**Add Component** | **Physics** | **Character
    Controller**添加一个**Character Controller**组件（这是为了启用接收`OnTriggerEnter`碰撞消息）。
- en: Create a cube named **Cube-checkpoint-1** at (5, 0, 0), scaled to (1, 1, 20).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(5, 0, 0)位置创建一个名为**Cube-checkpoint-1**的立方体，缩放为(1, 1, 20)。
- en: With **Cube-checkpoint-1** selected, check the **Is Trigger** property of its
    **Box Collider** component in the **Inspector** panel.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Cube-checkpoint-1**，在**Inspector**面板中检查其**Box Collider**组件的**Is Trigger**属性。
- en: Create a **CheckPoint** tag, and assign this tag to **Cube-checkpoint-1**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**CheckPoint**标签，并将此标签分配给**Cube-checkpoint-1**。
- en: Duplicate **Cube-checkpoint-1** by naming the **Cube-checkpoint-2** clone and
    positioning it at (-5, 0, 0).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名**Cube-checkpoint-2**克隆体并放置在(-5, 0, 0)的位置来复制**Cube-checkpoint-1**。
- en: Create a sphere named **Sphere-Death** at (7, 0.5, 0). Assign the **m_red**
    material to this sphere to make it red.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(7, 0.5, 0)位置创建一个名为**Sphere-Death**的球体。将**m_red**材质分配给这个球体，使其变为红色。
- en: With **Sphere-Death** selected, check the **Is Trigger** property of its **Sphere
    Collider** component in the **Inspector** panel.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Sphere-Death**，在**Inspector**面板中检查其**Sphere Collider**组件的**Is Trigger**属性。
- en: Create a **Death** tag, and assign this tag to **Sphere-Death**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**Death**标签，并将此标签分配给**Sphere-Death**。
- en: Duplicate **Sphere-Death**, and position this clone at (0, 0.5, 0).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Sphere-Death**，并将这个克隆体放置在(0, 0.5, 0)的位置。
- en: Duplicate **Sphere-Death** a second time, and position this second clone at
    (-10, 0.5, 0).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二次复制**Sphere-Death**，并将这个第二个克隆体放置在(-10, 0.5, 0)的位置。
- en: 'Add an instance of the following C# script class called `CheckPoints` to the
    **Cube-player** GameObject:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下名为`CheckPoints`的C#脚本类的一个实例添加到**Cube-player**GameObject中：
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the scene. If the cube runs into a red sphere *before* crossing a checkpoint,
    it will be respawned back to its starting position. Once the red cube has passed
    a checkpoint, if a red sphere is hit, then the cube will be moved back to the
    location of the most recent checkpoint that it passed through.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。如果方块在通过检查点之前撞到了红色球体，它将被重新生成到其起始位置。一旦红色方块通过检查点，如果击中了红色球体，则方块将被移动到它最近通过的检查点的位置。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The C# script class called `CheckPoints` has one variable called `respawnPosition`,
    which is a Vector3 that refers to the position the player's cube is to be moved
    to (respawned) if it collides with a **Death** tagged object. The default setting
    for this is the position of the player's cube when the scene begins—so in the
    `Start()`method, we set it to the player's position.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckPoints`这个C#脚本类有一个名为`respawnPosition`的变量，它是一个Vector3，指向玩家方块要移动到（重新生成）的位置，如果它与标记为**Death**的对象发生碰撞。此变量的默认设置是场景开始时玩家方块的位置——因此，在`Start()`方法中，我们将其设置为玩家的位置。'
- en: Each time an object tagged called **CheckPoint** is collided with, the value
    of `respawnPosition` is updated to the current position of the player's red cube
    at this point in time (that is, where it is when it touches the stretched cube
    tagged called **CheckPoint**). So that the next time the object tagged **Death**
    is hit, the cube will be respawned back to where it last touched the object tagged
    called **CheckPoint**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当与标记为**CheckPoint**的对象发生碰撞时，`respawnPosition`的值将更新为玩家红色方块在此时刻的位置（即它接触标记为**CheckPoint**的拉伸方块时的位置）。这样，下次标记为**Death**的对象被击中时，方块将被重新生成到它上次接触标记为**CheckPoint**的对象的位置。
- en: NPC NavMeshAgent to seek or flee destination while avoiding obstacles
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC NavMeshAgent在寻找或逃离目的地的同时避开障碍物
- en: The introduction of Unity's NavMeshAgent has greatly simplified the coding for
    NPC and enemy agent behaviors. In this recipe, we'll add some wall (scaled cubes)
    obstacles, and generate a NavMesh, so that Unity knows not to try to walk through
    the walls. We then add a NavMeshAgent component to our NPC GameObject, and tell
    it to head to a stated destination location by intelligently planning and following
    a path, while avoiding the wall obstacles.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的NavMeshAgent的引入大大简化了NPC和敌人代理行为的编码。在这个菜谱中，我们将添加一些墙壁（缩放立方体）障碍物，并生成一个NavMesh，这样Unity就知道不要试图穿过墙壁。然后我们向NPC
    GameObject添加一个NavMeshAgent组件，并告诉它通过智能规划和跟随路径前往一个指定的目的地位置，同时避开墙壁障碍物。
- en: In the next screenshot, we can see in the **Scene** panel the squares that represent
    potential points on the path. We can also see lines showing the current temporary
    direction and destination around the current obstacle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张截图的**场景**面板中，我们可以看到代表路径上潜在点的正方形。我们还可以看到显示当前临时方向和目的地以及当前障碍物周围的线条。
- en: When the **Navigation** panel is visible, then the **Scene** panel displays
    the blue-shaded *walkable* areas, and unshaded, non-walkable areas at the edge
    of the terrain and around each of the two *wall* objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当**导航**面板可见时，**场景**面板显示蓝色阴影的**可通行**区域，以及在地形边缘和每个两个**墙**对象周围的未着色、不可通行区域。
- en: '![NPC NavMeshAgent to seek or flee destination while avoiding obstacles](img/1362OT_08_05.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![NPC NavMeshAgent寻求或逃离目的地同时避开障碍物](img/1362OT_08_05.jpg)'
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于您在本章开头创建的玩家控制的3D立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make an object seek or flee from a position, follow these steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个对象从一个位置寻求或逃离，请遵循以下步骤：
- en: Delete the **Cube-player** GameObject, since we are going to be creating an
    NPC computer controlled agent.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Cube-player** GameObject，因为我们将要创建一个NPC电脑控制代理。
- en: Create a sphere named **Sphere-arrow** that is positioned at (2, 0.5, 2). Scale
    it as (1,1,1).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Sphere-arrow**的球体，其位置在(2, 0.5, 2)。将其缩放为(1,1,1)。
- en: Create a second sphere named **Sphere-small**. Scale it as (0.5, 0.5, 0.5).
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为**Sphere-small**的球体。将其缩放为(0.5, 0.5, 0.5)。
- en: Child **Sphere-small** to **Sphere-arrow** and position it at (0, 0, 0.5).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sphere-small**子对象化到**Sphere-arrow**，并将其位置设置为(0, 0, 0.5)。
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Childing** refers to making one GameObject, in the **Hierarchy** panel, a
    child of another GameObject. This is done by dragging the object that is to be
    childed over the object to be the parent. Once completed, the parent-child relationship
    is indicated visually by all children being right-indented and positioned immediately
    below their parent in the **Hierarchy** panel. If a parent object is transformed
    (moved/scaled/rotated), then all its children will also be transformed accordingly.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**子对象化**指的是在**层次结构**面板中，将一个GameObject设置为另一个GameObject的子对象。这是通过将作为子对象的物体拖动到作为父对象的物体上完成的。一旦完成，父-子关系将通过所有子对象在**层次结构**面板中右缩进并立即位于其父对象下方来视觉上表示。如果一个父对象被变换（移动/缩放/旋转），那么所有其子对象也将相应地变换。'
- en: In the **Inspector** panel, add a new NavMeshAgent to **Sphere-arrow**; choose
    **Add Component** | **Navigation** | **Nav Mesh Agent**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，为**Sphere-arrow**添加一个新的NavMeshAgent；选择**添加组件** | **导航** | **Nav
    Mesh Agent**。
- en: Set the **Stopping Distance** property of **NavMeshAgent** component to `2`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**NavMeshAgent**组件的**停止距离**属性设置为`2`。
- en: 'Add the following C# script class called `ArrowNPCMovement` to GameObject **Sphere-arrow**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下名为`ArrowNPCMovement`的C#脚本类添加到**Sphere-arrow** GameObject：
- en: '[PRE14]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ensure that **Sphere-arrow** is selected in the **Inspector** panel for the
    `ArrowNPCMovement` scripted component. Drag **Capsule-destination** over the variable
    **Projectile** called **Target GO**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**检查器**面板中选择**Sphere-arrow**的`ArrowNPCMovement`脚本组件。将**Capsule-destination**拖动到名为**Target
    GO**的变量**投射物**上。
- en: Create a 3D cube named **Cube-wall** at (-6, 0, 0), and scale it to (1, 2, 10).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-6, 0, 0)处创建一个名为**Cube-wall**的3D立方体，并将其缩放为(1, 2, 10)。
- en: Create another 3D cube named **Cube-wall** at (-2, 0, 6), and scale it to (1,
    2, 7).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-2, 0, 6)处创建另一个名为**Cube-wall**的3D立方体，并将其缩放为(1, 2, 7)。
- en: Display the **Navigation** panel by choosing **Window** | **Navigation**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**窗口** | **导航**来显示**导航**面板。
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A great place to *dock* the **Navigation** panel is next to the **Inspector**
    panel since you will never be using the **Inspect** and **Navigation** panels
    at the same time.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将**导航**面板放置在**检查器**面板旁边是一个很好的地方，因为您永远不会同时使用**检查**和**导航**面板。
- en: In the **Hierarchy** tab, select both of the **Cube-wall** objects (we select
    the objects that are *not* supposed to be a part of the **walkable** parts of
    our scene), and then in the **Navigation** panel, check the **Navigation Static**
    checkbox. Then, click on the **Bake** button at the bottom of the **Navigation**
    panel. When the **Navigation** panel is displayed, you'll see a blue *tint* on
    the parts of the **Scene** that are walkable. Candidate areas for a **NavMeshAgent**
    are supposed to be considered as parts of a path to a destination.![How to do
    it...](img/1362OT_08_06.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 选项卡中，选择两个 **Cube-wall** 对象（我们选择那些不应该成为场景可走部分的对象），然后在 **Navigation**
    面板中，勾选 **Navigation Static** 复选框。然后，点击 **Navigation** 面板底部的 **Bake** 按钮。当 **Navigation**
    面板显示时，你会在 **Scene** 面板中可走的区域看到蓝色 **tint**。**NavMeshAgent** 的候选区域应该被视为通往目的地的路径的一部分。![如何操作...](img/1362OT_08_06.jpg)
- en: Now run your game. You will see the **Sphere-arrow** GameObject automatically
    move towards the **Capsule-destination** GameObject, following a path that avoids
    the two wall objects.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行你的游戏。你会看到 **Sphere-arrow** GameObject 自动移动到 **Capsule-destination** GameObject，沿着一条避开两个墙壁对象的路径。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The **NavMeshAgent** component that we added to GameObject **Sphere-arrow**
    does most of the work for us. **NavMeshAgents** need 2 things: a destination location
    to head towards, and a **NavMesh** component of the terrain with walkable/non-walkable
    areas, so that it can plan a path, avoiding obstacles. We created two obstacles
    (the **Cube-wall** objects), and these were selected when we created **NavMesh**
    for this scene in the **Navigation** panel.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到 GameObject **Sphere-arrow** 的 **NavMeshAgent** 组件为我们做了大部分工作。**NavMeshAgents**
    需要 2 件事情：一个要前往的目标位置，以及具有可走/不可走区域的地面 **NavMesh** 组件，这样它就可以规划路径，避开障碍物。我们创建了两个障碍物（**Cube-wall**
    对象），并在创建此场景的 **Navigation** 面板中创建 **NavMesh** 时选择了这些对象。
- en: The location for our NPC object to travel towards is the position of the **Capsule-destination**
    GameObject at (-12, 0, 8); but of course, we could just move this object in the
    **Scene** panel at **Design-time**, and its new position would be the destination
    when we run the game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 NPC 对象要前往的位置是 **Capsule-destination** GameObject 在 (-12, 0, 8) 的位置；但当然，我们可以在
    **Scene** 面板中的 **Design-time** 移动这个对象，并且当运行游戏时，它的新位置将是目的地。
- en: 'The C# script class called `ArrowNPCMovement` has two variables: one is a reference
    to the destination GameObject, and the second is a reference to the NavMeshAgent
    component of the GameObject in which our instance of the `ArrowNPCMovement` class
    is also a component. When the scene starts, via the `Start()` method, the **NavMeshAgent**
    sibling component is found, and the `HeadForDestination()` method is called, which
    sets the destination of the NavMeshAgent to the position of the destination GameObject.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `ArrowNPCMovement` 的 C# 脚本类有两个变量：一个是目标 GameObject 的引用，另一个是我们 `ArrowNPCMovement`
    类实例所在的 GameObject 的 NavMeshAgent 组件的引用。当场景开始时，通过 `Start()` 方法，找到 **NavMeshAgent**
    同级组件，并调用 `HeadForDestination()` 方法，将 NavMeshAgent 的目标位置设置为目标 GameObject 的位置。
- en: Once the NavMeshAgent has a target to head towards, it will plan a path there
    and will keep moving until it arrives (or gets within the **Stopping Distance**
    if that parameter has been set to a distance greater than zero).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 NavMeshAgent 有了一个要前往的目标，它将规划一条路径并持续移动，直到到达（或者如果设置了大于零的停止距离参数，则到达停止距离内）。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ensure that the object with the NavMeshAgent component is selected in the **Hierarchy**
    panel at runtime to be able to see this navigation data in the **Scene** panel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在运行时选择带有 NavMeshAgent 组件的对象在 **Hierarchy** 面板中，以便能够在 **Scene** 面板中看到这些导航数据。
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: Constantly updating the NavMeshAgent destination to Player's character current
    location
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续更新 NavMeshAgent 的目标位置到玩家角色的当前位置
- en: Rather than a destination that is fixed when the scene starts, let's allow the
    **Capsule-destination** object to be moved by the player while the scene is running.
    In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination
    to wherever the **Capsule-destination** has been moved to.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在场景开始时固定的目标，让我们允许 **Capsule-destination** 对象在场景运行时被玩家移动。在每一帧，我们将重置 NPC 箭头的
    NavMeshAgent 的目标位置到 **Capsule-destination** 被移动到的位置。
- en: 'To allow the user movement of the destination object and frame-by-frame updating
    of NavMeshAgent destination, we need to do the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许用户移动目标对象并逐帧更新 NavMeshAgent 目标，我们需要做以下事情：
- en: Add an instance of the C# script class called `PlayerControl` as a component
    of **Capsule-destination**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `PlayerControl` 的 C# 脚本类实例添加为 **胶囊目标** 的组件。
- en: 'Update the C# script class called `ArrowNPCMovement` so that we call the `HeadForDestintation()`
    method every frame, that is, from `Update()`, rather than just once in `Start()`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新名为 `ArrowNPCMovement` 的 C# 脚本类，以便我们每帧调用 `HeadForDestintation()` 方法，即从 `Update()`
    而不是仅在 `Start()` 中调用一次：
- en: '[PRE15]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, when you run the game, you can use the arrow keys to move the destination
    location, and the NavMeshAgent will update its paths in each frame, based on the
    updated position of the **Capsule-destination** GameObject.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏时，你可以使用箭头键来移动目标位置，NavMeshAgent 将根据 **胶囊目标** GameObject 的更新位置在每一帧更新其路径。
- en: Constantly update NavMeshAgent destination to flee away from Player's character
    current location
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不断更新 NavMeshAgent 目标以避开玩家角色的当前位置
- en: Rather than seeking towards the player's current position, let's make our NPC
    agent always attempt to flee away from the player's location. For example, an
    enemy with very low-health points might run away, and so gain time to regain its
    health before fighting again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是朝向玩家的当前位置寻求，让我们让我们的 NPC 代理始终尝试避开玩家的位置。例如，一个健康值非常低的敌人可能会逃跑，从而在再次战斗之前获得恢复健康的时间。
- en: '![Constantly update NavMeshAgent destination to flee away from Player''s character
    current location](img/1362OT_08_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![不断更新 NavMeshAgent 目标以避开玩家角色的当前位置](img/1362OT_08_10.jpg)'
- en: 'To instruct our NavMeshAgent to flee away from the player''s location, we need
    to replace the C# script class called `ArrowNPCMovement` with the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示我们的 NavMeshAgent 避开玩家的位置逃跑，我们需要用以下内容替换名为 `ArrowNPCMovement` 的 C# 脚本类：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Start()` method caches a reference to the NavMeshAgent component, and also
    calculates the `runAwayDistance` variable to be twice the NavMeshAgent's stopping
    distance (although this can be changed by changing the value of the `runAwayMultiplier`
    variable accordingly). When the distance to the enemy is less than the value of
    this variable, then we'll instruct the computer-controlled object to flee in the
    opposite direction.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法缓存了 NavMeshAgent 组件的引用，并计算 `runAwayDistance` 变量，使其为 NavMeshAgent
    停止距离的两倍（尽管可以通过相应地更改 `runAwayMultiplier` 变量的值来改变这个值）。当到敌人的距离小于这个变量的值时，我们将指示由计算机控制的对象向相反方向逃跑。'
- en: The `Update()` method calculates whether the distance to the enemy is within
    the `runAwayDistance`, and if so, it calls the `FleeFromTarget(…)` method that
    passes the location of the enemy as a parameter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法计算到敌人的距离是否在 `runAwayDistance` 范围内，如果是，则调用传递敌人位置作为参数的 `FleeFromTarget(…)`
    方法。'
- en: The `FleeFromTarget(…)` method calculates a point that is the `runAwayDistance`
    Unity units away from the Player's cube, in a direction that is directly away
    from the computer-controlled object. This is achieved by subtracting the enemy
    position vector from the current transform's position. Finally, the `HeadForDestintation(…)`
    method is called, passing the flee-to position, which results in the NavMeshAgent
    being told to set the location as its new destination.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`FleeFromTarget(…)` 方法计算一个点，该点距离玩家的立方体 `runAwayDistance` Unity 单位，方向是直接远离由计算机控制的对象。这是通过从当前变换的位置减去敌人位置向量来实现的。最后，调用
    `HeadForDestintation(…)` 方法，传递逃跑到的位置，这将导致 NavMeshAgent 被指示将位置设置为新的目标。'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Unity units are arbitrary, since they are just numbers in a computer. However,
    in most cases, it simplifies things to think of distances in terms of meters (1
    Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram).
    Of course, if your game is based on a microscopic world, or a pan-galatic space
    travel and more, then you need to decide what each Unity unit corresponds to for
    your game context. For more discussion of units in Unity, check out the [http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487)
    link.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的单位是任意的，因为它们只是计算机中的数字。然而，在大多数情况下，将距离视为米（1 Unity单位 = 1米）和将质量视为千克（1 Unity单位
    = 1千克）可以简化事情。当然，如果您的游戏基于微观世界或全银河系太空旅行等，那么您需要决定每个Unity单位在您的游戏上下文中对应什么。有关Unity中单位的更多讨论，请参阅[http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487)链接。
- en: 'As the following screenshot illustrates, the NavMeshAgent plans a path to the
    position to flee towards:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，NavMeshAgent规划了一条逃向位置的路径：
- en: '![Constantly update NavMeshAgent destination to flee away from Player''s character
    current location](img/1362OT_08_17.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![不断更新NavMeshAgent目标以逃离玩家角色当前位置](img/1362OT_08_17.jpg)'
- en: Create a mini point-and-click game
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个迷你点选游戏
- en: Another way to choose the destination for our **Sphere-arrow** GameObject is
    by the user clicking on an object on the screen, and then the **Sphere-arrow**
    GameObject moving to the location of the clicked object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种为我们的**Sphere-arrow**游戏对象选择目标的方法是通过用户点击屏幕上的一个对象，然后**Sphere-arrow**游戏对象移动到被点击对象的当前位置。
- en: 'To allow the user to select the destination objects with point-and-click, we
    need to do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许用户通过点选选择目标对象，我们需要做以下操作：
- en: Remove the `ArrowNPCMovement` component from the **Sphere-arrow** GameObject.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Sphere-arrow**游戏对象中移除`ArrowNPCMovement`组件。
- en: Create some target objects, such as a black cube, a blue sphere, and a green
    cylinder. Note that, to be a target, each object needs to have a collider component
    in order to receive the `OnMouseOver` event messages (when creating primitives
    objects from the Unity menu **Create** | **3D Object**, the colliders are automatically
    created).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些目标对象，例如一个黑色立方体、一个蓝色球体和一个绿色圆柱体。请注意，为了成为目标，每个对象都需要一个碰撞器组件以便接收`OnMouseOver`事件消息（从Unity菜单**创建**
    | **3D对象**创建原生物体时，会自动创建碰撞器）。
- en: 'Add an instance of the following C# script class called `ClickMeToSetDestination`
    to each of the GameObjects that you wish to be a clickable target:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下名为`ClickMeToSetDestination`的C#脚本类实例添加到您希望成为可点击目标的每个GameObject中：
- en: '[PRE17]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, while running the game, when your mouse is over one of the three objects,
    that object will be highlighted yellow. If you click on the mouse button when
    the object is highlighted, the **Sphere-arrow** GameObject will make its way up
    to (but stopping just before) the clicked object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当运行游戏时，当您的鼠标悬停在三个对象之一上时，该对象将被突出显示为黄色。如果您在对象突出显示时点击鼠标按钮，**Sphere-arrow**游戏对象将前往（但停在点击对象之前）。
- en: NPC NavMeshAgent to follow the waypoints in a sequence
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC NavMeshAgent按顺序跟随航点
- en: Waypoints are often used as a guide to make autonomously moving NPCs and enemies
    follow a path in a general way (but be able to respond with other directional
    behaviors, such as flee or seek, if friends/predators/prey are sensed nearby).
    The waypoints are arranged in a sequence, so that when the character reaches,
    or gets close to a waypoint, it will then select the next waypoint in the sequence
    as the target location to move towards. This recipe demonstrates an arrow object
    moving towards a waypoint, and then, when it gets close enough, it will choose
    the next waypoint in the sequence as the new target destination. When the last
    waypoint has been reached, it again starts heading towards the first waypoint.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 航点通常用作引导，使自主移动的NPC和敌人以一般方式跟随路径（但如果附近检测到朋友/捕食者/猎物，则能够响应其他方向行为，如逃跑或寻找）。航点按顺序排列，因此当角色到达或接近航点时，它将选择序列中的下一个航点作为移动的目标位置。本配方演示了一个箭头对象向航点移动，然后，当它足够接近时，它将选择序列中的下一个航点作为新的目标目的地。当到达最后一个航点后，它再次开始向第一个航点前进。
- en: Since Unity's NavMeshAgent has simplified coding NPC behavior, our work in this
    recipe becomes basically finding the position of the next waypoint, and then telling
    the NavMeshAgent that this waypoint is its new destination.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity的NavMeshAgent简化了NPC行为的编码，我们在这个配方中的工作基本上是找到下一个航点的位置，然后告诉NavMeshAgent这个航点是其新的目的地。
- en: '![NPC NavMeshAgent to follow the waypoints in a sequence](img/1362OT_08_08.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![NPC NavMeshAgent 按顺序跟随航点](img/1362OT_08_08.jpg)'
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于您在本章开头创建的玩家控制3D立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行操作。
- en: For this recipe, we have prepared the yellow brick texture image that you need
    in a folder named `Textures` in the `1362_08_06` folder`.`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`1362_08_06`文件夹中的`Textures`文件夹中准备了您需要的黄色砖块纹理图像。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To instruct an object to follow a sequence of waypoints, follow these steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示一个对象按照航点的顺序进行跟随，请按照以下步骤操作：
- en: Delete the **Cube-player** GameObject, since we are going to be creating an
    NPC computer controlled agent.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Cube-player**游戏对象，因为我们将要创建一个NPC电脑控制代理。
- en: Create a sphere named **Sphere-arrow**, position at (2, 0.5, 2), and scale it
    as (1,1,1).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Sphere-arrow**的球体，定位在(2, 0.5, 2)，并按(1,1,1)的比例缩放。
- en: Create a second sphere named **Sphere-small**, and scale it as (0.5, 0.5, 0.5).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为**Sphere-small**的球体，并按(0.5, 0.5, 0.5)的比例缩放。
- en: Child **Sphere-small** to **Sphere-arrow**, and then position it at (0, 0, 0.5).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sphere-small**到**Sphere-arrow**，然后将其定位在(0, 0, 0.5)。
- en: In the **Inspector,** add a new NavMeshAgent to **Sphere-arrow**, and then choose
    **Add Component** | **Navigation** | **NavMeshAgent**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，向**Sphere-arrow**添加一个新的NavMeshAgent，然后选择**添加组件** | **导航** | **NavMeshAgent**。
- en: Set the **Stopping Distance** property of the **NavMeshAgent** component to
    `2`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**NavMeshAgent**组件的**停止距离**属性设置为`2`。
- en: Display the **Navigation** panel by choosing **Window** | **Navigation**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**窗口** | **导航**来显示**导航**面板。
- en: Click on the **Bake** button at the bottom of the **Navigation** panel. When
    the **Navigation** panel is displayed, you'll see a blue *tint* on the parts of
    the **Scene** panel that are walkable, which will be all parts of the terrain,
    except near the edges.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**导航**面板底部的**烘焙**按钮。当**导航**面板显示时，您将在**场景**面板的可行走部分看到蓝色**色调**，这将是地形的所有部分，除了边缘附近。
- en: 'Add an instance of the following C# script class called `ArrowNPCMovement`
    to the **Sphere-arrow** GameObject:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ArrowNPCMovement`的以下C#脚本类实例添加到**Sphere-arrow**游戏对象中：
- en: '[PRE18]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a new capsule object named **Capsule-waypoint-0** at (-12, 0, 8), and
    give it the **waypoint** tag.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(-12, 0, 8)位置创建一个新的胶囊对象**Capsule-waypoint-0**，并赋予它**航点**标签。
- en: Copy **Capsule-waypoint -0,** name the copy as **Capsule-waypoint -3,** and
    position this copy at (8, 0, -8).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**胶囊-航点 -0**，将其命名为**胶囊-航点 -3**，并将此副本定位在(8, 0, -8)。
- en: Note
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are going to add some intermediate waypoints numbered 1 and 2 later on. This
    is why our second waypoint here is numbered 3, in case you were wondering.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后将要添加一些中间的航点，编号为1和2。这就是为什么我们的第二个航点编号为3，以防您有所疑问。
- en: 'Add the following C# script class called `WaypointManager` to the **Sphere-arrow**
    GameObject:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`WaypointManager`的以下C#脚本类添加到**Sphere-arrow**游戏对象中：
- en: '[PRE19]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ensure that **Sphere-arrow** is selected in the **Inspector** for the `WaypointManager`
    scripted component. Drag **Capsule-waypoint-0** and **Capsule-waypoint-3** over
    the public variable projectile called **Way Point 0** and **Way Point 3,** respectively.![How
    to do it...](img/1362OT_08_07.jpg)
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**检查器**中选择了`WaypointManager`脚本组件的**Sphere-arrow**。将**Capsule-waypoint-0**和**Capsule-waypoint-3**拖到名为**航点
    0**和**航点 3**的公共变量projectile上。![如何操作...](img/1362OT_08_07.jpg)
- en: Display the Navigation panel by choosing **Window | Navigation**.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**窗口 | 导航**来显示导航面板。
- en: Click on the **Bake** button at the bottom of the **Navigation** panel. When
    the **Navigation** panel is displayed, you'll see a blue *tint* on the parts of
    the **Scene** that are *walkable*, which will be all the parts of the terrain,
    except near the edges.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**导航**面板底部的**烘焙**按钮。当**导航**面板显示时，您将在**场景**的可行走部分看到蓝色**色调**，这将是地形的所有部分，除了边缘附近。
- en: Now, run your game. The arrow object will first move towards one of the waypoint
    capsules, then when it gets close to it, it will slow down, turn around, head
    towards the other waypoint capsule, and keep doing that continuously.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。箭头对象将首先移动到其中一个waypoint胶囊，然后当它靠近时，它会减速，转身，朝向另一个waypoint胶囊前进，并持续这样做。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The **NavMeshAgent** component that we added to the **Sphere-arrow** GameObject
    does most of the work for us. **NavMeshAgents** need two things: a destination
    location to head towards, and a NavMesh, so that it can plan a path, avoiding
    obstacles.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到**Sphere-arrow** GameObject中的**NavMeshAgent**组件为我们做了大部分工作。**NavMeshAgents**需要两样东西：一个目的地位置来前往，以及一个NavMesh，以便它可以规划路径，避开障碍物。
- en: 'We created two possible waypoints to be the location for our NPC to move towards:
    **Capsule-waypoint-0** and **Capsule-waypoint-3**.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个可能的waypoint作为NPC移动的位置：**Capsule-waypoint-0**和**Capsule-waypoint-3**。
- en: 'The C# script class called `WaypointManager` has one job — to return a reference
    to the next waypoint that our NPC should head towards. There are two variables:
    `wayPoint0` and `wayPoint3` that reference to the two waypoint GameObjects in
    our scene. The `NextWaypoint(…)` method takes a single parameter named `current`,
    which is a reference to the current waypoint that the object was moving towards
    (or null). This method''s task is to return a reference to the **next** waypoint
    that the NPC should travel towards. The logic for this method is simple—if `current`
    refers to `waypoint0`, then we''ll return `waypoint3`, otherwise we''ll return
    `waypoint0`. Note that if we pass this `null` method, then we''ll get `waypoint0`
    back (so, it is our default first waypoint).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: C#脚本类`WaypointManager`有一个任务——返回我们的NPC应该前往的下一个waypoint的引用。有两个变量：`wayPoint0`和`wayPoint3`，它们分别引用场景中的两个waypoint
    GameObject。`NextWaypoint(…)`方法接受一个名为`current`的单个参数，它是对象移动方向上的当前waypoint的引用（或null）。此方法的任务是返回NPC应该前往的**下一个**waypoint的引用。此方法的逻辑很简单——如果`current`指向`waypoint0`，则我们将返回`waypoint3`，否则返回`waypoint0`。注意，如果我们传递此`null`方法，则将返回`waypoint0`（因此，它是我们的默认第一个waypoint）。
- en: 'The C# script class called `ArrowNPCMovement` has three variables: one is a
    reference to the destination GameObject named `targetGO`. The second is a reference
    to the `NavMeshAgent` component of the GameObject in which our instance of the
    class called `ArrowNPCMovement` is also a component. The third variable called
    `WaypointManager` is a reference to the sibling scripted component, an instance
    of our `WaypointManager` script class.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: C#脚本类`ArrowNPCMovement`有三个变量：一个是名为`targetGO`的指向目标GameObject的引用。第二个是`NavMeshAgent`组件的引用，该组件位于我们的`ArrowNPCMovement`类实例所在的GameObject中。第三个变量名为`WaypointManager`，是引用同级的脚本组件，即我们的`WaypointManager`脚本类的实例。
- en: When the scene starts, via the `Start()`method, the **NavMeshAgent** and `WaypointManager`
    sibling components are found, and the `HeadForDestination()`method is called.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景开始时，通过`Start()`方法，找到**NavMeshAgent**和`WaypointManager`同级组件，并调用`HeadForDestination()`方法。
- en: The `HeadForDestination()` method first sets the variable called `targetGO`
    to refer to the GameObject that is returned by a call to `NextWaypoint(…)` of
    the scripted component called `WaypointManager` (that is, `targetGO` is set to
    refer to either **Capsule-waypoint-0** or **Capsule-waypoint-3**). Next, it instructs
    the `NavMeshAgent` to make its destination the position of the `targetGO` GameObject.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadForDestination()`方法首先将变量`targetGO`设置为指向由名为`WaypointManager`的脚本组件调用的`NextWaypoint(…)`方法返回的GameObject（即`targetGO`设置为指向**Capsule-waypoint-0**或**Capsule-waypoint-3**）。接下来，它指示`NavMeshAgent`将其目的地设置为`targetGO`
    GameObject的位置。'
- en: Each frame method called `Update()` is called. A test is made to see if the
    distance from the NPC arrow object is close to the destination waypoint. If the
    distance is smaller than twice the *stopping distance*, set in our `NavMeshAgent`,
    then a call is made to `WaypointManager`.`NextWaypoint(…)` to update our target
    destination to be the next waypoint in the sequence.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧都会调用名为`Update()`的方法。进行一个测试，查看NPC箭头对象与目的地waypoint的距离是否接近。如果距离小于我们在`NavMeshAgent`中设置的**停止距离**的两倍，则调用`WaypointManager`.`NextWaypoint(…)`来更新我们的目标目的地为序列中的下一个waypoint。
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: More efficient to avoid using NavMeshes for waypoints
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更高效地避免使用NavMeshes作为waypoint
- en: NavMeshes are far superior to waypoints, since a location in a general area
    (not a specific point) can be used, and the path finding the algorithm will automatically
    find the shortest route. For a succinct recipe (such as the above), we can simplify
    the implementation of waypoints using NavMeshes for calculating movements for
    us. However, for optimized, real-world games the most common way to move from
    one waypoint to the next is via linear interpolation, or by implementing Craig
    Reynold's Seek algorithm (for details follow the link listed in the Conclusion
    section, at the end of this chapter).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: NavMeshes 比航点优越得多，因为可以使用一个大致区域的位置（而不是一个特定点），路径查找算法将自动找到最短路径。对于简短的菜谱（如上述），我们可以简化使用
    NavMeshes 计算移动的实现。然而，对于优化后的现实游戏，从一点移动到下一点的最常见方式是通过线性插值，或者通过实现 Craig Reynold 的
    Seek 算法（有关详细信息，请参阅结论部分列出的链接，在本章末尾）。
- en: Working with arrays of waypoints
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用航点数组进行工作
- en: Having a separate C# script class called `WaypointManager` to simply swap between
    **Capsule-waypoint-0** and **Capsule-waypoint-3** may have seemed to be a heavy
    duty and over-engineering task, but this was actually a very good move. An object
    of the script class called `WaypointManager` has the job of returning the *next*
    waypoint. It is now very straightforward to add a more sophisticated approach
    of having an array of waypoints, without us having to change any code in the script
    class called `ArrowNPCMovement`. We can choose a random waypoint to be the next
    destination (see the *Choosing destinations – find nearest (or a random) spawnpoint*
    recipe). Or, we can have an array of waypoints, and choose the next one in the
    sequence.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `WaypointManager` 的独立 C# 脚本类，用于简单地切换 **Capsule-waypoint-0** 和 **Capsule-waypoint-3**，这似乎是一个繁重且过度工程化的任务，但实际上这是一个非常好的举措。`WaypointManager`
    脚本类的一个对象负责返回 *下一个* 航点。现在，添加一个更复杂的具有航点数组的方法变得非常简单，而无需修改名为 `ArrowNPCMovement` 的脚本类中的任何代码。我们可以选择一个随机航点作为下一个目的地（参见
    *选择目的地 – 找到最近的（或随机的）出生点* 菜谱）。或者，我们可以有一个航点数组，并按顺序选择下一个。
- en: 'To improve our game to work with an array of waypoints in the sequence to be
    followed, we need to do the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的游戏，使其能够按照航点序列工作，我们需要做以下事情：
- en: Copy **Capsule-waypoint-0**, name the copy as **Capsule-waypoint-1**, and position
    this copy at (0, 0, 8).
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 **Capsule-waypoint-0**，将其命名为 **Capsule-waypoint-1**，并将此副本放置在 (0, 0, 8)。
- en: 'Make four more copies (named **Capsule-waypoint-1**, **2, 4**, **5**), and
    position them as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再复制四个（命名为 **Capsule-waypoint-1**、**2**、**4**、**5**），并按照以下方式定位：
- en: '**Capsule-waypoint-1**: Position = (-2, 0, 8)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Capsule-waypoint-1**: 位置 = (-2, 0, 8)'
- en: '**Capsule-waypoint-2**: Position = (8, 0, 8)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Capsule-waypoint-2**: 位置 = (8, 0, 8)'
- en: '**Capsule-waypoint-4**: Position = (-2, 0, -8)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Capsule-waypoint-4**: 位置 = (-2, 0, -8)'
- en: '**Capsule-waypoint-5**: Position = (-12, 0, -8)'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Capsule-waypoint-5**: 位置 = (-12, 0, -8)'
- en: 'Replace the C# script class called `WaypointManager` with the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换名为 `WaypointManager` 的 C# 脚本类：
- en: '[PRE20]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ensure that **Sphere-arrow** is selected. In the **Inspector** panel for the
    `WaypointManager` scripted component set the size of the `Waypoints` array to
    `6`. Now, drag in all the six capsule waypoint objects called as `Capsule-waypoint`-`0`/`1`/`2`/`3`/`4`/`5`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择 **Sphere-arrow**。在 `WaypointManager` 脚本组件的 **Inspector** 面板中设置 `Waypoints`
    数组的大小为 `6`。现在，拖入所有六个名为 `Capsule-waypoint-0`/`1`/`2`/`3`/`4`/`5` 的胶囊航点对象。
- en: Run the game. Now, the **Sphere-arrow** GameObject will first move towards the
    waypoint 0 (top left, and then follow the sequence around the terrain).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。现在，**Sphere-arrow** GameObject 将首先移动到航点 0（左上角），然后沿着地形周围的序列移动。
- en: Finally, you can make it look as if the Sphere is following a yellow brick road.
    Import the provided yellow brick texture, add this to your terrain, and paint
    the texture an oval-shaped path between the waypoints. You may also uncheck the
    Mesh Rendered component for each waypoint capsule, so that the user does not see
    any of the way points, but just the arrow object following the yellow brick path
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以让它看起来像球体正沿着一条黄色的砖路行走。导入提供的黄色砖纹理，将其添加到你的地形中，并在航点之间绘制一个椭圆形路径的纹理。你也可以取消选中每个航点胶囊的“网格渲染”组件，这样用户就看不到任何航点，只能看到跟随黄色砖路的箭头对象。
- en: In the `NextWaypoint(…)` method, first we check in case the array is empty,
    in which case an error is logged. Next, the array index for the current waypoint
    GameObject is found (if present in the array). Finally, the array index for the
    next waypoint is calculated using a modulus operator to support a cyclic sequence,
    returning to the beginning of the array after the last element has been visited.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NextWaypoint(…)`方法中，首先检查数组是否为空，如果是，则记录错误。接下来，找到当前waypoint GameObject的数组索引（如果存在于数组中）。最后，使用模运算符计算下一个waypoint的数组索引，以支持循环序列，在访问最后一个元素后返回数组的开头。
- en: Increased flexibility with a WayPoint class
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用WayPoint类提高灵活性
- en: Rather than forcing a GameObject to follow a single rigid sequence of locations,
    we can make things more flexible by defining a `WayPoint` class, whereby each
    waypoint GameObject has an array of possible destinations, and each of these has
    its own array and so on. In this way a **di-graph** (**directed graph**) can be
    implemented, of which a linear sequence is just one possible instance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是强制一个GameObject跟随一个单一的刚体序列位置，我们可以通过定义一个`WayPoint`类来使事情更加灵活，其中每个waypoint GameObject都有一个可能的终点数组，每个这样的终点都有一个自己的数组，以此类推。这样就可以实现一个**有向图**（**directed
    graph**），其中线性序列只是可能的一个实例。
- en: 'To improve our game to work with a di-graph of waypoints, do the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高我们的游戏以使用waypoint的有向图，请执行以下操作：
- en: Remove the scripted `WayPointManager` component from the **Sphere-arrow** GameObject.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Sphere-arrow** GameObject中移除脚本组件`WayPointManager`。
- en: 'Replace the C# script class called `ArrowNPCMovement` with the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换名为`ArrowNPCMovement`的C#脚本类：
- en: '[PRE21]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new C# script class called `WayPoint` with the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类名为`WayPoint`，代码如下：
- en: '[PRE22]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Select all the six GameObjects called **Capsule-waypoint -0**/**1**/**2**/**3**/**4**/**5,**
    and add to them a scripted instance of C# class called `WayPoint`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有六个名为**Capsule-waypoint -0**/**1**/**2**/**3**/**4**/**5**的GameObject，并添加一个名为`WayPoint`的C#类的脚本实例。
- en: Select the **Sphere-arrow** GameObject and add to it a scripted instance of
    C# class called `WayPoint`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Sphere-arrow** GameObject，并添加一个名为`WayPoint`的C#类的脚本实例。
- en: 'Ensure that the **Sphere-arrow** GameObject is selected: in the **Inspector**
    panel for the `ArrowNPCMovement` scripted component drag **Capsule-waypoint-0**
    into the **Waypoint** public variable slot.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已选择**Sphere-arrow** GameObject：在`ArrowNPCMovement`脚本组件的**Inspector**面板中，将**Capsule-waypoint-0**拖入**Waypoint**公共变量槽中。
- en: Now, we need to link **Capsule-waypoint-0** to **Capsule-waypoint-1**, **Capsule-waypoint-1**
    to **Capsule-waypoint -2**, and so on. Select **Capsule-waypoint-0**, set its
    `Waypoints` array size to `1`, and drag in **Capsule-waypoint-1**. Next, select
    **Capsule-waypoint-1**, set its **Waypoints** array size to 1, and drag in **Capsule-waypoint-2**.
    Do the following until you finally link **Capsule-waypoint-5** back to **Capsule-waypoint-0**.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将**Capsule-waypoint-0**链接到**Capsule-waypoint-1**，**Capsule-waypoint-1**链接到**Capsule-waypoint
    -2**，依此类推。选择**Capsule-waypoint-0**，将其`Waypoints`数组大小设置为`1`，并将**Capsule-waypoint-1**拖入。接下来，选择**Capsule-waypoint-1**，将其**Waypoints**数组大小设置为1，并将**Capsule-waypoint-2**拖入。重复此操作，直到最终将**Capsule-waypoint-5**链接回**Capsule-waypoint-0**。
- en: You now have a much more flexible game architecture, allowing GameObjects to
    randomly select one of several different paths at each waypoint reached. In this
    final recipe variation, we have implemented a waypoint sequence, since each waypoint
    has an array of just one linked waypoint. However, if you change the array size
    to 2 or more, you will then be creating a graph of linked waypoints, adding random
    variations in the sequence of waypoints that a computer controlled character follows
    for any given run of your game.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个更加灵活的游戏架构，允许GameObject在到达每个waypoint时随机选择几条不同的路径。在这个最终的食谱变体中，我们实现了一个waypoint序列，因为每个waypoint都有一个仅包含一个链接waypoint的数组。然而，如果你将数组大小更改为2或更多，那么你将创建一个链接waypoint的图，为计算机控制的字符在游戏运行中的任何给定运行添加随机变化。
- en: Controlling the object group movement through flocking
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过群聚控制对象组的移动
- en: 'A realistic, natural-looking, flocking behavior (for example birds or antelopes
    or bats) can be created through creating collections of objects with the following
    four simple rules:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建具有以下四个简单规则的对象集合，可以创建一个逼真、自然的外观群聚行为（例如鸟类、羚羊或蝙蝠）：
- en: '**Separation**: Avoiding getting too close to neighbors'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：避免与邻居过于接近'
- en: '**Avoid Obstacle**: Turning away from an obstacle immediately ahead'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避开障碍物**：立即转向避开前方障碍物'
- en: '**Alignment**: Moving in the general direction the flock is heading'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：向群移动的一般方向'
- en: '**Cohesion**: Moving towards the location in the middle of the flock'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚力**：向群中间的位置移动'
- en: 'Each member of the flock acts independently, but needs to know about the current
    heading and location of the members of its flock. This recipe shows you how to
    create a scene with two flocks of cubes: one flock of green cubes and, one flock
    of yellow cubes. To keep things simple, we''ll not worry about separation in our
    recipe.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 群中的每个成员都独立行动，但需要了解其群成员的当前航向和位置。此配方向您展示如何创建一个场景，其中包含两群立方体：一群绿色立方体和一群黄色立方体。为了简化，我们不会在配方中考虑分离。
- en: '![Controlling the object group movement through flocking](img/1362OT_08_15.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![通过群聚控制对象组移动](img/1362OT_08_15.jpg)'
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled cube Unity project that you created
    in the first recipe. So, make a copy of this project, open it, and then follow
    the steps for this recipe.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于你在第一个配方中创建的玩家控制立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行操作。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make a group of objects flock together, please follow these steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一组对象聚集在一起，请按照以下步骤操作：
- en: Create a Material in the **Project** panel, and name it as `m_green` with the
    Main Color tinted green.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中创建一个材质，并将其命名为`m_green`，主色调为绿色。
- en: Create a Material in the **Project** panel, and name it as `m_yellow` with Main
    Color tinted yellow.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中创建一个材质，并将其命名为`m_yellow`，主色调为黄色。
- en: Create a 3D Cube GameObject named `Cube-drone` at (0,0,0). Drag the `m_yellow`
    Material into this object.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(0,0,0)处创建一个名为`Cube-drone`的3D立方体游戏对象。将`m_yellow`材质拖动到这个对象中。
- en: Add a **Navigation** | **NavMeshAgent** component to `Cube-drone`. Set the **Stopping
    Distance** property of the **NavMeshAgent** component to `2`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Cube-drone`添加一个**导航** | **NavMeshAgent**组件。将**停止距离**属性设置为`2`。
- en: 'Add a **Physics RigidBody** component to `Cube-drone` with the following properties:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性的**物理刚体**组件添加到`Cube-drone`中：
- en: '**Mass** is `1`'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**为`1`'
- en: '**Drag** is `0`'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拖动**为`0`'
- en: '**Angular Drag** is `0.05`'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角动量阻力**为`0.05`'
- en: '**Use Gravity** and **Is Kinematic** are both unchecked'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用重力**和**是运动学**都未勾选'
- en: Under **Constrains Freeze Position** for the **Y**-axis is checked
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**约束冻结位置**的**Y**轴上勾选
- en: You will see the following Inspector values for your cube's rigid body component:![How
    to do it...](img/1362OT_08_16.jpg)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下检查器值用于你的立方体刚体组件：![如何操作...](img/1362OT_08_16.jpg)
- en: 'Create the following C# script class called `Drone`, and add an instance as
    a component to the `Cube-drone` GameObject:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下名为`Drone`的C#脚本类，并将其作为组件添加到`Cube-drone`游戏对象中：
- en: '[PRE23]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a new empty Prefab named `dronePrefabYellow`, and from the **Hierarchy**
    panel, drag your `Cube-boid` GameObject into this Prefab.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空Prefab，命名为`dronePrefabYellow`，然后从**层次**面板中，将你的`Cube-boid`游戏对象拖动到这个Prefab中。
- en: Now, drag the `m_green` Material into the `Cube-boid` GameObject.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`m_green`材质拖动到`Cube-boid`游戏对象中。
- en: Create a new empty Prefab named `dronePrefabGreen`, and from the **Hierarchy**
    panel, drag your `Cube-drone` GameObject into this Prefab.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空Prefab，命名为`dronePrefabGreen`，然后从**层次**面板中，将你的`Cube-drone`游戏对象拖动到这个Prefab中。
- en: Delete the `Cube-drone` GameObject from the **Scene** panel.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**场景**面板中删除`Cube-drone`游戏对象。
- en: 'Add the following C# script `Swarm` class to the **Main Camera**:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`Swarm`类添加到**主相机**：
- en: '[PRE24]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With **Main Camera** selected in the **Hierarchy** panel, drag `prefab_boid_yellow`,
    from the **Project** panel, over the public variable of **Drone** Prefab.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择**主相机**，从**项目**面板中，将`prefab_boid_yellow`拖动到**Drone**Prefab的公共变量上。
- en: With **Main Camera** selected in the **Hierarchy** panel, add a second instance
    of the script class called `Swarm` to this GameObject, and then drag `prefab_boid_green`,
    from the **Project** panel, over the public variable of **Drone** Prefab.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择**主相机**，向此游戏对象添加第二个名为`Swarm`的脚本类实例，然后从**项目**面板中，将`prefab_boid_green`拖动到**Drone**Prefab的公共变量上。
- en: 'Create a new Cube named `wall-left` with the following properties:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`wall-left`的新立方体，具有以下属性：
- en: Position = (-15, 0.5, 0)
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置 = (-15, 0.5, 0)
- en: Scale = (1, 1, 20)
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸 = (1, 1, 20)
- en: Duplicate the `wall-left` object by naming the new object as `wall-right`, and
    change the position of `wall-right` to (15, 0.5, 0).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将新对象命名为`wall-right`来复制`wall-left`对象，并将`wall-right`的位置更改为(15, 0.5, 0)。
- en: 'Create a new Cube named as `wall-top` with the following properties:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`wall-top`的新立方体，具有以下属性：
- en: Position = (0, 0.5, 10)
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Position = (0, 0.5, 10)
- en: Scale = (31, 1, 1)
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scale = (31, 1, 1)
- en: Duplicate the `wall-top` object by naming the new object as `wall-bottom`, and
    change the position of `wall-bottom` to (0, 0.5, -10).
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将新对象命名为`wall-bottom`来复制`wall-top`对象，并将`wall-bottom`的位置更改为（0，0.5，-10）。
- en: 'Create a new Sphere named as `Sphere-obstacle` with the following properties:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为`Sphere-obstacle`的球体，具有以下属性：
- en: Position = (5, 0, 3)
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Position = (5, 0, 3)
- en: Scale = (10, 3, 3)
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scale = (10, 3, 3)
- en: In the **Hierarchy** panel, select the `Sphere-obstacle` GameObject. Then in
    the **Navigation** panel, check the **Navigation Static** checkbox. Then, click
    on the **Bake** button at the bottom of the **Navigation** panel.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，选择`Sphere-obstacle`游戏对象。然后在**导航**面板中，勾选**导航静态**复选框。然后，点击**导航**面板底部的**烘焙**按钮。
- en: Finally, make the player's red cube larger by setting its scale to (3,3,3).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将玩家的红色立方体的比例设置为（3，3，3）来使其更大。
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Swarm` class contains three variables:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swarm`类包含三个变量：'
- en: '`droneCount`: It is an integer referencing the number of the `Swarm` class
    members created'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`droneCount`：它是一个整数，引用创建的`Swarm`类成员的数量'
- en: '`dronePrefab`: It references to the Prefab to be cloned to create swarm members'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dronePrefab`：它引用要克隆以创建蜂群成员的Prefab'
- en: '`Drone`: A list of objects that reference `drones`, a list of all the scripted
    `Drone` components inside all the `Swarm` objects that have been created'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drone`：一个对象列表，引用`drones`，它是一个列表，包含所有已创建的`Swarm`对象内部的所有脚本`Drone`组件'
- en: Upon creation, as the scene starts, the `Swarm` script class `Awake()` method
    loops to create `droneCount` swarm members by repeatedly calling the `AddDrone()`
    method. This method instantiates a new `GameObject` from the prefab, and then
    sets the `newDrone` variable to be a reference to the Drone-scripted object, inside
    the new `Swarm` class member. In each frame, the `FixedUpdate()` method loops
    through the list of `Drone` objects by calling their `SetTargetPosition(…)` method,
    and passing in the `Swarm` center location and the average of all the swarm member
    velocities.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，随着场景的开始，`Swarm`脚本类的`Awake()`方法循环创建`droneCount`个蜂群成员，通过重复调用`AddDrone()`方法。该方法从预制体实例化一个新的`GameObject`，然后将`newDrone`变量设置为对新的`Swarm`类成员中Drone脚本对象的引用。在每一帧中，`FixedUpdate()`方法通过调用它们的`SetTargetPosition(…)`方法遍历`Drone`对象列表，并传入蜂群中心位置和所有蜂群成员速度的平均值。
- en: 'The rest of this `Swarm` class is made up of two methods: one (`SwarmCenterAverage`)
    returns a Vector3 object, representing the average position of all the `Drone`
    objects, and the other (`SwarmMovementAverage`) returns a `Vector3` object, representing
    the average velocity (movement force) of all the `Drone` objects as described
    in the following list.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Swarm`类的其余部分由两个方法组成：一个（`SwarmCenterAverage`）返回一个表示所有`Drone`对象平均位置的Vector3对象，另一个（`SwarmMovementAverage`）返回一个表示所有`Drone`对象平均速度（运动力）的Vector3对象，如下列表所述。
- en: '`SwarmMovementAverage()`:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwarmMovementAverage()`：'
- en: What is the general direction that the swarm is moving in?
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂群移动的一般方向是什么？
- en: This is known as **alignment**—a swarm member attempting to move in the same
    direction as the swarm average
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这被称为**对齐**——一个蜂群成员试图移动到蜂群平均方向
- en: '`SwarmCenterAverage()`:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwarmCenterAverage()`：'
- en: What is the center position of the swarm?
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂群的中心位置是什么？
- en: This is known as **cohesion**—a swarm member attempting to move towards the
    center of the swarm
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这被称为**凝聚力**——一个蜂群成员试图移动到蜂群中心
- en: The core work is undertaken by the `Drone` class. Each drone's `Start(…)` method
    finds and caches a reference to its NavMeshAgent component.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 核心工作由`Drone`类承担。每个无人机的`Start(…)`方法找到并缓存其NavMeshAgent组件的引用。
- en: 'Each drone''s `UpdateVelocity(…)` method takes as input two Vector3 arguments:
    `swarmCenterAverage` and `swarmMovementAverage`. This method then calculates the
    desired new velocity for this Drone (by simply adding the two vectors), and then
    uses the result (a Vector3 location) to update the NavMeshAgent''s target location.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 每个无人机的`UpdateVelocity(…)`方法接受两个Vector3参数：`swarmCenterAverage`和`swarmMovementAverage`。然后该方法计算这个无人机期望的新速度（通过简单地添加两个向量），然后使用结果（一个Vector3位置）来更新NavMeshAgent的目标位置。
- en: There's more...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Learn more about flocking Artificial Intelligence
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解更多关于集群人工智能的信息
- en: Most of the flocking models in modern computing owe much to the work of Craig
    Reynolds in the 1980s. Learn more about Craig and his boids program at [http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算中的大多数群集模型都归功于克雷格·雷诺兹在20世纪80年代的工作。在[http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics))了解更多关于克雷格和他的boids程序的信息
- en: Conclusion
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter, we have introduced recipes demonstrating a range of player
    and computer controlled characters, vehicles, and objects. Player character controllers
    are fundamental to the usability experience of every game, while the NPC objects
    and characters add rich interactions to many games:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种玩家和计算机控制的角色、车辆和对象的配方。玩家角色控制器是每个游戏可用体验的基础，而NPC对象和角色则为许多游戏增添了丰富的交互：
- en: Learn more about Unity NavMeshes from this Unity tutorial, which is available
    at [http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这个Unity教程中了解更多关于Unity NavMeshes的信息，该教程可在[http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)找到
- en: Learn more about the Unity 2D character controllers at [http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers)了解更多关于Unity
    2D角色控制器的信息
- en: Learn lots about the computer-controlled moving GameObjects from the classic
    paper entitled *Steering Behaviors For Autonomous Characters* by Craig W. Reynolds,
    presented at the GDC-99 (Game Developer's Conference) at [http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从克雷格·雷诺兹的经典论文《Steering Behaviors For Autonomous Characters》中学习大量关于计算机控制移动GameObject的知识，这篇论文在1999年GDC-99（游戏开发者大会）上展出，可在[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)找到
- en: 'Learn about the Unity 3D character component and control at:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下链接了解Unity 3D角色组件和控制：
- en: '[http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)'
- en: '[http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character)'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character)'
- en: 'Every game needs textures—here are some of the sources of free textures suitable
    for many games:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都需要纹理——以下是一些适合许多游戏的免费纹理来源：
- en: CG Textures are available at [http://www.cgtextures.com/](http://www.cgtextures.com/)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CG Textures可在[http://www.cgtextures.com/](http://www.cgtextures.com/)找到
- en: Naldz Graphics blog are available at [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Naldz Graphics博客可在[http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)找到
