<html><head></head><body>
<div><h1 class="chapterNumber">1</h1>
<h1 class="chapterTitle" id="_idParaDest-16">Hello Blazor</h1>
<p class="normal">Thank you for picking up your copy of <em class="italic">Web Development with Blazor</em>. This book intends to get you started as quickly and smoothly as possible, chapter by chapter, without you having to read this book from cover to cover before getting your Blazor on.</p>
<p class="normal">This book will start by guiding you through the most common scenarios you’ll come across when you begin your journey with Blazor and will also dive into a few more advanced scenarios later on. This book aims to show you what Blazor is – Blazor Server, Blazor WebAssembly, Blazor Hybrid, and on top of that, the new <strong class="keyWord">Server-Side Rendering</strong> (<strong class="keyWord">SSR</strong>) – and how it <a id="_idIndexMarker000"/>all works practically to help you avoid traps.</p>
<p class="normal">This is the book’s third edition; much has happened since the first edition. .NET 6 and .NET 7 were released, and for the second edition, I updated the content to reflect the changes and the new functionality we got. </p>
<p class="normal">This edition has been updated to include all the new things in .NET 8, and let me tell you, that is a lot.</p>
<p class="normal">I do Blazor presentations all over the world, and there are common questions that I get asked a lot. Without going into too much detail, they are often related to download size or time when it comes to Blazor WebAssembly and continuous connection to Blazor Server. In .NET 8, we can leverage a new mode, SSR, that solves all of these problems in one swift blow. Okay, maybe not all problems, but we are well on our way to solving them. A common belief is that Blazor is WebAssembly, but WebAssembly is just one way of running Blazor. Many books, workshops, and blog posts on Blazor focus heavily on WebAssembly. </p>
<p class="normal">This book will cover Blazor WebAssembly, Blazor Server, Blazor Hybrid, and SSR. There are a few differences between the different ways of running Blazor; I will point them out as we go along.</p>
<p class="normal">This first chapter will explore where Blazor came from, what technologies made Blazor possible, and the different ways of running Blazor. We will also touch on which type (Blazor WebAssembly, Blazor Server, or Blazor Hybrid) is best for you.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Why Blazor?</li>
<li class="bulletList">Preceding Blazor</li>
<li class="bulletList">Introducing WebAssembly</li>
<li class="bulletList">Introducing .NET 8</li>
<li class="bulletList">Introducing Blazor</li>
</ul>
<h1 class="heading-1" id="_idParaDest-17">Technical requirements</h1>
<p class="normal">It is recommended that you have some knowledge of .NET before you start, as this book is aimed at .NET developers who want to utilize their skills to make interactive web applications. However, it’s more than possible that you will pick up a few .NET tricks if you are new to the world of .NET.</p>
<h1 class="heading-1" id="_idParaDest-18">Why Blazor?</h1>
<p class="normal">Not that long ago, I got asked by a random person on Facebook if I work with Blazor.</p>
<p class="normal">I said, “Yes, yes I do”.</p>
<p class="normal">He then continued <a id="_idIndexMarker001"/>with a long remark telling me Blazor would never beat Angular, React, or Vue.</p>
<p class="normal">I see these kinds of remarks quite often, and it’s essential to understand that beating other <strong class="keyWord">Single-Page Application</strong> (<strong class="keyWord">SPA</strong>) frameworks has never been the goal. This is not <em class="italic">Highlander</em>, and there can be more than one.</p>
<p class="normal">Learning web development has previously been pretty tough. Not only do we need to know ASP.NET for the server but we also need to learn an SPA framework like React, Angular, or Vue.</p>
<p class="normal">But it doesn’t end there. We also need to learn npm, Bower, and Parcel, as well as JavaScript or TypeScript.</p>
<p class="normal">We need to understand transpiling and build that into our development pipeline. This is, of course, just the tip of the iceberg; depending on the technology, we need to explore other rabbit holes.</p>
<p class="normal">Blazor is an excellent choice for .NET developers to write interactive web applications without needing to learn (or keep up with) everything we just mentioned. We can leverage our existing C# knowledge and the packages we use and share code between the server and client.</p>
<p class="normal">I usually say, “Blazor removes <a id="_idIndexMarker002"/>all the things I hate about web development.” I guess the saying should be, “Blazor <em class="italic">can</em> remove all the things I hate about web development.” With Blazor, it is still possible to do JavaScript interop and use JavaScript frameworks or other SPA frameworks from within Blazor, but we don’t have to.</p>
<p class="normal">Blazor has opened a door where I can feel productive and confident I am creating a great user experience for my users, with my existing C# knowledge. </p>
<h1 class="heading-1" id="_idParaDest-19">Preceding Blazor</h1>
<p class="normal">You probably didn’t get this <a id="_idIndexMarker003"/>book to read about <strong class="keyWord">JavaScript</strong>, but it helps to remember that we came from a pre-Blazor time. I recall that time – the dark times. Many of the concepts used in Blazor are not that far from those used in many JavaScript frameworks, so I will start with a brief overview of where we came from. </p>
<p class="normal">As developers, we have <a id="_idIndexMarker004"/>many different platforms we can develop for, including desktop, mobile, games, the cloud (or server side), AI, and even IoT. All these platforms have a lot of different languages to choose from, but there is, of course, one more platform: the apps that run inside the browser.</p>
<p class="normal">I have been a web developer for a long time, and I’ve seen code move from the server to run within the browser. It has changed the way we develop our apps. Frameworks such as Angular, React, Aurelia, and Vue have changed the web from reloading the whole page to updating small parts on the fly. This <em class="italic">new</em> on-the-fly update method has enabled pages to load quicker, as the perceived load time has been lowered (not necessarily the whole page load).</p>
<p class="normal">But for many developers, this is an entirely new skill set – that is, switching between a server (most likely C#, if you are reading this book) to a frontend developed in JavaScript. Data objects are written in C# in the backend and then serialized into JSON, sent via an API, and then deserialized into another object written in JavaScript in the frontend.</p>
<p class="normal">JavaScript used to work differently in different browsers, which jQuery tried to solve by having a common API that was translated into something the web browser could understand. Now, the differences between different web browsers are much more minor, which has rendered jQuery obsolete in many cases.</p>
<p class="normal">JavaScript differs slightly <a id="_idIndexMarker005"/>from other languages since it is not object-oriented or typed, for example. In 2010, Anders Hejlsberg (known for being C#, Delphi, and Turbo Pascal’s <a id="_idIndexMarker006"/>original language designer) started working on <strong class="keyWord">TypeScript</strong>. This object-oriented language can be compiled/transpiled into JavaScript.</p>
<p class="normal">You can use Typescript with Angular, React, Aurelia, and Vue, but in the end, it is JavaScript that will run the actual code. Simply put, to create interactive web applications today using JavaScript/TypeScript, you need to switch between languages and choose and keep up with different frameworks.</p>
<p class="normal">In this book, we will look at this in another way. Even though we will talk about JavaScript, our primary focus will be on developing interactive web applications mainly using C#.</p>
<p class="normal">Now, we know a bit about the history of JavaScript. JavaScript is no longer the only language that can run within a browser, thanks to WebAssembly, which we will cover in the next section.</p>
<h1 class="heading-1" id="_idParaDest-20">Introducing WebAssembly</h1>
<p class="normal">In this section, we will look at how <strong class="keyWord">WebAssembly</strong> works. One way of running Blazor is by using WebAssembly, but for now, let’s focus on what WebAssembly is.</p>
<p class="normal">WebAssembly is a binary <a id="_idIndexMarker007"/>instruction format that is compiled and, therefore, smaller. It is designed for native speeds, which means that when it comes to speed, it is closer to C++ than it is to JavaScript. When loading JavaScript, the JavaScript files (or inline JavaScript) are downloaded, parsed, optimized, and JIT-compiled; most of those steps are not needed for WebAssembly.</p>
<p class="normal">WebAssembly has a very strict security model that protects users from buggy or malicious code. It runs within a sandbox and cannot escape that sandbox without going through the <a id="_idIndexMarker008"/>appropriate APIs. Suppose you want to communicate outside WebAssembly, for example, by changing the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>) or downloading a file from the web. In that case, you will need to do that with JavaScript interop (more on that later; don’t worry – Blazor will solve this for us).</p>
<p class="normal">Let’s look at some code to get a bit more familiar with WebAssembly.</p>
<p class="normal">In this section, we will create an app that sums two numbers and returns the result, written in C (to be honest, this is about the level of C I’m comfortable with).</p>
<p class="normal">We can compile C into WebAssembly but it requires the installation of some tooling so we will not do <a id="_idIndexMarker009"/>this all the way. The point here is just to give us a feeling of how WebAssembly works under the hood. Consider this code:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
  return 1+2;
}
</code></pre>
<p class="normal">The result of this will be the number <code class="inlineCode">3</code>.</p>
<p class="normal">WebAssembly is a stack machine language, which means that it uses a stack to perform its operations.</p>
<p class="normal">Consider this code:</p>
<pre class="programlisting code"><code class="hljs-code">1+2
</code></pre>
<p class="normal">Most compilers will optimize the code and return <code class="inlineCode">3</code>.</p>
<p class="normal">But let’s assume that all the instructions should be executed. This is the way WebAssembly would do things:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">It will start by pushing <code class="inlineCode">1</code> onto the stack (<code class="inlineCode">instruction: i32.const 1</code>), followed by pushing <code class="inlineCode">2</code> onto the stack (<code class="inlineCode">instruction: i32.const 2</code>). At this point, the stack contains <code class="inlineCode">1</code> and <code class="inlineCode">2</code>.</li>
<li class="numberedList">Then, we must execute the add instruction (<code class="inlineCode">i32.add</code>), which will pop (<code class="inlineCode">get</code>) the two top values (<code class="inlineCode">1</code> and <code class="inlineCode">2</code>) from the stack, add them up, and push the new value onto the stack (<code class="inlineCode">3</code>).</li>
</ol>
<p class="normal">This demo shows that we can build WebAssembly from C code. Even though we never need to go to this level to understand WebAssembly (Blazor handles all of that for us), we will use C code and other libraries compiled into WebAssembly later in the book (<em class="chapterRef">Chapter 16</em>, <em class="italic">Going Deeper into WebAssembly</em>).</p>
<div><p class="normal">OTHER LANGUAGES</p>
<p class="normal">Generally, it is only low-level languages that can be compiled into WebAssembly (such as C or Rust). However, there are a plethora of languages that can run on top of WebAssembly. Here is a great collection of some of these languages: <a href="https://github.com/appcypher/awesome-wasm-langs">https://github.com/appcypher/awesome-wasm-langs</a>.</p>
<p class="normal">WebAssembly is super performant (near-native speeds) – so performant that game engines have already adopted this technology for that very reason. Unity, as well as Unreal Engine, can be compiled into WebAssembly.</p>
<p class="normal">Here are a <a id="_idIndexMarker010"/>couple of examples of games running on top of WebAssembly:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Angry Bots (Unity)</strong>: <a href="https://beta.unity3d.com/jonas/AngryBots/">https://beta.unity3d.com/jonas/AngryBots/</a></li>
<li class="bulletList"><strong class="keyWord">Doom</strong>: <a href="https://wasm.continuation-labs.com/d3demo/">https://wasm.continuation-labs.com/d3demo/</a></li>
</ul>
<p class="normal">This is a great list of different WebAssembly projects: <a href="https://github.com/mbasso/awesome-wasm">https://github.com/mbasso/awesome-wasm</a>.</p>
</div>
<p class="normal">This section touched the surface of how WebAssembly works; in most cases, you won’t need to know much more. We will dive into how Blazor uses this technology later in this chapter.</p>
<p class="normal">To write Blazor apps, we can leverage the power of .NET 8, which we’ll look at next.</p>
<h1 class="heading-1" id="_idParaDest-21">Introducing .NET 8</h1>
<p class="normal">.NET is a platform developed by Microsoft for building different types of applications, including web, mobile, and desktop applications. The .NET team has been working hard on tightening <a id="_idIndexMarker011"/>everything up for us developers for years. They have been making everything simpler, smaller, cross-platform, and open source – not to mention easier to utilize your existing knowledge of .NET development.</p>
<p class="normal">.NET Core<a id="_idIndexMarker012"/> was a step toward a more unified .NET. It allowed Microsoft to re-envision the whole .NET platform, build it in a completely new way, and make it run on even more platforms.</p>
<p class="normal">There were three <a id="_idIndexMarker013"/>different types of .NET runtimes:</p>
<ul>
<li class="bulletList">.NET Framework (full .NET)</li>
<li class="bulletList">.NET Core</li>
<li class="bulletList">Mono/Xamarin</li>
</ul>
<p class="normal">Different runtimes had different capabilities and performances. This also meant that creating a .NET Core app (for example) had different tooling and frameworks that needed to be installed.</p>
<p class="normal">.NET 5 was the <a id="_idIndexMarker014"/>start of our journey toward one single .NET. With this unified toolchain, the experience of creating, running, and so on became the same across all the different project types. “Framework” and “Core” were dropped from the name. .NET 5 is still modular in a similar way to what we are used to, so we do not have to worry that merging all the different .NET versions is going to result in a bloated .NET.</p>
<p class="normal">Thanks to the .NET platform, you will be able to reach all the platforms we talked about at the beginning of this chapter (web, desktop, mobile, games, the cloud (or server side), AI, and even IoT) using only C# and with the same tooling.</p>
<p class="normal">Blazor has been around for a while now. In .NET Core 3, the first version of Blazor Server was released, and at Microsoft Build in 2020, Microsoft released Blazor WebAssembly.</p>
<p class="normal">In .NET 5, we got a lot of new components for Blazor – pre-rendering and CSS isolation to name a couple of things. Don’t worry; we will go through all these things throughout the book.</p>
<p class="normal">In .NET 6, we got even <a id="_idIndexMarker015"/>more functionality, like Hot Reload, co-located JavaScript, new components, and much more, all of which we will explore throughout the book.</p>
<p class="normal">In .NET 7, we got even <a id="_idIndexMarker016"/>more enhancements for Blazor developers. We got performance improvements and get/set/after modifiers, among other things.</p>
<p class="normal">In November 2023, Microsoft released .NET 8, and with that, everything changed. During development, this new way of developing Blazor apps was called “Blazor United,” which is a name they now have updated to simply Blazor. This is the new way of creating Blazor applications and it is an awesome way. But let’s save something for later chapters as well.</p>
<p class="normal">.NET 8 brought us <a id="_idIndexMarker017"/>performance improvements, native Define, better source generators, and so much more. It is also an LTS (Long-Term Support) version.</p>
<p class="normal">Looking at the enhancements and number of features, I can only conclude that Microsoft believes in Blazor, and so do I.</p>
<p class="normal">Now that you know about some of the surrounding technologies, in the next section, it’s time to introduce the main character of this book: Blazor.</p>
<h1 class="heading-1" id="_idParaDest-22">Introducing Blazor</h1>
<p class="normal"><strong class="keyWord">Blazor</strong> is an open-source web UI framework. That’s a lot of buzzwords in the same sentence, but simply put, it means that you can create interactive web applications using HTML, CSS, and C# with <a id="_idIndexMarker018"/>full support for bindings, events, forms and validation, dependency injection, debugging, and much more, with Blazor. We will take a look at these in this book.</p>
<p class="normal">In 2017, Steve Sanderson (well-known for creating the Knockout JavaScript framework and who works for the ASP.NET team at Microsoft) was about to do a session called <em class="italic">Web Apps can’t really do *that*, can they?</em> at the developer conference NDC Oslo.</p>
<p class="normal">But Steve wanted to show a cool demo, so he thought, <em class="italic">Would it be possible to run C# in WebAssembly?</em> He found an old inactive project on GitHub called <em class="italic">Dot Net Anywhere</em>, which was written in C and used tools (similar to what we just did) to compile the C code into WebAssembly.</p>
<p class="normal">He got a simple console app running in the browser. This would have been a fantastic demo for most people, but Steve wanted to take it further. He thought, <em class="italic">Is it possible to create a simple web framework on top of this?</em>, and went on to see if he could also get the tooling working.</p>
<p class="normal">When it was time for his session, he had a working sample to create a new project, create a to-do list with great tooling support, and run the project in the browser.</p>
<p class="normal">Damian Edwards (the .NET team) and David Fowler (the .NET team) were also at the NDC conference. Steve showed them what he was about to demo, and they described the event as their heads exploded and their jaws dropped.</p>
<p class="normal">And that’s how the prototype of Blazor came into existence.</p>
<p class="normal">The name Blazor comes from a combination of <strong class="keyWord">Browser</strong> and <strong class="keyWord">Razor</strong> (which is the technology used to combine code and HTML). Adding an <em class="italic">L</em> made the name sound better, but other than that, it has no real meaning or acronym.</p>
<p class="normal">There are a few different flavors of Blazor, including Blazor Server, Blazor WebAssembly, Blazor Hybrid (using .NET MAUI), and Server-Side Rendering.</p>
<p class="normal">The different versions have some pros and cons, all of which I will cover in the upcoming sections and chapters.</p>
<h2 class="heading-2" id="_idParaDest-23">Blazor Server</h2>
<p class="normal">Blazor Server <a id="_idIndexMarker019"/>uses SignalR to communicate between the client and the server, as shown in the following diagram:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21849_01_01.png"/></figure>
<p class="packt_figref">Figure 1.1: Overview of Blazor Server</p>
<p class="normal"><strong class="keyWord">SignalR</strong> is an <a id="_idIndexMarker020"/>open-source, real-time communication library that will create a connection between the client and the server. SignalR can use many different means of transporting data and automatically selects the best transport protocol based on your server and client capabilities. SignalR will always try to use WebSockets, which is a transport protocol built into HTML5. If WebSockets is not enabled, it will gracefully fall back to another protocol.</p>
<p class="normal">Blazor is built <a id="_idIndexMarker021"/>with reusable UI elements called <strong class="keyWord">components</strong> (more on components in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>). Each component contains C# code and markup. A component can include other components. You can use Razor syntax to mix markup and C# code or do everything in C# if you wish. The components can be updated by user interaction (pressing a button) or triggers (such as a timer).</p>
<p class="normal">The components are rendered into a render tree, a binary representation of the DOM containing object states and any properties or values. The render tree will keep track of any changes compared to the previous render tree, and then send only the things that changed over SignalR using a binary format to update the DOM.</p>
<p class="normal">JavaScript will receive the changes on the client side and update the page accordingly. If we compare this <a id="_idIndexMarker022"/>to traditional ASP.NET, we only render the component itself, not the entire page, and we only send over the actual changes to the DOM, not the whole page.</p>
<p class="normal">There are <a id="_idIndexMarker023"/>advantages to Blazor Server:</p>
<ul>
<li class="bulletList">It contains just enough code to establish that the connection is downloaded to the client, so the site has a small footprint, which makes the site startup really fast.</li>
<li class="bulletList">Since everything is rendered on the server, Blazor Server is more SEO-friendly.</li>
<li class="bulletList">Since we are running on the server, the app can fully utilize the server’s capabilities.</li>
<li class="bulletList">The site will work on older web browsers that don’t support WebAssembly.</li>
<li class="bulletList">The code runs on the server and stays on the server; there is no way to decompile the code.</li>
<li class="bulletList">Since the code is executed on your server (or in the cloud), you can make direct calls to services and databases within your organization.</li>
</ul>
<p class="normal">There are, of <a id="_idIndexMarker024"/>course, some disadvantages to Blazor Server as well:</p>
<ul>
<li class="bulletList">You need to always be connected to the server since the rendering is done on the server. If you have a bad internet connection, the site might not work. The big difference compared to a non-Blazor Server site is that a non-Blazor Server site can deliver a page and then disconnect until it requests another page. With Blazor, that connection (SignalR) must always be connected (minor disconnections are okay).</li>
<li class="bulletList">There is <a id="_idIndexMarker025"/>no offline/<strong class="keyWord">PWA</strong> (<strong class="keyWord">Progressive Web App</strong>) mode since it needs to be connected.</li>
<li class="bulletList">Every click or page update must do a round trip to the server, which might result in higher latency. It is important to remember that Blazor Server will only send the changed data. I have not experienced any slow response times personally.</li>
<li class="bulletList">Since we have to have a connection to the server, the load on that server increases and makes scaling difficult. To solve this problem, you can use the Azure SignalR hub to handle the constant connections and let your server concentrate on delivering content.</li>
<li class="bulletList">Each connection <a id="_idIndexMarker026"/>stores the information in the server’s memory, increasing memory use and making load balancing more difficult.</li>
<li class="bulletList">To be able to run Blazor Server, you have to host it on an ASP.NET Core-enabled server.</li>
</ul>
<p class="normal">At my workplace, we already had a large site, so we decided to use Blazor Server for our projects. We had a customer portal and an internal CRM tool, and our approach was to take one component at a time and convert it into a Blazor component.</p>
<p class="normal">We quickly <a id="_idIndexMarker027"/>realized that, in most cases, it was faster to remake the component in Blazor rather than continue to use ASP.NET MVC and add functionality. The <strong class="keyWord">User Experience</strong> (<strong class="keyWord">UX</strong>) for the <a id="_idIndexMarker028"/>end-user became even better as we converted.</p>
<p class="normal">The pages loaded faster. We could reload parts of the page as we needed instead of the whole page, and so on.</p>
<p class="normal">We found that Blazor introduced a new problem: the pages became <em class="italic">too</em> fast. Our users didn’t understand whether data had been saved because <em class="italic">nothing happened</em>; things <em class="italic">did</em> happen, but too fast for the users to notice. Suddenly, we had to think more about UX and how to inform the user that something had changed. This is, of course, a very positive side effect of Blazor.</p>
<p class="normal">Blazor Server is not the only way to run Blazor – you can also run it on the client (in the web browser) using WebAssembly.</p>
<h2 class="heading-2" id="_idParaDest-24">Blazor WebAssembly</h2>
<p class="normal">There is <a id="_idIndexMarker029"/>another option: instead of running Blazor on a server, you can run it inside your web browser using WebAssembly.</p>
<p class="normal">The Mono runtime is a tool that lets you run programs made with C# and other .NET languages on various operating systems, not just Windows.</p>
<p class="normal">Microsoft has taken the Mono runtime (which is written in C) and compiled that into WebAssembly.</p>
<p class="normal">The WebAssembly version of Blazor works very similarly to the server version, as shown in the following diagram. We have moved everything off the server, and it is now running within our web browser:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21849_01_02.png"/></figure>
<p class="packt_figref">Figure 1.2: Overview of Blazor WebAssembly</p>
<p class="normal">A render tree is still created, and instead of running the Razor pages on the server, they are now running <a id="_idIndexMarker030"/>inside our web browser. Instead of SignalR, since WebAssembly doesn’t have direct DOM access, Blazor updates the DOM with direct JavaScript interop.</p>
<p class="normal">The Mono runtime that’s <a id="_idIndexMarker031"/>compiled into WebAssembly is called <strong class="keyWord">dotnet.wasm</strong>. The page contains a small piece of JavaScript that will make sure to load <code class="inlineCode">dotnet.wasm</code>. Then, it will download <code class="inlineCode">blazor.boot.json</code>, a JSON file containing all the files the application needs to run, as well as the application’s entry point.</p>
<p class="normal">If we look at the default sample site that is created when we start a new Blazor project in Visual Studio, the <code class="inlineCode">Blazor.boot.json</code> file contains 63 dependencies that need to be downloaded. All the dependencies get downloaded and the app boots up.</p>
<p class="normal">As we mentioned previously, <code class="inlineCode">dotnet.wasm</code> is the mono runtime that’s compiled into WebAssembly. It runs .NET DLLs – the ones you have written and the ones from .NET Framework (which is needed to run your app) – in your browser.</p>
<p class="normal">When I first heard of this, I got a bit of a bad taste. It’s running the whole .NET runtime in my browser?! But then, after a while, I realized how amazing that is. You can run any .NET Standard DLLs in your web browser.</p>
<p class="normal">In the next <a id="_idIndexMarker032"/>chapter, we will look at exactly what happens and in what order code gets executed when a WebAssembly app boots up.</p>
<p class="normal">There are, of <a id="_idIndexMarker033"/>course, some advantages of Blazor WebAssembly:</p>
<ul>
<li class="bulletList">Since the code <a id="_idIndexMarker034"/>runs in the browser, creating a <strong class="keyWord">PWA</strong> is easy.</li>
<li class="bulletList">It does not require a connection to the server. Blazor WebAssembly will work offline.</li>
<li class="bulletList">Since we’re not running anything on the server, we can use any backend server or file share (no need for a .NET-compatible server in the backend).</li>
<li class="bulletList">No round trips mean that you can update the screen faster (that is why there are game engines that use WebAssembly).</li>
</ul>
<p class="normal">There are <a id="_idIndexMarker035"/>some disadvantages to Blazor WebAssembly as well:</p>
<ul>
<li class="bulletList">Even if we compare it to other large sites, the footprint of Blazor WebAssembly is large and there are a large number of files to download.</li>
<li class="bulletList">To access any on-site resources, you will need to create a Web API to access them. You cannot access the database directly.</li>
<li class="bulletList">The code runs in the browser, meaning it can be decompiled. All app developers are used to this, but it is perhaps not as common for web developers.</li>
</ul>
<p class="normal">I wanted to put WebAssembly to the test! When I was seven years old, I got my first computer, a Sinclair ZX Spectrum. I remember that I sat down and wrote the following:</p>
<pre class="programlisting code"><code class="hljs-code">10 PRINT "Jimmy"
20 GOTO 10
</code></pre>
<p class="normal">That was <em class="italic">my</em> code; I made the computer write my name on the screen over and over!</p>
<p class="normal">That was when I decided that I wanted to become a developer to make computers do stuff.</p>
<p class="normal">After becoming a developer, I wanted to revisit my childhood and decided I wanted to build a ZX Spectrum emulator. In many ways, the emulator has become my test project instead of a simple <em class="italic">Hello World</em> when I encounter new technology. I’ve had it running on a Gadgeteer, Xbox One, and even a HoloLens (to name a few platforms/devices).</p>
<p class="normal">But is it possible to run my emulator in Blazor?</p>
<p class="normal">It took me only <a id="_idIndexMarker036"/>a couple of hours to get the emulator working with Blazor WebAssembly by leveraging my already built .NET Standard DLL; I only had to write the code specific to this implementation, such as the keyboard and graphics. This is one of the reasons Blazor (both Server and WebAssembly) is so powerful: it can run libraries that have already been made. Not only can you leverage your knowledge of C# but you can also take advantage of the large ecosystem and .NET community.</p>
<div><p class="normal">You can find the emulator here: <a href="http://zxbox.com">http://zxbox.com</a>. This is one of my favorite projects to work on, as I keep finding ways to optimize and improve the emulator.</p>
</div>
<p class="normal">Building interactive web applications used to only be possible with JavaScript. Now, we know we can use Blazor WebAssembly and Blazor Server, but which one of these new options is the best?</p>
<h2 class="heading-2" id="_idParaDest-25">Blazor WebAssembly versus Blazor Server</h2>
<p class="normal">Which one should we choose? The answer is, as always, it depends. You have seen the advantages <a id="_idIndexMarker037"/>and disadvantages of both.</p>
<p class="normal">If you have a current site that you want to port over to Blazor, I recommend going for the server side; once you have ported it, you can make a new decision as to whether you want to go for WebAssembly as well. This way, it is easy to port parts of the site, and the debugging experience is better with Blazor Server.</p>
<p class="normal">Suppose your site runs on a mobile browser or another unreliable internet connection. In that case, you might consider going for an offline-capable (PWA) scenario with Blazor WebAssembly since Blazor Server needs a constant connection.</p>
<p class="normal">The startup time for WebAssembly is a bit slow, but there are ways to combine the two hosting models to have the best of both worlds. We will cover this in <em class="chapterRef">Chapter 16</em>, <em class="italic">Going Deeper into WebAssembly</em>.</p>
<p class="normal">There is no silver bullet when it comes to this question, but read up on the advantages and disadvantages and see how they affect your project and use cases.</p>
<p class="normal">With .NET 8, we have more opportunities to mix and match the different technologies, so the question <a id="_idIndexMarker038"/>becomes less relevant since we can choose to have one specific component running Blazor Server and another running Blazor WebAssembly (more on that later in this chapter).</p>
<p class="normal">We can run Blazor server-side and on the client, but what about desktop and mobile apps?</p>
<h2 class="heading-2" id="_idParaDest-26">Blazor Hybrid/.NET MAUI</h2>
<p class="normal">.NET MAUI is a cross-platform application framework. The name comes from <strong class="keyWord">.NET Multi-platform App UI</strong> and is the next version of Xamarin. We can use traditional XAML code to create our <a id="_idIndexMarker039"/>cross-platform application just as with Xamarin. However, .NET MAUI also targets desktop operating systems that will enable running our Blazor app on Windows and even macOS.</p>
<p class="normal">.NET MAUI has <a id="_idIndexMarker040"/>its own template that enables us to run Blazor inside of a .NET MAUI application using a Blazor WebView. This is called Blazor Hybrid. Blazor Hybrid works in a similar way to the other hosting models (Blazor Server and Blazor WebAssembly). It has a render tree and updates the Blazor WebView, which is a browser component in .NET MAUI. This is a bit oversimplified perhaps but we have a whole chapter on Blazor Hybrid (<em class="chapterRef">Chapter 18</em>, <em class="italic">Visiting .NET MAUI</em>). Using Blazor Hybrid, we also get access to native APIs (not only Web APIs), making it possible to take our application to another level.</p>
<p class="normal">We will take a look at .NET MAUI in <em class="chapterRef">Chapter 18</em>, <em class="italic">Visiting .NET MAUI</em>.</p>
<p class="normal">Sometimes we don’t need interactive components, we just need to render some content and be done. In .NET 8, we have a new way of doing that.</p>
<h2 class="heading-2" id="_idParaDest-27">Server-Side Rendering (SSR)</h2>
<p class="normal">Server-side rendering is the new kid on the Blazor block. It makes it possible to use the Razor syntax <a id="_idIndexMarker041"/>to build web pages that are rendered server-side just like MVC or Razor Pages. This is called Static Server-side Rendering. It has some additional features that will keep scrolling in the previous position even though the whole page is reloaded, which is called enhanced form navigation. This will only render static pages, with no interactivity (with a few exceptions). There is also something called streaming rendering that will load the page even faster. This mode is called streaming server-side rendering. During long-running tasks, streaming rendering will first send the HTML it has and then update the DOM once the long-running task is complete, giving it a more interactive feeling. </p>
<p class="normal">But sometimes we want interactivity, and choosing between Blazor Server or Blazor WebAssembly can be a bit hard. But what if I told you we don’t have to choose anymore? We can mix it up.</p>
<h2 class="heading-2" id="_idParaDest-28">The feature formerly known as Blazor United</h2>
<p class="normal">This next feature was called “Blazor United” when Microsoft first spoke of it but is now simply part of Blazor, not an <a id="_idIndexMarker042"/>extra feature. I still want to mention the name because the community still uses it, and chances are you might have heard it and are wondering why I am not mentioning it.</p>
<p class="normal">It is a really cool feature: we can pick and choose what components will run using SSR and what components will use Blazor Server, Blazor WebAssembly, or (hope you are sitting down for this) a mix of the two. Previously, we had to choose one of the two (Blazor Server or Blazor WebAssembly), but now we can combine the technologies to get the best of both worlds. We can now tell each component how we want it to render and we can mix and match throughout the site. The new “auto” feature means the first time our users visit the site, they will run Blazor Server. This is to get a quick connection and get data to the user as quickly as possible. In the background, the WebAssembly version is downloaded and cached so the next time they visit the site, it will use the cached Blazor WebAssembly version. If the WebAssembly version can be downloaded and started within 100 milliseconds, it will load only the WebAssembly version. If it takes longer, it will start up Blazor Server and download in the background. This is one of the ways we can speed up the download speed of our Blazor site. We can combine all of these technologies, pre-render the content on the server using Static Server-side Rendering, make the site interactive using Blazor Server (using SignalR), and then switch over to Blazor WebAssembly without the “long” download time. </p>
<h1 class="heading-1" id="_idParaDest-29">Summary</h1>
<p class="normal">In this chapter, we discussed how Blazor was created and its underlying technologies, such as SignalR and WebAssembly. You also learned about the render tree and how the DOM gets updated to give you an understanding of how Blazor works under the hood.</p>
<p class="normal">We got an overview of the different technologies you can use with Blazor, such as server-side (Blazor Server), client-side (WebAssembly), desktop, and mobile (Blazor Hybrid). This overview should have helped you decide what technology to choose for your next project.</p>
<p class="normal">We talked about why Blazor is a good choice for .NET developers. </p>
<p class="normal">We looked at SSR and (according to me) the most exciting feature in .NET 8 for Blazor, what was known as Blazor United.</p>
<p class="normal">In the upcoming chapters, I will walk you through various scenarios to equip you with the knowledge to handle everything from upgrading an old/existing site and creating a new server-side site to creating a new WebAssembly site.</p>
<p class="normal">In the next chapter, we’ll get our hands dirty by configuring our development environment and creating and examining our first Blazor app.</p>
<h1 class="heading-1" id="_idParaDest-30">Further reading</h1>
<p class="normal">As a .NET developer, you might be interested in Uno Platform (<a href="https://platform.uno/">https://platform.uno/</a>), which makes it possible to create a UI in XAML and deploy it to many different platforms, including WebAssembly.</p>
<p class="normal">If you want to see how the ZX Spectrum emulator is built, you can download the source code here: <a href="https://github.com/EngstromJimmy/ZXSpectrum">https://github.com/EngstromJimmy/ZXSpectrum</a>.</p>
<h1 class="heading-1" id="_idParaDest-31">Join our community on Discord </h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/WebDevBlazor3e">https://packt.link/WebDevBlazor3e</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code2668029180838459906.png"/></p>
</div>
</body></html>