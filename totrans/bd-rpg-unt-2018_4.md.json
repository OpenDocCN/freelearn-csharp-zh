["```cs\nusing System;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace com.noorcon.rpg2e\n{\n  public class BarbarianCharacterCustomization : MonoBehaviour\n  {\n    public GameObject PLAYER_CHARACTER;\n\n    public PlayerCharacter PlayerCharacterData;\n\n    public Material[] PLAYER_SKIN;\n\n    public GameObject CLOTH_01LOD0;\n    public GameObject CLOTH_01LOD0_SKIN;\n    public GameObject CLOTH_02LOD0;\n\n    // Player Character Defense Weapons\n    public GameObject SHIELD_01LOD0;\n    public GameObject SHIELD_02LOD0;\n\n    public GameObject QUIVER_LOD0;\n    public GameObject BOW_01_LOD0;\n\n    // Player Character Calf - Right / Left\n    public GameObject KNEE_PAD_R_LOD0;\n    public GameObject LEG_PLATE_R_LOD0;\n\n    public GameObject KNEE_PAD_L_LOD0;\n    public GameObject LEG_PLATE_L_LOD0;\n\n    public GameObject BOOT_01LOD0;\n    public GameObject BOOT_02LOD0;\n\n    // Use this for initialization\n    void Start()\n    {\n      PlayerCharacterData = PLAYER_CHARACTER.GetComponent<PlayerAgent>().playerCharacterData;\n    }\n\n    public bool ROTATE_MODEL = false;\n\n    // Update is called once per frame\n    void Update()\n    {\n      if (Input.GetKeyUp(KeyCode.R))\n      {\n        ROTATE_MODEL = !ROTATE_MODEL;\n      }\n\n      if (ROTATE_MODEL)\n      {\n        PLAYER_CHARACTER.transform.Rotate(new Vector3(0, 1, 0), 33.0f * Time.deltaTime);\n      }\n\n      if (Input.GetKeyUp(KeyCode.L))\n      {\n        Debug.Log(PlayerPrefs.GetString(\"Name\"));\n      }\n\n    }\n\n        void DisableShoulderPads()\n        {\n            SHOULDER_PAD_R_01LOD0.SetActive(false);\n            SHOULDER_PAD_R_02LOD0.SetActive(false);\n            SHOULDER_PAD_R_03LOD0.SetActive(false);\n            SHOULDER_PAD_R_04LOD0.SetActive(false);\n\n            SHOULDER_PAD_L_01LOD0.SetActive(false);\n            SHOULDER_PAD_L_02LOD0.SetActive(false);\n            SHOULDER_PAD_L_03LOD0.SetActive(false);\n            SHOULDER_PAD_L_04LOD0.SetActive(false);\n        }\n```", "```cs\n    public void SetShoulderPad(Toggle id)\n    {\n      try\n      {\n        PlayerCharacter.ShoulderPad name \n          = (PlayerCharacter.ShoulderPad)Enum.Parse(typeof(PlayerCharacter.ShoulderPad), id.name, true);\n        if (id.isOn)\n        {\n          PlayerCharacterData.SelectedShoulderPad = name;\n        }\n        else\n        {\n          PlayerCharacterData.SelectedShoulderPad \n            = PlayerCharacter.ShoulderPad.none;\n        }\n      }\n      catch\n      {\n        // if the value passed is not in the enumeration set it to none\n        PlayerCharacterData.SelectedShoulderPad \n          = PlayerCharacter.ShoulderPad.none;\n      }\n\n            // disable before new selection\n            DisableShoulderPads();\n\n            switch (id.name)\n      {\n        case \"SP01\":\n          {\n            SHOULDER_PAD_R_01LOD0.SetActive(id.isOn);\n            SHOULDER_PAD_L_01LOD0.SetActive(id.isOn);\n            break;\n          }\n...\n        case \"SP04\":\n          {\n            SHOULDER_PAD_R_04LOD0.SetActive(id.isOn);\n            SHOULDER_PAD_L_04LOD0.SetActive(id.isOn);\n            break;\n          }\n      }\n    }\n\n    public void SetShoulderPad(PlayerCharacter.ShoulderPad id)\n    {\n            // disable before new selection\n            DisableShoulderPads();\n\n            switch (id.ToString())\n      {\n        case \"SP01\":\n          {\n            SHOULDER_PAD_R_01LOD0.SetActive(true);\n            SHOULDER_PAD_L_01LOD0.SetActive(true);\n            break;\n          }\n...\n        case \"SP04\":\n          {\n            SHOULDER_PAD_R_04LOD0.SetActive(true);\n            SHOULDER_PAD_L_04LOD0.SetActive(true);\n            break;\n          }\n      }\n    }\n...https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition\n```", "```cs\nusing UnityEngine; \nusing System.Collections; \n\npublic class DoNotDestroy : MonoBehaviour \n{ \n\n   // Use this for initialization \n   void Start() \n   { \n      DontDestroyOnLoad(this); \n   } \n\n   // Update is called once per frame \n   void Update() \n   { \n\n   } \n} \n```", "```cs\nusing UnityEngine;\nusing UnityEngine.AI;\nnamespace com.noorcon.rpg2e\n{\npublic class NPC_BarbarianMovement : MonoBehaviour\n{\n// reference to the animator\npublic Animator animator;\n// these variables are used for the speed\n// horizontal and vertical movement of the NPC\npublic float speed = 0.0f;\npublic float h = 0.0f;\npublic float v = 0.0f;\npublic bool attack = false; // used for attack mode 1\npublic bool jump = false; // used for jumping\npublic bool die = false; // are we alive?\n// used for debugging\npublic bool DEBUG = false;\npublic bool DEBUG_DRAW = false;\n// Reference to the NavMeshAgent component.\nprivate NavMeshAgent nav;\n// Reference to the sphere collider trigger component.\nprivate SphereCollider col;\n// where is the player character in relation to NPC\npublic Vector3 direction;\n// how far away is the player character from NPC\npublic float distance = 0.0f;\n// what is the angle between the PC and NPC\npublic float angle = 0.0f;\n// a reference to the player character\npublic GameObject player;\n// is the PC in sight?\npublic bool playerInSight;\n// what is the field of view for our NPC?\n// currently set to 110 degrees\npublic float fieldOfViewAngle = 110.0f;\n// calculate the angle between PC and NPC\npublic float calculatedAngle;\nvoid Awake()\n{\n// get reference to the animator component\nanimator = GetComponent<Animator>() as Animator;\n// get reference to nav mesh agent\nnav = GetComponent<NavMeshAgent>() as NavMeshAgent;\n// get reference to the sphere collider\ncol = GetComponent<SphereCollider>() as SphereCollider;\n// get reference to the player\nplayer = GameObject.FindGameObjectWithTag(\"Player\") as GameObject;\n// we don't see the player by default\nplayerInSight = false;\n}\n// Use this for initialization\nvoid Start()\n{\n}\nvoid Update()\n{\n// if player is in sight let's slerp towards the player\nif (playerInSight)\n{\ntransform.rotation =\nQuaternion.Slerp(this.transform.rotation,\nQuaternion.LookRotation(direction), 0.1f);\n}\n}\n// let's update our scene using fixed update\nvoid FixedUpdate()\n{\nh = angle; // assign horizontal axis\nv = distance; // assign vertical axis\n// calculate speed based on distance and delta time\nspeed = distance / Time.deltaTime;\nif (DEBUG)\nDebug.Log(string.Format(\"H:{0} - V:{1} - Speed:{2}\", h, v, speed));\n// set the parameters defined in the animator controller\nanimator.SetFloat(\"Speed\", speed);\nanimator.SetFloat(\"AngularSpeed\", v);\nanimator.SetBool(\"Attack\", attack);\n}\n```", "```cs\n// if the PC is in our collider, we want to examine the location\n// of the player\n// calculate the direction based on our position and the\n// player's position\n// use the DOT product to get the angle between the two vectors\n// calculate the angle between the NPC forward vector and the PC\n// if it falls within the field of view, we have the player in\n// sight\n// if the player is in sight, we will set the nav agent destination\n// if we are within a certain distance from the PC, the NPC has\n// the ability to attack\nvoid OnTriggerStay(Collider other)\n{\nif (other.transform.tag.Equals(\"Player\"))\n{\n// Create a vector from the enemy to the player and store\n// the angle between it and forward.\ndirection = other.transform.position - transform.position;\ndistance = Vector3.Distance(other.transform.position, transform.position) - 1.0f;\nfloat DotResult = Vector3.Dot(transform.forward, player.transform.position);\nangle = DotResult;\nif (DEBUG_DRAW)\n{\nDebug.DrawLine(transform.position + Vector3.up, direction * 50, Color.gray);\nDebug.DrawLine(other.transform.position, transform.position, Color.cyan);\n}\nplayerInSight = false;\ncalculatedAngle = Vector3.Angle(direction, transform.forward);\nif (calculatedAngle < fieldOfViewAngle * 0.5f)\n{\nRaycastHit hit;\nif (DEBUG_DRAW)\nDebug.DrawRay(transform.position + transform.up, direction.normalized, Color.magenta);\n// ... and if a raycast towards the player hits something...\nif (Physics.Raycast(transform.position + transform.up, direction.normalized, out hit,\ncol.radius))\n{\n// ... and if the raycast hits the player...\nif (hit.collider.gameObject == player)\n{\n// ... the player is in sight.\nplayerInSight = true;\nif (DEBUG)\nDebug.Log(\"PlayerInSight: \" + playerInSight);\n}\n}\n}\nif (playerInSight)\n{\nnav.SetDestination(other.transform.position);\nCalculatePathLength(other.transform.position);\nif (distance < 1.1f)\n{\nattack = true;\n}\nelse\n{\nattack = false;\n}\n}\n}\n}\n```", "```cs\nvoid OnTriggerExit(Collider other)\n{\nif (other.transform.tag.Equals(\"Player\"))\n{\ndistance = 0.0f;\nangle = 0.0f;\nattack = false;\nplayerInSight = false;\n}\n}\n// this is a helper function at this point\n// in the future we will use it to calculate distance around\n// the corners\n// it currently is also used to draw the path of the nav mesh\n// agent in the\n// editor\nfloat CalculatePathLength(Vector3 targetPosition)\n{\n// Create a path and set it based on a target position.\nNavMeshPath path = new NavMeshPath();\nif (nav.enabled)\nnav.CalculatePath(targetPosition, path);\n// Create an array of points which is the length of the number\n// of corners in the path + 2.\nVector3[] allWayPoints = new Vector3[path.corners.Length + 2];\n// The first point is the enemy's position.\nallWayPoints[0] = transform.position;\n// The last point is the target position.\nallWayPoints[allWayPoints.Length - 1] = targetPosition;\n// The points inbetween are the corners of the path.\nfor (int i = 0; i < path.corners.Length; i++)\n{\nallWayPoints[i + 1] = path.corners[i];\n}\n// Create a float to store the path length that is by default 0.\nfloat pathLength = 0;\n// Increment the path length by an amount equal to the\n// distance between each waypoint and the next.\nfor (int i = 0; i < allWayPoints.Length - 1; i++)\n{\npathLength += Vector3.Distance(allWayPoints[i], allWayPoints[i + 1]);\nif (DEBUG_DRAW)\nDebug.DrawLine(allWayPoints[i], allWayPoints[i + 1], Color.red);\n}\nreturn pathLength;\n}\n}\n}\n```", "```cs\ndirection = other.transform.position - transform.position; \n\ndistance = Vector3.Distance(other.transform.position, transform.position) - 1.0f; \n\nfloat DotResult = Vector3.Dot(transform.forward,player.transform.position); \n\nangle = DotResult; \n```", "```cs\nusing UnityEngine; \nusing System.Collections; \n\npublic class NPC_Movement : MonoBehaviour \n{ \n... \n    void Update() \n    { \n        // if player is in sight let's slerp towards the player \n        if (playerInSight) \n        { \n            this.transform.rotation = \n                Quaternion.Slerp(this.transform.rotation, \n                Quaternion.LookRotation(direction), 0.1f); \n        } \n\n        if(this.player.transform.GetComponent<CharacterController>().die) \n        { \n            animator.SetBool(\"Attack\", false); \n            animator.SetFloat(\"Speed\", 0.0f); \n            animator.SetFloat(\"AngularSpeed\", 0.0f); \n        } \n    } \n\n    // let's update our scene using fixed update \n    void FixedUpdate() \n    { \n        h = angle;          // assign horizontal axis \n        v = distance;       // assign vertical axis \n\n        // calculate speed based on distance and delta time \n        speed = distance / Time.deltaTime; \n\n        if (DEBUG) \n            Debug.Log(string.Format(\"H:{0} - V:{1} - Speed:{2}\", h, v, speed)); \n\n        // set the parameters defined in the animator controller \n        animator.SetFloat(\"Speed\", speed); \n        animator.SetFloat(\"AngularSpeed\", v); \n        animator.SetBool(\"Attack\", attack1); \n        animator.SetBool(\"Attack1\", attack1); \n\n        if(playerInSight) \n        { \n            if (animator.GetFloat(\"Attack1C\") == 1.0f) \n            { \n                this.player.GetComponent<PlayerAgent>().playerCharacterData.HEALTH -= 1.0f; \n            } \n        } \n    } \n... \n} \n```", "```cs\n    using System;\n    using UnityEngine;\n\n    namespace com.noorcon.rpg2e\n    {\n       [Serializable]\n       public class BaseCharacter\n       {\n          [SerializeField]\n          public string Name;\n          [SerializeField]\n          public string Description;\n\n          [SerializeField]\n          public float Strength;\n          [SerializeField]\n          public float Defense;\n          [SerializeField]\n          public float Dexterity;\n          [SerializeField]\n          public float Intelligence;\n          [SerializeField]\n          public float Health;\n       }\n    }\n```", "```cs\nusing System; \nusing UnityEngine; \n\nnamespace com.noorcon.rpg2e \n{ \n   [Serializable] \n   public class PlayerCharacter : MonoBehaviour \n   { \n\n   } \n} \n```", "```cs\nusing System; \nusing UnityEngine; \n\nnamespace com.noorcon.rpg2e \n{ \n   [Serializable] \n   public class PlayerAgent : MonoBehaviour \n   { \n      public PlayerCharacter playerCharacterData; \n\n      void Awake() \n      { \n         PlayerCharacter tmp = new PlayerCharacter(); \n         tmp.Name = \"Maximilian\"; \n         tmp.Health = 100.0f; \n         tmp.Defense = 50.0f; \n         tmp.Description = \"Our Hero\"; \n         tmp.Dexterity = 33.0f; \n         tmp.Intelligence = 80.0f; \n         tmp.Strength = 60.0f; \n\n         playerCharacterData = tmp; \n      } \n\n      // Use this for initialization \n      void Start() \n      { \n\n      } \n\n      // Update is called once per frame \n      void Update() \n      { \n         if (playerCharacterData.Health < 0.0f) \n         { \n            playerCharacterData.Health = 0.0f; \n\n            transform.GetComponent<BarbarianCharacterController>().die = true; \n         } \n      } \n   } \n} \n```"]