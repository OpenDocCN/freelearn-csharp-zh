- en: Coding for the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云端编码
- en: The previous chapters explored patterns, from lower-level concepts such as the
    Singleton and Factory patterns, to patterns for specific technologies such as
    databases and web applications. These patterns are essential for ensuring the
    good design of a solution to ensure maintainability and efficient implementation.
    These patterns provide a solid foundation that allows applications to be enhanced
    and modified as requirements change and new functionality is added.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章探讨了从较低层次的概念，如单例模式和工厂模式，到特定技术（如数据库和Web应用）的模式。这些模式对于确保解决方案的良好设计至关重要，以确保可维护性和高效的实现。这些模式提供了一个坚实的基础，使得应用能够随着需求的变化和新功能的添加而增强和修改。
- en: This chapter takes a higher-level view of a solution to address concerns involving
    designing implementing solutions that are reliable, scalable, and secure. The
    patterns in this chapter often involve environments that contain multiple applications,
    a repository, and a range of possible infrastructure configurations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从更高层次的角度审视解决方案，以解决设计、实施可靠、可扩展和安全的解决方案所涉及的问题。本章中讨论的模式通常涉及包含多个应用、存储库和一系列可能的基础设施配置的环境。
- en: The software industry is continually evolving and with the change comes new
    opportunity as well as new challenges. In this chapter, we will look at different
    software patterns for the cloud. Many of these patterns are not new, and existed
    in on-premises environments. As cloud-first solutions are becoming the norm, these
    patterns are even more commonplace due to the ease of implementing solutions that
    do not rely on on-premises infrastructure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业持续发展，随着变化而来的是新的机遇以及新的挑战。在本章中，我们将探讨针对云的不同软件模式。许多这些模式并非新颖，它们存在于本地环境中。随着云优先解决方案成为常态，这些模式变得更加普遍，因为实现不依赖本地基础设施的解决方案变得容易。
- en: Cloud-first or cloud-native solutions have been designed to target cloud computing
    resources, while hybrid solutions have been designed to use both cloud computing
    resources as well as resources from a private data center.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 云优先或云原生解决方案旨在针对云计算资源，而混合解决方案旨在使用云计算资源以及来自私有数据中心资源。
- en: 'This chapter defines five key concerns when building solutions in the cloud:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章定义了在云中构建解决方案时的五个关键关注点：
- en: Scalability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Availability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Application design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用设计
- en: DevOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: We will discuss the key concerns and why they are significant to building cloud
    solutions. As the concerns are discussed, different patterns will be described
    that can be applied to address these concerns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这些关键关注点及其在构建云解决方案中的重要性。在讨论这些问题时，将描述可以应用于解决这些问题的不同模式。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any special technical requirements or source code
    as it is primarily theoretical.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何特殊的技术要求或源代码，因为它主要是理论性的。
- en: Key considerations when building solutions in the cloud
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中构建解决方案时的关键考虑因素
- en: Making the decision to move to the cloud comes with its own set of problems
    and challenges. In this section, we will cover five key areas of consideration
    for building cloud-based solutions. While these are not unique to the cloud, they
    require special attention when switching to the cloud due to the wide range of
    technologies and solutions that are available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 决定迁移到云中会带来其自身的问题和挑战。在本节中，我们将讨论构建基于云的解决方案时需要考虑的五个关键领域。虽然这些问题并非云所独有，但由于可用的技术和解决方案范围广泛，因此在迁移到云时需要特别注意。
- en: 'The five primary considerations are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 五个主要考虑因素如下：
- en: '**Scalability**: This allows for accommodation of increased load or traffic
    for a growing business.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这允许适应不断增长的业务增加的负载或流量。'
- en: '**Resilience/availability**: This ensures the handling of failures in a system
    gracefully with as little impact on the user as possible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性/可用性**：这确保了系统在处理故障时尽可能优雅，对用户的影响最小。'
- en: '**Security**: This ensures that private and proprietary data stays that way
    and is safe from hacks and attacks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这确保了私有和专有数据保持私密，并免受黑客和攻击。'
- en: '**Application design**: This refers to the design of applications with special
    consideration for cloud-based solutions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用设计**：这指的是对应用进行设计，特别考虑基于云的解决方案。'
- en: '**DevOps**: This is a collection of tools and practices that supports the development
    and running of cloud-based solutions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps**：这是一个支持基于云的解决方案的开发和运行的工具和实践的集合。'
- en: Depending on your business requirements, you may need to look for solutions
    for some or all of these considerations. It is also in your business's best interest
    to adopt providers with solutions to problems that you don't anticipate but would
    make for good contingency planning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的业务需求，您可能需要寻找解决这些考虑因素中的一些或全部的解决方案。同时，为了您的业务利益，采用能够解决您未预见到但会为良好的应急计划做出贡献的问题的提供商也是有益的。
- en: In the following sections, we will discuss these considerations in further detail
    along with the available solution patterns for them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将进一步详细讨论这些考虑因素以及针对它们的可用解决方案模式。
- en: These patterns range from a type of technology to architectural to business
    processes and a single pattern could address more than one concern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式从技术类型到架构到业务流程，一个模式可以解决多个问题。
- en: Scalability
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Scalability refers to the ability to allocate and manage resources used by an
    application in order for the application to maintain an acceptable level of quality
    under a given workload. Most cloud offerings provide mechanisms for increasing
    the quality and quantity of resources used by an application. For example, the
    Azure App Service allows scaling of both the size of the App Service and the number
    of instances of the App Service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性指的是在给定工作负载下，应用能够分配和管理其使用的资源，以便在应用中保持可接受的质量水平。大多数云服务提供增加应用使用的资源质量和数量的机制。例如，Azure
    App Service允许扩展App Service的大小和App Service实例的数量。
- en: Scalability can be viewed as demand on a limited number of resources. A resource
    could be disk space, RAM, bandwidth, or another aspect of software that can be
    quantified. The demand can range from the number of users, concurrent connections,
    or another demand that would produce a constraint on a resource. As the demand
    increases, a strain is placed on the application in order to provide the resource.
    When the strain affects the performance of the application, this is referred to
    as a resource bottleneck.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性可以被视为对有限数量资源的需求。资源可以是磁盘空间、RAM、带宽或软件的另一个可量化的方面。需求可以从用户数量、并发连接或其他会对资源产生约束的需求中产生。随着需求的增加，应用将承受压力以提供资源。当压力影响应用性能时，这被称为资源瓶颈。
- en: For example, a measure might be the number of users that can access an application
    before the performance of the application begins to deteriorate. The performance
    could be set as an average latency on requests being less than 2 seconds. As the
    number of users increases, the load on the system could then be viewed, and specific
    resource bottlenecks affecting the performance could be identified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个衡量标准可能是应用性能开始下降之前可以访问应用的用户数量。性能可以设定为请求的平均延迟小于2秒。随着用户数量的增加，可以观察系统负载，并确定影响性能的具体资源瓶颈。
- en: Workload
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载
- en: 'In order to determine how to effectively address scaling issues, it is important
    to understand the workload that the system will be under. There are four main
    types of workload: static, periodic, once-in-a-lifetime and unpredictable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定如何有效地解决可扩展性问题，了解系统将承受的工作负载非常重要。有四种主要类型的工作负载：静态、周期性、一生一次和不可预测的。
- en: A static workload represents a constant level of activity on a system. Because
    the workload does not fluctuate, this type of system does not require a very elastic
    infrastructure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工作负载表示系统上的活动水平保持恒定。由于工作负载没有波动，这类系统不需要非常灵活的基础设施。
- en: Systems that have a predictable change in workload have a periodic workload.
    An example would be a system that experiences a surge of activity around the weekends
    or around the months when income tax is due. These systems can be scaled up to
    maintain a desired level of quality when the load increases and scaled down to
    save cost when the load decreases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可预测工作负载变化系统的周期性工作负载。一个例子是周末或收入税到期月份活动激增的系统。这些系统可以在负载增加时扩展以维持所需的质量水平，在负载减少时缩减以节省成本。
- en: Once-in-a-lifetime workloads indicate systems designed around a specific event.
    These systems are provisioned to handle the workload around the event and deprovisioned
    once they are no longer needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一生一次的工作负载表明围绕特定事件设计的系统。这些系统被配置来处理事件周围的工作负载，一旦不再需要就取消配置。
- en: Unpredictable workloads often benefit from the auto-scale functionality mentioned
    earlier. These systems have large fluctuations in activity that are either not
    understood by the business yet or are influenced by other factors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不可预测的工作负载通常可以从前面提到的自动扩展功能中受益。这些系统活动的大幅波动可能尚未被业务理解，或受到其他因素的影响。
- en: Understanding and designing a cloud-based application for its type of workload
    is essential for both maintaining a high level of performance as well as lowering
    costs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和设计基于云的应用程序以适应其工作负载类型对于保持高性能以及降低成本至关重要。
- en: Solution patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: 'We have available three design patterns and one architecture pattern to choose
    from to enable us to add scalability to our systems:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种设计模式和一种架构模式可供选择，以使我们能够为系统添加可伸缩性：
- en: Vertical scaling
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Horizontal scaling
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Auto-scaling
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Microservices
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Let's review each in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地回顾一下。
- en: Vertical scaling
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Though it is possible to add physical RAM or an additional disk drive to an
    on-premises server, most cloud providers support the ability to easily increase
    or decrease the computing power of a system. This is often with little or no downtime
    as the system scales. This type of scaling is called vertical scaling and refers
    to when a resource such as the type of CPU, size and quality of RAM, or size and
    quality of the disk is altered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在本地服务器上添加物理RAM或额外的磁盘驱动器，但大多数云服务提供商支持轻松增加或减少系统计算能力的能力。这种扩展通常在系统扩展时几乎没有或没有停机时间。这种类型的扩展称为垂直扩展，指的是当CPU类型、RAM的大小和质量或磁盘的大小和质量等资源发生改变时。
- en: Vertical scaling is often referred to as *scaling up* while horizontal scaling
    is often referred to as *scaling out*. In this context, the term *up* refers to
    the size of the resource while *out* refers to the number of instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展通常被称为*向上扩展*，而水平扩展通常被称为*向外扩展*。在这个上下文中，术语*向上*指的是资源的大小，而*向外*指的是实例的数量。
- en: Horizontal scaling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Horizontal scaling differs from vertical scaling because, instead of altering
    the size of a system, horizontal scaling changes the number of systems involved.
    For example, a web application might run on a single server having 4 GB RAM and
    2 CPUs. If the server was increased in size to 8 GB RAM and 4 CPUs, then this
    would be vertical scaling. However, if two more servers were added with the same
    configuration of 4 GB RAM and 2 CPUs, then this would be horizontal scaling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展与垂直扩展的不同之处在于，它不是改变系统的大小，而是改变涉及的系统数量。例如，一个Web应用程序可能运行在一个拥有4 GB RAM和2个CPU的单个服务器上。如果将服务器的容量增加到8
    GB RAM和4个CPU，那么这将是垂直扩展。然而，如果添加了两个配置相同的4 GB RAM和2个CPU的服务器，那么这将是水平扩展。
- en: 'Horizontal scaling can be achieved by using some form of load balancing that
    redirects the requests across a collection of systems as illustrated in the following
    diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展可以通过使用某种形式的负载均衡来实现，该负载均衡将请求重定向到系统集合中，如下面的图示所示：
- en: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
- en: Horizontal scaling is usually preferred in cloud solutions over vertical scaling.
    This is because, in general, it is more cost effective to use several smaller
    virtual machines to a single large server to provide the same measure of performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在云解决方案中，水平扩展通常比垂直扩展更受欢迎。这是因为，一般来说，使用几个较小的虚拟机而不是单个大型服务器来提供相同性能的度量更经济有效。
- en: For horizontal scaling to be most effective, it does require a system design
    that supports this type of scaling. For example, web applications designed without
    sticky sessions and/or state stored on the server work better for horizontal scaling.
    This is because sticky sessions cause a user's requests to be routed to the same
    virtual machine for processing and, over time, the balance of the routing across
    the virtual machines could become uneven and therefore not as efficient as possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使水平扩展最有效，确实需要一种支持此类扩展的系统设计。例如，没有粘性会话和/或服务器上存储状态的Web应用程序更适合水平扩展。这是因为粘性会话会导致用户的请求被路由到同一虚拟机进行处理，随着时间的推移，虚拟机之间的路由平衡可能会变得不均匀，因此可能不是最有效的。
- en: Stateful applications
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态应用程序
- en: A *stateful* application maintains information about an active session on the
    server or repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *有状态* 的应用程序在服务器或存储库上维护有关活动会话的信息。
- en: Stateless applications
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态应用程序
- en: '*Stateless* applications are designed to not require information about an active
    session to be stored on the server or repository. This allows for subsequent requests
    in a single session to be sent to any server to be handled and not just to the
    same server for the entire session.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*无状态* 应用程序设计为不需要在服务器或存储库中存储有关活动会话的信息。这允许在单个会话中的后续请求可以发送到任何服务器进行处理，而不仅仅是整个会话期间发送到同一服务器。'
- en: Web applications designed that are stateful require sessions or information
    to be maintained in a shared repository. Stateless web applications support a
    more resilient pattern as any server in a web garden or web farm. This allows
    for a single node in the web application to fail without losing session information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设计为有状态的 Web 应用程序需要在共享存储库中维护会话或信息。无状态 Web 应用程序支持更健壮的模式，因为任何服务器在 Web 花园或 Web 农场中。这允许
    Web 应用程序的单个节点失败而不会丢失会话信息。
- en: A web *garden* is a pattern where multiple copies of the same web application
    are hosted on the same server, whereas a web *farm* is a pattern where multiple
    copies of the same web application are hosted on different servers. In both patterns,
    routing is used to expose the multiple copies as if they were a single application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *花园* 式的 Web 应用程序是指多个相同的 Web 应用程序在同一服务器上托管，而一个 *农场* 式的 Web 应用程序是指多个相同的 Web
    应用程序在不同的服务器上托管。在这两种模式中，路由都用于将多个副本暴露出来，就像它们是一个单一的应用程序一样。
- en: Auto-scaling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展
- en: 'An advantage of using a cloud provider over on-premises solutions is the built-in
    support for auto-scaling. As an added benefit to horizontal scaling, the ability
    to auto-scale an application is often a configurable feature of a cloud service.
    For example, an Azure App Service provides the ability to set up auto-scale profiles
    that allow an application to react to conditions. For example, the following screenshot
    shows an auto-scale profile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务提供商而不是本地解决方案的优势在于内置的自动扩展支持。作为水平扩展的额外好处，自动扩展应用程序的能力通常是云服务的一个可配置功能。例如，Azure
    App Service 提供了设置自动扩展配置文件的能力，允许应用程序对条件做出反应。例如，以下截图显示了一个自动扩展配置文件：
- en: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
- en: The profile designed for weekdays will increase or decrease the number of app
    service instances depending on the load on the servers. The load is being measured
    in CPU percentage. If the CPU percentage is averages above 60%, then the number
    of instances is increased up to a maximum of 10\. Similarly, if the CPU percentage
    falls below 30%, the number of instances is reduced to a minimum of 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为工作日设计的配置文件将根据服务器的负载增加或减少应用程序实例的数量。负载是通过 CPU 百分比来衡量的。如果 CPU 百分比平均超过 60%，则实例数量将增加到最多
    10 个。同样，如果 CPU 百分比低于 30%，则实例数量将减少到最少 2 个。
- en: An elastic infrastructure allows for resources to be scaled vertically or horizontally
    without requiring a re-deploy or downtime. The term is actually more of a degree
    of elasticity instead of referring to whether a system is *elastic* or *not elastic*.
    For example, an elastic service could allow for scaling both vertically and horizontally
    without requiring a restart of the service instances. A less elastic service would
    allow for scaling horizontally without a restart but would require a restart of
    the service when the size of the server is altered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性基础设施允许资源垂直或水平扩展，而无需重新部署或停机。实际上，这个术语更多地是指弹性程度，而不是指系统是否是 *弹性的*。例如，一个弹性的服务可以允许垂直和水平扩展，而无需重启服务实例。一个弹性较低的服务可以在不重启的情况下进行水平扩展，但需要在更改服务器大小时重启服务。
- en: Microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'There are different interpretations of what microservices means and how it
    relates to **service-oriented architecture** (**SOA**). In this section, we are
    going to view microservices as a refinement of SOA and not a new architectural
    pattern. The microservice architecture extends SOA by adding some additional key
    principles which require that services must:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务意味着什么以及它与 **面向服务的架构**（**SOA**）如何相关，存在不同的解释。在本节中，我们将把微服务视为SOA的细化，而不是一种新的架构模式。微服务架构通过添加一些额外的关键原则来扩展SOA，这些原则要求服务必须：
- en: be small - hence the term *micro*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很小——因此称为 *微观*
- en: be built around a business capability
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕业务能力构建
- en: be loosely coupled with other services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他服务松散耦合
- en: be independently maintainable
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立可维护
- en: have an isolated state
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有隔离的状态
- en: Small
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小型
- en: Microservices takes the services in SOA farther by reducing them to their smallest
    possible size. This fits well with some other patterns that we have seen, such
    as **Keep It Simple Stupid** (**KISS**) and **You Aren't Gonna Need It** (**YAGNI**)
    from [Chapter 2](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml), *Modern Software
    Design Patterns and Principles*. The microservice should only fulfill its requirements
    and nothing more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过将服务缩减到可能的最小尺寸，将SOA中的服务推进得更远。这很好地符合我们看到的某些其他模式，例如来自第2章的**简单至上**（**KISS**）和**你不需要它**（**YAGNI**）模式，见*现代软件开发模式和原则*。微服务应该只满足其需求，而不做更多。
- en: Business capability
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务能力
- en: By building a service around a business capability, we align our implementation
    in such a way that, as the business requirements change, our services will be
    changed in a similar manner. Because of this, it is less likely that change in
    one area of the business will impact other areas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过围绕业务能力构建服务，我们以这种方式调整我们的实现，使得当业务需求发生变化时，我们的服务将以类似的方式改变。正因为如此，业务某一领域的变更不太可能影响其他领域。
- en: Loosely coupled
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: A microservice should interact with other services across a service boundary
    using a technology-agnostic protocol such as HTTP. This allows for the microservices
    to be integrated more easily and, more importantly, not require the rebuild of
    a microservice when another service changes. This does require a known *service
    contract* to exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该使用如HTTP这样的技术无关协议在服务边界与其他服务进行交互。这允许微服务更容易地集成，更重要的是，当其他服务发生变化时，不需要重新构建微服务。这确实需要存在已知的*服务合同*。
- en: Service contract
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务合同
- en: A *service contract* is the definition of a service that is distributed to other
    development teams. **Web Services Description Language** (**WSDL**) is a widely
    known XML-based language for describing services, but other languages, such as
    Swagger, are also very popular.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务合同*是向其他开发团队分发的服务的定义。**Web服务描述语言**（**WSDL**）是一种广泛使用的基于XML的语言，用于描述服务，但其他语言，如Swagger，也非常受欢迎。'
- en: When implementing a microservice, it is important to have a strategy for how
    the change will be managed. By having a versioned service contract, it is then
    possible to communicate the change clearly to a client of the service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现微服务时，制定一个如何管理变更的策略非常重要。通过拥有版本化的服务合同，就可以清楚地与服务客户端沟通变更。
- en: 'For example, the strategy of a microservice used to store an inventory of books
    could have the following strategy:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于存储书籍库存的微服务所使用的策略可能如下：
- en: Each service will be versioned and include a Swagger definition.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都将进行版本控制并包含Swagger定义。
- en: Each service will start with version 1.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务将从版本1开始。
- en: When a change is made that requires the service contract to change, the version
    will be increased by 1.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务合同需要变更时，版本号将增加1。
- en: The service will maintain up to three versions.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务将维护最多三个版本。
- en: Changes to a service must ensure that all current versions behave suitably.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务的变更必须确保所有当前版本的行为都适宜。
- en: The preceding basic strategy does have interesting implications. First of all,
    the team maintaining a service must ensure that changes do not break existing
    services. This ensures a new deployment will not break other services while allowing
    for new functionality to be deployed. The contract does allow for up to three
    services to be active at a time, thus allowing for a dependable service to update
    independently.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的基本策略确实有一些有趣的含义。首先，维护服务的团队必须确保变更不会破坏现有的服务。这确保了新的部署不会破坏其他服务，同时允许部署新的功能。合同确实允许同时最多有三个服务处于活动状态，从而允许可信赖的服务独立更新。
- en: Independently maintainable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立可维护
- en: This is one of the most distinguishing features of microservices. Having a microservice
    able to be maintained independent of other microservices empowers a business to
    be able to manage the service without impacting other services. By managing a
    service, we are including both the development as well as the deployment of a
    service. With this principle, microservices can be updated and deployed with a
    reduced chance of impacting other services, as well as at a different rate of
    change from other services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务最显著的特征之一。拥有能够独立于其他微服务维护的微服务，使企业能够管理服务而不会影响其他服务。通过管理服务，我们包括服务的开发以及部署。根据这一原则，微服务可以以降低影响其他服务的风险以及与其他服务不同的变化速度进行更新和部署。
- en: Isolated state
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立状态
- en: Isolated state includes both data and other resources that could be shared including
    databases and files. This is also a distinguishing feature of microservice architecture.
    By having an independent state, we are reducing the chance that a change in the
    data model to support one service will impact other services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 独立状态包括数据和其他可共享的资源，包括数据库和文件。这也是微服务架构的一个显著特征。通过拥有独立的状态，我们减少了数据模型变化以支持一个服务而影响其他服务的可能性。
- en: 'The following diagram illustrates a more traditional SOA approach, where a
    single database is used by multiple services:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了更传统的SOA方法，其中多个服务使用单个数据库：
- en: '![](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
- en: 'By requiring a microservice to have an isolated state, we would then require
    a database per service as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过要求微服务拥有独立的状态，我们就会需要每个服务一个数据库，如下图所示：
- en: '![](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
- en: This has an advantage in that each service can choose the technology that best
    fits the requirements of the services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，即每个服务都可以选择最适合服务需求的技术。
- en: Advantages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: The microservice architecture does represent a shift from traditional service
    design and it does fit well in a cloud-based solution. The advantages of microservices
    and why they are gaining in popularity might not be immediately obvious. We have
    touched on how the design of microservices provides advantages for handling change
    gracefully. From a technical point of view, microservices can be scaled independently
    both at the service level and at the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构确实代表了从传统服务设计到的一种转变，并且它非常适合基于云的解决方案。微服务的优势以及为什么它们越来越受欢迎可能并不立即明显。我们已经讨论了微服务设计如何提供优雅处理变化的优势。从技术角度来看，微服务可以在服务级别和数据库级别独立扩展。
- en: What might not be clear is the benefit a microservice architecture has to a
    business. By having small independent services, the business can then look at
    different ways to maintain and develop microservices. The business now has options
    to host the services in different ways, including different cloud providers, as
    best fits the independent services. Likewise, the isolated nature of the services
    allows for a greater degree of agility in developing the services. As change happens,
    resources (that is, development team members) can be allocated to different services
    as required, and, as the scope of service is smaller, the amount of business knowledge
    required is also reduced.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不清楚微服务架构对企业的益处。通过拥有小型独立的服务，企业可以探索不同的方式来维护和开发微服务。企业现在有选择以不同的方式托管服务的选择，包括不同的云提供商，以最适合独立服务。同样，服务的独立性质允许在开发服务时具有更大的灵活性。随着变化的发生，资源（即，开发团队成员）可以根据需要分配到不同的服务中，并且由于服务范围较小，所需的企业知识量也减少了。
- en: Resiliency/availability
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性/可用性
- en: Resiliency is the ability of an application to handle failure gracefully while
    availability is a measure of the amount of time the application is working. An
    application may have a collection of resources and still remain available if one
    of the resources becomes inoperable or unavailable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是指应用程序优雅处理失败的能力，而可用性是衡量应用程序工作时间的指标。即使其中一个资源变得不可操作或不可用，应用程序可能仍然具有资源集合并保持可用。
- en: If an application is designed to handle one or more resources failing without
    the entire system becoming inoperable, this is referred to as **graceful degradation**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序被设计成在系统完全不可操作的情况下处理一个或多个资源失败，这被称为**优雅降级**。
- en: Patterns apply to both isolate the elements of an application as well as handle
    the interaction between the elements so that when a failure occurs, the impact
    is limited. Many of the resiliency-related patterns focus on the messaging between
    the components within the application or to other applications. The Bulkhead pattern,
    for example, isolates the traffic into pools so that when one pool becomes overwhelmed
    or fails, the other pools are not adversely affected. Other patterns apply specific
    techniques to handle messaging, such as retry policies or compensating transactions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模式适用于隔离应用程序的元素以及处理元素之间的交互，以便当发生故障时，影响被限制。许多与弹性相关的模式侧重于应用程序内部或到其他应用程序的组件之间的消息传递。例如，Bulkhead模式通过隔离流量到池中，以便当一个池过载或失败时，其他池不会受到不利影响。其他模式应用特定的技术来处理消息，例如重试策略或补偿事务。
- en: Availability is an important factor to many cloud-based applications and, typically,
    availability is measured against a **service level agreement** (**SLA**). In most
    cases, the SLA stipulates the percentage of time the application must remain operable.
    Patterns involve both allowing for redundancy of components as well as using techniques
    to limit the effect of an increase in activity. For example, the Queue-Based Load
    Leveling pattern uses a queue to limit the effect a spike in activity might have
    on an application by acting as a buffer between the caller, or client, and the
    application or service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性是许多基于云的应用程序的一个重要因素，通常，可用性是通过**服务水平协议**（**SLA**）来衡量的。在大多数情况下，SLA规定了应用程序必须保持可操作的时间百分比。模式包括允许组件冗余以及使用技术来限制活动增加的影响。例如，基于队列的负载均衡模式通过在调用者或客户端与应用程序或服务之间充当缓冲区，使用队列来限制活动峰值可能对应用程序产生的影响。
- en: Resiliency and availability are identified here as related cloud solution factors
    as often a resilient application allows for a strict SLA on availability to be
    achieved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性和可用性在此被识别为相关的云解决方案因素，因为一个弹性的应用程序通常允许实现严格的可用性SLA。
- en: Solution pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: To ensure we have a system that has resilience and availability, our best bet
    is to look for a provider with a specific architecture. Enter **event-driven architecture**
    (**EDA**).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们有一个具有弹性和可用性的系统，我们的最佳选择是寻找具有特定架构的提供商。进入**事件驱动架构**（**EDA**）。
- en: EDA is an architectural pattern that uses *events* to drive the behavior and
    activity of a system. The solution patterns available under it will help us achieve
    the intended resolutions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: EDA是一种使用*事件*来驱动系统和活动行为的架构模式。其下可用的解决方案模式将帮助我们实现预期的解决方案。
- en: EDA
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA
- en: EDA promotes the concept of having loosely connected producers and consumers
    where the producers do not have direct knowledge of the consumers. An event in
    this context is any change ranging from a user logging onto a system, to an order
    being placed, to a process failing to complete successfully. EDA fits well in
    distributed systems and allows for highly scalable solutions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: EDA提倡松散连接的生产者和消费者的概念，其中生产者没有直接了解消费者。在这个上下文中，事件是任何变化，从用户登录系统，到下单，到进程未能成功完成。EDA非常适合分布式系统，并允许实现高度可扩展的解决方案。
- en: 'There are many related patterns and approaches to EDA and the following patterns
    are presented in this section as being directly relevant to EDA:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与EDA相关的模式和途径，以下模式在本节中作为与EDA直接相关的内容进行展示：
- en: Queue-Based Load Leveling
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于队列的负载均衡
- en: Publisher Subscriber
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者-订阅者
- en: Priority Queue
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Compensating Transaction
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿事务
- en: Queue-Based Load Leveling
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于队列的负载均衡
- en: 'Queue-Based Load Leveling is an effective way of minimizing the impact of occurrences
    of high demand on availability. By introducing a queue between a client and service,
    we are able to throttle or restrict the number of requests that are being handled
    by the service at a time. This allows for smoother user experience. Take the following
    diagram as an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于队列的负载均衡是减少高需求发生对可用性影响的有效方式。通过在客户端和服务之间引入队列，我们能够调节或限制服务一次处理的请求数量。这允许提供更平滑的用户体验。以下图为例：
- en: '![](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
- en: The preceding diagram shows a client submitting a request to a queue to be processed
    and the result saved to a table. The queue acts to prevent the function from being
    overwhelmed by a sudden spike in activity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了客户端向队列提交请求以进行处理，并将结果保存到表中。队列的作用是防止功能因活动突然增加而超负荷。
- en: Publisher Subscriber
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者订阅者
- en: 'The Publisher Subscriber pattern states that there are event publishers and
    event consumers. Essentially, this is the heart of EDA, as the publishers are
    decoupled from the consumers and are not concerned about the delivery of events
    to the consumers, but only with publishing events. The event will contain information
    that will be used to route the event to interested consumers. A consumer would
    then register or subscribe to being interested in specific events:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者订阅者模式指出存在事件发布者和事件消费者。本质上，这是事件驱动架构（EDA）的核心，因为发布者与消费者解耦，并且不关心事件是否被发送给消费者，而只关心发布事件。事件将包含用于将事件路由到感兴趣消费者的信息。然后，消费者会注册或订阅对特定事件的兴趣：
- en: '![](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
- en: The preceding diagram illustrates a Customer Service and an Order Service. The
    Customer Service acts as a publisher and submits an event when a customer is added.
    The Order Service has subscribed to new customer events. When a new customer event
    is received, the Order Service inserts the customer information into its local
    store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了客户服务和订单服务。客户服务充当发布者，当添加客户时提交一个事件。订单服务已订阅新的客户事件。当接收到新的客户事件时，订单服务将客户信息插入其本地存储。
- en: By introducing the Publisher Subscriber pattern into the architecture, the Order
    Service is then decoupled from the Customer Service. An advantage of this is it
    provides a more flexible architecture for change. For example, a new service could
    be introduced to add new customers to the solutions that do not require being
    added to the same repository used by the Customer Service. Also, more than one
    service could subscribe to the new customer event. Adding a welcome email could
    more easily be added as a new subscriber, rather than having to build this functionality
    into a single monolithic solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将发布者订阅者模式引入架构，订单服务随后与客户服务解耦。这样做的一个优点是它提供了一个更灵活的架构以适应变化。例如，可以引入一个新的服务来添加新客户到解决方案中，而不需要添加到客户服务使用的相同存储库中。此外，多个服务可以订阅新的客户事件。添加欢迎邮件作为新的订阅者可以更容易地实现，而不是将此功能构建到单一的大型解决方案中。
- en: Priority Queue
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: Another related pattern is Priority Queue, which provides a mechanism for treating
    similar events differently. Using the new customer example from the previous section,
    it would be possible to have two subscribers for a new customer event. One subscriber
    would be interested in the majority of the new customers, while one subscriber
    would identify a subset of the customers that should be handled differently. For
    example, new subscribers from rural areas might receive an email with additional
    information about specialized shipping providers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的模式是优先队列，它提供了一种对不同事件进行不同处理的机制。使用上一节中的新客户示例，可以为新客户事件设置两个订阅者。一个订阅者可能对大多数新客户感兴趣，而另一个订阅者可能会识别出应该以不同方式处理的客户子集。例如，来自农村地区的新订阅者可能会收到有关专业运输提供商的额外信息的电子邮件。
- en: Compensating transaction
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补偿事务
- en: 'With distributed systems, it is not always practical or desirable to issue
    a command as a transaction. A transaction in this context refers to a lower-level
    programming construct that manages one or more commands as a single action that
    either all succeeds or all fails. In some situations, a distributed transaction
    is not supported, or the overhead of using a distributed transaction outweighs
    the benefits. The Compensating Transaction pattern was developed to handle this
    situation. Let''s use the following as an example based on a BizTalk orchestration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，并不总是实际或理想地以事务的形式发布命令。在此上下文中，事务指的是一种低级编程结构，它将一个或多个命令作为一个单一的操作来管理，要么全部成功，要么全部失败。在某些情况下，分布式事务可能不受支持，或者使用分布式事务的开销超过了其带来的好处。补偿事务模式就是为了处理这种情况而开发的。以下是一个基于BizTalk编排的示例：
- en: '![](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
- en: 'The diagram shows two steps in a process: creating order in an Order Service
    and debiting funds from a Customer Service. The diagram shows how, first the order
    is created and then the funds are removed. If the debit of funds does not succeed
    then the order is removed from the Order Service.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了流程中的两个步骤：在订单服务中创建秩序和从客户服务中扣除资金。该图展示了首先创建订单，然后移除资金的顺序。如果资金扣除失败，则订单将从订单服务中移除。
- en: Security
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Security ensures an application does not disclose information incorrectly or
    provide functionality outside of intended use. Security includes both malicious
    and accidental actions. With cloud applications and increasing use of a wide range
    of identity providers, restricting access to only approved users is often challenging.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安全确保应用程序不会错误地披露信息或提供超出预期用途的功能。安全包括恶意和意外行为。随着云应用程序和广泛使用各种身份提供者，仅限制访问到经过批准的用户通常具有挑战性。
- en: End-user authentication and authorization requires design and planning as fewer
    applications run in isolation, and it is common for multiple identity providers,
    such as Facebook, Google, and Microsoft, to be used. In some instances, patterns
    are used to provide access directly to resources for improved performance and
    scalability. Furthermore, other patterns are concerned with creating a virtual
    wall between clients and applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户的身份验证和授权需要设计和规划，因为运行在隔离中的应用程序越来越少，并且使用多个身份提供者，如Facebook、Google和Microsoft，是很常见的。在某些情况下，使用模式可以直接访问资源以改善性能和可扩展性。此外，其他模式关注于在客户端和应用程序之间创建虚拟墙。
- en: Solution patterns
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: As the industry has become more interconnected, the pattern of using an external
    party to authenticate users has become more common. The Federated Security pattern
    has been chosen for discussion here as it is one of the best ways to ensure security
    in our systems, and most **software-as-a-service (SaaS)** platforms offer this
    feature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着行业变得更加互联互通，使用外部方进行用户认证的模式变得越来越普遍。在这里选择讨论联邦安全模式，因为它是我们系统中确保安全的最有效方法之一，并且大多数**软件即服务（SaaS**）平台都提供此功能。
- en: Federated security
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦安全
- en: Federated security delegates the authentication of user or service (consumer)
    to an external party known as an **identity provider** (**IdP**). An application
    using federated security will trust the IdP to properly authenticate the consumer
    and provide details about the consumer or claims accurately. This information
    about the consumer is presented as a token. A common scenario for this would be
    a web application using a social IdP such as Google, Facebook, or Microsoft.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦安全将用户或服务（消费者）的身份验证委托给一个称为**身份提供者（IdP**）的外部方。使用联邦安全的应用程序将信任IdP正确地验证消费者并提供关于消费者或声明的准确详情。关于消费者的这些信息以令牌的形式展示。这种场景的一个常见例子是使用社交IdP（如Google、Facebook或Microsoft）的Web应用程序。
- en: 'Federated security can handle a variety of scenarios, from interactive sessions
    to authentication backend services or non-interactive sessions. Another common
    scenario is the ability to provide a single authentication experience or **single
    sign-on** (**SSO**) across a suite of separately hosted applications. This scenario
    allows for a single token to be acquired from a **security token service** (**STS**)
    and the same token used to present to the multiple applications without requiring
    the login procedure to be repeated:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦安全可以处理各种场景，从交互式会话到身份验证后端服务或非交互式会话。另一个常见场景是能够在一系列分别托管的应用程序中提供单一的认证体验或**单点登录（SSO**）。这种场景允许从**安全令牌服务（STS**）获取单个令牌，并使用相同的令牌向多个应用程序展示，而无需重复登录过程：
- en: '![](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
- en: Federated security has two main purposes. First, it simplifies the management
    of identities by having a single identity store. This allows for identities to
    be managed in a central and unified manner, making it easier to perform management
    tasks such as providing the login experience, forgotten password management, as
    well as revoking passwords in a consistent manner. Secondly, it provides a better
    user experience by offering users a similar experience across multiple applications
    as well as requiring only a single form of authentication, instead of needing
    to remember multiple passwords.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦安全有两个主要目的。首先，它通过拥有一个单一的标识存储库来简化身份管理。这使得身份可以以集中和统一的方式管理，从而使得执行管理任务（如提供登录体验、忘记密码管理以及以一致的方式撤销密码）变得更加容易。其次，它通过在多个应用程序中提供类似体验以及只需要一种认证方式，而不是需要记住多个密码，从而提供更好的用户体验。
- en: There are several standards for federated security and two widely used ones
    are **Security Assertion Markup Language** (**SAML**) and **OpenId Connect** (**OIDC**).
    SAML is older than OIDC and allows for the exchange of messages using an XML SAML
    format. OIDC is built upon OAuth 2.0 and commonly uses **JSON Web Token** (**JWT**)
    for describing the security token. Both formats support federated security, SSO,
    and many public IdPs such as Facebook, Google, and Microsoft support both standards.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦安全有几个标准，其中两个广泛使用的是**安全断言标记语言**（**SAML**）和**OpenId Connect**（**OIDC**）。SAML比OIDC更老，允许使用XML
    SAML格式交换消息。OIDC建立在OAuth 2.0之上，通常使用**JSON Web Token**（**JWT**）来描述安全令牌。这两种格式都支持联邦安全、单点登录（SSO）以及许多公共身份提供者（IdP），如Facebook、Google和Microsoft，都支持这两种标准。
- en: Application design
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: The design of an application can vary significantly and be influenced by many
    factors. These factors are not only technical but are influenced by the teams
    involved in building, managing, and maintaining the applications. Some patterns,
    for example, work best with small dedicated teams as opposed to a larger number
    of geographically dispersed teams. Other design-related patterns handle different
    types of workload better and are used in specific scenarios. Other patterns have
    been designed around the frequency of change and how to limit the disruption of
    changes to an application once it has been released to users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的设计可以非常不同，并且可能受到许多因素的影响。这些因素不仅与技术有关，而且受到参与构建、管理和维护应用程序的团队的影响。例如，某些模式与小型专用团队配合得最好，而不是与大量地理上分散的团队配合。其他与设计相关的模式处理不同类型的负载更好，并在特定场景中使用。其他模式是围绕变更频率以及如何限制变更对已发布给用户的应用程序的干扰而设计的。
- en: Solution patterns
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: As almost all on-premises patterns are applicable to cloud-based solutions,
    the scope of patterns that could be covered is staggering. The Cache and CQRS
    patterns have been chosen because the former is a very common pattern employed
    by most web applications and the latter shifts how designers think of building
    solutions and lends itself well to other architectural patterns such as SOA and
    microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有本地模式都适用于基于云的解决方案，因此可能涵盖的模式范围令人震惊。选择缓存和CQRS模式，因为前者是大多数Web应用程序非常常见的模式，而后者改变了设计师构建解决方案的方式，并且非常适合其他架构模式，如SOA和微服务。
- en: Cache
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Storing information retrieved from slower forms of storage into faster forms
    of storage, or caching, has been a technique that has been used in programming
    for decades and can be seen in software such as a browser cache and hardware such
    as RAM. In this chapter, we will look at three examples: Cache-aside, Write-through
    Cache, and Static Content Hosting.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将从较慢的存储形式检索到的信息存储到较快的存储形式中，或称为缓存，这是一种在编程中使用了几十年的技术，可以在浏览器缓存和RAM等软件和硬件中看到。在本章中，我们将探讨三个示例：缓存旁路、写入缓存和静态内容托管。
- en: Cache-aside
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存旁路
- en: 'The Cache-aside pattern can be used to improve performance by loading frequently
    referenced data in a local or faster form of storage. With this pattern, it is
    the responsibility of the application to maintain the state of the cache. This
    is illustrated in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存旁路模式可以通过在本地或更快的存储形式中加载频繁引用的数据来提高性能。使用此模式时，维护缓存状态的责任在于应用程序。以下图示说明了这一点：
- en: '![](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
- en: First, the application requests information from the cache. If the information
    is missing, then it is requested from the data store. The application then updates
    the cache with the information. Once the information is stored, it will then be
    retrieved from the cache and used without referencing the slower data store. With
    this pattern, it is the application's responsibility to maintain the cache, both
    when there is a cache miss, and when the data is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应用程序从缓存请求信息。如果信息缺失，则从数据存储中请求。然后应用程序使用信息更新缓存。一旦信息存储，它将从缓存检索并使用，而不需要引用较慢的数据存储。使用这种模式，当发生缓存未命中或数据更新时，维护缓存是应用程序的责任。
- en: The term *cache miss* refers to when data is not found in the cache. In other
    words, it is missing from the cache.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “缓存未命中”这个术语指的是数据在缓存中找不到的情况。换句话说，它缺失在缓存中。
- en: Write-through cache
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入通过缓存
- en: 'The Write-through Cache pattern can also be used to improve performance in
    a similar manner as the Cache-aside pattern. Its approach differs by moving the
    management of the cache''s content from the application to the cache itself, as
    shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 写入通过缓存模式也可以像缓存旁路模式一样用于提高性能。其方法不同之处在于将缓存内容的管理从应用程序移动到缓存本身，如下面的图所示：
- en: '![](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
- en: A request is made for a piece of information in the cache. If the data is not
    already loaded, then the information is retrieved from the data store, placed
    in the cache, and then returned. If the data was already held, then it is immediately
    returned. This pattern supports updating the cache by passing the write of the
    information through the cache service. The cache service then updates the information
    held, both in the cache and in the data store.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对缓存中的某条信息发出请求。如果数据尚未加载，则从数据存储中检索信息，放入缓存，然后返回。如果数据已经存在，则立即返回。此模式支持通过将信息的写入传递给缓存服务来更新缓存。缓存服务随后更新缓存和数据存储中保存的信息。
- en: Static Content Hosting
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内容托管
- en: 'The Static Content Hosting pattern moves static content such as media images,
    movies, and other non-dynamic files to a system dedicated for fast retrieval.
    A specialized service for this is called a **content delivery network** (**CDN**),
    which manages to distribute content across multiple data centers and directs requests
    to the data center closest to the caller, as shown in the following diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容托管模式将如媒体图像、电影和其他非动态文件等静态内容移动到用于快速检索的系统。为此专门提供的服务称为**内容分发网络**（**CDN**），它能够将内容分布到多个数据中心，并将请求导向最接近调用者的数据中心，如下面的图所示：
- en: '![](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
- en: Static Content Hosting is a common pattern for web applications where a dynamic
    page is requested from the web application and the page contains a collection
    of static content, such as JavaScript and images, which the browser then retrieves
    directly from the CDN. This is an effective way to reduce the traffic on the web
    application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容托管是网络应用中的一种常见模式，其中从网络应用请求一个动态页面，该页面包含一系列静态内容，如JavaScript和图像，浏览器随后直接从CDN检索这些内容。这是一种有效减少网络应用流量的方法。
- en: Command and Query Responsibility Segregation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和查询责任分离
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is a great software
    pattern to discuss in more detail as it is conceptually simple and relatively
    easy to implement but has dramatic implications to both the application and the
    developers involved. The pattern clearly separates the commands that affect the
    state of the application from queries that only retrieve data. Simply put, commands
    such as updates, adds, and deletes are provided in different services from the
    queries that do not change any data.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令和查询责任分离**（**CQRS**）是一个值得详细讨论的优秀软件模式，因为它在概念上简单，相对容易实现，但对应用程序和涉及的开发者都有重大影响。该模式明确地将影响应用程序状态的操作命令与仅检索数据的查询分离。简单来说，如更新、添加和删除等命令由不同的服务提供，而查询则不改变任何数据。'
- en: You might say *CQRS again!* and we recognize that we have used an example of
    CQRS in OOP and database design. The same principle does apply to many areas of
    software development. We are presenting CQRS in this section as a pattern for
    service design as it leads to some interesting benefits and fits well in modern
    patterns such as microservices and reactive application design.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说 *再次 CQRS*！我们认识到我们已经在一个面向对象编程和数据库设计中使用了 CQRS 的例子。同样的原则也适用于软件开发的其他许多领域。我们在这个部分将
    CQRS 作为服务设计模式提出，因为它带来了一些有趣的好处，并且与现代模式如微服务和反应式应用程序设计很好地结合。
- en: 'CQRS is based on the object-oriented design presented in the late 1980s by
    Bertrand Meyer''s book, *Object-Oriented Software Construction*: [http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 基于伯特朗·迈耶在 20 世纪 80 年代后期在其著作 *面向对象软件构造* 中提出的面向对象设计：[http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/)。
- en: 'If we revisit [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml): *Implementing
    Design Patterns - .NET Core*, we illustrated this pattern by splitting our inventory
    context into two interfaces: `IInventoryReadContext` and `IInventoryWriteContext`.
    As a reminder, here are the interfaces:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾 [第 5 章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml)：*实现设计模式 - .NET Core*，我们通过将库存上下文拆分为两个接口来展示这个模式：`IInventoryReadContext`
    和 `IInventoryWriteContext`。作为提醒，以下是对接口的描述：
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the `GetBooks` method is separated from the two methods, `AddBook`
    and `UpdateQuantity`, that modify the state of the inventory. This illustrated
    CQRS within the code solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`GetBooks` 方法与修改库存状态的两种方法 `AddBook` 和 `UpdateQuantity` 分离。这展示了代码解决方案中的
    CQRS。
- en: 'The same approach can be applied at a service level. If we use a service for
    maintaining inventory as an example, we would break the service between a service
    for updating the inventory and another service for retrieving the inventory. This
    is illustrates in the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法可以在服务级别上应用。如果我们以维护库存的服务为例，我们会在更新库存的服务和检索库存的服务之间拆分服务。这在下图中展示：
- en: '![](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
- en: Let's explore CQRS first by looking at the challenges of when it is applied
    in cloud-based solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过查看在基于云的解决方案中应用 CQRS 的挑战来探索 CQRS。
- en: Challenges of CQRS
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS 的挑战
- en: 'There are significant challenges to using the CQRS pattern with services:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中使用 CQRS 模式存在重大挑战：
- en: Consistency
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Adoption
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用
- en: Staleness is a measure of how closely data reflects the committed version of
    the data. Data, in most circumstances, has the potential to change, so, as soon
    as a piece of data is read, there is a chance that the data could be updated,
    making the read data become inconsistent with the source data. This is a challenge
    with all distributed systems where it is not practical to guarantee the value
    shown to a user reflects the source value. When the data directly reflects what
    is stored, we can call the data consistent; when the data does not, it is viewed
    as inconsistent.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 陈旧性是衡量数据与提交版本的数据反映程度的一个指标。在大多数情况下，数据有改变的可能性，因此，一旦读取了一份数据，就有可能更新数据，使得读取的数据与源数据不一致。这是所有分布式系统的一个挑战，在这些系统中，保证显示给用户的值反映源值是不切实际的。当数据直接反映存储的内容时，我们可以称数据是一致的；当数据不反映时，它被视为不一致的。
- en: A common term used in distributed systems is *eventual consistency*. Eventual
    consistency is used to say a system will over time become consistent. In other
    words, it will eventually become consistent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中常用的一个术语是 *最终一致性*。最终一致性用于表示系统最终会变得一致。换句话说，它最终会变得一致。
- en: The other more subtle challenge is adoption. Implementing CQRS into an established
    development team can be met with resistance both from developers and designers
    who are unfamiliar with the pattern and may lack support from the business for
    deviating from current design patterns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更微妙挑战是采用。将 CQRS 实施到既定的开发团队中可能会遇到来自不熟悉该模式且可能缺乏业务对偏离当前设计模式支持的开发商和设计师的阻力。
- en: So what are the benefits?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些好处是什么？
- en: Why CQRS?
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 CQRS？
- en: 'The following are three compelling factors for using CQRS:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 CQRS 的三个有力因素：
- en: '**Collaboration**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**'
- en: '**Model separation**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型分离**'
- en: '**Independent scalability**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立可伸缩性**'
- en: With separate services, we can then maintain, deploy, and scale these services
    independently. This increases the level of collaboration we can achieve between
    the development teams.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过独立的服务，我们可以然后独立维护、部署和扩展这些服务。这增加了我们可以在开发团队之间实现的合作水平。
- en: By having separate services, we can use a model that best fits our service.
    The command service might use simple SQL statements directly against a database,
    as that is the most familiar technology to the team responsible, while the team
    building the query service might use a framework for handling complex statements
    against the database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有独立的服务，我们可以使用最适合我们服务模式的模型。命令服务可能直接使用简单的SQL语句对数据库进行操作，因为这是负责团队最熟悉的技术，而构建查询服务的团队可能使用框架来处理对数据库的复杂语句。
- en: Most solutions tend to have a higher level of reads than writes (or vice versa)
    so splitting the services along this criterion makes sense in many scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数解决方案的读取操作往往比写入操作多（或反之亦然），因此根据这一标准划分服务在许多场景中是有意义的。
- en: DevOps
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps
- en: With cloud-based solutions, the data center is remotely hosted and you often
    do not have full control or access to all aspects of an application. In some cases,
    such as serverless services, the infrastructure is abstracted away. An application
    must still expose information about a running application that can be used to
    manage and monitor an application. Patterns used to manage and monitor are essential
    for the success of an application by providing both the ability to keep an application
    running healthily as well as providing strategic information to the business.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于云的解决方案中，数据中心是远程托管，你通常无法完全控制或访问应用程序的所有方面。在某些情况下，例如无服务器服务，基础设施被抽象化。应用程序仍然需要暴露有关运行中的应用程序的信息，这些信息可用于管理和监控应用程序。用于管理和监控的模式对于应用程序的成功至关重要，因为它既提供了保持应用程序健康运行的能力，又为业务提供了战略信息。
- en: Solution patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: With the availability of commercial packages relating to monitoring and managing
    solutions, many businesses have gained better control and understanding of their
    distributed systems. Telemetry and continuous delivery/continuous integration
    have been chosen to cover in more detail as they have particular value in cloud-based
    solutions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着与监控和管理解决方案相关的商业软件包的可用性，许多企业已经获得了对其分布式系统更好的控制和理解。遥测和持续交付/持续集成被选择进行更详细的介绍，因为它们在基于云的解决方案中具有特殊价值。
- en: Telemetry
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遥测
- en: 'As the software industry has evolved and distributed systems involve more services
    and applications, being able to have a collective and consistent view of a system
    has become a huge asset. Popularized by services such as New Relic and Microsoft
    Application Insights, **application performance management** (**APM**) systems
    use information recorded about applications and infrastructure, known as telemetry,
    to monitor, manage performance, and view the availability of a system. In cloud-based
    solutions, where it is often not possible or practical to gain direct access to
    the infrastructure of a system, an APM allows for telemetry to be sent to a central
    service, digested, and then presented to operations and the business, as shown
    in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件行业的演变和分布式系统涉及更多服务和应用程序，能够对系统有一个集体和一致的观点已经成为一项巨大的资产。由New Relic和微软应用洞察等服务普及的**应用性能管理**（**APM**）系统使用有关应用程序和基础设施记录的信息，称为遥测，以监控、管理性能和查看系统的可用性。在基于云的解决方案中，通常无法或实际无法直接访问系统的基础设施，APM允许将遥测发送到中央服务，进行处理，然后如图所示呈现给运维和业务：
- en: '![](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
- en: The preceding diagram is taken from Microsoft Application Insights and provides
    a high-level snapshot of a running web application. At a glance, operations can
    identify changes in the behavior of the system and react accordingly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表摘自微软应用洞察，提供了一个正在运行的Web应用程序的高级快照。一眼望去，运维人员可以识别系统行为的变更并据此做出反应。
- en: Continuous integration/continuous deployment
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成/持续部署
- en: '**Continuous integration/continuous deployment** (**CI/CD**) is a modern development
    process designed to streamline the **software delivery product life cycle** (**SDLC**)
    by merging changes frequently and deploying those changes often. CI addresses
    the issues that arise in enterprise software development where multiple programmers
    are working on the same code base or when a single product is managed with multiple
    code branches.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成/持续部署**（**CI/CD**）是一种现代开发流程，旨在通过频繁合并更改和经常部署这些更改来简化**软件交付产品生命周期**（**SDLC**）。CI解决了企业级软件开发中可能出现的问题，其中多个程序员正在同一个代码库上工作，或者当单个产品使用多个代码分支管理时。'
- en: 'Take a look at the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
- en: 'In the preceding example, there are three target environments: Development,
    **User Acceptance Testing** (**UAT**), and Production. The Development environment
    is the initial environment where all the changes made to an application are tested
    together. The UAT environment is used by the **Quality Assurance** (**QA**) team
    to verify the system is working as intended before the changes are moved to a
    customer-facing environment, referred to in the diagram as Production. The code
    base has been broken into three matching branches: the trunk which all changes
    by the development team are merged into, UAT, which is used to deploy to the UAT
    environment, and the Production code base, which is used to deploy into the Production
    environment.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，有三个目标环境：开发、**用户验收测试**（**UAT**）和产品。开发环境是所有对应用程序所做的更改一起测试的初始环境。UAT环境由**质量保证**（**QA**）团队使用，以验证系统在更改移动到面向客户的环境（在图中称为产品）之前按预期工作。代码库已被分成三个匹配的分支：主干，所有开发团队的更改都合并到其中；UAT，用于部署到UAT环境；以及产品代码库，用于部署到产品环境。
- en: The CI pattern is applied by creating a new build when the code base changes.
    After a successful build, a suite of unit tests is run against the build to ensure
    existing functionality has not been broken. If a build is not successful, the
    development team investigates and either fixes the code base or the unit test
    so the build then passes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: CI模式通过在代码库更改时创建新的构建来应用。在构建成功后，会运行一系列单元测试来确保现有功能没有被破坏。如果构建不成功，开发团队将进行调查，并修复代码库或单元测试，以便构建通过。
- en: Successful builds are then pushed to a target environment. The Trunk might be
    set to push a new build automatically once a day to the Integration environment,
    while the QA team has requested less disturbance in the environment, so a new
    build is only pushed once a week after office hours. Production might require
    a manual trigger to coordinate new releases as to announce the new features and
    bug fixes in a formal release.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将成功的构建推送到目标环境。主干可能被设置为每天自动将新构建推送到集成环境，而QA团队要求减少对环境的干扰，因此新构建仅在下班后每周推送一次。产品可能需要手动触发来协调新版本发布，以便正式发布中宣布新功能和错误修复。
- en: There is confusion over the terms *continuous deployment* and *continuous delivery*.
    Many sources differentiate the two terms as to whether the process of deploying
    is automated or manual. In other words, continuous deployment requires automated
    continuous delivery.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**持续部署**和**持续交付**这两个术语存在混淆。许多资料将这两个术语区分开来，以确定部署过程是自动的还是手动的。换句话说，持续部署需要自动化的持续交付。
- en: The trigger to cause a merge between environments and therefore a build to be
    pushed to an environment, or released, might differ. In our illustration for the
    Development environment, we have a set of automated tests that are run against
    new builds automatically. If the tests are successful, then the merge is automatically
    performed from the Trunk to the UAT code base. The merge between UAT and Production
    code bases is only performed once the QA team has signed off or accepted the changes
    in the UAT environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 导致环境合并并因此将构建推送到环境或发布的触发器可能不同。在我们的开发环境示例中，我们有一套针对新构建自动运行的自动化测试。如果测试成功，则从主干分支自动合并到UAT代码库。UAT和产品代码库之间的合并只有在QA团队签署或接受UAT环境中的更改后才会进行。
- en: Each enterprise will tailor the CI/CD process to fit their particular SDLC and
    business requirements. A public-facing website, for example, might require a rapid
    SDLC to stay competitive in the market, whereas an internal application might
    require a more conservative approach to limit the disruption caused by changing
    functionality without staff training.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个企业都会根据其特定的SDLC和业务需求定制CI/CD流程。例如，一个面向公众的网站可能需要一个快速的SDLC来在市场上保持竞争力，而一个内部应用程序可能需要一个更保守的方法来限制由于功能更改而造成的干扰，同时不需要员工培训。
- en: Regardless, suites of tools have been developed to manage the CI/CD process
    within an organization. Azure DevOps, for example, helps to manage this process
    by allowing for a pipeline to be built to handle when builds are created and when
    they are released to environments, including both manual and automated triggers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，已经开发了一系列工具来管理组织内部的CI/CD流程。例如，Azure DevOps通过允许构建管道来处理构建创建和发布到环境（包括手动和自动触发）的过程，从而帮助管理这一流程。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Cloud development requires careful planning, maintenance, and monitoring, and
    patterns can help achieve highly scalable, reliable, and secure solutions. Many
    of the patterns discussed in this chapter are applicable to on-premises applications
    and are essential in cloud solutions. The design of a cloud-first application
    should consider many factors, including scalability, availability, maintenance,
    monitoring, and security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 云开发需要仔细规划、维护和监控，模式可以帮助实现高度可扩展、可靠和安全的解决方案。本章讨论的许多模式适用于本地应用程序，并在云解决方案中至关重要。云优先应用程序的设计应考虑许多因素，包括可扩展性、可用性、维护、监控和安全。
- en: A scalable application allows for fluctuations in system load while maintaining
    an acceptable level of performance. The load can be measured in the number of
    users, concurrent processes, amount of data, and other factors in software. The
    ability to scale a solution horizontally requires a particular type of application
    development and is a paradigm that is especially significant to cloud computing.
    Patterns such as Queue-Based Load Leveling are a great technique to ensure solutions
    remain responsive under an increased load.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的应用程序允许系统负载在波动的同时保持可接受的性能水平。负载可以通过用户数量、并发进程、数据量以及软件中的其他因素来衡量。能够水平扩展解决方案需要特定类型的应用程序开发，并且这种范式对于云计算特别重要。例如，基于队列的负载均衡模式是一种确保在增加负载下解决方案保持响应性的优秀技术。
- en: Many of the patterns covered in this chapter are complementary. For example,
    an application following the Command and Query Responsibility Segregation might
    leverage federated security for providing a single sign-on experience and use
    an event-driven architecture to handle consistency across the different components
    of an application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的许多模式都是互补的。例如，遵循命令和查询责任分离的应用程序可能会利用联邦安全来提供单一登录体验，并使用事件驱动架构来处理应用程序不同组件之间的一致性。
- en: In cloud-based solutions, there is a near-endless collection of applicable patterns
    that address different challenges in distributed systems. The patterns presented
    in this chapter represent a selection chosen for their breadth, as well as how
    they complement one another. Please see the references to explore other patterns
    suitable in cloud-based solutions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于云的解决方案中，存在几乎无限的适用模式集合，这些模式针对分布式系统中的不同挑战。本章中展示的模式是根据它们的广度和相互补充性选择的。请参阅参考文献以探索其他适用于基于云解决方案的模式。
- en: What a journey! We have covered patterns from software design patterns used
    in object-oriented programming and architectural patterns used in cloud-based
    solutions, to business patterns for more efficient teams and patterns for building
    successful applications. Though we tried to cover a wide range of patterns, there
    are bound to be ones that could have, and should have, been added.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 多么精彩的旅程！我们涵盖了从面向对象编程中使用的软件设计模式到基于云解决方案中使用的架构模式，再到更高效团队的业务模式和构建成功应用程序的模式。尽管我们试图涵盖广泛的模式，但肯定有一些模式本可以，也应该被添加。
- en: With that, thank you from Gaurav and Jeffrey and we hope you enjoyed and gained
    something from reading *Hands-On Design Patterns with C# and .NET Core*. Please
    let us know what you think and share with us your favorite patterns.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，感谢Gaurav和Jeffrey，并希望您在阅读《动手实践C#和.NET Core设计模式》时有所收获。请告诉我们您的想法，并与我们分享您最喜欢的模式。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: Most patterns have been developed recently and only apply to cloud-based applications.
    True or false?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数模式都是最近开发的，并且仅适用于基于云的应用程序。这是真的还是假的？
- en: 'An ESB stands for what, and can be used in what type of architecture: EDA,
    SOA or monolithic?'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ESB代表什么，可以在哪种类型的架构中使用：EDA、SOA还是单体？
- en: Is Queue-Based Load Leveling primarily used for DevOps, scalability, or availability?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于队列的负载均衡主要用于DevOps、可扩展性还是可用性？
- en: What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD的好处是什么？它对大量全球分散的团队或单个小型本地化开发团队更有益吗？
- en: In a website following Static Content Hosting, does a browser retrieve images
    and static content directly through a CDN, or does the web application retrieve
    the information on behalf of the browser?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遵循静态内容托管的网站上，浏览器是直接通过CDN检索图像和静态内容，还是由Web应用程序代表浏览器检索信息？
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, refer to the following
    books. These books will provide you with various in-depth and hands-on exercises
    on the topics that have been covered in this chapter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涵盖的主题，请参考以下书籍。这些书籍将为您提供关于本章已涵盖主题的各种深入和实战练习：
- en: '*Azure Serverless Computing Cookbook,* by *Praveen Kumar Sreeram,* published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Azure无服务器计算食谱》，作者* *Praveen Kumar Sreeram*，由* *Packt Publishing* *出版*：[https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
- en: '*Microservices with Azure,* by *Namit Tanasseri* *and Rahul Rai*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Azure的微服务》，作者* *Namit Tanasseri* *和* *Rahul Rai*，由* *Packt Publishing*
    *出版*：[https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
- en: '*Hands-On Azure for Developers,* by *Kamil Mrzygłód,* published by *Packt Publishing*:
    [https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《开发者实战Azure》，作者* *Kamil Mrzygłód*，由* *Packt Publishing* *出版*：[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
- en: '*Building Microservices with .NET Core 2.0 - Second Edition* by *Gaurav Aroraa*,
    published by *Packt Publishing*: [https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用.NET Core 2.0构建微服务 - 第二版》，作者* *Gaurav Aroraa*，由* *Packt Publishing* *出版*：[https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition)。'
