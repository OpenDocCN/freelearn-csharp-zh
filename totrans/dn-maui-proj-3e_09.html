<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor854"/>9</h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor855"/>Setting Up a Backend for a Game Using Azure Services</h1>
<p>In this chapter, we will set up a backend for a game app with real-time communication. We will not only create a backend that can scale up to handle a large number of users but also scale down when the number of users is reduced. To build that backend, we will use a serverless <a id="_idIndexMarker879"/>architecture based on services in <strong class="bold">Microsoft Azure</strong>.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the different Azure serverless services</li>
<li>Creating a <strong class="bold">SignalR</strong> service in Microsoft Azure</li>
<li>Using Azure Functions as an <strong class="bold">application programming </strong><strong class="bold">interface</strong> (<strong class="bold">API</strong>)</li>
</ul>
<h1 id="_idParaDest-151"><a id="_idTextAnchor856"/>Technical requirements</h1>
<p>To be able to complete this project, you need to have Visual Studio for Mac or PC installed, as well as the necessary .NET MAUI components. See <em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment.</p>
<p>You also need an Azure account. If you have a Visual Studio subscription, there are a specific amount of Azure credits included each month. To activate your Azure benefits, go to <a href="https://my.visualstudio.com">https://my.visualstudio.com</a>.</p>
<p>You can also create a free account, where you can use selected services for free over 12 months. You will get $200 worth of credit to explore any Azure service for 30 days, and you can also use the free services at any time. Read more at <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a>.</p>
<p>If you do not have and do not want to sign up for a free Azure account, you can use local development tools to run the services without Azure.</p>
<p>You can find the full source for the code in this chapter at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition</a>.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor857"/>Project overview</h1>
<p>The main aim of this project will be to set up the backend for a game. A large part of the project will be the configuration that we will carry out in the Azure portal. We will also write some code for the Azure functions that will handle the SignalR connections and a bit of the game logic and state. SignalR is a library that makes real-time communication in applications easier. Azure SignalR is a service that makes it easier to connect multiple clients to send messages via the SignalR library. SignalR is described in more detail later. There will be functions to return information about the SignalR connection, manage matching players to play against each other, and post the result of each player’s turn to the SignalR service. </p>
<p>The following diagram shows an overview of the architecture of this application:</p>
<div><div><img alt="" role="presentation" src="img/B19214_09_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Application architecture</p>
<p>The estimated time to complete this part of the project is about 2 hours.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor858"/>An overview of the game</h2>
<p><em class="italic">Sticks &amp; Stones</em> is a turn-based social game based on the concepts of two childhood games mashed into one, Dots and Boxes and Tic-Tac-Toe. The game board is laid out in a 9x9 grid. Each player will take a turn placing a stick along the side of a box, earning one point. If a stick <a id="_idIndexMarker880"/>completes a box, then the player takes ownership of the box, earning five points. The game is won when a player owns three boxes in a row, horizontally, vertically, or diagonally. If no player can own three boxes in a row, the winner of the game is determined by the player with the highest score.</p>
<p>To keep the app and the service side relatively simple, we will eliminate a lot of state management. When the player opens the app, they will have to connect to the game service. They will have to provide a gamer tag or username and an email address. Optionally, they can upload a picture of themselves to use as a profile picture.</p>
<p>Once connected, the player will see a list of all the other players connected to the same game service; this is called the lobby. The player’s status, either “Ready to play” or “In a match,” will be displayed along with the player’s gamer tag and profile picture. If the player is not in a match, then there will also be a button to challenge the player to a match.</p>
<p>Challenging a player to a match will cause the app to prompt the opponent to respond to the challenge, either accept or decline. If the opponent accepts the challenge, then both players are navigated to a new game board where the player who received the challenge will have the first turn. Both players’ statuses will update to “In a match” in all the other players’ lobbies. Play will alternate between players as they choose a location to place a single stick. Each time a stick is placed by a player, the game board and score will update on both players’ devices. When a stick is placed that completes one or more squares, the player then “owns” that square, and a pile of stones is placed in the center of the square. When all <a id="_idIndexMarker881"/>sticks have been placed, or a player owns three stones in a row, the game is over, the players navigate back to the lobby, and their status is updated to “Ready to play.”</p>
<p>If a player leaves the app during a game, then they will have forfeited the game and the remaining opponent will be credited with the win and navigated back to the lobby.</p>
<p>The following screenshot should give you an idea of what the app will look like when it’s completed in <em class="italic">Chapter 10</em>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 9.2 – The main game screens" src="img/B19214_09_2_Merged.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The main game screens</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor859"/>Understanding the different Azure serverless services</h1>
<p>Before we start to build a backend with a serverless architecture, we need to define what <strong class="bold">serverless</strong> means. In a serverless architecture, the code will run on a server, but we don’t need <a id="_idIndexMarker882"/>to worry about that; the only thing we need to focus on is building our software. We let someone else handle everything to do with servers. We don’t need to think about how much memory or <strong class="bold">central processing units</strong> (<strong class="bold">CPUs</strong>) the server needs, or even how many servers we need. When we use services in Azure, Microsoft takes care of this for us.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor860"/>Azure SignalR Service</h2>
<p><strong class="bold">Azure SignalR Service</strong> is a service in <strong class="bold">Microsoft Azure</strong> for real-time communication between a <a id="_idIndexMarker883"/>server and clients. The service will push content to the clients without them having to poll the server to get content updates. SignalR can <a id="_idIndexMarker884"/>be used for multiple types of applications, including mobile applications, web applications, and desktop applications.</p>
<p>SignalR will use <strong class="bold">WebSockets</strong> if that <a id="_idIndexMarker885"/>option is available. If it is not, SignalR <a id="_idIndexMarker886"/>will use other techniques for communication, such as <strong class="bold">Server-Sent Events</strong> (<strong class="bold">SSEs</strong>) or <strong class="bold">long polling</strong>. SignalR will detect which transport technology <a id="_idIndexMarker887"/>is available and use it without the developer having to think about it at all.</p>
<p>SignalR can <a id="_idIndexMarker888"/>be used in the following examples:</p>
<ul>
<li><strong class="bold">Chat applications</strong>: Where the application requires updates from the server as soon as new messages are available</li>
<li><strong class="bold">Collaborative applications</strong>: For example, meeting applications or when users on multiple devices are working with the same document</li>
<li><strong class="bold">Multiplayer games</strong>: Where all users need live updates about other users</li>
<li><strong class="bold">Dashboard applications</strong>: Where users need live updates</li>
</ul>
<h2 id="_idParaDest-156"><a id="_idTextAnchor861"/>Azure Functions</h2>
<p>Azure Functions is a Microsoft Azure service that allows us to run code in a serverless way. We will deploy <a id="_idIndexMarker889"/>small pieces of <a id="_idIndexMarker890"/>code called <strong class="bold">functions</strong>. Functions are deployed <a id="_idIndexMarker891"/>in groups, called <strong class="bold">function apps</strong>. When we are creating a function app, we need to select whether we want it to run on a Consumption plan or an App Service plan. We select a Consumption plan if we want the application to be completely serverless, while with an App Service plan, we have to specify <a id="_idIndexMarker892"/>the requirements of the server. With a Consumption plan, we pay for the execution time and for how much memory the function uses. One benefit of an App Service plan is that you can configure it to be <strong class="bold">Always-On</strong>, and you won’t have any cold starts, so long as you don’t have to scale up to more instances. The big benefit of a Consumption plan is that it will always scale according to which resources are needed at that time.</p>
<p>There are several ways in which a function can be triggered to run. Two examples are <code>HttpTrigger</code> and <code>TimeTrigger</code>. <code>HttpTrigger</code> will trigger the function to run when an HTTP request is calling the function. With <code>TimeTrigger</code>, functions will run at an interval that we specify. There are also triggers for other Azure services. For example, we can configure a function to run when a file is uploaded to Azure Blob storage, when a new message is posted to an event hub or service bus, or when data is changed in an Azure Cosmos DB service.</p>
<p>Now that we understand what features Azure SignalR Service and Functions offer, let’s use them to build our game backend.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor862"/>Building the serverless backend</h1>
<p>In this section, we will <a id="_idIndexMarker893"/>set up the backend based on the services described in the preceding section.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor863"/>Creating a SignalR service</h2>
<p>The first <a id="_idIndexMarker894"/>service that we will set up is the one for SignalR. To create such a service, proceed as follows:</p>
<ol>
<li>Go to the Azure portal at <a href="https://portal.azure.com">https://portal.azure.com</a>.</li>
<li>Create a <a id="_idIndexMarker895"/>new resource. The <strong class="bold">SignalR Service</strong> resource is in the <strong class="bold">Web &amp; </strong><strong class="bold">Mobile</strong> category.</li>
<li>Provide a name for the resource in the form.</li>
<li>Select the subscription you want to use for this project.<p class="list-inset">We recommend that you create a new <strong class="bold">Resource group</strong> and use it for all the resources that we will create for this project. The reason that we want one resource group is that it is easier to track which resources are related to this project, and it is also easier to delete all the resources together.</p></li>
<li>Select a location that is close to your users.</li>
<li>Select a pricing tier. For this project, we will use the <strong class="bold">Free</strong> tier. We can always use the <strong class="bold">Free</strong> tier for development and later scale up to a tier that can handle more connections.</li>
<li>Set <strong class="bold">Service mode</strong> to <strong class="bold">Serverless</strong>.</li>
<li>Click <strong class="bold">Review + create</strong> to review the settings before creating the SignalR service.</li>
<li>Click <strong class="bold">Create</strong> to create the storage account.</li>
</ol>
<p>Refer to the following screenshot to view the preceding information:</p>
<div><div><img alt="Figure 9.3 – Creating the SignalR service" src="img/B19214_09_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Creating the SignalR service</p>
<p>This is all <a id="_idIndexMarker896"/>we need to do to set up a SignalR service. We will return to it in the Azure portal later to grab a connection string to it.</p>
<p>The next step <a id="_idIndexMarker897"/>is to set up a storage account in which we can store the images that are uploaded by the users.</p>
<p>With the Computer Vision service created, we can now create the Azure Functions service, which will run our game logic and use SignalR, Blob storage, and Cognitive Services, which we just created.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor864"/>Using Azure Functions as an API</h2>
<p>All the <a id="_idIndexMarker898"/>code we will write for the backend will <a id="_idIndexMarker899"/>be in Azure Functions. We will use a Visual Studio project to write, debug, and deploy our functions. Before we create the project, we will have to set up and configure the Azure Functions service. Then, we will implement the function to connect the player to the game and provide the client with a list of current players. Next, we will write the functions that allow one player to challenge <a id="_idIndexMarker900"/>another to a game. Finally, we will <a id="_idIndexMarker901"/>wrap up by writing the function that allows players to take turns placing sticks on the board.</p>
<p>Let’s begin by creating the Azure Functions service.</p>
<h3>Creating the Azure Functions service</h3>
<p>Before we <a id="_idIndexMarker902"/>write any code, we will create the function app. This will contain the functions in the Azure portal. Proceed as follows:</p>
<ol>
<li>Create a new <strong class="bold">Function App</strong> resource. <strong class="bold">Function App</strong> can be found under the <strong class="bold">Compute</strong> category.</li>
<li>Select a subscription for the function app.</li>
<li>Select a resource group for the function app. This should be the same as the other resources we have created in this chapter.</li>
<li>Give the function app a name. The name will also be the start of the URL of the function.</li>
<li>Select <strong class="bold">Code</strong> as the deployment mechanism.</li>
<li>Select <strong class="bold">.NET</strong> as the runtime stack for the functions.</li>
<li>Select <strong class="bold">.NET 6.0 (Long Term Support)</strong> for the version.</li>
<li>Select a location that is closest to your users.</li>
<li>Select <strong class="bold">Windows</strong> for <strong class="bold">Operating System</strong>.</li>
<li>We will use the <strong class="bold">Consumption</strong> plan as our <strong class="bold">Hosting</strong> plan, so we’ll only pay for what we use. <strong class="bold">Function app</strong> will scale both up and down according to our requirements – without us having to think about it at all – if we select a <strong class="bold">Consumption</strong> plan.<p class="list-inset">Refer to the following screenshot to view the preceding information:</p></li>
</ol>
<div><div><img alt="Figur﻿e 9.4 – Create Function App – Basics" src="img/B19214_09_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Create Function App – Basics</p>
<ol>
<li value="11">Click <strong class="bold">Review + create</strong> to review the settings before creating the function app.</li>
<li>Click <strong class="bold">Create</strong> to create the function app.</li>
</ol>
<h3>Creating the projects</h3>
<p>If you want, you can create functions in the Azure portal. I prefer to use Visual Studio, however, because <a id="_idIndexMarker903"/>the code editing experience is better, and you can use source control. For this project, we will need to separate projects as part of our solution – an Azure Functions project and a class library for shared code between the functions and the .NET MAUI app that will be built in <em class="italic">Chapter 10</em>. To create and configure the projects, proceed as follows:</p>
<ol>
<li>Create a new project in Visual Studio.</li>
<li>Enter <code>function</code> in the search field to find the template for Azure Functions.</li>
<li>Click the <strong class="bold">Azure Functions</strong> template to continue, as illustrated in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 9.5 – Create a new project" src="img/B19214_09_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Create a new project</p>
<ol>
<li value="4">Name the project <code>SticksAndStones.Functions</code>.</li>
<li>Name the <a id="_idIndexMarker904"/>solution <code>SticksAndStones.Functions</code>, as illustrated in the following screenshot, and click <strong class="bold">Next</strong>:</li>
</ol>
<div><div><img alt="Figu﻿re 9.6 – Configure your new project" src="img/B19214_09_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Configure your new project</p>
<p>The next step is to create our first function, as follows:</p>
<ol>
<li>Select <strong class="bold">.Net 6.0 (Long Term Support)</strong> for <strong class="bold">Functions worker</strong> at the top of the dialog box.</li>
<li>Select <strong class="bold">Http trigger</strong> as the trigger for our first function.</li>
<li>Click <strong class="bold">Create</strong> to continue; our functions project will be created.</li>
</ol>
<p>Refer to <a id="_idIndexMarker905"/>the following screenshot to view the preceding information:</p>
<div><div><img alt="Figure 9.7 – Creating a new Azure Functions application – Additional information" src="img/B19214_09_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Creating a new Azure Functions application – Additional information</p>
<p>Our first function will return the connection information for the SignalR service. To do that, we need to connect the function by adding a connection string to the SignalR service, as follows:</p>
<ol>
<li>Go to the <strong class="bold">SignalR Service</strong> resource in the Azure portal.</li>
<li>Go to the <strong class="bold">Keys</strong> tab on the left and copy the connection string.</li>
<li>Go to the <code>AzureSignalRConnectionString</code> as the name for the setting.</li>
<li>Add the <a id="_idIndexMarker906"/>connection string to the <code>local.settings.json</code> file in the Visual Studio project to be able to run the function locally on the development machine, as illustrated in the following code block:<pre class="source-code">
{  "IsEncrypted": false,  "Values": {    "AzureWebJobsStorage": "UseDevelopmentStorage=true",    "FUNCTIONS_WORKER_RUNTIME": "dotnet",    "AzureSignalRConnectionString": "<code>SticksAndStones.Functions</code> project, and add the code listed previously with your connection string.</p></li> </ol>
<p>Next, in the <code>SticksAndStones.Functions</code> project, we need to reference the <code>Microsoft.Azure.WebJobs.Extensions.SignalRService</code> NuGet package. This package contains the classes we need to communicate with the SignalR service. If an error occurs during this and you are not able to install the package, make sure that you have the latest version of all other packages in the project and try again.</p>
<p>The last change we need to make is to adjust the automatic namespace generation. By default, the default namespace is the name of the project, which means all types in this project would have a root namespace of <code>SticksAndStones.Functions</code>. We don’t need the <code>Functions</code> part of that, so let’s remove it:</p>
<ol>
<li>Right-click the <code>SticksAndStones.Functions</code> project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong>.</li>
<li>In the <code>Default namespace</code>.</li>
<li>Change the <code>$(MSBuildProjectName.Split(".")[0].Replace(" ", "</code><code>_"))</code>.<p class="list-inset">This will split the project name on <code>.</code>, using only the first part and replacing any spaces with underscores.</p></li>
</ol>
<p>Now, when we <a id="_idIndexMarker907"/>create a new class, the namespace will start with just <code>SticksAndStones</code>. It’s time to create a shared project so that we can reuse code in both the .NET MAUI client and the Azure Functions service.</p>
<p>The shared code will go into a class library project. To create the project and reference it from the <code>SticksAndStones.Functions</code> project, follow these steps:</p>
<ol>
<li>Right-click on the <code>SticksAndStones</code> solution node in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong>, then <strong class="bold">New Project</strong>.</li>
<li>Search for <code>Class Library</code> in the <strong class="bold">Add a new project</strong> dialog box, as shown here:</li>
</ol>
<div><div><img alt="Figure 9.8 – Add a new project" src="img/B19214_09_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Add a new project</p>
<ol>
<li value="3">Select <a id="_idIndexMarker908"/>the <strong class="bold">Class Library</strong> template, then click <strong class="bold">Next</strong>.</li>
<li>In the <code>StickAndStones.Shared</code> for the name, as shown in the following screenshot, and click <strong class="bold">Next</strong>:</li>
</ol>
<div><div><img alt="Figure 9.9 – Configure your new project" src="img/B19214_09_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Configure your new project</p>
<ol>
<li value="5">Select the <strong class="bold">.NET 6.0 (Long Term Support)</strong> framework project in the <strong class="bold">Additional information</strong> dialog, then click <strong class="bold">Create</strong>.</li>
<li>Delete the <code>Class1.cs</code> file that is created as part of the project template.</li>
<li>Add a reference to <code>SticksAndStones.Shared</code> in the <code>SticksAndStones.Functions</code> project.</li>
</ol>
<p>As we did <a id="_idIndexMarker909"/>for the <code>SticksAndStones.Functions</code> project, we will change the default namespace by following these steps:</p>
<ol>
<li>Right-click the <code>SticksAndStones.Functions</code> project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong>.</li>
<li>In the <code>Default namespace</code>.</li>
<li>Change the <code>$(MSBuildProjectName.Split(".")[0].Replace(" ", "</code><code>_"))</code>.<p class="list-inset">This will <a id="_idIndexMarker910"/>split the project name on <code>.</code>, using only the first part and replacing any spaces with underscores.</p></li>
</ol>
<p>Now, we can write the code for the function that will return the connection information.</p>
<h3>Connecting a player to the game</h3>
<p>The first step in the game is to get connected. Being connected adds you to the list of available <a id="_idIndexMarker911"/>players so that you or other players can then join a game. As we have done in other projects in this book, first, we will create the models that we need to store or transfer data between the service and the clients. Then, we will implement the <code>Connect</code> function itself.</p>
<h3>Creating the models</h3>
<p>We will need a few functions for the app in <em class="italic">Chapter 10</em> to call during the life cycle of the app. The first <a id="_idIndexMarker912"/>is to establish a connection with the game services, called <code>Connect</code>. Essentially, this tells the service that a new or existing player is active and ready for play. The <code>Connect</code> function will register the player details and return the connection string to the SignalR hub so that the app can receive messages. We will need a few models before we can complete the function. There needs to be a <code>Player</code> model, a <code>Game</code> model, and models to assist with passing data between Azure Functions and the SignalR service to the app.</p>
<p>Before we dive into creating the library, we should discuss the naming convention used in this chapter. Having a convention for how you name things will make it easier to determine how the class is used. When the app calls any Azure function, if it needs to send any data, it will do so using a class that has a suffix of <code>-Request</code>, and any Azure function that returns data will do so using a class that ends with <code>-Response</code>. For any data that is sent via the SignalR hub, we will use a class that has an <code>EventArgs</code> suffix. These classes will contain references to our actual models, and just act as a container for the data. Having these classes in place means that you can modify the data being sent or received without affecting the models themselves.</p>
<p>Since this is a two-player game, we need to track a little bit of the state so that we know who is online and what matches are in play. For this project, we will keep the state simple and not involve an actual database, but we will still use Entity Framework to do most of the work for us.</p>
<p>Now that we have <a id="_idIndexMarker913"/>created and referenced the new project, and we have a naming convention in place, we can start creating the classes we will need. We will start with the two models, <code>Player</code> and <code>Match</code>. <code>Player</code> represents each person, while <code>Game</code> is a match between two <code>Player instances</code> and the state of play. To create the two models, follow these steps:</p>
<ol>
<li>Create a new folder in the <code>SticksAndStones.Shared</code> project called <code>Models</code>.</li>
<li>Create a new class in the <code>Models</code> folder called <code>Player</code>.</li>
<li>Create a <code>public</code> property in the <code>Player</code> class called <code>Id</code> as <code>Guid</code> and initialize it to <code>Guid.Empty</code>.</li>
<li>Create another <code>public</code> property called <code>GamerTag</code> as <code>string</code> and initialize it to <code>string.Empty</code>.</li>
<li>Create a <code>public</code> property named <code>GameId</code> as <code>Guid</code> and initialize it to <code>Guid.Empty</code>.</li>
<li>Your <code>Player</code> class should now resemble the following code block:<pre class="source-code">
namespace SticksAndStones.Models;public class Player {    public Guid Id { get; set; } = Guid.Empty;    public string GamerTag { get; set; } = string.Empty;    public string EmailAddress { get; set; } = string.Empty;    public Guid MatchId { get; set; } = Guid.Empty;}</pre></li> </ol>
<p>Our model classes <a id="_idIndexMarker914"/>will use the <code>Id</code> field as a unique identifier so that we can locate each one individually. It will be used to locate specific players for messaging and relating <code>Match</code> instances to <code>Player</code> instances. <code>GamerTag</code> will be the display name for the player, and <code>EmailAddress</code> is how we can correlate players if they leave the app and then log back in again. Finally, the <code>MatchId</code> property will track whether the player is actively in a game.</p>
<p>Now that we have defined the <code>Player</code> class, it’s time to define the <code>Match</code> class:</p>
<ol>
<li>Create a new class in the <code>Models</code> folder called <code>Match</code>.</li>
<li>Create a <code>public</code> property in the <code>Game</code> class called <code>Id</code> as <code>Guid</code> and initialize it to <code>Guid.Empty</code>.</li>
<li>Create a <code>public</code> property called <code>PlayerOneId</code> as <code>Guid</code>.</li>
<li>Add a <code>public</code> property named <code>PlayerOneScore</code> as <code>int</code>.</li>
<li>Create another <code>public</code> property called <code>PlayerTwoId</code> as <code>Guid</code>.</li>
<li>Add a <code>public</code> property named <code>PlayerTwoScore</code> as <code>int</code>.</li>
<li>Create a <code>public</code> property called <code>NextPlayerId</code> as <code>Guid</code>.</li>
<li>Create a <code>public</code> property called <code>Sticks</code> as <code>List&lt;int&gt;</code> and initialize it to <code>new List&lt;int&gt;(24)</code>.</li>
<li>Create a <code>public</code> property called <code>Stones</code> as <code>List&lt;int&gt;</code> and initialize it to <code>new List&lt;int&gt;(9)</code>.</li>
<li>Create a <code>public</code> property called <code>Scores</code> as <code>List&lt;int&gt;</code> and initialize it to <code>new List&lt;int&gt;(2)</code>.</li>
<li>Create a <code>public</code> property called <code>Completed</code> as <code>bool</code> and initialize it to <code>false</code>.</li>
<li>Create a <code>public</code> property called <code>WinnerId</code> as <code>Guid</code> and initialize it to <code>Guid.Empty</code>.</li>
<li>Add a <code>public</code> <code>static</code> method named <code>New</code> that takes two parameters, both of the <code>Guid</code> type, called <code>challengerId</code> and <code>opponentId</code>. The method returns an <a id="_idIndexMarker915"/>object of the <code>Game</code> type. The method should return a new instance of <code>Game</code> and assign the <code>Id</code> property to <code>Guid.NewGuid()</code>, <code>PlayerOneId</code> and <code>NextPlayerId</code> to <code>opponentId</code>, and <code>PlayerTwoId</code> to <code>challengerId</code>.</li>
<li>The <code>Player</code> class should now resemble the following code block:<pre class="source-code">
using System;using System.Collections.Generic;namespace SticksAndStones.Models;public class Match {    public Guid Id { get; set; } = Guid.Empty;    public Guid PlayerOneId { get; set; }    public int PlayerOneScore { get; set; }    public Guid PlayerTwoId { get; set; }    public int PlayerTwoScore { get; set; }    public Guid NextPlayerId { get; set; }    public List&lt;int&gt; Sticks {get; set; } = new(new int[24]);    public List&lt;int&gt; Stones {get; set;} = new(new int[9]);    public List&lt;int&gt; Score = new(new int[2]);    public bool Completed { get; set; } = false;    public Guid WinnerId { get; set; } = Guid.Empty;    public static Game New(Guid challengerId, Guid opponentId)    {        return new()        {            Id = Guid.NewGuid(),            PlayerOne = opponent,            PlayerTwo = challenger,            NextPlayer = opponent         };    }}</pre></li> </ol>
<p>The <code>Player</code> and <code>Match</code> classes will be used for data storage and data transfer between the client and server. Before we go any further with creating our models, let’s add the database using <a id="_idIndexMarker916"/>Entity Framework. Perform the following steps to add a reference to Entity Framework and create the database context so that the <code>Player</code> and <code>Match</code> classes can be stored in an <code>InMemory</code> database:</p>
<ol>
<li>Add a package reference to <code>Microsoft.EntityFrameworkCore.InMemory</code> to the <code>SticksAndStones.Functions</code> project.</li>
<li>Create a new folder called <code>Repository</code> in the <code>SticksAndStones.Functions</code> project.</li>
<li>Create a class named <code>GameDbContext</code> in the <code>Repository</code> folder.</li>
<li>Modify the constructor for the class to set database options:<pre class="source-code">
public GameDbContext(DbContextOptions&lt;GameDbContext&gt; options) : base(options) { }</pre></li> <li>Add a public <code>Players</code> property to store the <code>Player</code> objects:<pre class="source-code">
public DbSet&lt;Player&gt; Players { get; set; }</pre></li> <li>Add a public <code>Matches</code> property to store the <code>Match</code> objects:<pre class="source-code">
public DbSet&lt;Match Matches { get; set; }</pre></li> <li>Add an <a id="_idIndexMarker917"/>override to the <code>OnModelCreating</code> method:<pre class="source-code">
protected override void OnModelCreating(ModelBuilder modelBuilder){}</pre><p class="list-inset">This method is where we specify to Entity Framework how to relate our classes together in a relational database.</p></li> <li>Start by declaring the identifiers for each class in the <code>OnModelCreating</code> method, as shown here:<pre class="source-code">
modelBuilder.Entity&lt;Player&gt;()    .HasKey&lt;Player&gt;(p =&gt; p.Id);modelBuilder.Entity&lt;Match&gt;()    .HasKey&lt;Match&gt;(g =&gt; g.Id);base.OnModelCreating(modelBuilder);</pre></li> <li>Entity Framework does not handle our <code>List&lt;int&gt;</code> properties properly. It assumes that since it is a list, they are related instances. To change the default behavior in Entity Framework, we can use the following highlighted code:<pre class="source-code">
modelBuilder.Entity&lt;Game&gt;()    .HasKey(g =&gt; g.Id);<strong class="bold">modelBuilder.Entity&lt;</strong><strong class="bold">Match</strong><strong class="bold">&gt;()</strong>    <strong class="bold">.Property(p =&gt; p.Sticks)</strong>    <strong class="bold">.HasConversion(    </strong>    <strong class="bold">toDb =&gt; string.Join(",", toDb),    </strong>    <strong class="bold">fromDb =&gt; fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? new(new int[24]));</strong>
<strong class="bold">modelBuilder.Entity&lt;Match&gt;()</strong>    <strong class="bold">.Property(p =&gt; p.Stones)</strong>    <strong class="bold">.HasConversion(    </strong>    <strong class="bold">toDb =&gt; string.Join(",", toDb),    </strong>    <strong class="bold">fromDb =&gt; fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? new(new int[9]));</strong>
base.OnModelCreating(modelBuilder);</pre><p class="list-inset">What each block does is define a conversion for the property. A conversion has two Lambda expressions – one from the C# object to the database and the other from <a id="_idIndexMarker918"/>the database to the C# object. For our <code>List&lt;int&gt;</code> properties, we want to convert a C# <code>List&lt;int&gt;</code> into a comma-separated string of integers, and then a comma-separated string of integers to <code>List&lt;int&gt;</code>.</p><p class="list-inset"><code>toDB</code> is an instance of <code>List&lt;int&gt;</code>, so to convert that into a comma-separated list of numbers, we can use the <code>String.Join</code> function to join each element of the list with <code>,</code> between them.</p><p class="list-inset"><code>fromDb</code> is a <code>string</code> value containing numbers separated by commas. To convert that into <code>List&lt;int&gt;</code>, we can use the <code>String.Split</code> method to isolate each number, then pass each number into the <code>Int.Parse</code> method to convert the number into an <code>int</code> value. <code>Select</code> will produce <code>IEnumberable&lt;int&gt;</code>; we can <a id="_idIndexMarker919"/>use the <code>ToList</code>, to convert that into <code>List&lt;int&gt;</code>. If it doesn’t create a list, we can supply a default list of values, just like we did in the <code>Match</code> class itself.</p></li> </ol>
<p>To initialize Entity Framework to use an in-memory database, we need to create a <code>Startup</code> method. To create the method and initialize the database, follow these steps:</p>
<ol>
<li>Create a new class named <code>Startup</code> in the root of the <code>SticksAndStones.Functions</code> project.</li>
<li>Modify <a id="_idIndexMarker920"/>the class file with the following highlighted code:<pre class="source-code">
<strong class="bold">using Microsoft.Azure.Functions.Extensions.DependencyInjection;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.DependencyInjection;using SticksAndStones.Repository;[assembly: FunctionsStartup(typeof(SticksAndStones.Startup))]</strong>
namespace SticksAndStones;public class Startup <strong class="bold">: FunctionsStartup </strong>{    <strong class="bold">public override void Configure(IFunctionsHostBuilder builder)    {        string SqlConnection = Environment.GetEnvironmentVariable("SqlConnectionString");        builder.Services.AddDbContextFactory&lt;GameDbContext&gt;(            options =&gt;            {                options.UseInMemoryDatabase("SticksAndStones");            });    }</strong>}</pre></li> </ol>
<p>The <code>Startup</code> method will now be called when the <code>SticksAndStones.Functions</code> project is loaded at runtime. It will then create a factory for creating instances of the <code>GameDbContext</code> class we created previously and initialize it with an in-memory database.</p>
<p>That concludes <a id="_idIndexMarker921"/>our setup for Entity Framework and our basic models, <code>Player</code> and <code>Game</code>. There is one final model that we need to send the SignalR connection information to the client. To create this model, follow these steps:</p>
<ol>
<li>Create a new class in the <code>Models</code> folder named <code>ConnectionInfo</code>.</li>
<li>Add a public property <code>Url</code> that is a <code>string</code> value.</li>
<li>Add another public property named <code>AccessToken</code> that is also a <code>string</code> value.</li>
<li>The <code>ConnectionInfo</code> class should look like this:<pre class="source-code">
namespace SticksAndStones.Models;public class ConnectionInfo {    public string Url { get; set; }    public string AccessToken { get; set; }}</pre></li> </ol>
<p>With the models now created, we can start creating the <code>Connect</code> function.</p>
<h4>Creating the Connect function</h4>
<p>We will start with a function to connect our player to the game, aptly named <code>Connect</code>. This function <a id="_idIndexMarker922"/>will expect a partially filled <code>Player</code> object to be sent in the request body. The function will return a fully populated <code>Player</code> object, a list of the currently connected players, and the connection information needed by the client to connect to the SignalR hub. To make the inputs and outputs cleaner, we will wrap them.</p>
<p>To create the input and output classes, proceed as follows:</p>
<ol>
<li>Create a new class in the <code>Messages</code> folder called <code>ConnectMessages</code>.</li>
<li>Modify <code>ConnectMessages.cs</code> so that it looks like this:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct ConnectRequest(Player Player);public record struct ConnectResponse(Player Player, List&lt;Player&gt; Players, ConnectionInfo ConnectionInfo);</pre></li> </ol>
<p>For all the classes that will be used to transfer data between the client and Azure Functions or <a id="_idIndexMarker923"/>the SignalR service, we will use the <code>record</code> syntax. Since these classes will not have any real functionality, their sole purpose is to contain our models. By using a <code>record</code> struct, we also improve the memory usage of our functions since a new instance would be created in local memory and not global memory, which requires additional handling. The <code>record</code> syntax combines the constructor and property declarations into a single line of code, eliminating a lot of boilerplate code that adds no real benefit.</p>
<p>You will notice that we are using the conventions we discussed in the <em class="italic">Creating the models</em> section. Classes that have a suffix of <code>Request</code> or <code>Response</code> are used as input and output for any Azure function. For any data that is sent via the SignalR service, the class will use a suffix of <code>EventArgs</code>.</p>
<p>When a new client is connecting, a message will be sent to other users via the SignalR service to indicate that they have connected. This message will also be used to notify when players start or end a game. To create such a message, proceed as follows:</p>
<ol>
<li>Create a new class called <code>PlayerUpdatedEventArgs</code> in the <code>Messages</code> folder of the <code>SticksAndStones.Shared</code> project.</li>
<li>Modify the class so that it’s a <code>record</code> struct with a single <code>Player</code> parameter, as shown in the following code snippet:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct PlayerUpdatedEventArgs(Player Player);</pre></li> </ol>
<p>Now that <a id="_idIndexMarker924"/>we have created the structures needed for the <code>Connect</code> function, we can start writing the function itself:</p>
<ol>
<li>Create a new folder called <code>Hubs</code>. We will put our service class into this folder.</li>
<li>Move the <code>Function1.cs</code> file into the <code>Hubs</code> folder.</li>
<li>Respond <strong class="bold">Yes</strong> to the next two prompts for moving the file and adjusting the namespace.</li>
<li>Rename the <code>Function1.cs</code> file <code>GameHub.cs</code> and click <strong class="bold">Yes</strong> in the rename prompt.</li>
<li>Open the <code>GameHub.cs</code> file and rename the class <code>GameHub</code>, replace the <code>internal static</code> access modifiers and replace them with <code>public</code>, and derive it from the <code>ServerlessHub</code> base class, as highlighted here:<pre class="source-code">
<strong class="bold">public </strong>class GameHub <strong class="bold">: ServerlessHub</strong>
{    [FunctionName("Function1")]    public static async Task&lt;IActionResult&gt; Run(    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,    ILogger log)    {        log.LogInformation("C# HTTP trigger function processed a request.");        string name = req.Query["name"];        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();        dynamic data = JsonConvert.DeserializeObject(requestBody);        name = name ?? data?.name;        string responseMessage = string.IsNullOrEmpty(name)        ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."                : $"Hello, {name}. This HTTP triggered function executed successfully.";        return new OkObjectResult(responseMessage);    }}</pre></li> <li>Rename the <a id="_idIndexMarker925"/>default <code>Function1</code> function <code>Connect</code>, removing the <code>static</code> modifier as well. The method signature should look like the following highlighted code snippet:<pre class="source-code">
[FunctionName("<code>HttpTrigger</code> attribute indicates that this function is called by using the HTTP protocol and not by some other means, such as a SignalR message or a timer. The function is only called using the HTTP <code>POST</code> method, not <code>GET</code>.</p></li> <li>To send a message <a id="_idIndexMarker926"/>to all clients connected to the SignalR hub, we will need another SignalR binding. This time, it is an <code>HubName</code> and is of the <code>IAsyncCollector&lt;SignalRMessage&gt;</code> type, as follows:<pre class="source-code">
[HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = null)] HttpRequest req,[SignalRConnectionInfo(HubName = "GameHub")] SignalRConnectionInfo connectionInfo,<strong class="bold">[SignalR(HubName = "GameHub")] IAsyncCollector&lt;SignalRMessage&gt; signalRMessages,</strong>ILogger log)</pre></li> </ol>
<p>Remove the contents of the <code>Connect</code> method and proceed as follows to implement the function:</p>
<ol>
<li>Logging is important in Azure Functions as it helps when debugging in production environments. So, let’s add a <code>log</code> message:<pre class="source-code">
log.LogInformation("A new client is requesting connection");</pre></li> <li>The client, a .NET MAUI app, will send <code>ConnectRequest</code> in the body of the HTTP request <a id="_idIndexMarker927"/>as JSON. To get an instance of <code>ConnectRequest</code> from the request body, use the following lines of code:<pre class="source-code">
var result = await JsonSerializer.DeserializeAsync&lt;ConnectRequest&gt;(req.Body, jsonOptions);var newPlayer = result.Player;</pre><p class="list-inset">You will have to add <code>using System.Text.Json</code> to the namespace declarations as well. This uses the <code>System.Text.Json.JsonSerializer</code> class to read the contents of the request body and create a <code>ConnectRequest</code> object from it. It uses <code>jsonOptions</code> to properly deserialize the object.</p></li> <li>Now, we need to define the <code>jsonOptions</code> field. Add the following line of code above the <code>Connect</code> method:<pre class="source-code">
internal class GameHub : ServerlessHub {<strong class="bold">    private readonly JsonSerializerOptions jsonOptions = new(JsonSerializerDefaults.Web);</strong>
    [FunctionName("Connect")]    public async Task&lt;IActionResult&gt; Connect(</pre><p class="list-inset"><code>JsonSerializerDefaults.Web</code> ensures that the JSON is formatted properly so that Azure Functions and the SignalR service will properly serialize and deserialize the objects. Mainly, it will enforce the following:</p><ul><li>Property names are case-insensitive</li><li>All property and object names will be formatted as camelCase</li><li>Numbers can be quoted</li></ul></li> <li>If we receive <a id="_idIndexMarker928"/>bad player data, return <code>ArgumentException</code> to the client, as follows:<pre class="source-code">
if (newPlayer is null){    var error = new ArgumentException("No player data.", "Player");    log.LogError(error, "Failure to deserialize arguments");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.GamerTag)){    var error = new ArgumentException("A GamerTag is required for all players.", "GamerTag");    log.LogError(error, "Invalid value for GamerTag");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.EmailAddress)){    var error = new ArgumentException("An Email Address is required for all players.", "EmailAddress");    log.LogError(error, "Invalid value for EmailAddress");    return new BadRequestObjectResult(error);}</pre><p class="list-inset">Since the return type of the function is <code>IActionResult</code>, we can’t simply return our custom objects. Instead, we need to create an object that derives or implements <code>IActionResult</code> and pass in our result. In the case of errors, we will use <code>BadRequestObjectResult</code>, which will accept <code>Exception</code> as a parameter in the constructor. <code>BadRequestObjectResult</code> will set the HTTP status code to <code>400</code>, indicating an error. This status code can then be checked by the client to know whether the request succeeded or not before parsing the body of the response.</p></li> <li>The next <a id="_idIndexMarker929"/>couple of steps will require us to query the database, so we need to add the database context factory to the class. Add the <code>Microsoft.EntityFrameworkCore</code> namespace declaration:<pre class="source-code">
using Microsoft.Azure.WebJobs.Extensions.SignalRService;<code>private</code> field to store the context factory and a constructor with an argument that will be fulfilled by dependency injection, as follows:<pre class="source-code">
private readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);<strong class="bold">
private readonly IDbContextFactory &lt;GameDbContext&gt; dbContextFactory;public GameHub(IDbContextFactory&lt;GameDbContext&gt; dbcontext){    contextFactory = dbContextFactory;}</strong>
[FunctionName("Connect")]public async Task&lt;IActionResult&gt; Connect(</pre></li> <li>Add a namespace declaration for <code>System.Linq</code> to allow the use of <strong class="bold">Linq</strong> queries:<pre class="source-code">
using System;<code>GamerTag</code> in the database to ensure it isn’t in use already by another player, as follows:<pre class="source-code">
using var context = contextFactory.CreateDbContext();log.LogInformation("Checking for GameTag usage");var gamerTagInUse = (from p in context.Players                      where string.Equals(p.GamerTag, newPlayer.GamerTag, StringComparison.InvariantCultureIgnoreCase)                     &amp;&amp; !string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase)                     select p).Any();if (gamerTagInUse){    var error = new ArgumentException($"The GamerTag {newPlayer.GamerTag} is in use, please choose another.", "GamerTag");    log.LogError(error, "GamerTag in use.");    return new BadRequestObjectResult(error);}</pre><p class="list-inset">The first step is to get a new database context from the factory. The <code>Players</code> list from the database context to compare <code>GamerTag</code> value to other GamerTagsvalues. However, we want to exclude a result if it matches <code>EmailAddress</code> since that would indicate the records are identical, and this user is just signing back in again.</p></li> <li>Now, query the <code>Players</code> dataset for a player with a matching email:<pre class="source-code">
    log.LogInformation("Locating Player record.");    var thisPlayer = (from p in context.Players where string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase) select p).FirstOrDefault();</pre></li> <li>If there <a id="_idIndexMarker931"/>is no <code>Player</code> in <code>Players</code> that matches, then add <code>Player</code> to the dataset:<pre class="source-code">
if (thisPlayer is null){    log.LogInformation("Player not found, creating.");    thisPlayer = newPlayer;    thisPlayer.Id = Guid.NewGuid();    context.Add(thisPlayer);    await context.SaveChangesAsync();}</pre><p class="list-inset">We assign the <code>Player</code> object a new <code>Guid</code> so that each <code>Player</code> has a unique identifier. This could also be done by Entity Framework; however, we will take care of it here. The context is then used to add the <code>Player</code> instance so that it is tracked for any changes. After this, <code>SaveChangesAsync</code> will commit all changes to the database.</p></li> <li>The next step in the <code>Connect</code> function is to send a message to all the connected players that a new player has joined. We can do that using the <code>SendAsync</code> method. The <code>SendAsync</code> method takes two parameters – the method name as a <code>string</code> value that the message is intended for, and the message as an <code>object</code> value. To ensure we are sending and receiving the right method, we will create a constant value. Create a new class named <code>Constants</code> in the root of the <code>SticksAndStones.Shared</code> project, then update it so that it looks like this:<pre class="source-code">
namespace SticksAndStones;public static class Constants {    public static class Events     {        public static readonly string PlayerUpdated = nameof(PlayerUpdated);    }}</pre></li> <li>Now, we can <a id="_idIndexMarker932"/>notify other connected players that a new player has connected. Open the <code>GameHub</code> class and, at the end of the <code>Connect</code> method, add the following code:<pre class="source-code">
    log.LogInformation("Notifying connected players of new player.");    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(thisPlayer));</pre><p class="list-inset">This code uses the <code>SendAsync</code> method from the <code>Clients.All</code> collection in the <code>ServerlessHub</code> base class to send a message to all connected clients. We pass <code>Constants.Events.PlayerUpdated</code>, which is the <code>"PlayerUpdated"</code> string, as the method name. As arguments, we are sending the <code>Player</code> instance wrapped in <code>PlayerUpdatedEventArgs</code>. We will handle this message in <em class="italic">Chapter 10</em>.</p></li> <li>Now, get the set of available players from the database to send back to the client:<pre class="source-code">
// Get the set of available players log.LogInformation("Getting the set of available players.");    var players = (from player in context.Players         where player.Id != thisPlayer.Id         select player).ToList();</pre><p class="list-inset">Using Linq, we can easily query the <code>Players</code> collection and exclude the current player.</p></li> <li>At this point, we need to get the SignalR connection information from the SignalR service. This can be accomplished by calling the <code>NegotiateAsync</code> method of the <code>ServerlessHub</code> base class. Additionally, so that we can send directed messages to individual users, we will set the <code>UserId</code> value for the connection <a id="_idIndexMarker933"/>to the player ID value. Add the following line of code to configure and retrieve the SignalR connection information:<pre class="source-code">
var connectionInfo = await NegotiateAsync(new NegotiationOptions() { UserId = thisPlayer.Id.ToString() });</pre></li> <li>Now that we have all the information that we need to return to the client, we can construct the <code>ConnectResponse</code> object. We will use the <code>ConnectionInfo</code> class and map the <code>SignalRConnection</code> properties to it so that we avoid having to reference the SignalR service in the shared library:<pre class="source-code">
log.LogInformation("Creating response.");var connectResponse = new ConnectResponse(){    Player = thisPlayer,    Players = players,    ConnectionInfo = new Models.ConnectionInfo { Url = connectionInfo.Url, AccessToken = connectionInfo.AccessToken }};</pre></li> <li>Once <code>ConnectResponse</code> has been initialized, we can return it by using <code>OkObjectResult</code>, which will use an HTTP response code of <strong class="bold">200 OK</strong>:<pre class="source-code">
log.LogInformation("Sending response.");return new OkObjectResult(connectResponse);</pre></li> </ol>
<p>To test the function we just wrote, you can use a PowerShell command prompt and the following command, after pressing <em class="italic">F5</em> in Visual Studio:</p>
<pre class="console">
Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect -Method Post -Body ''</pre> <p>The port <a id="_idIndexMarker934"/>number used in the <code>Uri</code> parameter may be different for your project. You can get the correct port number by opening the <code>launchSettings.json</code> file in the <code>Properties</code> folder of the <code>SticksAndStones.Functions</code> project. The port number is set in the <code>commandLineArgs</code> property, as highlighted here:</p>
<pre class="source-code">
{  "profiles": {    "SticksAndStones.Functions": {      "commandName": "Project",      "commandLineArgs": "--port <code>Uri</code> parameter after <code>localhost:</code>.</p>
<p>In the <code>Body</code> parameter, you can add the JSON that the command is expecting. For the <code>Connect</code> function, this would be <code>ConnectRequest</code> and would look like this:</p>
<pre class="source-code">
'{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress": "newplayer2@gmail.com",    }}'</pre> <p>The full command will look like this:</p>
<pre class="source-code">
Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect -Method Post -Body '{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress": "newplayer2@gmail.com",    }}'</pre> <p>Go ahead <a id="_idIndexMarker935"/>and try out various versions of the command to see how the function reacts.</p>
<p>Now that we can connect players to the game server, let’s look at what is needed for the lobby.</p>
<h3>Refreshing the lobby</h3>
<p>In the Sticks and Stones App, which you will create in Chapter 10, once a player has connected, they will move to the lobby page. Initially, the lobby <a id="_idIndexMarker936"/>will be populated from the list of players <a id="_idIndexMarker937"/>sent in the response from the <code>Connect</code> function. Additionally, as each player connects, the lobby will be updated through a SignalR event.</p>
<p>But we all get impatient and want a way to refresh the list immediately. So, the lobby page has a way to refresh the list; to do so, it will call the <code>GetAllPlayers</code> function.</p>
<p>Let’s start by creating the messages needed for <code>GetAllPlayers</code>.</p>
<h3>Creating the messages</h3>
<p><code>GetAllPlayers</code> takes no <a id="_idIndexMarker938"/>parameters, so we only need to create the <code>GetAllPlayersResponse</code> type. Follow these steps to add <code>GetAllPlayersResponse</code>:</p>
<ol>
<li>In the <code>SticksAndStones.Shared</code> project, create a new file named <code>GetAllPlayers</code><strong class="source-inline">
Messages.cs</strong> in the <code>Messages</code> folder.</li>
<li>Modify the contents of the file so that it looks as follows:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct GetAllPlayersResponse(List&lt;Player&gt; Players);</pre></li> </ol>
<p>With the <a id="_idIndexMarker939"/>messages created, we can move on to the <code>GetAllPlayers</code> function.</p>
<h4>Getting all the players</h4>
<p><code>GetAllPlayers</code> is called using the <code>Http</code> <code>GET</code> method and has an optional parameter that is passed through <code>QueryString</code> using the <code>id</code> key. The optional parameter is used to <a id="_idIndexMarker940"/>exclude a specific <code>id</code> from the returned list. This makes it <a id="_idIndexMarker941"/>so that the app can send the current player’s <code>id</code> and not have it returned in the list. To create the <code>GetAllPlayers</code> function, follow these steps:</p>
<ol>
<li>In the <code>GameHub</code> class, after the <code>Connect</code> method, add the following method declaration:<pre class="source-code">
[FunctionName("GetAllPlayers")]public IActionResult GetAllPlayers([HttpTrigger(AuthorizationLevel.Function, "get", Route = "Players/GetAll")] HttpRequest req,ILogger log){}</pre><p class="list-inset">Not much is new here other than using <code>"get"</code> instead of <code>"post"</code> for the <code>Http</code> method, and <code>Route</code> is set to <code>"Players/GetAll"</code>, which would make the URL for the function <code>http://localhost:7024/api/Players/GetAll</code>.</p></li> <li>In the method, we will process the <code>id</code> option parameter. To do so, add the following code:<pre class="source-code">
// Exclude the playerId if provided Guid playerId = Guid.Empty;if (req.Query.ContainsKey("id")){    string id = req.Query["id"];    if (!string.IsNullOrEmpty(id))    {        playerId = new Guid(id);    }}</pre><p class="list-inset">In this code, we check for the existence of a key named <code>id</code>. If it exists, then its value is retrieved and converted into a <code>Guid</code> value and assigned to the <code>playerId</code> variable.</p></li> <li>Next, we can <a id="_idIndexMarker942"/>query the database for all players, and exclude <code>player.Id</code> using the following code:<pre class="source-code">
using var context = contextFactory.CreateDbContext();// Get the set of available players log.LogInformation("Getting the set of available players.");var players = (from player in context.Players                where player.Id != playerId                select player).ToList();</pre></li> <li>Finally, return <code>OkObjectResult</code> with a new <code>GetAllPlayersResponse</code> object initialized with the list of <code>players</code>:<pre class="source-code">
return new OkObjectResult(new GetAllPlayersResponse(players));</pre></li> </ol>
<p>Now that we can refresh the lobby with a list of all the players, it’s time to match them up for a game.</p>
<h3>Challenging another player to a game</h3>
<p>To test your <a id="_idIndexMarker943"/>skills at this game, you’ll need an opponent – someone who would also like to test their skills against yours. This section will build the functionality needed in the <code>SticksAndStones.Function</code> project to have one player – the challenger – challenge another player – the opponent – to a game. The opponent has the option to accept the challenge or deny it. We will also handle the case where the opponent does not respond since they might have put their phone down; this is an edge case.</p>
<p>The interactions <a id="_idIndexMarker944"/>in this use case can get tricky, so let’s review the following diagram to get a better understanding of what we are building:</p>
<div><div><img alt="Figure 9.10 – Challenge diagram" src="img/B19214_09_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Challenge diagram</p>
<p>The process starts with a user interaction that results in the client making an HTTP request to the <code>GameHub</code> instance via the <code>IssueChallenge</code> function. The client will pass the challenger and opponent details when making the HTTP call. <code>IssueChallenge</code> will create an <code>Id</code> value to track this process. <code>IssueChallenge</code> will then send a direct message to the opponent via the SignalR hub using the <code>SendAsync</code> method. The message will include the <code>Id</code> value that was created earlier, the challenger, and the opponent details as an instance of <code>ChallengeEventArgs</code>. The opponent’s client will receive the message via an <code>On&lt;ChallengeEventArgs&gt;</code> event handler. The opponent will then have the choice of accepting or declining the challenge. The response is sent back to the <code>GameHub</code> instance using the <code>AcknowledgeChallenge</code> function. The <code>Id</code> value of the challenge is sent along with <code>ChallengeResponse</code>, either <code>Accept</code> or <code>Decline</code>. A third possibility is <code>Timeout</code>. If the opponent never responds, then after a certain amount of time has passed, <code>Challenge</code> will <code>Timeout</code>. In either event, the result is then returned to the challenger using the response of the <code>IssueChallenge</code> call.</p>
<p>Let’s get started by defining the messages.</p>
<h4>Creating the messages and models</h4>
<p>We will <a id="_idIndexMarker945"/>start with <code>IssueChallengeRequest</code> since that is the first message that is being sent. Follow these steps to create the class:</p>
<ol>
<li>In the <code>SticksAndStones.Shared</code> project, create a new file named <code>ChallengeMessages.cs</code> under the <code>Message</code> folder.</li>
<li>Modify the file so that it looks as follows:<pre class="source-code">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct IssueChallengeRequest(Player Challenger, Player Opponent);</pre></li> </ol>
<p>As we have in the <code>Connect</code> function, we use a <code>record</code> struct to eliminate a lot of the boilerplate code needed to define a <code>struct</code> value. Our message only needs two <code>Player</code> objects – <code>Challenger</code> and <code>Opponent</code>. The client will have both available when it makes the call to this function. <code>Challenger</code> will be the client making the call to <code>IssueChallenge</code> and <code>Opponent</code> will be the opposing side.</p>
<p>The <code>IssueChallenge</code> function will return <code>IssueChallengeResponse</code>. This <code>Issue</code><strong class="source-inline">
ChallengeResponse</strong> will have just one field, <code>Response</code>, which will be an <code>enum</code> value called <code>ChallengeResponse</code>. Follow these steps to create <code>ChallengeResponse</code>:</p>
<ol>
<li>In the <code>SticksAndStones.Shared</code> project, in the <code>Models</code> folder, create a new <code>enum</code> named <code>ChallengeResponse</code>.</li>
<li>Add the following values to the <code>enum</code> value:<ul><li><code>None</code></li><li><code>Accepted</code></li><li><code>Declined</code></li><li><code>Timeout</code></li></ul><p class="list-inset">Your code should look like this:</p><pre class="source-code">
namespace SticksAndStones.Models;public enum ChallengeResponse {    None,    Accepted,    Declined,    TimeOut }</pre></li> </ol>
<p>To create <a id="_idIndexMarker946"/>the remaining messages for the <code>IssueChallenge</code> and <code>AcknowledgeChallenge</code> functions, follow these steps:</p>
<ol>
<li>Open the <code>ChallengeMessages.cs</code> file and add the following declaration at the end of the file:<pre class="source-code">
public record struct IssueChallengeResponse(ChallengeResponse Response);</pre></li> <li>When the opponent responds to a challenge, they will call the <code>AcknowledgeChallenge</code> function and pass an <code>AcknowledgeChallengeRequest</code> object as an argument. In the <code>ChallengeMessages.cs</code> file, add the following declaration to create <code>AcknowledgeChallengeRequest</code>:<pre class="source-code">
public record struct AcknowledgeChallengeRequest(Guid Id, ChallengeResponse Response);</pre></li> </ol>
<p>That completes the messages that are sent or received from the <code>GameHub</code> functions for a challenge. That just leaves <code>ChallengeEventArgs</code>, which is sent from <code>GameHub</code> to the opponent. To create the <code>ChallengeEventArgs</code> class, follow these steps:</p>
<ol>
<li>In the <code>Messages</code> folder of the <code>SticksAndStones.Shared</code> project, create a new file named <code>ChallengeEventArgs.cs</code>.</li>
<li>Replace the contents of the <code>ChallengeEventArgs.cs</code> file with the following:<pre class="source-code">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct ChallengeEventArgs(Guid Id, Player Challenger, Player Opponent);</pre></li> <li>To add <a id="_idIndexMarker947"/>the method name constant for the <code>SendAsync</code> method, open the <code>Constants.cs</code> file in the <code>SticksAndStones.Shared</code> project and add the following highlighted field to the <code>Events</code> class:<pre class="source-code">
public static class Events {    public static readonly string PlayerUpdated = nameof(PlayerUpdated);    <strong class="bold">public static readonly string Challenge = nameof(Challenge);</strong>}</pre></li> </ol>
<p>As with the previous message definitions, <code>ChallengeEventArgs</code> is also defined as <code>public record struct</code>. The parameters are an <code>Id</code> value of the <code>Guid</code> type and two <code>Player</code> objects – one for <code>Challenger</code> or the initiator, and one for <code>Opponent</code> or the receiver. <code>Id</code> will be created in the <code>IssueChallenge</code> function and is used to correlate the challenge with the response. This is needed because we are tracking the challenge and if a certain amount of time has passed, we expire the challenge. <code>Id</code> is used to track that state and check whether the challenge is still valid if the client responds.</p>
<p>What was not included in the diagram in <em class="italic">Figure 9</em><em class="italic">.10</em> is a structure that is used to track the challenge in the <code>GameHub</code> class. It is only needed while a challenge is active and hasn’t timed out. To create the <code>Challenge</code> class, follow these steps:</p>
<ol>
<li>Create a file named <code>Challenge.cs</code> in the <code>Models</code> folder of the <code>SticksAndStones.Shared</code> project.</li>
<li>Replace the contents of the <code>Challenge.cs</code> file with the following code:<pre class="source-code">
using System;namespace SticksAndStones.Models;public record struct Challenge(Guid Id, Player Challenger, Player Opponent, ChallengeResponse Response);</pre></li> </ol>
<p>As with <a id="_idIndexMarker948"/>previous models, we use a <code>record</code> struct. The <code>Challenge</code> class has various properties – <code>Id</code>, <code>Challenger</code> as a <code>Player</code> type, <code>Opponent</code> as a <code>Player</code> type, and <code>ChallengeResponse</code>, which is called <code>Response</code>.</p>
<p>If a player accepts the challenge, then the two players will start a match with each other. Each player will be notified that the match has begun by receiving a <code>MatchStarted</code> SignalR event. To create the event and its arguments, follow these steps:</p>
<ol>
<li>Open the <code>Constants.cs</code> file in the <code>SticksAndStones.Shared</code> project and add the following highlighted field to the <code>Events</code> class:<pre class="source-code">
public static class Events {    public static readonly string PlayerUpdated = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);<strong class="bold">
    public static readonly string GameStarted = nameof(MatchStarted);</strong>}</pre></li> <li>In the <code>Messages</code> folder of the <code>SticksAndStones.Shared</code> project, create a new file named <code>MatchStartedEventArgs.cs</code>.</li>
<li>Replace the contents of the <code>MatchStartedEventArgs.cs</code> file with the following:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct MatchStartedEventArgs(Match Match);</pre></li> </ol>
<p>That <a id="_idIndexMarker949"/>concludes the new messages and models that are needed to allow one player to challenge another to a game of <code>SticksAndStones</code>. Next, we will create the first of two functions that will handle the process in the <code>GameHub</code> class.</p>
<h3>Creating the IssueChallenge function</h3>
<p>We’ll <a id="_idIndexMarker950"/>start with the <code>IssueChallenge</code> function. This function is called from the <code>Challenger</code> client to start the challenge process. The client will pass their <code>Player</code> object, <code>Challenger</code>, and the player they are challenging – that is, <code>Opponent</code>. These two models are contained in an <code>IssueChallengeRequest</code> object. The <code>IssueChallenge</code> function will need to perform the following actions:</p>
<ul>
<li>Validate input</li>
<li>Create a challenge object</li>
<li>Send a challenge to the opponent</li>
<li>Wait for a response from the opponent</li>
<li>Send the response to the challenger</li>
</ul>
<p>To create the function and implement these actions, follow these steps:</p>
<ol>
<li>Open the <code>GameHub.cs</code> file in the <code>SticksAndStones.Functions</code> project.</li>
<li>Add the <code>IssueChallenge</code> function declaration, as follows:<pre class="source-code">
[FunctionName("IssueChallenge")]public async Task&lt;IssueChallengeResponse&gt; IssueChallenge(    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Challenge/Issue")] HttpRequest req,    ILogger log){}</pre><p class="list-inset">The <code>FunctionName</code> attribute tells Azure Functions that this is an available function. The <code>req</code> parameter is an <code>HttpRequest</code> object, and the Azure Functions runtime will provide its instance when the function is called. It is attributed by the <code>HttpTrigger</code> attribute, which makes the function available via an <code>Http</code> API call. <code>HttpRequest</code> must use the <code>POST</code> method and not <code>GET</code> when making the call and the function’s <code>Route</code> or <code>Url</code> will end with <code>Challenge/Issue</code>. The function returns <code>IssueChallengeResponse</code> to the caller.</p></li> <li>The first <a id="_idIndexMarker951"/>action the function performs is to validate the inputs. The <code>IssueChallengeRequest</code> object is sent as part of the body of the <code>Http</code> POST request. To retrieve the instance, use the following code in the <code>IssueChallenge</code> function:<pre class="source-code">
{    var result = await JsonSerializer.DeserializeAsync&lt;IssueChallengeRequest&gt;(req.Body, jsonOptions);}</pre><p class="list-inset">This is the same way we retrieved the arguments that were passed in the <code>Connect</code> function. The main difference is that the type of object being returned by the <code>DeserializeAsync</code> method is <code>IssueChallengeRequest</code>, not <code>ConnectRequest</code>. The <code>jsonOptions</code> field is already defined in the <code>GameHub</code> class.</p></li> <li>Now, we need to check whether the challenger and opponent are valid. Valid means that they exist in our database, and neither are currently in a match. We will use <code>IssueChallenge</code> function to verify that the players exist:<pre class="source-code">
using var context = contextFactory.CreateDbContext();Guid challengerId = result.Challenger.Id;var challenger = (from p in context.Players                   where p.Id == challengerId                   select p).FirstOrDefault();

Guid opponentId = result.Opponent.Id;var opponent = (from p in context.Players                 where p.Id == opponentId                 select p).FirstOrDefault();if (challenger is null)    throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag} is not a valid player.");if (opponent is null)    throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag} is not a valid player.");</pre><p class="list-inset">First, we capture the <code>Id</code> value of the player. We use this <code>Id</code> to query the <code>Players</code> <code>DbSet</code> in the database context for a matching <code>Id</code> and return the <code>Player</code> object if it exists; otherwise, we return <code>null</code>. If the object is <code>null</code>, then <a id="_idIndexMarker952"/>we exit the function by throwing <code>ArgumentException</code> and passing the name of the object as the <code>paramName</code> argument and a message detailing the issue. This can be used on the client to display an error message.</p></li> <li>The following code will check whether the players are currently engaged in a match with another player. Add the following code to the end of the <code>IssueChallenge</code> function:<pre class="source-code">
var challengerInMatch = (from g in context.Matches
                         where g.PlayerOneId == challengerId || g.PlayerTwoId == challengerId
                         select g).Any();
var opponentInMatch = (from g in context.Matches
                       where g.PlayerOneId == opponentId || g.PlayerTwoId == opponentId
                       select g).Any();
if (challengerInMatch)
    throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag} is already in a match!");
if (opponentInMatch)
    throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag} is already in a match!");</pre><p class="list-inset">Again, we use <code>Matches</code> <code>DbSet</code>. We are not looking for the <code>Match</code> instance, just the fact that one does exist, where either <code>PlayerOneId</code> or <code>PlayerTwoId</code> is the player’s <code>Id</code> value. We use the <code>Any</code> function to return <code>true</code> if there are any results and <code>false</code> if there are no results. Again, we throw <code>ArgumentException</code> if either player is in a match with an appropriate message.</p></li> <li>At this point, we have validated that both players exist and can join a new game. We will <a id="_idIndexMarker953"/>need to capture the game <code>Id</code> value if the challenge is accepted, so let’s create the variable and log some details before moving on:<pre class="source-code">
Guid matchId = Guid.Empty;log.LogInformation($"{challenger.GamerTag} has challenged {opponent.GamerTag} to a match!");</pre></li> </ol>
<p>The next step in the <code>IssueChallenge</code> function is to create a <code>Challenge</code> object. But because we want to track how long <code>Challenge</code> is waiting so that we can time it out, we need a helper class to abstract that detail away from the function.</p>
<p class="callout-heading">Don’t reinvent the wheel</p>
<p class="callout">The <a id="_idIndexMarker954"/>implementation of <code>ChallengeHandler</code> is heavily based on <code>AckHandler</code> from the <strong class="bold">Azure SignalR AckableChatRoom</strong> sample. The source for the sample is available at <a href="https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom">https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom</a>.</p>
<p>Let’s <a id="_idIndexMarker955"/>create the <code>ChallengeHandler</code> class by following these steps:</p>
<ol>
<li>Create a new folder in the <code>SticksAndStones.Functions</code> folder named <code>Handlers</code>.</li>
<li>Create a new class named <code>ChallengeHandler</code> in the <code>Handlers</code> folder, and change the access modifier from <code>internal</code> to <code>public</code>.</li>
<li>Add a constructor for the class that has three parameters – <code>completeAcksOnTimeout</code> as <code>bool</code>, <code>ackThreshold</code> as <code>TimeSpan</code>, and <code>ackInterval</code> as <code>TimeSpan</code>. The constructor will create a timer to periodically clear out old challenges and store the <code>ackThreshold</code> value in a class field. The class’s contents should look like this:<pre class="source-code">
private readonly TimeSpan ackThreshold;private readonly Timer timer;
public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan ackInterval){    if (completeAcksOnTimeout)    {        timer = new Timer(_ =&gt; CheckAcks(), state: null, dueTime: ackInterval, period: ackInterval);    }    this.ackThreshold = ackThreshold;}</pre><p class="list-inset">You will need to add a <code>using</code> declaration for the <code>System.Threading</code> namespace to use the <code>Timer</code> type. The <code>CheckAcks</code> method will be created later in this section.</p></li> <li>To provide <a id="_idIndexMarker956"/>some reasonable defaults for the constructor, we will create a parameterless constructor and provide the defaults, as shown in the following snippet:<pre class="source-code">
private readonly Timer timer;<strong class="bold">
public ChallengeHandler() : this(    completeAcksOnTimeout: true,    ackThreshold: TimeSpan.FromSeconds(30),    ackInterval: TimeSpan.FromSeconds(1))    {    }</strong>
public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan ackInterval)</pre><p class="list-inset">This will provide the default values to the main constructor.</p></li> <li>Now, to create a new <code>Challenge</code>, the <code>IssueChallenge</code> function will call a method named <code>CreateChallenge</code>, as shown here:<pre class="source-code">
public (Guid id, Task&lt;Challenge&gt; responseTask) CreateChallenge(Player challenger, Player opponent){    var id = Guid.NewGuid();    var tcs = new TaskCompletionSource&lt;Challenge&gt;(TaskCreationOptions.RunContinuationsAsynchronously);    handlers.TryAdd(id, new(id, tcs, DateTime.UtcNow, new(id, challenger, opponent, ChallengeResponse.None)));    return (id, tcs.Task);}
private record struct ChallengeRecord(Guid Id, TaskCompletionSource&lt;Challenge&gt; ResponseTask, DateTime Created, Challenge Challenge);</pre><p class="list-inset">Add <a id="_idIndexMarker957"/>this declaration to the top of the <code>ChallengeHandler</code> class. This <code>record</code> has an <code>Id</code> value – for uniqueness, <code>TaskCompletionSource</code> – a <code>DateTime</code> value to track the creation time, and the <code>Challenge</code> object itself. We keep a list of <code>ChallengeRecord</code> instances in another field called <code>handlers</code>. The <code>handlers</code> field, which is declared right after the <code>ChallengeRecord</code> class, is as follows:</pre><pre class="source-code">private readonly ConcurrentDictionary&lt;Guid, ChallengeRecord&gt; handlers = new();</pre><p class="list-inset">We use <code>ConcurrentDictionary</code> since we may be accessing the field from several different threads at the same time. <code>ConncurrentDictionary</code> is designed to prevent data corruption in multithreaded situations, like this one.</p><p class="list-inset">Once <code>TaskCompletionSource</code>, <code>Challenge</code>, and <code>ChallengeRecord</code> have been created, the <code>Challenge</code> <code>Id</code> value and the <code>Task</code> value associated with <code>TaskCompletionSource</code> are returned as a <code>Tuple</code> value to the <code>IssueChallenge</code> function. We will see what happens to that data later in this section when we complete the <code>IssueChallege</code> function.</p><p class="list-inset">Finally, to resolve the missing namespaces, add the following highlighted namespace declarations to your <code>ChallengeHandler</code> class file:</p><pre class="source-code"><strong class="bold">using SticksAndStones.Models;</strong>
using System;
<strong class="bold">using System.Collections.Concurrent;</strong>
using System.Threading;
<code>AcknowledgeChallenge</code> function will call a method named <code>Respond</code>. The <code>Respond</code> method will remove <code>ChallengeRecord</code> from the dictionary, if it exists, and <a id="_idIndexMarker958"/>return the associate <code>Challenge</code>. If there is no <code>ChallengeRecord</code>, then a new empty <code>Challenge</code> record is returned, as shown in the following code:<pre class="source-code">
public Challenge Respond(Guid id, ChallengeResponse response){    if (handlers.TryRemove(id, out var res))    {        var challenge = res.Challenge;        challenge.Response = response;        res.ResponseTask.TrySetResult(challenge);        return challenge;    }    return new Challenge();}</pre></li> <li>The <code>CheckAcks</code> method, which is called periodically to check for <code>Challenge</code> objects that have expired and have not been responded to, looks like this:<pre class="source-code">
private void CheckAcks(){    foreach (var pair in handlers)    {        var elapsed = DateTime.UtcNow - pair.Value.Created;        if (elapsed &gt; ackThreshold)        {            pair.Value.ResponseTask.TrySetException(new TimeoutException("Response time out"));        }    }}</pre><p class="list-inset">This method will iterate over all the pairs in the <code>handlers</code> dictionary. For each one, it will determine whether the elapsed time is greater than the threshold provided in the constructor. If it is, then the task fails with a <code>TimeOutException</code> error.</p></li> <li>To wrap <a id="_idIndexMarker959"/>up this class, we need to make sure that we clean up any remaining tasks when the service shuts down. We will handle canceling tasks in a <code>Dispose</code> method, which is implemented via the <code>IDisposable</code> interface. Add the <code>IDisposable</code> interface to the <code>ChallengeHandler</code> class and add the following <code>Dispose</code> method to the end of the class:<pre class="source-code">
public void Dispose(){    timer?.Dispose();    foreach (var pair in handlers)    {        pair.Value.ResponseTask.TrySetCanceled();    }}</pre><p class="list-inset">The <code>Dispose</code> method will dispose of the timer since we don’t want that firing any longer. Then, it iterates over the handlers and cancels each of the tasks.</p></li> </ol>
<p>That should complete the <code>ChallengeHandler</code> class. We can now resume the implementation of the <code>IssueChallenge</code> function:</p>
<ol>
<li>Open the <code>GameHub.cs</code> file and locate the constructor, modifying it as highlighted in the following code:<pre class="source-code">
private readonly GameDbContext context;<strong class="bold">private readonly ChallengeHandler challengeHandler;</strong>
public GameHub(GameDbContext dbcontext<strong class="bold">, ChallengeHandler handler</strong>){    context = dbcontext;    <strong class="bold">challengeHandler = handler;</strong>
}</pre><p class="list-inset">Since we will need the <code>ChallengeHandler</code> class, and it needs to maintain state, we will use dependency injection and have the Azure Functions runtime supply us with the instance.</p></li> <li>Open the <code>Startup.cs</code> file in the <code>SticksAndStones.Function</code> project and add the following line of code at the end of the <code>Configure</code> method:<pre class="source-code">
builder.Services.AddSingleton&lt;ChallengeHandler&gt;();</pre><p class="list-inset">This will <a id="_idIndexMarker960"/>register <code>ChallengeHandler</code> with dependency injection to allow the Azure Functions runtime to manage the instance creation and lifetime.</p></li> <li>Open the <code>GameHub.cs</code> file and navigate to the bottom of the <code>IssueChallenge</code> function.</li>
<li>Add the following lines of code:<pre class="source-code">
var challengeInfo = challengeHandler.CreateChallenge(challenger, opponent);log.LogInformation($"Challenge [{challengeInfo.id}] has been created.");
log.LogInformation($"Waiting on response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");await Clients.User(opponent.Id.ToString()).SendAsync(Constants.Events.Challenge, new ChallengeEventArgs(challengeInfo.id, challenger, opponent));</pre><p class="list-inset">This code will first call <code>CreateChallenge</code> using the <code>ChallengeHandler</code> instance that we are getting in the constructor. <code>challengeInfo</code> is a <code>Tuple</code> value of the <code>Challenge</code> <code>Id</code> type and <code>task</code>.</p><p class="list-inset">Next, the opponent is sent a SignalR <code>Challenge</code> message with <code>ChallengeEventArgs</code>. This message is sent slightly differently since this message will only be sent to the client that matches the opponent’s <code>Id</code>.</p></li> <li>Now, we <a id="_idIndexMarker961"/>need to wait for the opponent’s response, or a timeout from <code>ChallengeHandler</code>, by using the following code:<pre class="source-code">
ChallengeResponse response;try {    var challenge = await challengeInfo.responseTask.ConfigureAwait(false);    log.LogInformation($"Got response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");    response = challenge.Response;}catch {    log.LogInformation($"Never received a response from {opponent.GamerTag} for challenge[{challengeInfo.id}], it timed out.");    response = ChallengeResponse.TimeOut;}return new(response);</pre><p class="list-inset">The real trick in this code is the <code>challengeInfo.responseTask</code> await. <code>responseTask</code> is the task that is created as part of <code>TaskCompletionSource</code> in <code>ChallengeHandler</code>. By awaiting it, we do not continue until either the <code>Respond</code> method is called and the task is completed, or the task is failed by setting a <code>TimeoutException</code> error in the <code>CheckAcks</code> method of <code>ChallengeHandler</code>.</p><p class="list-inset">Once one of those conditions is <code>true</code>, the method completes and we can get the response from the returned <code>Challenge</code>, or in the case of a timeout, handle the exception and return the response to the client in a new instance of <code>IssueChallengeResponse</code>.</p></li> </ol>
<p>The <code>IssueChallenge</code> function is now complete. The client can call the function and it will send a message to the opponent’s client and wait for the response. If the opponent <a id="_idIndexMarker962"/>client does not respond in a defined amount of time, which is 30 seconds by default, then the challenge will time out. Now, let’s work on accepting or declining a challenge. As with the <code>Connect</code> function, you can try it out using the command line. You just need to connect two players, and then have one challenge the other!</p>
<h3>Creating the AcknowledgeChallenge function</h3>
<p>The <code>AcknowledgeChallenge</code> function is used by the client to respond to an open challenge <a id="_idIndexMarker963"/>from another player. Let’s create the function by following these steps:</p>
<ol>
<li>Add a new function to the <code>GameHub</code> class, as follows:<pre class="source-code">
[FunctionName("AcknowledgeChallenge")]public async Task AcknowledgeChallenge(    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Challenge/Ack")] HttpRequest req,    ILogger log)
{}</pre></li> <li>In the body of the function, deserialize the arguments using the following line of code:<pre class="source-code">
var result = await JsonSerializer.DeserializeAsync&lt;AcknowledgeChallengeRequest&gt;(req.Body, jsonOptions);</pre></li> <li>Use <code>challengeHandler</code> to <code>Respond</code> to the challenge:<pre class="source-code">
var challenge = challengeHandler.Respond(result.Id, result.Response);if (challenge.Id == Guid.Empty){    return;}</pre></li> <li>If the <a id="_idIndexMarker964"/>response is <code>Declined</code>, then just log a message:<pre class="source-code">
var challenger = challenge.Challenger;var opponent = challenge.Opponent;if (result.Response == ChallengeResponse.Declined){    log.LogInformation($"{opponent.GamerTag} has declined the challenge from {challenger.GamerTag}!");}</pre></li> <li>If the response is <code>Accepted</code>, then create a match and notify the players:<pre class="source-code">
if (result.Response == ChallengeResponse.Accepted)
{
    log.LogInformation($"{opponent.GamerTag} has accepted the challenge from {challenger.GamerTag}!");
    using var context = contextFactory.CreateDbContext();
    var game = Match.New(challenger.Id, opponent.Id);
    context.Matches.Add(game);
    opponent.MatchId = challenger.MatchId = match.Id;
    context.Players.Update(opponent);
    context.Players.Update(challenger);
    context.SaveChanges();
    log.LogInformation($"Created match {match.Id} between {opponent.GamerTag} and {challenger.GamerTag}!");
    // Create Group for Game
    await UserGroups.AddToGroupAsync(opponent.Id.ToString(), $"Match[{match.Id}]");
    await UserGroups.AddToGroupAsync(challenger.Id.ToString(), $"Match[{match.Id}]");
    await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchStarted, new MatchStartedEventArgs(match));
    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(opponent));
    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(challenger));
}</pre><p class="list-inset">So, ignoring all the logging, since that is non-functional, the preceding code starts by <a id="_idIndexMarker965"/>creating a new <code>Match</code> instance and assigning <code>PlayerOneId</code>, <code>PlayerTwoId</code>, and <code>NextPlayerId</code>. The <code>Match</code> object’s <code>Id</code> property is then assigned to both of the players, and all the changes are saved to the database.</p><p class="list-inset">Next, is the SignalR messages. First, we create a SignalR group with just the two players in it and use the <code>Match</code> object’s <code>Id</code> property in the name. This way we can send messages to the group and both players will receive them.</p><p class="list-inset">The first message we will send will indicate the start of a new game and it will send the <code>match</code> instance wrapped in <code>MatchStartedEventArgs</code>.</p><p class="list-inset">Finally, we send a message for each player to all players, indicating a change in their status.</p></li> </ol>
<p>That completes the functionality for one player to challenge another player to a match of Sticks and Stones! It’s time to move on to playing a match. But first, we will need a function to return the game to the player.</p>
<h3>Getting the match</h3>
<p>You may be wondering why we need this functionality since, in the previous function, we sent the <code>Match</code> object to both players through a SignalR message. The answer is rather simple – if the user accidentally closes the Sticks and Stones app while in the middle of a game, then when they <a id="_idIndexMarker966"/>return to the Sticks and Stones app and log back in, the app will detect that they are still in a match and navigate to the <code>Match</code> page. It will use this function to retrieve the <code>Match</code> object in this case since it wasn’t sent during <code>Connect</code>, just <code>Id</code>.</p>
<p>So, let’s create a function to return a game by its <code>Id</code>, starting with the messages.</p>
<h3>Creating the messages</h3>
<p>This function <a id="_idIndexMarker967"/>will only need a response message object. Unlike the previous functions, the <code>GetMatch</code> function will use the <code>Http</code> GET method, and we will pass the match <code>Id</code> value as part of the URL. The response from the <code>GetGame</code> function will be the <code>Match</code> instance. To create the <code>GetGameResponse</code> message, follow these steps:</p>
<ol>
<li>In the <code>SticksAndStones.Shared</code> project, create a new file named <code>GetGameMessages.cs</code> in the <code>Messages</code> folder.</li>
<li>Modify the contents of the file so that it’s as follows:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct GetMatchResponse(Match Match);</pre></li> </ol>
<p>With the response message class in place, we can create the <code>GetMatch</code> function.</p>
<h3>Getting a match by its ID</h3>
<p>The <code>GetMatch</code> function will accept a single integer named <code>id</code> as a parameter. The parameter <a id="_idIndexMarker968"/>is bound to a part of the URL that’s used to call the function. Let’s look at an example. If we wanted to get <code>Match</code> identified by a <code>Guid</code> type of <code>c39c7490-f4bc-425a-84ab-0a4ad916ea48</code>, then the URL would be <code>http://localhost:7024/api/Game/c39c7490-f4bc-425a-84ab-0a4ad916ea48</code>.</p>
<p>Follow these steps to implement the <code>GetMatch</code> function:</p>
<ol>
<li>Open the <code>GameHub.cs</code> file in the <code>Hubs</code> folder of the <code>SticksAndStones.Functions</code> project.</li>
<li>Add the following method declaration after the <code>AcknowledgeChallenge</code> method:<pre class="source-code">
[FunctionName("GetMatch")]
public IActionResult GetMatch(
[HttpTrigger(AuthorizationLevel.Function, "get", Route = 
"Match/{id}")] HttpRequest req,
    Guid id,    ILogger log){}</pre><p class="list-inset">There are a few differences from the other functions. First, the <code>Http</code> method that’s used is <code>"get"</code>, not <code>"post"</code>. Second, <code>Route</code> is set to <code>"Game/{id}"</code>; <code>{id}</code> in <code>Route</code> tells the Azure Functions runtime that this function has a parameter named <code>id</code> and that the value in that position of the URL should be passed in as an argument. You can see that the third change is that there is an <code>id</code> parameter of the <code>Guid</code> type. This means that whatever is on the URL in the <code>{id}</code> position must be able to be converted into the <code>Guid</code> type; otherwise, the Azure Functions runtime will return an HTTP <code>500 Internal </code><code>Server</code> error.</p></li> <li>To query our database for the <code>Match</code> object that matches the <code>id</code> value, use the following lines of code:<pre class="source-code">
using var context = contextFactory.CreateDbContext();Match match = (from m in context.Matches where m.Id == id select m).FirstOrDefault();</pre></li> <li>If the method gets this far, then it has been completed successfully, so we can return <code>OkObjectResult</code>. The object that’s returned will be a <code>GetMatchResponse</code> instance with the <code>Match</code> instance that was found, or <code>null</code>:<pre class="source-code">
return new OkObjectResult(new GetMatchResponse(match));</pre></li> </ol>
<p>Since this <a id="_idIndexMarker969"/>function uses the HTTP GET method, you can test it out in your favorite browser:</p>
<ol>
<li>Press <em class="italic">F5</em> to start the project in debug mode.</li>
<li>Wait for txhe service to start, then copy the URL for the <code>GetMatch</code> function from the output window – for example, http://localhost:####/api/Game/{id}, where <code>###</code> is your port number.</li>
<li>Open your browser and paste the URL in the address bar.</li>
<li>Change <code>{id}</code> to anything.</li>
<li>Press <em class="italic">Enter</em>.<p class="list-inset">You should get an error page in your browser. Try a valid <code>Guid</code> value such as <code>c39c7490-f4bc-425a-84ab-0a4ad916ea48</code>. You should get a response similar to the following:</p><pre class="source-code">
{    "match": null }</pre><p class="list-inset">Since there are no active games, you won’t be able to retrieve an actual <code>Match</code> instance.</p></li> </ol>
<p>Now that we can retrieve the <code>Match</code> object, we will tackle how players make and receive moves and how to determine the score and winner of the game.</p>
<h3>Playing the game</h3>
<p>Sticks and Stones is an interactive, fast-paced, turn-based game. </p>
<p>Let's review the following diagram to get a better understanding of what we are building:</p>
<div><div><img alt="Figure 9.11 – Processing turns" src="img/B19214_09_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Processing turns</p>
<p>Once a match has started, players will take turns choosing a location to place one of their sticks. The client <a id="_idIndexMarker970"/>application will then send a message to the GameHub’s <code>ProcessTurn</code> function. The <code>ProcessTurn</code> function will then validate the move, recalculate the score, check for a winner, and finally, send an update to the players.</p>
<h4>Creating the ProcessTurn messages and models</h4>
<p>The <code>ProcessTurn</code> function has three parameters – the <code>Match Id</code>, the player making the move, and <a id="_idIndexMarker971"/>the position of the move. The function will return an updated <code>Match</code> instance. Follow these steps to add the <code>ProcessTurn</code> messages:</p>
<ol>
<li>Add a new file named <code>ProcessTurnMessages.cs</code> to the <code>Messages</code> folder in the <code>SticksAndStones.Shared</code> project.</li>
<li>Modify the contents of the file so that it looks as follows:<pre class="source-code">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct ProcessTurnRequest(Guid MatchId, Player Player, int Position);
public record struct ProcessTurnResponse(Match Match);</pre></li> </ol>
<p>As part of the turn, <code>ProcessTurn</code> will send the updated <code>Match</code> instance to the players. This will require a new SignalR event. Perform the following steps to add it:</p>
<ol>
<li><code>SaveMatchAndSendUpdates</code> sends a new event via SignalR to the clients, so we need to add that to our constants. Add the highlighted code in the following snippet to the <code>Constants.cs</code> file in the <code>SticksAndStones.Shared</code> project:<pre class="source-code">
    public static class Events     {        public static readonly string PlayerUpdated = nameof(PlayerUpdated);        public static readonly string Challenge = nameof(Challenge);        public static readonly string MatchStarted = nameof(MatchStarted);
        public static readonly string MatchUpdated = nameof(MatchUpdated);
    }</pre></li> <li>Add the <code>MatchUpdatedEventArgs</code> class that we used to send the updated <code>Match</code> to the players when the <code>MatchUpdated</code> event is set by adding a new file named <code>MatchUpdatedEventArgs.cs</code> to the <code>Messages</code> folder in the <code>SticksAndStones.Shared</code> project.</li>
<li>Modify the contents of the file so that it’s as follows:<pre class="source-code">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct MatchUpdatedEventArgs(Match Match);</pre></li> </ol>
<p>That <a id="_idIndexMarker972"/>concludes the additional models, events, and messages that are used by the <code>ProcessTurn</code> function. Next, we can start working on the ProcessTurn (P-Code) function.</p>
<h4>Processing turns</h4>
<p>The <code>ProcessTurn</code> function <a id="_idIndexMarker973"/>has a few responsibilities. It will need to do the following:</p>
<ul>
<li>Validate the turn</li>
<li>Make the necessary changes to the <code>Match</code> object</li>
<li>Recalculate the score</li>
<li>Determine whether there is a winner</li>
<li>Notify the players</li>
</ul>
<p>To start the <a id="_idIndexMarker974"/>implementation of the <code>ProcessTurn</code> function, we will create stubs for each of the methods that we will call when processing a turn. Follow these steps to create the method stubs:</p>
<ol>
<li>Add a new method declaration to the <code>GameHub</code> class for the <code>ProcessTurn</code> function:<pre class="source-code">
[FunctionName("ProcessTurn")]public async Task&lt;IActionResult&gt; ProcessTurn(
    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Game/Move")] HttpRequest req,
    ILogger log)
{}</pre></li> <li>Add a new method declaration for <code>ValidateProcessTurnRequest</code>:<pre class="source-code">
private Exception ValidateProcessTurnRequest(ProcessTurnRequest args)
{    return null;}</pre><p class="list-inset">The method accepts <code>ProcessTurnRequest</code> as the only argument. If there are no errors in the arguments, then it will default to returning <code>null</code>. If there is an error, then it will return an <code>Exception</code> error.</p></li> <li>We will use another method to verify the match state before processing the move. Create a new method in the <code>GameHub</code> class named <code>VerifyMatchState</code>, as follows:<pre class="source-code">
private Exception VerifyMatchState(Match match, ProcessTurnRequest args)
{    return null;}</pre><p class="list-inset">Just like with <code>ValidateProcessTurnRequest</code>, we will return <code>null</code> for the error if everything is okay; otherwise, we will return an error.</p></li> </ol>
<p>Now that we <a id="_idIndexMarker975"/>have the helper method signatures in place, let’s implement them, starting with <code>ValidateProcessTurnRequest</code>. Follow these steps to add the implementation to <code>ValidateProcessTurnRequest</code>:</p>
<ol>
<li>In <code>ValidateProcessTurnRequest</code>, add the following at the top of the method to check for a valid position:<pre class="source-code">
if (args.Position &lt;= 0 || args.Position &gt; 23)
{
    return new IndexOutOfRangeException("Position is out of range, must be between 1 and 24");}</pre></li> <li>In <code>ValidateProcessTurnRequest</code>, add the following at the top of the method to check for a valid player:<pre class="source-code">
if (args.Player is null){    return new ArgumentException("Invalid Player");}</pre></li> <li>In <code>ValidateProcessTurnRequest</code>, add the following at the top of the method to check for a valid game <code>Id</code> value:<pre class="source-code">
if (args.MatchId == Guid.Empty){
    return new ArgumentException("Invalid MatchId");}</pre></li> </ol>
<p>That <a id="_idIndexMarker976"/>completes the <code>ValidateProcessTurnRequest</code> method. Now, we can add the code to <code>VerifyMatchState</code>, as follows:</p>
<ol>
<li>In <code>VerifyMatchState</code>, add the following at the top of the method to check that the position hasn’t already been played:<pre class="source-code">
if (match.Sticks[args.Position] != 0){    return new ArgumentException($"Position [{args.Position}] has already been played");}</pre></li> <li>In <code>VerifyMatchState</code>, add the following at the top of the method to check that the correct player is taking their turn:<pre class="source-code">
if (args.Player.Id != game.NextPlayerId){    return new ArgumentException($"It is not {args.Player.GamerTag}'s turn");}</pre></li> <li>In <code>VerifyMatchState</code>, add the following at the top of the method to check that the game isn’t over already:<pre class="source-code">
if (match.WinnerId != Guid.Empty){    return new ArgumentException("Match is complete");}</pre></li> <li>In <code>VerifyMatchState</code>, add the following at the top of the method to check that the game object exists:<pre class="source-code">
if (match is null)
{
    return new ArgumentException("Invalid MatchId");
}</pre></li> </ol>
<p>Now that <a id="_idIndexMarker977"/>we have created these helper methods, we can implement the <code>ProcessTurn</code> method by following these steps:</p>
<ol>
<li>Deserialize the arguments that are passed to the <code>ProcessTurn</code> function using <code>JsonSerializer</code>, as follows:<pre class="source-code">
var args = await JsonSerializer.DeserializeAsync&lt;ProcessTurnRequest&gt;(req.Body, jsonOptions);</pre></li> <li>In the <code>ProcessTurn</code> method, we can call <code>ValidateProcessTurnRequest</code>. If there is an error, we can handle it, as follows:<pre class="source-code">
var error = ValidateProcessTurnRequest(args);
if (error is not null)
{
    log.LogError(error, "Error validating turn request");
    return new BadRequestObjectResult(error);
}</pre></li> <li>With the arguments verified, we can query the database for the game, and fail if it doesn’t exist:<pre class="source-code">
using var context = contextFactory.CreateDbContext();
var game = (from g in context.Matches where m.Id == args.MatchId select m).FirstOrDefault() ?? throw new ArgumentException("Invalid MatchId.");</pre></li> <li>Now, we can call <code>VerifyGameState</code>. If there is an error, we can handle it, as follows:<pre class="source-code">
error = VerifyGameState(game, args);
if (error is not null)
{
    log.LogError(error, "Error validating game state");
    return new BadRequestObjectResult(error);
}</pre></li> <li>We must <a id="_idIndexMarker978"/>do one final check before making the move and updating the scores – we need to check to see whether the player made their selection before their turn expired using the following code:<pre class="source-code">
if (turnHandler.EndTurn(args.GameId) == TurnHandler.TurnStatus.Forfeit)
{
    error = new ArgumentException($"The turn has expired.");
    log.LogError(error, $"Player did not respond in the time alloted.");
    return new BadRequestObjectResult(error);
}</pre></li> </ol>
<p>With the validation of the input and game out of the way, we can now focus on applying the player’s move to the current state of the game, updating the score, and determining a winner. To make the code for updating the score simpler, we will need a complex data structure. Let’s explore this further.</p>
<p>When a player chooses a location to place one of their sticks, it may complete a square. If it does, then the player who placed the stick gets the square and an additional five points. The trick is how to determine that a stick has completed a square. We are storing the state of all sticks and stones as an array of integers. What we need is a map from a stone index (0–8) to the sticks that make up its sides. But we can simplify the logic a bit more once we know what sticks make up a square since we are only interested in a single stick, and a single stick can complete, at most, two squares. So, we can now have a structure <a id="_idIndexMarker979"/>that maps each stick position (0–23) to an array of tuples. Each tuple has an integer that is the index for the stone and another integer array that is the other three stick indexes that make up the square.</p>
<p>Let’s use an example to illustrate this. Pretend that we have a game that’s in the following state:</p>
<div><div><img alt="Figure 9.12 – Sample view of the board game" src="img/B19214_09_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Sample view of the board game</p>
<p>Now, pretend <a id="_idIndexMarker980"/>that a player has chosen to place their stick at location 9, highlighted in aqua:</p>
<div><div><img alt="Figure 9.13 – Board game with stick placement highlighted" src="img/B19214_09_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Board game with stick placement highlighted</p>
<p>We will <a id="_idIndexMarker981"/>only need to check the two squares highlighted in brown. This means that we need to check whether there are sticks in positions 2, 5, and 6 for the stone in the upper brown box, and 12, 13, and 16 for the stone in the lower brown box.</p>
<p>This means we need two tuples – one for stone 2 and a second for stone 5 – each with an array of integers of the sides – f example, { (2, {2, 5, 6} ), (5, {12, 13, 16) }. Using that data, we can check the two possible squares that could be completed by placing a stick at position 9.</p>
<p>Using old-fashioned sticky notes with a pencil and eraser, we can determine that the complete mapping will look like this:</p>
<pre class="source-code">
(int stone, int[] sticks)[][] stickToStoneMap = new (int, int[])[][] {/* 1 */ new (int, int[])[] { (1, new int[] { 4, 5, 8}), (0, new int[] { 0, 0, 0})},/* 2 */ new (int, int[])[] { (2, new int[] { 5, 6, 9}), (0, new int[] { 0, 0, 0})},/* 3 */ new (int, int[])[] { (3, new int[] { 6, 7,10}), (0, new int[] { 0, 0, 0})},/* 4 */ new (int, int[])[] { (1, new int[] { 1, 5, 8}), (0, new int[] { 0, 0, 0})},/* 5 */ new (int, int[])[] { (1, new int[] { 1, 4, 8}), (2, new int[] { 2, 6, 9})},/* 6 */ new (int, int[])[] { (2, new int[] { 2, 5, 9}), (3, new int[] { 3, 7,10})},/* 7 */ new (int, int[])[] { (3, new int[] { 3, 6,10}), (0, new int[] { 0, 0, 0})},/* 8 */ new (int, int[])[] { (1, new int[] { 1, 4, 5}), (4, new int[] {11,12,15})},/* 9 */ new (int, int[])[] { (2, new int[] { 2, 5, 6}), (5, new int[] {12,13,16})},/*10 */ new (int, int[])[] { (3, new int[] { 3, 6, 7}), (6, new int[] {13,14,17})},/*11 */ new (int, int[])[] { (4, new int[] { 8,12,15}), (0, new int[] { 0, 0, 0})},/*12 */ new (int, int[])[] { (4, new int[] { 8,11,15}), (5, new int[] { 9,13,16})},/*13 */ new (int, int[])[] { (5, new int[] { 9,12,16}), (6, new int[] {10,14,17})},/*14 */ new (int, int[])[] { (6, new int[] {10,13,17}), (0, new int[] { 0, 0, 0})},/*15 */ new (int, int[])[] { (4, new int[] { 8,11,12}), (7, new int[] {18,19,22})},/*16 */ new (int, int[])[] { (5, new int[] { 9,12,13}), (8, new int[] {19,20,23})},/*17 */ new (int, int[])[] { (6, new int[] {13,14,17}), (9, new int[] {20,21,24})},/*18 */ new (int, int[])[] { (7, new int[] {15,19,22}), (0, new int[] { 0, 0, 0})},/*19 */ new (int, int[])[] { (7, new int[] {15,18,22}), (8, new int[] {16,20,23})},/*20 */ new (int, int[])[] { (8, new int[] {16,19,23}), (9, new int[] {17,21,24})},/*21 */ new (int, int[])[] { (9, new int[] {17,20,24}), (0, new int[] { 0, 0, 0})},/*22 */ new (int, int[])[] { (7, new int[] {15,18,19}), (0, new int[] { 0, 0, 0})}, /*23 */ new (int, int[])[] { (8, new int[] {16,19,20}), (0, new int[] { 0, 0, 0})},/*24 */ new (int, int[])[] { (9, new int[] {17,20,21}), (0, new int[] { 0, 0, 0})},};</pre> <p>Add the <a id="_idIndexMarker982"/>preceding code to the <code>GameHub</code> class after the <code>turnHandler</code> field declaration. Now that we have declared the data structure for finding completed boxes, let’s continue processing the turn:</p>
<ol>
<li>Return the <code>ProcessTurn</code> method, and add the following code at the end:<pre class="source-code">
match.Sticks[args.Position] = args.Player.Id == match.PlayerOneId ? 1 : -1;</pre><p class="list-inset">This will assign the position <code>-1</code> or <code>1</code>, depending on who the active player is. We will use a value of <code>-1</code> and <code>1</code> later in determining a winner, in the case of three stones in a row.</p></li> <li>Now that we have placed the stick, we need to adjust the player’s score, as follows:<pre class="source-code">
if (args.Player.Id == game.PlayerOneId){    match.PlayerOneScore += 1;}else {    match.PlayerTwoScore += 1;}</pre></li> <li>The following code will use the data structure from earlier to determine whether placing the stick completed any squares:<pre class="source-code">
// Determine if this play creates a square
foreach (var tuple in stickToStoneMap[args.Position])
{
    if (tuple.stone == 0) continue;
    var stickCompletesABox = 
    (
        Math.Abs(match.Sticks[tuple.sticks[0] - 1]) + 
        Math.Abs(match.Sticks[tuple.sticks[1] - 1]) + 
        Math.Abs(match.Sticks[tuple.sticks[2] - 1])
    ) == 3;
    if (stickCompletesABox)
    {
        // If so, place stone, and adjust score
        var player = args.Player.Id == match.PlayerOneId ? 1 : -1;
        match.Stones[tuple.stone - 1] = player;
        if (player &gt; 0)
        {
            match.PlayerOneScore += 5;
        }
        else
        {
            match.PlayerTwoScore += 5;
        }
    }
}</pre><p class="list-inset">This code will iterate over the tuples declared at the array position of the newly placed stick, adjusting for C# arrays being 0-based. It will then use the array of stick positions from the tuple to index into the array of sticks in the match The value at <a id="_idIndexMarker983"/>that location will be either <code>1</code> for player one, <code>-1</code> for player two, or <code>0</code> for unclaimed. We can add the absolute value of all three locations and if it is 3, then the newly placed stick completes a box. If so, then assign the stone location from the tuple, adjusting for 0-based arrays again, to the player, and give them five points.</p></li> <li>To help determine whether the match is over, we are going to use a couple of helper functions to make the code cleaner and easier to read. The first of those returns a <code>boolean</code> value if all the sticks have been played in the match. Add the following code to the end of the <code>GameHub</code> class:<pre class="source-code">
private static bool AllSticksHaveBeenPlayed(Match match)
{
    return !(from s in match.Sticks where s == 0 select s).Any();
}</pre><p class="list-inset">This function uses a straightforward LINQ query to search the <code>Sticks</code> array for any element that has a value of <code>0</code>, meaning unclaimed. If there are, the function returns.</p></li> <li>The next function is a little more complex as it is used to determine whether a player has three <a id="_idIndexMarker984"/>stones in a row, either horizontally, vertically, or diagonally, and returns the <code>Id</code> value of the player that does. Add the following code to the end of the <code>GameHub</code> class:<pre class="source-code">
private static int HasThreeInARow(List&lt;int&gt; stones){    for (var rc = 0; rc &lt; 3; rc++)    {        var rowStart = rc * 3;        var rowValue = stones[rowStart] + stones[rowStart + 1] + stones[rowStart + 2];        if (Math.Abs(rowValue) == 3) // we Have a winner!        {            return rowValue;        }        var colStart = rc;        var colValue = stones[colStart] + stones[colStart + 3] + stones[colStart + 6];        if (Math.Abs(colValue) == 3) // We have a winner!        {            return colValue ;        }    }    var tlbrValue = stones[0] + stones[4] + stones[8];    var trblValue = stones[2] + stones[4] + stones[6];    if (Math.Abs(tlbrValue) == 3) { return tlbrValue; }    if (Math.Abs(trblValue) == 3) { return trblValue; }    return 0;}</pre><p class="list-inset">This method starts by checking all the rows and columns for 3 stones in a row, for the same player. Since there are nine stones arranged in a 3x3 grid, we only need to check three columns and three rows. Using a single iterator, each row or column is checked by adding the values stored at each position in <a id="_idIndexMarker985"/>the row or column and if the absolute value of the sum is 3, then a single player has a winning row. If the sum is positive, player one has won; otherwise, player two has won. Since there are only two possible diagonals, those checks use the same logic but are done individually, rather than looping.</p></li> <li>Now, we can use those two functions to determine whether there is a winner. To do so, we can use the following code at the end of the <code>ProcessTurn</code> function:<pre class="source-code">
// Does one player have 3 stones in a row?
var winner = Guid.Empty;
var threeInARow = HasThreeInARow(match.Stones);
if (threeInARow != 0)
    winner = threeInARow &gt; 0 ? match.PlayerOneId : match.PlayerTwoId;
if (winner == Guid.Empty) // No Winner yet
{
    // Have all sticks been played, if yes, use top score.
    if (HaveAllSticksBeenPlayed(match))
    {
        winner = match.PlayerOneScore &gt; match.PlayerTwoScore ? match.PlayerOneId : match.PlayerTwoId;
    }
}</pre><p class="list-inset">Here, we use <a id="_idIndexMarker986"/>the two methods we just created to do the main checks and assign the winner. We capture the winner as the <code>Guid</code> type from the <code>Id</code> property of the <code>Player</code> class, so some translation is needed.</p></li> <li>Next, we can set the next player’s turn, or if there is a winner, complete the match, as follows:<pre class="source-code">
if (winner == Guid.Empty)
{
    match.NextPlayerId = args.Player.Id == match.PlayerOneId ? match.PlayerTwoId : match.PlayerOneId;
}
else
{
    match.NextPlayerId = Guid.Empty;
    match.WinnerId = winner;
    match.Completed = true;
}</pre></li> <li>The final steps are to save any changes we have made and send updates to the players. We will use a helper method called <code>SaveGameAndSendUpdates</code> to handle that as we will need the same code when a turn expires. Add the following code to the end of the <code>GameHub</code> class:<pre class="source-code">
private async Task SaveMatchAndSendUpdates(GameDbContext context, Match match)
{
    context.Matches.Update(match);
    await context.SaveChangesAsync();
    await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchUpdated, new MatchUpdatedEventArgs(match));
    if (match.Completed)
    {
        await UserGroups.RemoveFromGroupAsync(match.PlayerOneId.ToString(), $"Match[{match.Id}]");
        await UserGroups.RemoveFromGroupAsync(game.PlayerTwoId.ToString(), $"Match[{match.Id}]");
    }
}</pre></li> </ol>
<p>This function will save the current match state to the database, then sends a message to the SignalR group for the match indicating that there have been updates to the match. If the match is over, then we remove the players from the group.</p>
<ol>
<li>The following final three lines of code complete the <code>ProcessTurn</code> method:<pre class="source-code">
await SaveMatchAndSendUpdates(context, match);
return new OkObjectResult(new ProcessTurnResponse(match));</pre><p class="list-inset">After saving the match changes and notifying the players of the match updates, if the match is not over yet, we notify the next player that it is their turn to play. To wrap things up we return the updated match object back to the player that just made their move.</p></li> <li>We also need to call <code>SaveGameAndSendUpdates</code> when there is an error after calling <code>VerifyGameState</code>. Modify that section of code in <code>ProcessTurn</code> using the following snippet:<pre class="source-code">
error = VerifyMatchState(game, args);
if (error is not null)
{
    await SaveMatchAndSendUpdates(game);
    log.LogError(error, "Error validating match state.");
    return new BadRequestObjectResult(error);
}</pre></li> </ol>
<p>We have now completed all the required functions to connect a player to the service, challenge another player to a match, and then process each player’s turn and determine the winner.</p>
<p>Let’s take a short look back at what we have accomplished so far in this chapter. We started by creating the Azure services that our game server backend would need, a SignalR <a id="_idIndexMarker987"/>service for real-time communication, and finally, the Functions service to host our backend functions. We then implemented the Azure functions that would provide the functionality for our game:</p>
<ul>
<li><code>Connect</code>: To register players to the game service</li>
<li><code>IssueChallenge</code>: To allow one player to request a game with another player</li>
<li><code>AcknowledgeChallenge</code>: To accept or decline a request</li>
<li><code>ProcessTurn</code>: To manage the gameplay between two players and determine the winner</li>
</ul>
<p>Our backend is now complete, and we are ready to publish it to Azure so that we can consume the services from the game app in <em class="italic">Chapter 10</em>.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor865"/>Deploying the functions to Azure</h1>
<p>The final <a id="_idIndexMarker988"/>step in this chapter is to deploy the functions to Azure. You can do that as a part of a <strong class="bold">continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>) pipeline – for example, with Azure DevOps. But the easiest way to deploy the functions, in this case, is to do it directly from Visual Studio. Perform the following steps to deploy the functions:</p>
<ol>
<li>Right-click on the <code>SticksAndStones.Functions</code> project and select <strong class="bold">Publish</strong>.</li>
<li>Select <strong class="bold">Azure</strong> as the <a id="_idIndexMarker989"/>destination for publishing and click <strong class="bold">Next</strong>:</li>
</ol>
<div><div><img alt="Figure 9.14 – Target selection when publishing" src="img/B19214_09_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Target selection when publishing</p>
<ol>
<li value="3">Choose <strong class="bold">Azure Function App (Windows)</strong> in the <strong class="bold">Specific target</strong> tab, then click <strong class="bold">Next</strong>:</li>
</ol>
<div><div><img alt="Figure 9.15 – Container selection when publishing" src="img/B19214_09_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Container selection when publishing</p>
<ol>
<li value="4">Sign in to <a id="_idIndexMarker990"/>the same Microsoft account that we used in the Azure portal when we were creating the <strong class="bold">Function </strong><strong class="bold">App</strong> resource.</li>
<li>Select the subscription that contains the function app. All function apps we have in the subscription will now be loaded.</li>
<li>Select the function app and click <strong class="bold">Finish</strong>. If your app isn’t showing up, click <strong class="bold">Back</strong> and choose the <strong class="bold">Azure Function App (Linux)</strong> option as you may not have changed the default when creating the service in the <em class="italic">Creating the Azure service for </em><em class="italic">functions</em> section.</li>
<li>When the profile is created, click the <strong class="bold">Publish</strong> button.</li>
</ol>
<p>The following screenshot shows the last step. After that, the publishing profile will be created:</p>
<div><div><img alt="Figure 9.16 – Publishing Azure functions" src="img/B19214_09_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Publishing Azure functions</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor866"/>Summary</h1>
<p>In this chapter, we started by learning about a few Azure services, including SignalR, and Functions. Then, we created the services in Azure that our game server backend would need – a SignalR service for real-time communication, and finally, the Functions service to host our backend functions. After this, we implemented the Azure functions that would provide the functionality for our game.</p>
<p>We wrapped up this chapter by publishing our function code to the Azure Functions instance in Azure.</p>
<p>In the next chapter, we will build a game app that will use the backend we have built in this project.</p>
</div>
</body></html>