- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Control Flow and Collection Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流和集合类型
- en: One of the central duties of a computer is to control what happens when predetermined
    conditions are met. When you click on a folder, you expect it to open; when you
    type on the keyboard, you expect the text to mirror your keystrokes. Writing code
    for applications or games is no different—they both need to behave in a certain
    way in one state, and in another when conditions change. In programming terms,
    this is called control flow, which is apt because it controls the flow of how
    code is executed in different scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一项基本职责是控制当预定的条件满足时会发生什么。当你点击一个文件夹时，你期望它打开；当你敲击键盘时，你期望文本反映你的按键。为应用程序或游戏编写代码并无不同——它们都需要在一种状态下以某种方式表现，在另一种状态下当条件改变时也是如此。在编程术语中，这被称为控制流，这是恰当的，因为它控制了在不同场景中代码执行的流程。
- en: 'In addition to working with control statements, we''ll be taking a hands-on
    look at collection data types. Collections are a category of types that allow
    multiple values, and groupings of values, to be stored in a single variable. We''ll
    break the chapter down into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理控制语句外，我们还将亲手研究集合数据类型。集合是一类允许在单个变量中存储多个值和值组的类型。我们将把本章分解为以下主题：
- en: Selection statements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句
- en: Working with array, dictionary, and list collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组、字典和列表集合进行操作
- en: Iteration statements with `for`, `foreach`, and `while` loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`、`foreach`和`while`循环的迭代语句
- en: Fixing infinite loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决无限循环
- en: Selection statements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: The most complex programming problems can often be boiled down to sets of simple
    choices that a game or program evaluates and acts on. Since Visual Studio and
    Unity can't make those choices by themselves, writing out those decisions is up
    to us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的编程问题通常可以归结为游戏或程序评估并采取的简单选择集。由于Visual Studio和Unity不能自己做出这些选择，编写这些决策取决于我们。
- en: 'The `if-else` and `switch` selection statements allow you to specify branching
    paths, based on one or more conditions, and the actions you want to be taken in
    each case. Traditionally, these conditions include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`和`switch`选择语句允许你根据一个或多个条件指定分支路径，以及在每个情况下你想要采取的操作。传统上，这些条件包括以下内容：'
- en: Detecting user input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测用户输入
- en: Evaluating expressions and Boolean logic
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估表达式和布尔逻辑
- en: Comparing variables or literal values
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较变量或文字值
- en: You're going to start with the simplest of these conditional statements, `if-else`,
    in the following section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将开始使用这些条件语句中最简单的一种，`if-else`。
- en: The if-else statement
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if-else`语句'
- en: '`if-else` statements are the most common way of making decisions in code. When
    stripped of all its syntax, the basic idea is, *If my condition is met, execute
    this block of code; if it''s not, execute this other block of code*. Think of
    these statements as gates, or doors, with the conditions as their keys. To pass
    through, the key needs to be valid. Otherwise, entry will be denied and the code
    will be sent to the next possible gate. Let''s take a look at the syntax for declaring
    one of these gates.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`语句是代码中做出决策最常见的方式。当去掉所有的语法后，基本想法是，“如果我的条件满足，执行这个代码块；如果不满足，执行另一个代码块”。将这些语句想象成门，或者说是门，条件是它们的钥匙。要通行，钥匙必须是有效的。否则，将拒绝进入，代码将被发送到下一个可能的门。让我们看看声明这些门之一的语法。'
- en: 'A valid `if-else` statement requires the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的`if-else`语句需要以下内容：
- en: The `if` keyword at the beginning of the line
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行首的`if`关键字
- en: A pair of parentheses to hold the condition
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对括号来持有条件
- en: A statement body inside curly brackets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号内的语句体
- en: 'It looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Optionally, an `else` statement can be added to store the action you want to
    take when the `if` statement condition fails. The same rules apply for the `else`
    statement:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以添加`else`语句来存储当`if`语句条件失败时要采取的操作。对于`else`语句，同样适用：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In blueprint form, the syntax almost reads like a sentence, which is why this
    is the recommended approach:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式中，语法几乎就像一个句子，这就是为什么这是推荐的方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since these are great introductions to logical thinking, at least in programming,
    we''ll break down the three different `if-else` variations in more detail:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是逻辑思维的优秀介绍，至少在编程中，我们将更详细地分解三种不同的`if-else`变体：
- en: 'A single `if` statement can exist by itself in cases where you don''t care
    about what happens if the condition isn''t met. In the following example, if `hasDungeonKey`
    is set to `true`, then a debug log will print out; if set to `false`, no code
    will execute:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不需要关心条件不满足时会发生什么的情况下，单个`if`语句可以独立存在。在以下示例中，如果`hasDungeonKey`设置为`true`，则将打印调试日志；如果设置为`false`，则不会执行任何代码：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When referring to a condition as being met, I mean that it evaluates to true,
    which is often referred to as a passing condition.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当提到一个条件被满足时，我的意思是它评估为真，这通常被称为通过条件。
- en: 'Add an `else` statement in cases where an action needs to be taken whether
    the condition is true or false. If `hasDungeonKey` were `false`, the `if` statement
    would fail and the code execution would jump to the `else` statement:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要无论条件是否为真都要采取行动的情况下，添加一个没有条件的`else`语句。如果`hasDungeonKey`为`false`，则`if`语句将失败，代码执行将跳转到`else`语句：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For cases where you need to have more than two possible outcomes, add an `else-if`
    statement with its parentheses, conditions, and curly brackets. This is best shown
    rather than explained, which we'll do next.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于需要超过两种可能结果的情况，添加一个带有其括号、条件和花括号的`else-if`语句。这最好通过展示而不是解释来说明，我们将在下面这样做。
- en: Keep in mind that `if` statements can be used by themselves, but the other statements
    cannot exist on their own. You can also create more complex conditions with basic
    math operations, such as `>` (greater than), `<` (less than), `>=` (greater than
    or equal to), `<=` (less than or equal to), and `==` (equivalent). For example,
    a condition of (2 > 3) will return `false` and fail, while a condition of (2 <
    3) will return `true` and pass.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`if`语句可以单独使用，但其他语句不能单独存在。您还可以使用基本的数学运算创建更复杂的条件，例如`>`（大于）、`<`（小于）、`>=`（大于或等于）、`<=`（小于或等于）和`==`（等于）。例如，条件（2
    > 3）将返回`false`并失败，而条件（2 < 3）将返回`true`并通过。
- en: Don't worry too much about anything beyond this right now; you'll get your hands
    on this stuff soon enough.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必太担心这个范围之外的事情；你很快就会接触到这些内容。
- en: 'Let''s write out an `if-else` statement that checks the amount of money in
    a character''s pocket, returning different debug logs for three different cases—greater
    than `50`, less than `15`, and anything else:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`if-else`语句来检查角色口袋里的金额，为三种不同的情况返回不同的调试日志——大于`50`、小于`15`和任何其他情况：
- en: 'Open up `LearningCurve` and add a new public `int` variable, named `CurrentGold`.
    Set its value to between 1 and 100:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`并添加一个新的公共`int`变量，命名为`CurrentGold`。将其值设置为1到100之间：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a `public` method with no return value, called `Thievery`, and call it
    inside `Start`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的`public`方法，命名为`Thievery`，并在`Start`内部调用它。
- en: 'Inside the new function, add an `if` statement to check whether `CurrentGold`
    is greater than `50`, and print a message to the console if this is true:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新函数内部，添加一个`if`语句来检查`CurrentGold`是否大于`50`，如果这个条件为真，则在控制台打印一条消息：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add an `else-if` statement to check whether `CurrentGold` is less than `15`
    with a different debug log:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`else-if`语句来检查`CurrentGold`是否小于`15`，并使用不同的调试日志。
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add an `else` statement with no condition and a final default log:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个没有条件且为最终默认日志的`else`语句。
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file, check that your method matches the code below, and click on
    play:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，确保你的方法与下面的代码匹配，然后点击播放：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With `CurrentGold` set to `32` in my example, we can break down the code sequence
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，将`CurrentGold`设置为`32`，我们可以将代码序列分解如下：
- en: The `if` statement and debug log are skipped because `CurrentGold` is not greater
    than `50`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`CurrentGold`不是大于`50`，因此跳过了`if`语句和调试日志。
- en: The `else-if` statement and debug log are also skipped because `CurrentGold`
    is not less than `15`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`CurrentGold`不是小于`15`，因此跳过了`else-if`语句和调试日志。
- en: Since 32 is not less than 15 or greater than 50, neither of the previous conditions
    was met. The `else` statement executes and the third debug log is displayed:![](img/B17573_04_01.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于32既不小于15也不大于50，因此之前的条件都没有满足。执行`else`语句并显示第三个调试日志：![](img/B17573_04_01.png)
- en: 'Figure 4.1: Screenshot of the console showing the debug output'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.1：显示调试输出的控制台截图
- en: After trying out some other values for `CurrentGold` on your own, let's discuss
    what happens if we want to test a failing condition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己尝试了`CurrentGold`的其他值之后，让我们讨论如果我们想测试一个失败的条件会发生什么。
- en: Using the NOT operator
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NOT运算符
- en: 'Use cases won''t always require checking for a positive, or `true`, condition,
    which is where the `NOT` operator comes in. Written with a single exclamation
    point, the `NOT` operator allows negative, or false, conditions to be met by `if`
    or `else-if` statements. This means that the following conditions are the same:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有用例都需要检查正的或`true`条件，这就是`NOT`运算符发挥作用的地方。用单个感叹号表示的`NOT`运算符允许`if`或`else-if`语句满足负的或`false`条件。这意味着以下条件是相同的：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you already know, you can check for Boolean values, literal values, or expressions
    in an `if` condition. So, naturally, the `NOT` operator has to be adaptable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你可以在`if`条件中检查布尔值、字面值或表达式。因此，`NOT`运算符必须具有适应性。
- en: 'Take a look at the following example of two different negative values, `hasDungeonKey`
    and `weaponType`, used in an `if` statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例，其中在`if`语句中使用了两个不同的负值，`hasDungeonKey`和`weaponType`：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can evaluate each statement as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样评估每个语句：
- en: The first statement can be translated to, "If `hasDungeonKey` is `false`, the
    `if` statement evaluates to true and executes its code block."
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个语句可以翻译为：“如果`hasDungeonKey`为`false`，则`if`语句评估为真并执行其代码块。”
- en: 'If you''re asking yourself how a false value can evaluate to true, think of
    it this way: the `if` statement is not checking whether the value is true, but
    that the expression itself is true. `hasDungeonKey` might be set to false, but
    that''s what we''re checking for, so it''s true in the context of the `if` condition.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你自己在想一个假值如何评估为真，可以这样想：`if`语句不是检查值是否为真，而是检查表达式本身是否为真。`hasDungeonKey`可能被设置为`false`，但这是我们正在检查的，所以在`if`条件的上下文中它是真的。
- en: The second statement can be translated to, "If the string value of `weaponType`
    is `not equal` to `Longsword`, then execute this code block."
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个语句可以翻译为：“如果`weaponType`的字符串值不等于`Longsword`，则执行此代码块。”
- en: 'You can see the debug results in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中查看调试结果：
- en: '![](img/B17573_04_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_02.png)'
- en: 'Figure 4.2: Screenshot of the console showing the NOT operator output'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：显示`NOT`运算符输出的控制台屏幕截图
- en: However, if you're still confused, copy the code we've looked at in this section
    into `LearningCurve` and play around with the variable values until it makes sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你仍然感到困惑，请将本节中我们查看的代码复制到`LearningCurve`中，并尝试调整变量值，直到它变得有意义。
- en: So far, our branching conditions have been fairly simple, but C# also allows
    conditional statements to be nested inside each other for more complex situations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的分支条件相当简单，但C#也允许在更复杂的情况下将条件语句嵌套在彼此内部。
- en: Nesting statements
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套语句
- en: 'One of the most valuable functions of `if-else` statements is that they can
    be nested inside each other, creating complex logic routes through your code.
    In programming, we call them decision trees. Just like a real hallway, there can
    be doors behind other doors, creating a labyrinth of possibilities:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`语句最有价值的函数之一是它们可以嵌套在彼此内部，通过你的代码创建复杂的逻辑路径。在编程中，我们称之为决策树。就像现实中的走廊一样，门后面可能有门，从而创造出一个可能性迷宫：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s break down the preceding example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的示例：
- en: First, an `if` statement checks whether we have `weaponEquipped`. At this point,
    the code only cares whether it's `true`, not what type of weapon it is.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一个`if`语句检查我们是否有`weaponEquipped`。在这个时候，代码只关心它是否为`true`，而不是它是什么类型的武器。
- en: The second `if` statement checks the `weaponType` and prints out the associated
    debug log.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`if`语句检查`weaponType`并打印出相关的调试日志。
- en: If the first `if` statement evaluates to `false`, the code would jump to the
    `else` statement and its debug log. If the second `if` statement evaluates to
    `false`, nothing is printed because there is no `else` statement.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个`if`语句评估为`false`，代码将跳转到`else`语句及其调试日志。如果第二个`if`语句评估为`false`，则不会打印任何内容，因为没有`else`语句。
- en: The responsibility of handling logic outcomes is 100% on the programmer. It's
    up to you to determine the possible branches or outcomes your code can take.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 处理逻辑结果的责任完全在程序员身上。取决于你确定代码可能采取的可能分支或结果。
- en: What you've learned so far will get you through simple use cases with no problem.
    However, you'll quickly find yourself in need of more complex statements, which
    is where evaluating multiple conditions comes into play.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止学到的知识将帮助你处理没有问题的简单用例。然而，你很快就会发现自己需要更复杂的语句，这就是评估多个条件发挥作用的地方。
- en: Evaluating multiple conditions
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估多个条件
- en: 'In addition to nesting statements, it''s also possible to combine multiple
    condition checks into a single `if` or `else-if` statement with `AND` `OR` logic
    operators:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌套语句外，还可以使用 `AND` 和 `OR` 逻辑运算符将多个条件检查组合成一个单独的 `if` 或 `else-if` 语句：
- en: '`AND` is written with two ampersand characters, `&&`. Any condition using the
    `AND` operator means that all conditions need to evaluate to true for the `if`
    statement to execute.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND` 使用两个和号字符 `&&` 表示。任何使用 `AND` 运算符的条件都意味着所有条件都需要评估为真，`if` 语句才能执行。'
- en: '`OR` is written with two pipe characters, `||`. An `if` statement using the
    `OR` operator will execute if one or more of its conditions is true.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR` 使用两个管道字符 `||` 表示。使用 `OR` 运算符的 `if` 语句将在其中一个或多个条件为真时执行。'
- en: Conditions are always evaluated from left to right.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件总是从左到右进行评估。
- en: 'In the following example, the `if` statement has been updated to check for
    both `weaponEquipped` and `weaponType`, both of which need to be true for the
    code block to execute:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`if` 语句已被更新，以检查 `weaponEquipped` 和 `weaponType`，这两个条件都必须为真，代码块才能执行：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AND` `OR` operators can be combined to check multiple conditions in any
    order. There is also no limit on how many operators you can combine. Just be careful
    when using them together that you don't create logic conditions that will never
    execute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`AND` 和 `OR` 运算符可以组合起来以任意顺序检查多个条件。你还可以组合任意数量的运算符。但请注意，在使用它们时，不要创建永远不会执行的逻辑条件。'
- en: It's time to put everything we've learned so far about `if` statements to the
    test. So, review this section if you need to, and then move on to the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们到目前为止关于 `if` 语句所学的所有内容了。所以，如果你需要的话，回顾这一节，然后继续下一节。
- en: 'Let''s cement this topic with a little treasure chest experiment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小宝箱实验来巩固这个主题：
- en: 'Declare three variables at the top of `LearningCurve`: `PureOfHeart` is a `bool`
    and should be `true`, `HasSecretIncantation` is also a `bool` and should be `false`,
    and `RareItem` is a string and its value is up to you:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LearningCurve` 的顶部声明三个变量：`PureOfHeart` 是一个 `bool`，应该是 `true`，`HasSecretIncantation`
    也是一个 `bool`，应该是 `false`，而 `RareItem` 是一个字符串，其值由你决定：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a `public` method with no return value, called `OpenTreasureChamber`,
    and call it from inside `Start()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的 `public` 方法，命名为 `OpenTreasureChamber`，并在 `Start()` 内部调用它。
- en: 'Inside `OpenTreasureChamber`, declare an `if-else` statement to check whether
    `PureOfHeart` is `true` *and* that `RareItem` matches the string value you assigned
    to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OpenTreasureChamber` 内部声明一个 `if-else` 语句，检查 `PureOfHeart` 是否为 `true` 并且 `RareItem`
    是否与分配给它的字符串值匹配：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a nested `if-else` statement inside the first, checking whether `HasSecretIncantation`
    is `false`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个 `if-else` 语句内部创建一个嵌套的 `if-else` 语句，检查 `HasSecretIncantation` 是否为 `false`：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add debug logs for each `if-else` case.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个 `if-else` 情况添加调试日志。
- en: 'Save, check that your code matches the code below, and click play:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，检查你的代码是否与下面的代码匹配，然后点击播放：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you matched the variable values to the preceding screenshot, the nested
    `if` statement debug log will be printed out. This means that our code got past
    the first `if` statement checking for two conditions, but failed the third:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将变量值与前面的截图匹配，嵌套的 `if` 语句调试日志将被打印出来。这意味着我们的代码通过了检查两个条件的第一个 `if` 语句，但未能通过第三个：
- en: '![](img/B17573_04_03.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_03.png)'
- en: 'Figure 4.3: Screenshot of debut output in the console'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：控制台首次输出截图
- en: Now, you could stop here and use even bigger `if-else` statements for all your
    conditional needs, but that's not going to be efficient in the long run. Good
    programming is about using the right tool for the right job, which is where the
    `switch` statement comes in.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在所有条件需求上使用更大的 `if-else` 语句，但这从长远来看效率不高。好的编程是关于使用正确的工具来做正确的事情，这就是 `switch`
    语句的作用所在。
- en: The switch statement
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: '`if-else` statements are a great way to write decision logic. However, when
    you have more than three or four branching actions, they just aren''t feasible.
    Before you know it, your code can end up looking like a tangled knot that''s hard
    to follow, and a headache to update.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 语句是编写决策逻辑的好方法。然而，当你有超过三个或四个分支操作时，它们就不再可行了。很快，你的代码可能会变得像一团乱麻，难以跟踪，更新起来也头疼。'
- en: '`switch` statements take in expressions and let us write out actions for each
    possible outcome, but in a much more concise format than `if-else`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句接受表达式，并允许我们为每个可能的输出编写操作，但格式比 `if-else` 更简洁。'
- en: '`switch` statements require the following elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句需要以下元素：'
- en: The `switch` keyword followed by a pair of parentheses holding its condition
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 关键字后跟一对括号，括号内包含其条件'
- en: A pair of curly brackets
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对大括号
- en: 'A `case` statement for each possible path ending with a colon: individual lines
    of code or methods, followed by the `break` keyword and a semicolon'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个可能的以冒号结尾的路径创建一个 `case` 语句：单独的代码行或方法，后面跟着 `break` 关键字和分号
- en: 'A default `case` statement ending with a colon: individual lines of code or
    methods, followed by the `break` keyword and a semicolon'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以冒号结尾的默认 `case` 语句：单独的代码行或方法，后面跟着 `break` 关键字和分号
- en: 'In blueprint form, it looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式中，它看起来像这样：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The highlighted keywords in the preceding blueprint are the important bits.
    When a `case` statement is defined, anything between its colon and `break` keyword
    acts like the code block of an `if-else` statement. The `break` keyword just tells
    the program to exit the `switch` statement entirely after the selected `case`
    fires. Now, let's discuss how the statement determines which `case` gets executed,
    which is called pattern matching.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的蓝图中突出显示的关键字是重要的部分。当定义 `case` 语句时，其冒号和 `break` 关键字之间的任何内容都像 `if-else` 语句的代码块。`break`
    关键字只是告诉程序在选定的 `case` 执行后完全退出 `switch` 语句。现在，让我们讨论语句如何确定要执行哪个 `case`，这被称为模式匹配。
- en: Pattern matching
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配
- en: In `switch` statements, pattern matching refers to how a match expression is
    validated against multiple `case` statements. A match expression can be of any
    type that isn't null or nothing; all `case` statement values need to match the
    type of the match expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 语句中，模式匹配指的是如何将匹配表达式与多个 `case` 语句进行验证。匹配表达式可以是任何非空或无类型的类型；所有 `case`
    语句的值都需要与匹配表达式的类型匹配。
- en: For example, if we had a `switch` statement that was evaluating an integer variable,
    each `case` statement would need to specify an integer value for it to check against.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个评估整数变量的 `switch` 语句，每个 `case` 语句都需要指定一个整数值来检查。
- en: The `case` statement with a value that matches the expression is the one that
    is executed. If no `case` is matched, the default `case` fires. Let's try this
    out for ourselves!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与表达式匹配的 `case` 语句是执行的那个。如果没有 `case` 匹配，则触发默认 `case`。让我们亲自试试看！
- en: 'That was a lot of new syntax and information, but it helps to see it in action.
    Let''s create a simple `switch` statement for different actions a character could
    take:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多新的语法和信息，但看到它在实际中的应用会很有帮助。让我们创建一个简单的 `switch` 语句，用于不同角色可能采取的操作：
- en: Create a new string variable (member or local), named `CharacterAction`, and
    set it to `Attack:`
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的字符串变量（成员或局部变量），命名为 `CharacterAction`，并将其设置为 `Attack:`
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a `public` method with no return value called `PrintCharacterAction`,
    and call it inside `Start`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的 `public` 方法，命名为 `PrintCharacterAction`，并在 `Start` 中调用它。
- en: 'Declare a `switch` statement and use `CharacterAction` as the match expression:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `switch` 语句，并使用 `CharacterAction` 作为匹配表达式：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create two `case` statements for `Heal` and `Attack` with different debug logs.
    Don''t forget to include the `break` keyword at the end of each:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Heal` 和 `Attack` 创建两个 `case` 语句，并包含不同的调试日志。别忘了在每个语句的末尾包含 `break` 关键字：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add a default case with a debug log and `break:`
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有调试日志和 `break:` 的默认情况
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save the file, make sure your code matches the screenshot below, and click
    play:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，确保您的代码与下面的截图匹配，然后点击播放：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `CharacterAction` is set to `Attack`, the `switch` statement executes
    the second case and prints out its debug log:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CharacterAction` 被设置为 `Attack`，`switch` 语句执行第二个 `case` 并打印出其调试日志：
- en: '![](img/B17573_04_04.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_04.png)'
- en: 'Figure 4.4: Screenshot of the switch statement output in the console'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：控制台中的 `switch` 语句输出截图
- en: Change `CharacterAction` to either `Heal` or an undefined action to see the
    first and default cases in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `CharacterAction` 更改为 `Heal` 或未定义的操作，以查看第一个和默认情况的实际操作。
- en: There are going to be times where you need several, but not all, `switch` cases
    to perform the same action. These are called fall-through cases and are the subject
    of our next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要几个，但不是所有的 `switch` 情况来执行相同的操作。这些被称为穿透情况，是我们下一节的主题。
- en: Fall-through cases
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 穿透情况
- en: '`switch` statements can execute the same action for multiple cases, similar
    to how we specified several conditions in a single `if` statement. The term for
    this is called fall-through or, sometimes, fall-through cases. Fall-through cases
    let you define a single set of actions for multiple cases. If a case block is
    left empty or has code without the `break` keyword, it will fall through to the
    case directly beneath it. This helps keep your switch code clean and efficient,
    without duplicated case blocks.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句可以为多个情况执行相同的操作，类似于我们在单个 `if` 语句中指定多个条件的方式。这种情况下称为跳过（fall-through）或有时称为跳过情况。跳过情况允许你为多个情况定义一组单独的操作。如果一个情况块被留空或者包含没有
    `break` 关键字的代码，它将跳转到直接位于其下的情况。这有助于保持你的 switch 代码干净且高效，避免重复的情况块。'
- en: Cases can be written in any order, so creating fall-through cases greatly increases
    code readability and efficiency.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 情况可以按任何顺序编写，因此创建跳过情况大大增加了代码的可读性和效率。
- en: 'Let''s simulate a tabletop game scenario with a `switch` statement and fall-through
    case, where a dice roll determines the outcome of a specific action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `switch` 语句和跳过情况模拟一个桌面游戏场景，掷骰子的结果将决定特定动作的结果：
- en: 'Create an `int` variable, named `DiceRoll`, and assign it a value of `7`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DiceRoll` 的 `int` 变量，并给它赋值为 `7`：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a `public` method with no return value, called `RollDice`, and call it
    inside `Start`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的 `public` 方法，命名为 `RollDice`，并在 `Start` 中调用它。
- en: 'Add a `switch` statement with `DiceRoll` as the match expression:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以 `DiceRoll` 作为匹配表达式的 `switch` 语句：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Add three cases for possible dice rolls at `7`, `15`, and `20`, with a default
    `case` statement at the end.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可能的骰子点数 `7`、`15` 和 `20` 添加三个情况，并在最后添加一个默认 `case` 语句。
- en: Cases `15` and `20` should have their own debug logs and `break` statements,
    while case `7` should fall through to case `15:`
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 情况 `15` 和 `20` 应该有自己的调试日志和 `break` 语句，而情况 `7` 应该跳转到情况 `15`：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save the file and run it in Unity.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在 Unity 中运行它。
- en: If you want to see the fall-through case in action, try adding a debug log to
    case 7, but without the `break` keyword.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想看到跳过情况的实际应用，尝试在情况 7 中添加一个调试日志，但不要使用 `break` 关键字。
- en: 'With `DiceRoll` set to `7`, the `switch` statement will match with the first
    `case`, which will fall through and execute `case 15` because it lacks a code
    block and a `break` statement. If you change `DiceRoll` to `15` or `20`, the console
    will show their respective messages, and any other value will fire off the default
    case at the end of the statement:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `DiceRoll` 设置为 `7` 时，`switch` 语句将与第一个 `case` 匹配，然后跳过并执行 `case 15`，因为它没有代码块和
    `break` 语句。如果你将 `DiceRoll` 改为 `15` 或 `20`，控制台将显示它们各自的消息，任何其他值将触发语句末尾的默认情况：
- en: '![](img/B17573_04_05.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_05.png)'
- en: 'Figure 4.5: Screenshot of fall-through switch statement code'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：跳过 switch 语句代码的截图
- en: '`switch` statements are extremely powerful and can simplify even the most complex
    decision logic. If you want to dig deeper into switch pattern matching, refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句非常强大，甚至可以简化最复杂的决策逻辑。如果你想深入了解 switch 模式匹配，请参阅 [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch)。'
- en: That's all we need to know about conditional logic for the moment. So, review
    this section if you need to, and then test yourself on the following quiz before
    moving on to collections!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要了解这些关于条件逻辑的知识。所以，如果你需要，请复习这一节，然后在继续学习集合之前，先在下面的测验中测试一下自己！
- en: Pop quiz 1 – if, and, or but
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 1 – 如果，和，或但是
- en: 'Test your knowledge with the following questions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下问题测试你的知识：
- en: What values are used to evaluate `if` statements?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用来评估 `if` 语句的值是什么？
- en: Which operator can turn a true condition false or a false condition true?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个运算符可以将真条件转换为假或假条件转换为真？
- en: If two conditions need to be true for an `if` statement's code to execute, what
    logical operator would you use to join the conditions?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要两个条件都为真才能执行 `if` 语句的代码，你会使用哪个逻辑运算符来连接条件？
- en: If only one of two conditions needs to be true to execute an `if` statement's
    code, what logical operator would you use to join the two conditions?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只需要两个条件中的一个为真来执行 `if` 语句的代码，你会使用哪个逻辑运算符来连接这两个条件？
- en: With that done, you're ready to step into the world of collection data types.
    These types are going to open up a whole new subset of programming functionality
    for your games and C# programs!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你就可以进入集合数据类型的世界了。这些类型将为你的游戏和C#程序打开全新的编程功能子集！
- en: Collections at a glance
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一眼就能看到收藏夹
- en: So far, we've only needed variables to store a single value, but there are many
    conditions where a group of values will be required. Collection types in C# include
    arrays, dictionaries, and lists—each has its strengths and weaknesses, which we'll
    discuss in the following sections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需要变量来存储单个值，但有许多情况下需要一组值。C#中的集合类型包括数组、字典和列表——每个都有其优势和劣势，我们将在接下来的章节中讨论。
- en: Arrays
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: '**Arrays** are the most basic collection that C# offers. Think of them as containers
    for a group of values, called *elements* in programming terminology, each of which
    can be accessed or modified individually:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是C#提供的最基本的数据集合。把它们想象成一组值的容器，在编程术语中称为*元素*，每个元素都可以单独访问或修改：'
- en: Arrays can store any type of value; all the elements need to be of the same
    type.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以存储任何类型的值；所有元素都需要是同一类型。
- en: The length, or the number of elements an array can have, is set when it's created
    and can't be modified afterward.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的长度，或数组可以拥有的元素数量，在创建时设置，之后不能修改。
- en: If no initial values are assigned when it's created, each element will be given
    a default value. Arrays storing number types default to zero, while any other
    type gets set to null or nothing.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在创建时没有分配初始值，每个元素都将被赋予一个默认值。存储数字类型的数组默认为零，而任何其他类型都被设置为null或无。
- en: Arrays are the least flexible collection type in C#. This is mainly because
    elements can't be added or removed after they have been created. However, they
    are particularly useful when storing information that isn't likely to change. That
    lack of flexibility makes them faster compared to other collection types.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是C#中最不灵活的数据集合类型。这主要是因为一旦创建元素后，就不能再添加或删除。然而，当存储不太可能改变的信息时，它们特别有用。这种缺乏灵活性使它们比其他数据集合类型更快。
- en: 'Declaring an array is similar to other variable types we''ve worked with, but
    has a few modifications:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 声明数组与其他我们使用过的变量类型类似，但有一些修改：
- en: Array variables require a specified element type, a pair of square brackets,
    and a unique name.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组变量需要一个指定的元素类型、一对方括号和一个唯一名称。
- en: The `new` keyword is used to create the array in memory, followed by the value
    type and another pair of square brackets. The reserved memory area is the exact
    size of the data you're intending to store in the new array.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`关键字在内存中创建数组，后面跟着值类型和另一对方括号。保留的内存区域正好是你打算存储在新数组中的数据大小。
- en: The number of elements the array will store goes inside the second pair of square
    brackets.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组将要存储的元素数量放在第二对方括号内。
- en: 'In blueprint form, it looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式上，它看起来是这样的：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s take an example where we need to store the top three high scores in
    our game:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们需要在我们的游戏中存储前三名高分：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Broken down, `topPlayerScores` is an array of integers that will store three
    integer elements. Since we didn't add any initial values, each of the three values
    in `topPlayerScores` is `0`. However, if you change the array size, the contents
    of the original array are lost, so be careful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`topPlayerScores`是一个整数数组，将存储三个整数元素。由于我们没有添加任何初始值，`topPlayerScores`中的三个值都是`0`。然而，如果你更改数组大小，原始数组的内容就会丢失，所以请小心。
- en: 'You can assign values directly to an array when it''s created by adding them
    inside a pair of curly brackets at the end of the variable declaration. C# has
    a longhand and shorthand way of doing this, but both are equally valid:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建数组时，可以直接在变量声明末尾的一对方括号内添加值来赋值给数组。C#有长格式和短格式的方式来完成这个操作，但两者都是有效的：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Initializing arrays with the shorthand syntax is very common, so I'll be using
    it for the rest of the book. However, if you want to remind yourself of the details,
    feel free to use the explicit wording.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简写语法初始化数组非常常见，所以本书的其余部分我将使用它。然而，如果你想提醒自己细节，请随时使用明确的措辞。
- en: Now that the declaration syntax is no longer a mystery, let's talk about how
    array elements are stored and accessed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明语法不再是谜，让我们谈谈数组元素是如何存储和访问的。
- en: Indexing and subscripts
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和下标
- en: Each array element is stored in the order it's assigned, which is referred to
    as its index. Arrays are zero-indexed, meaning that the element order starts at
    zero instead of one. Think of an element's index as its reference, or location.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组元素都是按照其分配的顺序存储的，这被称为其索引。数组是零索引的，这意味着元素顺序从零开始而不是一。将元素的索引视为其引用或位置。
- en: 'In `topPlayerScores`, the first integer, `452`, is located at index `0`, `713`
    at index `1`, and `984` at index `2`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`topPlayerScores`中，第一个整数`452`位于索引`0`，`713`位于索引`1`，`984`位于索引`2`：
- en: '![](img/B17573_04_06.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_06.png)'
- en: 'Figure 4.6: Array indexes mapped to their values'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：数组索引映射到其值
- en: 'Individual values are located by their index using the subscript operator,
    which is a pair of square brackets that contains the index of the elements. For
    example, to retrieve and store the second array element in `topPlayerScores`,
    we would use the array name followed by subscript brackets and index `1`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下标运算符可以通过索引定位单个值，它是一对包含元素索引的方括号。例如，要检索并存储`topPlayerScores`中的第二个数组元素，我们会使用数组名称后跟下标括号和索引`1`：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The subscript operator can also be used to directly modify an array value just
    like any other variable, or even passed around as an expression by itself:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下标运算符也可以用来直接修改数组值，就像任何其他变量一样，或者甚至可以作为一个表达式本身传递：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The values in `topPlayerScores` would then be `452`, `1001`, and `984`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`topPlayerScores`中的值将是`452`、`1001`和`984`。'
- en: Range exceptions
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围异常
- en: 'When arrays are created, the number of elements is set and unchangeable, which
    means we can''t access an element that doesn''t exist. In the `topPlayerScores`
    example, the array length is 3, so the range of valid indices is from `0` to `2`.
    Any index of `3` or higher is out of the array''s range and will generate an aptly-named
    `IndexOutOfRangeException` error in the console:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建数组时，元素的数目是固定的，不可更改，这意味着我们无法访问不存在的元素。在`topPlayerScores`的例子中，数组长度是3，因此有效索引的范围是从`0`到`2`。任何大于`3`的索引都超出了数组的范围，将在控制台中生成一个名为`IndexOutOfRangeException`的错误：
- en: '![](img/B17573_04_07.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_07.png)'
- en: 'Figure 4.7: Screenshot of index out of range exception'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：索引越界异常的截图
- en: Good programming habits dictate that we avoid range exceptions by checking whether
    the value we want is within an array's index range, which we'll cover in the *Iteration
    statements* section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程习惯要求我们通过检查我们想要的值是否在数组索引范围内来避免范围异常，我们将在*迭代语句*部分进行介绍。
- en: 'You can always check the length of an array, that is, how many items it contains,
    with the `Length` property:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Length`属性始终检查数组的长度，即它包含多少项：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our case, the length of `topPlayerScores` is 4.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`topPlayerScores`的长度是4。
- en: Arrays aren't the only collection types C# has to offer. In the next section,
    we'll deal with lists, which are more flexible and more common in the programming
    landscape.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 数组并不是C#所能提供的唯一集合类型。在下一节中，我们将处理列表，它们更加灵活，在编程领域中更为常见。
- en: Lists
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: '**Lists** are closely related to arrays, collecting multiple values of the
    same type in a single variable. They''re much easier to deal with when it comes
    to adding, removing, and updating elements, but their elements aren''t stored
    sequentially. They are also mutable, meaning you can change the length or number
    of items you''re storing, without overwriting the whole variable. This can, sometimes,
    lead to a higher performance cost over arrays.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**与数组密切相关，在单个变量中收集相同类型的多个值。在添加、删除和更新元素时，它们处理起来更容易，但它们的元素不是按顺序存储的。它们也是可变的，这意味着你可以更改存储的长度或项目数量，而无需覆盖整个变量。这有时可能会导致比数组更高的性能成本。'
- en: Performance cost refers to how much of a computer's time and energy a given
    operation takes up. Nowadays, computers are fast, but they can still get overloaded
    with big games or applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 性能成本指的是给定操作占用计算机时间和能量的多少。如今，计算机速度很快，但它们仍然可能因为大型游戏或应用程序而超载。
- en: 'A list-type variable needs to meet the following requirements:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表类型的变量需要满足以下要求：
- en: The `List` keyword, its element type inside left and right arrow characters,
    and a unique name
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`关键字，其元素类型在左右箭头字符之间，以及一个独特的名称'
- en: The `new` keyword to initialize the list in memory, with the `List` keyword
    and element type between arrow characters
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`关键字、`List`关键字和元素类型在箭头字符之间初始化列表
- en: A pair of parentheses capped off by a semicolon
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对括号，以分号结尾
- en: 'In blueprint form, it reads as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以蓝图形式，它读作如下：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: List length can always be modified, so there is no need to specify how many
    elements it will eventually hold when created.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表长度总是可以修改的，因此创建时不需要指定它最终将包含多少元素。
- en: 'Like arrays, lists can be initialized in the variable declaration by adding
    element values inside a pair of curly brackets:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，列表可以在变量声明时通过在花括号内添加元素值来初始化：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Elements are stored in the order they are added (instead of the sequential order
    of the values themselves), are zero-indexed, and can be accessed using the subscript
    operator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 元素按添加的顺序存储（而不是值的顺序），是零索引的，并且可以使用下标操作符访问。
- en: Let's start setting up a list of our own to test out the basic functionality
    this class has on offer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置自己的列表以测试这个类提供的基本功能。
- en: 'Let''s do a warm-up exercise by creating a list of party members in a fictional
    role-playing game:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个虚构角色扮演游戏中的角色列表来进行一次热身练习：
- en: 'Create a new `List` of the `string` type inside `Start` called `QuestPartyMembers`,
    and initialize it with the names of three characters:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Start` 中创建一个新的 `string` 类型的 `List`，名为 `QuestPartyMembers`，并用三个角色的名字初始化它：
- en: '[PRE35]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a debug log to print out the number of party members in the list using
    the `Count` method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调试日志，使用 `Count` 方法打印出列表中的人数：
- en: '[PRE36]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save the file and play it in Unity.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在 Unity 中播放。
- en: We initialized a new list, called `QuestPartyMembers`, which now holds three
    string values, and used the `Count` method from the `List` class to print out
    the number of elements. Notice that you use `Count` for lists, but `Length` for
    arrays.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个新的列表，名为 `QuestPartyMembers`，现在它包含三个字符串值，并使用 `List` 类的 `Count` 方法打印出元素的数量。请注意，对于列表，您使用
    `Count`，但对于数组，您使用 `Length`。
- en: '![](img/B17573_04_08.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_08.png)'
- en: 'Figure 4.8: Screenshot of list item output in the console'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：控制台中的列表项输出截图
- en: Knowing how many elements are in a list is highly useful; however, in most cases,
    that information is not enough. We want to be able to modify our lists as needed,
    which we'll discuss next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 知道列表中有多少元素非常有用；然而，在大多数情况下，这些信息并不足够。我们希望能够根据需要修改我们的列表，我们将在下一节讨论。
- en: Accessing and modifying lists
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问和修改列表
- en: List elements can be accessed and modified like arrays with a subscript operator
    and index, as long as the index is within the `List` class's range. However, the
    `List` class has a variety of methods that extend its functionality, such as adding,
    inserting, and removing elements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素可以通过下标操作符和索引像数组一样访问和修改，只要索引在 `List` 类的范围内。然而，`List` 类有许多扩展其功能的方法，例如添加、插入和删除元素。
- en: 'Sticking with the `QuestPartyMembers` list, let''s add a new member to the
    team:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 `QuestPartyMembers` 列表，向团队添加一个新成员：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Add()` method appends the new element at the end of the list, which brings
    the `QuestPartyMembers` count to four and the element order to the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()` 方法将新元素追加到列表的末尾，这使得 `QuestPartyMembers` 的计数达到四个，元素顺序如下：'
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To add an element to a specific spot in a list, we can pass the index and the
    value that we want to add to the `Insert()` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列表的特定位置添加一个元素，我们可以传递索引和要添加的值给 `Insert()` 方法：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When an element is inserted at a previously occupied index, all the elements
    in the list have their indices increased by `1`. In our example, `"Tanis the Thief"`
    is now at index `1`, meaning that `"Merlin the Wise"` is now at index `2` instead
    of `1`, and so on:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素插入到之前已占用的索引时，列表中的所有元素的索引都会增加 `1`。在我们的例子中，`"Tanis the Thief"` 现在位于索引 `1`，这意味着
    `"Merlin the Wise"` 现在位于索引 `2` 而不是 `1`，依此类推：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Removing an element is just as simple; all we need is the index or the literal
    value, and the `List` class does the work:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素同样简单；我们只需要索引或要删除的值，`List` 类就会完成工作：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the end of our edits, `QuestPartyMembers` now contains the following elements
    indexed from `0` to `3`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的编辑结束时，`QuestPartyMembers` 现在包含以下元素，索引从 `0` 到 `3`：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are many more `List` class methods that allow for value checks, finding
    and sorting elements, and working with ranges. A full method list, with descriptions,
    can be found here: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类有许多其他方法，允许进行值检查、查找和排序元素，以及与范围一起工作。完整的方 法列表和描述可以在此处找到：[https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2)。'
- en: While lists are great for single-value elements, there are cases where you'll
    need to store information or data containing more than one value. This is where
    dictionaries come into play.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表非常适合单个值元素时，有些情况下你需要存储包含多个值的信息或数据。这就是字典发挥作用的地方。
- en: Dictionaries
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'The **Dictionary** type steps away from arrays and lists by storing value pairs
    in each element, instead of single values. These elements are referred to as key-value
    pairs: the key acts as the index, or lookup value, for its corresponding value.
    Unlike arrays and lists, dictionaries are unordered. However, they can be sorted
    and ordered in various configurations after they are created.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dictionary**类型通过在每个元素中存储值对，而不是单个值，与数组和列表不同。这些元素被称为键值对：键作为其对应值的索引或查找值。与数组和列表不同，字典是无序的。然而，在创建后，它们可以根据各种配置进行排序和排序。'
- en: 'Declaring a dictionary is almost the same as declaring a list, but with one
    added detail—both the key and the value type need to be specified inside the arrow
    symbols:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 声明字典几乎与声明列表相同，但有一个额外的细节——键和值类型都需要在箭头符号内指定：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To initialize a dictionary with key-value pairs, do the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用键值对初始化字典，请执行以下操作：
- en: Use a pair of curly brackets at the end of the declaration.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明末尾使用一对花括号。
- en: Add each element within its pair of curly brackets, with the key and the value
    separated by a comma.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其成对的圆括号内添加每个元素，键和值之间用逗号分隔。
- en: Separate elements with a comma, except the last element where the comma is optional.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用逗号分隔元素，除了最后一个元素，那里的逗号是可选的。
- en: 'It looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An important note to consider when picking key values is that each key must
    be unique, and they cannot be changed. If you need to update a key, then you need
    to change its value in the variable declaration or remove the entire key-value
    pair and add another in code, which we'll look at next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择键值时，一个重要的注意事项是每个键必须是唯一的，并且不能更改。如果你需要更新一个键，那么你需要更改变量声明中的其值，或者删除整个键值对并在代码中添加另一个，我们将在下一部分讨论。
- en: Just like with arrays and lists, dictionaries can be initialized on a single
    line with no problems from Visual Studio. However, writing out each key-value
    pair on its line, as in the preceding example, is a good habit to get into—both
    for readability and your sanity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组和列表一样，字典可以在单行中初始化，而不会从Visual Studio中产生任何问题。然而，像前面示例中那样，将每个键值对写在单独的一行上，是一个好习惯——既有利于可读性，也有利于你的精神健康。
- en: 'Let''s create a dictionary to store items that a character might carry:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个字典来存储一个角色可能携带的物品：
- en: Declare a `Dictionary` with a `key` type of `string` and a `value` type of `int`
    called `ItemInventory` in the `Start` method.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中声明一个名为`ItemInventory`的`Dictionary`，其`key`类型为`string`，`value`类型为`int`。
- en: 'Initialize it to `new Dictionary<string, int>()`, and add three key-value pairs
    of your choice. Make sure each element is in its pair of curly brackets:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化它为`new Dictionary<string, int>()`，并添加三个你选择的键值对。确保每个元素都在其成对的花括号内：
- en: '[PRE45]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a debug log to print out the `ItemInventory.Count` property so that we
    can see how items are stored:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调试日志来打印出`ItemInventory.Count`属性，这样我们就可以看到物品是如何存储的：
- en: '[PRE46]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save the file and play.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并播放。
- en: 'Here, a new dictionary, called `ItemInventory`, was created and initialized
    with three key-value pairs. We specified the keys as strings, with corresponding
    values as integers, and printed out how many elements `ItemInventory` currently
    holds:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为`ItemInventory`的新字典，并初始化了三个键值对。我们指定键为字符串，相应的值为整数，并打印出`ItemInventory`当前包含的元素数量：
- en: '![](img/B17573_04_09.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_09.png)'
- en: 'Figure 4.9: Screenshot of dictionary count in console'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：控制台中的字典计数截图
- en: Like lists, we need to be able to do more than just print out the number of
    key-value pairs in a given dictionary. We'll explore adding, removing, and updating
    these values in the following section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表一样，我们需要能够做更多的事情，而不仅仅是打印出给定字典中键值对的数量。在下一节中，我们将探讨添加、删除和更新这些值。
- en: Working with dictionary pairs
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理字典对
- en: 'Key-value pairs can be added, removed, and accessed from dictionaries using
    both subscript and class methods. To retrieve an element''s value, use the subscript
    operator with the element''s key—in the following example, `numberOfPotions` would
    be assigned a value of `5`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用索引操作符和类方法从字典中添加、删除和访问键值对。要检索元素的值，请使用元素的键作为索引操作符——在以下示例中，`numberOfPotions`将被分配一个值为`5`：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An element''s value can be updated using the same method—the value associated
    with `"Potion"` would now be `10`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素的值可以使用相同的方法进行更新——与 `"Potion"` 关联的值现在将是 `10`：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Elements can be added to dictionaries in two ways: with the `Add` method and
    with the subscript operator. The `Add` method takes in a key and a value and creates
    a new key-value element, as long as their types correspond to the dictionary declaration:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式向字典中添加元素：使用 `Add` 方法和使用下标运算符。`Add` 方法接受一个键和一个值，并创建一个新的键值元素，只要它们的类型与字典声明相匹配：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the subscript operator is used to assign a value to a key that doesn''t
    exist in a dictionary, the compiler will automatically add it as a new key-value
    pair. For example, if we wanted to add a new element for `"Bandage"`, we could
    do so with the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用下标运算符将值分配给字典中不存在的键，编译器将自动将其添加为新键值对。例如，如果我们想为 `"Bandage"` 添加一个新元素，我们可以使用以下代码：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This brings up a crucial point about referencing key-value pairs: it''s better
    to be certain that an element exists before trying to access it, to avoid mistakenly
    adding new key-value pairs. Pairing the `ContainsKey` method with an `if` statement
    is the simple solution since `ContainsKey` returns a Boolean value based on whether
    the key exists. In the following example, we make sure that the `"Aspirin"` key
    exists using an `if` statement before modifying its value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了关于引用键值对的一个关键点：在尝试访问它之前，最好确定元素是否存在，以避免错误地添加新的键值对。将 `ContainsKey` 方法与 `if`
    语句配对是简单解决方案，因为 `ContainsKey` 根据键是否存在返回一个布尔值。在以下示例中，我们使用 `if` 语句确保 `"Aspirin"`
    键存在，然后再修改其值：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, a key-value pair can be deleted from a dictionary using the `Remove()`
    method, which takes in a key parameter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 `Remove()` 方法从字典中删除键值对，该方法接受一个键参数：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Like lists, dictionaries offer a variety of methods and functionality to make
    development easier, but we can't cover them all here. If you're curious, the official
    documentation can be found at [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，字典提供了各种方法和功能来简化开发，但我们不能在这里涵盖所有内容。如果你好奇，官方文档可以在 [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2)
    找到。
- en: 'Collections are safely in our toolkit, so it''s time for another quiz to make
    sure you''re ready to move on to the next big topic: iteration statements.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 集合已经安全地进入我们的工具箱，所以现在是时候进行另一个测验，以确保你准备好进入下一个重要主题：迭代语句。
- en: Pop quiz 2 – all about collections
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 2 – 全部关于集合
- en: What is an element in an array or list?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组或列表中的元素是什么？
- en: What is the index number of the first element in an array or list?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组或列表中第一个元素的索引号是多少？
- en: Can a single array or list store different types of data?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个数组或列表能否存储不同类型的数据？
- en: How can you add more elements to an array to make room for more data?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何向数组中添加更多元素以腾出更多空间？
- en: Since collections are groups or lists of items, they need to be accessible in
    an efficient manner. Luckily, C# has several iteration statements, which we'll
    talk about in the following section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是项的组或列表，它们需要以高效的方式访问。幸运的是，C# 有几个迭代语句，我们将在下一节中讨论。
- en: Iteration statements
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代语句
- en: We've accessed individual collection elements through the subscript operator,
    along with collection type methods, but what do we do when we need to go through
    the entire collection element by element? In programming, this is called iteration,
    and C# provides several statement types that let us loop through (or iterate over,
    if you want to be technical) collection elements. Iteration statements are like
    methods, in that they store a block of code to be executed; unlike methods, they
    can repeatedly execute their code blocks as long as their conditions are met.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过下标运算符访问了单个集合元素，以及集合类型方法，但当我们需要逐个遍历整个集合元素时，我们该怎么办？在编程中，这被称为迭代，C# 提供了多种语句类型，允许我们遍历（或者如果你想更技术性地表达，就是迭代）集合元素。迭代语句就像方法一样，因为它们存储要执行的代码块；与方法不同的是，只要条件满足，它们可以重复执行它们的代码块。
- en: for loops
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 循环
- en: The `for` loop is most commonly used when a block of code needs to be executed
    a certain number of times before the program continues. The statement itself takes
    in three expressions, each with a specific function to perform before the loop
    executes. Since `for` loops keep track of the current iteration, they are best
    suited to arrays and lists.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行一定次数的代码块后程序继续时，`for` 循环是最常用的。该语句本身接受三个表达式，每个表达式在循环执行前都有特定的功能。由于 `for` 循环跟踪当前迭代，因此它们最适合数组列表。
- en: 'Take a look at the following looping statement blueprint:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下循环语句蓝图：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s break this down:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: The `for` keyword starts the statement, followed by a pair of parentheses.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for` 关键字开始语句，后面跟着一对括号。'
- en: 'Inside the parentheses are the gatekeepers: the `initializer`, `condition`,
    and `iterator` expressions.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在括号内是守门人：`initializer`、`condition` 和 `iterator` 表达式。
- en: The loop starts with the `initializer` expression, which is a local variable
    created to keep track of how many times the loop has executed—this is usually
    set to 0 because collection types are zero-indexed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环从 `initializer` 表达式开始，这是一个局部变量，用于跟踪循环已执行了多少次——这通常设置为 0，因为集合类型是零索引的。
- en: Next, the `condition` expression is checked and, if true, proceeds to the iterator.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查 `condition` 表达式，如果为真，则继续到 `iterator`。
- en: The `iterator` expression is used to either increase or decrease (increment
    or decrement) the initializer, meaning the next time the loop evaluates its condition,
    the initializer will be different.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iterator` 表达式用于增加或减少（递增或递减）初始化器，这意味着下一次循环评估其条件时，初始化器将不同。'
- en: Increasing and decreasing a value by 1 is called incrementing and decrementing,
    respectively (`--` will decrease a value by 1, and `++` will increase it by 1).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 1 增加或减少一个值称为递增和递减，分别（`--` 会减少一个值 1，而 `++` 会增加它 1）。
- en: 'That all sounds like a lot, so let''s look at a practical example with the
    `QuestPartyMembers` list we created earlier:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来好像很多，那么让我们看看一个使用我们之前创建的 `QuestPartyMembers` 列表的实际例子：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s go through the loop again and see how it works:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次遍历循环，看看它是如何工作的：
- en: First, the `initializer` in the `for` loop is set as a local `int` variable
    named `i` with a starting value of `0`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`for` 循环中的 `initializer` 被设置为名为 `i` 的局部 `int` 变量，起始值为 `0`。
- en: 'To ensure we never get an out-of-range exception, the `for` loop makes sure
    that the loop only runs another time if `i` is less than the number of elements
    in `QuestPartyMembers`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们永远不会得到越界异常，`for` 循环确保只有在 `i` 小于 `QuestPartyMembers` 中元素的数量时才会再次运行循环：
- en: With arrays, we use the `Length` property to determine how many items it has
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数组，我们使用 `Length` 属性来确定它有多少项。
- en: With lists, we use the `Count` property
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表，我们使用 `Count` 属性
- en: Finally, `i` is increased by 1 each time the loop runs with the `++` operator.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每次循环运行时，`i` 都会通过 `++` 运算符增加 1。
- en: Inside the `for` loop, we've just printed out the index and the list element
    at that index using `i`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环内部，我们刚刚使用 `i` 打印出了索引和该索引处的列表元素。
- en: Notice that `i` is in step with the index of the collection elements, since
    both start at 0:![](img/B17573_04_10.png)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`i` 与集合元素的索引保持一致，因为它们都是从 0 开始的：![img/B17573_04_10.png](img/B17573_04_10.png)
- en: 'Figure 4.10: Screenshot of list values printed out with a for loop'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：使用 `for` 循环打印出的列表值的截图
- en: Traditionally, the letter `i` is typically used as the initializer variable
    name. If you happen to have nested `for` loops, the variable names used should
    be the letters j, k, l, and so on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，字母 `i` 通常用作初始化变量名。如果你恰好有嵌套的 `for` 循环，所使用的变量名应该是字母 j、k、l 等等。
- en: Let's try out our new iteration statements on one of our existing collections.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们现有的集合之一上尝试我们的新迭代语句。
- en: 'While we loop through `QuestPartyMembers`, let''s see whether we can identify
    when a certain element is iterated over and add a special debug log just for that
    case:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历 `QuestPartyMembers` 时，让我们看看我们是否可以识别出某个元素被迭代的情况，并为这种情况添加一个特殊的调试日志：
- en: Move the `QuestPartyMembers` list and `for` loop into a public function called
    `FindPartyMember` and call it in `Start`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `QuestPartyMembers` 列表和 `for` 循环移动到名为 `FindPartyMember` 的公共函数中，并在 `Start`
    中调用它。
- en: Add an `if` statement below the debug log in the `for` loop to check whether
    the current `questPartyMember` list matches `"Merlin the Wise":`
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环中在调试日志下方添加一个 `if` 语句，以检查当前的 `questPartyMember` 列表是否匹配 `"Merlin the
    Wise"`：
- en: '[PRE55]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If it does, add a debug log of your choice, check that your code matches the
    screenshot below, and hit play:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，添加一个你选择的调试日志，检查你的代码是否与下面的截图匹配，然后点击播放：
- en: '[PRE56]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The console output should look almost the same, except that there is now an
    extra debug log—one that only printed once when it was Merlin''s turn to go through
    the loop. More specifically, when `i` was equal to `1` on the second loop, the
    `if` statement fired and two logs were printed out instead of just one:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应该看起来几乎一样，但现在有一个额外的调试日志——当轮到梅林进入循环时只打印了一次。更具体地说，当第二次循环中的 `i` 等于 `1` 时，`if`
    语句被触发，打印了两个日志而不是一个：
- en: '![](img/B17573_04_11.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_11.png)'
- en: 'Figure 4.11: Screenshot of the for loop printing out list values and matching
    if statements'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：for 循环打印列表值和匹配 if 语句的截图
- en: Using a standard `for` loop can be highly useful in the right situation, but
    there's seldom just one way to do things in programming, which is where the `foreach`
    statement comes into play.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的情况下，使用标准的 `for` 循环非常有用，但在编程中，事情往往没有唯一的方法，这就是 `foreach` 语句发挥作用的地方。
- en: foreach loops
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foreach 循环
- en: '`foreach` loops take each element in a collection and store each one in a local
    variable, making it accessible inside the statement. The local variable type must
    match the collection element type to work properly. `foreach` loops can be used
    with arrays and lists, but they are especially useful with dictionaries, since
    dictionaries are key-value pairs instead of numeric indexes.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环将集合中的每个元素取出来，并将每个元素存储在一个局部变量中，使其在语句内部可访问。局部变量类型必须与集合元素类型匹配才能正常工作。`foreach`
    循环可以与数组列表一起使用，但它们在字典中特别有用，因为字典是键值对而不是数字索引。'
- en: 'In blueprint form, a `foreach` loop looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式中，`foreach` 循环看起来是这样的：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s stick with the `Q``uestPartyMembers` list example and do a roll call
    for each of its elements:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 `Q``uestPartyMembers` 列表示例，并对它的每个元素进行点名：
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can break this down as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样分解：
- en: The element type is declared as a `string`, which matches the values in `QuestPartyMembers`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素类型被声明为 `string`，这与 `QuestPartyMembers` 中的值相匹配。
- en: A local variable, called `partyMember`, is created to hold each element as the
    loop repeats.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `partyMember` 的局部变量来保存每次循环重复时的每个元素。
- en: The `in` keyword, followed by the collection we want to loop through, in this
    case, `QuestPartyMembers`, finishes things off:![](img/B17573_04_12.png)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in` 关键字，后面跟着我们要遍历的集合，在这个例子中是 `QuestPartyMembers`，完成了操作！![图片](img/B17573_04_12.png)'
- en: 'Figure 4.12: Screenshot of a foreach loop printing out list values'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17573_04_12.png)'
- en: This is a good deal simpler than the `for` loop. However, when dealing with
    dictionaries, there are a few important differences we need to mention—namely
    how to deal with key-value pairs as local variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 `for` 循环简单得多。然而，当处理字典时，有一些重要的区别我们需要提及——即如何作为局部变量处理键值对。
- en: Looping through key-value pairs
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历键值对
- en: To capture a key-value pair in a local variable, we need to use the aptly named
    `KeyValuePair` type, assigning both the key and value types to match the dictionary's
    corresponding types. Since `KeyValuePair` is its type, it acts just like any other
    element type, as a local variable.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要在局部变量中捕获键值对，我们需要使用名为 `KeyValuePair` 的类型，将键和值类型分配为与字典的对应类型相匹配。由于 `KeyValuePair`
    是其类型，它就像任何其他元素类型一样，作为一个局部变量。
- en: 'For example, let''s loop through the `ItemInventory` dictionary we created
    earlier in the *Dictionaries* section and debug each key-value like a shop item
    description:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们遍历在 *Dictionaries* 部分中创建的 `ItemInventory` 字典，并像商店商品描述一样调试每个键值对：
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've specified a local variable of `KeyValuePair`, called `kvp`, which is a
    common naming convention in programming, like calling the `for` loop initializer
    `i`, and setting the `key` and `value` types to `string` and `int` to match `ItemInventory`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个名为 `kvp` 的局部变量，这是编程中的一种常见命名约定，就像将 `for` 循环初始化器命名为 `i`，并将 `key` 和 `value`
    类型设置为 `string` 和 `int` 以匹配 `ItemInventory`。
- en: To access the key and value of the local `kvp` variable, we use the `KeyValuePair`
    properties of `Key` and `Value`, respectively.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问局部变量 `kvp` 的键和值，我们分别使用 `KeyValuePair` 的 `Key` 和 `Value` 属性。
- en: 'In this example, the keys are `strings` and the `values` are integers, which
    we can print out as the item name and item price:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，键是 `string` 类型，值是整数，我们可以将其打印出来作为项目名称和项目价格：
- en: '![](img/B17573_04_13.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_04_13.png)'
- en: 'Figure 4.13: Screenshot of a foreach loop printing out dictionary key-value
    pairs'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：打印字典键值对的 `foreach` 循环截图
- en: If you're feeling particularly adventurous, try out the following optional challenge
    to drive home what you've just learned.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您特别有冒险精神，请尝试以下可选挑战，以巩固您刚刚学到的知识。
- en: Hero's trial – finding affordable items
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 英雄的考验 – 寻找负担得起的物品
- en: Using the preceding script, create a variable to store how much gold your fictional
    character has, and see whether you can add an `if` statement inside the `foreach`
    loop to check for items that you can afford.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的脚本，创建一个变量来存储您虚构角色拥有的金币数量，并尝试在 `foreach` 循环中添加一个 `if` 语句来检查您能否负担得起这些物品。
- en: 'Hint: use `kvp.Value` to compare prices with what''s in your wallet.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用 `kvp.Value` 来比较价格与您钱包中的金额。
- en: while loops
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`while` loops are similar to `if` statements in that they run as long as a
    single expression or condition is true.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 `if` 语句类似，只要单个表达式或条件为真就会运行。'
- en: Value comparisons and Boolean variables can be used as `while` conditions, and
    they can be modified with the `NOT` operator.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 值比较和布尔变量可以用作 `while` 条件，并且可以使用 `NOT` 运算符进行修改。
- en: 'The `while` loop syntax says, *While my condition is true, keep running my
    code block indefinitely*:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的语法表示为：“当我的条件为真时，无限期地运行我的代码块”：'
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With `while` loops, it's common to declare an initializer variable, as in a
    `for` loop, and manually increment or decrement it at the end of the loop's code
    block. We do this to avoid an infinite loop, which we will discuss at the end
    of the chapter. Depending on your situation, the initializer is usually part of
    the loop's condition.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，通常像 `for` 循环一样声明一个初始化变量，并在循环代码块的末尾手动增加或减少它。我们这样做是为了避免无限循环，我们将在本章末尾讨论这个问题。根据您的具体情况，初始化器通常是循环条件的一部分。
- en: '`while` loops are very useful when coding in C#, but they are not considered
    good practice in Unity because they can negatively impact performance and routinely
    need to be manually managed.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环在 C# 编程中非常有用，但在 Unity 中并不被认为是良好的实践，因为它们可能会对性能产生负面影响，并且通常需要手动管理。'
- en: 'Let''s take a common use case where we need to execute code while the player
    is alive, and then debug when that''s no longer the case:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个常见的用例，其中我们需要在玩家存活时执行代码，然后在该情况不再成立时进行调试：
- en: 'Create an initializer variable called `PlayerLives` of the `int` type, and
    set it to `3`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerLives` 的初始化变量，其类型为 `int`，并将其设置为 `3`：
- en: '[PRE61]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Create a new public function called `HealthStatus` and call it in `Start`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的公共函数 `HealthStatus` 并在 `Start` 中调用它。
- en: 'Declare a `while` loop with the condition checking whether `PlayerLives` is
    greater than `0` (that is, the player is still alive):'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `while` 循环，其条件检查 `PlayerLives` 是否大于 `0`（即玩家仍然存活）：
- en: '[PRE62]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Inside the `while` loop, debug something to let us know the character is still
    kicking, then decrement `PlayerLives` by 1 using the `--` operator:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环内部，进行一些调试以让我们知道角色仍然在战斗，然后使用 `--` 运算符将 `PlayerLives` 减少一：
- en: '[PRE63]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a debug log after the `while` loop curly brackets to print something when
    our lives run out:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环的大括号后添加一个调试日志，以便在生命耗尽时打印一些内容：
- en: '[PRE64]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Your code should look like the following:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的代码应如下所示：
- en: '[PRE65]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With `PlayerLives` starting out at `3`, the `while` loop will execute three
    times. During each loop, the debug log, `"Still alive!"`, fires, and a life is
    subtracted from `PlayerLives`. When the `while` loop goes to run a fourth time,
    our condition fails because `PlayerLives` is `0`, so the code block is skipped
    and the final debug log prints out:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PlayerLives` 的初始值为 `3`，`while` 循环将执行三次。在每次循环中，调试日志 `"Still alive!"` 被触发，并从
    `PlayerLives` 中减去一条生命。当 `while` 循环尝试第四次运行时，由于 `PlayerLives` 为 `0`，条件失败，因此代码块被跳过，并打印出最后的调试日志：
- en: '![](img/B17573_04_14.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_14.png)'
- en: 'Figure 4.14: Screenshot of while-loop output in the console'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：控制台中的 `while` 循环输出截图
- en: If you're not seeing multiple "Still alive!" debug logs, make sure the **Collapse**
    button in the **Console** toolbar isn't selected.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到多个 "仍存活！" 调试日志，请确保 **Console** 工具栏中的 **Collapse** 按钮没有被选中。
- en: The question now is what happens if a loop never stops executing? We'll discuss
    this issue in the following section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如果循环永远不会停止执行会发生什么？我们将在下一节讨论这个问题。
- en: To infinity and beyond
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到无限远方
- en: 'Before finishing this chapter, we need to understand one extremely vital concept
    when it comes to iteration statements: *infinite loops*. These are exactly what
    they sound like: when a loop''s conditions make it impossible for it to stop running
    and move on in the program. Infinite loops usually happen in `for` and `while`
    loops when the iterator is not increased or decreased; if the `PlayerLives` line
    of code was left out of the `while` loop example, Unity would freeze and/or crash,
    recognizing that `PlayerLives` would always be 3 and execute the loop forever.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我们需要理解迭代语句中的一个极其重要的概念：*无限循环*。它们正是其名称所暗示的那样：当循环的条件使得循环无法停止运行并继续程序中的其他部分时。无限循环通常发生在`for`和`while`循环中，当迭代器没有被增加或减少时；如果`while`循环示例中遗漏了`PlayerLives`代码行，Unity会冻结和/或崩溃，意识到`PlayerLives`始终为3，并无限期地执行循环。
- en: Iterators are not the only culprits to be aware of; setting conditions in a
    `for` loop that will never fail, or evaluate to false, can also cause infinite
    loops. In the party members example, from the *Looping through key-value pairs*
    section, if we had set the `for` loop condition to `i < 0` instead of `i < QuestPartyMembers.Count`,
    `i` would always be less than `0`, looping until Unity crashed.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器并不是唯一需要警惕的罪魁祸首；在`for`循环中设置永远不会失败或评估为假的条件，也可能导致无限循环。在“通过键值对循环”部分提到的党员例子中，如果我们把`for`循环的条件设置为`i
    < 0`而不是`i < QuestPartyMembers.Count`，`i`将始终小于`0`，循环直到Unity崩溃。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we bring the chapter to a close, we should reflect on how much we've accomplished
    and what we can build with that new knowledge. We know how to use simple `if-else`
    checks and more complex `switch` statements, allowing decision making in code.
    We can create variables that hold collections of values with arrays and lists
    or key-value pairs with dictionaries. This allows complex and grouped data to
    be stored efficiently. We can even choose the right looping statement for each
    collection type, while carefully avoiding infinite-loop crashes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们应该反思我们已经取得了多少成就，以及我们可以用这些新知识构建什么。我们知道如何使用简单的`if-else`检查和更复杂的`switch`语句，允许在代码中进行决策。我们可以使用数组、列表或字典来创建存储值集合的变量，或者存储键值对。这允许复杂和分组的数据被有效地存储。我们甚至可以为每种集合类型选择正确的循环语句，同时小心避免无限循环崩溃。
- en: If you're feeling overloaded, that's perfectly OK—logical, sequential thinking
    is all part of exercising your programming brain.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到压力过大，那完全没问题——逻辑性和顺序性思维都是锻炼编程大脑的一部分。
- en: The next chapter will complete the basics of C# programming with a look at classes,
    structs, and **object-oriented programming** (**OOP**). We'll be putting everything
    we've learned so far into these topics, preparing for our first real dive into
    understanding and controlling objects in the Unity engine.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过对类、结构和**面向对象编程**（**OOP**）的探讨来完成C#编程的基础。我们将把迄今为止学到的所有知识应用到这些主题中，为理解并控制Unity引擎中的对象做好第一次真正的准备。
- en: JOIN us on Discord!
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和哈里森·费罗恩一起阅读这本书。提问、为其他读者提供解决方案、通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Join Now!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
