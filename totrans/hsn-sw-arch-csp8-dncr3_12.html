<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design Patterns and .NET Core Implementation</h1>
                </header>
            
            <article>
                
<p>Design patterns can be defined as ready to use architectural solutions for common problems you encounter during software development. They are essential for understanding the .NET Core architecture and useful for solving ordinary problems that we face when designing any piece of software. In this chapter, we will look at the implementation of some design patterns. It is worth mentioning that this book doesn't explain all the known patterns we can use. The focus here is to explain the importance of studying and applying them.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li><span>Understanding design patterns and their purpose</span></li>
<li>Understanding the available design patterns in .NET Core</li>
</ul>
<p>By the end of this chapter, you will have learned about some of the use cases from WWTravelClub that you can implement with design patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>You will require the following to complete this chapter:</span></p>
<ul>
<li><span>Visual Studio 2017 or 2019 free Community Edition or better with all the database tools installed.</span></li>
<li>A free Azure account. The <em>Creating an Azure account</em> subsection of <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em><span>Understanding the Importance of Software Architecture</span></em>, explains how to create one.</li>
</ul>
<p>You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09</a><span>.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding design patterns and their purpose</h1>
                </header>
            
            <article>
                
<p>Being able to decide on the design of a system is challenging, and the responsibility associated with this task is enormous. As a software architect, we must always keep in mind that features such as great reusability, good performance, and good maintainability are key. This is where design patterns help and accelerate the design process.</p>
<p>As we mentioned previously, design patterns are solutions that have already been discussed and defined so that they can solve common software architectural problems. This approach grew in popularity after the release of the book <em>Design Patterns <span>–</span> Elements of Reusable Object-Oriented Software</em>, where the <strong>Gang of Four</strong> (<strong>GoF</strong>) <span>divided </span>these patterns into three types:</p>
<ul>
<li>Creational</li>
<li>Structural</li>
<li>Behavioral</li>
</ul>
<p>A little bit later, Uncle Bob introduced the SOLID principles to the developers community, giving us the opportunity to efficaciously organize functions and data structures of each system into classes. SOLID principles indicate how these classes should be connected. It is worth mentioning that, compared to the design patterns presented by GoF, SOLID principles don't deliver code recipes. Instead, they give you the basic principles to follow when you design your solutions. </p>
<p>As technologies and software problems change, more patterns are conceived. The advance of cloud computing has brought a bunch of them, all of which can be found at <a href="https://docs.microsoft.com/azure/architecture/patterns/">https://docs.microsoft.com/azure/architecture/patterns/</a>.</p>
<p>The reason why you should always consider them is quite simple <span>– </span>as a software architect, you cannot spend time reinventing the wheel. However, there is another great reason for using them: you will find many patterns implemented in .NET Core.</p>
<p>In the next few subsections, we will cover some of the most well-known patterns. However, the idea of this chapter is to let you know that they exist and need to be studied so that you can accelerate and simplify your project. Moreover, each pattern with be presented with a C# code snippet so that you can easily implement them in your projects.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Builder pattern</h1>
                </header>
            
            <article>
                
<p>There are cases where you will have a complex object with different behaviors due to its<span> configuration</span>. Instead of setting this object up while using it, you may want to decouple its configuration from its usage, using a customized configuration already built. This way, you have different representations of the instances you are building. This is where you should use the Builder pattern. </p>
<p>The following class diagram shows the pattern that has been implemented for a scenario from this book's use case. The idea behind this design choice is to simplify the way rooms from WWTravelClub are described:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d7b5096e-d9e3-49f8-a384-606831fec9be.png"/></p>
<p><span>As shown in the following code, the code for this is implemented</span> <span>in a way where the</span> <span>configurations of the instances </span><span>aren't set in</span> <span>the main program. Instead, you just build the objects using the <kbd>Construct()</kbd> method. This example is simulating the creation of different room styles (a single room and a family room) in the WWTravelClub:</span></p>
<pre>using DesignPatternsSample.BuilderSample;<br/>using System;<br/><br/>namespace DesignPatternsSample<br/>{<br/>    class Program<br/>    {<br/>        static void Main()<br/>        {<br/>            #region Builder Sample<br/>            Console.WriteLine("Builder Sample");<br/><br/>            var directorRoom = new DirectorRooms(new SimpleRoomBuilder());<br/>            var simpleRoom = directorRoom.Construct();<br/>            simpleRoom.Describe();<br/>          <br/>            directorRoom = new DirectorRooms(new FamilyRoomBuilder());<br/>            var familyRoom = directorRoom.Construct();<br/>            familyRoom.Describe();<br/>            #endregion<br/><br/>            Console.ReadKey();<br/>        }<br/>    }<br/>}</pre>
<p>The result of this implementation is quite simple but clarifies the reason why you need to implement a pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a770151-f3f3-4c83-b37e-a4effe5208ea.png" style="width:23.50em;height:12.17em;"/></p>
<p>As soon as you have the implementation, evolving this code becomes simpler and easier. For example, if you need to build a different style of room, you just have to create the concrete builder for that and you will be able to use it. Fortunately, if you need to increase the configuration settings for the product, all the concrete classes you used previously will be defined in the Builder interface and stored there so that you can update them with ease.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Factory pattern</h1>
                </header>
            
            <article>
                
<p>The Factory pattern is really useful in situations where you have multiple objects from the same abstraction and you don't know which need to be created by the time you start coding. This means you will have to create the instance according to a certain configuration or according to where the software is living at the moment. </p>
<p>For instance, let's check out the WWTravelClub sample. Here, there's a User Story that describes that this application will have customers from all over the world paying for their trips. However, in the real world, there are different payment services available for each country. The process of paying is similar for each country, but this system will have more than one payment service available. A good way to simplify this payment implementation is by using the Factory pattern. The following diagram shows the basic idea of its architectural implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/94214e08-4bd1-45fc-9b37-fa26ce54fa97.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Notice that, since you have an interface that describes what the Payment Service for the application is, you can use the factory to change the concrete class according to the services that are available:</p>
<pre>static void Main()<br/>{<br/>    #region Factory Sample<br/>    var psCreator = new PaymentServiceCreator();<br/>    var brazilianPaymentService = (IPaymentService)psCreator.Factory<br/>        (PaymentServiceCreator.ServicesAvailable.Brazilian);<br/>    brazilianPaymentService.EmailToCharge = "gabriel@sample.com";<br/>    brazilianPaymentService.MoneyToCharge = 178.90f;<br/>    brazilianPaymentService.OptionToCharge =<br/>        FactorySample.Enums.EnumChargingOptions.CreditCard;<br/>    brazilianPaymentService.ProcessCharging();<br/>    <br/>    var italianPaymentService = (IPaymentService)psCreator.Factory<br/>        (PaymentServiceCreator.ServicesAvailable.Italian);<br/>    italianPaymentService.EmailToCharge = "francesco@sample.com";<br/>    italianPaymentService.MoneyToCharge = 188.70f;<br/>    italianPaymentService.OptionToCharge =<br/>        FactorySample.Enums.EnumChargingOptions.DebitCard;<br/>    italianPaymentService.ProcessCharging();<br/>    #endregion<br/>    Console.ReadKey();<br/>}</pre>
<p>Once again, the service's usage has been simplified due to the implemented pattern. If you were to use this code in a real-world application, you would change the instance's behavior by defining the service you need in the Factory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton pattern</h1>
                </header>
            
            <article>
                
<p>When you implement a Singleton in your application, you will have a single instance of the object implemented in the entire solution. This can be considered as one of the most used patterns in every application. The reason is simple <span>– </span>there are many use cases where you need some classes to have just one instance. Singletons solve this by providing a better solution than a global variable does.</p>
<p>In the Singleton pattern, the class is responsible for creating and delivering a single object that will be used by the application. In other words, the Singleton class creates a single instance:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73659067-540d-4379-a698-9df3fe07fafa.png" style="width:11.25em;height:21.25em;"/> </p>
<p>To do so, the object that's created is <kbd>static</kbd> and is delivered in a static property or method. The following code implements the Singleton pattern, which has a <kbd>Message</kbd> property and a <kbd>Print()</kbd> method:</p>
<pre>public sealed class SingletonDemo<br/>{<br/>    #region This is the Singleton definition<br/>    private static SingletonDemo _instance;<br/>    public static SingletonDemo Current<br/>    {<br/>        get<br/>        {<br/>            if (_instance == null)<br/>                _instance = new SingletonDemo();<br/>            return _instance;<br/>        }<br/>    }<br/>    #endregion<br/><br/>    public string Message { get; set; }<br/><br/>    public void Print()<br/>    {<br/>        Console.WriteLine(Message);<br/>    }<br/>}</pre>
<p>Its usage is really simple <span>– </span>you just need to call the static property every time you need to use the Singleton object:</p>
<pre>SingletonDemo.Current.Message = "This text will be printed by the singleton.";<br/>SingletonDemo.Current.Print();</pre>
<p>One of the places where you may use this pattern is when you need to deliver the app configuration in a way that can be easily accessed from anywhere in the solution. For instance, let's say you have some configuration parameters that are stored in a table that your app needs to query at several decision points. Instead of querying the configuration table directly, you can create a Singleton class to help you:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93719043-7e2b-43f3-9d1c-182662e4de97.png" style="width:15.92em;height:19.08em;"/></p>
<p>Moreover, you will need to implement a cache in this Singleton, thus improving the performance of the system, since you will be able to decide whether the system will check each configuration in the database every time it needs it or if the cache will be used. The following screenshot shows the implementation of the cache where the configuration is loaded every 5 seconds. The parameter that is being read in this case is just a random number:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2dfb9f8-0240-451d-826b-9ae519f91d8b.png" style="width:34.75em;height:26.75em;"/></p>
<p>This is great for the application's performance. Besides, using parameters in several places in your code is simpler, since you don't have to create configuration instances everywhere in the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxy pattern</h1>
                </header>
            
            <article>
                
<p>The Proxy pattern is used when you need to provide an object that controls access to another object. One of the biggest reasons why you should do this is related to the cost of creating the object that is being controlled. For instance, if the controlled object takes too long to be created or consumes too much memory, a proxy can be used to guarantee that the huge part of the object will only be created when it's required.</p>
<p class="mce-root"/>
<p>The following class diagram shows the class diagram of a Proxy pattern's implementation for loading pictures from the Room, but only when requested:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17bd01c8-99ca-44a8-8311-d618f50ae1d7.png" style="width:35.08em;height:28.42em;"/></p>
<p>The client of this proxy will request its creation. Here, the proxy will only gather basic information (<kbd>Id</kbd>, <kbd>FileName</kbd>, and <kbd>Tags</kbd>) from the real <span>object and won't query</span> <kbd>PictureData</kbd>. When <kbd>PictureData</kbd> is requested, the proxy will load it:</p>
<pre>static void Main()<br/>{<br/>    Console.WriteLine("Proxy Sample");<br/>    var roomPicture = new ProxyRoomPicture();<br/>    Console.WriteLine($"Picture Id: {roomPicture.Id}");<br/>    Console.WriteLine($"Picture FileName: {roomPicture.FileName}");<br/>    Console.WriteLine($"Tags: {string.Join(";", roomPicture.Tags)}");<br/>    Console.WriteLine($"1st call: Picture Data");<br/>    Console.WriteLine($"Image: {roomPicture.PictureData}");<br/>    Console.WriteLine($"2nd call: Picture Data");<br/>    Console.WriteLine($"Image: {roomPicture.PictureData}");<br/>}</pre>
<p>If <kbd>PictureData</kbd> is requested again, since image data is already in place, the proxy will guarantee that image reloading will not be repeated. The following screenshot shows the result of running the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54cf03cd-511a-4ad9-9fa6-98d6444855e9.png" style="width:25.92em;height:11.83em;"/></p>
<p>This technique can be referred to as another well-known pattern: <strong>lazy loading</strong>. In fact, the Proxy pattern is a way of implementing lazy loading. For instance, in Entity Framework Core 2.1, as discussed in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a>, <em>Interacting with Data in C# - Entity Framework Core</em>, you can turn on lazy loading using proxies. You can find out more about this at <a href="https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading">https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command pattern</h1>
                </header>
            
            <article>
                
<p>There are many cases where you need to execute a <em>command</em> that will affect the behavior of an object. The Command pattern can help you with this by encapsulating this kind of request in an object. The pattern also describes how to handle undo/redo support for the request.</p>
<p class="CDPAlignLeft CDPAlign">For instance, let's imagine that, on the WWTravelClub website, the users have the ability to evaluate the packages by specifying whether they like, dislike, or even love them. The following class diagram is an example of what can be implemented to create this rating system with the Command pattern:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/69730dee-9393-4ae2-b992-7ba7e8fcbcc1.png"/></p>
<p>Notice the way this pattern works <span>– i</span>f you need a different command, such as <span class="packt_screen">Hate</span>, you don't need to change the code and classes that use the command. The Undo method can be added in a similar way to the Redo method. The full code sample for this is available in this book's GitHub repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher/Subscriber pattern</h1>
                </header>
            
            <article>
                
<p>Providing information from an object to a group of other objects is common in all applications. The Publisher/Subscriber pattern is almost mandatory when there's a large volume of components <span>(subscribers) </span>that will receive a message containing the information that was sent by the object (publisher).</p>
<p>The concept here is quite simple to understand and is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/52ef2ea5-0ab4-4c21-8abe-e8ba22065fa3.png"/></p>
<p><span>When you have an indefinite number of different possible subscribers, it is essential to decouple the component that broadcasts information from the components that consume it. The Publisher/Subscriber pattern does this for us.</span></p>
<p><span>Implementing this pattern is complex, since distributing environments isn't a trivial task. Therefore, it is recommended that you consider already existing technologies for implementing the Message Broker that connects the Input Channel to the Output Channels, instead of building it from scratch. Azure Service Bus is a reliable implementation of this pattern, so all you need to do is connect to it.</span></p>
<p><span>RabbitMQ, which we mentioned in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, is another service that can be used to implement a Message Broker, but it is a lower-level implementation of the pattern and requires several related tasks, such as retries, in case errors have to be coded manually.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency Injection pattern</h1>
                </header>
            
            <article>
                
<p><span>The Dependency Injection pattern is considered a good </span><span>way to implement the Dependency Inversion principle. Besides, it forces all the other SOLID principles to be followed by the implementation. </span>As we discussed at the beginning of this chapter, a way to keep the software's structure strong and reliable is by following the SOLID design principles presented by Uncle Bob. These can be defined as follows:</p>
<ul>
<li><strong>Single Responsibility</strong>: A module or function should be responsible for a single purpose.</li>
<li><strong>Open-Closed</strong>: A software artifact should be open for extension but closed for modification.</li>
<li><strong>Liskov Substitution</strong>: The behavior of a program needs to remain unchanged when you substitute one of its components for another component that's been defined by a supertype of the primer object.</li>
<li><strong>I</strong><span><strong>nterface Segregation</strong>: Creating huge interfaces will cause dependencies to occur while you're building concrete objects, but these are harmful to the system architecture.</span></li>
<li><strong>Dependency Inversion</strong>: The most flexible systems are the ones where object dependencies only refer to abstractions.</li>
</ul>
<p>This concept is quite simple. Instead of creating instances of the objects that the component <span>depends on</span>, you just need to define their dependencies, declare their interfaces, and enable the reception of the objects by <em>injection</em>.</p>
<p>There are three ways to perform dependency injection:</p>
<ul>
<li>Use the constructor of the class to receive the objects.</li>
<li>Tag some class properties to receive the objects.</li>
<li>Define an interface with a method to inject all the necessary components.</li>
</ul>
<p>The following diagram shows the implementation of the Dependency Injection pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2489a07f-eb5f-42fd-9aaf-320472e5bc56.png"/></p>
<p>Apart from this, dependency injection can be used with an <strong>Inversion of Control</strong> (<strong>IoC</strong>) container. This container enables the automatic injection of dependencies whenever they are asked for. <span>There are several IoC container frameworks available on the market, but w</span>ith .NET Core, there is no need to use third-party software since it contains a set of libraries to solve this in the <kbd>Microsoft.Extensions.DependencyInjection</kbd> namespace.</p>
<p>This IoC container is responsible for creating and disposing of the objects that are requested. The implementation of dependency injection is based on Constructor types. There are three options for the injected component's lifetime:</p>
<ul>
<li><strong>Transient</strong>: The objects are created each time they are requested.</li>
<li><strong>Scoped</strong>: The objects are created for each <span class="packt_screen">scope</span> defined in the application. <span>In a Web App, a <em>scope</em> is identified with a web request.</span></li>
<li><strong>Singleton</strong>: Each object has the same application lifetime, so a single object is reused to serve all the requests for a given type.</li>
</ul>
<p>The way you are going to use these options depends on the business rules of the project you are developing. You need to be careful in deciding the correct one, since the behavior of the application will change according to <span>the type of object you are injecting.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the available design patterns in .NET Core</h1>
                </header>
            
            <article>
                
<p>As we discovered in the previous sections, C# allows us to implement any of the aforementioned patterns. .NET Core provides many implementations in its SDK that follow all the patterns we've discussed, such as Entity Framework Core Proxy Lazy Loading. Another good example that's been <span>available since .NET Core 2.1 </span>is .NET Generic Host. </p>
<p>In <a href="003ee8cb-5995-4364-8772-73d73df29cf8.xhtml">Chapter 13</a>, <em>Presenting ASP.NET Core MVC</em>, we will detail the hosting that's available for Web Apps in .NET Core. This web host helps us since the app's startup and lifetime management is set up alongside it. The idea of .NET Generic Host is to enable this pattern for applications that don't need HTTP implementation. With this Generic Host, any .NET Core program can have a Startup class where we can configure the Dependency Injection Engine. This can be really useful for creating multi-service apps. </p>
<p>You can find out more at .NET Generic Host at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host</a>, which contains some sample code. The code provided in this book's GitHub repository is simpler, but it focuses on the creation of a console app that can run a service for monitoring. The great thing about this is the way the console app is set up to run, where the builder configures the services that will be provided by the application, and the way logging will be managed. This is shown in the following code:</p>
<pre>public static void Main()<br/>{<br/>    var host = new HostBuilder()<br/>        .ConfigureServices((hostContext, services) =&gt;<br/>        {<br/>            services.AddHostedService&lt;HostedService&gt;();<br/>            services.AddHostedService&lt;MonitoringService&gt;();<br/>        })<br/>        .ConfigureLogging((hostContext, configLogging) =&gt;<br/>        {<br/>            configLogging.AddConsole();<br/>        })<br/>        .Build();<br/>    host.Run();<br/>    <br/>    Console.WriteLine("Host has terminated. Press any key to finish the <br/>    App.");<br/>    Console.ReadKey();<br/> }</pre>
<p class="mce-root"><span>The preceding code gives us an idea of how .NET Core uses design patterns. Using the</span> Builder pattern<span>, .NET Generic Host allows you to set the classes that will be</span> injected <span>as services. Apart from this, the Builder pattern helps you configure some other</span> features, such as <span>the way logs will be shown/stored. This configuration allows the services to inject <kbd>ILogger&lt;out TCategoryName&gt;</kbd> objects into any instance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we understood why design patterns help with the maintainability and reusability of the parts of the system you are building. We also looked at some typical use cases and code snippets that you can use in your projects. Finally, we presented .NET Generic Host, which is a good example of how .NET uses design patterns to enable code <span>reusability </span>and enforce best practices. All this content will help you while architecting a new software or even maintaining an existing one, since design patterns are solutions already known for some real life problems in software development. </p>
<p>In the next chapter, we will cover the domain-driven design approach. We will also learn how to use SOLID design principles so that we can map different domains to our software solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are design patterns?</li>
<li>What's the difference between design patterns and design principles?</li>
<li>When is it a good idea to implement the Builder pattern?</li>
<li>When is it a good idea to implement the Factory pattern?</li>
<li>When is it a good idea to implement the Singleton pattern?</li>
<li>When is it a good idea to implement the Proxy pattern?</li>
<li>When is it a good idea to implement the Command pattern?</li>
<li>When is it a good idea to implement the Publisher/Subscriber pattern?</li>
<li>When is it a good idea to implement the Dependency Injection pattern?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>The following are some books and websites where you can find out more regarding what was covered in this chapter:</span></p>
<ul>
<li><span><em>Clean Architecture: A Craftsman's Guide to Software Structure and Design</em>,<span> </span>Martin, Robert C. Pearson Education, 2018.</span></li>
<li><span><em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, Erica Gamma et al. Addison-Wesley, 1994.</span></li>
<li><em>Design Principles and Design Patterns</em>, Robert C. Martin, 2000.</li>
</ul>
<p>If you need to get more info about design patterns and architectural principles, please check these links:</p>
<ul>
<li><a href="https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video">https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles">https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles</a></li>
</ul>
<p>If you want to understand better the idea of generic hosts, follow this link:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host</a></li>
</ul>
<p>There is a very good explanation about service bus messaging in this link:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions</a></li>
</ul>
<p>You can learn more about dependency injection checking these links:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a></li>
<li><a href="https://www.martinfowler.com/articles/injection.html">https://www.martinfowler.com/articles/injection.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>