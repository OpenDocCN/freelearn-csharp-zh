<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-276"><a id="_idTextAnchor275"/>13</h1>
<h1 id="_idParaDest-277"><a id="_idTextAnchor276"/>Creating a Roslyn Analyzer</h1>
<p>In the previous chapter, we covered the use of code analyzers to detect issues in code. But what happens when your team has common issues that aren’t detected by any existing analysis rules?</p>
<p>It turns out that modern C# provides a means for building custom analyzers through something called <strong class="bold">Roslyn Analyzers</strong>. In this chapter, we’ll see how Roslyn Analyzers work in action by building an analyzer of our own.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Understanding Roslyn Analyzers</li>
<li>Creating a Roslyn Analyzer</li>
<li>Testing Roslyn Analyzers with <code>RoslynTestKit</code></li>
<li>Sharing analyzers as Visual Studio extensions</li>
</ul>
<h1 id="_idParaDest-278"><a id="_idTextAnchor277"/>Technical requirements</h1>
<p>Unlike other chapters, we won’t be starting with sample code. Instead, we’ll be starting with a blank solution and gradually adding new projects to that solution.</p>
<p>The starting empty solution and final code for this chapter are available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter13</code> folder.</p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor278"/>Understanding Roslyn Analyzers</h1>
<p>Before we can go into<a id="_idIndexMarker781"/> what a Roslyn Analyzer is, let’s talk about Roslyn.</p>
<p><strong class="bold">Roslyn</strong> is the codename for the reimagined <strong class="bold">.NET Compiler Platform</strong> that was released alongside Visual Studio 2015. Since “.NET Compiler Platform” is a lot to say, most people refer to this as the Roslyn compiler or simply Roslyn for short.</p>
<p>Before Roslyn, if a tool wanted to understand C#, VB, or F# source code, developers needed to write their own language parser for these code files. This involved a significant amount of time and complexity, and this effort needed to be repeated every time these programming languages changed. This led to tools being slower to support new language features, lost productivity, and bugs.</p>
<p>One of the explicit <a id="_idIndexMarker782"/>goals of the Rosyln compiler was to provide visibility into the structure of code in a standardized way. This way, plugins could work with the Roslyn APIs to get live information about code without having to write their own parser.</p>
<p>To do this, projects can create <strong class="bold">Roslyn Analyzers</strong>, which integrate into the code analysis and compilation process. This lets you do the following:</p>
<ul>
<li>Provide warnings and errors when anti-patterns in code are present</li>
<li>Integrate into the <strong class="bold">Quick Actions</strong> menu, allowing developers to automatically fix known issues using established solutions</li>
<li>Provide refactoring capabilities, thereby improving developer productivity</li>
</ul>
<p>You’ve been working with Roslyn Analyzers this whole time with the various code warnings, suggestions, and <strong class="bold">Quick Action</strong> refactorings you’ve seen in Visual Studio.</p>
<p>You can explore the built-in analyzers in your projects by going to <strong class="bold">Solution Explorer</strong> and then expanding a project’s <strong class="bold">Dependencies</strong> node, followed by its <strong class="bold">Analyzers</strong> node and specific analyzer assemblies, as shown in <em class="italic">Figure 13</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 13.1 – Code analyzers in Solutions Explorer" src="img/B21324_13_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Code analyzers in Solutions Explorer</p>
<p>Through the rest <a id="_idIndexMarker783"/>of this chapter, we’ll create a Roslyn Analyzer of our own, but before we do, let’s talk about how Roslyn sees C# code.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor279"/>Installing the extension development workload and DGML editor</h2>
<p>When you’re developing with <a id="_idIndexMarker784"/>Roslyn Analyzers, two additions to Visual Studio will help you create and debug your own analyzers. Let’s install<a id="_idIndexMarker785"/> these by launching <strong class="bold">Visual Studio Installer</strong> from the<a id="_idIndexMarker786"/> Windows start menu. Next, select your installation of Visual Studio and click <strong class="bold">Modify</strong>.</p>
<p>This will bring up a list of workloads and features that are available. These change over time, but you’ll want to make sure that the <strong class="bold">Visual Studio extension development</strong> workload is checked in the <strong class="bold">Workloads</strong> tab, as shown in <em class="italic">Figure 13</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 13.2 – Installing Visual Studio extension development and DGML editor" src="img/B21324_13_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Installing Visual Studio extension development and DGML editor</p>
<p>Next, find <strong class="bold">DGML editor</strong> in the <strong class="bold">Individual components</strong> tab and check it as well before clicking <strong class="bold">Modify</strong> to install the additional components.</p>
<p>The Visual Studio extension <a id="_idIndexMarker787"/>development workload is useful when you are trying to create a VSIX extension <a id="_idIndexMarker788"/>project for Visual Studio. This type of project allows you to add custom user interface elements, analyzers, and new features to Visual Studio. We’ll talk more about VSIX extensions periodically throughout the rest of this chapter and the next.</p>
<p>The DGML editor works<a id="_idIndexMarker789"/> with <strong class="bold">Directed Graph Markup Language</strong> (<strong class="bold">DGML</strong>) to show interactive visualizations in Visual Studio. It also happens to install a very useful view that will help us understand Rosyln more: <strong class="bold">Syntax Visualizer</strong>.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/>Introducing Syntax Visualizer</h2>
<p><strong class="bold">Syntax Visualizer</strong> is a view in Visual<a id="_idIndexMarker790"/> Studio that allows you to see the structure of source code from the Roslyn API’s point of view.</p>
<p>To see this in action, open a<a id="_idIndexMarker791"/> C# file in your editor and then open <strong class="bold">Syntax Visualizer</strong> by clicking the <strong class="bold">View</strong> menu, followed by <strong class="bold">Other Windows</strong> and then <strong class="bold">Syntax Visualizer</strong>.</p>
<p>This should show you a hierarchy of various nodes corresponding to the code in your editor, as shown in <em class="italic">Figure 13</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 13.3 – Syntax Visualizer synchronizing with the current code selection" src="img/B21324_13_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Syntax Visualizer synchronizing with the current code selection</p>
<p>Click on various keywords, variables, methods, and<a id="_idIndexMarker792"/> values in your code and watch <strong class="bold">Syntax Visualizer</strong> change to reflect what you’ve selected.</p>
<p>This is a very good way of<a id="_idIndexMarker793"/> understanding how code is structured in Roslyn’s APIs, but the tool can also be helpful when you’re not sure what class inside of the Roslyn API refers to the type of code element you want to work with.</p>
<p>Now that we have a slightly greater understanding of what the Roslyn API is, let’s create our first Roslyn Analyzer.</p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor281"/>Creating a Roslyn Analyzer</h1>
<p>People create custom <a id="_idIndexMarker794"/>Roslyn Analyzers when they experience common issues in their code that no existing analyzer addresses. These custom analyzers help enforce rules that specific organizations or teams find to be useful. However, these organization-specific rules tend to be less relevant to the larger .NET community.</p>
<p>Here are a few examples of when you might want to build a custom analyzer:</p>
<ul>
<li>Your team has been having issues with too many <code>FormatException</code> errors from things such as <code>int.Parse</code> and wants to make <code>int.TryParse</code> their standard</li>
<li>Due to large files and limited memory, your team wants to avoid the <code>File.ReadAllText</code> method and use stream-based approaches instead</li>
<li>Your team mandates that all classes must override the <code>ToString</code> method to improve the debugging and logging experience</li>
</ul>
<p>Note that none of these approaches relate to styling or syntax. Instead, these analyzers deal with team-specific <a id="_idIndexMarker795"/>decisions about how to best use .NET. We’ll explore ways of enforcing styling and syntax choices in <a href="B21324_16.xhtml#_idTextAnchor341"><em class="italic">Chapter 16</em></a>, <em class="italic">Adopting </em><em class="italic">Code Standards</em>.</p>
<p>Let’s say that Cloudy Skies Airlines is spending a lot of time debugging and troubleshooting code and suspects that overriding <code>ToString</code> in more places would lead to a better developer experience for their team.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s not an established best practice to override <code>ToString</code> in all classes. There are likely some performance drawbacks to doing so, but for this chapter, we’ll assume this rule makes sense for the Cloudy Skies team.</p>
<p>Throughout the rest of this chapter, we’ll create this analyzer, starting from a blank solution.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor282"/>Adding the analyzer project to our solution</h2>
<p>While there are<a id="_idIndexMarker796"/> templates for creating Roslyn Analyzers built into Visual Studio, these are older templates and they hide some of the implementation details. Instead, we’re going to walk through the steps of creating and deploying a Roslyn Analyzer from an empty solution.</p>
<p>We’ll start by adding a class library that will contain our analyzer. Class libraries are a special type of project that provides code to other projects but cannot run on their own.</p>
<p>Starting with the <code>Chapter13BeginningCode</code> solution, we’ll right-click on the solution in <strong class="bold">Solution Explorer</strong> and then choose <strong class="bold">Add</strong> and then <strong class="bold">New Project…</strong>.</p>
<p>From there, we’ll select<a id="_idIndexMarker797"/> the type of project we want to create, select a <strong class="bold">Class Library</strong> project using the C# language, as shown in <em class="italic">Figure 13</em><em class="italic">.4</em>, and click <strong class="bold">Next</strong>:</p>
<div><div><img alt="Figure 13.4 – Adding a C# Class Library project to our solution" src="img/B21324_13_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Adding a C# Class Library project to our solution</p>
<p class="callout-heading">Warning</p>
<p class="callout">There are multiple projects with the name Class Library in different languages. Look for the green C# icon and the C# label in the list.</p>
<p>Next, we’ll need to provide a name for our class library. This is the library that will hold the code analyzer we’re creating this chapter, so let’s call it <code>Packt.Analyzers</code> since the name of the project will become the default namespace of the project.</p>
<p>After this, you’ll be asked to select the framework the project should use. Select <strong class="bold">.NET Standard 2.0</strong> and click <strong class="bold">Create</strong>. The new project will be added to your solution.</p>
<p class="callout-heading">Why .NET Standard?</p>
<p class="callout">Unlike other projects in this book, we’re using .NET Standard here. This is a special version of .NET that was designed to run on a variety of different .NET runtimes. This makes .NET Standard a great choice for when you don’t know which version of .NET your code will be running in. See the <em class="italic">Further reading</em> section for more information.</p>
<p>To create a Roslyn Analyzer, we’ll need to add a few NuGet packages to our class library. To do this, right-click on the class library in <strong class="bold">Solution Explorer</strong> and then choose <strong class="bold">Manage </strong><strong class="bold">NuGet Packages…</strong>.</p>
<p>Once you’re in <code>Microsoft.CodeAnalysis</code> package, as shown in <em class="italic">Figure 13</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 13.5 – Installing version 4.0.1 of Microsoft.CodeAnalysis" src="img/B21324_13_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Installing version 4.0.1 of Microsoft.CodeAnalysis</p>
<p>Note that version 4.0.1 is not the most recent version of this package. This specific version was chosen to avoid a conflict with the testing library we’ll use later.</p>
<p>Now that the package has been installed, we’re ready to start creating our Roslyn Analyzer.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor283"/>Defining a code analysis rule</h2>
<p>Let’s start by <a id="_idIndexMarker799"/>renaming the <code>Class1.cs</code> file to <code>ToStringAnalyzer.cs</code> and replacing its contents with the following:</p>
<pre class="source-code">
using System;
using System.Linq;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
namespace Packt.Analyzers {
  [DiagnosticAnalyzer(LanguageNames.CSharp)]
  public class ToStringAnalyzer : DiagnosticAnalyzer {
  }
}</pre>
<p>This is the minimum<a id="_idIndexMarker800"/> we need to have a compiling analyzer. Let’s explore what’s here.</p>
<p>First of all, the <code>ToStringAnalyzer</code> class inherits from <code>DiagnosticAnalyzer</code>, which is a base class for all Roslyn Analyzers that provide warnings to the user.</p>
<p>The class has a <code>DiagnosticAnalyzer</code> attribute that says the analyzer applies to code written in C#.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s possible to write analyzers that apply to C#, F#, Visual Basic, or some combination of these languages.</p>
<p>Inheriting from the abstract <code>DiagnosticAnalyzers</code> class forces us to override the <code>SupportedDiagnostics</code> property and the <code>Initialize</code> method. Let’s do that now in the simplest way possible:</p>
<pre class="source-code">
public override ImmutableArray&lt;DiagnosticDescriptor&gt;
  SupportedDiagnostics =&gt; null;
public override void Initialize(AnalysisContext con) {
}</pre>
<p>The <code>SupportedDiagnostics</code> property returns <code>ImmutableArray</code>, which contains all diagnostic rules the analyzer provides to the editor. In our case, we’ll want it to return the warning the user might see if the rule is violated.</p>
<p>Let’s add a new property and update our <code>SupportedDiagnostics</code> property, as shown here:</p>
<pre class="source-code">
<strong class="bold">public static readonly DiagnosticDescriptor Rule =</strong>
<strong class="bold">  new DiagnosticDescriptor(</strong>
<strong class="bold">    id: "CSA1001",</strong>
<strong class="bold">    title: "Override ToString()",</strong>
<strong class="bold">    messageFormat: "Override ToString on {0}",</strong>
<strong class="bold">    category: "Maintainability",</strong>
<strong class="bold">    defaultSeverity: DiagnosticSeverity.Info,</strong>
<strong class="bold">    isEnabledByDefault: true,</strong>
<strong class="bold">    description: "Override ToString to help debugging.");</strong>
public override ImmutableArray&lt;DiagnosticDescriptor&gt;
  SupportedDiagnostics =&gt; <strong class="bold">ImmutableArray.Create(Rule);</strong></pre>
<p>Here, we’ve added a static <code>Rule</code> property that defines the <code>DiagnosticDescriptor</code> object that’s <a id="_idIndexMarker801"/>defining our rule. This rule is then included in the <code>SupportedDiagnostics</code> property.</p>
<p class="callout-heading">Localization note</p>
<p class="callout"><code>DiagnosticDescriptor</code> objects can be created with either raw strings, as we’re using here, or by using <code>LocalizableString</code> parameters. <code>LocalizableString</code> works better in different languages, so you’ll want to use it if you are trying to create a Roslyn Analyzer intended to be used throughout the globe.</p>
<p>The <code>DiagnosticDescriptor</code> object that this code defines will show up in the <strong class="bold">Error List</strong> pane and build output if the rule is ever violated. The rule needs the following parts:</p>
<ul>
<li><code>CSA</code> for Cloudy Skies Airlines.</li>
<li><strong class="bold">Title</strong>: The short name of the code analysis warning. This is what will appear in tooltips when the rule is violated.</li>
<li><strong class="bold">Message format</strong>: A formattable string that will appear in the Visual Studio tooltip.</li>
<li><code>Naming</code>, <code>Performance</code>, <code>Maintainability</code>, <code>Security</code>, <code>Reliability</code>, <code>Design</code>, and <code>Usage</code>.</li>
<li><code>Hidden</code>, <code>Info</code>, <code>Warning</code>, or <code>Error</code>.</li>
<li><strong class="bold">Enabled by default</strong>: Whether the rule starts as enabled.</li>
<li><strong class="bold">Description</strong>: A detailed description of the rule and why it’s important. This shows up in the <strong class="bold">Error List</strong> pane when a rule violation is expanded.</li>
</ul>
<p>Defining your rule as a separate property is helpful when other code needs to refer to your exact rule <a id="_idIndexMarker802"/>definition.</p>
<p>Now that our rule has been defined, let’s write the code that detects when the rule is violated.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor284"/>Analyzing symbols with our Roslyn Analyzer</h2>
<p>Let’s start by building <a id="_idIndexMarker803"/>out our <code>Initialize</code> method:</p>
<pre class="source-code">
public override void Initialize(AnalysisContext con) {
<strong class="bold">  con.ConfigureGeneratedCodeAnalysis(</strong>
<strong class="bold">    GeneratedCodeAnalysisFlags.None);</strong>
<strong class="bold">  con.EnableConcurrentExecution();</strong>
<strong class="bold">  con.RegisterSymbolAction(Analyze, SymbolKind.NamedType);</strong>
}</pre>
<p>This method now does a few additional things:</p>
<ul>
<li>First, we configure the analyzer to ignore any auto-generated code for analysis purposes. These are files that the user didn’t write but various tools generate and so it doesn’t make sense to analyze them.</li>
<li>Secondly, we tell Roslyn that it’s fine to evaluate multiple pieces of code with this rule at the same time. This is always the preferred option from a performance standpoint.</li>
</ul>
<p>Finally, we tell the analyzer that whenever it encounters a named <code>Type</code> during code analysis, we want to<a id="_idIndexMarker804"/> know about it. Specifically, the code should call a new <code>Analyze</code> method for each <code>Type</code> that is detected.</p>
<p>We haven’t written that <code>Analyze</code> method yet, so let’s do so now:</p>
<pre class="source-code">
private static void Analyze(
  SymbolAnalysisContext con) {
  INamedTypeSymbol sym = (INamedTypeSymbol)con.Symbol;
  IMethodSymbol toString =
    sym.GetMembers()
       .OfType&lt;IMethodSymbol&gt;()
       .FirstOrDefault(m =&gt; m.Name == "ToString"
                         &amp;&amp; m.IsOverride
                         &amp;&amp; m.Parameters.Length == 0);
  if (toString == null) {
    Diagnostic diagnostic = Diagnostic.Create(
      Rule, sym.Locations[0], sym.Name);
    con.ReportDiagnostic(diagnostic);
  }
}</pre>
<p>This code is not easy to write or read, so let’s go over it before discussing <em class="italic">how</em> to write analyzer code.</p>
<p>First, since we know this method is called on named types, we can cast the symbol Roslyn gives us to <code>INamedTypeSymbol</code>, which lets us query further.</p>
<p>Using this symbol, we can ask for all members such as properties and methods using <code>GetMembers</code>. Next, we<a id="_idIndexMarker805"/> can use LINQ to filter these down to just ones that are methods. Once we have these, we can use <code>FirstOrDefault</code> to see if we have a method named <code>ToString</code> that takes in zero parameters and is an override.</p>
<p class="callout-heading">Why not check the return type?</p>
<p class="callout">We could check if the return type was a string, but the C# compiler doesn’t allow multiple methods with the same parameters and different return types. We also know all objects have <code>string ToString()</code>, so the return type will be <code>string</code>.</p>
<p>If we didn’t find a <code>ToString</code> override, our analyzer should flag this as a violation of the rule. It does so by creating a <code>Diagnostic</code> object referencing the <code>Rule</code> property we defined earlier, as well as the name and location of the symbol that violated the rule. Here, the symbol will be a <code>Type</code> definition that does not override <code>ToString</code>.</p>
<p>Before we go into verifying our analyzer works, let’s talk about writing analyzer code.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>Tips for writing Roslyn Analyzers</h2>
<p>In my experience, Roslyn<a id="_idIndexMarker806"/> Analyzers are one of the tougher pieces of code to write. With Roslyn, you’re looking at your C# code in a completely different light.</p>
<p>Each analyzer you write will likely be analyzing something completely different than the last one, making discussing the breadth of options available in Roslyn difficult.</p>
<p>I’ve found two key things helpful for writing Roslyn Analyzers:</p>
<ul>
<li><strong class="bold">Looking at other Roslyn Analyzers</strong>: There are a lot of other Roslyn Analyzers out there (including the ones built into .NET) and most are open source. This means you can find an existing analyzer similar to what you’re interested in and then look at its source code and do something similar.<p class="list-inset">See the <em class="italic">Further reading</em> section of this chapter for a few popular collections of Roslyn Analyzers.</p></li>
<li><code>Analyze</code> method, you can give Copilot a prompt such as “I want to find all methods contained in this type” or “How would I check if this type is marked as public?”<p class="list-inset">You still need to provide high-level guidance, but in my experience, Copilot can be extremely effective at helping you write complex and unfamiliar analyzer code.</p></li>
</ul>
<p>Now that we’ve built our<a id="_idIndexMarker807"/> Roslyn Analyzer, let’s look at how we can make sure it works.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor286"/>Testing Roslyn Analyzers with RoslynTestKit</h1>
<p>We’ll show how to use your <a id="_idIndexMarker808"/>Roslyn Analyzers in projects of your own at the end of this chapter, but we’ll start by writing unit tests around our <a id="_idIndexMarker809"/>existing analyzer.</p>
<p>At a high level, we want to test two things with our analyzer:</p>
<ul>
<li>The analyzer doesn’t trigger for code that doesn’t violate its rule.</li>
<li>The analyzer correctly flags code that it should.</li>
</ul>
<p>We’ll do this with two unit tests in a new unit test project.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>Adding a Roslyn Analyzer test project</h2>
<p>Our tests can be <a id="_idIndexMarker810"/>written in <strong class="bold">MSTest</strong>, <strong class="bold">xUnit</strong>, or <strong class="bold">NUnit</strong>. We’ll use xUnit for consistency.</p>
<p>We’ll start by adding a new xUnit project to the solution by right-clicking on the solution and then choosing <strong class="bold">Add</strong> and then <strong class="bold">New Project…</strong>, as we’ve done before.</p>
<p>After this, select the C# version of <code>Packt.Analyzers.Tests</code> and click <strong class="bold">Next</strong>. When prompted with the framework, select <strong class="bold">.NET 8.0</strong> and click <strong class="bold">Create</strong>.</p>
<p>Once the project has been created, add a project reference to <code>Packt.Analyzers</code> by right-clicking on the <code>Packt.Analyzers.Tests</code> project and then<a id="_idIndexMarker811"/> selecting <strong class="bold">Add Project Reference…</strong>, as shown in <em class="italic">Figure 13</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 13.6 – Add Project Reference…" src="img/B21324_13_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Add Project Reference…</p>
<p>Check the box next to <code>Packt.Analyzers</code> and click <strong class="bold">OK</strong>. This will allow you to reference your analyzers from the test project.</p>
<p>Next, we’ll need to add a reference to the <strong class="bold">RoslynTestKit</strong> NuGet package. This is a testing framework-agnostic library that lets us unit-test Roslyn Analyzers by extending from certain test fixture classes, as we’ll see in a moment.</p>
<p>Right-click <code>Packt.Analyzers.Tests</code> and click <code>SmartAnalyzers.RoslynTestKit</code>.</p>
<p class="callout-heading">Troubleshooting installation issues</p>
<p class="callout">You may encounter a conflict between the latest versions of <code>Microsoft.CodeAnalysis</code> and <code>SmartAnalyzers.RoslynTestKit</code>. See this chapter’s final code on GitHub for recommended versions of NuGet packages to resolve this issue.</p>
<p>With the project setup out of the way, let’s create our test fixture.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor288"/>Creating AnalyzerTestFixture</h2>
<p>We’ll start by renaming <code>UnitTest1.cs</code> to <code>ToStringAnalyzerTests.cs</code> and replacing its<a id="_idIndexMarker812"/> contents with the following code:</p>
<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using RoslynTestKit;
namespace Packt.Analyzers.Tests;
public class ToStringAnalyzerTests : AnalyzerTestFixture {
  protected override string LanguageName
    =&gt; LanguageNames.CSharp;
  protected override DiagnosticAnalyzer CreateAnalyzer()
    =&gt; new ToStringAnalyzer();
}</pre>
<p>This class inherits from <code>AnalyzerTestFixture</code> in <code>RoslynTestKit</code>. This forces the class to provide the language it works with and a method to create the analyzer we want to test. Since we’re working with C#, we return <code>LanguageNames.CSharp</code> for the language. In <code>CreateAnalyzer</code>, we instantiate and return an instance of our <code>ToStringAnalyzer</code> from the <code>Packt.Analyzers</code> project.</p>
<p>This lets <code>RoslynTestKit</code> know how to create our analyzer and what languages we’re working with, but we haven’t defined a test yet. Let’s write our first test now.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>Verifying that our Roslyn Analyzer doesn’t flag good code</h2>
<p>Our first test will be to<a id="_idIndexMarker813"/> ensure that code that doesn’t violate our analyzer won’t get flagged as a rule violation. We’ll test this by defining a string containing valid code and then verifying that the analyzer didn’t find any issues with it.</p>
<p>We declare the “good” code as follows:</p>
<pre class="source-code">
<strong class="bold">public const string GoodCode = @"</strong>
using System;
public class Flight
{
  public string Id {get; set;}
  public string DepartAirport {get; set;}
  public string ArriveAirport {get; set;}
  <strong class="bold">public override string ToString() =&gt; Id;</strong>
}<strong class="bold">"</strong>;</pre>
<p>This multi-line string<a id="_idIndexMarker814"/> defines C# for a simple class declaration of a <code>Flight</code> class, which includes an override of the <code>ToString</code> method. Because <code>ToString</code> is overridden, our rule should not find issues with this class definition.</p>
<p>We can verify this with the following code:</p>
<pre class="source-code">
[Fact]
public void AnalyzerShouldNotFlagGoodCode() {
  <strong class="bold">NoDiagnostic(GoodCode, ToStringAnalyzer.Rule.Id);</strong>
}</pre>
<p>Here, we use the <code>NoDiagnostic</code> method from the <code>RoslynTestKit's AnalyzerTestFixture</code> class to check that the code doesn’t violate our rule.</p>
<p><code>RoslynTestKit</code> needs to know the ID of the rule we’re checking for, so we use the <code>Rule</code> property we defined on <code>ToStringAnalyzer</code> earlier to provide its <code>id</code> value.</p>
<p>Now that our test passes without issues, let’s move on to the second test.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>Verifying that our Roslyn Analyzer flags bad code</h2>
<p>To verify that bad code<a id="_idIndexMarker815"/> triggers the analyzer rule, we’ll use a similar approach: we’ll pass in known bad code and ensure that the rule is triggered.</p>
<p>This is slightly more complicated because we want to make sure the rule is triggered for the right symbol in the code. So, when we define our bad code, we need to add <code>[|</code> and <code>|]</code> markers to denote which<a id="_idIndexMarker816"/> symbol should be flagged, as shown here:</p>
<pre class="source-code">
public const string BadCode = @"
using System;
public class <strong class="bold">[|</strong>Flight<strong class="bold">|]</strong>
{
  public string Id {get; set;}
  public string DepartAirport {get; set;}
  public string ArriveAirport {get; set;}
}";</pre>
<p>This code doesn’t have a <code>ToString</code> override, so the <code>Flight</code> class should be flagged as a rule violation. We can verify this with the <code>HasDiagnostic</code> method:</p>
<pre class="source-code">
[Fact]
public void AnalyzerShouldFlagViolations() {
  <strong class="bold">HasDiagnostic(BadCode, ToStringAnalyzer.Rule.Id);</strong>
}</pre>
<p>This code is very similar to our approach to validating good code and will fail if the rule was not triggered or was not triggered explicitly for the <code>Flight</code> symbol.</p>
<p>We could continue to expand our tests with additional examples and counter-examples, but let’s move on to talking briefly about debugging our Roslyn Analyzers.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>Debugging Roslyn Analyzers</h2>
<p>When you write a <a id="_idIndexMarker817"/>Roslyn Analyzer, it’s unlikely that you’ll get it right the first time.</p>
<p>Unit tests help detect failures in your analyzer, but let’s talk about how you would debug a Roslyn Analyzer.</p>
<p>My recommended approach with Roslyn Analyzers is to follow the approach of this chapter: <em class="italic">create a class library containing your analyzer and a test project that </em><em class="italic">tests it</em>.</p>
<p>If your analyzer isn’t properly triggering for certain code, you can put breakpoints in your analyzer code and step through the code for a specific instance by right-clicking on a specific test and selecting <strong class="bold">Debug</strong>, as shown in <em class="italic">Figure 13</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 13.7 – Debugging a specific test case" src="img/B21324_13_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Debugging a specific test case</p>
<p>I’ve found this approach to be generally very helpful when analyzing specific test cases. In these scenarios, I can see the exact objects the analyzer encounters from the test scenario. From<a id="_idIndexMarker818"/> there, I wrote enough code to get the analyzer to handle that scenario. Once the analyzer has handled that test case, I’m usually at a point where I’m ready to try the analyzer on a wider range of code, which we’ll discuss next.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor292"/>Sharing analyzers as Visual Studio extensions</h1>
<p>Once you’re ready to try an analyzer<a id="_idIndexMarker819"/> on more code or share it with your peers, there are a few options available:</p>
<ul>
<li>Deploy the analyzer as a NuGet package, as we’ll discuss in the next chapter</li>
<li>Create a <strong class="bold">Visual Studio Installer</strong> (<strong class="bold">VSIX</strong>) to install the analyzers locally</li>
<li>Create a new project and add an explicit reference to the analyzers by editing the <code>.csproj</code> file and adding an <code>Analyzer</code> node, as shown here:</li>
</ul>
<pre class="source-code">
&lt;ItemGroup&gt;
<strong class="bold">  &lt;Analyzer Include="..\some\path\Your.Analyzer.dll" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
<p>This last approach is one you might consider if you had a large solution and wanted your analyzer to only apply to other projects in that solution. However, I’ve found this approach to be buggy and<a id="_idIndexMarker820"/> require frequent reloads of Visual Studio for changes in the analyzers to take hold, so we’ll use the VSIX approach as we close out this chapter.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/>Creating a Visual Studio extension (VSIX) for your Roslyn Analyzer</h2>
<p>Visual Studio extension<a id="_idIndexMarker821"/> projects (VSIX projects) allow you to bundle a diverse set of capabilities into an extension that can then<a id="_idIndexMarker822"/> be installed into Visual Studio.</p>
<p>Let’s create a new VSIX project, add our analyzer to it, and then use it in a new instance of Visual Studio.</p>
<p>We’ll start as we usually do: by right-clicking on the solution in <strong class="bold">Solution Explorer</strong>, choosing <strong class="bold">Add</strong>, and then <strong class="bold">New Project…</strong>.</p>
<p>Next, select the <code>Packt.Analyzers.Installer</code> and click <strong class="bold">Create</strong>.</p>
<p>This empty project consists of a single <code>source.extension.vsixmanifest</code> file, which we’ll refer to as the manifest. This manifest is the only file we’ll need. Double-click on it to open the designer, as shown in <em class="italic">Figure 13</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 13.8 – The manifest in the design view" src="img/B21324_13_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The manifest in the design view</p>
<p>This opens the metadata view, which contains different settings you can configure. We’ll ignore those and click on the <strong class="bold">Assets</strong> blade on the left sidebar.</p>
<p>The <strong class="bold">Assets</strong> blade<a id="_idIndexMarker823"/> specifies the different <a id="_idIndexMarker824"/>components that are included in the extension. We want to include our analyzer, so click <strong class="bold">New</strong> to open the <strong class="bold">Add New </strong><strong class="bold">Asset</strong> dialogue.</p>
<p>Next, specify the <code>Packt.Analyzers</code> project, as shown in <em class="italic">Figure 13</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 13.9 – Adding the Roslyn Analyzer to your VSIX project as an asset" src="img/B21324_13_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Adding the Roslyn Analyzer to your VSIX project as an asset</p>
<p>Click <strong class="bold">OK</strong>; your analyzer should now appear in the list of assets.</p>
<p>With that change, our VSIX project is now ready for us to use. To test this project, right-click on the <code>Packt.Analyzers.Installer</code> project and choose <strong class="bold">Set as Startup Project</strong>. Next, run your project – a new experimental instance of Visual Studio will open.</p>
<p class="callout-heading">Note</p>
<p class="callout">It can take a few minutes for Visual Studio to open after you run the project. The version of Visual Studio that opens is built specifically for developing extensions and needs additional time to launch. It is not recommended to use this version of Visual Studio for actual development. Instead, use it to test your extensions and then close it.</p>
<p>After a few minutes, a new instance of Visual Studio will open with your VSIX project installed. Using this instance of Visual Studio, you can open any other project and the Roslyn Analyzer you built in this chapter will be active.</p>
<p>Specifically, our <a id="_idIndexMarker825"/>analyzer will show up as a suggestion on classes that don’t override <code>ToString</code>, such as the <code>SkillController</code> class in <em class="italic">Figure 13</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 13.10 – Our Roslyn Analyzer suggests overriding ToString" src="img/B21324_13_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Our Roslyn Analyzer suggests overriding ToString</p>
<p>Warnings for your analyzer <a id="_idIndexMarker826"/>will also show up in the error list, though if you marked them as having a severity, as we did in the chapter, you’ll need to make sure that messages are displayed in those results. See the highlighted button in <em class="italic">Figure 13</em><em class="italic">.10</em> for the message filter.</p>
<p class="callout-heading">DebuggerDisplay attributes versus ToString overrides</p>
<p class="callout">This chapter uses <code>ToString</code> as an example, and overriding <code>ToString</code> can help with the debugger experience. An alternative to this would be to add a <code>[DebuggerDisplay]</code> attribute <a id="_idIndexMarker827"/>above your class definition to describe how it appears in the debugger without needing to override <code>ToString</code>.</p>
<p>Once you are satisfied with your test, close the new instance of Visual Studio.</p>
<p>Building and testing your installer will have created a <code>Packt.Analyzers.Installer.vsix</code> file in the <code>bin/Debug</code> folder within your extension project. This <code>.vsix</code> file will let other people install your custom extension and use your analyzers in their projects.</p>
<p class="callout-heading">Note</p>
<p class="callout">You could also distribute your installer on the Visual Studio marketplace. This would make the extension publicly available and easier for others to locate and download.</p>
<p>Any time you update<a id="_idIndexMarker828"/> your analyzer, you’ll need to<a id="_idIndexMarker829"/> share a new version of the extension and your team will need to upgrade. This makes managing Roslyn Analyzers via <code>.vsix</code> files challenging.</p>
<p>Fortunately, NuGet packages offer a better way of sharing Roslyn Analyzers, as we’ll see in the next chapter.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/>Summary</h1>
<p>In this chapter, we created our first Roslyn Analyzer, tested it with <code>RoslynTestKit</code>, and built a VSIX extension to integrate it into Visual Studio.</p>
<p>We saw how Roslyn Analyzers power all the warnings we interact with in Visual Studio and how you and your team can create new Roslyn Analyzers to detect and flag issues that are unique to your team and its codebase.</p>
<p>In the next chapter, we’ll see how Roslyn Analyzers can be used to fix the issues they find and help safely refactor your code.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor295"/>Questions</h1>
<ol>
<li>How do Roslyn Analyzers work?</li>
<li>When would you want to create your own Roslyn Analyzer?</li>
<li>How can you verify that Roslyn Analyzers work correctly?</li>
</ol>
<h1 id="_idParaDest-297"><a id="_idTextAnchor296"/>Further reading</h1>
<p>You can find more information about the topics that were covered in this chapter at these URLs:</p>
<ul>
<li><em class="italic">Roslyn </em><em class="italic">Analyzers</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview">https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview</a></li>
<li><em class="italic">Install third-party </em><em class="italic">analyzers</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers">https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers</a></li>
<li><em class="italic">Awesome </em><em class="italic">Roslyn</em>: <a href="https://github.com/ironcev/awesome-roslyn">https://github.com/ironcev/awesome-roslyn</a></li>
<li>.<em class="italic">NET </em><em class="italic">Standard</em>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/net-standard">https://learn.microsoft.com/en-us/dotnet/standard/net-standard</a></li>
</ul>
<p>Here are some popular open-source Roslyn Analyzers on GitHub:</p>
<ul>
<li><em class="italic">Roslyn </em><em class="italic">Analyzers</em>: <em class="italic">https://github.com/dotnet/roslyn-analyzers</em></li>
<li><em class="italic">StyleCop</em>: <a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers">https://github.com/DotNetAnalyzers/StyleCopAnalyzers</a></li>
</ul>
</div>
</body></html>