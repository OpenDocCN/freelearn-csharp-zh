<html><head></head><body>
        

                            
                    <h1 class="header-title">Best Practices and Other Related Techniques</h1>
                
            
            
                
<p>The last chapter was a very interesting one as we explored Dependency Injection in different frameworks such as TypeScript, ES2015, and Angular 2. This is the last chapter and we are going to discuss the coding and architectural practices proved to be the best while implementing Dependency Injection in the project.</p>
<p class="mce-root">It's obvious that, when you learn something new and try to implement it in your application, excitement might lead you to create a bad architecture. That would eventually lead to a bad practice because, after you code it for a few times unknowingly, it becomes a habit. Suppose, you get a requirement to save user details to the database. You will definitely send the details to the <kbd>Service Layer</kbd> method which in turn would connect to the <kbd>Data Access Layer</kbd> method, to save the details. Quickly (if you are new to the application and don't know about the architecture implemented), the first thing you would do is to use the <kbd>new</kbd> keyword to instantiate the dependencies and directly call the methods. In that way, we can't achieve loosely coupled modules. However, we could have designed the app and the layers in such a way that the consumers won't be able to generate coupling by any means. We will explore these techniques in this chapter.</p>
<p>So, exploring how to deliver your best with the concept you just learned is important for you and your app. For that reason, there are best practices which you should be aware of. Dependency Injection deals with Object Composition, Object Lifetime, and Interception as a whole, which should be ideally managed by DI Containers. If we try to deal with these building blocks ourselves instead of using a container to manage the dependencies, we might end up with a bad design.</p>
<p>Although we can choose one DI Container, designing and refactoring our code accordingly to help the container to work with our classes might be an erroneous task.</p>
<p>In this chapter, we will touch upon these points in detail to understand the real-time problems faced during the induction of DI into the projects. We will learn techniques to avoid bad habits in DI.</p>
<p>We will discuss the following topics:</p>
<ul>
<li>Best practices and recommendations in Dependency Injection</li>
<li>Some recommended techniques to remove tight coupling</li>
<li>Refactoring and implementation of DI in legacy layered applications</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Tightly coupled systems</h1>
                
            
            
                
<p>Till now, we have discussed <em>DI in .NET Core 2.0, Pillars of DI, DI Patterns, Anti-Patterns, DI in other frameworks</em>. Someone who is new to the DI concept might do make mistakes and it's normal. We will see more of such scenarios in upcoming sections. Before that, let's analyze something which you might find more often in ASP.NET MVC projects. If you don't, ask your colleagues and friends. You will definitely see such instances.</p>
<p>Let's see one simple controller without DI implemented and learn how to refactor that so that it will respect the principles of <em>Inversion of Control</em>.</p>
<p class="mce-root">Inversion of Control states <em>Do not call us we will call you</em>. When a class tries to instantiate another class inside it, it basically creates a coupling with the second class. Now the first class creation depends on the second class.</p>
<p class="mce-root">If the second class fails, for any reason, we won't be able to get the instance of the first class, as the constructor will break:</p>
<div><img height="195" width="438" src="img/62615398-6b59-4eb3-8657-451926cf6fe7.png"/></div>
<p class="mce-root">The <strong>Someone</strong> in the picture can be an IoC Container.<br/>
I would strongly recommend Mr. Shivprasad Koirala's article, if you want to grasp this concept in depth. Here is the link--<a href="https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency">https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The problem</h1>
                
            
            
                
<p>The following diagram depicts what we are going to do now. We will have a <strong>Controller</strong> depending on a <strong>Service</strong>, which in turn depends on a <strong>Repository</strong> for data:</p>
<div><img height="100" width="396" src="img/2a6cbf62-357a-46b5-9785-14b3fb11853a.png"/></div>
<p>First of all, let's think of a simple controller and how that is generally implemented in projects. The following is a simple <kbd>UsersController</kbd> which has an action method <kbd>Edit</kbd>:</p>
<pre>    public class UsersController : Controller<br/>    {<br/>      public IActionResult Edit(int userId)<br/>      {<br/>        var usersService = new UsersService();<br/>        return View(usersService.GetUser(userId));<br/>      }<br/>    } </pre>
<p>The following are the conclusions (more accurately the problems), which can be made from the preceding code block:</p>
<ul>
<li><kbd>UsersController</kbd> instantiates <kbd>UsersService</kbd> using the <kbd>new</kbd> keyword (creates an instance of a concrete class)</li>
<li><kbd>UsersController</kbd> is tightly coupled with <kbd>UsersService</kbd></li>
</ul>
<p>As far as our knowledge from other chapters is concerned, we should definitely avoid both of the preceding points. This makes Unit Testing difficult. DI principles encourage us to utilize the area of the Composition Root to register all required classes/dependencies (such as <kbd>UsersService</kbd>) and then use a DI container to resolve the instances instead of using the <kbd>new</kbd> keyword whenever required.</p>
<p>Next is <kbd>UsersService</kbd>, which might look something like the following:</p>
<pre>    public class UsersService<br/>    {<br/>      private readonly UsersRepository _usersRepository;<br/>      public UsersService()<br/>      {<br/>        _usersRepository = <strong>new UsersRepository();<br/>        // Concrete Class Dependency</strong><br/>      }<br/>      public User GetUser(int userId) =&gt; _usersRepository.GetUser(userId);<br/>    }</pre>
<p>Yet another concrete dependency with <kbd>UsersRepository</kbd>. <kbd>UsersService</kbd> now does the same kind of stuff as we saw in the case of the controller. In this example, the service is trying to pass the data returned from the repository. But in reality, it might do a lot of things. The important aspect here is how we are managing our dependencies inside a class which might get uglier as we build a complex system in the future. The exercise we are doing now is just to point out the problem, so don't go by the simplicity of the structure.</p>
<p>The repository would look like the following:</p>
<pre>    public class UsersRepository<br/>    {<br/>      public User GetUser(int userId) =&gt; new <br/>         DataContext().Users.SingleOrDefault(u =&gt; u.UserId == userId);<br/>      // You can just return a demo user like: <br/>      // new User { UserId = 1, UserName = "Tadit" };<br/>    }</pre>
<p>The following diagram explains what has been done so far:</p>
<div><img height="175" width="493" src="img/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png"/></div>
<p>Everything stops here. This is the last in the queue. It gets the data from the <kbd>Users</kbd> table and sends it back to the client. This architecture works, but there are shortcomings which might get worse as you progress:</p>
<ul>
<li>Unit testing is not easy as the classes are tightly coupled with each other. For instance, <kbd>UsersController</kbd> depends on <kbd>UsersService</kbd>, which in turn depends upon <kbd>UsersRepository</kbd>, and then, at last, it deals with the database, while unit testing might fail due to database interactions.</li>
<li>If this architecture grows and becomes a fully fledged application, then maintenance becomes difficult as the classes are wound up with dependencies all over which will be difficult to identify and manage.</li>
<li>There is no technique/method by which we can easily modify the dependencies. Suppose we want to implement another class for a service named <kbd>UsersNewService</kbd> and we want to use that instead of <kbd>UsersService</kbd>. It will be a tedious task as we have to identify all dependencies of <kbd>UsersService</kbd> and then change them everywhere.</li>
<li>Moreover, the concrete service reference might fail in certain circumstances where the method signatures may vary across different classes. For example, the <kbd>GetUser</kbd> method in both of these service classes may vary in the signature, making the developer's life difficult as you have to modify the <kbd>GetUser</kbd> caller methods as well, including service reference changes.</li>
</ul>
<p>These flaws not only describe a poorly architected project but also become a developer's nightmare to refactor and maintain.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The solution - refactoring with DI</h1>
                
            
            
                
<p>As we all know, the Dependency Inversion Principle states the following:</p>
<ul>
<li>High-level modules should not depend on low-level modules. Both should depend on <strong>abstractions</strong>.</li>
<li>Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
<p>Therefore, let's design the interfaces to abstract out the concrete classes.</p>
<p>Start from the last one in the hierarchy, which is the repository:</p>
<div><img height="49" width="325" src="img/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png"/></div>
<p>The abstraction for the repository would look like the following:</p>
<pre>    public interface IUsersRepository<br/>    {<br/>      User GetUser(int userId);<br/>    }</pre>
<p>So, <kbd>UsersRepository</kbd> would implement <kbd>IUsersRepository</kbd> as follows:</p>
<pre>    public class UsersRepository : IUsersRepository<br/>    {<br/>      public User GetUser(int userId)  =&gt; new <br/>        DataContext().Users.SingleOrDefault(u =&gt; u.UserId == userId);<br/>      // You can just return a demo user like:<br/>      // new User { UserId = 1, UserName = "Tadit" }; <br/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Interface extraction</h1>
                
            
            
                
<p class="mce-root">Do you know how easy it is to extract an interface out of a class? It's very easy and effective with Visual Studio. Let's see the following steps:</p>
<ol>
<li class="mce-root">Hover on the concrete class; you will see a bulb at the left side.</li>
<li>Click on that to open a drop-down menu. Refer to the following screenshot:</li>
</ol>
<div><img height="191" width="562" src="img/0a1663e5-99b6-41d1-9af6-3d7527067b01.png"/></div>
<ol start="3">
<li>Select the <kbd>Extract</kbd> Interface.</li>
<li>A modal pops up which also lists the public members of the class. See the following screenshot:</li>
</ol>
<div><img style="font-size: 1em" height="315" width="381" src="img/4ee3d902-fa21-4d9c-919a-7eda2914b586.png"/></div>
<ol start="5">
<li>Hit OK. It will create the interface for you.</li>
</ol>
<p>There is another way to extract an interface. You can write the interface name and then do a <em>Ctrl</em> + <em>.</em> (dot) so that the option bubble appears. You need to select either of the top two options to generate the interface:</p>
<div><img src="img/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png"/></div>
<p class="mce-root">However, there is a difference in comparison to the first approach; its marked with the red block. If you select either of the <kbd>Generate</kbd> options shown in the screenshot, it will create a block for interface with a blank block without any code inside it (indicated inside the red block). However, in the first case, we had the opportunity to select the public members to include them in the interface. Imagine a huge class with lots of public members. Undoubtedly, the first approach wins for obvious reasons as previously described.</p>
<p class="mce-root">Alright. Now we can modify the <kbd>UsersService</kbd> to inject the repository as a dependency instead of instantiating using the <kbd>new</kbd> keyword inside the constructor. The <kbd>IUsersService</kbd> interface can be designed as we did for the repository in order to use it inside the controller, which we will see in a while:</p>
<div><img height="52" width="345" src="img/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png"/></div>
<p><kbd>IUsersService</kbd> is just a simple interface with <kbd>GetUser</kbd> as a public member:</p>
<pre>  public interface IUsersService<br/>  {<br/>    User GetUser(int userId);<br/>  }</pre>
<p><kbd>UsersService</kbd> can be modified now to implement <kbd>IUsersService</kbd>. Injection can be done using the Constructor Injection pattern to inject the <kbd>IUserRepository</kbd> dependency:</p>
<pre>    public class UsersService : <strong>IUsersService // Abstraction</strong><br/>    {<br/><strong>      private readonly IUsersRepository _usersRepository;</strong><br/><strong>      public UsersService(IUsersRepository <br/>         usersRepository) // Constructor Injection</strong><br/><strong>      {</strong><br/><strong>        _usersRepository = usersRepository;</strong><br/><strong>      }</strong><br/>       public User GetUser(int userId) =&gt; _usersRepository.GetUser(userId);<br/>    }</pre>
<p class="mce-root">This change will trigger a modification to the controller; otherwise the compiler would complain. Let's make the compiler happy:</p>
<pre>    public IActionResult Edit(int userId)<br/>    {<br/><strong>    var usersService = new UsersService(new UsersRepository());</strong><br/>    return View(usersService.GetUser(userId));<br/>    }</pre>
<p>We can now inject/insert the repository instance to the service inside the controller action <kbd>Edit</kbd>.</p>
<p>So far, we have eliminated one concrete reference from the architecture that is from the <kbd>UsersService</kbd> class. It's very important to understand our goal. We are actually trying to get every dependency in one place so that the design gets simplified. Thus, with minimal change, we can easily inject different types of dependency into the system.</p>
<p>For example, our <kbd>UsersService</kbd> is now taking responsibility for managing the <kbd>UsersRepository</kbd> dependency instead of the service managing it internally with a tight coupling.</p>
<p>However, we are still not done. We have another clearly visible dependency in the controller instantiated using the <kbd>new</kbd> keyword inside the action <kbd>Edit</kbd> and that is none other than the <kbd>UsersService</kbd>.</p>
<p>The refactored injectible <kbd>UsersController</kbd> would look like the following:</p>
<pre>    public class UsersController : Controller<br/>    {<br/><strong>      private readonly IUsersService _usersService;</strong><br/><strong>      public UsersController(IUsersService usersService) // <br/>        Constructor Injection</strong><br/><strong>      {</strong><br/><strong>        _usersService = usersService;</strong><br/><strong>      }<br/></strong><br/>      public IActionResult Edit(int userId)<br/>      {<br/><strong>        // We commented out the following line and used<br/>        // private member _usersService instead.</strong><br/>        //var userService = new UsersService(new UsersRepository());<br/>        return View(<strong>_usersService.GetUser(userId)</strong>);<br/>      }<br/>    }</pre>
<p>Simple, isn't it? Constructor Injection again comes to our rescue and allows us to inject the service so that we can use it for further operations.</p>
<p>Awesome, now we removed all dependencies. Go ahead and run the app:</p>
<div><img height="38" width="672" src="img/57020285-5416-42e4-b3e2-57a2503a9318.png"/></div>
<p>Unfortunately, it threw an exception. It isn't a surprise. The framework would expect one parameter less constructor inside the controller which we don't have anymore and then it found one parameterized constructor accepting the <kbd>IUsersService</kbd> implementation instance which was never provided anywhere in the app. Thus, the exception was formulated.</p>
<p>Okay, I know what you are thinking. Adding one parameter less or default constructor won't change the scene. Rather it will show the following in the browser:</p>
<div><img height="39" width="638" src="img/5fc28848-c597-42cc-9482-e8261406f8d4.png"/></div>
<p>Moreover, DI does not recommend using multiple constructors, so that is not an option anyway.</p>
<p>Before we go ahead with the solution, let me summarise what we have done so far.</p>
<ul>
<li>We created abstractions for concrete classes</li>
<li>We replaced new keywords with constructors injected with abstractions</li>
<li>In the process, we also modified the default constructor of <kbd>UsersController</kbd> to inject the <kbd>IUsersService</kbd> dependency</li>
</ul>
<p>However, we received exceptions. That is because we have neither instantiated any implementation of the <kbd>IUsersService</kbd> interface nor provided it to the constructor.</p>
<p>We need to do two more things to make the app run. That is to let the compiler know what the implementations of the following are:</p>
<ul>
<li><kbd>IUsersService</kbd> interface</li>
<li><kbd>IUsersRepository</kbd> interface</li>
</ul>
<p>That can be done with an IoC Container. As we are on .NET Core 2.0, let's use the built-in container and see what happens. The <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class would look like the following:</p>
<pre>    public void ConfigureServices(IServiceCollection services)<br/>    {<br/>    services.AddTransient&lt;IUsersService, UsersService&gt;()<br/>            .AddTransient&lt;IUsersRepository, UsersRepository&gt;();<br/>    services.AddMvc();<br/>    }</pre>
<p>Let's run the app now:</p>
<div><img height="474" width="275" src="img/b96498fe-fcd1-4546-9f01-953678456324.png"/></div>
<p>Finally, it runs. Everything is perfect and we got the output in the browser, thanks to the DI engine of .NET Core and yes, of course, to the progress you have made so far with the book.</p>
<p class="mce-root">We did a fabulous job in refactoring the classes to inject dependencies instead of referring concrete classes which were inefficient and not maintainable. Still, the tight coupling is not totally eliminated. The service is still returning a database model class <kbd>User</kbd> instance to the controller.</p>
<p class="mce-root">Imagine a three-layered architecture, where the layers can be the <kbd>ASP.NET MVC Web App Layer</kbd>, <kbd>Service/Business Layer</kbd>, and <kbd>Data Access Layer</kbd>. If a developer uses the model classes directly in the presentation layer (<kbd>ASP.NET MVC Web App Layer</kbd>), that means it is tightly coupled and can't live without a reference to the <kbd>Data Access Layer</kbd> in the project. In the next section, we will see such a problem and try to refactor it to DI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Layered architecture</h1>
                
            
            
                
<p class="mce-root">In a typical modern ASP.NET MVC web app, you will find a three-layered architecture with isolated components depending on each other as shown in the following diagram:</p>
<div><img height="72" width="368" src="img/877c5277-733d-409e-8e5e-ef8fffdb14ff.png"/></div>
<p>When we say some layer depends on another, that means the layer that depends, needs instances of the dependency objects to perform certain operations. As we saw in the previous section, to get a user from the database, the controller was asking the service to provide it from the repository. Thus, we can easily separate the classes and package them as components or a class library, speaking technically.</p>
<p>That means my controller remains in <kbd>UI Layer</kbd> or <kbd>Presentation Layer</kbd>, <kbd>Service Class</kbd> make another layer who talks to the database through <kbd>Data Access Layer</kbd> classes. Now, as we chose Dependency Injection Technique to manage the dependencies, it's the responsibility of the IoC Container to provide the dependent <kbd>Data Access Layer</kbd> objects to the <kbd>Service Layer</kbd>, and <kbd>Service Layer</kbd> objects to the UI Layer. Most importantly, it takes the control from each layer for object creation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The problem - The concrete class reference again</h1>
                
            
            
                
<p>I think you may not have noticed one thing in the last section. We tried to decouple the system as far as we could. But we have not totally achieved a loosely coupled architecture. Let me explain in the next paragraph.</p>
<p>Composition Root is the place where we register all the dependencies to be used by the application. The <kbd>ConfigureServices</kbd> method in the <kbd>Startup</kbd> class was the location of this dependency registration as we saw:</p>
<pre>    services.AddTransient&lt;IUsersService, UsersService&gt;()<br/>    .AddTransient&lt;IUsersRepository, UsersRepository&gt;();</pre>
<p>Notice that we are saying, take the <kbd>UsersService</kbd> instance when <kbd>IUserService</kbd> dependency is required and the <kbd>UsersRepository</kbd> instance when <kbd>IUsersRepository</kbd> is required. So, basically, we now have to get the assembly references of both <kbd>Service Layer</kbd> and <kbd>Data Access Layer</kbd> in order to run this code without compilation issues. Check out the following screenshot, which proves what I just said:</p>
<div><img height="435" width="349" src="img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png"/></div>
<p>Whatever classes we have designed so far are just separated out in these three layers. The repository is in the <kbd>Data Access Layer</kbd> and the service is inside the <kbd>Business Layer</kbd>.</p>
<p>Clearly, you can see there is a <kbd>Business Layer</kbd> assembly reference in the UI Layer. As the <kbd>Business Layer</kbd> has a reference to the <kbd>Data Access Layer</kbd>, so automatically it is carried over to the UI Layer.</p>
<p>Due to this, the <kbd>Presentation Layer</kbd> now has access to various implementations of the <kbd>Service Layer</kbd> and <kbd>Data Access Layer</kbd>. This is a very bad coding practice as we are trying to violate the layered architecture concept altogether. There is no separation existing between the layers. Moreover, developers can misuse the concrete class implementations, as they have direct access due to the assembly reference. This is not acceptable at all.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Misuse of business and Data Access Layer assemblies</h1>
                
            
            
                
<p>Here we will discuss how we, as developers, could misuse the layers in the code by direct reference to the layers. Let's try to understand a few scenarios where these assemblies can be misused in the <kbd>UI Layer</kbd>:</p>
<ul>
<li><strong>Direct Business Layer Service Access</strong>: As we have a reference of <kbd>Business Layer</kbd>, so we can instantiate it and then call the <kbd>GetUser()</kbd> method. We needed a <kbd>Repository</kbd> instance for the <kbd>Service</kbd> constructor, which we can also easily provide.</li>
</ul>
<pre>    public IActionResult Edit(int userId)<br/>    {<br/>      UsersService service = new UsersService(new UsersRepository());<br/>      return View(service.GetUser(userId));<br/>    }</pre>
<p style="padding-left: 60px">Notice how we can easily instantiate the <kbd>UsersService</kbd> class by passing the <kbd>Repository</kbd> instance to its constructor. That means we still love the <kbd>new</kbd> keyword.</p>
<ul>
<li><strong>Direct Data Access Repository Access</strong>: Why go through <kbd>Service</kbd> when we have the <kbd>Data Access</kbd> reference? Why not directly deal with the Repository to get the data? Cool isn't it!</li>
</ul>
<pre>    public IActionResult Edit(int userId)<br/>    {<br/>      UsersRepository repo = <strong>new</strong> UsersRepository();<br/>      return View(repo.GetUser(userId));<br/>    }</pre>
<p style="padding-left: 60px">Yet another <kbd>new</kbd> keyword usage.</p>
<ul>
<li><strong>Direct Data Layer Context Access</strong>: Even better is the following approach where we don't even need these intermediate <kbd>Service</kbd> or <kbd>Repository</kbd> instances. We can directly get data from contexts:</li>
</ul>
<pre>        public IActionResult Edit(int userId)<br/>        {<br/>          return View(<strong>new</strong> DataContext()<br/>           .Users<br/>           .SingleOrDefault(u =&gt; u.UserId == userId)<br/>          );<br/>        }</pre>
<p><kbd>DataContext</kbd> can provide the data directly inside the Controller Action as shown in the preceding code.</p>
<p>We destroyed the layered architecture and the modules are not independent anymore. Rather the <kbd>Business Layer</kbd> and <kbd>Data Access Layer</kbd> are now tightly coupled with the <kbd>UI Layer</kbd>. This happened just because we had to register concrete implementations for the interfaces with the Service Collections inside the <kbd>ConfigureServices</kbd> method. For DI injection to take place, we need this registration step so that we can ask the container for dependencies whenever required.</p>
<p>Now, we have to find a way. Let's discover a best practice for this kind of problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Best practice for layered architecture</h1>
                
            
            
                
<p class="mce-root">Remember, you can do a ton of things to improve the architecture and optimize the performance whilst using DI techniques; however, you can't remove the assemblies from inside the <kbd>bin</kbd> folder of the ASP.NET MVP web application. You need to understand that the problem lies with access to different concrete implementations of the <kbd>Business Layer</kbd> and <kbd>Data Access Layer</kbd> inside the <kbd>Presentation Layer</kbd>; as we saw how devastating it can be when developers try to play with the layers instead of properly using them.</p>
<p>Therefore, we need to figure out a way to overcome this situation and not allow the <kbd>Presentation Layer</kbd> to access the concrete classes of other layers while being benefited by Dependency Injection. The solution is MEF. Let's explore more in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managed Extensibility Framework (MEF)</h1>
                
            
            
                
<p>Before exploring MEF, let me summarize the problem.</p>
<p><strong>Tight coupling:</strong> Concrete classes are referenced inside the <kbd>UI Layer</kbd> by DI during the <kbd>Startup</kbd> inside <kbd>ConfigureServices</kbd> method.</p>
<p>So, basically, we need to do some automation which enables us not to depend upon concrete classes of other layers. That is where MEF comes into the picture.</p>
<p>MEF is a library for creating lightweight extensible applications. With the help of MEF, developers can easily build the an app to automatically bind extensions together without any configurations. There is more on MEF at <a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index">https://docs.microsoft.com/en-us/dotnet/framework/mef/index</a><a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index">.</a><a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/index"/></p>
<p>We are not going deeply into the MEF; you can do that from the preceding link I shared. We just need to understand how we can solve our issue with MEF. For example, we have a <kbd>Service</kbd> class and a <kbd>Repository</kbd> class which we don't want to expose to UI for direct consumption as we saw in our preceding code snippets. MEF would do that for us by pulling the classes required to register the dependencies.</p>
<p>The following diagram depicts the role MEF is going to play in our app:</p>
<div><img height="298" width="525" src="img/84fe4a37-b067-4153-bc63-a5eed43e85ad.png"/></div>
<p>You can see we have <kbd>ModuleInit</kbd> classes in every layer with one <kbd>Init()</kbd> method and these classes implement a common interface called <kbd>IModule</kbd>. It's obvious that the DLLs of all the layers will be there in the <kbd>bin</kbd> folder of the ASP.NET MVC Web Project.</p>
<p>Now the interesting scene. MEF gets all assemblies from the <kbd>bin</kbd> folder of the App, then it does the following:</p>
<ol>
<li>Searches for the implementations of <kbd>IModule</kbd>.</li>
<li>Fires the <kbd>Init()</kbd> method of each found module.</li>
</ol>
<p>In the next section, we will see the codes in different layers and how MEF can bring back loosely coupled modules to optimise the architecture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Layers and MEF implementation</h1>
                
            
            
                
<p>Before going into the code in some depth, let's first analyze the layers. So, there are three layers.</p>
<ol>
<li><strong>Web App Layer:</strong> Contains <kbd>Controller</kbd>, <kbd>View</kbd>, and so on. Most importantly, it has the entry point <kbd>Startup.cs</kbd>.</li>
<li><strong>Business/Service Layer:</strong> Contains the <kbd>Services</kbd> where we can include our business logic.</li>
<li><strong>Data Access Layer:</strong> Contains <kbd>Contexts</kbd>, <kbd>DbSets</kbd>, and <kbd>Repository</kbd> for data retrieval from the database.</li>
</ol>
<p>Let's have a quick look at the <kbd>Visual Studio Solution</kbd> window:</p>
<div><img height="324" width="382" src="img/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png"/></div>
<p>We have organized our classes into different layers. Interestingly, we have introduced another layer named as <kbd>Common Layer</kbd>, where we have placed all common code related to <kbd>Business Layer</kbd> and <kbd>Data Access Layer</kbd>. A common project is referenced both by <kbd>Business Layer</kbd> and <kbd>Data Access Layer</kbd>.</p>
<p>This common code will help us fetch the dependencies from assemblies related to different layers and package them into one (called <kbd>ModuleLoader</kbd>) so that the web app can call just one method to initiate everything. Let's understand each part one by one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction of IUser</h1>
                
            
            
                
<p>The goal is to remove the concrete class access from the UI layer. We started to move all common items into one central layer called <kbd>Common</kbd>. As we moved <kbd>IUsersService</kbd> to <kbd>Common</kbd>, we identified a <kbd>GetUser</kbd> method, which is actually returning a concrete <kbd>User</kbd> instance. Moreover, <kbd>UserService</kbd> inside the <kbd>Business Layer</kbd> also has the same method as it implements <kbd>IUsersService</kbd>.</p>
<p>The following code shows how the return type of <kbd>GetUser</kbd> can be updated to <kbd>IUser</kbd> type instead of <kbd>User</kbd> type:</p>
<pre>    public <strong>IUser</strong> GetUser(int userId) =&gt;<br/>          _usersRepository.GetUser(userId);<br/>   // Return type is changed from User to IUser.</pre>
<p>We need to get rid of this <kbd>User</kbd> class dependency, otherwise, <kbd>Common Layer</kbd> has to again refer to the <kbd>Data Access Layer</kbd> because the <kbd>User</kbd> resides in that, which is the same case for <kbd>Business Layer</kbd> to refer <kbd>Data Access</kbd>. Moreover, <kbd>Common</kbd> is designed to be referred by other layers and not to get other layers references inside itself. It should be free from project dependencies. This is important.</p>
<p>The solution is very easy. One <kbd>IUser</kbd> interface can be added inside the <kbd>Common/Entities/Users</kbd> directory, which will be used as a return type for the <kbd>GetUser</kbd> method. So, <kbd>GetUser</kbd> inside <kbd>UsersService</kbd> and <kbd>UsersRepository</kbd> can return the <kbd>IUser</kbd> type instead of the <kbd>User</kbd> instance. Now we can easily remove the coupling of <kbd>Data Access</kbd> with the <kbd>Common Layer</kbd>. Also <kbd>Data Access</kbd> coupling with the <kbd>Business Layer</kbd>.</p>
<p>The following diagram tells us what was wrong when we used <kbd>User</kbd> class. We had references to the <kbd>Common Layer</kbd> and <kbd>Data Access Layer</kbd> in the <kbd>Business Layer</kbd>:</p>
<div><img height="174" width="541" src="img/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png"/></div>
<p>The following is the approach which is correct with an interface <kbd>IUser</kbd>, which allows us to reduce the coupling of layers:</p>
<div><img height="179" width="554" src="img/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png"/></div>
<p>Now there is no need for a reference to the <kbd>Data Layer</kbd> inside the <kbd>Common Layer</kbd>. On the contrary, the <kbd>Business Layer</kbd> and <kbd>Data Layer</kbd> are dependent on <kbd>Common</kbd>, which is our intention. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The IModuleRegistrar interface</h1>
                
            
            
                
<p>The <kbd>IModuleRegistrar</kbd> interface is responsible for adding the dependency into the service collection. Basically, the implementer of this interface will have an <kbd>Add()</kbd> method with the signature mentioned, which does the job of the <kbd>Add***</kbd> (<kbd>AddTransient</kbd>/<kbd>AddScoped</kbd>/<kbd>AddSingleton</kbd>) methods.</p>
<pre>    using Microsoft.Extensions.DependencyInjection;<br/>    using System;<br/>    namespace PacktDIExamples.Common<br/>    {<br/>      public interface IModuleRegistrar<br/>      {<br/>        void Add(Type serviceType, Type implementationType,<br/>           ServiceLifetime lifetime);<br/>      }<br/>    }</pre>
<p>This is present inside the <kbd>Common Layer</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The ModuleRegistrar class</h1>
                
            
            
                
<p><kbd>ModuleRegistrar</kbd>, which implements the previously mentioned interface, will look something like the following. This basically behaves as a wrapper for the built-in IoC Container to register dependencies:</p>
<pre>    using Microsoft.Extensions.DependencyInjection;<br/>    using System;<br/><br/>    namespace PacktDIExamples.Common<br/>    {<br/>      internal class ModuleRegistrar : IModuleRegistrar<br/>      {<br/>        private readonly IServiceCollection _serviceCollection;<br/>        public ModuleRegistrar(<strong>IServiceCollection serviceCollection</strong>)<br/>        {<br/>            <strong>this._serviceCollection = serviceCollection;</strong><br/>        }<br/><br/>        public void Add(Type serviceType, Type implementationType,<br/>            ServiceLifetime lifetime)<br/>        {<br/>            <strong>var descriptor = new ServiceDescriptor(serviceType, <br/>              implementationType, lifetime);</strong><br/><strong>            this._serviceCollection.Add(descriptor);</strong><br/>        }<br/>      }<br/>    }</pre>
<p>Notice the two important aspects of this class:</p>
<ul>
<li><kbd>IServiceCollection</kbd> is injected into the constructor</li>
<li>Injected <kbd>IServiceCollection</kbd> used to add dependencies into the container using <kbd>ServiceDescriptor</kbd> instance</li>
</ul>
<p>This class is a part of the Common Library.</p>
<div><strong>Service Descriptor:</strong> <kbd>IServiceCollection</kbd> is the collection of the service descriptors. A Service Descriptor instance when created can provide full information about a service or dependency. We have different methods for different lifestyles such as <kbd>AddTransient</kbd>, <kbd>AddScoped</kbd>, and <kbd>AddSingleton</kbd> to register dependencies. However, we can't write all three methods to manage the dependencies at a commonplace. That is where a Service Descriptor can help takes lifetime as a parameter and can be added directly to the <kbd>ServiceCollection</kbd> using the <kbd>Add</kbd> method.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">The IModule interface</h1>
                
            
            
                
<p><kbd>IModule</kbd> is the main hero of the architecture because this is the first thing which will be used by a Loader to recognize what modules are required to be fetched from all the assemblies that are targeted. This interface exposes one method, <kbd>Initialize()</kbd> which is invoked by the Loader to add dependencies into the container. Consider the following code snippet:</p>
<pre>    namespace PacktDIExamples.Common<br/>    {<br/>      public interface IModule<br/>      {<br/>        void Initialize(IModuleRegistrar registrar);<br/>      }<br/>    }</pre>
<p>This interface lies inside Common Library as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The ModuleInit class</h1>
                
            
            
                
<p>Let's see how the preceding <kbd>IModule</kbd> interface can be implemented inside the <kbd>Business Layer</kbd>:</p>
<pre>    using Microsoft.Extensions.DependencyInjection;<br/>    using PacktDIExamples.Common;<br/>    using System.Composition;<br/><br/>    namespace <strong>PacktDIExamples.Business</strong><br/>    {<br/><strong>      [Export(typeof(IModule))] // Will be used by MEF to<br/>         fetch the class.</strong><br/>      public class ModuleInit : <strong>IModule</strong><br/>      {<br/>        public void Initialize(<strong>IModuleRegistrar registrar</strong>) <strong>// Registrar<br/>            injected.</strong><br/>        {<br/><strong>           registrar.Add(typeof(IUsersService), typeof(UsersService),<br/></strong><strong>              ServiceLifetime.Transient);<br/>           // Adds the UserService instance <br/>           // to the container with Transient Lifetime.</strong><br/>        }<br/>      }<br/>    } </pre>
<p><kbd>ModuleInit</kbd> is present inside both the <kbd>Business Layer</kbd> and <kbd>Data Access Layer</kbd>. This class helps us to add different dependencies in each layer such as <kbd>UsersService</kbd> in <kbd>Business</kbd> and <kbd>UsersRepository</kbd> in <kbd>Data Access</kbd>. You can see how <kbd>UserService</kbd> is added to the registrar inside <kbd>Business Layer</kbd>. I am skipping <kbd>ModuleInit</kbd> of the <kbd>DataAccess Layer</kbd>. It's just a change of one line inside <kbd>Initialize</kbd>. The following line of code can be added for <kbd>UserRepository</kbd> dependency registration inside <kbd>ModuleInit</kbd> of <kbd>Data Access Layer</kbd>:</p>
<pre>    registrar.Add(typeof(IUsersRepository), typeof(UsersRepository),<br/>      ServiceLifetime.Transient);</pre>
<p>Just make a note of the bold part <kbd>([Export(typeof(IModule))])</kbd> in the last-but-one code block, which is very important. This is the attribute, which helps MEF to grab the <kbd>ModuleInit</kbd> classes in the specified assemblies, with the interface <kbd>IModule</kbd>. It can then easily call <kbd>Initialize</kbd> to start the process of registering dependencies. We will very soon see the code, that does this task for us.</p>
<p>Wait! We have a Constructor Injection here. And what is that used for? Actually, the code for registering the dependency lies inside the registrar, so we definitely need the <kbd>IModuleRegistrar</kbd> dependency in order to call <kbd>Add()</kbd> of <kbd>Registrar</kbd>, which registers the required dependency, for example, <kbd>UsersService</kbd> here inside <kbd>Business Layer</kbd>.</p>
<p>Check out the flow of controls during the process of dependency registrations. Typically the flow is like the following:</p>
<p><kbd>ModuleLoader</kbd> | <kbd>ModuleInit(IRegistrar)</kbd> | <kbd>ModuleRegistrar</kbd> | <kbd>Add()</kbd> (adds the dependency to collection):</p>
<p>The following diagram visualizes the work of <strong>Module Loader</strong> through the available layers as discussed:</p>
<div><img height="293" width="413" src="img/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The ModuleLoader class</h1>
                
            
            
                
<p>To work with MEF, we need a Nuget package known as &lt;/span&gt;<kbd>Microsoft.Composition.</kbd> This will install <kbd>System.Composition</kbd> into the project. You need to add the package inside the <kbd>Common Layer</kbd>. <kbd>ContainerConfiguration</kbd> is the class present inside the <kbd>System.Composition.Hosting</kbd> namespace, which composes all assemblies and can provide us with a Container, from which we can easily<em> </em>extract the required concrete implementations.</p>
<p>The following screenshot is the <kbd>NuGet</kbd> Package preview shown in the NuGet Package Manager window when you search:</p>
<div><img style="color: #333333;font-size: 14.6667px" src="img/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png"/></div>
<p>Finally the last, but not the least,  <kbd>ModuleLoader</kbd>. All that we have learned till now is managed by the Loader which is a static class with one method <kbd>LoadContainer</kbd>. This method is invoked by our MVC Web App <kbd>Startup</kbd> to initialize the dependency registration process. Let's have a sneak peek at the codes:</p>
<pre>    namespace PacktDIExamples.Common<br/>    {<br/>     public static class ModuleLoader<br/>     {<br/>        public static void LoadContainer(IServiceCollection collection,<br/>            string pattern)<br/>        {<br/>           // Gets the Assembly Location: The total path of the Web App<br/>           assembly, which in our case is <br/><strong>           "C:\\Users\\taditd\\Desktop\\Packt\\Codes\\PacktDIExamples\\<br/>            PacktDIExamples\\bin\\Debug\\netcoreapp2.0\\<br/>            PacktDIExamples.dll"</strong>.<br/>            var executableLocation = Assembly.GetEntryAssembly().Location;<br/><br/>            // Get all assemblies inside the location with a pattern<br/>              from <strong>"bin\Debug\netcoreapp2.0"</strong>.<br/>            var assemblies = Directory<br/>                .GetFiles(Path.GetDirectoryName(executableLocation),<br/>                   <strong>pattern</strong>, SearchOption.AllDirectories)<br/>                .Select(AssemblyLoadContext.Default.LoadFromAssemblyPath)<br/>                .ToList();<br/><br/>            <strong>// Composes the assemblies.</strong><br/>            var configuration = new ContainerConfiguration()<br/>               .WithAssemblies(assemblies);<br/>            using (var container = configuration.CreateContainer())<br/>            {<br/><strong>              // This is important.</strong> <strong>The following line extracts<br/>             all the IModule implementations from the<br/>             assemblies we fetched.</strong><br/>             IEnumerable&lt;IModule&gt; modules = container.GetExports&lt;IModule&amp;gt;();<br/>             var registrar = new ModuleRegistrar(collection);<br/><br/>             foreach (IModule module in modules)<br/>             {<br/>           <strong>   // Invoke Initialize for each module with the registrar<br/>               as a dependency.</strong><br/>              module.Initialize(registrar);<br/>             }<br/>           }<br/>          }<br/>        }<br/>     }</pre>
<p>I have added comments over each step so that it will be easy for you to analyze the steps. The steps can be defined as follows:</p>
<ol>
<li>Get the <kbd>Web App Assembly Location</kbd>. As we are going to call this method from Web App and every other assembly is placed there, we need that location to find others.</li>
<li>Find out, what other assemblies present in that particular location. However, we need to have DLLs of the layers we have in our app. For that reason, a pattern is necessary to recognize the assemblies of the layers. According to our layers, we only need to find all assembly names starting with PacktDIExamples and ending with <kbd>.dll</kbd>, because the Layer names are like <kbd>PacktDIExamples.Business.dll</kbd> and <kbd>PacktDIExamples.DataAccess.dll</kbd>. So, the pattern will be <kbd>PacktDIExamples.*.dll</kbd>. We will see the code sends this pattern to the <kbd>LoadContainer</kbd> in a moment. You can see the extracted modules shown in the Visual Studio tooltip while debugging, shown as follows:</li>
</ol>
<div><img height="184" width="524" src="img/118fd71a-eb45-4c62-a0c7-ab68c473a375.png"/><br/></div>
<ol start="3">
<li>Create a container to hold all the assemblies using the <kbd>ContainerConfiguration</kbd> instance.</li>
<li>Now <kbd>container.GetExports&lt;IModule&gt;()</kbd> is used to extract the <kbd>IModule</kbd> implementation from these assemblies.</li>
<li>Execute the <kbd>Initialize</kbd> method for each <kbd>IModule</kbd> implementations with a registrar instance as a dependency because the <kbd>Registrar</kbd> has the actual <kbd>Add</kbd> method for dependency registration with the <kbd>ServiceCollection</kbd>.</li>
</ol>
<p>I would advise you to put <kbd>try...catch</kbd> blocks in this method to handle the exceptions. Due to the space restrictions, I have not posted the <kbd>try...catch</kbd> block. I just want to show the core logic of a <kbd>ModuleLoader</kbd>. I have also removed the <kbd>usings</kbd>, which were taking up a lot of space. You can figure out the <kbd>usings</kbd>, anyway; if not, use Visual Studio. Hover on the red lines and then follow the steps which will include the required libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing the ModuleLoader.LoaderContainer() method from Web App</h1>
                
            
            
                
<p>This is the final step and the simplest one. See how we can call this Loader from the Web App inside the <kbd>Startup</kbd> as follows:</p>
<pre>    public void ConfigureServices(IServiceCollection services)<br/>    {<br/>      // Commented out codes because we now load dependencies from<br/>          another layer.<br/>      // services.AddTransient&lt;IUsersService, UsersService&gt;()<br/>      //         .AddTransient&lt;IUsersRepository, UsersRepository&gt;();<br/><br/>      ModuleLoader.LoadContainer(<strong>services</strong>, "PacktDIExamples.*.dll");<br/>      services.AddMvc();<br/>    }</pre>
<p>As I mentioned, we need to send a pattern to fetch the Assembly names from <kbd>bin/debug/netcoreapp2.0</kbd>; otherwise, it will fetch all assemblies, which is unnecessary.</p>
<p>Notice that we are sending the services to the <kbd>LoadContainer</kbd>. Now the previous code for registering the dependencies is commented, which got optimized by the <kbd>ModuleLoader.LoadContainer</kbd> call.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What have we achieved with MEF?</h1>
                
            
            
                
<p>If you have not yet realized the benefits of refactoring the layered architecture with MEF, have a close look at the following screenshot with explanations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Layers are separated</h1>
                
            
            
                
<p>Layers were tightly coupled as the UI was referencing the <kbd>Business Layer</kbd> and the <kbd>Data Access Layer</kbd>. Now after MEF, the UI is not tied to the <kbd>Data Access Layer</kbd> anymore. However, the UI has one <kbd>Business Layer</kbd> assembly reference as shown in the following screenshot. But that is not used anywhere inside the project. It is there because the assembly should be inside the <kbd>bin</kbd> folder so that the MEF Module is able to read it while initializing to export the <kbd>IModule</kbd> implementations. The following is a quick comparison of Project Dependencies before and after MEF:</p>
<div><br/>
<img height="345" width="667" src="img/a29dad10-90ff-43ba-b7a0-fd385789141e.png"/></div>
<p>If you try to remove the Business reference from the UI and run the app, it will throw an exception, as follows. And this is for obvious reasons. Unless you have the reference, MEF won't be able to extract the <kbd>IUsersService</kbd> implementation and register to the DI Container, simple!</p>
<p>Thus, the issue happens as soon as you hit the controller, as nothing has been registered to the <kbd>IServiceCollection</kbd>:</p>
<div><img src="img/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">All classes inside layers are now internal</h1>
                
            
            
                
<p>Instead of having <kbd>public</kbd> as the access specifiers for the classes, we can make them <kbd>internal</kbd> so that they are only accessible inside the assembly (this means only internally inside the Layer):</p>
<p>&gt;<img height="210" width="345" src="img/ffb885fe-c0ca-4295-8741-62720a46541f.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">No concrete class instantiation inside the UI Layer</h1>
                
            
            
                
<p class="mce-root">Before MEF implementation, we saw how, inside the <kbd>Edit</kbd> action method, we could directly reference the <kbd>Data Access Layer</kbd> and <kbd>Business Layer</kbd> classes. Now we won't be able to do this because the classes are not accessible anymore.</p>
<p class="mce-root">That is proved from the compiler errors inside <kbd>UsersController</kbd> as shown in the following screenshot. Notice the tooltip preview, which indicates the unavailability of the UsersService. So, misusing classes of other layers is restricted even if you add the references:</p>
<div><img height="364" width="674" src="img/1bf50224-e455-4124-bc5d-b38f56c0f499.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">More layers can be added to the architecture</h1>
                
            
            
                
<p>When, in the future, you add more layers for optimisation or any other business-related requirements, that assembly can be simply referred to by the UI; then every dependency will automatically get registered to the IoC Container. Remember, you need have to a <kbd>ModuleInit</kbd> class implementing the interface <kbd>IModule</kbd> to automate the process. The application is totally flexible now, allowing new modules to be attached easily with no hassle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusion</h1>
                
            
            
                
<p>Most modern applications follow a layered architecture. Having a Dependency Injection technique to manage the dependencies required inside the layers is something we should be following. Having said that, we need to be careful with layer designs. That is because we applied DI, thinking that it would resolve issues of tight coupling with the dependencies of a class. However, we did not realize that the layers are getting connected with each other through concrete dependencies (such as the <kbd>User</kbd> instance return type).</p>
<p><em>Managed Extensibility Framework</em> provided us with a few easy steps to dynamically bind the dependencies from different layers, package them into one, and then register it to the container for further use by the controllers in the <kbd>UI Layer</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>After learning DI Techniques, Patterns, Anti-Patterns and so on, we still needed some pointers to deal with practical scenarios where DI comes into play.</p>
<p>We explored a few real-time application instances where DI can help eliminate coupling and introduce a cleaner dependency structure.</p>
<p>Tightly coupled systems are often seen when a developer tries to be lazy and instantiates the required dependencies directly inside the class using the <kbd>new</kbd> operator. Keep in mind that new is glue. This not only instills a bad practice in you as a coder but also makes your code untestable. Unit testing becomes difficult. We learned the technique to deal with the problem of tight coupling by following DI techniques.</p>
<p>Then we realized that layering in an application is a common approach with applications. Having DI is definitely going to help us in the long run for layered systems. However, there might be loose ends in the layered approach which should be addressed.</p>
<p>MEF is the technique which we adopted to solve a couple of problems with layered architecture. By implementing MEF, the business or data layer implementations can be marked as internal so that they are not exposed to other layers. Also, layer architectural rules for the separation of concerns can remain intact with a DI container. Thus, the layers can breathe independently without any interference and decorate the architecture in such a way that the introduction of new modules into it becomes very smooth.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>