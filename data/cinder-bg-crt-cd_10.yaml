- en: Chapter 10. Talk to the User – Adding Interactivity and UI Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 与用户对话 – 添加交互性和UI事件
- en: 'In this chapter we will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Detecting a key press on the keyboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测键盘按键
- en: Detecting mouse movement and clicks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测鼠标移动和点击
- en: Creating an application that will use basic input for real-time control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用基本输入进行实时控制的应用程序
- en: We have used some of these functionality in the previous chapters, but here
    we will try to gain a more systematic overview of what kind of basic interactivity
    is possible with Cinder.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面几章中使用了一些这些功能，但在这里我们将尝试获得一个更系统的概述，了解Cinder可以提供哪些基本交互性。
- en: Handling events
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: Throughout this book we are writing a code that basically extends the functionality
    of the `cinder::app::AppBasic` class and base class `App` that it inherits. The
    methods that we are declaring and implementing are basically overrides of virtual
    functions that are built in the `AppBasic` and `App` classes and are called upon
    in certain events. Some of them can be called event handlers, and what they basically
    do is they respond to certain events that are happening during the application
    flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们编写的代码基本上扩展了`cinder::app::AppBasic`类及其继承的基类`App`的功能。我们声明和实现的方法基本上是覆盖了`AppBasic`和`App`类中构建的虚拟函数，并在某些事件中被调用。其中一些可以被称为事件处理器，它们基本上是对应用程序流程中发生的某些事件做出响应。
- en: 'There are three basic methods that form the core of a Cinder application:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本方法构成了Cinder应用程序的核心：
- en: '`setup()`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`'
- en: '`update()`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`'
- en: '`draw()`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw()`'
- en: These methods handle the events that are happening inside the application core
    and a user can't control whether these functions are called or not (it is possible
    to stop the execution of the method by using `return` or similar means at the
    beginning of the function implementation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法处理应用程序核心内部发生的事件，用户无法控制这些函数是否被调用（在函数实现的开头使用`return`或类似方式可以停止方法的执行）。
- en: 'Then there are methods that can be used to execute code on certain events for
    example moving your mouse, pressing a key on the keyboard, scrolling the mouse
    wheel, and so on. These are the ones we will focus on during this chapter. So
    here is a list of methods (or event handlers) that we will override:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一些方法可以在某些事件上执行代码，例如移动鼠标、按键盘上的键、滚动鼠标滚轮等。这是我们将在本章中关注的内容。所以这里有一个方法（或事件处理器）列表，我们将覆盖它们：
- en: '`keyDown()`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyDown()`'
- en: '`keyUp()`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyUp()`'
- en: '`fileDrop()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileDrop()`'
- en: '`mouseDown()`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseDown()`'
- en: '`mouseUp()`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseUp()`'
- en: '`mouseMove()`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseMove()`'
- en: '`mouseDrag()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseDrag()`'
- en: Let's create a simple drawing application that will use all of these events.
    To do so, we will need to create a new project. Open **TinderBox** and create
    a new project with the name `BasicEvents`. Open the project file (`xcode/BasicEvents.xcodeproj`
    on Mac OS X or `vc10\BasicEvents.sln` on Windows). Open the `BasicEventsApp.cpp`
    in the editor and let's start to add some code there.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的绘图应用程序，它将使用所有这些事件。为此，我们需要创建一个新的项目。打开**TinderBox**，创建一个名为`BasicEvents`的新项目。打开项目文件（在Mac
    OS X上为`xcode/BasicEvents.xcodeproj`，在Windows上为`vc10\BasicEvents.sln`）。在编辑器中打开`BasicEventsApp.cpp`，然后开始添加一些代码。
- en: Using mouseMove()
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`mouseMove()`
- en: 'First we will add a custom mouse cursor that will fall down slowly while we
    don''t move the mouse, and returns to the current mouse position when we move
    it. To do so we have to declare objects that will hold the x and y position of
    the cursor. Add the following line of code to the class declaration part of the
    file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个自定义鼠标光标，当鼠标不移动时，它会慢慢下落，当鼠标移动时，它会返回到当前鼠标位置。为此，我们需要声明将保存光标x和y位置的变量。将以下代码行添加到文件声明部分：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This variable will hold the `x` and `y` positions of our cursor as `int` values.
    The `i` part of the `Vec2i` tells us that it is a two-dimensional vector that
    consists of integer values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将保存我们的光标`x`和`y`位置的`int`值。`Vec2i`中的`i`部分告诉我们它是一个由整数值组成的二维向量。
- en: 'Next we need to initialize the value by setting it to the current mouse position
    at the application launch. Add the following line of code to the `setup()` method
    implementation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过将值设置为应用程序启动时的当前鼠标位置来初始化该值。将以下代码行添加到`setup()`方法实现中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will get the current mouse position and assign it to our cursor position
    value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取当前鼠标位置并将其分配给我们的光标位置值。
- en: 'Next, we want to draw a circle at the `cursorPos` coordinates. Let''s navigate
    to the `draw()` method implementation of our application and add the following
    line just after the `gl::clear()` function call:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想在`cursorPos`坐标处绘制一个圆圈。让我们导航到应用程序的`draw()`方法实现，并在`gl::clear()`函数调用之后添加以下行：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've used this function before. This will draw a circle with the radius of
    10 pixels at the position defined by the `cursorPos` variable. Compile and run
    the project to see for yourself!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过这个函数。这将使用`cursorPos`变量定义的位置绘制一个半径为10像素的圆圈。编译并运行项目，亲自看看吧！
- en: 'Next we want to add the falling motion to the circle. To do so, we will need
    to update the circle''s `y` position by each frame. In other words, we are going
    to increase the `y` coordinate of the circle by one frame each. Let''s navigate
    to the `update()` method implementation and add a simple line of code as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要给圆圈添加下落动作。为此，我们需要在每一帧更新圆圈的`y`位置。换句话说，我们将每帧增加圆圈的`y`坐标。让我们导航到`update()`方法实现，并添加以下简单的一行代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will let our cursor fall down. Finally we need to make it stick to the
    mouse on the `mouseMove` event. We will need to declare the `mouseMove()` method
    override in the class declaration of our application. Add the following line at
    the end of the class declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使光标下落。最后，我们需要在`mouseMove`事件中使其粘附到鼠标上。我们需要在应用程序的类声明中声明`mouseMove()`方法重写。在类声明的末尾添加以下行：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the method implementation to the class implementation as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将方法实现添加到类实现中，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is more than one way of getting the current mouse position and instead
    of `event.getPos()`. We could use `getMousePos()` and it would do the same thing
    that is assigned to the mouse position to the `cursorPos` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前鼠标位置的方法不止一种，而不是使用`event.getPos()`。我们可以使用`getMousePos()`，它将执行与鼠标位置分配给`cursorPos`变量相同的事情。
- en: 'Compile and run our application to see the result as shown in the following
    screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序，查看以下截图所示的结果：
- en: '![Using mouseMove()](img/9564_10_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用mouseMove()](img/9564_10_01.jpg)'
- en: You should see a falling circle that sticks to the mouse as you move it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个跟随鼠标移动的下落圆圈。
- en: Using mouseDown()
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mouseDown()
- en: The next event handler that we are going to implement is the `mouseDown()` handler.
    It will execute code every time we click on any of the mouse buttons. We will
    write code that will add a static circle on the screen every time we click the
    left mouse button. It will remove the first circle when we click the right mouse
    button.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的事件处理程序是`mouseDown()`处理程序。每次我们点击鼠标的任意按钮时，它都会执行代码。我们将编写代码，每次我们点击左鼠标按钮时，都会在屏幕上添加一个静态圆圈。当我们点击右鼠标按钮时，它将移除第一个圆圈。
- en: To begin with, we will need to declare a new variable that will be able to store
    more than one pair of coordinates for our generated circles. We could use an array
    of `Vec2i` objects but as we don't know the exact count of the circles we are
    going to create, we will use a C++ `vector`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明一个新的变量，该变量能够存储我们生成的圆圈的多对坐标。我们可以使用`Vec2i`对象的数组，但由于我们不知道将要创建的圆圈的确切数量，我们将使用C++的`vector`。
- en: A **vector** is a dynamic array that is able to store `std::vector::max_size`
    amount of objects of a certain type. A `vector` array changes it's size (or length)
    dynamically on element add (or push) and remove (or pop).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**是一个动态数组，能够存储`std::vector::max_size`数量的特定类型的对象。`vector`数组在元素添加（或推入）和移除（或弹出）时动态地改变其大小（或长度）。'
- en: 'Add the following lines of code at the end of our class declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类声明的末尾添加以下代码行：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is possible that the `mouseDown()` method is declared for us already. If
    so, don''t mention the second line of the code. If `mouseDown()` was not declared
    before, go ahead and add the event handler method to the class implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的`mouseDown()`方法已经为我们声明了。如果是这样，不要提及代码的第二行。如果`mouseDown()`之前没有声明，请继续将事件处理程序方法添加到类实现中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can tell from the comments in the preceding code, it checks which mouse
    button has been pressed and then decides what to do next. As we stated before,
    a circle has to be created when you click the left-mouse button and a circle has
    to be removed when you click on the right-mouse button. Actually we do not create
    circles here, we just save their positions. In the `draw()` method we will be
    able to chose whether we want to draw circles or something else entirely.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码注释中可以看出，它检查哪个鼠标按钮已被按下，然后决定接下来要做什么。正如我们之前所述，当您点击左鼠标按钮时，必须创建一个圆，当您点击右鼠标按钮时，必须移除一个圆。实际上，我们在这里并没有创建圆，我们只是保存它们的位置。在`draw()`方法中，我们将能够选择是绘制圆还是其他完全不同的东西。
- en: 'So let''s navigate to the `draw()` method implementation and add the following
    code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们导航到`draw()`方法实现，并添加以下代码片段：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To loop through a vector we have to use an iterator in this case. Vector iterators
    are objects that are designed to traverse the vector. In this case the iterator
    object is like a pointer and a `vector<Vec2i>` type iterator will point to a `Vec2i`
    object inside of it. By increasing and decreasing the iterator position we gain
    access to the next or previous item in the vector. It is possible to get the `begin()`
    and `end()` iterators from a vector and they point to the first and the past-the-end
    element of a vector respectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历一个向量，我们必须在这种情况下使用迭代器。向量迭代器是设计用来遍历向量的对象。在这种情况下，迭代器对象就像一个指针，一个`vector<Vec2i>`类型的迭代器将指向它内部的`Vec2i`对象。通过增加和减少迭代器的位置，我们可以访问向量中的下一个或上一个项目。可以从向量中获取`begin()`和`end()`迭代器，它们分别指向向量的第一个和超出结束元素。
- en: To access an element through the iterator (that is similar to a pointer), we
    have to make use of the concept of **dereferencing** . To dereference a pointer
    we have to use an asterisk (`*`) before the pointer variable. If `i` is a pointer
    to the actual position of a circle, to access the actual `Vec2i` object that stores
    the coordinates, we have to use `*i`. To access properties of the object, we write
    `(*i).x` or `i->x`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过迭代器（类似于指针）访问元素，我们必须使用**解引用**的概念。要解引用指针，我们必须在指针变量前使用一个星号（`*`）。如果`i`是指向一个圆的实际位置的指针，要访问存储坐标的实际`Vec2i`对象，我们必须使用`*i`。要访问对象的属性，我们写`(*i).x`或`i->x`。
- en: Compile and run the project. You should be able to add and remove circles by
    clicking on the right and left buttons of your mouse.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目。您应该能够通过点击鼠标的左右按钮来添加和移除圆。
- en: '![Using mouseDown()](img/9564_10_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用mouseDown()](img/9564_10_02.jpg)'
- en: You can do the same by using the `mouseUp()` event handler instead of `mouseDown()`.
    The only difference is that the code will be executed when you release the mouse
    button.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用`mouseUp()`事件处理器而不是`mouseDown()`来实现相同的功能。唯一的区别是，当您释放鼠标按钮时，代码将被执行。
- en: Using mouseDrag()
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mouseDrag()
- en: 'Next we are going to make use of the `mouseDrag()` event handler to draw a
    polyline on the screen. We will need another `vector` for storing the coordinates
    of the points that will actually form the polyline. Let''s declare the `vector`
    and `mouseDrag()` event handlers in the class declaration. Add the following line
    of code at the end of it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用`mouseDrag()`事件处理器在屏幕上绘制一个折线。我们需要另一个`vector`来存储实际形成折线的点的坐标。让我们在类声明中声明这个`vector`和`mouseDrag()`事件处理器。在它的末尾添加以下代码行：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use `PolyLine<Vec2f>` here because `PolyLine` is a Cinder class that is used
    to store control point values of a line. We use `Vec2f` instead of `int`, because
    there is no `draw` function in Cinder that would accept a `PolyLine` class that
    consists of `int` values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`PolyLine<Vec2f>`，因为`PolyLine`是Cinder类，用于存储线的控制点值。我们使用`Vec2f`而不是`int`，因为Cinder中没有接受由`int`值组成的`PolyLine`类的`draw`函数。
- en: 'Let''s move to the next step and add the implementation of the `mouseDrag()`
    method to the class implementation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行下一步，并将`mouseDrag()`方法的实现添加到类实现中：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will add a new position with the current mouse coordinates to the `PolyLine`
    each time a change in mouse position is detected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在检测到鼠标位置变化时，将当前鼠标坐标的新位置添加到`PolyLine`中。
- en: 'Lastly, we have to draw the `PolyLine`. So let''s navigate to the `draw()`
    method implementation and add the following line of code there:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须绘制`PolyLine`。所以让我们导航到`draw()`方法实现，并添加以下代码行：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `gl::drawSolid` function will basically draw a filled polygon. The `PolyLine`
    itself defines the outline of the polygon. Compile and run the project to see
    what I mean to say. You should end up with an image similar to the one shown in
    the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl::drawSolid`函数基本上会绘制一个填充的多边形。`PolyLine`本身定义了多边形的轮廓。编译并运行项目以查看我的意思。您应该得到一个类似于以下截图所示的图像：'
- en: '![Using mouseDrag()](img/9564_10_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用mouseDrag()](img/9564_10_03.jpg)'
- en: If you want to draw a line, use `gl::draw(line)` instead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想画一条线，请使用`gl::draw(line)`代替。
- en: Using keyDown()
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`keyDown()`
- en: 'It would be nice if we had the ability to clear the screen while the application
    is running instead of closing and reopening it to start again. Let''s make use
    of the `keyDown()` event handler to detect a key press. What we want to do is
    to erase all circles and the line when the *C* key is pressed. To do that, we
    need to declare the `keyDown()` method in the class declaration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序运行时能够清除屏幕而不是关闭和重新打开它来重新开始，那将很棒。让我们使用`keyDown()`事件处理器来检测按键。我们想要做的是，当按下*C*键时，擦除所有圆圈和线条。为此，我们需要在类声明中声明`keyDown()`方法：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next we have to implement this, so add the following code snippet at the end
    of the file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现这一点，所以请在文件末尾添加以下代码片段：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `keyDown()` method takes a `KeyEvent` parameter that contains the code of
    the key that is being pressed. Here we check if the key code represents the letter
    C on the keyboard and if that is `true`, we clear the `circlePositions` `vector`
    and `vector` values in the `PolyLine` object that actually stores the control
    points in the same manner as the `vector` `circlePositions` does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyDown()`方法接受一个`KeyEvent`参数，该参数包含被按下的键的代码。在这里，我们检查键码是否代表键盘上的字母C，如果是`true`，我们就清除`circlePositions`
    `vector`和`vector`值，在`PolyLine`对象中以与`vector` `circlePositions`相同的方式存储控制点。'
- en: You can do the same thing with the `keyUp()` event handler. We won't make a
    separate example of it now as it works exactly the same way when a key is released.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`keyUp()`事件处理器做同样的事情。现在我们不会为它制作一个单独的示例，因为它在按键释放时工作方式完全相同。
- en: Using fileDrop()
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`fileDrop()`
- en: 'What we will do though is we will make use of the `fileDrop()` event handler
    to place a picture in the background. It takes `FileDropEvent` object as a parameter.
    It contains the path to the file that is being dropped on to the application window.
    To make use of that path, we need to add these lines at the top of the class file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们将使用`fileDrop()`事件处理器来在背景中放置一张图片。它接受一个`FileDropEvent`对象作为参数。它包含被拖放到应用程序窗口上的文件的路径。为了使用该路径，我们需要在类文件顶部添加以下行：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first include is needed because it contains the `gl::Texture` class that
    we will need in order to store the background image and to draw it by using the
    `gl::draw()` function. The `ImageIo.h` file is here because of the image loading
    functions that we will need to load an actual image into the `Texture` instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含文件是必需的，因为它包含我们将需要的`gl::Texture`类，以便存储背景图像并使用`gl::draw()`函数绘制它。`ImageIo.h`文件在这里是因为我们需要加载实际图像到`Texture`实例中的图像加载函数。
- en: 'Next, we need to declare a variable that will store the background image and
    the `fileDrop()` event method itself. Add the following lines of code at the end
    of the class declaration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明一个变量来存储背景图像和`fileDrop()`事件方法本身。请在类声明末尾添加以下代码行：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to implement the `fileDrop()` method. Add the following lines of
    code in the class implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现`fileDrop()`方法。请在类实现中添加以下代码行：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we are making use of the `try` and `catch` statement. By doing this we
    just make sure that our application does not crash if the wrong kind of file is
    being dropped. We load an image into the `background` variable if we are lucky
    or print an error message to the console if not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`try`和`catch`语句。通过这样做，我们只是确保如果放置了错误类型的文件，我们的应用程序不会崩溃。如果我们幸运的话，我们将图像加载到`background`变量中，如果不幸运，则将错误消息打印到控制台。
- en: Take a closer look on the `console()` function call. The `console()` function
    refers to the standard output or console. This is one of the best debugging tools
    in the world and you should consider using it if you are not using it already.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看`console()`函数调用。`console()`函数指的是标准输出或控制台。这是世界上最好的调试工具之一，如果您还没有使用它，您应该考虑使用它。
- en: 'There is one last thing missing, we have to draw the `background`. Go to the
    `draw()` method implementation and add the following code snippet right after
    the `gl::clear()` function call and before all the code we added to this method
    during this chapter. We do so because the background is the first thing that we
    need to draw in each frame:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要完成，我们必须绘制`背景`。前往`draw()`方法实现，在`gl::clear()`函数调用之后和我们在本章中添加到该方法的所有代码之前添加以下代码片段。我们这样做是因为背景是我们需要在每一帧中首先绘制的：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Before we draw a texture, we have to make sure that it actually exists. That's
    why we are using an extra if statement. Only then 'can' we draw the background
    texture within the bounds of our application window that is returned by the `getWindowBounds()`
    method call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制纹理之前，我们必须确保它确实存在。这就是为什么我们使用了一个额外的 if 语句。只有在这种情况下，我们才能在由`getWindowBounds()`方法调用返回的应用程序窗口范围内绘制背景纹理。
- en: 'Compile and run our application. Drop an image file on to the window of our
    application and see what happens. You should see an image similar to the following
    screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。将一个图像文件拖放到我们应用程序的窗口上，看看会发生什么。你应该会看到一个类似于以下屏幕截图的图像：
- en: '![Using fileDrop()](img/9564_10_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用 fileDrop()](img/9564_10_04.jpg)'
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained a basic understanding about the built-in and mostly
    used events that any kind of application could make use of. We learned how to
    make use of mouse press, mouse drag, key press, and even file drop events. We
    also made use of some new drawing methods that were not explained in previous
    chapters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们获得了对任何类型的应用程序都可能使用的内置和最常用事件的基本理解。我们学习了如何利用鼠标点击、鼠标拖动、键盘点击甚至文件拖放事件。我们还利用了一些在之前章节中未解释的新绘图方法。
- en: In the next chapter, we are going to talk about communication between applications
    built-in Cinder, and other applications on the same or other networked computer
    by using Syphon and Open Sound Control message system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用 Syphon 和 Open Sound Control 消息系统，在 Cinder 内置的应用程序与其他同一或不同网络计算机上的应用程序之间的通信。
