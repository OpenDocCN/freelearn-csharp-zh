<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor165"/>5</h1>
<h1 id="_idParaDest-95"><a id="_idTextAnchor166"/>Stacks and Queues</h1>
<p>So far, you learned a lot about arrays and lists. However, these structures are not the only ones available. Among others, there is also a group of more specialized data structures <a id="_idIndexMarker451"/>called <strong class="bold">limited access </strong><strong class="bold">data structures</strong>.</p>
<p>What does this mean? To explain the name, let’s return to the topic of arrays for the moment, which belong to the group<a id="_idIndexMarker452"/> of <strong class="bold">random access data structures</strong>. The difference between them is only one word -  that is, <em class="italic">limited</em> or <em class="italic">random</em>. As you already know, arrays allow you to store data and get access to various elements using indices. Thus, you can easily get the first, the middle, the <em class="italic">n</em>th, or the last element from an array. For this reason, it can be named a random access data structure.</p>
<p>However, what does <em class="italic">limited</em> mean? The answer is very simple. With a limited access data structure, <strong class="bold">you cannot access every element from the structure</strong>. Thus, <strong class="bold">the way of getting elements is strictly specified</strong>. For example, you can get only the first or the last element, but you cannot get the <em class="italic">n</em>th element from the data structure. Popular representatives of limited access data structures are stacks and queues, which are topics mentioned in this chapter.</p>
<p>You will see the application of a stack, as well as a few variants of queues, including a regular one, a priority queue, and a circular queue. To make understanding easier, the text is supported with illustrations and code snippets with detailed explanations.</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>Stacks</li>
<li>Queues</li>
<li>Priority queu<a id="_idTextAnchor167"/>es</li>
<li>Circular queue<a id="_idTextAnchor168"/>s</li>
</ul>
<h1 id="_idParaDest-96"><a id="_idTextAnchor169"/>Stacks</h1>
<p>To begin, let’s talk about a <strong class="bold">stack</strong>. It is a data <a id="_idIndexMarker453"/>structure that allows you to <strong class="bold">add a new element only at the top</strong> (referred to as a <strong class="bold">push </strong>operation) and <strong class="bold">to get an element only by removing it from the top</strong> (a <strong class="bold">pop</strong> operation). For this reason, a stack is consistent with<a id="_idIndexMarker454"/> the <strong class="bold">LIFO</strong> principle, which stands for <strong class="bold">Last-In First-Out</strong>.</p>
<p class="callout-heading">Imagine a stack</p>
<p class="callout">If you want to better visualize a stack, let’s close the book for a moment, go to the kitchen, and take a look at a pile of plates, each placed on top of the other. You can only add a new plate to the top of the pile, and you can only get a plate from the top of the pile. You cannot remove the seventh plate without taking the previous six from the top, and you cannot add a plate to the middle of the pile. So, the last added plate (last-in) will be removed from the pile first (first-out). And do not even try to get a plate from the middle of the pile, as you don’t want to break plates! The stack operates similarly. It allows you to add a new element only at the top (a push operation) and to get an element only by removing it from the top (a pop operation).</p>
<p>A diagram of a <a id="_idIndexMarker455"/>stack with <em class="italic">push</em> and <em class="italic">pop</em> operations is shown as follows:</p>
<div><div><img alt="Figure 5.1 – ﻿Illustration of a stack" src="img/B18069_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Illustration of a stack</p>
<p>It seems to be very easy, doesn’t it? It really is, and you can benefit from various features of <a id="_idIndexMarker456"/>stacks using the built-in generic <code>Stack</code> class. It is worth remembering that it is located in the <code>System.Collections.Generic</code> namespace.</p>
<p>Let’s mention three methods from this class:</p>
<ul>
<li><code>Push</code> inserts an element at the top of the stack</li>
<li><code>Pop</code> removes an element from the top of the stack and returns it</li>
<li><code>Peek</code> returns an element from the top of the stack without removing it</li>
</ul>
<p>You also have access to other methods, such as for removing all elements from the stack (<code>Clear</code>) or for checking whether a given element is available in the stack (<code>Contains</code>). You can get the number of elements currently in the stack using the <code>Count</code> property.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">It is worth<a id="_idIndexMarker457"/> noting that the <code>Push</code> method is either an <em class="italic">O(1)</em> operation, if the capacity does not need to increase, or <em class="italic">O(n) </em>otherwise, where <em class="italic">n</em> is the number of elements in the stack. Both <code>Pop</code> and <code>Peek</code> are <em class="italic">O(1)</em> operations.</p>
<p>As the time complexity looks very promising, it is high time to take a look at some examples showing stacks in a<a id="_idTextAnchor170"/>ction.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a stack at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1</a></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor171"/>Example – reversing a word</h2>
<p>For the<a id="_idIndexMarker458"/> first example, let’s try to reverse a word using a stack. You can do this by iterating through characters that form a string, adding each at the top of the stack, and then removing all elements from the stack. At the end, you receive the reversed word, as shown in the following diagram presenting how to reverse <code>MARCIN</code>:</p>
<div><div><img alt="Figure 5.2 – ﻿Illustration of the reversing ﻿a word example" src="img/B18069_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Illustration of the reversing a word example</p>
<p>The<a id="_idIndexMarker459"/> implementation is shown in the following code snippet:</p>
<pre class="source-code">
string text = "MARCIN";
<strong class="bold">Stack&lt;char&gt; chars = new();</strong>
foreach (char c in text) { chars.<strong class="bold">Push</strong>(c); }
while (chars.<code>Stack</code> class is created. In this scenario, the stack can contain only <code>char</code> elements. Then, you iterate through all characters using a <code>foreach</code> loop and insert each character at the top of the stack by calling the <code>Push</code> method. The remaining part of the code consists of a <code>while</code> loop, which is executed until the stack is empty. This condition is checked using the <code>Count</code> property. In each iteration, the top element is removed from the stack (by calling <code>Pop</code>) and written in the console (using the <code>Write</code> static method of the <code>Console</code> class).</p>
<p>After running the code, you will receive the following r<a id="_idTextAnchor172"/>esult:</p>
<pre class="console">
<a id="_idTextAnchor173"/>NICRAM</pre> <h2 id="_idParaDest-98"><a id="_idTextAnchor174"/>Example – Tower of Hanoi</h2>
<p>The next <a id="_idIndexMarker460"/>example<a id="_idIndexMarker461"/> is a significantly more complex application of stacks. It is related to the mathematical game <em class="italic">Tower of Hanoi</em>. The game requires three rods, onto which you can put discs. Each disc has a different size. At the beginning, all discs are placed on the first rod, forming a stack, ordered from the smallest (at the top) to the biggest (at the bottom). It is presented in<a id="_idIndexMarker462"/> the following diagram (on the left):</p>
<div><div><img alt="Figure 5.3 – ﻿Illustration of the Tower of Hanoi example" src="img/B18069_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Illustration of the Tower of Hanoi example</p>
<p>The aim <a id="_idIndexMarker463"/>of the<a id="_idIndexMarker464"/> game is to <code>FROM</code>) <code>TO</code>). However, during the whole game, you <strong class="bold">cannot place a bigger disc on a smaller one</strong>. Moreover, you <strong class="bold">can only move one disc at a time</strong>, and, of course, you <strong class="bold">can only take a disc from the top of </strong><strong class="bold">any rod</strong>.</p>
<p>How could you move discs between the rods to comply with the aforementioned rules? The problem <a id="_idIndexMarker465"/>can be divided into sub-problems:</p>
<ul>
<li><code>FROM</code> to <code>TO</code>, without using the <code>AUXILIARY</code> rod.</li>
<li><code>FROM</code> to <code>AUXILIARY</code>. Then, you move the remaining disc from <code>FROM</code> to <code>TO</code>. At the end, you move a disc from <code>AUXILIARY</code> to <code>TO</code>.</li>
<li><code>FROM</code> to <code>AUXILIARY</code>, using the mechanism described earlier. The operation involves <code>TO</code> as the auxiliary rod. Then, you move the remaining disc from <code>FROM</code> to <code>TO</code>, and then move two discs from <code>AUXILIARY</code> to <code>TO</code>, using <code>FROM</code> as the auxiliary rod.</li>
</ul>
<p>As you <a id="_idIndexMarker466"/>can see, you can solve the problem of <code>FROM</code> to <code>AUXILIARY</code>, using <code>TO</code> as the auxiliary rod. Then, you <a id="_idIndexMarker467"/>should move the remaining disc from <code>FROM</code> to <code>TO</code>. At the end, you just need to move <em class="italic">n-1</em> discs from <code>AUXILIARY</code> to the <code>TO</code> rod, using <code>FROM</code> as the auxiliary rod.</p>
<p>Now that you know the basic rules, let’s proceed to the code. First, let’s focus on the <code>Game</code> class, which contains the logic related to the game:</p>
<pre class="source-code">
public class <strong class="bold">Game</strong>
{
    public Stack&lt;int&gt; <strong class="bold">From</strong> { get; private set; }
    public Stack&lt;int&gt; <strong class="bold">To</strong> { get; private set; }
    public Stack&lt;int&gt; <strong class="bold">Auxiliary</strong> { get; private set; }
    public int <strong class="bold">DiscsCount</strong> { get; private set; }
    public int <strong class="bold">MovesCount</strong> { get; private set; }
    public event EventHandler&lt;EventArgs&gt;? <strong class="bold">MoveCompleted</strong>;
}</pre> <p>The class contains five properties, representing the following:</p>
<ul>
<li>Three rods (<code>From</code>, <code>To</code>, <code>Auxiliary</code>)</li>
<li>The overall number of discs (<code>DiscsCount</code>)</li>
<li>The number of performed moves (<code>MovesCount</code>)</li>
</ul>
<p>The <code>MoveCompleted</code> event is declared as well. It is fired after each move to inform that the user interface should be refreshed. Therefore, you can show the proper content, illustrating the current state of the rods.</p>
<p>Apart from the properties and the event, the class also has the following constructor:</p>
<pre class="source-code">
public <strong class="bold">Game</strong>(int discsCount)
{
    DiscsCount = discsCount;
    From = new Stack&lt;int&gt;();
    To = new Stack&lt;int&gt;();
    Auxiliary = new Stack&lt;int&gt;();
    <strong class="bold">for (int i = 0; i &lt; discsCount; i++)</strong>
    {
        int size = discsCount - i;
        <strong class="bold">From.Push(size);</strong>
    }
}</pre> <p>The<a id="_idIndexMarker468"/> constructor takes only one parameter, namely the <a id="_idIndexMarker469"/>number of discs (<code>discsCount</code>), and sets it as a value of the <code>DiscsCount</code> property. Then, new instances of the <code>Stack</code> class are created, and references to them are stored in the <code>From</code>, <code>To</code>, and <code>Auxiliary</code> properties. At the end, a <code>for</code> loop is used to create the necessary number of discs and to add elements to the first stack (<code>From</code>), using the <code>Push</code> method.</p>
<p>It is worth noting that <code>From</code>, <code>To</code>, and <code>Auxiliary</code> stacks only store integer values (<code>Stack&lt;int&gt;</code>). Each integer value represents the size of a particular disc. Such data is crucial due to the rules of moving discs between rods.</p>
<p>One of the most interesting and important parts of the code is the <code>MoveAsync</code> recursive method. It takes four parameters, namely the number of discs and references to three stacks. However, what happens in the <code>MoveAsync</code> method? Let’s look inside:</p>
<pre class="source-code">
public async Task <strong class="bold">MoveAsync</strong>(int discs, Stack&lt;int&gt; from,
    Stack&lt;int&gt; to, Stack&lt;int&gt; auxiliary)
{
    if (discs == 0) { return; }
    <strong class="bold">await MoveAsync(discs - 1, from, auxiliary, to);</strong>
    <strong class="bold">to.Push(from.Pop());</strong>
    MovesCount++;
    MoveCompleted?.Invoke(this, EventArgs.Empty);
    await Task.Delay(250);
    <strong class="bold">await MoveAsync(discs - 1, auxiliary, to, from);</strong>
}</pre> <p>As <code>MoveAsync</code> is <a id="_idIndexMarker470"/>called recursively, it is necessary to<a id="_idIndexMarker471"/> specify an exit condition to prevent the method from being called infinitely. In this case, the method will not call itself when the value of the <code>discs</code> parameter is equal to <code>0</code>.</p>
<p>Otherwise, the <code>MoveAsync</code> method is called, but the order of stacks is changed. Then, the element is removed from the stack represented by the second parameter (<code>from</code>), and inserted at the top of the stack represented by the third parameter (<code>to</code>).</p>
<p>In the following lines, the number of moves (<code>MovesCount</code>) is incremented and the <code>MoveCompleted</code> event is fired. It is responsible for refreshing the user interface. Then, the algorithm stops for 250 milliseconds to show the following steps of the operation in a way well visible to a user.</p>
<p>At the end, the <code>MoveAsync</code> method is called again, with another configuration of rod order. By calling this method several times, the discs will be moved from the first (<code>From</code>) rod to the second (<code>To</code>) rod. The operations performed in the <code>MoveAsync</code> method are consistent with the description of the problem of moving <em class="italic">n</em> discs between rods, as explained in the introduction to this example.</p>
<p>When the class with the logic regarding the <em class="italic">Tower of Hanoi</em> game is created, let’s see how to create a user interface that allows you to present the following moves of the algorithm. Such a task is accomplished by the <code>Visualization</code> class:</p>
<pre class="source-code">
public class <strong class="bold">Visualization</strong>
{
    private readonly Game <strong class="bold">_game</strong>;
    private readonly int <strong class="bold">_columnSize</strong>;
    private readonly char[,] <strong class="bold">_board</strong>;
    public <strong class="bold">Visualization</strong>(Game game)
    {
        _game = game;
        _columnSize = Math.Max(6,
            GetDiscWidth(_game.DiscsCount) + 2);
        _board = new char[_game.DiscsCount,
            _columnSize * 3];
    }
}</pre> <p>It<a id="_idIndexMarker472"/> contains <a id="_idIndexMarker473"/>three private fields, namely storing a reference to data of the game (<code>_game</code>), the number of characters to present a single rod (<code>_columnSize</code>), as well as a two-dimensional array with visualization of all rods, shown in the console (<code>_board</code>). The constructor takes only one parameter and sets values for all private fields.</p>
<p>Column size is calculated using the <code>GetDiscWidth</code> auxiliary method:</p>
<pre class="source-code">
private int <code>Show</code>, which is shown next:</p>
<pre class="source-code">
public void <strong class="bold">Show</strong>(Game game)
{
    Console.Clear();
    if (game.DiscsCount &lt;= 0) { return; }
    <strong class="bold">FillEmptyBoard();</strong>
    <strong class="bold">FillRodOnBoard(1, game.From);</strong>
    <strong class="bold">FillRodOnBoard(2, game.To);</strong>
    <strong class="bold">FillRodOnBoard(3, game.Auxiliary);</strong>
    Console.WriteLine(Center("FROM")
        + Center("TO") + Center("AUXILIARY"));
    <strong class="bold">DrawBoard();</strong>
    Console.WriteLine($"\nMoves: {game.MovesCount}");
    Console.WriteLine($"Discs: {game.DiscsCount}");
}</pre> <p>The <a id="_idIndexMarker474"/>method clears the current content of the console (by calling the <code>Clear</code> method). Then, it calls the <code>FillEmptyBoard</code> and <code>FillRodOnBoard</code> methods <a id="_idIndexMarker475"/>to clear content that should be shown in the console and then fill it with data of the current state of rods, one in each call of <code>FillRodOnBoard</code>. Next, you show captions for each rod, draw the board, as well as write the number of moves and discs.</p>
<p>To clear the content of the board, you just iterate through all elements in the two-dimensional array and set the value of each item to a space, as shown next:</p>
<pre class="source-code">
private void <strong class="bold">FillEmptyBoard</strong>()
{
    for (int y = 0; y &lt; _board.GetLength(0); y++)
    {
        for (int x = 0; x &lt; _board.GetLength(1); x++)
        {
            _board[y, x] = ' ';
        }
    }
}</pre> <p>If you want to learn <a id="_idIndexMarker476"/>how to fill a part of the two-dimensional array that is related to a particular rod, let’s take <a id="_idIndexMarker477"/>a look at the code of <code>FillRodOnBoard</code>:</p>
<pre class="source-code">
private void <strong class="bold">FillRodOnBoard</strong>(int column, Stack&lt;int&gt; stack)
{
    int discsCount = _game.DiscsCount;
    int margin = _columnSize * (column - 1);
    for (int y = 0; y &lt; stack.Count; y++)
    {
        int size = stack.ElementAt(y);
        int row = discsCount - (stack.Count - y);
        int columnStart = margin + discsCount - size;
        int columnEnd = columnStart + GetDiscWidth(size);
        for (int x = columnStart; x &lt;= columnEnd; x++)
        {
            _board[row, x] = '=';
        }
    }
}</pre> <p>First, the left margin is calculated to add data in the correct section within the overall array - that is, within the correct range of columns. The main part of the method is the <code>for</code> loop, where the number of iterations is equal to the number of discs located in the stack. In each iteration, the size of the current disc is read using the <code>ElementAt</code> extension method (from the <code>System.Linq</code> namespace). Next, you calculate an index of a row, where the disc should be shown, as well as start and end indices for columns. Finally, a <code>for</code> loop is used to insert the equals sign (<code>=</code>) in proper locations in the array.</p>
<p>One of the auxiliary methods is <code>Center</code>. It aims to add additional spaces before and after the text, passed as the parameter, to center the text in the column:</p>
<pre class="source-code">
private string <strong class="bold">Center</strong>(string text)
{
    int margin = (_columnSize - text.Length) / 2;
    return text.PadLeft(margin + text.Length)
        .PadRight(_columnSize);
}</pre> <p>The last <a id="_idIndexMarker478"/>used method is named <code>DrawBoard</code>. It simply iterates<a id="_idIndexMarker479"/> through all elements in the two-dimensional array and writes content in the console. The code is shown next:</p>
<pre class="source-code">
private void <strong class="bold">DrawBoard</strong>()
{
    for (int y = 0; y &lt; _board.GetLength(0); y++)
    {
        string line = string.Empty;
        for (int x = 0; x &lt; _board.GetLength(1); x++)
        {
            line += _board[y, x];
        }
        Console.WriteLine(line);
    }
}</pre> <p>In the end, let’s take a look at the main code, located in the <code>Program.cs</code> file:</p>
<pre class="source-code">
Game game = new(10);
Visualization vis = new(game);
game.MoveCompleted += (s, e) =&gt; vis.Show((Game)s!);
<strong class="bold">await game.MoveAsync(game.DiscsCount,</strong>
    <code>Game</code> class is created. The parameter indicates that <code>10</code> discs are used. In the next line, you create a new instance of the <code>Visualization</code> class responsible for<a id="_idIndexMarker480"/> showing the following steps of the game. You also specify that the <code>Show</code> method is called when the <code>MoveCompleted</code> event is fired. Finally, you call the <code>MoveAsync</code> method to start moving discs between rods.</p>
<p>You already<a id="_idIndexMarker481"/> added the necessary code to run the <em class="italic">Tower of Hanoi</em> mathematical game. Let’s launch the application and see it in action! Just after starting the program, you see that all discs are located in the first rod (<code>FROM</code>). In the next step, the smallest disc is moved from the top of the first rod (<code>FROM</code>) to the top of the third rod (<code>AUXILIARY</code>), as shown in the following screenshot:</p>
<div><div><img alt="Figure 5.4 – The second step in the Tower of Hanoi example" src="img/B18069_05_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The second step in the Tower of Hanoi example</p>
<p>While making many other moves in the program, you can see how discs are moved between all three rods. One of the intermediate steps is as follows:</p>
<div><div><img alt="Figure 5.5 – One of the intermediate steps in the Tower of Hanoi example" src="img/B18069_05_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – One of the intermediate steps in the Tower of Hanoi example</p>
<p>When the <a id="_idIndexMarker482"/>necessary moves are completed, all discs are moved <a id="_idIndexMarker483"/>from the first rod (<code>FROM</code>) to the second one (<code>TO</code>). The final result is presented next:</p>
<div><div><img alt="Figure 5.6 – Final step in the Tower of Hanoi example" src="img/B18069_05_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Final step in the Tower of Hanoi example</p>
<p>Finally, it is worth mentioning the number of moves necessary to complete the <em class="italic">Tower of Hanoi</em> game. In the case of 10 discs, the number of moves is 1,023. If you use only 3 discs, the number of moves is 7. Generally speaking, <strong class="bold">the number of moves can be calculated with the formula</strong> <strong class="bold">2</strong>n<strong class="bold">-1</strong>, where <em class="italic">n</em> is the number of discs.</p>
<p>That’s all! In this section, you learned the first limited access data structure, namely a stack. Now, it is high time that you get<a id="_idTextAnchor175"/> <a id="_idTextAnchor176"/>to know more about queues.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor177"/>Queues</h1>
<p>A <strong class="bold">queue</strong> is a<a id="_idIndexMarker484"/> data structure <a id="_idIndexMarker485"/>that allows you <strong class="bold">to add a new element only at the end of the queue</strong> (referred to as an <strong class="bold">enqueue</strong> operation) and <strong class="bold">to get an element only from the beginning of the queue</strong> (a <strong class="bold">dequeue</strong> operation). For this<a id="_idIndexMarker486"/> reason, a queue is consistent with the <strong class="bold">FIFO</strong> principle, which<a id="_idIndexMarker487"/> stands for <strong class="bold">First-In First-Out</strong>.</p>
<p class="callout-heading">Imagine a queue</p>
<p class="callout">If you want to better imagine a queue, let’s take a break from learning data structures and algorithms, wear your favorite jacket, and go to a shop in the vicinity. You buy your favorite ice cream, and you see five people waiting for checkout. Oh no... You are the last one, so you need to wait until the first, second, third, fourth, and fifth person pay. These lines in shops can be frustrating! In general, new people stand at the end of the line, and the next person is taken to the checkout from the beginning of the line. No one is allowed to choose a person from the middle and serve them in a different order. The queue data structure operates similarly. You can only add new elements at the end of the queue and remove an element from the beginning of the queue. So, people who come first (first-in) are served at the beginning (first-out).</p>
<p>The<a id="_idIndexMarker488"/> operation of a queue is presented in the following diagram:</p>
<div><div><img alt="Figure 5.7 – ﻿Illustration of a queue" src="img/B18069_05_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Illustration of a queue</p>
<p>It is worth mentioning that a <a id="_idIndexMarker489"/>queue is a <strong class="bold">recursive data structure</strong>, similar to a stack. This means that <strong class="bold">a queue can be either empty or consists of the first element and the rest of the queue, which also forms a queue</strong>. Let’s take a look at the following diagram, where the beginning of the queue is marked with a bold line:</p>
<div><div><img alt="Figure 5.8 – A queue as a recursive data structure" src="img/B18069_05_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – A queue as a recursive data structure</p>
<p>The queue data structure seems to be very easy to understand, as well as being similar to a stack, apart<a id="_idIndexMarker490"/> from the way of removing an element. Does this mean that you can also use a built-in class to use a queue in your programs? Fortunately, yes! The available generic class is <code>Queue</code> from the <code>System.Collections.Generic</code> namespace.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a queue at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1</a>.</p>
<p>The <code>Queue</code> class contains the following set of methods:</p>
<ul>
<li><code>Enqueue</code> adds an element at the end of the queue</li>
<li><code>Dequeue</code> removes an element from the beginning of the queue and returns it</li>
<li><code>Peek</code> returns an element from the beginning of the queue without removing it</li>
<li><code>Clear</code> removes all elements from the queue</li>
<li><code>Contains</code> checks whether the queue contains the given element</li>
</ul>
<p>The <code>Queue</code> class also contains the <code>Count</code> property, which returns the total number of elements located in the queue. It can be used to check whether the queue is empty.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">It is worth mentioning that the <code>Enqueue</code> method is either an <em class="italic">O(1)</em> operation, if the internal array does not need to be reallocated, or <em class="italic">O(n) </em>otherwise, where <em class="italic">n</em> is the number of elements in the queue. Both <code>Dequeue</code> and <code>Peek</code> are <em class="italic">O(1)</em> operations.</p>
<p>The <a id="_idIndexMarker491"/>great performance results are supported by a very easy application of this data structure, as shown in the following part of the code:</p>
<pre class="source-code">
List&lt;int&gt; items = [2, -4, 1, 8, 5];
<strong class="bold">Queue&lt;int&gt; queue = new();</strong>
items.ForEach(queue.<strong class="bold">Enqueue</strong>);
while (queue.<strong class="bold">Count</strong> &gt; 0)
{
    Console.WriteLine(queue.<strong class="bold">Dequeue</strong>());
}</pre> <p>Here, you create a new list and a queue containing only integer values. Then, you add all elements from the list to the queue, using the <code>Enqueue</code> method. At the end, you use a <code>while</code> loop to <a id="_idIndexMarker492"/>dequeue all the elements, using the <code>Dequeue</code> method.</p>
<p>It is worth noting that in the third line, you do not use the lambda expression and simply use the name of the method. Of course, you can use the following form instead:</p>
<pre class="source-code">
items.ForEach(<code>ConcurrentQueue</code> generic class from the <code>System.Collections.Concurrent</code> namespace. This class contains a set of built-in methods to <a id="_idIndexMarker493"/>perform various operations on the queue, such as the following:</p>
<ul>
<li><code>Enqueue</code> adds an element at the end of the queue</li>
<li><code>TryDequeue</code> tries to remove an element from the beginning and return it</li>
<li><code>TryPeek</code> tries to return an element from the beginning without removing it</li>
</ul>
<p>Both <code>TryDequeue</code> and <code>TryPeek</code> have a parameter with the <code>out</code> keyword. If the operation is successful, such methods return <code>true</code>, and the result is returned as a value of the <code>out</code> parameter. Moreover, the <code>ConcurrentQueue</code> class also contains two properties, namely <code>Count</code> to get the number of elements stored in the collection and <code>IsEmpty</code> to return a value indicating whether the queue is empty.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding the <code>ConcurrentQueue</code> class at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1</a>.</p>
<p>After this short introduction, let’s proceed to two examples representing a queue in the context of a call center, with many c<a id="_idTextAnchor178"/>l<a id="_idTextAnchor179"/>ients and one or many consultants.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor180"/>Example – call center with a single consultant</h2>
<p>This<a id="_idIndexMarker494"/> first example represents a simple approach to the call center solution, where there are <strong class="bold">many clients</strong> (with different identifiers), and <strong class="bold">only one consultant</strong>, who answers waiting calls in the same order in which they appear.</p>
<p>This scenario is shown next:</p>
<div><div><img alt="Figure 5.9 – ﻿Illustration of the call center with a single consultant example" src="img/B18069_05_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Illustration of the call center with a single consultant example</p>
<p>As you <a id="_idIndexMarker495"/>can see in the preceding diagram, four calls are performed by clients. They are added to the queue with waiting phone calls, namely from clients <code>#1234</code>, <code>#5678</code>, <code>#1468</code>, and <code>#9641</code>. When a consultant is available, they answer the phone. When the call ends, the consultant can answer the next waiting call. According to this rule, the consultant will talk with clients in the following order: <strong class="bold">#1234</strong>, <strong class="bold">#5678</strong>, <strong class="bold">#1468</strong>, and <strong class="bold">#9641</strong>.</p>
<p>Let’s take a look at the code of the first class, named <code>IncomingCall</code>, which represents a single incoming call performed by a client. Its code is as follows:</p>
<pre class="source-code">
public class <strong class="bold">IncomingCall</strong>
{
    public int Id { get; set; }
    public int ClientId { get; set; }
    public DateTime CallTime { get; set; }
    public DateTime? AnswerTime { get; set; }
    public DateTime? EndTime { get; set; }
    public string? Consultant { get; set; }
}</pre> <p>The class contains six properties representing a unique identifier of a call (<code>Id</code>), a client identifier (<code>ClientId</code>), the date and time when the call was started (<code>CallTime</code>), when it was answered (<code>AnswerTime</code>), and when it was ended (<code>EndTime</code>), as well as the name of the consultant (<code>Consultant</code>).</p>
<p>The <a id="_idIndexMarker496"/>most important part of the code is related to the <code>CallCenter</code> class, which represents call-related operations. Its fragment is as follows:</p>
<pre class="source-code">
public class <strong class="bold">CallCenter</strong>
{
    private int _counter = 0;
    <strong class="bold">public Queue&lt;IncomingCall&gt; Calls { get; private set; }</strong>
    public CallCenter() =&gt;
        Calls = <strong class="bold">new Queue&lt;IncomingCall&gt;();</strong>
}</pre> <p>The <code>CallCenter</code> class contains the <code>_counter</code> field with an identifier of the last call, which is equal to the number of calls so far. The class also has the <code>Calls</code> property representing a queue (with <code>IncomingCall</code> instances), where data of waiting calls is stored. In the constructor, a new instance of the <code>Queue</code> generic class is created, and its reference is assigned to the <code>Calls</code> property.</p>
<p>Of course, the class contains some methods, such as <code>Call</code> with the following code:</p>
<pre class="source-code">
public IncomingCall <strong class="bold">Call</strong>(int clientId)
{
    IncomingCall call = new()
    {
        Id = ++_counter,
        ClientId = clientId,
        CallTime = DateTime.Now
    };
    Calls.<strong class="bold">Enqueue</strong>(call);
    return call;
}</pre> <p>Here, you<a id="_idIndexMarker497"/> create a new instance of the <code>IncomingCall</code> class and set values of its properties, namely its identifier (together with pre-incrementing the <code>_counter</code> field), the client identifier (using the <code>clientId</code> parameter), and the call time. The created instance is added to the queue by calling the <code>Enqueue</code> method and returned.</p>
<p>The next method is <code>Answer</code>. It represents the operation of answering the call from the person waiting in the queue for the longest time. Such a call is represented by the element located at the beginning of the queue. The <code>Answer</code> method is shown next:</p>
<pre class="source-code">
public IncomingCall? <strong class="bold">Answer</strong>(string consultant)
{
    if (!AreWaitingCalls()) { return null; }
    IncomingCall call = Calls.<strong class="bold">Dequeue</strong>();
    call.Consultant = consultant;
    call.AnswerTime = DateTime.Now;
    return call;
}</pre> <p>Within this method, you check whether the queue is empty. If so, the method returns <code>null</code>, which means that there are no phone calls that can be answered by the consultant. Otherwise, the call is removed from the queue (using the <code>Dequeue</code> method), and its properties are updated by setting the consultant’s name (using the <code>consultant</code> parameter) and answer time (to the current date and time). At the end, the data of the call is returned.</p>
<p>Apart from the <code>Call</code> and <code>Answer</code> methods, you also implement the <code>End</code> method, which is called whenever the consultant ends a call with a particular client. In such a case, you only set the end time, as shown in the following piece of code:</p>
<pre class="source-code">
public void <strong class="bold">End</strong>(IncomingCall call)
    =&gt; call.EndTime = DateTime.Now;</pre> <p>The<a id="_idIndexMarker498"/> last method in the <code>CallCenter</code> class is named <code>AreWaitingCalls</code>. It returns a value indicating whether there are any waiting calls in the queue, using the <code>Count</code> property of the <code>Queue</code> class. Its code is as follows:</p>
<pre class="source-code">
public bool <code>Program.cs</code> file and its code:</p>
<pre class="source-code">
Random random = new();
<strong class="bold">CallCenter center = new();</strong>
center.<strong class="bold">Call</strong>(1234);
center.<strong class="bold">Call</strong>(5678);
center.<strong class="bold">Call</strong>(1468);
center.<strong class="bold">Call</strong>(9641);
while (center.<strong class="bold">AreWaitingCalls</strong>())
{
    IncomingCall call = center.<strong class="bold">Answer</strong>("Marcin")!;
    Log($"Call #{call.Id} from client #{call.ClientId}
        answered by {call.Consultant}.");
    await Task.Delay(random.Next(1000, 10000));
    center.<strong class="bold">End</strong>(call);
    Log($"Call #{call.Id} from client #{call.ClientId}
        ended by {call.Consultant}.");
}</pre> <p>You <a id="_idIndexMarker499"/>create a new instance of the <code>Random</code> class (for getting random numbers), as well as an instance of the <code>CallCenter</code> class. Then, you simulate making a few calls by clients, namely with the following identifiers: <code>1234</code>, <code>5678</code>, <code>1468</code>, and <code>9641</code>. The most interesting part of the code is located in the <code>while</code> loop, which is executed until there are no waiting calls in the queue. Within the loop, the consultant answers the call (using the <code>Answer</code> method) and a log is generated (using the <code>Log</code> auxiliary method). Then, you wait for a random number of milliseconds (between <code>1000</code> and <code>10000</code>) to simulate the various lengths of a call. When this has elapsed, the call ends (by calling the <code>End</code> method), and a proper log is generated.</p>
<p>The last part of the code necessary for this example is the <code>Log</code> method:</p>
<pre class="source-code">
void <strong class="bold">Log</strong>(string text) =&gt;
    Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");</pre> <p>When you run the example, you will receive a result similar to the following:</p>
<pre class="console">
[13:10:53] Call #1 from client #1234 answered by Marcin.
[13:10:56] Call #1 from client #1234 ended by Marcin.
[13:10:56] Call #2 from client #5678 answered by Marcin.
[13:10:59] Call #2 from client #5678 ended by Marcin.
[13:10:59] Call #3 from client #1468 answered by Marcin.
[13:11:06] Call #3 from client #1468 ended by Marcin.
[13:11:06] Call #4 from client #9641 answered by Marcin.
[13:11:09] Call #4 from client #9641 ended by Marcin.</pre> <p>Congratulations! You just completed the first example regarding a queue data structure. If you want to learn more about the thread-safe version of the queue-related c<a id="_idTextAnchor181"/>l<a id="_idTextAnchor182"/>ass, let’s proceed to the next example.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor183"/>Example – call center with many consultants</h2>
<p>The example <a id="_idIndexMarker500"/>shown in the preceding section was intentionally simplified to make understanding a queue much simpler. However, it is high time you make it more related to real-world problems. In this section, you will see how to expand it to support many consultants, as shown in the following diagram:</p>
<div><div><img alt="Figure 5.10 – ﻿Illustration of the call center with many consultants example" src="img/B18069_05_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Illustration of the call center with many consultants example</p>
<p>What is important is that both clients and consultants operate at the same time. If there are more incoming calls than available consultants, a new call will be added to the queue and will wait until there is a consultant who can answer the call. If there are too many consultants and few calls, the consultants will wait for a call. To perform this task, you create a few threads, which access the queue. Therefore, you use a thread-safe version of the queue, namely the <code>ConcurrentQueue</code> class.</p>
<p>Let’s take a <a id="_idIndexMarker501"/>look at the code! First, you need to declare an <code>IncomingCall</code> class, the code of which is exactly the same as in the previous example. Various modifications are necessary in the <code>CallCenter</code> class, as presented next:</p>
<pre class="source-code">
using System.Collections.Concurrent;
public class <strong class="bold">CallCenter</strong>
{
    private int _counter = 0;
    <strong class="bold">public ConcurrentQueue&lt;IncomingCall&gt; Calls</strong>
        <strong class="bold">{ get; private set; }</strong>
    public CallCenter() =&gt; Calls =
        <strong class="bold">new ConcurrentQueue&lt;IncomingCall&gt;();</strong>
}</pre> <p>As the <code>Enqueue</code> method is available in both the <code>Queue</code> and <code>ConcurrentQueue</code> classes, no changes are necessary in the <code>Call</code> method.</p>
<p>However, the <code>Dequeue</code> method does not exist in <code>ConcurrentQueue</code>. For this reason, you need to modify the <code>Answer</code> method to use the <code>TryDequeue</code> method. It returns a value indicating whether the element is removed from the queue. The removed element is returned using the <code>out</code> parameter, as shown next:</p>
<pre class="source-code">
public IncomingCall? Answer(string consultant)
{
    <strong class="bold">if (!Calls.IsEmpty</strong>
        <strong class="bold">&amp;&amp; Calls.TryDequeue(out IncomingCall? call))</strong>
    {
        call.Consultant = consultant;
        call.AnswerTime = DateTime.Now;
        return call;
    }
    return null;
}</pre> <p>You<a id="_idIndexMarker502"/> can also slightly modify the <code>AreWaitingCalls</code> method to use the <code>IsEmpty</code> property instead of <code>Count</code>, presented as follows:</p>
<pre class="source-code">
public bool AreWaitingCalls() =&gt; <code>CallCenter</code> class. However, more changes are required in the code located in <code>Program.cs</code>, as shown next:</p>
<pre class="source-code">
Random random = new();
<strong class="bold">CallCenter center = new();</strong>
Parallel.Invoke(
  () =&gt; <strong class="bold">Clients</strong>(center),
  () =&gt; <strong class="bold">Consultant</strong>(center, "Marcin", ConsoleColor.Red),
  () =&gt; <strong class="bold">Consultant</strong>(center, "James", ConsoleColor.Yellow),
  () =&gt; <code>CallCenter</code> instance, you start execution of four actions, namely representing clients and three consultants, using the <code>Invoke</code> static method of the <code>Parallel</code> class from the <code>System.Threading.Tasks</code> namespace. The lambda expressions are used to specify methods that are called, namely <code>Clients</code> for client-related operations and <code>Consultant</code> for consultant-related tasks. You also specify additional parameters, such as a name and a color for a given consultant.</p>
<p>The <code>Clients</code> method represents operations performed cyclically by many clients. Its code is shown in the following block:</p>
<pre class="source-code">
void <strong class="bold">Clients</strong>(CallCenter center)
{
    while (true)
    {
        int clientId = random.Next(1, 10000);
        IncomingCall call = center.<strong class="bold">Call</strong>(clientId);
        Log($"Incoming call #{call.Id}
            from client #{clientId}");
        Log($"Waiting calls in the queue:
            {<strong class="bold">center.Calls.Count</strong>}");
        Thread.Sleep(random.Next(500, 2000));
    }
}</pre> <p>Within<a id="_idIndexMarker503"/> the <code>while</code> loop, you get a random number as an identifier of a client (<code>clientId</code>), and the <code>Call</code> method is called. The client identifier is logged, together with the number of waiting calls. At the end, the client-related thread is suspended for a random number of milliseconds in the range between 500 ms and 2,000 ms, to simulate the delay between another call made by the next client.</p>
<p>The following method is named <code>Consultant</code> and is executed on a separate thread for each consultant. The method takes three parameters, namely an instance of <code>CallCenter</code>, as well as a name and color for the consultant. The code is as follows:</p>
<pre class="source-code">
void <strong class="bold">Consultant</strong>(CallCenter center, string name,
    ConsoleColor color)
{
    while (true)
    {
        Thread.Sleep(random.Next(500, 1000));
        IncomingCall? call = center.<strong class="bold">Answer</strong>(name);
        if (call == null) { continue; }
        Log($"Call #{call.Id} from client #{call.ClientId}
            answered by {call.Consultant}.", color);
        Thread.Sleep(random.Next(1000, 10000));
        center.<strong class="bold">End</strong>(call);
        Log($"Call #{call.Id} from client #{call.ClientId}
            ended by {call.Consultant}.", color);
    }
}</pre> <p>Within <a id="_idIndexMarker504"/>the <code>while</code> loop, the consultant waits for a random period, between 0.5 and 1 second. Then, they try to answer the first waiting call, using the <code>Answer</code> method. If there are no waiting calls, you skip to the next iteration. Otherwise, the log is presented in a color of the current consultant. Then, the thread is suspended for a random period of time between 1 and 10 seconds. After this time, the consultant ends the call, which is indicated by calling the <code>End</code> method, and a log is generated.</p>
<p>The last method is named <code>Log</code> and is similar to the previous example:</p>
<pre class="source-code">
void <strong class="bold">Log</strong>(string text,
    ConsoleColor color = ConsoleColor.Gray)
{
    Console.ForegroundColor = color;
    Console.WriteLine(
        $"[{DateTime.Now:HH:mm:ss.fff}] {text}");
    Console.ResetColor();
}</pre> <p>When you run the program and wait for some time, you will receive a result similar to the one shown in the following screenshot:</p>
<div><div><img alt="Figure 5.11 – ﻿Screenshot of the call center with many consultants example" src="img/B18069_05_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Screenshot of the call center with many consultants example</p>
<p>You just<a id="_idIndexMarker505"/> completed two examples representing the application of a queue in the case of a call center scenario. Are you already a queue master?</p>
<p class="callout-heading">Try to modify parameters on your own</p>
<p class="callout">It is a good idea to modify various parameters of the program, such as the number of consultants, as well as delay times, especially the delay between following calls performed by clients. Then, you will see how the algorithm works in the case when there are too many clients, as well as too many or too few consultants.</p>
<p>However, how<a id="_idIndexMarker506"/> can you handle clients with priority support? In the current solution, they wait in the same queue as clients with the standard support plan. Do you need to create two queues and first take clients from the prioritized queue? If so, what should happen if you introduce another support plan? Do you need to add another queue and introduce such modifications in the code? Fortunately, no! You can use another data structure, namely a priority queue, as <a id="_idTextAnchor184"/>e<a id="_idTextAnchor185"/>xplained in detail in the following section.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor186"/>Priority queues</h1>
<p>A <code>0</code>, while lower priority is specified by <code>1</code>, <code>2</code>, <code>3</code>, and so on.</p>
<p class="callout-heading">Imagine a priority queue</p>
<p class="callout">If you want to better visualize a priority queue, close your eyes for a moment and imagine yourself going on the greatest vacation of your life. All passengers are already lining up at the gate, including you, but it turns out that right next to it, there is a much shorter queue for people who have a gold airline card. There are only 3 people in that line, and in yours there are over 100. These 3 people will be served first, and only then will the service of your queue begin. Well, that’s how a priority queue works! You first serve all the highest priority items in the order they were added to the priority queue. Then, you return all lower priority items, also in the order they were added to the priority queue. Then, you take all items with an even lower priority, and so on, until all priorities are properly handled. And now the dream about holidays is over, it’s time to get back to further learning data structures and algorithms!</p>
<p>A diagram of a priority queue is presented next:</p>
<div><div><img alt="Figure 5.12 – ﻿Illustration of a priority queue" src="img/B18069_05_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Illustration of a priority queue</p>
<p>Let’s analyze<a id="_idIndexMarker509"/> the diagram. First, the priority queue contains two <a id="_idIndexMarker510"/>elements with the same priority (equal to <code>1</code>), namely <code>Marcin</code> (first) and <code>Lily</code> (second). Then, <code>Mary</code> is added with the lowest priority (<code>2</code>), which means that this element is placed at the end of the queue. In the next step, <code>John</code> is added with the highest priority (<code>0</code>), so it is added at the beginning of the priority queue. The third column presents the addition of <code>Emily</code> with a priority equal to <code>1</code> -  the same as <code>Marcin</code> and <code>Lily</code>. As <code>Emily</code> is added last, it is added after <code>Lily</code>. According to the aforementioned rules, you add the following elements - namely, <code>Sarah</code> with a priority set to <code>2</code> and <code>Luke</code> with a priority equal to <code>1</code>. The final order is shown on the right-hand side of the preceding diagram.</p>
<p>Of course, it is possible to implement a priority queue <code>PriorityQueue</code> from the <code>System.Collections.Generic</code> namespace. The mentioned class requires you to specify two types, namely for the stored data and for the priority. The class contains some useful methods, such as the following:</p>
<ul>
<li><code>Enqueue</code> adds an element to the priority queue</li>
<li><code>Dequeue</code> removes an element from the beginning and returns it</li>
<li><code>Clear</code> removes all elements from the priority queue</li>
<li><code>Peek</code> returns an element from the beginning of the queue without removing it</li>
</ul>
<p>You can also get<a id="_idIndexMarker512"/> the number of elements in the queue using the <code>Count</code> property. The class contains a set of other methods as well - for example, <code>TryDequeue</code> and <code>TryPeek</code>.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a priority queue at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2</a>.</p>
<p>To make your horizons <a id="_idIndexMarker513"/>even broader, you will learn how to use <code>OptimizedPriorityQueue</code>. More information about this package is available at <a href="https://www.nuget.org/packages/OptimizedPriorityQueue">https://www.nuget.org/packages/OptimizedPriorityQueue</a>.</p>
<p class="callout-heading">How to install a NuGet package?</p>
<p class="callout">Do you know <a id="_idIndexMarker515"/>how you can add a NuGet package to your project? If not, select <strong class="bold">Manage NuGet Packages</strong> from the context menu of the project node in the <strong class="bold">Solution Explorer</strong> window. Then, choose the <strong class="bold">Browse</strong> tab in the opened window and type the name of the package in the <strong class="bold">Search</strong> box. Click on the name of the package and press <strong class="bold">Install</strong>. Confirm this operation and wait until the installation is ready.</p>
<p class="callout">While the package is being installed, do you know that you can also be an author of a NuGet package that can be later used by developers from various regions of the world? If you create something great, please let me know! In the meantime, please keep in mind that you always should comply with the license terms of particular packages, and you should not fully trust all available packages, especially those with a smaller number of downloads. However, NuGet packages are a nice feature that can significantly simplify and speed up your work.</p>
<p>The <code>OptimizedPriorityQueue</code> library simplifies<a id="_idIndexMarker516"/> the application of a priority queue. Within it, the <code>SimplePriorityQueue</code> generic class is available, which contains some useful methods, such as the following:</p>
<ul>
<li><code>Enqueue</code> adds an element to the priority queue</li>
<li><code>Dequeue</code> removes an element from the beginning of the queue and returns it</li>
<li><code>GetPriority</code> returns the priority of the element</li>
<li><code>UpdatePriority</code> updates the priority of the element</li>
<li><code>Contains</code> checks whether the element exists in the priority queue</li>
<li><code>Clear</code> removes all elements from the priority queue</li>
</ul>
<p>You can get the <a id="_idIndexMarker517"/>number of elements currently available in the priority queue<a id="_idIndexMarker518"/> using the <code>Count</code> property. If you want to get an element from the beginning of the priority queue without removing it, you can use the <code>First</code> property. Moreover, the class contains a set of other methods, such as <code>TryDequeue</code> and <code>TryRemove</code>. As you can see, the names of some members of the class are even the same, as in the case of the <code>PriorityQueue</code> built-in class. Thus, you can easily change one implementation to another and check the impact of the implementation on the results or the performance of your solution.</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">Both <code>Enqueue</code> and <code>Dequeue</code> methods are <em class="italic">O(log </em><em class="italic">n)</em> operations.</p>
<p>If you want to see in action the priority queue depicted in the preceding diagram, you can use the following part of the code:</p>
<pre class="source-code">
using Priority_Queue;
<strong class="bold">SimplePriorityQueue&lt;string&gt; queue = new();</strong>
queue.<strong class="bold">Enqueue</strong>("Marcin", <strong class="bold">1</strong>);
queue.<strong class="bold">Enqueue</strong>("Lily", <strong class="bold">1</strong>);
queue.<strong class="bold">Enqueue</strong>("Mary", <strong class="bold">2</strong>);
queue.<strong class="bold">Enqueue</strong>("John", <strong class="bold">0</strong>);
queue.<strong class="bold">Enqueue</strong>("Emily", <strong class="bold">1</strong>);
queue.<strong class="bold">Enqueue</strong>("Sarah", <strong class="bold">2</strong>);
queue.<strong class="bold">Enqueue</strong>("Luke", <strong class="bold">1</strong>);
while (queue.<strong class="bold">Count</strong> &gt; 0)
{
    Console.WriteLine(queue.<strong class="bold">Dequeue</strong>());
}</pre> <p>At the beginning, you <a id="_idIndexMarker519"/>create a new priority queue containing only <code>string</code> values. Then, you <a id="_idIndexMarker520"/>add all elements in the correct order, together with specifying their priority, using the <code>Enqueue</code> method. At the end, you use a <code>while</code> loop to dequeue all the elements, using the <code>Dequeue</code> method. Pretty simple and easy to understand, isn’t it?</p>
<p>When you run the code, you will get the following result:</p>
<pre class="console">
John
Marcin
Lily
Emily
Luke
Mary
Sarah</pre> <p>After this short introduction to the topic of priority queues, let’s proceed to the example of a c<a id="_idTextAnchor187"/>a<a id="_idTextAnchor188"/>ll center with priority support, which is described next.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor189"/>Example – call center with priority support</h2>
<p>As an<a id="_idIndexMarker521"/> example of a priority queue, let’s present a simple approach to the call center solution, where there are many clients (with different identifiers), and only one consultant who answers waiting calls, first from clients with the priority support plan, and then from clients with the standard support plan.</p>
<p>This scenario is presented in the following diagram. Calls with standard priority are marked with <code>–</code>, while calls with priority support are indicated by <code>∆</code>, as follows:</p>
<div><div><img alt="Figure 5.13 – ﻿Illustration of the call center with priority support example" src="img/B18069_05_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Illustration of the call center with priority support example</p>
<p>The <a id="_idIndexMarker522"/>priority queue contains only three elements, which will be served in the following order: <code>#5678</code> (the priority support), <code>#1234</code>, and <code>#1468</code>. However, the call from the client with the <code>#9641</code> identifier causes the order to change to <code>#5678</code>, <code>#9641</code> (due to priority support), <code>#1234</code>, and <code>#1468</code>.</p>
<p>It is high time to write some code! Let’s proceed to the implementation of the <code>IncomingCall</code> class:</p>
<pre class="source-code">
public class <strong class="bold">IncomingCall</strong>
{
    public int Id { get; set; }
    public int ClientId { get; set; }
    public DateTime CallTime { get; set; }
    public DateTime? AnswerTime { get; set; }
    public DateTime? EndTime { get; set; }
    public string? Consultant { get; set; }
    <strong class="bold">public bool IsPriority { get; set; }</strong>
}</pre> <p>Here, there is only one change in comparison to the previously presented scenario of the simple call center application - namely, the <code>IsPriority</code> property is added. It indicates whether the current call has priority (<code>true</code>) or standard support (<code>false</code>).</p>
<p>Some <a id="_idIndexMarker523"/>modifications are also necessary for the <code>CallCenter</code> class, where a type of the <code>Calls</code> property is changed to <code>SimplePriorityQueue&lt;IncomingCall&gt;</code>, as shown next:</p>
<pre class="source-code">
public class <strong class="bold">CallCenter</strong>
{
    private int _counter = 0;
    <strong class="bold">public SimplePriorityQueue&lt;IncomingCall&gt; Calls</strong>
        <strong class="bold">{ get; private set; }</strong>
    public CallCenter() =&gt; Calls =
        <strong class="bold">new SimplePriorityQueue&lt;IncomingCall&gt;();</strong>
}</pre> <p>The following changes are necessary for the <code>Call</code> method:</p>
<pre class="source-code">
public IncomingCall <strong class="bold">Call</strong>(int clientId, <strong class="bold">bool isPriority</strong>)
{
    IncomingCall call = new()
    {
        Id = ++_counter,
        ClientId = clientId,
        CallTime = DateTime.Now,
        <strong class="bold">IsPriority = isPriority</strong>
    };
    <strong class="bold">Calls.Enqueue(call, isPriority ? 0 : 1);</strong>
    return call;
}</pre> <p>Here, a<a id="_idIndexMarker524"/> value of the <code>IsPriority</code> property is set using the parameter. Moreover, while calling the <code>Enqueue</code> method, two parameters are used, not only the value of the element (an instance of the <code>IncomingCall</code> class), but also an integer value representing the priority, namely <code>0</code> in the case of priority support, or <code>1</code> otherwise.</p>
<p>No more changes are necessary in the methods of the <code>CallCenter</code> class, namely in <code>Answer</code>, <code>End</code>, and <code>AreWaitingCalls</code>, which are shown next for your convenience:</p>
<pre class="source-code">
public IncomingCall? <strong class="bold">Answer</strong>(string consultant)
{
    if (!AreWaitingCalls()) { return null; }
    IncomingCall call = Calls.Dequeue();
    call.Consultant = consultant;
    call.AnswerTime = DateTime.Now;
    return call;
}
public void <strong class="bold">End</strong>(IncomingCall call) =&gt;
    call.EndTime = DateTime.Now;
public bool <code>Program.cs</code> file:</p>
<pre class="source-code">
Random random = new();
<strong class="bold">CallCenter center = new();</strong>
center.<strong class="bold">Call</strong>(1234, <strong class="bold">false</strong>);
center.<strong class="bold">Call</strong>(5678, <strong class="bold">true</strong>);
center.<strong class="bold">Call</strong>(1468, <strong class="bold">false</strong>);
center.<strong class="bold">Call</strong>(9641, <strong class="bold">true</strong>);
while (center.<strong class="bold">AreWaitingCalls</strong>())
{
    IncomingCall call = center.<strong class="bold">Answer</strong>("Marcin")!;
    Log($"Call #{call.Id} from client #{call.ClientId} is
        answered by {call.Consultant}.", <strong class="bold">call.IsPriority</strong>);
    await Task.Delay(random.Next(1000, 10000));
    center.<strong class="bold">End</strong>(call);
    Log($"Call #{call.Id} from client #{call.ClientId} is
        ended by {call.Consultant}.", <strong class="bold">call.IsPriority</strong>);
}
void <strong class="bold">Log</strong>(string text, bool isPriority)
{
    Console.ForegroundColor = isPriority
        ? ConsoleColor.Red : ConsoleColor.Gray;
    Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");
    Console.ResetColor();
}</pre> <p>You may be surprised to learn that only small changes are necessary in this part of the code. The reason for this is that the logic regarding a used data structure is hidden in the <code>CallCenter</code> class. Within the <code>Program.cs</code> file, you call methods and use properties exposed by the <code>CallCenter</code> class. You just need to modify how you add calls to the queue (together with priorities), as well as adjust logs presented when a call is answered by the<a id="_idIndexMarker525"/> consultant, to choose a proper color based on the call’s priority. That’s all!</p>
<p>When you run the application, you will receive a result similar to the following:</p>
<div><div><img alt="Figure 5.14 – ﻿Screenshot of the call center with priority support example" src="img/B18069_05_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Screenshot of the call center with priority support example</p>
<p>As you can see, the calls are served in the correct order. This means that the calls from clients with priority support are served earlier than calls from clients with the standard support plan, even though such calls need to wait much longer to be answered.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor190"/>Circular queues</h1>
<p>At the end <a id="_idIndexMarker526"/>of this chapter, let’s take a look at another data structure, namely a <strong class="bold">circular queue</strong>, also<a id="_idIndexMarker527"/> called a <strong class="bold">ring buffer</strong>. In this case, <strong class="bold">a queue forms a circle</strong>, internally uses <a id="_idIndexMarker528"/>an array, and the maximum number of elements that can be placed inside the queue is limited. You need to specify two variables that indicate indices of the <strong class="bold">front</strong> and <strong class="bold">rear</strong> elements. <strong class="bold">The front one points to the element that will be dequeued first. The rear one points to the element that is the last in </strong><strong class="bold">the queue</strong>.</p>
<p class="callout-heading">Imagine a circular queue</p>
<p class="callout">If you want to better imagine a circular queue, think back to your young years when you persuaded your parents to take you on a roller coaster. It consisted of 10 carriages, each with room for 2 people, so only 20 people could take part in 1 roller coaster ride. As this was a unique attraction, such a ride took place only once an hour. This meant that only 20 people were allowed to enter a queue for the roller coaster and no one else. As the departure date approached, people were admitted to it in the order in which they were admitted to the queue. And a circular queue works similarly! It has some specific capacity, and nothing else can be enqueued to it. However, when you dequeue elements, new ones can be added in place of the previous ones. Well, it means that after an hour, you can fill a queue for the roller coaster with new people!</p>
<p>The <a id="_idIndexMarker529"/>mentioned data structure<a id="_idIndexMarker530"/> is presented in the following diagram:</p>
<div><div><img alt="Figure 5.15 – ﻿Illustration of a circular queue" src="img/B18069_05_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Illustration of a circular queue</p>
<p>At the<a id="_idIndexMarker531"/> beginning, the<a id="_idIndexMarker532"/> circular queue is empty, so both <code>-1</code>. Then, you add <code>2</code>, <code>-4</code>, <code>1</code>, and <code>8</code> elements, and this state is shown in the first step in the preceding diagram. Here, the front index is equal to <code>0</code>, and the rear one to <code>3</code>.</p>
<p>In the next step, you perform an <code>5</code> is located at index <code>4</code>, as shown in the third step in the preceding diagram. Of course, the rear index is updated to <code>4</code> while the front index remains the same, namely <code>0</code>.</p>
<p>The following<a id="_idIndexMarker533"/> step shows a <code>2</code> is returned, and the front index is changed to <code>1</code>. It means that <a id="_idIndexMarker534"/>currently, the circular queue stores <code>4</code> elements in the part of the array between <code>1</code> (the front index) and <code>4</code> (the rear index).</p>
<p class="callout-heading">What about the performance?</p>
<p class="callout">The <a id="_idIndexMarker535"/>performance results are great in this case! Both the <code>Enqueue</code> and the <code>Dequeue</code> methods are <em class="italic">O(1)</em> operations, as you don’t need to iterate through an array.</p>
<p>You can perform many more <em class="italic">enqueue</em> and <em class="italic">dequeue</em> operations to see how the content of the queue “rotates” within a circular queue. To do so, you need to implement this data structure. Let’s write some code, starting with the <code>CircularQueue</code> class:</p>
<pre class="source-code">
public class <strong class="bold">CircularQueue</strong>&lt;T&gt;(int size)
    where T : struct
{
    private readonly T[] <strong class="bold">_items</strong> = new T[size];
    private int <strong class="bold">_front</strong> = -1;
    private int <strong class="bold">_rear</strong> = -1;
    private int <strong class="bold">_count</strong> = 0;
    public int <strong class="bold">Count</strong> { get { return _count; } }
}</pre> <p>It is a generic class that uses the primary constructor taking the maximum number of elements in the queue as the <code>size</code> parameter. You can see four private fields:</p>
<ul>
<li>An array with the stored items (<code>_items</code>)</li>
<li>An index of the front and rear elements in the queue (<code>_front</code> and <code>_rear</code>)</li>
<li>The current number of elements located in the circular queue (<code>_count</code>)</li>
</ul>
<p>The public<a id="_idIndexMarker536"/> read-only <code>Count</code> property is added as well, which<a id="_idIndexMarker537"/> returns the value of the <code>_count</code> field. If everything is clear for you, let’s take a look at the <code>Enqueue</code> method:</p>
<pre class="source-code">
public bool <strong class="bold">Enqueue</strong>(T item)
{
    if (_count == _items.Length) { return false; }
    if (_front &lt; 0) { _front = _rear = 0; }
    else { _rear = ++_rear % _items.Length; }
    _items[_rear] = item;
    _count++;
    return true;
}</pre> <p>In the beginning, you need to check whether you have any space within the circular queue, so you compare the current number of elements in the queue (<code>_count</code>) with the length of the array storing such data (<code>_items</code>). If these values are equal, you return <code>false</code> because there is no space, so you cannot enqueue any element.</p>
<p>The next line checks whether the circular queue is empty, which means that the front index is smaller than <code>0</code>. If so, both front and rear indices are set to <code>0</code>. It indicates that there is only one element in the circular queue, and it is pointed to by both these indices.</p>
<p>If there is already something in the queue, you increment a value of the rear index. If it is equal to the number of elements in the array, you assign <code>0</code> to it.</p>
<p>In the last three lines, you add the new item to the place indicated by the rear index (<code>_rear</code>), increment the counter storing the number of elements currently located in the queue (<code>_count</code>), as well as return <code>true</code> indicating that the enqueue operation was successful.</p>
<p>Let’s now<a id="_idIndexMarker538"/> move to the <code>Dequeue</code> method, the code of which is shown next:</p>
<pre class="source-code">
public T? <strong class="bold">Dequeue</strong>()
{
    if (_count == 0) { return null; }
    T result = _items[_front];
    if (_front == _rear) { _front = _rear = -1; }
    else { _front = ++_front % _items.Length; }
    _count--;
    return result;
}</pre> <p>Here, you check whether the circular queue is empty. If so, you return a <code>null</code> value. Otherwise, you save as <code>result</code> a value indicated by the front index. Such a value will be returned at the end of this method.</p>
<p>In the following lines, you check whether the front and rear indices are equal. It means that there is only one element in the queue. If so, you set both these indices to <code>-1</code>, which indicates that the circular queue is empty. Otherwise, you increment the front index. If it is equal to the number of elements in the array, you assign <code>0</code> to it.</p>
<p>In the last two lines, you just decrement the number of elements in the queue, as well as return the previously saved value (<code>result</code>).</p>
<p>Another method is named <code>Peek</code> and is presented as follows:</p>
<pre class="source-code">
public T? <strong class="bold">Peek</strong>()
{
    if (_count == 0) { return null; }
    return _items[_front];
}</pre> <p>This <a id="_idIndexMarker539"/>method just returns the first item in the queue without<a id="_idIndexMarker540"/> removing it from the queue. Of course, it returns <code>null</code> if the queue is empty.</p>
<p>As you can see, the implementation of a circular queue is not difficult and requires a small number of lines of code. So, let’s see it in action with the following code:</p>
<pre class="source-code">
<strong class="bold">CircularQueue&lt;int&gt; queue = new(8);</strong>
queue.<strong class="bold">Enqueue</strong>(2);
queue.<strong class="bold">Enqueue</strong>(-4);
queue.<strong class="bold">Enqueue</strong>(1);
queue.<strong class="bold">Enqueue</strong>(8);
queue.<strong class="bold">Enqueue</strong>(5);
int item = queue.<strong class="bold">Dequeue</strong>();
Console.WriteLine(item);</pre> <p>The preceding lines perform the operations shown in the diagram presenting a circular queue (<em class="italic">Figure 5</em><em class="italic">.15</em>). You create a new circular queue with places for eight elements of the <code>int</code> type. Then, you add <code>2</code>, <code>-4</code>, <code>1</code>, <code>8</code>, and <code>5</code> values and dequeue one element.</p>
<p>After the introduction to the topic of circular queues, it is high time to take a look at a real-world example.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor191"/>Example – gravity roller coaster</h2>
<p>Let’s <a id="_idIndexMarker541"/>simulate the behavior of a gravity roller coaster located on a mountainside. There can be a maximum of 12 carts on this queue at the same time, which slide down the chute accelerated by gravity. After the participant enters the cart, it accelerates automatically, and there are several turns on its path. After reaching the foot of the mountain, the cart and the participant are pulled in using a simple pulley. The participant gets off at the same place where they boarded the cart, as shown next:</p>
<div><div><img alt="Figure 5.16 – ﻿Illustration of a gravity roller coaster example" src="img/B18069_05_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Illustration of a gravity roller coaster example</p>
<p>You can<a id="_idIndexMarker542"/> simulate this example using a circular queue with the maximum size set to 12, which means that a maximum of 12 people can currently be on this gravity roller coaster. Another person will not be admitted until a seat becomes available. Entering the cart means performing an <em class="italic">enqueue</em> operation, and leaving the cart means performing a <em class="italic">dequeue</em> operation. It is also worth mentioning that it is not possible to change the order in which participants are served. Whoever enters the queue first will be let out first, which is consistent with the FIFO principle.</p>
<p>Let’s take a look at the code, which is located in the <code>Program.cs</code> file:</p>
<pre class="source-code">
using <strong class="bold">QueueItem</strong> = (System.DateTime StartedAt,
    System.ConsoleColor Color);
const int rideSeconds = 10;
Random random = new();
CircularQueue&lt;QueueItem&gt; queue = new(12);
ConsoleColor color = ConsoleColor.Black;</pre> <p>Here, you specify a <code>QueueItem</code> alias for the value tuple type consisting of cart entering time and the chosen color. Then, the ride length is set to 10 seconds, as well as some additional variables being created, including the circular queue and the last used color.</p>
<p>The next<a id="_idIndexMarker543"/> part of the code is shown here:</p>
<pre class="source-code">
while (true)
{
    <strong class="bold">while (queue.Peek() != null)</strong>
    {
        <strong class="bold">QueueItem item = queue.Peek()!.Value;</strong>
        TimeSpan elapsed = DateTime.Now - item.StartedAt;
        if (elapsed.TotalSeconds &lt; rideSeconds) { break; }
        <strong class="bold">queue.Dequeue();</strong>
        Log($"&gt; Exits\tTotal: {queue.Count}", item.Color);
    }
    bool isNew = random.Next(3) == 1;
    if (isNew)
    {
        color = color == ConsoleColor.White
            ? ConsoleColor.DarkBlue
            : (ConsoleColor)(((int)color) + 1);
        if (<strong class="bold">queue.Enqueue((DateTime.Now, color))</strong>)
        {
            Log($"&lt; Enters\tTotal: {queue.Count}", color);
        }
        else
        {
            Log($"! Not allowed\tTotal: {queue.Count}",
                ConsoleColor.DarkGray);
        }
    }
    await Task.Delay(500);
}</pre> <p>It contains <a id="_idIndexMarker544"/>an infinite <code>while</code> loop. Within it, you first check which items should be dequeued, which means that the ride time (that is, 10 seconds) elapsed for them. If so, you also log the message. Then, you draw a random number to decide whether a new item should be added to the circular queue in this iteration of an infinite <code>while</code> loop. If so, you choose the next color from the <code>ConsoleColor</code> enumeration, try to enqueue a new item to the queue, as well as log the message. At the end of the iteration, you wait 500 milliseconds.</p>
<p>The code of the auxiliary <code>Log</code> method is presented here:</p>
<pre class="source-code">
void <strong class="bold">Log</strong>(string text, ConsoleColor color)
{
    Console.ForegroundColor = color;
    Console.WriteLine($"{DateTime.Now:HH:mm:ss} {text}");
    Console.ResetColor();
}</pre> <p>When you run the code, you get the following result:</p>
<div><div><img alt="Figure 5.17 – ﻿Screenshot of the gravity roller coaster example" src="img/B18069_05_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 – Screenshot of the gravity roller coaster example</p>
<p>Congratulations – you <a id="_idIndexMarker545"/>now know how to use a few types of queues! You took a look at a regular one, a priority queue, as well as a circul<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>ar one, together with examples. So, it is high time to summarize the chapter.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor194"/>Summary</h1>
<p>In this chapter, you learned about two limited access data structures, namely stacks and queues, including regular, priority, and circular ones. It is worth remembering that such data structures have strictly specified ways of accessing elements. All of them also have various real-world applications. Some of them were mentioned in this chapter.</p>
<p>First, you saw how a <strong class="bold">stack</strong> operates according to the LIFO principle. In this case, you can add an element at the top of the stack (a <em class="italic">push</em> operation), and remove an element from the top (a <em class="italic">pop</em> operation). The stack was shown in two examples, namely for reversing a word and for solving the <em class="italic">Tower of Hanoi</em> mathematical game.</p>
<p>In the following part of the chapter, you got to know a <strong class="bold">queue</strong> as a data structure, which operates according to the FIFO principle. In this case, <em class="italic">enqueue</em> and <em class="italic">dequeue</em> operations were presented. The queue was explained using two examples, both regarding the application simulating a call center. You learned how to use a thread-safe variant of a queue-related class, which is available while developing applications in the C# language.</p>
<p>The next data structure shown in this chapter is named a <strong class="bold">priority queue</strong> and is an extension of a queue that supports the priorities of particular elements. In the end, you learned about a <strong class="bold">circular queue</strong>, which expands the concept of a regular queue by forming a circle, where the first and rear elements are indicated by indices.</p>
<p>This is just the fifth chapter of this book, and you already learned a lot about various data structures and algorithms that are useful while developing applications in C#! Are you interested in increasing your knowledge by learning about <strong class="bold">dictionaries</strong> and <strong class="bold">sets</strong>? If so, let’s proceed to the next chapter and learn more about them!</p>
</div>
</body></html>