- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Augmented Reality in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 中的增强现实
- en: Nowadays, new technologies expand the fields of the application of Unity, from
    gaming to all kinds of software, such as simulations, training, apps, and so on.
    In the latest versions of Unity, we saw lots of improvements in the field of augmented
    reality, which allows us to add a layer of virtuality on top of our reality, thereby
    augmenting what our device can perceive to create games that rely on real-world
    data, such as the camera’s image, our real-world position, and the current weather.
    This can also be applied to work environments, such as when viewing the building
    map or checking the electrical ducts inside a wall. Welcome to the extra section
    of this book, where we are going to discuss how to create **Augmented Reality**
    (**AR**) applications using Unity’s AR Foundation package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新技术扩展了 Unity 的应用领域，从游戏到各种软件，如模拟、培训、应用程序等。在 Unity 的最新版本中，我们在增强现实领域看到了许多改进，这使得我们可以在现实之上添加一层虚拟性，从而增强我们设备所能感知的内容，以创建依赖于现实世界数据的游戏，例如摄像机的图像、我们的现实世界位置和当前的天气。这也可以应用于工作环境，例如查看建筑图或检查墙内的电线管道。欢迎来到本书的额外部分，我们将讨论如何使用
    Unity 的 AR Foundation 包创建增强现实（**AR**）应用程序。
- en: 'In this chapter, we will examine the following AR Foundation concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下 AR Foundation 概念：
- en: Using AR Foundation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AR Foundation
- en: Building for mobile devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Creating a simple AR game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的 AR 游戏
- en: By the end of this chapter, you will be able to create AR apps using AR Foundation
    and will have a fully functional game that uses its framework so that you can
    test the framework’s capabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 AR Foundation 创建 AR 应用程序，并将拥有一个使用其框架的完整功能游戏，以便你可以测试框架的功能。
- en: Let’s start by exploring the AR Foundation framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索 AR Foundation 框架。
- en: Using AR Foundation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AR Foundation
- en: 'When it comes to AR, Unity has two main tools to create applications: **Vuforia**
    and **AR Foundation**. Vuforia is an AR framework that can work in almost any
    mobile device and contains all the needed features for basic AR apps, but with
    a paid subscription, we get more advanced features. On the other hand, the completely
    free AR Foundation framework supports the latest AR native features of our devices
    but is supported only in newer ones. Picking between one or the other depends
    a lot on the type of project you’re going to build and the target audience. However,
    since this book aims to discuss the latest Unity features, we are going to explore
    how to use AR Foundation to create our first AR app for detecting the positions
    of images and surfaces in the real world. So, we’ll start by exploring its API.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 AR 时，Unity 有两个主要的工具来创建应用程序：**Vuforia** 和 **AR Foundation**。Vuforia 是一个可以在几乎所有移动设备上工作的
    AR 框架，它包含了基本 AR 应用所需的所有功能，但通过付费订阅，我们可以获得更多高级功能。另一方面，完全免费的 AR Foundation 框架支持我们设备上最新的
    AR 原生功能，但仅支持较新的设备。选择其中一个还是另一个很大程度上取决于你将要构建的项目类型和目标受众。然而，由于本书旨在讨论最新的 Unity 功能，我们将探讨如何使用
    AR Foundation 创建我们的第一个 AR 应用，用于检测现实世界中图像和表面的位置。因此，我们将从探索其 API 开始。
- en: 'In this section, we will examine the following AR Foundation concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下 AR Foundation 概念：
- en: Creating an AR Foundation project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 AR 基础项目
- en: Using tracking features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: Let’s start by discussing how to prepare our project so that it can run AR Foundation
    apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何准备我们的项目，以便它能够运行 AR Foundation 应用程序。
- en: Creating an AR Foundation project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AR 基础项目
- en: Something to consider when creating AR projects is that we will not only change
    the way we code our game, but also the game design aspect. AR apps have differences,
    especially in the way the user interacts, and also limitations, such as the user
    being in control of the camera all the time. We cannot simply port an existing
    game to AR without changing the very core experience of the game. That’s why,
    in this chapter, we are going to work on a brand-new project; it would be too
    difficult to change the game we’ve created so far so that it works well in AR.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 AR 项目时需要考虑的是，我们不仅会改变我们编写游戏代码的方式，还会改变游戏设计方面。AR 应用程序有差异，尤其是在用户交互方式上，以及一些限制，例如用户始终控制着摄像头。我们不能简单地移植现有的游戏到
    AR 而不改变游戏的核心体验。这就是为什么在本章中，我们将着手一个全新的项目；改变我们迄今为止创建的游戏以使其在 AR 中运行将非常困难。
- en: 'In our case, we are going to create a game where the user controls a player
    moving a “marker,” a physical image you can print that will allow our app to recognize
    where the player is in the real world. We will be able to move the player while
    moving that image, and this virtual player will automatically shoot at the nearest
    enemy. Those enemies will spawn from certain spawn points that the user will need
    to place in different parts of the home. As an example, we can put two spawn points
    on the walls and place our player marker on a table in the middle of the room
    so that the enemies will go toward them. In the following image, you can see a
    preview of what the game will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个游戏，用户控制一个移动“标记”的玩家，这个“标记”是一个可以打印的物理图像，它将允许我们的应用程序识别玩家在现实世界中的位置。我们可以在移动该图像的同时移动玩家，这个虚拟玩家将自动射击最近的敌人。这些敌人将从用户需要在家庭不同部分放置的特定生成点出现。例如，我们可以在墙上放置两个生成点，并将我们的玩家标记放在房间中间的桌子上，这样敌人就会朝它们走去。在下面的图像中，你可以看到游戏的预览：
- en: '![](img/B18585_20_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_20_01.png)'
- en: 'Figure 20.1: Finished game. The Cylinder is an enemy spawner, the Capsule is
    the enemy, and the Cube is the player. These are positioned in a marker image
    displayed by the cellphone'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1：完成的游戏。圆柱体是敌人生成器，胶囊是敌人，立方体是玩家。这些在手机显示的标记图像中定位
- en: We’ll start creating a new URP-based project in the same manner we created our
    first game. Something to consider is that AR Foundation works with other pipelines,
    including built-in ones, in case you want to use it in already existing projects.
    If you don’t remember how to create a project, please refer to *Chapter 1*, *Creating
    a Unity Project*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以创建第一个游戏相同的方式开始创建一个新的基于URP的项目。需要考虑的是，AR Foundation与其他管道一起工作，包括内置的，以防你希望在现有项目中使用它。如果你不记得如何创建项目，请参阅*第1章*，*创建Unity项目*。
- en: Once you’re in your new blank project, install the AR Foundation package from
    the Package Manager, just like we’ve installed other packages previously—that
    is, from **Window** | **Package Manager**. Remember to set the Package Manager
    so that it shows all packages, not only the ones in the project (the **Packages**
    button at the top-left part of the window needs to be set to **Unity Registry**)
    and also the preview versions (click on the wheel icon, then **Project Settings**,
    and check **Enable Pre-release Packages** on the window that appears).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入你的新空白项目，就像我们之前安装其他包一样，从包管理器安装AR Foundation包——即，从**窗口** | **包管理器**。记得设置包管理器，使其显示所有包，而不仅仅是项目中的包（窗口左上角的**包**按钮需要设置为**Unity注册表**）以及预览版本（点击轮形图标，然后**项目设置**，在出现的窗口上检查**启用预发布包**）。
- en: 'At the time of writing this book, the latest stable release is 4.2.3, but we
    are going to explore the 5.0.0 preview 13 version. Remember to open the package
    version list by clicking the triangle button at the left to see the preview versions.
    If you find a newer version than mine, you can try using that one, but as usual,
    if something works differently from what we want, please install 5.0.0-pre.13\.
    As usual, if a warning prompting you to enable the new input system appears, click
    **Yes**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的稳定版本是4.2.3，但我们将探索5.0.0预览版13。记得通过点击左侧的三角形按钮打开包版本列表，以查看预览版本。如果你发现比我更新的版本，你可以尝试使用那个版本，但像往常一样，如果某些东西的工作方式与我们想要的不同，请安装5.0.0-pre.13。像往常一样，如果出现提示你启用新输入系统的警告，请点击**是**：
- en: '![](img/B18585_20_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_20_02.png)'
- en: 'Figure 20.2: Installing AR Foundation'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2：安装AR Foundation
- en: Before we install any other needed packages, now is a good moment to discuss
    some core ideas of the AR Foundation framework. This package, by itself, does
    nothing; it defines a series of AR features that mobile devices offer, such as
    image tracking, cloud points, and object tracking, but the actual implementation
    of how to do that is contained in the **Provider** packages, such as **Apple ARKit
    XR Plugin** and **Google ARCore XR plugin** packages. This is designed like this
    because, depending on the target device you want to work with, the way those features
    are implemented changes. As an example, in iOS, Unity implements those features
    using AR Kit, while in Android, it uses AR Core; they are platform-specific frameworks.
    Remember to install the same version of these platform packages as the AR Foundation
    one (5.0.0 preview 13 in this case).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装任何其他需要的包之前，现在是讨论 AR Foundation 框架核心思想的好时机。这个包本身并不做任何事情；它定义了一系列移动设备提供的 AR
    功能，例如图像跟踪、云点和对象跟踪，但实际如何实现这些功能的代码包含在 **Provider** 包中，例如 **Apple ARKit XR 插件** 和
    **Google ARCore XR 插件** 包。这样设计是因为，根据您想要与之合作的目标设备，实现这些功能的方式会有所不同。例如，在 iOS 中，Unity
    使用 AR Kit 实现这些功能，而在 Android 中，它使用 AR Core；它们是平台特定的框架。请记住，安装与 AR Foundation 相同版本的这些平台包（在本例中为
    5.0.0 预览版 13）。
- en: 'Something to consider here is that not all iOS or Android devices support AR
    Foundation apps. You might find an updated list of supported devices when searching
    for AR Core- and AR Kit-supported devices on the internet. At the time of writing,
    the following links provide the supported devices lists:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，并非所有 iOS 或 Android 设备都支持 AR Foundation 应用。您在网上搜索支持 AR Core 和 AR Kit
    的设备时，可能会找到一个更新的支持设备列表。在撰写本文时，以下链接提供了支持设备列表：
- en: '**iOS**: [https://www.apple.com/lae/augmented-reality](https://www.apple.com/lae/augmented-reality)
    (at the bottom of the page)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**: [https://www.apple.com/lae/augmented-reality](https://www.apple.com/lae/augmented-reality)（页面底部）'
- en: '**Android**: [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**: [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)'
- en: Also, there isn’t a PC Provider package, so the only way to test AR Foundation
    apps so far is directly on the device, but testing tools are going to be released
    soon. In my case, I will be creating an app for iOS, so aside from the **AR Foundation**
    package, I need to install the **ARKit XR** plugin.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，目前还没有 PC Provider 包，因此迄今为止测试 AR Foundation 应用程序的唯一方法是直接在设备上测试，但测试工具很快就会发布。在我的情况下，我将为
    iOS 创建一个应用程序，因此除了 **AR Foundation** 包之外，我还需要安装 **ARKit XR** 插件。
- en: 'However, if you want to develop for Android, install the **ARCore XR** plugin
    instead (or both if you’re targeting both platforms). Also, I will be using the
    4.1.7 version of these packages. Usually, the versions of the **AR Foundation**
    and **Provider** packages match but apply the same logic as when you picked the
    **AR Foundation** version. In the following screenshot, you can see the **ARKit**
    package in the **Package Manager**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想为 Android 开发，请安装 **ARCore XR** 插件（或者如果您针对两个平台，则两者都安装）。此外，我将使用这些包的 4.1.7
    版本。通常，**AR Foundation** 和 **Provider** 包的版本是一致的，但应用相同的逻辑，就像您选择 **AR Foundation**
    版本时一样。在下面的屏幕截图中，您可以在 **包管理器** 中看到 **ARKit** 包：
- en: 'Now that we have the needed plugins, we need to prepare a scene for AR, as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的插件，我们需要为 AR 准备一个场景，如下所示：
- en: Create a new Scene in **File | New Scene** and select the **Basic (URP)** template.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **文件 | 新建场景** 中创建一个新的场景，并选择 **基本 (URP)** 模板。
- en: Delete **Main Camera**; we are going to use a different one.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 **主摄像头**；我们将使用另一个摄像头。
- en: In the **GameObject | XR** menu, create an **AR Session** GameObject.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **GameObject | XR** 菜单中，创建一个 **AR Session** GameObject。
- en: In the same menu, create an **XR Origin (Mobile AR)** object that has a **Camera**
    inside it.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的菜单中，创建一个包含 **Camera** 的 **XR Origin (Mobile AR)** 对象。
- en: Select the Main Camera inside **XR Origin**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **XR Origin** 中选择 **主摄像头**。
- en: Set the **Render Mode** property of the **AR Camera Manager** component to **After
    Opaques**. This is a workaround for a bug that prevents the camera from being
    rendered properly in another mode in the current versions.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR 摄像机管理器** 组件的 **渲染模式** 属性设置为 **在不透明物体之后**。这是针对当前版本中另一种模式下无法正确渲染摄像头的错误的一个解决方案。
- en: 'Your hierarchy should look as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的层次结构应该如下所示：
- en: '![](img/B18585_20_03.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18585_20_03.png)'
- en: 'Figure 20.3: Starter AR Scene'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.3：入门 AR 场景
- en: The **AR Session** object will be responsible for initializing AR Framework
    and will handle all the update logic for the AR systems. The **XR Origin** object
    will allow the framework to locate tracked objects such as images and point clouds
    in a relative position to the scene. The devices inform the positions of tracked
    objects relative to what the device considers “the origin.” This is usually the
    first area of your house you were pointing at when the app started detecting objects,
    so the **XR Origin** object will represent that point in your physical space.
    Finally, you can check the camera inside the origin, which contains some extra
    components, with the most important being **Tracked Pose Driver**, which will
    make your **Camera** object move along with your device. Since the device’s position
    is relative to the Session Origin object’s point, the camera needs to be inside
    the origin object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Session**对象将负责初始化AR框架，并处理AR系统的所有更新逻辑。**XR Origin**对象将允许框架定位跟踪对象，如图像和点云，相对于场景的相对位置。设备会告知跟踪对象相对于设备认为的“原点”的位置。这通常是当应用程序开始检测对象时你指向的第一个区域，因此**XR
    Origin**对象将代表你物理空间中的那个点。最后，你可以检查原点内的相机，它包含一些额外的组件，其中最重要的是**Tracked Pose Driver**，它将使你的**Camera**对象随着设备移动。由于设备的位置相对于会话原点对象的点，相机需要位于原点对象内。'
- en: 'One extra step in case you are working on a URP project (our case) is that
    you need to set up the render pipeline so that it supports rendering the camera
    image in the app. To do that, go to the `Settings` folder that was generated when
    we created the project, look for the `URP-HighFidelity-Renderer` file, and select
    it. In the **Renderer Features** list, click the **Add Renderer Feature** button
    and select **AR Background Renderer Feature**. In the following screenshot, you
    can see what the Forward Renderer asset should look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个URP项目（我们的情况），则需要额外的一步，即设置渲染管线，使其支持在应用程序中渲染相机图像。为此，前往我们创建项目时生成的`Settings`文件夹，查找`URP-HighFidelity-Renderer`文件，并选择它。在**Renderer
    Features**列表中，点击**Add Renderer Feature**按钮，并选择**AR Background Renderer Feature**。在下面的屏幕截图中，你可以看到Forward
    Renderer资产应该看起来是什么样子：
- en: '![](img/B18585_20_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_04.png)'
- en: 'Figure 20.4: Adding support for URP'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：为URP添加支持
- en: And that’s all! We are ready to start exploring the AR Foundation components
    so that we can implement tracking features.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们准备好开始探索AR Foundation组件，以便我们可以实现跟踪功能。
- en: Using tracking features
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: 'For our project, we are going to need two of the most common tracking features
    in AR (but not the only ones): image recognition and plane detection. The first
    one consists of detecting the position in the real world of a specific image so
    that we can place digital objects on top of it, such as the player. The second
    one, plane detection, consists of recognizing real-life surfaces, such as floors,
    tables, and walls, so that we have a reference of where we can put objects, such
    as the enemy’s spawn points. Only horizontal and vertical surfaces are recognized
    (just vertical surfaces on some devices).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们需要AR中最常见的两个跟踪功能（但不是唯一的功能）：图像识别和平面检测。第一个功能包括检测特定图像在现实世界中的位置，以便我们可以在其上方放置数字对象，例如玩家。第二个功能，平面检测，包括识别现实生活中的表面，如地板、桌子和墙壁，以便我们有放置对象（如敌人的出生点）的参考。只有水平和垂直表面被识别（某些设备上仅识别垂直表面）。
- en: 'The first thing we need to do is tell our app which images it needs to detect,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是告诉我们的应用程序它需要检测哪些图片，如下所示：
- en: 'Add an image to the project that you can print or display on a mobile device.
    Having a way to display the image in the real world is necessary to test this.
    In this case, I will use the following image:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片添加到项目中，使其可以打印或显示在移动设备上。在现实世界中展示图片的方式对于测试这是必要的。在这种情况下，我将使用以下图片：
- en: '![](img/B18585_20_05.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_05.png)'
- en: 'Figure 20.5: Image to track'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5：要跟踪的图片
- en: Try to get an image that contains as many features as you can. This means an
    image with lots of little details, such as contrasts, sharp corners, and so on.
    Those are what our AR systems use to detect it; the more detail, the better the
    recognition. If your device has trouble detecting our current image, try other
    images (the classic QR code might help).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量获取包含尽可能多特征的图片。这意味着一个有很多小细节的图片，比如对比度、尖锐的角落等。这些都是我们的AR系统用来检测它的；细节越多，识别越好。如果你的设备在检测我们当前的图片时遇到困难，请尝试其他图片（经典的QR码可能有所帮助）。
- en: Consider that some devices might have trouble with certain images, such as the
    image suggested in this book. If this generates issues when testing, please try
    using another one. You will be testing this on your device in the upcoming sections
    of this chapter, so just keep this in mind.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到某些设备可能对某些图像存在困难，例如本书中建议的图像。如果在测试时产生问题，请尝试使用另一个图像。你将在本章接下来的部分中在自己的设备上测试此图像，所以请记住这一点。
- en: 'Create a **Reference Image Library**, an asset containing all the images we
    wish our app to recognize, by clicking the **+** button in **Project Panel** and
    selecting **XR | Reference Image Library**:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目面板**中点击**+**按钮并选择**XR | 参考图像库**来创建一个**参考图像库**，这是一个包含我们希望应用程序识别的所有图像的资产。
- en: '![](img/B18585_20_06.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_06.png)'
- en: 'Figure 20.6: Creating a Reference Image Library'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.6：创建参考图像库
- en: Select the **Reference Image Library** asset we created and click the **Add
    Image** button to add a new image to the library.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们创建的**参考图像库**资产，并点击**添加图像**按钮以将新图像添加到库中。
- en: Drag the texture to the texture slot (the one that says **None**).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理拖动到纹理槽（标有**None**的那个槽）中。
- en: 'Turn **Specify Size** on and set **Physical Size** to the size that your image
    will be printed in real life, in meters. Try to be accurate here; on some devices
    not having this value right might result in the image not being tracked:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**指定大小**，并将**物理大小**设置为图像在现实生活中的打印尺寸，单位为米。在这里尽量准确；在某些设备上，如果没有设置正确的值，可能会导致图像无法被跟踪：
- en: '![](img/B18585_20_07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_07.png)'
- en: 'Figure 20.7: Adding an image to be recognized'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.7：添加要识别的图像
- en: 'Now that we’ve specified the images to be detected, let’s test this by placing
    a cube on top of the real-life image:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了要检测的图像，让我们通过在现实生活中的图像上方放置一个立方体来测试这一点：
- en: Create a Prefab of a cube and add the **AR Tracked Image** component to it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体的Prefab，并向其添加**AR 跟踪图像**组件。
- en: Remember to set a small scale, like 0.1, on each axis, given that the default
    cube will be 1 meter by 1 meter, which will be huge in AR.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，由于默认的立方体将是1米乘1米，这在AR中会非常大，所以请在每个轴上设置一个小比例，例如0.1。
- en: Add the **AR Tracked Image Manager** component to the **XR Origin** object.
    This will be responsible for detecting images and creating objects in its position.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR 跟踪图像管理器**组件添加到**XR 原点**对象中。这将负责检测图像并在其位置创建对象。
- en: Drag the **Image Library** asset created in the previous steps to the **Serialized
    Library** property of the component to specify the images to recognize.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前步骤中创建的**图像库**资产拖动到组件的**序列化库**属性中，以指定要识别的图像。
- en: 'Drag the **Cube** Prefab to the **Tracked Image Prefab** property of the component:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**立方体**Prefab拖动到组件的**跟踪图像Prefab**属性中：
- en: '![](img/B18585_20_08.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_08.png)'
- en: 'Figure 20.8: Setting up the Tracked Image Manager'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.8：设置跟踪图像管理器
- en: 'And that’s all! Later in the *Building for mobile* section in this chapter,
    when we will create an iOS or Android build, we will see a cube spawning in the
    same position that the image is located in the real world. Remember that you need
    to test this in the device, which we will do in the next section, so for now,
    let’s keep coding our test app:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有内容！在本章的“为移动设备构建”部分中，当我们创建iOS或Android构建时，我们将看到立方体在图像在现实世界中的相同位置生成。请记住，你需要在这个设备上测试这一点，我们将在下一节中这样做，所以现在，让我们继续编写我们的测试应用程序代码：
- en: '![](img/B18585_20_01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_01.png)'
- en: 'Figure 20.9: Cube located on top of the image being displayed by the cellphone'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.9：位于手机显示图像顶部的立方体
- en: Let’s also prepare our app so that it can detect and display the plane surfaces
    the camera has recognized. This is simply done by adding the **AR Plane Manager**
    component to the **XR Origin** object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也准备我们的应用程序，以便它可以检测并显示相机识别出的平面表面。这很简单，只需将**AR 平面管理器**组件添加到**XR 原点**对象中。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_20_10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成描述](img/B18585_20_10.png)'
- en: 'Figure 20.10: Adding the AR Plane Manager component'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.10：添加 AR 平面管理器组件
- en: 'This component will detect surface planes over our house as we move the camera
    over it. It can take a while to detect them, so it’s important to visualize the
    detected areas to get feedback about this to ensure it’s working properly. We
    can manually get information about the plane from a component reference to the
    AR Plane Manager, but luckily, Unity allows us to visualize planes easily. Let’s
    take a look:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件会在我们移动相机时检测我们房子上的表面平面。检测它们可能需要一段时间，因此可视化检测区域以获取有关此操作的反馈非常重要，以确保其正常工作。我们可以从AR
    Plane Manager的组件引用手动获取有关平面的信息，但幸运的是，Unity允许我们轻松地可视化平面。让我们看看：
- en: Create a Prefab of a plane, first by creating the plane in **GameObject | 3D
    Object | Plane**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过在**GameObject | 3D Object | Plane**中创建一个平面的预制体。
- en: Add a **Line Renderer** to it. This will allow us to draw a line over the edges
    of the detected areas.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个**Line Renderer**。这将使我们能够在检测区域的边缘绘制线条。
- en: 'Set the **Width** property of **Line Renderer** to a small value such as `0.01`,
    the **Color** gradient property to black, and uncheck **Use World Space**:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Line Renderer**的**Width**属性设置为较小的值，例如`0.01`，将**Color**渐变属性设置为黑色，并取消选中**Use
    World Space**：
- en: '![Graphical user interface  Description automatically generated](img/B18585_20_11.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成的描述](img/B18585_20_11.png)'
- en: 'Figure 20.11: Setting the Line Renderer'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.11：设置线渲染器
- en: 'Remember to create a material with the proper shader (**Universal Render Pipeline/Unlit**)
    and set it as the material of the **Line Renderer** component under the **Materials**
    list property:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得创建一个具有适当着色器（**Universal Render Pipeline/Unlit**）的材质，并将其设置为**Materials**列表属性下**Line
    Renderer**组件的材质：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_12.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B18585_20_12.png)'
- en: 'Figure 20.12: Creating the Line Renderer material'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.12：创建线渲染器材质
- en: 'Also, create a transparent material and use it in the **MeshRenderer** plane.
    We want to see through it so that we can easily see the real surface beneath:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个透明材质，并将其用于**MeshRenderer**平面。我们希望透过它，这样我们就可以轻松地看到下面的真实表面：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_20_13.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B18585_20_13.png)'
- en: 'Figure 20.13: Material for the detected plane'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.13：检测到的平面的材质
- en: Add the **AR Plane** and **AR Plane Mesh Visualizer** components to the **Plane**
    Prefab.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Plane**和**AR Plane Mesh Visualizer**组件添加到**Plane**预制体中。
- en: 'Drag the Prefab to the **Plane Prefab** property of the **AR Plane Manager**
    component of the **XR Origin** object:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预制体拖动到**XR Origin**对象的**AR Plane Manager**组件的**Plane Prefab**属性中：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_20_14.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，自动生成的描述](img/B18585_20_14.png)'
- en: 'Figure 20.14: Setting the plane visualization Prefab'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.14：设置平面可视化预制体
- en: Now, we have a way to see the planes, but seeing them is not the only thing
    we can do (sometimes, we don’t even want them to be visible). The real power of
    planes resides in placing virtual objects on top of real-life surfaces, tapping
    into a specific plane area, and getting its real-life position. We can access
    the plane data using the **AR Plane Manager** or by accessing the **AR Plane**
    component of our visualization planes, but something easier is to use the **AR
    Raycast Manager** component.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了查看平面的方法，但看到它们并不是我们能做的唯一事情（有时，我们甚至不希望它们可见）。平面的真正力量在于在现实生活中的表面上放置虚拟对象，点击特定的平面区域，并获取其实际位置。我们可以通过**AR
    Plane Manager**或访问我们的可视化平面的**AR Plane**组件来访问平面数据，但更简单的方法是使用**AR Raycast Manager**组件。
- en: 'The **AR Raycast Manager** component provides us with the equivalent to the
    `Physics.Raycast` function of the Unity Physics system, which, as you may recall,
    is used to create imaginary rays that start from one position and go toward a
    specified direction in order to make them hit surfaces and detect the exact hit
    point. The version provided by **AR Raycast Manager**, instead of colliding with
    physics colliders, collides with tracked objects, mostly Point Clouds (we are
    not using them) and the “planes” we are tracking. We can test this feature by
    following these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Raycast Manager**组件为我们提供了与Unity物理系统中的`Physics.Raycast`函数等效的功能，你可能还记得，这个函数用于创建从某个位置开始并指向指定方向的虚拟射线，以便它们击中表面并检测确切的击中点。**AR
    Raycast Manager**提供的版本，而不是与物理碰撞体碰撞，而是与跟踪对象碰撞，主要是点云（我们未使用它们）和我们要跟踪的“平面”。我们可以通过以下步骤测试这个功能：'
- en: Add the **AR Raycast Manager** component to the **XR Origin** object.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Raycast Manager**组件添加到**XR Origin**对象中。
- en: Create a custom script called `SpawnerPlacer` in the **XR Origin** object.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**XR Origin**对象中创建一个名为`SpawnerPlacer`的自定义脚本。
- en: In the **Awake** cache, add the reference to `ARRaycastManager`. You will need
    to add the `using UnityEngine.XR.ARFoundation;` line to the top of the script
    for this class to be usable in our script.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Awake**缓存中添加对`ARRaycastManager`的引用。你需要将`using UnityEngine.XR.ARFoundation;`行添加到脚本顶部，以便在这个类中可以使用我们的脚本。
- en: 'Create a private field of the `List<ARRaycastHit>` type and instantiate it;
    the Raycast function is going to detect every plane our ray hit, not just the
    first one:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`List<ARRaycastHit>`类型的私有字段并实例化它；Raycast函数将检测我们的射线击中的每个平面，而不仅仅是第一个：
- en: '![](img/B18585_20_15.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_20_15.png)'
- en: 'Figure 20.15: List to store hits'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_20_15.png)'
- en: Under **Update**, check if the touch screen is pressed (`Touchscreen.current.primaryTouch.press.isPressed`).
    You will need the `using UnityEngine.InputSystem;` using at the top of the file
    to use the new input system.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Update**下检查触摸屏是否被按下（`Touchscreen.current.primaryTouch.press.isPressed`）。你需要在文件顶部使用`using
    UnityEngine.InputSystem;`来使用新的输入系统。
- en: Inside the `if` statement from the previous step, add another condition for
    calling the `Raycast` function of **AR Raycast Manager**, passing the position
    of the touch as the first parameter and the list of hits as the second (`Touchscreen.current.primaryTouch.position.ReadValue()`).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的`if`语句内部，为调用**AR Raycast Manager**的`Raycast`函数添加另一个条件，将触摸位置作为第一个参数，将碰撞列表作为第二个参数传递（`Touchscreen.current.primaryTouch.position.ReadValue()`）。
- en: This will throw a Raycast toward the direction the player touches the screen
    and store the hits inside the list we provided. This will return `true` if something
    has been hit, and `false` if not.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向玩家触摸屏幕的方向发射射线，并将碰撞存储在我们提供的列表中。如果击中某个物体，则返回`true`，如果没有击中，则返回`false`。
- en: Add a public field to specify the Prefab to instantiate in the place we touched.
    You can just create a Sphere Prefab and assign it to this field to test this;
    there’s no need to add any special component to the Prefab here. Remember to set
    a small scale.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共字段来指定在触摸位置实例化的Prefab。你可以创建一个球体Prefab并将其分配给此字段进行测试；这里不需要为Prefab添加任何特殊组件。请记住设置一个小的缩放。
- en: 'Instantiate the Prefab in the **Position** and **Rotation** fields of the **Pose**
    property of the first hit stored in the list. The hits are sorted by distance,
    so the first hit is the closest one. Your final script should look as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中存储的第一个碰撞的**Pose**属性的**Position**和**Rotation**字段中实例化Prefab。由于碰撞按距离排序，所以第一个碰撞是最接近的。你的最终脚本应该如下所示：
- en: '![](img/B18585_20_16.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_20_16.png)'
- en: 'Figure 20.16: Raycaster component'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.16：射线投射组件
- en: In this section, we learned how to create a new AR project using AR Foundation.
    We discussed how to install and set up the framework, as well as how to detect
    real-life image positions and surfaces, and then how to place objects on top of
    them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用AR Foundation创建新的AR项目。我们讨论了如何安装和设置框架，以及如何检测现实生活中的图像位置和表面，然后是如何在它们上方放置对象。
- en: As you may have noticed, we never hit **Play** to test this, and sadly at the
    time of writing this book, we cannot test this in the Editor. Instead, we need
    to test this directly on the device. Due to this, in the next section, we are
    going to learn how to do builds for mobile devices such as Android and iOS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们从未点击**Play**来测试这个，遗憾的是，在撰写本书时，我们无法在编辑器中测试这个。相反，我们需要直接在设备上测试这个。因此，在下一节中，我们将学习如何为Android和iOS等移动设备进行构建。
- en: Building for mobile devices
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Unity is a very powerful tool that solves the most common problems in game development
    very easily, and one of them is building the game for several target platforms.
    Now, the Unity part of building our project for such devices is easy to do, but
    each device has its non-Unity-related nuances when installing development builds.
    In order to test our AR app, we need to test it directly on the device. So, let’s
    explore how we can make our app run on Android and iOS, the most common mobile
    platforms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个非常强大的工具，它能够轻松解决游戏开发中最常见的问题，其中之一就是为多个目标平台构建游戏。现在，为这些设备构建我们的项目部分在Unity中很容易完成，但每个设备在安装开发版本时都有其与Unity无关的细微差别。为了测试我们的AR应用程序，我们需要直接在设备上测试它。因此，让我们探讨如何使我们的应用程序在Android和iOS（最常见的移动平台）上运行。
- en: Before diving into this topic, it is worth mentioning that the following procedures
    change a lot over time, so you will need to find the latest instructions on the
    internet. The Unity Learn portal site ([https://learn.unity.com/tutorial/how-to-publish-to-android-2](https://learn.unity.com/tutorial/how-to-publish-to-android-2))
    may be a good alternative in case the instructions in this book fail but try the
    steps here first.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这个主题之前，值得提到的是，以下程序会随着时间的推移而大量变化，因此您需要在互联网上找到最新的说明。Unity Learn门户网站（[https://learn.unity.com/tutorial/how-to-publish-to-android-2](https://learn.unity.com/tutorial/how-to-publish-to-android-2)）可能是本书记载的说明失败时的一个良好替代方案，但请先尝试这里的步骤。
- en: 'In this section, we will examine the following mobile building concepts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下移动构建概念：
- en: Building for Android
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android构建
- en: Building for iOS
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS构建
- en: Let’s start by discussing how to build our app so that it runs on Android phones.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何构建我们的应用程序，使其在Android手机上运行。
- en: Building for Android
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android构建
- en: 'Creating Android builds is relatively easy compared to other platforms, so
    we’ll start with Android. Remember that you will need an Android device capable
    of running AR Foundation apps, so please refer to the link regarding Android-supported
    devices we mentioned in the *Using AR Foundation* section of this chapter. The
    first thing we need to do is check if we have installed Unity’s Android support
    and configured our project to use that platform. To do that, follow these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他平台相比，创建Android构建相对容易，因此我们将从Android开始。请记住，您需要一个能够运行AR Foundation应用程序的Android设备，因此请参阅本章*使用AR
    Foundation*部分中提到的关于支持Android的设备的链接。我们需要做的第一件事是检查我们是否已安装Unity的Android支持，并配置我们的项目以使用该平台。为此，请按照以下步骤操作：
- en: Close Unity and open **Unity Hub**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Unity并打开**Unity Hub**。
- en: Go to the **Installs** section and locate the Unity version you are working
    on.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**安装**部分，找到您正在工作的Unity版本。
- en: 'Click the wheel icon button at the top-right corner of the Unity version you
    are using and click **Add Modules**:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您使用的Unity版本右上角点击轮形图标按钮，然后点击**添加模块**：
- en: '![](img/B18585_20_17.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_17.png)'
- en: 'Figure 20.17: Adding modules to the Unity version'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.17：向Unity版本添加模块
- en: 'Make sure **Android Build Support** and the sub-options that are displayed
    when you click the arrow on its left are checked. If not, check them and click
    the **Continue** button at the bottom-right to install them:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选**Android构建支持**以及点击其左侧箭头时显示的子选项。如果没有，请勾选它们，然后点击窗口右下角的**继续**按钮来安装它们：
- en: '![](img/B18585_20_18.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_18.png)'
- en: 'Figure 20.18: Adding Android support to Unity'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.18：将Android支持添加到Unity
- en: Accept all the terms and conditions prompts by checking the **Accept Terms**
    checkbox and clicking the **Continue** button.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选**接受条款**复选框并点击**继续**按钮，接受所有条款和条件提示。
- en: Open the AR project we created in this chapter.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章中创建的AR项目。
- en: Go to **Build Settings** (**File | Build Settings**).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**构建设置**（**文件 | 构建设置**）。
- en: 'Select the **Android** platform from the list and click the **Switch Platform**
    button at the bottom-right part of the window:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择**Android**平台，然后点击窗口右下角的**切换平台**按钮：
- en: '![Table  Description automatically generated with low confidence](img/B18585_20_19.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成，置信度低](img/B18585_20_19.png)'
- en: 'Figure 20.19: Switching to Android builds'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.19：切换到Android构建
- en: 'To build an app on Android, there are some requirements we need to meet, such
    as having the Java SDK (not the regular Java runtime) and Android SDK installed,
    but luckily, the new versions of Unity take care of that. Just to double-check
    that we have installed the needed dependencies, follow these steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Android 上构建应用程序，我们需要满足一些要求，例如安装 Java SDK（不是常规的 Java 运行时）和 Android SDK，但幸运的是，Unity
    的新版本会处理这些。为了确保我们已安装所需的依赖项，请按照以下步骤操作：
- en: Go to **Unity Preferences** (**Edit | Preferences** on Windows or **Unity |
    Preferences** on Mac).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Unity 预设** （在 Windows 上为 **编辑 | 预设**，在 Mac 上为 **Unity | 预设**）。
- en: Click **External Tools**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **外部工具**。
- en: 'Check that all the options that say **…Installed with Unity** on the Android
    section are checked. This means we will be using all the dependencies installed
    by Unity:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认 Android 部分所有标有 **…随 Unity 安装** 的选项都已勾选。这意味着我们将使用 Unity 安装的全部依赖项：
- en: '![A picture containing text, newspaper, screenshot, document  Description automatically
    generated](img/B18585_20_20.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、报纸、屏幕截图、文档的图片，自动生成描述](img/B18585_20_20.png)'
- en: 'Figure 20.20: Using installed dependencies'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.20：使用已安装的依赖项
- en: 'There are some additional Android ARCore-specific related settings to check
    that you can find at [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android).
    These can change if you are using newer versions of AR Core. You can apply them
    by following these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android)
    可以找到一些额外的 Android ARCore 特定相关设置，您可以通过以下步骤应用它们：
- en: Go to **Player Settings** (**Edit | Project Settings | Player**).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **玩家设置** （**编辑 | 项目设置 | 玩家**）。
- en: Uncheck **Multithreaded Rendering** and **Auto Graphics API** from the **Other
    Settings** section.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **其他设置** 部分取消选择 **多线程渲染** 和 **自动图形 API**。
- en: Remove **Vulkan** from the **Graphics APIs** list if it’s there.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，从 **图形 API** 列表中移除 **Vulkan**。
- en: 'Set **Minimum API Level** to **Android 7.0**:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **最小 API 级别** 设置为 **Android 7.0**：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_21.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序，自动生成描述](img/B18585_20_21.png)'
- en: 'Figure 20.21: AR Core settings'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.21：AR Core 设置
- en: Set the Scripting Backend to **IL2CPP**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本后端设置为 **IL2CPP**。
- en: Check the **ARM64** checkbox to give support to Android 64-bit devices.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **ARM64** 复选框以支持 Android 64 位设备。
- en: Check **Override Default Bundle Identifier** and set something custom, like
    `com.MyCompany.MyARApp`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **覆盖默认包标识符** 并设置一些自定义的，例如 `com.MyCompany.MyARApp`。
- en: Go to **Edit | Project Settings** and select the **XR Plug-in Management** option.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **编辑 | 项目设置** 并选择 **XR 插件管理** 选项。
- en: 'Check **Google ARCore** under **Plug-in Providers** to make sure it will be
    enabled in our build; if not we won’t see anything:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件提供者** 下选择 **Google ARCore** 以确保它将在我们的构建中启用；如果不这样做，我们不会看到任何内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_20_22.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序，自动生成描述](img/B18585_20_22.png)'
- en: 'Figure 20.22: ARCore plugin enabled'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.22：ARCore 插件已启用
- en: Now, you can finally build the app from **File | Build Settings** like usual,
    by using the **Build** button. This time, the output will be a single APK file
    that you can install by copying the file to your device and opening it. Remember
    that in order to install APKs that weren’t downloaded from the Play Store, you
    need to set your device to allow **Install Unknown Apps**. The location for that
    option varies a lot, depending on the Android version and the device you are using,
    but this option is usually located in the **Security** settings. Some Android
    versions prompt you to view these settings when installing the APK.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从 **文件 | 构建设置**（通过使用 **构建** 按钮）像往常一样构建应用程序。这次，输出将是一个单独的 APK 文件，您可以通过将文件复制到您的设备并打开它来安装。请记住，为了安装未从
    Play 商店下载的 APK，您需要将设备设置为允许 **安装未知应用**。该选项的位置因 Android 版本和您所使用的设备而异，但该选项通常位于 **安全**
    设置中。一些 Android 版本在安装 APK 时会提示您查看这些设置。
- en: 'Now, we can copy and install the generated APK build file every time we want
    to create a build. However, we can let Unity do that for us using the **Build
    and Run** button. This option, after building the app, will look for the first
    Android device connected to your computer via USB and will automatically install
    the app. For this to work, we need to prepare our device and PC, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们想要创建构建时，我们都可以复制并安装生成的APK构建文件。然而，我们可以让Unity为我们完成这项工作，使用**构建和运行**按钮。构建应用程序后，此选项将查找通过USB连接到您的电脑的第一个Android设备，并自动安装应用程序。为了使此功能正常工作，我们需要准备我们的设备和电脑，如下所示：
- en: 'On your device, find the build number in the **Settings** section of the device,
    whose location, again, can change depending on the device. On my device, it is
    located in the **About Phone | Software Information** section:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上，在**设置**部分找到构建号，其位置，再次提醒，可能会根据设备而变化。在我的设备上，它位于**关于手机 | 软件信息**部分：
- en: '![](img/B18585_20_23.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_23.png]'
- en: 'Figure 20.23: Locating the build number'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.23：定位构建号
- en: Tap it a few times until the device says you are now a programmer. This procedure
    enables the hidden developer option in the device, which you can now find in the
    settings.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻轻点击几次，直到设备告诉您您现在是一名程序员。此过程启用了设备中的隐藏开发者选项，您现在可以在设置中找到它。
- en: Open the developer options and turn on **USB Debugging**, which allows your
    PC to have special permissions on your device. In this case, it allows you to
    install apps.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者选项并开启**USB调试**，这允许您的电脑在您的设备上拥有特殊权限。在这种情况下，它允许您安装应用程序。
- en: Install the USB drivers from your phone manufacturer’s site onto your computer
    if using Windows. For example, if you have a Samsung device, search for `Samsung
    USB Driver`. Also, if you can’t find that, you can look for `Android USB Driver`
    to get the generic drivers, but that might not work if your device manufacturer
    has their own. On Mac, this step is usually not necessary.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用Windows，请从您的手机制造商的网站上安装USB驱动程序。例如，如果您有一部三星设备，请搜索`Samsung USB Driver`。另外，如果您找不到它，您可以查找`Android
    USB Driver`以获取通用驱动程序，但如果您的设备制造商有自己的驱动程序，这可能不起作用。在Mac上，此步骤通常不是必需的。
- en: 'Connect your device (or reconnect it if it’s already connected). The option
    to **Allow USB Debugging** for your computer will appear on the device. Check
    **Always Allow** and click **OK**:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的设备（如果尚未连接，请重新连接）。您的电脑将出现**允许USB调试**的选项。请选择**始终允许**并点击**确定**：
- en: '![Enabling USB Debugging on an Android Device](img/B18585_20_24.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![在Android设备上启用USB调试](img/B18585_20_24.png)'
- en: 'Figure 20.24: Allowing USB debugging'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.24：允许USB调试
- en: Accept the **Allow Data** prompt that appears.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受出现的**允许数据**提示。
- en: If these options don’t appear, check that the **USB Mode** of your device is
    set to **Debugging** and not any other.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些选项没有出现，请检查您的设备**USB模式**是否设置为**调试**，而不是其他任何模式。
- en: In Unity, build with the **Build and Run** button, and save the `apk` into a
    folder. Be patient because this will take a while the first time.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，使用**构建和运行**按钮进行构建，并将`apk`文件保存到文件夹中。请耐心等待，因为第一次可能需要一些时间。
- en: Please remember to try another image if you have trouble detecting the image
    where we instantiate the player (the Unity logo, in my case). This might vary
    a lot, according to your device’s capabilities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您在检测我们实例化玩家（以我的情况为例，是Unity标志）所在的位置时遇到问题，请尝试另一个镜像。这可能会根据您的设备功能有很大的不同。
- en: And that’s all! Now that you have your app running on your device, let’s learn
    how to do the same for the iOS platform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在您的应用程序已经在设备上运行，让我们学习如何为iOS平台做同样的事情。
- en: Building for iOS
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为iOS构建
- en: When developing on iOS, you will need to spend some money. You will need to
    run XCode, a piece of software you can only run on macOS X. Due to this, you’ll
    need a device that can run it, such as a MacBook, a Mac mini, and so on. There
    may be ways to run macOS X on PCs, but you will need to find this out and try
    it for yourself. Besides spending on a Mac and an iOS device (iPhone, iPad, iPod,
    and so on), you’ll need to pay for an Apple Developer account, which costs 99
    USD per year, but only if you are planning to release the game; for testing purposes,
    you can continue without it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上开发时，您可能需要花费一些钱。您需要运行XCode，这是一款只能在macOS X上运行的软件。因此，您需要一个可以运行它的设备，例如MacBook、Mac
    mini等。可能有在PC上运行macOS X的方法，但您需要自己找出并尝试。除了在Mac和iOS设备（iPhone、iPad、iPod等）上花费之外，您还需要为Apple开发者账户付费，每年99美元，但仅当您计划发布游戏时；用于测试目的，您可以继续使用。
- en: 'To create an AR Foundation iOS build, you should do the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建AR Foundation iOS构建，您应该执行以下操作：
- en: Get a Mac computer and an iOS device.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一台 Mac 电脑和一款 iOS 设备。
- en: Create an Apple Developer account (at the time of writing this book, you can
    create one at [https://developer.apple.com/](https://developer.apple.com/)).
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个苹果开发者账户（在撰写本书时，您可以在 [https://developer.apple.com/](https://developer.apple.com/)
    创建一个）。
- en: Install the latest XCode from the App Store onto your Mac.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 App Store 将最新版本的 XCode 安装到您的 Mac 上。
- en: Check if you have iOS build support in Unity Install on the Unity Hub. Please
    refer to the *Building for Android* section for more information about this step.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您在 Unity Hub 上的 Unity 安装中是否有 iOS 构建支持。有关此步骤的更多信息，请参阅 *为 Android 构建* 部分。
- en: 'Switch to the iOS platform under **Build Settings**, by selecting iOS and clicking
    the **Switch Platform** button:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **构建设置** 下切换到 iOS 平台，通过选择 iOS 并点击 **切换平台** 按钮：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_25.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18585_20_25.png)'
- en: 'Figure 20.25: Switching to iOS build'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.25：切换到 iOS 构建
- en: Go to **Edit | Project Settings** and select the **Player** option.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **编辑 | 项目设置** 并选择 **播放器** 选项。
- en: 'In **Other Settings**, set the **Camera Usage Description** property if not
    already. This will be a message shown to the user to tell them why we need access
    to their camera:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **其他设置** 中，如果尚未设置，请设置 **相机使用描述** 属性。这将是一个显示给用户的消息，告诉他们我们为什么需要访问他们的相机：
- en: '![](img/B18585_20_26.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_26.png)'
- en: 'Figure 20.26: Message regarding camera usage'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.26：关于相机使用的消息
- en: Go to **Edit | Project Settings** and select the **XR Plug-in Management** option.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **编辑 | 项目设置** 并选择 **XR 插件管理** 选项。
- en: 'Check **Apple ARKit** under **Plug-in Providers** to make sure it will be enabled
    in our build; if not, we won’t see anything:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件提供者** 下检查 **Apple ARKit** 以确保它在我们的构建中启用；如果没有，我们将看不到任何内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_20_27.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18585_20_27.png)'
- en: 'Figure 20.27: ARKit plugin enabled'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.27：ARKit 插件已启用
- en: Click the **Build** button in the **Build Settings** window, create a folder
    for the build, and wait for the build to finish. A folder containing the generated
    files should open when finished.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **构建设置** 窗口中点击 **构建** 按钮，创建一个构建文件夹，并等待构建完成。完成后，应打开一个包含生成文件的文件夹。
- en: 'You will notice that the result of the build process will be a folder containing
    an XCode project. Unity cannot create the build directly, so it generates a project
    you can open with the XCode software we mentioned previously. The step you need
    to follow to create a build with the XCode version being used in this book (13.4.1)
    are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到构建过程的结果将是一个包含 XCode 项目的文件夹。Unity 无法直接创建构建，因此它生成一个您可以使用我们之前提到的 XCode 软件打开的项目。您需要遵循以下步骤使用本书中使用的
    XCode 版本（13.4.1）创建构建：
- en: 'Double-click the `.xcodeproj` file inside the generated folder:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击生成文件夹内的 `.xcodeproj` 文件：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_28.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18585_20_28.png)'
- en: 'Figure 20.28: XCode project file'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.28：XCode 项目文件
- en: Go to **XCode | Preferences**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **XCode | 首选项**。
- en: 'In the **Accounts** tab, hit the **+** button at the bottom-left part of the
    window and log in with the Apple account you registered as an Apple developer:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **账户** 选项卡中，点击窗口左下角的 **+** 按钮，并使用您注册为苹果开发者的苹果账户登录：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_29.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18585_20_29.png)'
- en: 'Figure 20.29: Account settings'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.29：账户设置
- en: 'Connect your device and select it from the top-left part of the window, which
    should now say **Any iOS device**. You might need to unblock your device first,
    click on the **Trust** button, and wait for XCode to finish setting up your device
    to see your device in the list:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备，并从窗口的左上角选择它，现在应该显示为 **任何 iOS 设备**。您可能需要首先解除设备的锁定，点击 **信任** 按钮，并等待 XCode
    完成设置您的设备，以便在列表中看到您的设备：
- en: '![](img/B18585_20_30.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_30.png)'
- en: 'Figure 20.30: Selecting the device'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.30：选择设备
- en: XCode might ask you to install certain updates to support your device; please
    install them if needed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XCode 可能会要求您安装某些更新以支持您的设备；如果需要，请安装它们。
- en: In the left panel, click the folder icon and then the **Unity-iPhone** settings
    to display the project settings.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，点击文件夹图标，然后点击 **Unity-iPhone** 设置以显示项目设置。
- en: From the **TARGETS** list, select **Unity-iPhone** and click on the **Signing
    & Capabilities** tab.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**目标**列表中选择**Unity-iPhone**，然后点击**签名与能力**选项卡。
- en: Check **Automatically manage signing** and click on the **Enable Automatic**
    button on the prompt.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**自动管理签名**，并在提示中点击**启用自动**按钮。
- en: In the **Team** settings, select the option that says **Personal Team**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**团队**设置中，选择显示为**个人团队**的选项。
- en: If you see a **Failed to register bundle identifier** error, just change the
    **Bundle Identifier** setting for another one, always respecting the format (`com.XXXX.XXXX`),
    and then click on **Try Again** until it is solved.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看到“**无法注册包标识符**”错误，只需更改**包标识符**设置为其它的一个，始终遵守格式（`com.XXXX.XXXX`），然后点击**重试**直到问题解决。
- en: 'Once you find one that works, set it in Unity (**Bundle Identifier** under
    **Player Settings**) to avoid needing to change it in every build:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个可以工作的，将其设置在Unity中（在**玩家设置**下的**包标识符**）以避免在每次构建时都需要更改它：
- en: '![](img/B18585_20_31.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_20_31.png)'
- en: 'Figure 20.31: Setting up your iOS project'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.31：设置您的iOS项目
- en: Hit the **Play** button at the top-left part of the window and wait for the
    build to complete. You might be prompted to enter your password a couple of times
    in the process, so please do so.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**播放**按钮，等待构建完成。在这个过程中，您可能需要输入密码几次，所以请这样做。
- en: When the build completes, remember to unlock the device. A prompt will ask you
    to do that. Note that the process won’t continue unless you unlock the phone.
    If that fails click **Cancel Running** and try again, this time with the device
    unlocked; remember to select your device in the list again. Also, try to use the
    latest XCode available to support the latest iOS versions installed on your device.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当构建完成时，请记住解锁设备。会出现一个提示要求您这样做。请注意，除非您解锁手机，否则进程不会继续。如果失败，请点击**取消运行**并再次尝试，这次确保设备已解锁；请记住再次在列表中选择您的设备。此外，尝试使用最新的XCode以支持设备上安装的最新iOS版本。
- en: If you see a **Fetching Debug Symbols** prompt that never ends, restart your
    device.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看到一个**获取调试符号**提示，它永远不会结束，请重新启动您的设备。
- en: After completion, you may see an error saying that the app couldn’t be launched
    but that it was installed anyway. If you try to open it, it will say you need
    to trust the developer of the app, which you can do by going to the settings of
    your device.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可能会看到一个错误，表示应用无法启动，但它已经被安装。如果您尝试打开它，它将告诉您需要信任该应用的开发者，您可以通过访问设备的设置来完成此操作。
- en: From there, go to **General | VPN & Device Management** and select the first
    developer in the list.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，转到**通用 | VPN与设备管理**并选择列表中的第一个开发者。
- en: Click the blue **Trust…** button and then **Trust**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色**信任…**按钮，然后**信任**。
- en: Try to open the app again.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次打开应用。
- en: Please remember to try another image if you’re having trouble detecting the
    image where we instantiate the player (the pebbles image, in my case). This might
    vary a lot, depending on your device’s capabilities.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在检测我们实例化播放器（我的情况是鹅卵石图像）的图像时遇到困难，请记得尝试另一张图像。这可能会因您的设备功能而大不相同。
- en: In this section, we discussed how to build a Unity project that can run on iOS
    and Android, thus allowing us to create mobile apps—AR mobile apps, specifically.
    Like any build, there are methods we can follow to profile and debug, as we saw
    when we looked at PC builds, but we are not going to discuss that here. Now that
    we have created our first test project, we will convert it into a real game by
    adding some mechanics to it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何构建一个可以在iOS和Android上运行的Unity项目，从而允许我们创建移动应用——具体来说是AR移动应用。像任何构建一样，我们可以遵循一些方法来分析和调试，就像我们在查看PC构建时看到的那样，但在这里我们不会讨论这一点。现在我们已经创建了第一个测试项目，我们将通过添加一些机制来将其转换为真正的游戏。
- en: Creating a simple AR game
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: As we discussed previously, the idea is to create a simple game where we can
    move our player while moving a real-life image, and also put in some enemy spawners
    by just tapping where we want them to be, such as a wall, the floor, a table,
    and so on. Our player will automatically shoot at the nearest enemy, and the enemies
    will shoot directly at the player, so our only task will be to move the player
    so that they avoid bullets. We are going to implement these game mechanics using
    scripts very similar to the ones we used in this book’s main project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，想法是创建一个简单的游戏，我们可以移动我们的玩家，同时移动一个现实生活中的图像，并且只需轻触我们想要它们出现的位置，例如墙壁、地板、桌子等，就可以放入一些敌人生成器。我们的玩家将自动射击最近的敌人，而敌人将直接射击玩家，因此我们唯一的任务就是移动玩家以避免子弹。我们将使用与本书主要项目中使用的脚本非常相似的脚本来实现这些游戏机制。
- en: 'In this section, we will develop the following AR game features:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发以下 AR 游戏功能：
- en: Spawning the player and enemies
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成玩家和敌人
- en: Coding the player and enemy behavior
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写玩家和敌人行为代码
- en: First, we are going to discuss how to make our player and enemies appear on
    the app, specifically in real-world positions, and then we will make them move
    and shoot each other to create the specified gameplay mechanics. Let’s start with
    **spawning**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何让我们的玩家和敌人出现在应用中，具体是在现实世界的位置，然后我们将让它们移动并互相射击以创建特定的游戏机制。让我们从**生成**开始。
- en: Spawning the player and enemies
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成玩家和敌人
- en: 'The first thing we need to do in order to implement our game’s gameplay is
    to spawn objects to interact with. Let’s start with the player, since that’s the
    easiest one to deal with: we will create a Prefab with the graphics we want the
    player to have (in my case, just a cube), a `Rigidbody` with **Is Kinematic**
    checked (the player will move), and an **AR Tracked Image** script. We will set
    that Prefab as them **Tracked Image Prefab** of the **AR Tracked Image Manager**
    component in the **XR Origin** object. This will put the player on the tracked
    image. Remember to set the size of the player in terms of real-life sizes. In
    my case, I scaled the player to `0.05`, `0.05`, `0.05`. Since the original cube
    is 1 meter in size, this means that my player will be *5x5x5* centimeters.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的游戏玩法，我们首先需要生成可以与之交互的对象。让我们从玩家开始，因为那是最容易处理的一个：我们将创建一个 Prefab，其中包含我们想要玩家拥有的图形（在我的情况下，只是一个立方体），一个带有**是运动学**复选框的
    `Rigidbody`（玩家将会移动），以及一个**AR 跟踪图像**脚本。我们将该 Prefab 设置为**XR 原点**对象中**AR 跟踪图像管理器**组件的**跟踪图像
    Prefab**。这将使玩家出现在跟踪图像上。请记住，根据现实生活中的尺寸设置玩家的尺寸。在我的情况下，我将玩家缩放到 `0.05`、`0.05`、`0.05`。由于原始立方体的尺寸是
    1 米，这意味着我的玩家将是 *5x5x5* 厘米。
- en: 'Your **Player** Prefab should look as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**玩家**Prefab 应该看起来如下：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_20_32.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18585_20_32.png)'
- en: 'Figure 20.32: The starting “Player” Prefab'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.32：起始的“玩家”Prefab
- en: 'The enemies will require a little bit more work, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人需要做更多的工作，如下所示：
- en: Create a Prefab called `Spawner` with the graphic you want your spawner to have
    (in my case, a cylinder) and its real-life size (small scale).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Spawner` 的 Prefab，其中包含你想要你的生成器拥有的图形（在我的情况下是一个圆柱体）及其现实生活尺寸（小尺寸）。
- en: Add a custom script that spawns a Prefab every few seconds, such as the one
    shown in the following screenshot.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个每几秒生成一个 Prefab 的自定义脚本，例如以下截图所示。
- en: 'You will notice the usage of `Physics.IgnoreCollision` to prevent the `Spawner`
    GameObject from colliding with the spawned GameObject, getting the colliders of
    both objects, and passing them to the function. You can also use the **Layer Collision
    Matrix** to prevent collisions, just like we did in this book’s main project,
    if you prefer to:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到使用 `Physics.IgnoreCollision` 来防止 `Spawner` GameObject 与生成的 GameObject 发生碰撞，获取两个物体的碰撞器，并将它们传递给函数。你也可以使用**层碰撞矩阵**来防止碰撞，就像我们在本书的主要项目中做的那样，如果你愿意的话：
- en: '![](img/B18585_20_33.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_33.png)'
- en: 'Figure 20.33: Spawner script'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.33：生成器脚本
- en: Create an `Enemy` Prefab with the desired graphic (a capsule, in my case) and
    a `Rigidbody` component with the **Is Kinematic** checkbox checked. This way,
    the enemy will move but not with physics. Remember to consider the real-life size
    of the enemy.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需图形（在我的情况下是一个胶囊）和带有**是运动学**复选框的 `Rigidbody` 组件的**敌人**Prefab。这样，敌人将会移动，但不会使用物理。请记住考虑敌人的现实生活尺寸。
- en: 'Set the **Prefab** property of the Spawner so that it spawns our enemy at our
    desired time frequency:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Spawner的**Prefab**属性，以便它在期望的时间频率下生成我们的敌人：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_20_34.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  描述自动生成](img/B18585_20_34.png)'
- en: 'Figure 20.34: Configuring the Spawner'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.34：配置Spawner
- en: Set the Prefab of `SpawnerPlacer` in the XR Origin object so that it spawns
    the **Spawner** Prefab we created earlier.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XR Origin对象中设置`SpawnerPlacer`的Prefab，以便它生成我们之前创建的**Spawner**Prefab。
- en: And that’s all for the first part. If you test the game now, you will be able
    to tap on the detected planes in the app and see how the Spawner starts creating
    enemies. You can also look at the target image and see our cube player appear.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，第一部分就完成了。如果你现在测试游戏，你将能够点击应用中检测到的平面，并看到Spawner开始创建敌人。你还可以查看目标图像，并看到我们的立方体玩家出现。
- en: Now that we have the objects in the scene, let’s make them do something more
    interesting, starting with the enemies.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中有对象了，让我们让它们做一些更有趣的事情，从敌人开始。
- en: Coding the player and enemy behavior
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家和敌人行为
- en: The Enemy must move toward the player in order to shoot at them, so it will
    need to have access to the player’s position. Since the enemy is instantiated,
    we cannot drag the player reference to the Prefab. However, the player has also
    been instantiated, so we can add a `PlayerManager` script to the player that uses
    the `Singleton` pattern (as we did in *Chapter 8*, *Win and Lose Conditions*).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了射击玩家，敌人必须朝玩家移动，因此它需要访问玩家的位置。由于敌人是实例化的，我们无法将玩家引用拖动到Prefab中。然而，玩家也已经实例化了，因此我们可以向玩家添加一个使用`Singleton`模式（如我们在第8章*赢和输的条件*中所述）的`PlayerManager`脚本。
- en: 'To do that, follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: 'Create a `PlayerManager` script similar to the one shown in the following screenshot
    and add it to the player:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图中的`PlayerManager`脚本并将其添加到玩家中：
- en: '![](img/B18585_20_35.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_35.png](img/B18585_20_35.png)'
- en: 'Figure 20.35: Creating the PlayerManager script'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.35：创建PlayerManager脚本
- en: 'Now that the enemy has a reference to the player, let’s make them look at the
    player by adding a `LookAtPlayer` script, as shown here:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在敌人有了玩家的引用，让我们通过添加一个`LookAtPlayer`脚本，如图所示，让它们看向玩家：
- en: '![](img/B18585_20_36.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_36.png](img/B18585_20_36.png)'
- en: 'Figure 20.36: Creating the LookAtPlayer script'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.36：创建LookAtPlayer脚本
- en: 'Also, add a simple `MoveForward` script like the one shown in the following
    screenshot to make the **enemy** not only look at the player but also move toward
    them. Since the `LookAtPlayer` script is making the enemy face the player, this
    script moving along the *Z* axis is just enough:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加一个类似于以下截图中的简单`MoveForward`脚本，使**敌人**不仅看向玩家，而且朝他们移动。由于`LookAtPlayer`脚本使敌人面向玩家，因此沿着*Z*轴移动的脚本就足够了：
- en: '![](img/B18585_20_37.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_37.png](img/B18585_20_37.png)'
- en: 'Figure 20.37: Creating the MoveForward script'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.37：创建MoveForward脚本
- en: 'Now, we will take care of the player movement. Remember that our player is
    controlled by moving the image, so here, we are actually referring to the rotation,
    since the player will need to automatically look and shoot at the nearest enemy.
    To do this, follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理玩家移动。记住，我们的玩家是通过移动图像来控制的，因此在这里，我们实际上是在指旋转，因为玩家需要自动朝向最近的敌人看和射击。为此，请按照以下步骤操作：
- en: Create an `Enemy` script and add it to the **Enemy** Prefab.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Enemy`脚本并将其添加到**Enemy**Prefab中。
- en: 'Create an `EnemyManager` script like the one shown in the following screenshot
    and add it to an empty `EnemyManager` object in the scene:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图中的`EnemyManager`脚本并将其添加到场景中的空`EnemyManager`对象中：
- en: '![](img/B18585_20_38.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_38.png](img/B18585_20_38.png)'
- en: 'Figure 20.38: Creating the EnemyManager script'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.38：创建EnemyManager脚本
- en: 'In the `Enemy` script, make sure to register the object in the **all** list
    of `EnemyManager`, as we did previously with `WavesManager` in this book’s main
    project:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemy`脚本中，确保将对象注册到`EnemyManager`的**all**列表中，就像我们在本书的主要项目中使用`WavesManager`时那样：
- en: '![](img/B18585_20_39.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_39.png](img/B18585_20_39.png)'
- en: 'Figure 20.39: Creating the Enemy script'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.39：创建Enemy脚本
- en: 'Create a `LookAtNearestEnemy` script like the one shown in the following screenshot
    and add it to the **Player** Prefab to make it look at the nearest enemy:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图中的`LookAtNearestEnemy`脚本并将其添加到**Player**Prefab中，使它看向最近的敌人：
- en: '![](img/B18585_20_40.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_20_40.png](img/B18585_20_40.png)'
- en: 'Figure 20.40: Looking at the nearest Enemy'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.40：看向最近的敌人
- en: 'Now that our objects are rotating and moving as expected, the only thing missing
    is shooting and damaging:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们物体按预期旋转和移动，唯一缺少的是射击和造成伤害：
- en: 'Create a `Life` script like the one shown in the following screenshot and add
    it to both the **Player** and **Enemy** components. Remember to set a value for
    the amount of life field. You will see this version of `Life` instead of needing
    to check if the life reached zero every frame. We have created a `Damage` function
    to check that damage is dealt (the `Damage` function is executed), but the other
    version of this book’s project also works:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图所示的 `Life` 脚本，并将其添加到 **Player** 和 **Enemy** 组件中。请记住设置生命值字段的数量。你将看到这个版本的
    `Life`，而不是需要每帧检查生命值是否达到零。我们创建了一个 `Damage` 函数来检查是否造成了伤害（`Damage` 函数被执行），但本书项目的另一个版本也有效：
- en: '![](img/B18585_20_41.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_41.png)'
- en: 'Figure 20.41: Creating a Life component'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.41：创建生命组件
- en: Create a `Bullet` Prefab with the desired graphics, the collider with the **Is
    Trigger** checkbox on the collider checked, a `Rigidbody` component with **Is
    Kinematic** checked (a kinematic trigger collider), and the proper real-life size.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有所需图形的 `Bullet` 预制件，将碰撞器的 **Is Trigger** 复选框勾选，添加一个带有 **Is Kinematic**
    勾选的 `Rigidbody` 组件（一个运动学触发碰撞器），以及适当的真实尺寸。
- en: Add the `MoveForward` script to the **Bullet** Prefab to make it move. Remember
    to set the speed.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MoveForward` 脚本添加到 **Bullet** 预制件中，使其能够移动。请记住设置速度。
- en: Add a `Spawner` script to both the **Player** and the **Enemy** components and
    set the **Bullet** Prefab as the Prefab to spawn, as well as the desired spawn
    frequency.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Spawner` 脚本添加到 **Player** 和 **Enemy** 组件中，并将 **Bullet** 预制件设置为要实例化的预制件，以及所需的生成频率。
- en: 'Add a `Damager` script like the one shown in the following screenshot to the
    **Bullet** Prefab to make bullets inflict damage on the objects they touch. Remember
    to set the damage:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类似于以下截图所示的 `Damager` 脚本添加到 **Bullet** 预制件中，使子弹对其接触的物体造成伤害。请记住设置伤害值：
- en: '![](img/B18585_20_42.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_42.png)'
- en: 'Figure 20.42: Creating a Damager script – part 1'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.42：创建伤害脚本 – 第 1 部分
- en: 'Add an `AutoDestroy` script like the one shown in the following screenshot
    to the **Bullet** Prefab to make it despawn after a while. Remember to set the
    destroy time:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类似于以下截图所示的 `AutoDestroy` 脚本添加到 **Bullet** 预制件中，使其在一段时间后消失。请记住设置销毁时间：
- en: '![](img/B18585_20_43.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_20_43.png)'
- en: 'Figure 20.43: Creating a Damager script – part 2'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.43：创建伤害脚本 – 第 2 部分
- en: And that’s all! As you can see, we basically created a new game using almost
    the same scripts we used in the main game, mostly because we designed them to
    be generic (and the game genres are almost the same). Of course, this project
    can be improved a lot, but we have a nice base project to create amazing AR apps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 和此同时！正如你所见，我们基本上使用与主游戏几乎相同的脚本创建了一个新游戏，主要是因为我们设计它们时要通用（而且游戏类型几乎相同）。当然，这个项目可以有很多改进，但我们有一个很好的基础项目来创建令人惊叹的
    AR 应用。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the AR Foundation Unity framework, explored how
    to set it up, and how to implement several tracking features so that we can position
    virtual objects on top of real-life objects. We also discussed how to build our
    project so that it can run on both iOS and Android platforms, which is the only
    way we can test our AR apps at the time of writing. Finally, we created a simple
    AR game based on the game we created in the main project but modified it so that
    it’s suitable for use in AR scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 AR Foundation Unity 框架，探讨了如何设置它，以及如何实现几个跟踪功能，以便我们可以在真实生活物体上定位虚拟物体。我们还讨论了如何构建我们的项目，使其能够在
    iOS 和 Android 平台上运行，这是我们在撰写本文时测试 AR 应用的唯一方式。最后，我们基于主项目中创建的游戏创建了一个简单的 AR 游戏，但对其进行了修改，使其适合在
    AR 场景中使用。
- en: With this new knowledge, you will be able to start your path as an AR app developer,
    creating apps that augment real objects with virtual objects by detecting the
    positions of the real objects. This can be applied to games, training apps, and
    simulations. You may even be able to find new fields of usage, so take advantage
    of this new technology and its new possibilities!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些新知识，你将能够开始你的 AR 应用开发者之路，通过检测真实物体的位置，创建将虚拟物体添加到真实物体上的应用。这可以应用于游戏、培训应用和模拟。你甚至可能找到新的应用领域，所以利用这项新技术及其新可能性吧！
- en: 'Well, this is the end of this journey through Unity 2022\. I’m really glad
    you reached this point in the book. I hope this knowledge will help you to improve
    or start your game development career with one of the most versatile and powerful
    tools on the market: Unity. I hope to see your creations someday! See you on the
    road!'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是通过Unity 2022的旅程的终点了。我真的很高兴你在书中达到了这个阶段。我希望这些知识能帮助你利用市场上最灵活和强大的工具之一：Unity，来提升或开始你的游戏开发生涯。我希望有一天能看到你的作品！路上见！
