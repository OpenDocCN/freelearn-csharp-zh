- en: Chapter 6. Plotting Mathematical Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 绘制数学表达式
- en: 'In this chapter, we will create an application which will plot arbitrary mathematical
    expressions on a **Windows Presentation Foundation** (**WPF**)-based graphical
    surface. We will be using the GoF observer pattern for wiring expression input
    control and the rendering surface. In the process, we will develop a library which
    can evaluate arbitrary arithmetic expressions on the fly. The expression evaluator
    will support basic arithmetic operators (`+`, `-`, `*`, `/`, unary `+`/`-` ),
    trigonometric functions, and a pseudo variable (`$t`) which can represent the
    value of X-axis in a 2D Plane. During the course of this chapter, as a reader,
    you will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个应用程序，该程序将在基于**Windows Presentation Foundation**（**WPF**）的图形表面上绘制任意数学表达式。我们将使用GoF观察者模式来连接表达式输入控制和渲染表面。在这个过程中，我们将开发一个库，该库可以即时评估任意算术表达式。表达式评估器将支持基本的算术运算符（`+`、`-`、`*`、`/`、一元`+`/`-`），三角函数，以及一个伪变量（`$t`），它可以表示二维平面中X轴的值。在本章的整个过程中，作为读者，你将学习以下内容：
- en: The observer pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Parsing mathematical expressions using recursive descent
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归下降解析数学表达式
- en: Modeling **abstract syntax tree** (**AST**) as a composite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**抽象语法树**（**AST**）建模为组合
- en: The interpreter pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The builder pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者模式
- en: Elementary WPF 2D graphics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础WPF 2D图形
- en: Requirements for the expressions library and app
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式库和应用程序的要求
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirement statement, which is as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写库之前，让我们草拟一个初步的需求声明，如下所示：
- en: The ability to plot the result of arbitrary mathematical expressions is a common
    requirement for business applications. We need to parse an expression to evaluate
    the resulting tree-structured representation. The process of lexical analysis,
    parsing, modeling expression nodes, recursive evaluation, and so on should be
    opaque to the application programmer. The library should support some trigonometric
    functions and a variable (`$t`) to pass the information of the current X-coordinate
    of the graphics surface. The application should evaluate the value of the Y-coordinate
    for each value of the X-coordinate passed to the expression evaluation engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 能够绘制任意数学表达式的结果是商业应用程序的常见要求。我们需要解析表达式以评估结果树形表示。词法分析、解析、建模表达式节点、递归评估等过程应该对应用程序程序员是透明的。库应支持一些三角函数和一个变量（`$t`），以传递图形表面的当前X坐标信息。应用程序应评估传递给表达式评估引擎的每个X坐标值的Y坐标值。
- en: Solutions approach
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: 'We will divide the requirement into the two following parts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需求分为以下两个部分：
- en: A library for evaluating arbitrary mathematical expressions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于评估任意数学表达式的库
- en: An application which will consume the aforementioned library to plot data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将消耗上述库以绘制数据的程序
- en: 'The expression evaluator library requirements can be enumerated as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式评估库的要求可以列举如下：
- en: Modeling expressions as AST
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表达式建模为AST
- en: Writing a lexical analyzer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写词法分析器
- en: Writing a recursive descent parser
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写递归下降解析器
- en: Depth first walk of the tree
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的深度优先遍历
- en: Supporting trigonometric functions and pseudo variable (`$`)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持三角函数和伪变量（`$`）
- en: Packaging everything as a facade pattern-based API
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切打包为基于外观模式的API
- en: 'The application requirements can be enumerated as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的要求可以列举如下：
- en: A screen with a WPF 2D graphics surface
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有WPF 2D图形表面的屏幕
- en: A prompt for entering expressions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入表达式的提示
- en: Implementation of the observer for detecting a new plot request
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用于检测新绘图请求的观察者
- en: Passing the value to the expressions library for change in the X-coordinate
    value
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值传递给表达式库以改变X坐标值
- en: Rendering the resulting value
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染结果值
- en: The graph plotter application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形绘制应用程序
- en: 'The graph plotter application is a simple WPF application with a canvas and
    a textbox in the frame. The following image gives a snapshot of the screen after
    the screen has rendered the result of an expression:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图形绘制应用程序是一个简单的WPF应用程序，其中包含一个画布和一个文本框。以下图像显示了屏幕渲染表达式结果后的快照：
- en: '![The graph plotter application](img/B05691_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图形绘制应用程序](img/B05691_06_01.jpg)'
- en: 'The WPF canvas gets a notification whenever there is a change in the expression
    textbox. If the expression in the textbox is valid, the graph will be plotted
    as shown in the preceding image. We will deal with the nuances of implementing
    an expression evaluation engine in the following sections. The following code
    snippet shows how the change in text gets handled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式文本框中的表达式发生变化时，WPF 画布会收到通知。如果文本框中的表达式有效，图表将如图所示绘制。我们将在以下章节中处理实现表达式评估引擎的细微差别。以下代码片段显示了如何处理文本的变化：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The observer pattern for UI events
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 事件的观察者模式
- en: We will use the GoF observer pattern to handle UI events in an automatic fashion.
    The moment an expression gets changed in the textbox, the window should get a
    notification about it, and if the expression is valid, the resulting expression
    will be rendered on the screen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GoF 观察者模式自动处理 UI 事件。当文本框中的表达式发生变化时，窗口应该收到有关此变化的通知，如果表达式有效，结果表达式将在屏幕上渲染。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While implementing the observer pattern, we have two classes-the `Subject` class,
    which represents the event source, and the `Observer` class, which is a list of
    observers (observer who are interested in listening to the event. Whenever there
    is a change in the text, the `Subject` class which represents the event source
    sends notification to all the sinks who have subscribed to the event.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现观察者模式时，我们有两个类——`Subject` 类，它表示事件源，以及 `Observer` 类，它是一系列观察者（对监听事件感兴趣的观察者）。每当文本发生变化时，代表事件源的
    `Subject` 类将向所有已订阅事件的接收者发送通知。
- en: 'We have already mentioned that in the case of the observer pattern, we communicate
    between the event source and event sinks. The event source is represented using
    the `Subject` class, and the event sink is represented using an `Observer` class.
    Let us dissect the implementation of the `Observer` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，在观察者模式的情况下，我们在事件源和事件接收者之间进行通信。事件源用 `Subject` 类表示，事件接收者用 `Observer` 类表示。让我们分析
    `Observer` 类的实现：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We declare a delegate which will act as an event handler, and to make the class
    handle all the WPF controls, we mark the event subscriber as a WPF control. The
    concrete class can hold any object derived from `Control`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个委托，它将充当事件处理器，为了使类处理所有 WPF 控件，我们将事件订阅者标记为 WPF 控件。具体的类可以持有从 `Control` 派生的任何对象：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the constructor, we initialize the delegate with an address of an abstract
    method. This will automatically get wired to the concrete class implementation
    of the method. We are, effectively, using the GoF template method pattern for
    the observer implementation. The concrete class is mandated to implement the `Observer_ExpressionChangedEvent`
    method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用抽象方法的地址初始化委托。这将自动将其连接到具体类的该方法实现。实际上，我们正在使用 GoF 模板方法模式来实现观察者。具体类必须实现
    `Observer_ExpressionChangedEvent` 方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will try to write the `Subject` class which acts as an event source.
    The `Subject` class will iterate through the list of observers to dispatch the
    events which the observers are interested in. Any change in the expression textbox
    will be relayed to the window object, which acts as a receiver of the events:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试编写 `Subject` 类，它充当事件源。`Subject` 类将遍历观察者列表以分发观察者感兴趣的事件。表达式文本框的任何变化都将传递给窗口对象，该对象充当事件的接收者：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `BaseObserver` class given in the preceding code snippet is an abstract
    class, and we need to create a concrete class which implements `Observer_ExpressionChangedEvent`.
    The concrete implementation listing is given as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码片段中给出的 `BaseObserver` 类是一个抽象类，我们需要创建一个具体的类来实现 `Observer_ExpressionChangedEvent`。具体的实现列表如下：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let us see how we can connect the `Subject` and `Observer` class. See the `MainWindow.cs`
    module in the source code associated with this book. A snippet of the code is
    given as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何连接 `Subject` 和 `Observer` 类。参见与此书相关的源代码中的 `MainWindow.cs` 模块。以下是一段代码的示例：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whenever there is change in the text, the rendering routine will be notified.
    The rendering routine uses WPF 2D graphics transformations to plot the equation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本发生变化时，渲染例程将被通知。渲染例程使用 WPF 2D 图形变换来绘制方程式：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The expression evaluator and interpreter pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式评估器和解释器模式
- en: The authors of this book believe that any programmer worth his salt needs to
    learn the rudiments of compiler construction for implementing mini-languages or
    **domain-specific language** (**DSL**) in his work. A compiler treats expressions
    as data, and expressions are mostly hierarchical in nature. We use a data structure
    called AST for representing the nodes of an expression tree. To convert textual
    expressions into an AST, we need to write a parser to analyze the constituents
    of an expression. The subsystem which feeds data to the parser is a module called
    lexical analyzer, which breaks the input stream into a series of tokens.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书作者认为，任何值得尊敬的程序员都需要学习编译构造的基础知识，以便在其工作中实现微型语言或**领域特定语言**（**DSL**）。编译器将表达式视为数据，而表达式在本质上大多是分层的。我们使用一种称为抽象语法树（AST）的数据结构来表示表达式树的节点。要将文本表达式转换为AST，我们需要编写一个解析器来分析表达式的组成部分。向解析器提供数据的子系统是一个名为词法分析器的模块，它将输入流分解成一系列标记。
- en: The definition of a mini language, and writing an evaluator for it, is dealt
    with by the GoF catalog as interpreter pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GoF 目录将微型语言的定义及其评估器的编写视为解释器模式。
- en: In software design, the interpreter pattern is a design pattern that specifies
    how to evaluate sentences in a (mini) language. The basic idea is to have a class
    for each symbol (terminal or non-terminal) in a specialized computer language.
    In our case, we use a mini language with double precision floating point numbers,
    a symbolic variable (`$t`), trigonometric functions (sine/cosine), and basic arithmetic
    operators. The syntax tree of a sentence in the language is an instance of the
    composite pattern, and is used to evaluate (interpret) the sentence for a client.
    Some expressions which we handle are *2*3 + SIN($t)*2*, *$t*100*, *COS((3.14159/2)
    - $t)*, and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中，解释器模式是一种设计模式，它指定了如何在（微型）语言中评估句子。基本思想是为专用计算机语言中的每个符号（终结符或非终结符）创建一个类。在我们的情况下，我们使用一个带有双精度浮点数、符号变量（`$t`）、三角函数（正弦/余弦）和基本算术运算符的微型语言。该语言的句子语法树是组合模式的实例，用于评估（解释）客户端的句子。我们处理的一些表达式包括`2*3
    + SIN($t)*2`、`$t*100`、`COS((3.14159/2) - $t)`等。
- en: The abstract syntax tree (AST)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象语法树 (AST)
- en: In computer science, an AST, or just syntax tree, is a tree representation of
    the abstract (simplified) syntactic structure of the source code. Each node of
    the tree denotes a construct of the programming language under consideration.
    In our expression evaluator, the nodes are numeric values (IEEE 754 floating points),
    binary operators, unary operators, trigonometric functions, and a variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，AST（或简称语法树）是源代码抽象（简化）语法结构的树形表示。树中的每个节点表示正在考虑的编程语言的构造。在我们的表达式评估器中，节点是数值（IEEE
    754 浮点数）、二元运算符、一元运算符、三角函数和一个变量。
- en: 'The syntax is abstract in the sense that it does not represent every detail
    that appears in the real syntax. For instance, grouping parentheses is implicit
    in the tree structure, and AST data structure discards parentheses. Before we
    model the AST, let us see some expressions and its AST representations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 语法在抽象意义上并不代表真实语法中出现的每个细节。例如，分组括号在树结构中是隐含的，AST 数据结构忽略了括号。在我们建模AST之前，让我们看看一些表达式及其AST表示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![The abstract syntax tree (AST)](img/B05691_06_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![抽象语法树 (AST)](img/B05691_06_02.jpg)'
- en: The preceding example uses two node types, that is, `NumericConstant`, `BinaryExp`.
    Even the simplest expression creates a structure which seems a bit complicated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用了两种节点类型，即`NumericConstant`和`BinaryExp`。即使是最简单的表达式也会创建一个看似有些复杂的结构。
- en: 'Let us look at an expression which has a unary operator as well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个包含一元运算符的表达式：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![The abstract syntax tree (AST)](img/B05691_06_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![抽象语法树 (AST)](img/B05691_06_03.jpg)'
- en: 'Since our expression evaluator only supports a single variable, we create a
    context class which will store the variable in question. The class is named `RUNTIME_CONTEXT`,
    and the whole listing is given as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的表达式评估器只支持一个变量，我们创建了一个上下文类，该类将存储相关的变量。该类名为`RUNTIME_CONTEXT`，整个列表如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In any programming language, expression is what you evaluate for its value.
    This can be modeled as an abstract class. The numeric value which we support is
    of the type IEEE 754 double precision floating point:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，表达式是你评估其值的内容。这可以建模为一个抽象类。我们支持的数值类型是IEEE 754 双精度浮点数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The expression evaluator supports operators like `PLUS` (+), `MINUS` (-), `DIV`
    (/), and `MUL` (*). They are modeled using an enumerated type named `OPERATOR`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式评估器支持像 `PLUS` (+), `MINUS` (-), `DIV` (/), 和 `MUL` (*) 这样的运算符。它们使用名为 `OPERATOR`
    的枚举类型进行建模：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will start by creating a hierarchy of nodes for modeling an expression.
    We use the composite pattern to compose bigger expressions out of smaller ones:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个节点层次结构来模拟表达式。我们使用组合模式将较大的表达式从较小的表达式组合出来：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `NumericConstant` class can store an IEEE 754 double precision floating
    point value in it. This is a leaf node in the AST:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumericConstant` 类可以在其中存储 IEEE 754 双精度浮点值。这是 AST 中的一个叶节点：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `BinaryExp` class models a binary expression which takes two expressions
    (`ex1` for the left node and `ex2` for the right node), it applies the operator
    on both, the left-side value and the right-side value, inside the evaluate routine:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryExp` 类模拟一个二元表达式，它接受两个表达式（`ex1` 用于左节点和 `ex2` 用于右节点），在评估例程中对两个值（左侧值和右侧值）应用运算符：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the case of unary expressions, we take an operator and an `Exp` node as
    a child:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元表达式的情形下，我们取一个运算符和一个 `Exp` 节点作为子节点：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The sine node takes an expression as a child. We evaluate `_ex1`, and invoke
    `Math.Sin` on the resulting value:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦节点接受一个表达式作为子节点。我们评估 `_ex1`，并在结果值上调用 `Math.Sin`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The cosine node takes an expression as a child. We evaluate `_ex1`, and invoke
    `Math.Cos` on the resulting value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦节点接受一个表达式作为子节点。我们评估 `_ex1`，并在结果值上调用 `Math.Cos`：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And finally, the variables (`$t`) are modeled as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，变量（`$t`）被建模如下：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The grammar of expressions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式语法
- en: 'The **Backus-Naur Form** (**BNF**) notation is used to specify the grammar
    for programming languages. The semantics of BNF can be learned from books, and
    plenty of material is available. The grammar of the expression evaluator we use
    is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**巴科斯-诺尔范式**（**BNF**）符号用于指定编程语言的语法。可以从书籍中学习 BNF 的语义，并且有大量的资料可用。我们使用的表达式评估器的语法如下：'
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This BNF can be converted to source code very easily.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种巴科斯-诺尔范式（BNF）可以很容易地转换为源代码。
- en: Lexical analysis
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法分析
- en: 'The lexical analyzer groups characters into tokens including `''+''`, `''-''`,
    `''/''`, `''*''`, `SIN`, `COS`, and so on. In the process, the module feeds the
    parser when a request is made to it. Rather than doing a lexical scan of the entire
    input, the parser requests the next token from the lexical analyzer. In our expression
    evaluator, the following tokens are returned by the lexical analyzer upon request
    for the next token by the parser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器将字符分组为标记，包括 `'+'`, `'-'`, `'/'`, `'*'`, `SIN`, `COS` 等。在这个过程中，当模块被请求时，它会向解析器提供模块。解析器不是对整个输入进行词法扫描，而是从词法分析器请求下一个标记。在我们的表达式评估器中，以下标记是由词法分析器在解析器请求下一个标记时返回的：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The lexical analyzer module scans through the input, and whenever it finds
    a token (legal or illegal), it saves the current input pointer and returns the
    next token. Since the listing is lengthy and code is trivial, it is given as part
    of the code repository. The following pseudo-code shows the schema of the lexical
    analyzer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器模块扫描输入，每当它找到一个标记（合法或不合法）时，它会保存当前输入指针并返回下一个标记。由于列表很长且代码很平凡，它被作为代码仓库的一部分给出。以下伪代码显示了词法分析器的架构：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The parser module
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器模块
- en: By using recursive descent parsing, we will arrange the tokens to see whether
    expressions are valid, and generate the AST out of the input stream with the help
    of the lexical analyzer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用递归下降解析，我们将安排标记以查看表达式是否有效，并在词法分析器的帮助下从输入流中生成 AST：
- en: 'A recursive descent parser is a top-down parser built from a set of mutually-recursive
    procedures, where each such procedure usually implements one of the production
    rules of the grammar. Thus, the structure of the resulting program closely mirrors
    the grammar that it recognizes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降解析器是由一组相互递归的过程构建的从上到下的解析器，其中每个这样的过程通常实现语法规则中的一个。因此，生成的程序的结构与它所识别的语法紧密对应：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The constructor of the `RDParser` class takes the expression string as a parameter,
    and passes it to the `Lexer` class. Whenever the parser requires a token, it asks
    the `Lexer` class to provide one through the `GetToken()` method. The whole parsing
    process starts from the `CallExpr()` method, and inside it, a token is grabbed
    by the parser through the `Lexer` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RDParser`类的构造函数接受表达式字符串作为参数，并将其传递给`Lexer`类。每当解析器需要标记时，它都会通过`GetToken()`方法请求`Lexer`类提供一个标记。整个解析过程从`CallExpr()`方法开始，并在其中，解析器通过`Lexer`类获取一个标记：'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Expr()` function descends down to the `Term()` function (which is listed
    next), and returns the subexpressions from there. As long as there are further
    operators of the same precedence, it recursively calls the `Expr()` method to
    retrieve the factors in the form of tree. A `BinaryExp` node is created to represent
    the subexpressions parsed so far:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expr()`函数向下传递到`Term()`函数（如下所示），并从那里返回子表达式。只要存在进一步相同优先级的运算符，它就会递归地调用`Expr()`方法以检索以树的形式表示的因子。创建一个`BinaryExp`节点来表示到目前为止解析的子表达式：'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The term descends down to the `Factor()` method (shown next) to retrieve a
    node (which can be an expression itself within the parentheses), and as long as
    operators of the same precedence are available, it recursively calls itself to
    generate the terms of the same type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该术语向下传递到`Factor()`方法（如下所示），以检索一个节点（该节点可以是括号内的表达式本身），只要存在相同优先级的运算符，它就会递归地调用自身以生成相同类型的项：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the parser returns a number, the factor creates a numeric node and returns
    the same:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析器返回一个数字，因子创建一个数字节点并返回相同的值：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the current token is `$t`, a `Var` node is returned by the factor method.
    After instantiating the `Var` object, the parser grabs the next token before returning
    the expression object instance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前标记是`$t`，因子方法将返回一个`Var`节点。在实例化`Var`对象后，解析器在返回表达式对象实例之前获取下一个标记：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the current token is `SIN` or `COS`, we call `Expr()` recursively to parse
    the parameters. Once `Expr()` returns, we create the appropriate node:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前标记是`SIN`或`COS`，我们将递归地调用`Expr()`来解析参数。一旦`Expr()`返回，我们就创建相应的节点：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we find an opening parenthesis, a call to `Expr()` will go to parse the
    nested expressions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个开括号，`Expr()`的调用将用于解析嵌套表达式：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code snippet handles unary operators, and if the current token
    is any other thing which is not supposed to be there, an error will be thrown.
    The syntax diagrams (also known as railroad diagrams) of the grammar realized
    are shown next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段处理一元运算符，如果当前标记是任何不应该出现的东西，将抛出错误。下面显示了实现的语法的语法图（也称为铁路图）：
- en: '**Expr** is represented with the following syntax diagram. The BNF grammar
    gives better clarity:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**用以下语法图表示。BNF语法提供了更好的清晰度：'
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![The parser module](img/B05691_06_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![解析器模块](img/B05691_06_04.jpg)'
- en: 'The following syntax diagram represents the **Term.** The BNF grammar is shown
    for better clarity:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的语法图表示了**Term**。为了更好的清晰度，显示了BNF语法：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![The parser module](img/B05691_06_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![解析器模块](img/B05691_06_05.jpg)'
- en: '**Factor** can be represented using the following railroad diagram. The BNF
    grammar is also shown for the sake of clarity:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**因子**可以用以下铁路图表示。为了清晰起见，也显示了BNF语法：'
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![The parser module](img/B05691_06_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![解析器模块](img/B05691_06_06.jpg)'
- en: The builder, facade, and expression APIs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器、外观和表达式API
- en: 'The process of interpreting an expression is a complicated process, where a
    lot of classes work together towards the goal. As an application developer, to
    focus on the task at hand, we might have to expose an API which abstracts away
    the complexities of lexical analysis, parsing, and AST generation. We normally
    use the GoF facade pattern in these contexts. But, we will use the GoF builder
    pattern here, as this creational pattern is more appropriate in situations where
    we need to create a composite object. Here, we create expressions which are modeled
    as composites:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解释表达式的过程是一个复杂的过程，其中许多类共同协作以实现目标。作为一个应用开发者，为了专注于手头的任务，我们可能需要公开一个API，该API抽象掉了词法分析、解析和AST生成的复杂性。在这些情况下，我们通常使用GoF的外观模式。但是，在这里我们将使用GoF的构建器模式，因为这种创建型模式在需要创建复合对象的情况下更为合适。在这里，我们创建的表达式被建模为复合对象：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `GetExpression()` method leverages recursive descent parsing and lexical
    analysis to create an `Exp` object composed of AST nodes. If the parse fails,
    the routine will return null. The `Builder` class will be used to parse an expression
    from its textual representation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetExpression()`方法利用递归下降解析和词法分析来创建由AST节点组成的`Exp`对象。如果解析失败，该例程将返回null。`Builder`类将被用来解析从其文本表示形式中的表达式：'
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We parse the tree once to create the AST. Once the AST has been created, we
    can evaluate the resulting AST many times over by changing the value in the `RUNTIME_CONTEXT`
    object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析树一次以创建AST。一旦AST被创建，我们就可以通过更改`RUNTIME_CONTEXT`对象中的值多次评估生成的AST。
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The expression is parsed once, and an AST is created out of it. Once the tree
    has been created, it can be evaluated by changing the `context` object. In the
    preceding loop, `t` is updated and set to the `context` object. Each time you
    evaluate the tree, you evaluate against a different value of `t`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式只解析一次，并从中创建AST。一旦创建了树，就可以通过更改`context`对象来评估它。在前面的循环中，`t`被更新并设置为`context`对象。每次评估树时，都是针对不同的`t`值进行评估。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an application which plots the result of an arbitrary
    mathematical expression on a graphics surface. We used WPF for our rendering purpose.
    We also created an expression evaluator library, which uses the recursive descent
    parsing technique to parse an expression to a data structure called AST. The AST
    can be walked depth-first to evaluate the value. This is a good example of the
    interpreter pattern. We used the observer pattern to automatically relay the changes
    in the expression input to the canvas object. In the next chapter, you will learn
    how the .NET framework library leverages patterns to expose a good API for developers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个应用程序，该程序在图形表面上绘制任意数学表达式的结果。我们使用WPF作为我们的渲染目的。我们还创建了一个表达式评估库，它使用递归下降解析技术将表达式解析为称为AST的数据结构。AST可以通过深度优先遍历来评估其值。这是一个解释器模式的良好示例。我们使用了观察者模式来自动将表达式输入的变化传递到画布对象。在下一章中，你将学习.NET框架库如何利用模式为开发者提供一个良好的API。
