<html><head></head><body>
		<div><h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor219"/>14</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor220"/>Aspect-Oriented Programming</h1>
			<p>Throughout the book, you should have noticed a theme: automation. This means writing code that makes your code easier, more maintainable, and takes away repetitive work. In <a href="B19418_13.xhtml#_idTextAnchor206"><em class="ita ic">Chapter 13</em></a>, <em class="ita ic">Applying Cross-Cutting Concerns</em>, we talked about code that could be created for a specific concern and be automatically applied. In this chapter, we will take this concept to the next level and dive into a formalization that is designed for this purpose; <strong class="bo d">aspect-oriented </strong><strong class="bo d">programming</strong> (<strong class="bo d">AOP</strong>).</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>What is AOP?</li>
				<li>Logging</li>
				<li>Mixins</li>
				<li>Authorization</li>
			</ul>
			<p>By the end of this chapter, you should have a solid understanding of AOP and how it can be used in C# to create more modular, maintainable, and scalable applications.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor221"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter14</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>).</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor222"/>What is AOP?</h1>
			<p>In traditional programming, developers<a id="_idIndexMarker526"/> write code to implement the desired behavior of their applications. This code is organized into functions, classes, and modules that implement specific functionalities. However, many applications require additional functionality that spans multiple parts of the codebase, such as logging, error handling, and security. These<a id="_idIndexMarker527"/> functionalities, often referred to as cross-cutting concerns, can be difficult to manage and maintain when scattered throughout the codebase.</p>
			<p>AOP is a programming paradigm that aims to address this problem by separating cross-cutting concerns from the rest of the code. In AOP, developers define aspects, which encapsulate the behavior of cross-cutting concerns, and apply them to specific parts of the codebase using join points and pointcuts.</p>
			<p>AOP is very well suited<a id="_idIndexMarker528"/> in combination with other programming paradigms, such as <strong class="bo d">object-oriented programming</strong> (<strong class="bo d">OOP</strong>) and <strong class="bo d">functional programming</strong> (<strong class="bo d">FP</strong>), to create more modular, maintainable, and scalable applications. AOP has become increasingly popular<a id="_idIndexMarker529"/> in recent years, and there are many AOP frameworks available for various programming languages and platforms.</p>
			<p>In this chapter, we will explore<a id="_idIndexMarker530"/> how AOP can be used in C# to address cross-cutting concerns and improve code maintainability and reusability. We will cover the key concepts of AOP, such as aspects, pointcuts, and join points, and show how they can be applied to specific use cases, such as security and logging. We will do so using<a id="_idIndexMarker531"/> a framework called Castle Windsor (<a href="https://www.castleproject.org/projects/windsor/">https://www.castleproject.org/projects/windsor/</a>), and show how you use it to implement AOP in your C# applicat<a id="_idTextAnchor223"/>ions.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor224"/>Aspects</h2>
			<p>In AOP, an aspect<a id="_idIndexMarker532"/> is a modular unit of behavior that can be selectively applied to different parts of a program. An aspect is essentially a set of instructions that describe how to modify the behavior of a program in a particular way.</p>
			<p>Aspects are used to address cross-cutting concerns, which are concerns that span multiple parts of a program and cannot be encapsulated in a single module or class. Examples of cross-cutting concerns include logging, security, caching, and error handling.</p>
			<p>An aspect can be thought of as a reusable, modular piece of code that can be applied to multiple parts of a program. Aspects can be designed to be composable so that different aspects can be combined to achieve more complex behavior.</p>
			<p>Aspects are typically<a id="_idIndexMarker533"/> implemented as classes or modules that define the behavior to be added to the program. In AOP frameworks such as Castle Windsor, aspects are often implemented as interceptors, which are classes that intercept calls to methods or properties and modify their be<a id="_idTextAnchor225"/>havior.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor226"/>Pointcuts</h2>
			<p>Pointcuts are the mechanism<a id="_idIndexMarker534"/> used in AOP to specify <a id="_idIndexMarker535"/>the places in the code where an aspect should be applied. A pointcut is a set of join points, which are specific locations in the code where the aspect can be applied.</p>
			<p>A join point is a point in the execution of a program where an aspect can be applied. Examples of join points include method calls, method executions, field accesses, and exception handlers.</p>
			<p>To define a pointcut, you need to specify the join points that the pointcut includes. This can be done using a variety of criteria, such as method name, method signature, class name, or ann<a id="_idTextAnchor227"/>otations.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor228"/>Join points</h2>
			<p>In AOP, join points are specific<a id="_idIndexMarker536"/> points in the execution<a id="_idIndexMarker537"/> of a program where an aspect can be applied. Join points represent specific events, or method calls in the program, that can be intercepted by an aspect. For example, a join point could be a method call, field access, or an exception being thrown.</p>
			<p>Join points are defined using pointcuts, which specify the criteria for selecting the join points where an aspect should be applied. Pointcuts can be defined using various criteria, such as method signatures, class names, or annotations. For example, a pointcut could select all methods that have a specific attribute or all methods in a specific namespace.</p>
			<p>Once a pointcut has been defined, it can be used to apply an aspect to the selected join points. Aspects can modify the behavior of the join points they intercept by adding, modifying, or removing functionality. For example, an aspect could add logging or caching functionality to a method call or validate user input before allowing it to be processed.</p>
			<p>Join points are an essential<a id="_idIndexMarker538"/> concept in AOP, as they allow aspects<a id="_idIndexMarker539"/> to be applied selectively to specific parts of the codebase rather than having to modify the entire codebase to implement cross-cutting concerns. Join points also enable the modularization of cross-cutting concerns, making them easier to manage and maintain.</p>
			<p>Some common examples of join points in C# include the following:</p>
			<ul>
				<li><strong class="bo d">Method calls</strong>: These are join points that intercept<a id="_idIndexMarker540"/> method calls, either before the method is called (using a before advice) or after the method is called (using an after advice)</li>
				<li><strong class="bo d">Field access</strong>: These are join points that intercept read or write access to a field, either before the field <a id="_idIndexMarker541"/>is accessed (using a before advice) or after the field is accessed (using an after advice)</li>
				<li><strong class="bo d">Exception handling</strong>: Join points that intercept the throwing of an exception, allowing the aspect to handle<a id="_idIndexMarker542"/> the exception or modify its behavior</li>
			</ul>
			<p>The following diagram summarizes <strong class="bo d">Aspect</strong>, <strong class="bo d">Pointcuts</strong>, and <strong class="bo d">Join Points</strong>:</p>
			<div><div><img src="img/B19418_14_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – AOP terminology visualization</p>
			<p>With the terminology<a id="_idIndexMarker543"/> in place, we should now be ready to take a first dive into AOP and use it in some can<a id="_idTextAnchor229"/>onical examples.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor230"/>Logging</h1>
			<p>Logging<a id="_idIndexMarker544"/> is often cited as the canonical example<a id="_idIndexMarker545"/> of how AOP can be used to improve the modularity and maintainability of software. Logging is a common cross-cutting concern, meaning that it affects multiple parts of a software system and cannot be easily encapsulated within a single module or class.</p>
			<p>AOP provides a way to encapsulate the logging behavior and apply it consistently throughout the system without the need to modify each module or class individually. This allows developers to focus on the core functionality of their modules while still providing a consistent and coherent way to log system behavior.</p>
			<p>In this section, we will explore the role of logging<a id="_idIndexMarker546"/> in software systems<a id="_idIndexMarker547"/> and how AOP can be used to implement logging behavior in a modular and maintainable way. We will look at the benefits and drawbacks of different logging approaches and how AOP can help to address some of the challenges associated with logging in compl<a id="_idTextAnchor231"/>ex software systems.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor232"/>Creating a logging sample</h2>
			<p>Let’s start by creating a new project<a id="_idIndexMarker548"/> for the chapter. Create a folder called <strong class="source-in ine">Chapter14</strong>, change into this folder in your command line and create a new console project:</p>
			<pre class="source-code">
dotnet new console</pre>
			<p>For this chapter, as discussed, we will use<a id="_idIndexMarker549"/> a framework called Castle Windsor. It’s one<a id="_idIndexMarker550"/> of many frameworks coming out of <strong class="bo d">The Castle Project</strong>, which you can read more about it here (<a href="http://www.castleproject.org/">http://www.castleproject.org/</a>). Castle Windsor is an <strong class="bo d">Inversion of Control</strong> (<strong class="bo d">IoC</strong>), a container that provides extensive capabilities<a id="_idIndexMarker551"/> performing AOP.</p>
			<p>To make all the AOP magic possible, Castle Windsor is built on top of a project called Castle Core, which provides a convenient way to create dynamic runtime proxy objects, as we did in <a href="B19418_06.xhtml#_idTextAnchor098"><em class="ita ic">Chapter 6</em></a>, <em class="ita ic">Dynamic Proxy Generation</em>. This could be a natural step up from having to do everything yourself.</p>
			<p>It is all open source, and the concrete framework you will be using here is the <strong class="bo d">Windsor</strong> part and can be found on GitHub (<a href="https://github.com/castleproject/Windsor">https://github.com/castleproject/Windsor</a>).</p>
			<p>Add the package to dependency of the project:</p>
			<pre class="source-code">
dotnet add package Castle.Windsor</pre>
			<p>To get started with the Windsor container, you can simply replace the content of <strong class="source-in ine">Program.cs</strong> with the following:</p>
			<pre class="source-code">
using System.Reflection;
using Castle.Windsor;
using Castle.Windsor.Installer;
var container = new WindsorContainer();
container.Install(FromAssembly.InThisApplication(Assembly.
  GetEntryAssembly()));</pre>
			<p>The code creates an instance of <strong class="source-in ine">WindsorContainer</strong> and instructs it to install any implementations of <strong class="source-in ine">IWindsorInstaller</strong> from the running application. An installer is a way to configure<a id="_idIndexMarker552"/> the container. They are discovered in the <strong class="source-in ine">.Install()</strong> call, and you can have multiple installers for specific use cases.</p>
			<p>We want to create <strong class="source-in ine">DefaultInstaller</strong> that will set up a default behavior for the container. Add a file called <strong class="source-in ine">DefaultInstaller.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using System.Reflection;
using Castle.MicroKernel.Registration;
using Castle.MicroKernel.SubSystems.Configuration;
using Castle.Windsor;
namespace Chapter14;
public class DefaultInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container,
      IConfigurationStore store)
    {
        container.Register(Classes
          .FromAssemblyInThisApplication(Assembly
          .GetEntryAssembly())
            .Pick()
            .WithService.DefaultInterfaces()
            .LifestyleTransient());
    }
}</pre>
			<p>The code implements the <strong class="source-in ine">IWindsorInstaller</strong> interface and implements the <strong class="source-in ine">Install()</strong> method. Within it, the code instructs <strong class="source-in ine">container</strong> to register all classes from the application by associating it with a service represented by what is referred to as <strong class="source-in ine">DefaultInterfaces</strong>. This means that it will establish a convention as we did in <a href="B19418_10.xhtml#_idTextAnchor162"><em class="ita ic">Chapter 10</em></a>, <em class="ita ic">Convention over Configuration</em>, that says any class with a matching interface with a name prefixed by <strong class="source-in ine">I</strong> will be bound together (<strong class="source-in ine">IFoo</strong> -&gt; <strong class="source-in ine">Foo</strong>). Finally, it tells it that the lifestyle should be transient. Castle Windsor has a default life cycle of singleton, which could be dangerous and have undesired side effects, so my recommendation is to stay with transient as default and then override it when needed.</p>
			<p>An installer is just a tool to help<a id="_idIndexMarker553"/> you structure your code and help you with keeping things focused on a single responsibility and enable a more cohesive codebase. You can, in fact, work directly with the container right after instantiating it, as we will see later. Some things make sense to do right away, while others should be separated.</p>
			<p><strong class="source-in ine">Console.WriteLine()</strong> is not optimal for logging, so let’s use the<a id="_idTextAnchor233"/> Microsoft logger instead.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor234"/>Adding the Microsoft logger</h2>
			<p>By writing<a id="_idIndexMarker554"/> to the console<a id="_idIndexMarker555"/> using <strong class="source-in ine">Console.WriteLine()</strong>, you don’t get any structure to your logging. Log messages just become text, and the format is what you put into it. You often also want a different output for your local development than in production. Using a structured logging approach captures any values used in a log statement that could then be forwarded to a centralized log database, indexing them and making them searchable. There are many such tools<a id="_idIndexMarker556"/> out there, a<a href="https://datalust.co/seq">nd I recommend looking </a>at Seq (<a href="https://datalust.co/seq">https://datalust.co/seq</a>), which provides a tool that is free for local development.</p>
			<p>For this sample, we will use a library from Microsoft for structured logging. It is the same one used by Microsoft for everything they build. It provides extension points and can also be used with other popular<a id="_idIndexMarker557"/> logg<a href="https://serilog.net">ing libraries, such</a> as Serilog (<a href="https://serilog.net">https://serilog.net</a>).</p>
			<p>Start by adding package references to the core logging package and also to the <strong class="source-in ine">Console</strong> output:</p>
			<pre class="source-code">
dotnet add package Microsoft.Extensions.Logging
dotnet add package Microsoft.Extensions.Logging.Console</pre>
			<p>Then in the <strong class="source-in ine">Program.cs</strong> file, add the following code at the end:</p>
			<pre class="source-code">
var loggerFactory = LoggerFactory.Create(builder =&gt; builder.
  AddConsole());
container.Register(Component.For&lt;ILoggerFactory&gt;().
  Instance(loggerFactory));</pre>
			<p>The code creates <strong class="source-in ine">LoggerFactory</strong> and configures<a id="_idIndexMarker558"/> it to output<a id="_idIndexMarker559"/> to the console. It then goes on to register the <strong class="source-in ine">ILoggerFactory</strong> interface with the concrete instance you just configured into the Windsor IoC container. Any constructors with a dependency to <strong class="source-in ine">ILoggerFactory</strong> will now get this instance. <strong class="source-in ine">ILoggerFactory</strong> provides a way to create concrete <strong class="source-in ine">ILogger</strong> instances, which is what will be used for logging.</p>
			<p>In ASP.NET Core, <strong class="source-in ine">ILoggerFactory</strong> is being used internally in some cases to create logger instances. While in other cases, constructors have a dependency to <strong class="source-in ine">ILogger</strong> and, even more specifically, on the generic <strong class="source-in ine">ILogger&lt;&gt;</strong> version. The generic version of <strong class="source-in ine">ILogger</strong> allows you to get a scoped logger that is for your specific type. In the log output, you’ll see the source of the log messages, which is important metadata.</p>
			<p>Let’s configure the IoC container to support both of these scenarios. In the <strong class="source-in ine">Program.cs</strong> file, add the following code at the end:</p>
			<pre class="source-code">
var createLoggerMethod = typeof(LoggerFactoryExtensions)
    .GetMethods(BindingFlags.Public | BindingFlags.Static)
    .First(_ =&gt; _.Name == nameof(
      LoggerFactory.CreateLogger) &amp;&amp; _.IsGenericMethod);
container.Register(Component.For&lt;ILogger&gt;().
  UsingFactoryMethod((kernel, context) =&gt;
{
    var loggerFactory = kernel.Resolve&lt;ILoggerFactory&gt;();
    return loggerFactory.CreateLogger(
      context.Handler.ComponentModel.Implementation);
}).LifestyleTransient());
container.Register(Component.For(typeof(ILogger&lt;&gt;)).
  UsingFactoryMethod((kernel, context) =&gt;
{
    var loggerFactory = kernel.Resolve&lt;ILoggerFactory&gt;();
    var logger = createLoggerMethod
      .MakeGenericMethod(context.RequestedType
      .GenericTypeArguments[0]).Invoke(null, new[] {
      loggerFactory });
    return logger;
}));</pre>
			<p>The code starts by using reflection to get the <strong class="source-in ine">CreateLogger&lt;&gt;()</strong> extension method from <strong class="source-in ine">LoggerFactoryExtensions</strong>. This is because <strong class="source-in ine">ILoggerFactory</strong> only has a non-typed way of creating a logger, and the generic one is an extension method. Next, the code registers the untyped non-generic <strong class="source-in ine">ILogger</strong> with the container using a factory method that will create the instance dynamically when asked. It then leverages the container to get <strong class="source-in ine">ILoggerFactory</strong> and then creates a logger by giving it the type <strong class="source-in ine">Ilogger</strong> is being injected into. Since the default behavior of Windsor is to make everything a singleton, we explicitly configure <strong class="source-in ine">Ilogger</strong> to be transient. This way, we get different logger instances for the types using it. Otherwise, you would be sharing the same logger across all types. Lastly, the code configures the generic <strong class="source-in ine">ILogger&lt;&gt;</strong> using a factory method that uses the <strong class="source-in ine">CreateLogger&lt;&gt;()</strong> extension method from <strong class="source-in ine">LoggerFactoryExtensions</strong> by creating a generic method for the requested type and its generic type argument.</p>
			<p>With the basic logging<a id="_idIndexMarker560"/> infrastructure in place, we’re now read<a id="_idTextAnchor235"/>y to apply<a id="_idIndexMarker561"/> cross-cutting logging.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor236"/>Interceptors</h1>
			<p>In Castle Windsor, there<a id="_idIndexMarker562"/> is the concept of interceptors. They represent how you can implement the actual aspect and perform the cross-cutting operation.</p>
			<p>Let’s create one for handling logging for all method calls. In the root of <strong class="source-in ine">Chapter14</strong>, add a file called <strong class="source-in ine">LoggingInterceptor.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
using Castle.DynamicProxy;
namespace Chapter14;
public class LoggingInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        // Do something before
        invocation.Proceed();
        // Do something after
    }
}</pre>
			<p>The code sets up an implementation of <strong class="source-in ine">IInterceptor</strong> from Castle Windsor. In the <strong class="source-in ine">Intercept()</strong> method, the code calls the <strong class="source-in ine">Proceed()</strong> method on the invocation object, which will perform the actual call it is intercepting. Before and after this call is where we can do our cross-cutting operations.</p>
			<p>With .NET 6, Microsoft introduced an approach to logging that helps you become even more structured by encapsulating log messages into its own code file. This helps you with the maintenance of log messages and makes it easier for those scenarios when you want to output the same log message for different scenarios.</p>
			<p>Create a new file called <strong class="source-in ine">LoggingInterceptorLogMessages.cs</strong> and add the following<a id="_idIndexMarker563"/> code to it:</p>
			<pre class="source-code">
using Microsoft.Extensions.Logging;
namespace Chapter14;
internal static partial class LoggingInterceptorLogMessages
{
    [LoggerMessage(1, LogLevel.Information, "Before
      invoking {Method}", EventName = "BeforeInvocation")]
    internal static partial void BeforeInvocation(this
      ILogger logger, string method);
    [LoggerMessage(2, LogLevel.Error, "Error invoking
      {Method}", EventName = "InvocationError")]
    internal static partial void InvocationError(this
      ILogger logger, string method, Exception exception);
    [LoggerMessage(3, LogLevel.Information, "Before
      invoking {Method}", EventName = "AfterInvocation")]
    internal static partial void AfterInvocation(this
      ILogger logger, string method);
}</pre>
			<p>The code sets up a static partial class with extension methods for each log statement and leverages <strong class="source-in ine">[LoggerMessage]</strong> to configure the log message, its severity, a unique identifier within the file or globally, and optionally, an event name. Since all the methods are also partial and do not have any implementations, the C# compiler will generate the necessary code for this.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">I find it to be good practice to make logger messages like this internal, for both the class and the methods. That way, you isolate them for their module and do not run the risk of making them an extension method that will show up as IntelliSense in your editor globally across different projects. Normally you should also use the generic <strong class="source-in ine">ILogger&lt;&gt;</strong> as the type to extend for the extension method makes it specific to your concrete type. But since the log messages we have here are cross-cutting, we don’t know the type they will be used in.</p>
			<p>With the log messages in place<a id="_idIndexMarker564"/> for what we want to log, we can modify <strong class="source-in ine">LoggingInterceptor</strong> to do the logging. Open the <strong class="source-in ine">LoggingInterceptor</strong> file and change it to look like the following:</p>
			<pre class="source-code">
using Castle.DynamicProxy;
using Microsoft.Extensions.Logging;
namespace Chapter14;
public class LoggingInterceptor : IInterceptor
{
    readonly ILoggerFactory _loggerFactory;
    public LoggingInterceptor(ILoggerFactory loggerFactory)
    {
        _loggerFactory = loggerFactory;
    }
    public void Intercept(IInvocation invocation)
    {
        var logger = _loggerFactory.CreateLogger(
          invocation.TargetType)!;
        logger.BeforeInvocation(invocation.Method.Name);
        invocation.Proceed();
        logger.AfterInvocation(invocation.Method.Name);
    }
}</pre>
			<p>The code gets changed to take <strong class="source-in ine">ILoggerFactory</strong> as a dependency in the constructor. In the <strong class="source-in ine">Intercept()</strong> method, you now<a id="_idIndexMarker565"/> use the logger factory to create a logger for the target type. It then uses structured logging calling <strong class="source-in ine">BeforeInvocation()</strong> and <strong class="source-in ine">AfterInvocation()</strong> and passing the name of the method being invoked.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Just seeing the method being invoked in your logs by name might not be enough information. The <strong class="source-in ine">IInvocation</strong> type has details about the parameters being passed, and you could be logging them as well. The only thing<a id="_idIndexMarker566"/> to keep in mind would be to redact values that are sensitive, such as <strong class="bo d">General Data Protection Regulation</strong> (<strong class="bo d">GDPR</strong>)-related information or security information. Luckily, if you follow the advice in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, and use the <strong class="source-in ine">ConceptAs&lt;&gt;</strong> encapsulation for types, you could easily identify the types you need to redact and automatically do so.</p>
			<p>With the interceptor in place, the next step is to hook it up to Castle Windsor. Open the <strong class="source-in ine">DefaultInstaller.cs</strong> file and change it to the following:</p>
			<pre class="source-code">
using System.Reflection;
using Castle.MicroKernel.Registration;
using Castle.MicroKernel.SubSystems.Configuration;
using Castle.Windsor;
namespace Chapter14;
public class DefaultInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container,
      IConfigurationStore store)
    {
        // Added
        container.Register(Component.For&lt;
          LoggingInterceptor&gt;());
        container.Register(Classes
          .FromAssemblyInThisApplication(Assembly
          .GetEntryAssembly())
            .Pick()
            .WithService.DefaultInterfaces()
            // Added
            .Configure(_ =&gt;
              _.Interceptors&lt;LoggingInterceptor&gt;())
            .LifestyleTransient());
    }
}</pre>
			<p>The only change made to the installer is the registration of <strong class="source-in ine">LoggingInterceptor</strong>. Castle Windsor does not know how to resolve concrete types automatically, so we register it manually. The second addition is to configure the registration for the default convention to include <strong class="source-in ine">LoggingInterceptor</strong>.</p>
			<p>Now that you have all the infrastructure<a id="_idIndexMarker567"/> in place, you need something to test it with. Let’s create a user service for registering users, not focusing on implementing it, just<a id="_idTextAnchor237"/> something to test the interceptor with.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor238"/>Trying out the interceptor</h2>
			<p>Create<a id="_idIndexMarker568"/> a file called <strong class="source-in ine">IUsersService.cs</strong> in the root of <strong class="source-in ine">Chapter14</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter14;
public interface IUsersService
{
    Task&lt;Guid&gt; Register(string userName, string password);
}</pre>
			<p>The interface holds a single method for registering a user.</p>
			<p>For the interface, you’ll need an implementation. Add a file called <strong class="source-in ine">UsersService.cs</strong> and add the following code to it:</p>
			<pre class="source-code">
using Microsoft.Extensions.Logging;
namespace Chapter14;
public class UsersService : IUsersService
{
    readonly ILogger&lt;UsersService&gt; _logger;
    public UsersService(ILogger&lt;UsersService&gt; logger)
    {
        _logger = logger;
    }
    public Task&lt;Guid&gt; Register(string userName,
      string password)
    {
        _logger.LogInformation("Inside register method");
        var id = Guid.NewGuid();
        return Task.FromResult(id);
    }
}</pre>
			<p>The code represents an implementation of <strong class="source-in ine">IUsersService</strong>. It takes <strong class="source-in ine">ILogger&lt;UsersService&gt;</strong> as a dependency so that we can log from within it. For the <strong class="source-in ine">Register()</strong> method, it only logs it, creates a new <strong class="source-in ine">Guid</strong>, and returns this as a result.</p>
			<p>With a sample in place, you now<a id="_idIndexMarker569"/> need to get an instance of it and see that the interceptor works. Open the <strong class="source-in ine">Program.cs</strong> file and add the following to the very end:</p>
			<pre class="source-code">
var usersService = container.Resolve&lt;IUsersService&gt;();
var result = await usersService.Register("jane@doe.io", "Password1");
Console.ReadLine();</pre>
			<p>The code asks the Castle Windsor container for an instance of <strong class="source-in ine">IUsersService</strong> and then calls the <strong class="source-in ine">Register()</strong> method. We put in <strong class="source-in ine">Console.ReadLine()</strong> due to the use of async; if we didn’t, it would exit without any of the log messages being printed.</p>
			<p>You can now run this using <strong class="source-in ine">dotnet run</strong> or your preferred approach in your editor, and you should see the following output:</p>
			<pre class="source-code">
info: Chapter14.UsersService[1]
      Before invoking Register
info: Chapter14.UsersService[0]
      Inside register method
info: Chapter14.UsersService[3]
      Before invoking Register</pre>
			<p>The calling code has no concept<a id="_idIndexMarker570"/> of the interceptor; it is configured once and will be weaved into the running code automatically.</p>
			<p>However, the implementation of the <strong class="source-in ine">Intercept()</strong> method in <strong class="source-in ine">LoggingInterceptor</strong> is a bit naïve. It should support errors, and it also needs to support asynchronous method calls properly. Open the <strong class="source-in ine">LoggingInterceptor.cs</strong> file and change the <strong class="source-in ine">Intercept()</strong> method as follows:</p>
			<pre class="source-code">
public void Intercept(IInvocation invocation)
{
    var logger = _loggerFactory
      .CreateLogger(invocation.TargetType)!;
    logger.BeforeInvocation(invocation.Method.Name);
    try
    {
        invocation.Proceed();
        if (invocation.ReturnValue is Task task)
        {
            task.ContinueWith(t =&gt;
            {
                if (t.IsFaulted)
                {
                    logger.InvocationError(
                      invocation.Method.Name,
                      t.Exception!);
                }
                else
                {
                    logger.AfterInvocation(
                      invocation.Method.Name);
                }
            });
        }
        else
        {
            logger.AfterInvocation(invocation.Method.Name);
        }
    }
    catch (Exception ex)
    {
        logger.InvocationError(invocation.Method.Name, ex);
        throw;
    }
}</pre>
			<p>The code wraps the <strong class="source-in ine">Proceed()</strong> call in <strong class="source-in ine">try {} catch {}</strong> to be able to log the error, but rethrows it as the logging shouldn’t swallow the exception; it should bubble up to the original caller. For handling asynchronous calls, it looks at <strong class="source-in ine">ReturnValue</strong> of the <strong class="source-in ine">invocation</strong> instance if it is a <strong class="source-in ine">Task</strong>. If it is a task, it will continue, and get notified when it is completed. Tasks can<a id="_idIndexMarker571"/> have a faulty state, which w<a id="_idTextAnchor239"/>ould be if the call results in an exception.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor240"/>Mixins</h1>
			<p>In C++, multiple inheritances<a id="_idIndexMarker572"/> provide a powerful way to combine behaviors from multiple base classes. However, this can lead to complexity and the diamond problem. Mixins provide a simpler alternative to multiple inheritances that avoids these issues and are particularly useful for implementing cross-cutting concerns in your code.</p>
			<p>In the .NET <strong class="bo d">common language runtime</strong> (<strong class="bo d">CLR</strong>), however, multiple inheritance is not supported, as it uses a single<a id="_idIndexMarker573"/> inheritance model. This means that there is no built-in mechanism for combining behaviors from multiple classes. Mixins can be used to achieve this, providing a way to add functionality to a class without needing to modify its inheritance hierarchy. In this section, we’ll explore what mixins are, how they work, and why you might want to use them in your C# applications to overcome the limitations of the .NET CLR’s single inheritance model.</p>
			<p>One of the key features of Castle Core is its support for dynamic proxies, which allow you to intercept method calls and add behavior at runtime.</p>
			<p>Castle Windsor’s approach to mixins builds on this support for dynamic proxies to provide a way to compose behavior from multiple sources into a single object. Mixins allow you to define a set of behaviors as independent components, which can be combined with the behavior of another object to create a new object with the combined behavior.</p>
			<p>In Castle Windsor, mixins are implemented using a combination of dynamic proxies and an interception. When you register a component with mixins, Castle Windsor creates a dynamic proxy object that intercepts method calls to the component and delegates them to the mixins. The mixins can then modify the behavior of the component by adding new functionality or modifying the behavior of existing methods.</p>
			<p>To register a component with mixins in Castle Windsor, you typically define one or more interfaces that represent the mixins and register them as separate components with the container. You then register the component to which you want to add the mixins to and specify the mixins as dependencies. When the component is resolved from the container, Castle Windsor creates a dynamic proxy object that implements the component interface and the mixin interfaces<a id="_idIndexMarker574"/> and del<a id="_idTextAnchor241"/>egates method calls to the appropriate objects.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor242"/>Mixing it up</h2>
			<p>The <strong class="source-in ine">UserService</strong> you created earlier<a id="_idIndexMarker575"/> could be a candidate for mixins. In a system, you typically need a way to authenticate users and a way to ask whether they are authorized to perform an action. Obviously, .NET provides building blocks and great support for both authentication and authorization, but let’s say you want your abstraction on top of what .NET provides for specific use where you need to be able to authenticate a user by its username and password and then be able to ask whether the user is authorized to perform an action.</p>
			<p>In the folder for the <strong class="source-in ine">Chapter14</strong> code, add a file called <strong class="source-in ine">IAuthenticator.cs</strong> and put the following into it:</p>
			<pre class="source-code">
namespace Chapter14;
public interface IAuthenticator
{
    bool Authenticate(string username, string password);
}</pre>
			<p>The <strong class="source-in ine">IAuthenticator</strong> interface defines a method for performing authentication with a username and a password. It would typically return <strong class="source-in ine">true</strong> if it could successfully authenticate the user and <strong class="source-in ine">false</strong> if not.</p>
			<p>An implementation of <strong class="source-in ine">IAuthenticator</strong> can be put in a file called <strong class="source-in ine">Authenticator.cs</strong>, which looks like the following:</p>
			<pre class="source-code">
namespace Chapter14;
public class Authenticator : IAuthenticator
{
    public bool Authenticate(string username, string password)
    {
        return true;
    }
}</pre>
			<p>The code implements the <strong class="source-in ine">IAuthenticator</strong> interface, and for demo purposes, it only returns <strong class="source-in ine">true</strong>. Since we won’t be building<a id="_idIndexMarker576"/> anything specifically and are just demonstrating the power of mixins, this is OK for now.</p>
			<p>For the authorization part, you’re going to need another interface. Add a file called <strong class="source-in ine">IAuthorizer.cs</strong> and make it look like the following:</p>
			<pre class="source-code">
namespace Chapter14;
public interface IAuthorizer
{
    bool IsAuthorized(string username, string action);
}</pre>
			<p>Checking for authorization is done by giving it a username and an action. The method will then return <strong class="source-in ine">true</strong> if the user is authorized to perform the action and <strong class="source-in ine">false</strong> if not.</p>
			<p>For the authorizer, you’ll also need an implementation, so create a file called <strong class="source-in ine">Authorizer.cs</strong> and put the following into it:</p>
			<pre class="source-code">
namespace Chapter14;
public class Authorizer : IAuthorizer
{
    public bool IsAuthorized(string username, string action)
    {
        return true;
    }
}</pre>
			<p>As with the <strong class="source-in ine">Authenticator</strong> implementation, it will<a id="_idIndexMarker577"/> just return <strong class="source-in ine">true</strong> for demonstration purposes. This is where you’d have your logic for checking whether the user is authorized for a specific action.</p>
			<p>The <strong class="source-in ine">IAuthenticator</strong> and <strong class="source-in ine">IAuthorizer</strong>, with their respective implementations, are separate, and they’re also separate from <strong class="source-in ine">IUsersService</strong>. This is great as they represent different aspects of working with a user. They serve specific responsibilities of the system, and it’s logical to keep them separate, which leads to a more maintainable codebase.</p>
			<p>However, it might be desirable to be able to access them all as one at runtime. This is where mixins come in and can make it look as if it is one implementation.</p>
			<p>To be able to do so, you need to configure Castle Windsor correctly. Open the <strong class="source-in ine">DefaultInstaller.cs</strong> file and at the top of the <strong class="source-in ine">Install()</strong> method, add the following:</p>
			<pre class="source-code">
container.Register(
    Component.For&lt;IAuthenticator&gt;()
        .ImplementedBy&lt;Authenticator&gt;()
        .LifestyleTransient());
container.Register(
    Component.For&lt;IAuthorizer&gt;()
        .ImplementedBy&lt;Authorizer&gt;()
        .LifestyleTransient());</pre>
			<p>The code adds explicit container registrations for the <strong class="source-in ine">IAuthenticator</strong> and <strong class="source-in ine">IAuthorizer</strong> services. The reason for adding this explicitly is that we have to add an explicit registration for <strong class="source-in ine">IUsersService</strong>, and this has to happen prior to the automatic registrations that are already set up in <strong class="source-in ine">DefaultInstaller</strong>. If you were to register <strong class="source-in ine">IUsersService</strong> after the automatic registrations, you would get an exception saying there are duplicate registrations.</p>
			<p>For the mixin, you’re going<a id="_idIndexMarker578"/> to need another explicit registration. Add the following code right after the <strong class="source-in ine">IAuthenticator</strong> and <strong class="source-in ine">IAuthorize</strong> registrations and before the automatic registrations:</p>
			<pre class="source-code">
container.Register(
    Component.For&lt;IUsersService&gt;()
        .ImplementedBy&lt;UsersService&gt;()
        .Proxy.AdditionalInterfaces(typeof(IAuthorizer),
          typeof(IAuthenticator))
        .Proxy.MixIns(_ =&gt; _
            .Component&lt;Authorizer&gt;()
            .Component&lt;Authenticator&gt;())
        .Interceptors&lt;LoggingInterceptor&gt;()
        .LifestyleTransient());</pre>
			<p>The registration for <strong class="source-in ine">IUsersService</strong> is slightly different from what you’ve done before. First, it instructs Castle Windsor that <strong class="source-in ine">IUsersService</strong> is implemented by <strong class="source-in ine">UsersService</strong>, then it instructs it to implement some additional interfaces: <strong class="source-in ine">IAuthorizer</strong> and <strong class="source-in ine">IAuthenticator</strong>. The additional interfaces are then instructed to be implemented using the <strong class="source-in ine">.Mixins()</strong> call that tells it that they’re implemented by their respective <strong class="source-in ine">Authorizer</strong> and <strong class="source-in ine">Authenticator</strong> components. Since this is an explicit registration, the automatic one will not kick in, and <strong class="source-in ine">LoggingInterceptor</strong> you previously hooked up won’t kick in for this. For it to do so, you need to add an explicit <strong class="source-in ine">.Interceptors&lt;&gt;()</strong> call for the interceptor. Lastly, you set the lifestyle to be transient.</p>
			<p>If you run this with the debugger attached, you can investigate what has happened to <strong class="source-in ine">UserService</strong>. In the <strong class="source-in ine">Program.cs</strong> file, you can put a breakpoint right after you call <strong class="source-in ine">container.Resolve&lt;IUserService&gt;()</strong>. Run the debugger to this point:</p>
			<div><div><img src="img/B19418_14_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The debug breakpoint</p>
			<p>In the <strong class="source-in ine">Debug</strong> console (immediate window) of your editor/<strong class="bo d">integrated development environment</strong> (<strong class="bo d">IDE</strong>), you should be<a id="_idIndexMarker579"/> able to write <a id="_idIndexMarker580"/>the following:</p>
			<pre class="source-code">
usersService.GetType().GetInterfaces()</pre>
			<p>The output of this should be something like the following:</p>
			<div><div><img src="img/B19418_14_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The implemented interfaces</p>
			<p>To prove the calls are going to the mixins, you can add the following to the <strong class="source-in ine">Program.cs</strong> file before <strong class="source-in ine">Console.ReadLine();</strong>:</p>
			<pre class="source-code">
var authenticated = (usersService as IAuthenticator)!.
  Authenticate("jane@doe.io", "Password1");
var authorized = (usersService as IAuthorizer)!.IsAuthorized("jane@
  doe.io", "Some Action");
Console.WriteLine($"Authenticated: {authenticated}");
Console.WriteLine($"Authorized: {authorized}");</pre>
			<p>The code assumes that <strong class="source-in ine">UserService</strong> also implements the <strong class="source-in ine">IAuthenticator</strong> and <strong class="source-in ine">IAuthorizer</strong> interfaces and uses casting to get to them and calls the <strong class="source-in ine">Authenticate()</strong> and <strong class="source-in ine">IsAuthorized()</strong> methods, respectively. It then prints out the results of these.</p>
			<p>If you run your application now, you should see an output similar to the following:</p>
			<pre class="source-code">
info: Chapter14.UsersService[1]
      Before invoking Register
info: Chapter14.UsersService[0]
      Inside register method
info: Chapter14.Authenticator[1]
      Before invoking Authenticate
info: Chapter14.UsersService[3]
      Before invoking Register
info: Chapter14.Authenticator[3]
      Before invoking Authenticate
info: Chapter14.Authorizer[1]
      Before invoking IsAuthorized
info: Chapter14.Authorizer[3]
      Before invoking IsAuthorized
Authenticated: True
Authorized: True</pre>
			<p>The downside to this approach<a id="_idIndexMarker581"/> is that it is not clear in the contract of <strong class="source-in ine">IUsersService</strong> that it will also implement the <strong class="source-in ine">IAuthenticator</strong> and <strong class="source-in ine">IAuthorizer</strong> interfaces. However, this can be overcome by different techniques.</p>
			<p>One approach is to have an interface that represents the composition without an implementation, for instance, something such as the following:</p>
			<pre class="source-code">
public interface IUsersServiceComposition : IUsersService, IAuthenticator, IAuthorizer
{
}</pre>
			<p>The <strong class="source-in ine">IUsersServiceComposition</strong> interface is just for composition; it shouldn’t have any direct members on it as the goal<a id="_idIndexMarker582"/> is to combine implementations of <strong class="source-in ine">IUsersService</strong>, <strong class="source-in ine">IAuthenticator</strong>, and <strong class="source-in ine">IAuthorizer</strong>. We can then leverage the underlying <strong class="source-in ine">ProxyGenerator</strong> in the Castle <strong class="source-in ine">DynamicProxy</strong> library to create a proxy that represents this with the implementations in the different components.</p>
			<p>In the <strong class="source-in ine">DefaultInstaller.cs</strong> file, you can now create a new type of registration for the new <strong class="source-in ine">IUsersServiceComposition</strong> interface. At the end of the method, you can add the following code:</p>
			<pre class="source-code">
container.Register(
    Component.For&lt;IUsersServiceComposition&gt;()
        .UsingFactoryMethod((kernel, context) =&gt;
        {
            var proxyGenerator = new ProxyGenerator();
            var proxyGenerationOptions = new ProxyGenerationOptions();
            proxyGenerationOptions.AddMixinInstance(container.
            Resolve&lt;IAuthorizer&gt;());
            proxyGenerationOptions.AddMixinInstance(container.
            Resolve&lt;IAuthenticator&gt;());
            var logger = container.Resolve&lt;ILogger&lt;UsersService&gt;&gt;();
            proxyGenerationOptions.AddMixinInstance(new
            UsersService(logger));
            var usersServiceComposition = (proxyGenerator.
            CreateClassProxyWithTarget(
                typeof(object),
                new[] { typeof(IUsersServiceComposition) },
                new object(),
                proxyGenerationOptions) as IUsersServiceComposition)!;
            return usersServiceComposition;
        }));a</pre>
			<p>The code sets up a registration that uses a method to create the instance. With the <strong class="source-in ine">UsingFactoryMethod()</strong> instruction, you’re giving Castle Windsor a method that will be called when it needs to resolve<a id="_idIndexMarker583"/> the instance. The factory method uses <strong class="source-in ine">ProxyGenerator</strong> from the Castle <strong class="source-in ine">DynamicProxy</strong> and adds the different mixins for the <strong class="source-in ine">IAuthorizer</strong> and <strong class="source-in ine">IAuthenticator</strong> interfaces by using the container to provide an instance of these. For <strong class="source-in ine">IUsersService</strong>, we have to create an instance of it ourselves for this sample, providing the logger that uses the container to get an instance. The reason for this is that you already have a registration for <strong class="source-in ine">IUsersService</strong> that adds mixins for the <strong class="source-in ine">IAuthorizer</strong> and <strong class="source-in ine">IAuthenticator</strong> interfaces, which would throw an exception when creating a proxy.</p>
			<p>Once all the mixins are configured, the code creates a class proxy with a target based on the <strong class="source-in ine">object</strong> type and tells it that it should implement the <strong class="source-in ine">IUsersServiceComposition</strong> interface.</p>
			<p>With all that, you now get an instance that implements all the interfaces and delegates the implementation of them to the mixed-in instances. Kind of neat.</p>
			<p>Using <strong class="source-in ine">IUserServiceComposition</strong> is now much more intuitive and very clear for the consumer, as you don’t have to know what other interfaces it might implement. Open up the <strong class="source-in ine">Program.cs</strong> file and add the following code before <strong class="source-in ine">Console.ReadLine()</strong>:</p>
			<pre class="source-code">
var composition = container.Resolve&lt;IUsersServiceComposition&gt;();
authenticated = composition.Authenticate("jane@doe.io", "Password1");
authorized = composition.IsAuthorized("jane@doe.io", "Some Action");
Console.WriteLine($"Authenticated: {authenticated}");
Console.WriteLine($"Authorized: {authorized}");</pre>
			<p>Running the program should now<a id="_idIndexMarker584"/> give you a result similar to the following:</p>
			<pre class="source-code">
info: Chapter14.UsersService[1]
      Before invoking Register
info: Chapter14.UsersService[0]
      Inside register method
info: Chapter14.Authenticator[1]
      Before invoking Authenticate
info: Chapter14.UsersService[3]
      Before invoking Register
info: Chapter14.Authenticator[3]
      Before invoking Authenticate
info: Chapter14.Authorizer[1]
      Before invoking IsAuthorized
info: Chapter14.Authorizer[3]
      Before invoking IsAuthorized
Authenticated: True
Authorized: True
Authenticated: True
Authorized: True</pre>
			<p>Mixins provide a powerful way to add behavior to an object by combining it with behavior from other objects. Some of the benefits of using mixins include the following:</p>
			<ul>
				<li><strong class="bo d">Composition</strong>: Mixins allow you to compose<a id="_idIndexMarker585"/> complex behavior from simple, reusable components. This makes it easier to maintain and modify your code over time.</li>
				<li><strong class="bo d">Separation of concerns</strong>: Mixins enable you to separate the concerns of an object by breaking it down into smaller, more focused pieces of functionality. This makes it easier to understand and reason about your code.</li>
				<li><strong class="bo d">Reusability</strong>: Mixins allow you to reuse behavior across multiple objects, which reduces code duplication and makes it easier to maintain and modify your code over time.</li>
				<li><strong class="bo d">Flexibility</strong>: Mixins provide a flexible way to modify the behavior of an object by allowing you to selectively apply behavior as needed. This gives you greater control over the behavior of your code and makes it easier to customize for specific use cases.</li>
				<li><strong class="bo d">Testability</strong>: Mixins allow you to test individual pieces of functionality in isolation, which makes it easier to write <a id="_idIndexMarker586"/>tests and ensure the correctness of your code.</li>
			</ul>
			<p>Mixins are often used in conjunction<a id="_idIndexMarker587"/> with techniques such as pointcuts, which allow you to apply behavior to specific points in your code. Pointcuts provide a way to selectively apply mixins to specific parts of your code, which gives you even greater flexibility and control over the behavior of your code.</p>
			<p>In summary, mixins are a powerful tool for adding behavior to objects in a flexible, maintainable, and reusable way. When used in conjunction with pointcuts and other AOP techniques, they provide a powerful way to customize the behavior of your code and<a id="_idTextAnchor243"/> achieve greater modularity, flexibility, and testability.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor244"/>Authorization</h1>
			<p>Authorization is a critical concern<a id="_idIndexMarker588"/> for many software systems, as it is important to ensure that users and applications only have access to the resources and functionality that they are authorized to use. AOP can be a powerful tool for implementing authorization behavior, as it allows developers to encapsulate authorization logic and apply it consistently throughout the system.</p>
			<p>One approach to implementing authorization with AOP is to use join points to filter down to specific namespaces in C# code. Join points are points in the code where an aspect can be applied, such as method calls, field accesses, or object creation. By using join points to filter down specific namespaces, developers can apply authorization logic only to the relevant parts of the system, reducing the risk of errors or inconsistencies.</p>
			<p>In AOP, a pointcut is a specific location in the source code where an aspect should be applied. In other words, it’s a way to define the set of join points (i.e., specific points in a program’s execution flow) where an aspect should be executed.</p>
			<p>Pointcuts are often defined<a id="_idIndexMarker589"/> using a combination of different criteria, such as method names, method signatures, class names, package names, annotations, and more. The criteria used<a id="_idIndexMarker590"/> to define<a id="_idIndexMarker591"/> a pointcut are typically expressed using a syntax known as a “pointcut expression” or “pointcut language.”</p>
			<p>The pointcut language used may vary depending on the AOP framework being used. For example, in C#, with the help of libraries such as PostSharp, you can define pointcuts using a combination of attribute annotations and method signatures.</p>
			<p>Once a pointcut is defined, it can be used to “weave” one or more aspects into the code at the specified join points. This means that the aspect’s behavior is inserted into the code at the specified join points without requiring any modification to the original source code.</p>
			<p>Overall, pointcuts provide a powerful<a id="_idIndexMarker592"/> way to apply cross-cutting concerns, such as logging, caching<a id="_idTextAnchor245"/>, or security, to specific parts of a program’s execution flow.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor246"/>Using pointcuts</h2>
			<p>With interceptors, you might<a id="_idIndexMarker593"/> not want them applied to everything. This could especially<a id="_idIndexMarker594"/> be true for authorization. You could have parts of your application that do not require authorization, such as infrastructure, and possibly also concrete parts that are open to all users. With Castle Windsor, we can create pointcuts by leveraging selectors for the interceptors. This is a way to provide the actual interceptors to be applied dynamically based on type and method information.</p>
			<p>Let’s create a service for adding to-do items to a list, represented with an <strong class="source-in ine">ITodoService</strong> interface. Create a folder called <strong class="source-in ine">Todo</strong> in the root of the <strong class="source-in ine">Chapter14</strong> project, add a file called <strong class="source-in ine">ITodoService.cs</strong>, and add the following to it:</p>
			<pre class="source-code">
namespace Chapter14.Todo;
public interface ITodoService
{
    void Add(string item);
}</pre>
			<p>The interface only exposes<a id="_idIndexMarker595"/> a simple <strong class="source-in ine">Add()</strong> method for adding an item in the form of a string. Its implementation<a id="_idIndexMarker596"/> should be added to a file called <strong class="source-in ine">TodoService.cs</strong> within the <strong class="source-in ine">Todo</strong> folder and look like the following:</p>
			<pre class="source-code">
namespace Chapter14.Todo;
public class TodoService : ITodoService
{
    public void Add(string item)
    {
        Console.WriteLine($"Adding '{item}' to the todo list");
    }
}</pre>
			<p>Since we’re not focused on building something that creates a <strong class="source-in ine">todo</strong> item in a datastore, we just print what is added in the implementation. This is just to prove how you can leverage interceptors and selectors to filter what calls are made.</p>
			<p>The next thing you will need is an interceptor that checks whether the user is authorized.</p>
			<p>Add a file called <strong class="source-in ine">AuthorizationInterceptor.cs</strong> to the root of the <strong class="source-in ine">Chapter14</strong> project and add<a id="_idIndexMarker597"/> the following<a id="_idIndexMarker598"/> code to it:</p>
			<pre class="source-code">
using Castle.DynamicProxy;
namespace Chapter14;
public class AuthorizationInterceptor : IInterceptor
{
    readonly IUsersServiceComposition _usersService;
    public AuthorizationInterceptor(IUsersServiceComposition
      usersService)
    {
        _usersService = usersService;
    }
    public void Intercept(IInvocation invocation)
    {
        if (_usersService.IsAuthorized("jane@doe.io", invocation.
          Method.Name))
        {
            invocation.Proceed();
        }
    }
}</pre>
			<p>The code implements the Castle <strong class="source-in ine">DynamicProxy</strong> <strong class="source-in ine">IInterceptor</strong> interface, and the constructor has a dependency on the <strong class="source-in ine">IUsersServiceComposition</strong> service you created for the mixins section. The <strong class="source-in ine">Intercept()</strong> method leverages the composed user service to check whether the user is authorized. If the user is authorized, it lets the invocation carry on.</p>
			<p class="ca out-heading">Important note:</p>
			<p class="ca out">The user is hardcoded to <strong class="source-in ine">jane@doe.io</strong>, you would obviously need to get the currently logged-in user in a production system. Also, the implementation does not do anything if it’s not authorized. One approach could be to throw <strong class="source-in ine">UnauthorizedException()</strong> and let that bubble up.</p>
			<p>For the actual pointcut<a id="_idIndexMarker599"/> that will be filtering<a id="_idIndexMarker600"/> down which interceptors to apply when, you must implement the <strong class="source-in ine">IinterceptorSelector</strong> interface found in Castle <strong class="source-in ine">DynamicProxy</strong>. Add a file in the root of the project called <strong class="source-in ine">InterceptorSelector.cs</strong> and add the following code to it:</p>
			<pre class="source-code">
using System.Reflection;
using Castle.DynamicProxy;
namespace Chapter14;
public class InterceptorSelector : IinterceptorSelector
{
    public Iinterceptor[] SelectInterceptors(Type type, MethodInfo
      method, Iinterceptor[] interceptors)
    {
        if (type.Namespace?.StartsWith("Chapter14.Todo",          StringComparison.InvariantCulture) ?? false)
        {
            return interceptors;
        }
        return interceptors.Where(_ =&gt; _.GetType() !=
        typeof(AuthorizationInterceptor)).ToArray();
    }
}</pre>
			<p>The <strong class="source-in ine">SelectInterceptors()</strong> method gets called<a id="_idIndexMarker601"/> with the target type and the method being called, and you’re given<a id="_idIndexMarker602"/> the configured interceptors. You can, at this stage, decide which interceptors should be applied to the method call. The code makes this decision by looking at the namespace of the type and anything that starts with <strong class="source-in ine">Chapter14.Todo</strong> should have all interceptors, while anything else gets all interceptors except <strong class="source-in ine">AuthorizationInterceptor</strong>.</p>
			<p>With the interceptor and the selector in place, you will have to register them both in the Castle Windsor container and hook them up for use in existing registrations. Open the <strong class="source-in ine">DefaultInstaller.cs</strong> file and add the following to the top of the <strong class="source-in ine">Install()</strong> method:</p>
			<pre class="source-code">
container.Register(Component.For&lt;InterceptorSelector&gt;());
container.Register(Component.For&lt;AuthorizationInterceptor&gt;());</pre>
			<p>The code registers both <strong class="source-in ine">InterceptorSelector</strong> and <strong class="source-in ine">AuthorizationInterceptor</strong> with the container, making them possible to be injected into services needing it. In the <strong class="source-in ine">Install()</strong> method, there are two places where you’ve already added <strong class="source-in ine">LoggingInterceptor</strong>; in both these places, we want to add the new <strong class="source-in ine">AuthorizationInterceptor</strong> and also a statement telling Castle Windsor to use the new <strong class="source-in ine">InterceptorSelector</strong> to select the correct interceptors.</p>
			<p>The following lines add the interceptor and selector:</p>
			<pre class="source-code">
.Interceptors&lt;AuthorizationInterceptor&gt;()
.SelectInterceptorsWith(s =&gt; s.Service&lt;InterceptorSelector&gt;())</pre>
			<p>For reference, the block that configures <strong class="source-in ine">IUsersService</strong> needs these two lines:</p>
			<pre class="source-code">
container.Register(
    Component.For&lt;IUsersService&gt;()
        .ImplementedBy&lt;UsersService&gt;()
        .Proxy.AdditionalInterfaces(typeof(IAuthorizer),        typeof(IAuthenticator))
        .Proxy.MixIns(_ =&gt; _
            .Component&lt;Authorizer&gt;()
            .Component&lt;Authenticator&gt;())
        .Interceptors&lt;LoggingInterceptor&gt;()
        // Add the interceptor and the selector
        .Interceptors&lt;AuthorizationInterceptor&gt;()
        .SelectInterceptorsWith(s =&gt; s.Service&lt;InterceptorSelector&gt;())
        .LifestyleTransient());</pre>
			<p>And the second block<a id="_idIndexMarker603"/> that needs<a id="_idIndexMarker604"/> the two lines is generally, by convention, the automatic hookup:</p>
			<pre class="source-code">
container.Register(Classes.FromAssemblyInThisApplication(Assembly.
  GetEntryAssembly())
    .Pick()
    .WithService.DefaultInterfaces()
    .Configure(_ =&gt; _
        .Interceptors&lt;LoggingInterceptor&gt;()
        .Interceptors&lt;AuthorizationInterceptor&gt;()
        // Add the interceptor and the selector
        .Interceptors&lt;AuthorizationInterceptor&gt;()
        .SelectInterceptorsWith(s =&gt;
          s.Service&lt;InterceptorSelector&gt;()))
    .LifestyleTransient());</pre>
			<p>Now that everything is registered, it’s time to try it out. Open the <strong class="source-in ine">Program.cs</strong> file and add the following before <strong class="source-in ine">Console.ReadLine()</strong>:</p>
			<pre class="source-code">
var todo = container.Resolve&lt;ITodoService&gt;();
todo.Add("Buy milk");</pre>
			<p>By running your application<a id="_idIndexMarker605"/> now, you should see the following<a id="_idIndexMarker606"/> output:</p>
			<pre class="source-code">
info: Chapter14.UsersService[1]
      Before invoking Register
info: Chapter14.UsersService[0]
      Inside register method
info: Chapter14.UsersService[3]
      Before invoking Register
info: Chapter14.Authenticator[1]
      Before invoking Authenticate
info: Chapter14.Authenticator[3]
      Before invoking Authenticate
info: Chapter14.Authorizer[1]
      Before invoking IsAuthorized
info: Chapter14.Authorizer[3]
      Before invoking IsAuthorized
Authenticated: True
Authorized: True
Authenticated: True
Authorized: True
info: Chapter14.Todo.TodoService[1]
      Before invoking Add
Adding 'Buy milk' to the todo list
info: Chapter14.Todo.TodoService[3]
      Before invoking Add</pre>
			<p>As expected, you<a id="_idIndexMarker607"/> should be allowed<a id="_idIndexMarker608"/> to buy the milk. Let’s alter the authorizer to not permit this. Open the <strong class="source-in ine">Authorizer.cs</strong> file and return <strong class="source-in ine">false</strong> instead:</p>
			<pre class="source-code">
namespace Chapter14;
public class Authorizer : IAuthorizer
{
    public bool IsAuthorized(string username, string action)
    {
        return false;
    }
}</pre>
			<p>Running the program again should produce a different result with the <strong class="source-in ine">Adding 'Buy milk' to the todo list</strong> output being removed. You’ll still see that the method invocation from the logger happens, but the actual invocation is filtered out:</p>
			<pre class="source-code">
info: Chapter14.UsersService[1]
      Before invoking Register
info: Chapter14.UsersService[0]
      Inside register method
Authenticated: True
info: Chapter14.UsersService[3]
      Before invoking Register
Authorized: False
info: Chapter14.Authenticator[1]
      Before invoking Authenticate
info: Chapter14.Authenticator[3]
      Before invoking Authenticate
info: Chapter14.Authorizer[1]
      Before invoking IsAuthorized
info: Chapter14.Authorizer[3]
      Before invoking IsAuthorized
Authenticated: True
Authorized: False
info: Chapter14.Todo.TodoService[1]
      Before invoking Add
info: Chapter14.Todo.TodoService[3]
      Before invoking Add</pre>
			<p>Windsor Castle provides a flexible<a id="_idIndexMarker609"/> and powerful pointcut<a id="_idIndexMarker610"/> mechanism, based on Castle <strong class="source-in ine">DynamicProxy</strong>, that allows you to select join points based on the metadata found on the type and method. For example, you can create pointcuts based on the following criteria:</p>
			<ul>
				<li>The name of the method</li>
				<li>The return type of the method</li>
				<li>The parameters of the method</li>
				<li>The presence of attributes on the type or method</li>
				<li>The accessibility of the method (e.g., public, private, and so on)</li>
			</ul>
			<p>By combining multiple criteria, you can create complex pointcuts that match very specific sets of join points. For example, you could create a pointcut that matches all public methods with a specific attribute or all non-public methods with a specific name.</p>
			<p>Pointcuts are a powerful mechanism for filtering calls and applying aspects only to specific parts of the code. By using pointcuts, you can avoid the overhead of applying aspects to every single method call and, instead, selectively apply aspects only where they are needed. This can result in faster and more efficient code, with better separation of concerns.</p>
			<p>Overall, pointcuts are a key<a id="_idIndexMarker611"/> feature of AOP, and Windsor Castle provides a rich<a id="_idIndexMarker612"/> and flexible pointcu<a id="_idTextAnchor247"/>t mechanism that can be used to create complex and powerful aspect-based solutions.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor248"/>Summary</h1>
			<p>Although we’ve used Castle Windsor throughout, there are other tools, frameworks, or libr<a href="https://autofac.org">aries that could al</a>so be used, such as PostSharp (<a href="https://www.postsharp.net">https://www.postsharp.net</a>), Autofac (<a href="https://autofac.org">https://autofac.org</a>), or just use the underlying Castle Core <strong class="source-in ine">DynamicProxy</strong> to achieve the same without buying into a full-blown framework. You could be hand-rolling this yourself using reflection emit as well.</p>
			<p>Overall, AOP and Castle Windsor provide a powerful mechanism for separating concerns in your code and making them more modular and reusable. By selectively applying aspects to specific parts of your code, you can achieve a high degree of flexibility and control over the behavior of your application.</p>
			<p>In <a href="B19418_13.xhtml#_idTextAnchor206"><em class="ita ic">Chapter 13</em></a>, <em class="ita ic">Applying Cross-Cutting Concerns</em>, we discussed the importance of reducing risk in your codebase, which is perhaps the most critical use case. Since security is the most vulnerable aspect of our software, it is essential to adopt a zero-trust mindset when it comes to this and take all necessary steps to prevent security vulnerabilities.</p>
			<p>Moving onto the next chapter, we will dive into the power of the C# compiler, also known as Roslyn. With Roslyn, you<a id="_idIndexMarker613"/> get a whole new set of metadata to play with and new capabilities for metaprogramming.</p>
		</div>
	

		<div><h1 id="_idParaDest-165"><a id="_idTextAnchor249"/>Part 4:Compiler Magic Using Roslyn</h1>
			<p>In this part, you will get a glimpse into the C# compiler’s capabilities and the different extension points it provides through the .NET Compiler SDK. It dives into how the compiler has become an ecosystem and how you can do metaprogramming on a compile-time level rather than just the runtime. This part concludes the book with an overview of what the book has covered, thoughts on when to use what, and some closing words.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19418_15.xhtml#_idTextAnchor250"><em class="ita ic">Chapter 15</em></a>, <em class="ita ic">Roslyn Compiler Extensions</em></li>
				<li><a href="B19418_16.xhtml#_idTextAnchor272"><em class="ita ic">Chapter 16</em></a>, <em class="ita ic">Generating Code</em></li>
				<li><a href="B19418_17.xhtml#_idTextAnchor299"><em class="ita ic">Chapter 17</em></a>, <em class="ita ic">Static Code Analysis</em></li>
				<li><a href="B19418_18.xhtml#_idTextAnchor323"><em class="ita ic">Chapter 18</em></a>, <em class="ita ic">Caveats and Final Words</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>