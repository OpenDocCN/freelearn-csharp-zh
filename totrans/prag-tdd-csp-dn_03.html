<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor066"/>3</h1>
<h1 id="_idParaDest-64"><a id="_idTextAnchor067"/>Getting Started with Unit Testing</h1>
<p><strong class="bold">Unit testing</strong> is the core of TDD and a prerequisite for practicing it. I want to briefly go through the minimal necessary theory and focus more instead on familiarizing you with the tools and techniques that unit testing practitioners utilize in their daily code.</p>
<p>Here, you will learn how to write unit tests that cover moderate coding scenarios. In <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, of this book, we will take the knowledge acquired in this chapter to a higher level and use it in a lifelike fashion.</p>
<p>In the previous chapter, we built the <strong class="bold">weather forecasting application</strong> (<strong class="bold">WFA</strong>) and made it a <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>)-ready. We will use this application in this chapter as the basis for learning about unit testing. If you are not familiar with DI and DI containers, I recommend starting with <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>, first.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Introduce unit testing</li>
<li>Explain the structure of a unit testing project</li>
<li>Analyze the anatomy of a unit test class</li>
<li>Discuss the basics of xUnit</li>
<li>Show how SOLID principles and unit testing are related</li>
</ul>
<p>By the end of the chapter, you will be able to write basic unit tests.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor068"/>Technical requirements</h2>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03</a></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>Introducing unit testing</h1>
<p>As a TDD practitioner, you will <a id="_idIndexMarker177"/>be writing much more unit test code than production code (the regular application code). Unlike other test categories, unit tests will dictate some architectural decisions of your application and enforce DI.</p>
<p>We won’t dwell on long definitions. Instead, we will demonstrate unit testing with a plethora of examples. In this section, we will discuss the xUnit unit testing framework and the unit test structure.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>What is unit testing?</h2>
<p><em class="italic">Unit testing is testing a behavior while swapping real dependencies with test doubles</em>. Let me back up this definition with an example from <code>WeatherForecastController</code> in the WFA:</p>
<pre class="source-code">private readonly ILogger<a id="_idTextAnchor071"/>&lt;WeatherForecastController&gt; 
    _logger;
public double ConvertCToF(double c)
{
    double f = c * (9d / 5d) + 32;
    _logger.LogInformation("conversion requested");
    return f;
}</pre>
<p>This method converts Celsius to Fahrenheit and logs every call. Logging is not the concern here because this method’s concern is the conversion.</p>
<p>The <em class="italic">behavior</em> of this method is <em class="italic">converting input degrees from Celsius to Fahrenheit</em>, and the logging <em class="italic">dependency</em> here is accessed through the <code>_logger</code> object. At runtime, we are injecting a <code>Logger&lt;&gt;</code> that will be writing to a physical medium, but we possibly want to eliminate the writing side effect when testing.</p>
<p>Based on the earlier definition, we need to <em class="italic">swap the real dependency</em> that <code>_logger</code> uses at runtime with its test double counterpart and test the conversion behavior. We will show how to do this later on in this chapter.</p>
<p>Take another example from the same class:</p>
<pre class="source-code">private readonly <strong class="bold">IClient _client</strong>;
public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetReal()
{
    …
    OneCallResponse res = await <strong class="bold">_client.OneCallAsync</strong>(…
    …
}</pre>
<p>The behavior of this method is getting the real weather forecast and passing it to the caller. The <code>_client</code> object here represents the OpenWeather dependency. This method’s behavior is <em class="italic">not</em> about interacting with the details of the RESTful protocol of the OpenWeather API or the HTTP protocol. This is handled by <code>_client</code>. We need to swap the real dependency, <code>Client</code>, that <code>_client</code> uses at runtime, and replace it with one that is suitable <a id="_idIndexMarker178"/>for testing (we call this a <strong class="bold">test double</strong>). I will show how this is done, in many ways, in <a href="B18370_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>, <em class="italic">Real Unit Testing with Test Doubles</em>.</p>
<p>At this stage, the concept is still cryptic, I know; just bear with me, and we will start expanding gently. In the next section, we will discuss unit testing frameworks. We will need this to unit test the preceding examples and the WFA.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Unit testing frameworks</h2>
<p>.NET 6 has three major <a id="_idIndexMarker179"/>unit testing frameworks. The most popular one is <strong class="bold">xUnit</strong>, which we will use<a id="_idIndexMarker180"/> across this book. The other two are <strong class="bold">NUnit</strong> and <strong class="bold">MSTest</strong>:</p>
<ul>
<li><em class="italic">NUnit</em> is an open source library. It<a id="_idIndexMarker181"/> started as a port from Java’s JUnit <a id="_idIndexMarker182"/>framework and was then completely rewritten. You will still encounter it in legacy projects, but the majority of today’s projects start with xUnit.</li>
<li><em class="italic">MSTest</em> is Microsoft’s unit testing<a id="_idIndexMarker183"/> framework that gained popularity because it used to be shipped with Visual Studio and no extra effort <a id="_idIndexMarker184"/>was needed to install it, especially since NuGet did not exist back then. It became open source in version 2, and it was always lagging behind NUnit and then xUnit in terms of features.</li>
<li><em class="italic">xUnit</em> is an open source project <a id="_idIndexMarker185"/>that was started by developers <a id="_idIndexMarker186"/>from NUnit. It is feature-rich and in constant development.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">The term <strong class="bold">XUnit</strong> is an umbrella<a id="_idIndexMarker187"/> term for different languages’ unit test frameworks, such as <strong class="bold">JUnit</strong> (<strong class="bold">Java</strong>), <strong class="bold">NUnit</strong> (<strong class="bold">.NET</strong>), <strong class="bold">xUnit</strong> (<strong class="bold">.NET</strong>), and <strong class="bold">CUnit</strong> (<strong class="bold">C language</strong>). This should not be <a id="_idIndexMarker188"/>confused with the library name <em class="italic">xUnit</em>, which is a .NET unit test <a id="_idIndexMarker189"/>library, where the<a id="_idIndexMarker190"/> founders picked an already-taken and confusing name.</p>
<p>Learning one framework and then switching to another should take no time, as they are similar, and you just need to figure out the terminology used by the specific framework. Next, we will add an xUnit project to the solution to unit test the WFA.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor073"/>Understanding test projects</h1>
<p>xUnit templates come as part of <a id="_idIndexMarker191"/>VS. We will show how to add an xUnit project using the <strong class="bold">.NET CLI</strong> approach. At this stage, if you have not opened the companion source code that is ported from <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>, to this chapter, I encourage you to do so.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/>Adding xUnit via the CLI</h2>
<p>Currently, we have a <a id="_idIndexMarker192"/>solution with one ASP.NET Core project. Now, we <a id="_idIndexMarker193"/>want to add the unit tests library to our solution. To do so, create a new xUnit project called <code>Uqs.Weather.Tests.Unit</code> in a directory with the same name, and use .NET 6.0:</p>
<pre>dotnet new xunit -o Uqs.Weather.Tests.Unit -f net6.0</pre>
<p>Add the newly created project to the solution file:</p>
<pre>dotnet sln add Uqs.Weather.Tests.Unit</pre>
<p>Now, we have two projects in our solution. As the unit test project will be testing the ASP.NET Core project, the unit test project should have a reference to the ASP.NET Core project.</p>
<p>Add a project reference from <code>Uqs.Weather.Tests.Unit</code> on <code>Uqs.Weather</code>:</p>
<pre>dotnet add Uqs.Weather.Tests.Unit reference Uqs.Weather</pre>
<p>We now have our solution fully constructed via the CLI. You can see the full interaction here:</p>
<div><div><img alt="Figure 3.1 – Creating a new xUnit project in a solution via the CLI " height="508" src="img/Figure_3.1_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Creating a new xUnit project in a solution via the CLI</p>
<p>We now have a<a id="_idIndexMarker194"/> project to contain<a id="_idIndexMarker195"/> our unit tests.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor075"/>Test project naming convention</h2>
<p>You have noticed that <a id="_idIndexMarker196"/>we have appended <code>.Tests.Unit</code> to the original project name, so the unit test project became <code>Uqs.Weather.Tests.Unit</code>. This is a common convention in naming test projects.</p>
<p>This convention extends to other testing projects, such as integration testing and Sintegration testing, to be discussed in the <em class="italic">More testing categories</em> section in <a href="B18370_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>. You might also have the following:</p>
<ul>
<li><code>Uqs.Weather.Tests.Integration</code></li>
<li><code>Uqs.Weather.Tests.Sintegration</code></li>
</ul>
<p>The wisdom behind this convention is that you can look at your list of projects and rapidly find the test projects related to one production code project ordered next to each other, as follows:</p>
<div><div><img alt="Figure 3.2 – Ordered unit test projects " height="424" src="img/Figure_3.2_B18370.jpg" width="509"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Ordered unit test projects</p>
<p>The convention also <a id="_idIndexMarker197"/>helps in targeting all your test projects in the continuous integration, which will be covered in <a href="B18370_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Continuous Integration with GitHub Actions</em>, in case you wanted to run all categories of tests. Here is an example: <code>Uqs.Weather.Tests.*</code>.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor076"/>Running the sample unit test</h2>
<p>The xUnit template comes<a id="_idIndexMarker198"/> with a sample unit test class called <code>UnitTest1.cs</code> that has a sample unit test method with the following content:</p>
<pre class="source-code">using Xunit;
namespace Uqs.Weather.Tests.Unit;
public class UnitTest1
{
    [Fact]
    public void Test1()
    {
    }
}</pre>
<p>This has a single unit test called <code>Test1</code> that is empty and does nothing at the moment. To check that the xUnit framework and the integration with VS does work, you can try executing this single test.</p>
<p>From the VS menu, select <strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong> or similarly use the <em class="italic">Ctrl</em> + <em class="italic">R</em>, <em class="italic">A</em> keyboard shortcut. This will execute all your tests in the project (which is currently one test), and you will have the following tool, known as <strong class="bold">Test Explorer</strong>.</p>
<div><div><img alt="Figure 3.3 – Test Explorer " height="336" src="img/Figure_3.3_B18370.jpg" width="1073"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Test Explorer</p>
<p>The hierarchy displayed here is <strong class="bold">Project Name</strong> | <strong class="bold">Test Class Namespace</strong> | <strong class="bold">Test Class Name</strong> | <strong class="bold">Test Method Name</strong>.</p>
<p>If you are the CLI kind of<a id="_idIndexMarker199"/> person, you can go to the solution directory with the command prompt and execute the following:</p>
<pre>dotnet test</pre>
<p>This is what you may get:</p>
<div><div><img alt="Figure 3.4 – CLI dotnet test results " height="407" src="img/Figure_3.4_B18370.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – CLI dotnet test results</p>
<p>I have seen <strong class="bold">Test Explorer</strong> used more in day-to-day TDD-style development than the CLI. The CLI is useful for running the whole solution or for continuous integration and automated runs.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor077"/>Test Explorer</h2>
<p>Test Explorer <a id="_idIndexMarker200"/>comes with VS. Additionally, xUnit<a id="_idIndexMarker201"/> adds a few libraries that allow Test Explorer and VS to interact with xUnit tests. There are third-party providers that have more advanced test runners. One of them is <em class="italic">JetBrains ReSharper Unit Test Explorer</em>. We have everything ready to start writing unit test code.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Unit test class anatomy</h1>
<p>When we unit test, we tend to write a <strong class="bold">unit test class</strong> that is targeting a parallel production class – one test class against one production class.</p>
<p>Applying this concept to<a id="_idIndexMarker202"/> our WFA project, our production class is <code>WeatherForecastController</code> and the unit test class is going to be called <code>WeatherForecastControllerTests</code>. So, rename the <code>UnitTest1</code> sample class to <code>WeatherForecastControllerTests</code>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can set your text cursor anywhere within the class name in the source code (in the previous case, it was <code>UnitTest1</code>) and hit <em class="italic">Ctrl</em> + <em class="italic">R</em>, <em class="italic">R</em> (hold <em class="italic">Ctrl</em> then press <em class="italic">R</em> quickly twice). Type the new name <code>WeatherForecastControllerTests</code> and hit <em class="italic">Enter</em>. This will also rename the file if the <strong class="bold">Rename symbol’s file</strong> checkbox is ticked.</p>
<p>Next, we will see how to organize our <a id="_idIndexMarker203"/>unit test class and its methods.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor079"/>Class naming convention</h2>
<p>I found the most commonly<a id="_idIndexMarker204"/> used convention is calling the unit test class name the same as the production code class name, appending the <code>Tests</code> suffix. For example, the <code>MyProductionCode</code> test class counterpart would be <code>MyProductionCodeTests</code>.</p>
<p>When practicing TDD, you will need to switch between the test class and its counterpart production code class multiple times in a short period. Naming them using this pattern allows you to find the test and its related counterpart easily, or vice versa. It also clarifies the relationship between the two classes.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Test methods</h2>
<p>Each test class contains methods that<a id="_idIndexMarker205"/> test pieces of functionality, known as units, from the production code class. Let’s take the example of testing the <code>ConvertCToF</code> method.</p>
<h3>Test example 1</h3>
<p>Part of the requirements that <a id="_idIndexMarker206"/>we have is testing the conversion with a single decimal point accuracy. So, let’s consider one testing case by taking a zero degree (0.0 C) and testing if the method is returning 32.0 F. To do that, we can delete the <code>Test1</code> method in the unit tests class and replace it w<a id="_idTextAnchor081"/>ith the following:</p>
<pre class="source-code">[Fact]
public void ConvertCToF_0Celsius_32Fahrenheit()
{
    const double expected = 32d;
    var controller = new WeatherForecastController(
        null!, null!, null!, null!);
    double actual = controller.ConvertCToF(0);
    Assert.Equal(expected, actual);
}</pre>
<p>This code initializes the production code class, calls the method under test, and then assesses the results of the test with our expectations.</p>
<p><code>Fact</code> is an attribute that makes a method a unit test. <code>Assert</code> is a static class that has useful methods for comparing expected results to actual results. Both <code>Fact</code> and <code>Assert</code> are part of the xUnit framework.</p>
<p>Run this test with Test Explorer using <em class="italic">Ctrl</em> + <em class="italic">R</em>, <em class="italic">A</em>, and the test will yield the following screen:</p>
<div><div><img alt="Figure 3.5 – Fail output in Test Explorer " height="384" src="img/Figure_3.5_B18370.jpg" width="1144"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Fail output in Test Explorer</p>
<p>If we look inside the controller, we<a id="_idIndexMarker207"/> find that VS has a red sign to map the route that led to this failure:</p>
<div><div><img alt="Figure 3.6 – VS showing the failed test route " height="429" src="img/Figure_3.6_B18370.jpg" width="819"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – VS showing the failed test route</p>
<p>It is apparent from the error message what is causing <code>ArgumentNullException</code>:</p>
<pre class="source-code">_logger.LogInformation("conversion requested");</pre>
<p>This is expected, as we have passed the <code>logger</code> parameter from the unit test as <code>null</code>. We want <code>_logger.LogInformation</code> to do nothing, and in order to do that, we will be using <code>NullLogger&lt;&gt;</code>, which does nothing, as indicated by the official documentation. Our unit test code needs to change to the following so that we can replace the real logger with a dummy one:</p>
<pre class="source-code">var logger = 
    NullLogger&lt;WeatherForecastController&gt;.Instance;
var controller = new WeatherForecastController(
    logger, null!, null!, null!);</pre>
<p>If you run the test again, all the reds will turn green, and the test will pass.</p>
<h3>Test example 2</h3>
<p>To test another input and <a id="_idIndexMarker208"/>output for the method, we can add more unit tests to the class and follow the same test method name pattern. We can have the following:</p>
<pre class="source-code">public void ConvertCToF_1Celsius_33p8Fahrenheit() {…}
…
public void ConvertCToF_Minus1Celsius_30p2Fahrenheit() {…}</pre>
<p>But, there is a succinct solution for avoiding writing a similar unit test for every value combination, as follows:</p>
<pre class="source-code"><strong class="bold">[Theory]</strong>
<strong class="bold">[InlineData(-100 , -148)]</strong>
<strong class="bold">[InlineData(-10.1,  13.8)]</strong>
<strong class="bold">[InlineData(10   ,  50)]</strong>
public void ConvertCToF_Cel_CorrectFah(<strong class="bold">double c, double f</strong>)
{
    var logger = 
        NullLogger&lt;WeatherForecastController&gt;.Instance;
    var controller = new WeatherForecastController(
        logger, null!, null!, null!);
    double actual = controller.ConvertCToF(c);
    Assert.Equal(f, actual, 1);
}</pre>
<p>Notice that we are using <code>Theory</code> rather than <code>Fact</code>. Every <code>InlineData</code> will act as a single unit test. You can even eliminate <em class="italic">example 1</em> and make it an <code>InlineData</code> attribute. No need to say that <code>Theory</code> and <code>InlineData</code> are attributes from xUnit.</p>
<p>You can go ahead and run the tests.</p>
<p>Other examples are covered in <a href="B18370_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Writing Your First TDD Implementation</em>, similar to the previous ones in this chapter, so you could have a look for more clarity.</p>
<p><em class="italic">Examples 1</em> and <em class="italic">2</em> target a simple method, <code>ConvertCToF</code>, that has a single dependency, <code>_logger</code>. We will cover more sophisticated testing scenarios after learning about test doubles in <a href="B18370_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>, <em class="italic">Real Unit Testing with Test Doubles</em>. In reality, your production code will be more complicated than a simple conversion method and will contain multiple <a id="_idIndexMarker209"/>dependencies, but there is a first step for everything.</p>
<h3>Naming convention</h3>
<p>Unit test method names follow <a id="_idIndexMarker210"/>a popular convention: <code>MethodUnderTest_Condition_Expectation</code>. We have seen this convention used earlier. Here are more hypothetical examples:</p>
<ul>
<li><code>SaveData_CannotConnectToDB_InvalidOperationException</code></li>
<li><code>OrderShoppingBasket_EmptyBasket_NoAction</code></li>
</ul>
<p>This book contains plenty of other examples that should clarify this convention further.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor082"/>The Arrange-Act-Assert pattern</h2>
<p>The previous test method, and <a id="_idIndexMarker211"/>generally all unit test methods, follows a<a id="_idIndexMarker212"/> similar pattern:</p>
<ol>
<li>Create a state, declare some variables, and do some preparations.</li>
<li>Call the method under test.</li>
<li>Assert the actual results against expectations.</li>
</ol>
<p>Practitioners decided to give these three stages the following names: </p>
<p><strong class="bold">Arrange</strong>, <strong class="bold">Act</strong>, and <strong class="bold">Assert</strong> (<strong class="bold">AAA</strong>). </p>
<p>They mark the code with a comment to show the stages and emphasize the separation. According to this, we can write one of the previous test methods as follows:</p>
<pre class="source-code">[Fact]
public void ConvertCToF_0Celsius_32Fahrenheit()
{
    <strong class="bold">// Arrange</strong>
    const double expected = 32d;
    var controller = new WeatherForecastController(…);
    <strong class="bold">// Act</strong>
    double actual = controller.ConvertCToF(0);
    
    <strong class="bold">// Assert</strong>
    Assert.Equal(expected, actual);
}</pre>
<p>Notice the comments that were added to the code.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Some teams dislike having the separation by writing comments. Instead, they choose a different way to mark AAA, for example, by leaving a single line space between each section.</p>
<p>The AAA practice is more than<a id="_idIndexMarker213"/> a convention. It makes the method easier to read on-the-fly. It also emphasizes that there should be only one <em class="italic">Act</em> in a unit test method. Consequently, a unit test, based on best practices, is not supposed to have more than a single AAA structure.</p>
<h3>Using VS code snippets</h3>
<p>Every unit test is going to <a id="_idIndexMarker214"/>have the same structure. VS allows you to cut down on writing the same structure with the help of <code>CodeSnippets</code> directory in this chapter source code. It is called <code>aaa.snippet</code>. You can open it and view/edit its content via a regular text editor (not a word processor).</p>
<p>To use this snippet on Windows, copy <code>aaa.snippet</code> to this directory (choosing the right VS version):</p>
<pre>%USERPROFILE%\Documents\Visual Studio <strong class="bold">2022</strong>\Code Snippets\Visual 
C#\My Code Snippets</pre>
<p>Once this is copied, in your unit test class, type <code>aaa</code>, then hit the <em class="italic">Tab</em> button, and you will get the following generated code:</p>
<pre class="source-code">[Fact]
public void Method_Condition_Expectation()
{
    // Arrange
    // Act
    // Assert
}</pre>
<p>Rather than speaking more about having a single AAA in your unit test, we will demonstrate this across this book to illuminate the style that seniors use in writing unit tests.</p>
<p>Now that we had an overview<a id="_idIndexMarker216"/> of the class anatomy and the unit test method structure, we will explore the unit test class’s counterpart: the system under test. </p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor083"/>System under test</h2>
<p>A unit test is meant to test a single functionality of a production code. Each unit test class has a production code<a id="_idIndexMarker217"/> counterpart that is being tested. We refer to the<a id="_idIndexMarker218"/> production code being tested as the <strong class="bold">system under test</strong> (<strong class="bold">SUT</strong>). You can see here an illustration of what the SUT is:</p>
<div><div><img alt="Figure 3.7 – Unit tests operating against the SUT " height="762" src="img/Figure_3.7_B18370.jpg" width="1351"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Unit tests operating against the SUT</p>
<p>The term SUT is the most dominant one, but you might find others refer to it as <strong class="bold">class under test</strong> (<strong class="bold">CUT</strong>), <strong class="bold">code under test</strong> (<strong class="bold">CUT</strong> – yes, it is the<a id="_idIndexMarker219"/> same acronym), or <strong class="bold">method under test</strong> (<strong class="bold">MUT</strong>).</p>
<p>The term <em class="italic">SUT</em> is used in developers’ conversations, and it is <a id="_idIndexMarker220"/>also commonly <a id="_idIndexMarker221"/>used in the code to make it clear what is being tested, like this:</p>
<pre class="source-code">var <strong class="bold">sut</strong> = new ProductionCode(…);</pre>
<p>It is important to understand the<a id="_idIndexMarker222"/> SUT of your unit test class. You will gradually notice as your project grows that you will have a pattern being formed, as follows:</p>
<div><div><img alt="Figure 3.8 – Unit test project versus production code project " height="505" src="img/Figure_3.8_B18370.jpg" width="784"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Unit test project versus production code project</p>
<p>Every unit test class is paired with an SUT counterpart.</p>
<p>Now that we have seen a few features of xUnit both here and in <a href="B18370_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Writing Your First TDD Implementation</em>, it is time to have a closer look at xUnit.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>The basics of xUnit</h1>
<p>xUnit provides the hosting environment <a id="_idIndexMarker223"/>for your tests. One important feature of xUnit is that it is AAA-convention friendly. It also integrates with the VS IDE and its Test Explorer.</p>
<p>Extensive examples using xUnit appear naturally in this book. However, it is worth dedicating a few sections to discussing the principal features of this framework.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor085"/>Fact and theory attributes</h2>
<p>In your test project, any method<a id="_idIndexMarker224"/> that is decorated with <code>Fact</code> or <code>Theory</code> will become a test method. <code>Fact</code> is meant for a non-parametrized unit test, and <code>Theory</code> is for a parametrized <a id="_idIndexMarker225"/>one. With <code>Theory</code>, you can add other attributes, such as <code>InlineData</code>, for parametrization.</p>
<p class="callout-heading">Note</p>
<p class="callout">VS will give you a visual indication above the method name that you can run the methods decorated with these attributes, but sometimes it doesn’t until you run all the tests.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor086"/>Running the tests</h2>
<p>Each unit test will <em class="italic">run independently</em> and instantiate<a id="_idIndexMarker226"/> the class. The unit tests <em class="italic">do not share</em> each other’s states. So, a unit test class runs differently than a normal class. Let me elaborate with a sample code, shown here:</p>
<pre class="source-code">public class SampleTests
{
    private int _instanceField = 0;
    private static int _staticField = 0;
    [Fact]
    public void UnitTest1()
    {
        _instanceField++;
        _staticField++;
        Assert.Equal(<strong class="bold">1</strong>, _instanceField);
        Assert.Equal(<strong class="bold">1</strong>, _staticField);
    }
    [Fact]
    public void UnitTest2()
    {
        _instanceField++;
        _staticField++;
        Assert.Equal(<strong class="bold">1</strong>, _instanceField);
        Assert.Equal(<strong class="bold">2</strong>, _staticField);
    }
}</pre>
<p>The previous unit tests do pass. Notice that while I am incrementing <code>_instanceField</code> in both test methods, the value of <code>_instanceField</code> is not shared between the two methods, and <a id="_idIndexMarker227"/>every time xUnit is instantiating a method, all my class is instantiated again. This is why the value is reset back to <code>0</code> before every method execution. This<a id="_idIndexMarker228"/> characteristic of xUnit promotes a unit test principle known as <strong class="bold">no interdependency</strong>, which will be discussed in <a href="B18370_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">The FIRSTHAND Guidelines of TDD</em>.</p>
<p>On the other hand, the static field was shared between the two methods and its value has changed. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">While I have used both instance and static fields to illustrate the distinctive behavior of a unit test class, I want to emphasize that using a static <code>read-write</code> field in a unit test is an anti-pattern because this breaks the <em class="italic">no interdependency</em> principle. In general, you should have no common <code>write</code> fields in unit test classes, and fields are better to be marked with the <code>readonly</code> keyword.</p>
<p>Instead, if the same methods are<a id="_idIndexMarker229"/> part of a regular code class (not a unit test class) and both are called, we expect to find the value of <code>_instanceField</code> incremented to <code>2</code>, but this was not the case here.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor087"/>Assert class</h2>
<p><code>Assert</code> is a static class, and it is <a id="_idIndexMarker230"/>part of xUnit. This is how the official documentation defines <a id="_idIndexMarker231"/>the <code>Assert</code> class:</p>
<p>Contains various static methods that are used to verify0 that conditions are met.</p>
<p>Let’s have a quick overview of some of the methods of <code>Assert</code>:</p>
<ul>
<li><code>Equal(expected, actual)</code>: These are a series of overloads that will compare the expectations to actuals. You have seen a few examples of <code>Equal</code> in <a href="B18370_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Writing Your First TDD Implementation</em>, and in this chapter.</li>
<li><code>True(actual)</code>: Rather than using <code>Equal</code> to compare two objects, you can use this one where relevant to promote readability. Let’s clarify this with an example:<pre>Assert.Equal(true, isPositive);
// or
Assert.True(isPositive);</pre></li>
<li><code>False(actual)</code>: The opposite of the previous method.</li>
<li><code>Contains(expected, collection)</code>: A group of overloads that check for the existence of a single<a id="_idIndexMarker232"/> element in a collection.</li>
<li><code>DoesNotContain(expected, collection)</code>: The opposite of the previous method.</li>
<li><code>Empty(collection)</code>: This verifies that<a id="_idIndexMarker233"/> a collection is empty.</li>
<li><code>Assert.IsType&lt;Type&gt;(actual)</code>: This verifies whether an object is of a certain type.</li>
</ul>
<p>As there are more methods, I encourage you to visit the official xUnit site to have a look, or to do what most developers do: write <code>Assert</code> in a unit test class, and type a <em class="italic">dot</em> after it to trigger IntelliSense and view the displayed methods.</p>
<p>The methods of <code>Assert</code> will communicate with the test runner, such as Test Explorer, to report back the result of the assertions.</p>
<h3>Record class</h3>
<p>The <code>Record</code> class is a static <a id="_idIndexMarker234"/>class that records exceptions so that you can test whether your method is throwing or not throwing the right exception. This is an example of one of its static methods, which is called <code>Exception()</code>:</p>
<p><code>public static System.Exception Exception(Action testCode)</code></p>
<p>The previous code returns the exception that is thrown by <code>Action</code>. Let’s take this example:</p>
<pre class="source-code">[Fact]
public void Load_InvalidJson_FormatException()
{
    // Arrange
    string input = "{not a valid JSON";
    // Act
    var exception = <strong class="bold">Record.Exception</strong>(() =&gt; 
        JsonParser.Load(input));
        
    // Assert
    Assert.IsType&lt;FormatException&gt;(exception);
}</pre>
<p>Here, we are checking<a id="_idIndexMarker235"/> whether the <code>Load</code> method will throw <code>FormatException</code> if it is presented with an invalid JSON input.</p>
<p>This was a summary of xUnit’s functionality, and this should get you started writing basic unit tests.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/>Applying SOLID principles to unit testing</h1>
<p>The SOLID principles are highly<a id="_idIndexMarker236"/> covered and advertised on the web and in books. Chances are that this is not the first time that you’ve heard or read about <a id="_idIndexMarker237"/>them. They are a popular interview question as well. SOLID principles stand for the following:</p>
<ul>
<li><em class="italic">S</em>ingle-responsibility principle</li>
<li><em class="italic">O</em>pen-closed principle</li>
<li><em class="italic">L</em>iskov Substitution principle</li>
<li><em class="italic">I</em>nterface Segregation principle</li>
<li><em class="italic">D</em>ependency Inversion</li>
</ul>
<p>In this section, we are interested mostly in the relationship between the SOLID principles and unit testing. While not all the principles have strong ties with unit testing, we will cover all of them for completion.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor089"/>Single-responsibility principle</h2>
<p>The <strong class="bold">single-responsibility principle</strong> (<strong class="bold">SRP</strong>) is about having each class with one responsibility only. This will lead it to <a id="_idIndexMarker238"/>have one reason to change. The benefits of this approach are as follows:</p>
<ul>
<li><strong class="bold">Easier to read and understand classes</strong>:</li>
</ul>
<p>The classes will have <a id="_idIndexMarker239"/>fewer methods, which should cause less code. Its interface will have fewer methods as well.</p>
<ul>
<li><strong class="bold">Less rippling effect when changing a feature</strong>:</li>
</ul>
<p>There are fewer classes to change, which would lead to an easier change.</p>
<ul>
<li><strong class="bold">Less probability of change, which means fewer potential bugs</strong>:</li>
</ul>
<p>More code means more potential bugs, and changing code would also lead to potential bugs. Having less code in the first place means fewer code changes.</p>
<h3>Example</h3>
<p>The SRP is not an exact science, and the challenge is being able to decide what <em class="italic">responsibility</em> is. Every developer has their own view. The next example illustrates the idea.</p>
<p>Let’s assume you have created <a id="_idIndexMarker240"/>your own file format called <em class="italic">ABCML</em> to solve a particular problem, as the existing file formats (such as JSON, XML, and others) do not satisfy your specific need. A set of classes with each having a single responsibility could be as follows:</p>
<ul>
<li>A class to validate whether the content of the file is in the right structure</li>
<li>A class to export ABCML to a generic format</li>
<li>A class that inherits the generic ABCML export to support exporting to JSON, and another class that supports exporting to XML</li>
<li>A class that represents a node in your ABCML</li>
<li>More classes</li>
</ul>
<p>You can see how I split <a id="_idIndexMarker241"/>responsibilities into individual classes, although there is no single design for having a single responsibility.</p>
<h3>SRP and unit testing</h3>
<p>Naturally, when doing unit<a id="_idIndexMarker242"/> testing, you think of a single responsibility<a id="_idIndexMarker243"/> for a class, and you call your unit test class the same name with the <code>tests</code> suffix. So, if you are thinking of testing the validation of the ABCML file format, you might have <code>ABCMLValidationTests</code>.</p>
<p>In your unit test class, each unit test targets a single behavior in your SUT. Those behaviors combined lead to a single responsibility.</p>
<div><div><img alt="Figure 3.9 – Multiple single behavior tests targeting a single responsibility " height="407" src="img/Figure_3.9_B18370.jpg" width="1363"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Multiple single behavior tests targeting a single responsibility</p>
<p>The previous figure shows multiple tests, each test is focused on a single behavior, and they are targeting one responsibility: <em class="italic">validation</em>. On the right, there is one method, but this is only for illustration, as you might have multiple public methods and you can still have a single responsibility.</p>
<p>In <a href="B18370_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">The FIRSTHAND Guidelines of TDD</em>, we will introduce a guideline known as the <em class="italic">single-behavior guideline</em>. This guideline<a id="_idIndexMarker244"/> works with TDD and unit tests<a id="_idIndexMarker245"/> to encourage the SRP.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/>Open-closed principle</h2>
<p>The <strong class="bold">open-closed principle</strong> (<strong class="bold">OCP</strong>) is about <a id="_idIndexMarker246"/>preparing your class to be inheritable (having it open) so that any feature addition could just inherit this<a id="_idIndexMarker247"/> class without modifying it (having it closed).</p>
<p>The essence of this principle is to minimize unnecessary changes every time a new feature is added.</p>
<h3>Example</h3>
<p>Let’s take an example that will<a id="_idIndexMarker248"/> make this clearer. Assume we have created a library to do arithmetic calculations. Let’s start by <em class="italic">not being OCP-compliant</em>, as shown here:</p>
<pre class="source-code">public interface IArithmeticOperation {}
public class Addition : IArithmeticOperation
{
    public double Add(double left, double right) =&gt; 
        left + right;
}
public class Subtraction : IArithmeticOperation { … }
public class Calculation
{
    public double Calculate(IArithmeticOperation op, 
        double left, double right) =&gt; 
        op switch
        {
          Addition addition =&gt; addition.Add(left, right),
          Subtraction sub =&gt; sub.Subtract(left, right),
          <strong class="bold">//Multiplication mul =&gt; mul.Multiply(left,right)</strong>,
          _ =&gt; throw new NotImplementedException()
        };
}</pre>
<p>The <code>Calculate</code> method in the preceding code will have to change every time we add a new <code>ArithmeticOperation</code>. If we want to add the multiplication operation, per the commented line, as a feature at a later stage, then the <code>Calculate</code> method will need to change to accommodate the new feature.</p>
<p>We can make this implementation <a id="_idIndexMarker249"/>more OCP-compliant by eliminating the need to change the <code>Calculate</code> method every time a new operation is added. Let’s see how this can be done:</p>
<pre class="source-code">public interface IArithmeticOperation 
{
    public double Operate(double left, double right);
}
public class Addition : IArithmeticOperation
{
    public double Operate(double left, double right) =&gt; 
        left + right;
}
public class Subtraction : IArithmeticOperation { … }
// public class Multiplication : IArithmeticOperation { … }
public class Calculation
{
    public double Calculate(IArithmeticOperation op, 
        double left, double right) =&gt; 
            op.Operate(left, right);
}</pre>
<p>The previous example leveraged polymorphism to stop the <code>Calculation</code> method from being changed every time a new operation is added. You can see from the commented line how a new multiplication operation can be added. This is a more OCP-compliant approach.</p>
<p class="callout-heading">Note</p>
<p class="callout">While I had all the classes and interfaces listed together here and on the GitHub code, I did this for illustration, as they are usually separated into their own files. So, with the OCP, you also reduce the chance of changing the file and make it easier on the source control level to understand what changed.</p>
<h3>OCP and unit testing</h3>
<p>Unit testing protects changes in any class by making sure that a change does not inadvertently break an existing<a id="_idIndexMarker250"/> feature. The OCP and unit testing <a id="_idIndexMarker251"/>work hand in hand. So, while the OCP reduces the chance of avoidable changes, the unit testing adds an additional protection layer when a change is made by verifying business rules.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor091"/>Liskov substitution principle</h2>
<p>The <strong class="bold">Liskov substitution principle</strong> (<strong class="bold">LSP</strong>) states that an instance of a child class must replace an instance of the parent class without <a id="_idIndexMarker252"/>affecting the results that we would get from an instance of the base class itself. A child class should<a id="_idIndexMarker253"/> be a true representation of its parent class.</p>
<h3>Example</h3>
<p>We shall use an academic <a id="_idIndexMarker254"/>type of example that will make the concept easier to understand. Let’s take the following example:</p>
<pre class="source-code">public abstract class Bird
{
    public abstract void Fly();
    public abstract void Walk();
}
public class Robin : Bird
{
    public override void Fly() =&gt; Console.WriteLine("fly");
    public override void Walk() =&gt; 
        Console.WriteLine("walk");
}
public class Ostrich : Bird 
{
    <strong class="bold">public override void Fly() =&gt; </strong>
        <strong class="bold">throw new InvalidOperationException();</strong>
    public override void Walk() =&gt;
        Console.WriteLine("walk");
}</pre>
<p>In the previous code, and according to LSP, <code>Ostrich</code> should not have inherited <code>Bird</code>. Let’s rectify the code to comply with the LSP:</p>
<pre class="source-code">public abstract class Bird
{
    public abstract void Walk();
}
<strong class="bold">public abstract class FlyingBird : Bird</strong>
<strong class="bold">{</strong>
<strong class="bold">    public abstract void Fly();</strong>
<strong class="bold">}</strong>
public class Robin : FlyingBird
{
    public override void Fly() =&gt; Console.WriteLine("fly");
    public override void Walk() =&gt; 
        Console.WriteLine("walk");
}
public class Ostrich : Bird 
{
    public override void Walk() =&gt; 
        Console.WriteLine("walk");
}</pre>
<p>We have changed the inheritance <a id="_idIndexMarker255"/>hierarchy by introducing a new intermediary class called <code>FlyingBird</code> for compliance with the LSP.</p>
<h3>LSP and unit testing</h3>
<p>Unit testing has no<a id="_idIndexMarker256"/> direct impact on the LSP, but the LSP is<a id="_idIndexMarker257"/> mentioned here for completion.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor092"/>Interface segregation principle</h2>
<p>The <strong class="bold">interface segregation principle</strong> (<strong class="bold">ISP</strong>) states that child classes should not be forced to depend upon interfaces that <a id="_idIndexMarker258"/>they do not use. Interfaces <a id="_idIndexMarker259"/>should be smaller so that <a id="_idIndexMarker260"/>whoever is implementing them can mix and match.</p>
<h3>Example</h3>
<p>I always find the way collections<a id="_idIndexMarker261"/> implement in .NET is the best example to explain this principle. Let’s look at how <code>List&lt;T&gt;</code> is declared:</p>
<pre class="source-code">public class List&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;,  
  IList&lt;T&gt;, IReadOnlyCollection&lt;T&gt;, IReadOnlyList&lt;T&gt;, IList</pre>
<p>It is implementing six interfaces. Each interface contains a limited number of methods. <code>List&lt;T&gt;</code> provides a huge number of methods, but the way it does that is by selecting multiple interfaces, with each interface adding a few of the methods.</p>
<p>One method that <code>List&lt;T&gt;</code> exposes is <code>GetEnumerator()</code>. This method comes from the <code>IEnumerable&lt;T&gt;</code> interface; actually, it is the only method on <code>IEnumerable&lt;T&gt;</code>.</p>
<p>By having small interfaces (interfaces of few and related methods), as in this example, <code>List&lt;T&gt;</code> was able to choose what it needs to implement, no more and no less.</p>
<h3>ISP and unit testing</h3>
<p>Unit testing has no direct <a id="_idIndexMarker262"/>impact on the ISP, but the ISP is <a id="_idIndexMarker263"/>mentioned here for completion.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor093"/>Dependency inversion principle</h2>
<p>The <strong class="bold">dependency inversion principle</strong> (<strong class="bold">DIP</strong>) states that high-level modules should not depend on low-level modules. Both<a id="_idIndexMarker264"/> should depend on abstractions. Abstractions should not depend on details. Details should depend on<a id="_idIndexMarker265"/> abstractions. In other words, the DIP is a principle that promotes loose coupling between classes by using abstractions and DI.</p>
<h3>Example</h3>
<p><a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>, is focused on this topic, and it is rich with examples <a id="_idIndexMarker266"/>of changing the code to enable DI.</p>
<h3>DIP and unit testing</h3>
<p>There is a tight relationship between the DIP and unit testing. Real unit tests cannot function without DI. In fact, the<a id="_idIndexMarker267"/> effort spent on making everything injectable and having the proper interface designs for classes without interfaces <a id="_idIndexMarker268"/>promotes the DIP as a byproduct.</p>
<p>You can see that the SRP and the DIP are promoted by unit testing. So, while you are increasing your production quality, your design quality is improving as a result. There is no argument that unit testing requires effort, but part of this effort is already paid into your design quality and code readability.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor094"/>Summary</h1>
<p>In this chapter, we touched on basic unit testing-related topics, and we went through several examples.</p>
<p>If I was to categorize unit testing experience from 1 to 5, with level 1 being a beginner and 5 being an expert, this chapter should get you to level 2. Fear not! After going through the rest of the book, where more realistic examples will come, you will be at level 4, so I am glad you have made it so far. Keep going!</p>
<p><em class="italic">Is this book going to take me to level 5?</em> I hear you asking. Well, unit testing is not a sprint, it is a marathon; it takes years of practice to get to that level, and only getting your hands dirty in unit testing will get you there.</p>
<p>We also covered the relationship between SOLID principles and unit testing to show you the big picture and how everything fits nicely together.</p>
<p>In this chapter, I have deliberately avoided examples that require a deep understanding of test doubles, so as to introduce you to unit testing in a gentle way. However, in reality, most unit tests will require test doubles. Let’s move forward to a more realistic spectrum and dive into this concept in the next chapter.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor095"/>Further reading</h1>
<p>To learn more about the topics discussed in the <a id="_idTextAnchor096"/>chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">Walkthrough: Create a code snippet</em>: <a href="https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet">https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet</a></li>
<li><em class="italic">xUnit</em>: <a href="https://xunit.net">https://xunit.net</a></li>
</ul>
</div>
</div>
</body></html>