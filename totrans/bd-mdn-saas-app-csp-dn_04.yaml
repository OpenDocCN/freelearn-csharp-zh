- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Databases and Planning for Data-Rich Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we established a foundational SaaS application consisting
    of a straightforward database with a single table. This database was connected
    to an API, and we showcased secure multi-tenancy implementation using SQL Server,
    .NET, and Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve deeper into the intricacies of the database layer
    and its interactions with Entity Framework. As the bedrock of an entire application,
    the design choices made at the database level will influence every subsequent
    layer in the stack. We will explore how to construct and design resilient databases
    for data-intensive SaaS applications. You will acquire a variety of skills, such
    as normalization, indexing, performance optimization, as well as techniques to
    test and maintain the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once deployed, a database often represents the most demanding aspect of a system
    to keep current. The database is inherently stateful, and it is crucial to prevent
    data loss or corruption during updates. In addition to learning about database
    design and construction, we will examine several strategies to maintain and update
    the database, with an emphasis on the tools provided by Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The expertise you gain in this chapter is vital to create scalable and dependable
    SaaS applications. By mastering the methods discussed in this chapter, you will
    be capable of designing databases optimized for performance, scalability, and
    maintainability, thereby facilitating the development and maintenance of your
    SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of data in a SaaS application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a database using SQL Server and Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the database and data-rich applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working in production, keeping your database up to date, and keeping your data
    safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and a database are the foundations of a SaaS application. Let’s start by
    considering how important they are.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of data in a SaaS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a SaaS application, a database serves as the foundation for the application.
    The database (or more accurately, the data contained within) is what drives the
    application and where the primary value for users lies. A SaaS application without
    data is just an empty shell!
  prefs: []
  type: TYPE_NORMAL
- en: One of the key considerations when building a SaaS application is the type of
    data that the application will store and how it will be used. Will the application
    be storing large amounts of structured data, such as customer records or transaction
    histories? Or will it be storing unstructured data, such as the data underpinning
    a social media feed? The type of data will have a significant impact on the design
    and architecture of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Another important consideration is how the data will be accessed and manipulated.
    Will the data be accessed by a large number of users simultaneously, or will it
    only be accessed by a few users at a time? Will the data be updated frequently,
    or will it be mostly static? These factors will influence the choice of database
    technology and the design of the data model.
  prefs: []
  type: TYPE_NORMAL
- en: In a SaaS application, it is also important to consider how the data will be
    shared among different tenants. As we discussed in the previous chapter, the data
    for each tenant must be kept separate and secure, while still allowing for efficient
    access to and manipulation of the data that pertains to the current tenant. This
    requires careful planning and design of a data model and database schema.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to consider scalability. While a SaaS application may well
    start off with a small user base and thus a comparatively low number of reads/writes,
    this can change very quickly as the user base increases! It’s important to design
    a data model and schema in a way that allows the application to grow. Similarly,
    the amount of data that is transmitted over the internet must be managed. Bandwidth
    is not free nor unlimited, and in data-intensive applications, this can become
    a burden.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of data is not limited to technical considerations. Data plays
    a crucial role in the user experience. The way that data is presented, organized,
    and accessed can significantly impact the usability of an application. While this
    is, of course, dependent on the user interface, the structure of the underlying
    data, and the ease and speed with which it can be queried, will be noticed at
    the frontend by end users.
  prefs: []
  type: TYPE_NORMAL
- en: For a company building an application and hosting a database, data can be a
    key source of revenue. Some SaaS applications monetize their data by selling access
    to information about consumer demographics and buying habits to businesses looking
    to target specific market demographics. This data is often collected and classified
    by machine learning algorithms, allowing for insights about the users and creators
    of the data. With this valuable information, businesses can create targeted marketing
    campaigns and improve their products and services to better meet the needs of
    their customers.
  prefs: []
  type: TYPE_NORMAL
- en: Data is important for a myriad of reasons, and so it should go without saying
    that maintaining data security and compliance is a crucial aspect of building
    a successful SaaS application. It is the responsibility of the SaaS provider to
    ensure that sensitive data, such as financial or personal information, is kept
    secure and compliant with relevant regulations. To achieve this, the SaaS provider
    may need to implement various security measures, such as encryption and access
    controls, to protect the data.
  prefs: []
  type: TYPE_NORMAL
- en: Data and the database are absolutely critical parts of a SaaS application, and
    it’s important for SaaS developers to have a strong understanding of how to design,
    build, and maintain data-rich applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on using SQL Server and Entity Framework to design
    and construct a database for your SaaS application. We will cover a range of topics,
    including choosing the right database technology, designing an efficient and scalable
    data model with Entity Framework, and implementing database security and compliance
    measures with SQL Server. By the end of this section, you will have a solid understanding
    of how to build a robust and reliable database for your SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: Types of database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because this is a book focused on making use of the Microsoft stack, I will
    focus on SQL Server as the underlying database platform, and I will use Entity
    Framework to interact with the database. SQL Server is a **relational database**,
    which is a type of database that stores data in the form of tables, with rows
    representing individual records and columns representing data attributes. It is
    a very structured way to store data, and the “shape” of the data must be known
    in advance and built into the application at design time.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we will focus on SQL Server and, therefore, relational data, it is worth
    briefly considering the alternatives, which are outside the scope of this book.
    Some of the following alternatives may be worth further investigation if you have
    a specific use case that may require something other than relational data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document databases**: A document database is a type of database that stores
    data in the form of documents. In this context, a document is data that is typically
    made up of key-value pairs and is designed to be scalable and flexible. In a document
    database, the structure or shape of the data will not be set when the database
    is designed, making it a good choice to store and query large volumes of data
    with diverse structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph databases**: These databases store data in the form of nodes (representing
    data entities) and edges (representing relationships between nodes). They are
    often used in applications that need to represent complex relationships between
    data entities, such as social networks or recommendation engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-value stores**: These databases store data in the form of key-value pairs,
    where the key is used to identify the data and the value is the data itself. They
    are often used for simple data storage and retrieval scenarios where the data
    does not need to be queried or indexed. This is similar to a document database
    but more limited in that it is only really suitable for simple use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-memory databases**: These databases store data in memory, rather than
    on disk. They are often used for applications that require fast read and write
    access to data, such as online gaming or financial applications. Note that in-memory
    databases can also be used to help test databases. These are two separate use
    cases and should not be confused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-series databases**: These databases are designed specifically for storing
    and querying time-stamped data, such as sensor readings or financial transactions.
    They are often used in applications that need to analyze data over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will focus on SQL Server, which is a relational database.
    We will interact with the database using a tool that Microsoft developed specifically
    for this purpose – namely, Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: What is ACID?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with databases – and particularly relational databases – you will
    often come across the acronym **ACID**. This refers to the four properties of
    a database transaction – namely, atomicity, consistency, isolation, and durability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**: A transaction is treated as a single, indivisible unit of work,
    and either all its operations are completed or none of them are'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: The transaction brings the database from one valid state to
    another, preserving database invariants and constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: The concurrent execution of transactions results in a system
    state that would be obtained if transactions were executed serially, in some order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability**: Once a transaction has been committed, its changes to the database
    persist and survive future system failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are a set of properties that are guaranteed by a database management
    system to ensure the reliability and consistency of data stored in a database.
    ACID is most commonly associated with **relational database management systems**
    (**RDBMS**), such as Oracle, MySQL, PostgreSQL, and Microsoft SQL Server. However,
    some newer databases, such as NoSQL databases and NewSQL databases, may also provide
    ACID guarantees, although they may have different levels of consistency and durability.
    The level of ACID support depends on the specific database technology and how
    it is implemented and configured.
  prefs: []
  type: TYPE_NORMAL
- en: ACID is generally associated with transactions in relational databases, and
    less commonly so in NoSQL or document databases. In this chapter, and indeed throughout
    this book, we will focus on SQL Server, a relational database that provides support
    for ACID transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entity Framework is an **object-relational mapping** (**ORM**) tool that allows
    developers to interact with a database using .NET objects. It simplifies the process
    of accessing and manipulating data by eliminating the need to write SQL queries
    and manually map data to objects. Entity Framework is well-suited for developers
    who are familiar with .NET and want to streamline their data access and manipulation
    tasks, which makes it an excellent choice for study in this .NET-focused book!
  prefs: []
  type: TYPE_NORMAL
- en: While we will focus on SQL Server, one of the big benefits of using Entity Framework
    is its ability to generate database-agnostic code, allowing developers to change
    a database platform or support multiple database platforms without having to significantly
    rewrite their code. This feature is of particular interest when dealing with a
    multi-tenant SaaS application, where certain customers may mandate a specific
    database platform.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework wraps up a lot of the complexities associated with writing
    code that interacts with a database. Concepts such as lazy loading, change tracking,
    and automatic migration of data and schema changes are handled out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many other ORMs, Entity Framework supports several different approaches
    to interacting with a database, including the traditional database-first approach,
    the code-first approach, and the model-first approach. This gives developers the
    flexibility to choose the approach that best fits their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework is a powerful tool that can greatly enhance the productivity
    of experienced .NET developers by simplifying data access and manipulation tasks,
    and it is highly recommended when approaching a project that will be highly dependent
    on a data platform – such as a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: It is out of the scope of this chapter to cover all of the possible ways to
    use Entity Framework, so I will focus on one – Code First.
  prefs: []
  type: TYPE_NORMAL
- en: Code first with Entity Framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Code first with Entity Framework is a development approach that allows developers
    to create their .NET application’s data model using C# code, rather than designing
    a database using a UI such as SQL Server Management Studio, or through writing
    and maintaining SQL scripts. This approach is particularly useful for developers
    who prefer to work with code and want more control over their application’s data
    model. With code first, developers can define their data model using classes and
    properties in their code, and Entity Framework will handle the creation and management
    of the underlying database. This approach allows developers to focus on the data
    model and business logic of their application, without having to worry about the
    implementation details of the database.
  prefs: []
  type: TYPE_NORMAL
- en: We saw this approach in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056). When
    the database was configured, we didn’t write a single line of SQL code – we wrote
    a C# class called `GoodHabits.cs` and defined the data structure in C# code. We
    then used two commands on the Entity Framework CLI that updated the database.
    In [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), we modified this file to facilitate
    multi-tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures with Entity Framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditionally, it has been very common to use stored procedures when designing
    a database. While this is still a very valid and useful approach to database development,
    it is increasingly being seen as best practice to use an ORM such as Entity Framework
    to access and manipulate data in a database, rather than using stored procedures.
    There are a few reasons for this.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework allows you to work with objects and entities in your code,
    rather than having to write raw SQL queries. This gives you a higher level of
    abstraction, which can make it easier to develop an application. With this approach,
    you can build your database in a familiar object-orientated way, which can make
    it easier to reason about and maintain. Entity Framework is able to interpret
    relationships between objects and create database relationships from C# code.
    If you create logic and then model it in a stored procedure, Entity Framework
    loses sight of that logic.
  prefs: []
  type: TYPE_NORMAL
- en: Another huge benefit of using Entity Framework is that many database platforms
    are supported out of the box. However, logic in stored procedures is typically
    not transferrable between database platforms and would have to be built and maintained
    separately on a per-platform basis.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Entity Framework has a number of testing tools available to use. Using
    stored procedures and triggers will require specific testing infrastructure and
    techniques, and this may make it harder to test an application because logic is
    split between code and the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain cases when using stored procedures or triggers may be beneficial.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When working with very large datasets, or in situations where performance is
    critical, it may be advantageous to execute logic directly against a database
    by way of a stored procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where data security is a concern, stored procedures can help to prevent
    unauthorized access to data by limiting the types of queries that can be run against
    a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where you want to abstract the data access layer of your application
    from the underlying database schema, using stored procedures can help to decouple
    the two. This can be particularly useful in situations where a database schema
    may change frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand your specific use case when deciding whether or
    not to make use of stored procedures in your database. For the demo application,
    we will continue to use Entity Framework to manipulate and access the database.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Database normalization is the process of organizing a database in a way that
    reduces redundancy and improves data integrity. It involves dividing the database
    into smaller, more focused tables that are related to each other through relationships.
    The goal of normalization is to eliminate redundancy and ensure that each piece
    of data is stored in only one place in the database. Normalization is an important
    step in the database design process and can greatly improve the performance and
    reliability of a database.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework supports the process of normalizing a database in several ways.
    One of the main ways it does this is through the creation and modification of
    tables and relationships within the database. This allows developers to structure
    their data in a way that reduces redundancy and improves data integrity – a key
    goal of normalization. Entity Framework also includes support for the automatic
    migration of data changes. This means that when developers make changes to their
    data model, those changes are automatically reflected in the underlying database.
    This can be particularly useful when normalizing a database, as it allows developers
    to easily update the structure of their data without having to manually migrate
    data between tables.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Entity Framework’s LINQ query syntax allows developers to easily
    retrieve and manipulate data from a normalized database. It supports a wide range
    of operations, including filtering, sorting, and aggregation, making it easy to
    work with data from multiple tables. Finally, Entity Framework’s support for eager
    and lazy loading allows developers to optimize the performance of their application
    by only loading the data they need on demand, rather than loading all data upfront.
    This can be harder with a poorly normalized database. Overall, Entity Framework
    provides a number of tools and features to help developers normalize their databases
    and improve the performance and reliability of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: There are several normal forms that can be used to measure the degree of normalization
    in a database. The first three (called 1NF, 2NF, and 3NF) are used to address
    redundancy in a database and are generally considered to be good practice in most
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the first three, the additional normal forms are designed to address
    specific types of problems; however, these are less commonly used and are considered
    out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that achieving higher normal forms does not always constitute
    a better-designed database. It is generally better to design a database that is
    efficient and performant around a specific use case than to adhere blindly to
    the normalization rules. That said, achieving 3NF is usually a good starting point
    from which to work, and further normalization, or indeed denormalization, can
    follow from there.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate this with an example. Let’s consider adding a user table to
    the `GoodHabit` example we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056).
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the first normal form (1NF), all attributes in the database must
    be atomic. This means that each column in the database should contain a single
    value. We could design a user table that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Poorly normalized data](img/B19343_Figure_4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Poorly normalized data
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding table shows poorly normalized data. The **Name** column contains
    two pieces of information (first and last name), which may be useful to use separately.
    The **Habits** column contains a comma-separated list of data. This can be improved
    upon like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Data in the first normal form (1NF)](img/B19343_Figure_4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Data in the first normal form (1NF)
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table shows the data in 1NF. Each attribute holds a single value.
    We now have a row in the database for each habit, but the users appear multiple
    times. If Dave decided that he would prefer to be called David, we would have
    to update the data in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move this data into the second normal form, we need to break the data into
    two tables – one for the user, and one for the habit. We will need a third table
    to link the users to the habits they are going to work on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Data in the second normal form (2NF)](img/B19343_Figure_4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Data in the second normal form (2NF)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much better, and we can start to see that this could be queried and
    updated in a very tidy way. There is one further improvement we could make though.
    The **Habit** table has a **Frequency** column that is indirectly dependent on
    the ID column. This is called a transitive dependency. In order to move this data
    to the third normal form, we must break this transitive dependency by adding a
    **Frequency** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Data in the third normal form (3NF)](img/B19343_Figure_4.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Data in the third normal form (3NF)
  prefs: []
  type: TYPE_NORMAL
- en: The third normal form is sufficient at this stage, and we’ll take this no further.
    You can see that all of the data is separated into individual tables, and linked
    through foreign key constraints to the **UserHabit** table. This allows efficient
    querying and updating of the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and performance optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indexing a database means creating a separate data structure that is used to
    improve the performance of certain types of queries. Indexes are typically created
    on specific columns within a table, allowing the database to quickly locate the
    rows that match given criteria. For example, if you have a large table of customer
    records and you frequently search for customers by their last name, you could
    create an index on the `last_name` column to improve the performance of those
    searches. Indexes can significantly improve the performance of certain types of
    queries, but they also have a cost in terms of storage space and maintenance.
    As a result, it is important to carefully consider which columns should be indexed
    and to balance the benefits of indexing with the costs.
  prefs: []
  type: TYPE_NORMAL
- en: To do indexing with Entity Framework, developers can use a variety of tools
    and approaches. One way to do indexing is to use the Entity Framework Fluent API,
    which allows developers to define indexes on their entities using code. To create
    an index using the Fluent API, developers can use the `HasIndex` method and specify
    the properties that should be included in the index. Another option is to use
    Entity Framework Designer, a visual tool that allows developers to design their
    data model using a graphical interface. The Designer includes the ability to define
    indexes on entities by right-clicking on an entity and selecting **Add Index**.
    Finally, developers can use database migrations to create indexes on their entities
    by adding the appropriate code to their migration files.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring indexes with Entity Framework is straightforward!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the `GoodHabit` table that we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    we used the following C# code to define the structure of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add an index to the `Name` column by decorating the class with an attribute
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will instruct the database platform to create an index for the `Name`
    column. We could do the same for the `ID` column in the same way. You can create
    a composite index by setting the attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to set the sort order of the indexes, you can use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to name your index, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is a great deal of flexibility provided by Entity Framework, and it is
    out of the scope of this book to cover all of it.
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information about it at [https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations](https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations).
  prefs: []
  type: TYPE_NORMAL
- en: We will now build out a database for the example application, being mindful
    of what we have just learned.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a database schema using Entity Framework code first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start designing a database, let’s stop and think about what our requirements
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The database will store user information to identify individual users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can add habits to the database to track their progress and achieve their
    goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can log progress for each habit and set reminders to perform it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can set goals for their habits, such as running a certain number of miles
    or saving a certain amount of money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database can support users in achieving their goals and improving their
    overall well-being by tracking and managing their habits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a diagram representing the database that we just
    configured. This shows the tables, columns, and relationships between the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A suggested database schema](img/B19343_Figure_4.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – A suggested database schema
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows a schema that can meet the requirements defined
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are using Entity Framework code first, we will build this database by
    writing C# code. Create the entity classes with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We already have the `Habit` entity, but we will update it with some additional
    properties. Copy the following code into `Habit.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `Goal.cs` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Progress.cs` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Reminder.cs` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `User.cs` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code into the `GoodHabitsDbContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create the migration by running the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The migrations will be automatically applied to the database when `HabitService`
    runs, so simply run the Habit service to push the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Server Explorer to view the database, we can see that the schema has
    been successfully applied!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The schema applied to the database](img/B19343_Figure_4.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The schema applied to the database
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows that the schema has successfully migrated to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Testing data-rich applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the database layer of a SaaS application is an essential part of the
    development process. A database is a critical component of any application, as
    it stores and manages the data that an application relies on. Ensuring that the
    database is working correctly is crucial for the overall stability and performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are several challenges that you may encounter when testing the database
    layer of your application. One challenge is ensuring that the database schema
    is correct and that the data is stored and retrieved correctly. Another challenge
    is ensuring that the database is properly optimized for performance, particularly
    if you are dealing with large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different techniques that you can use to test the database
    layer of your application. One common technique is to use unit tests to verify
    that individual database functions are working correctly. Another technique is
    to use integration tests to ensure that the database is working correctly in conjunction
    with the rest of the application. You may also want to use performance tests to
    ensure that the database is able to handle large amounts of data without experiencing
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are a type of automated testing that is used to verify the behavior
    of individual units of code, such as individual functions or methods. In contrast
    to unit tests, integration tests focus on testing how different parts of an application
    work together as a system. Integration tests are used to ensure that different
    components of the application are able to communicate and interact with one another
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upgrading a database with Entity Framework involves making changes to the database
    schema and data to reflect changes in an application. This can include adding
    new tables or columns, modifying existing tables or columns, and migrating data
    from one format to another.
  prefs: []
  type: TYPE_NORMAL
- en: There are several approaches that you can take when upgrading a database with
    Entity Framework. One approach is to use the `DbMigrations` class to automatically
    generate and execute the necessary SQL commands to update the database schema.
    This can be convenient, as it allows you to make changes to the database using
    a high-level API, rather than having to write raw SQL commands. However, it can
    also be less flexible than some other approaches, as it relies on Entity Framework
    to generate the SQL commands, and that may not always produce optimal results.
    This is the approach that we will take in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth being aware of a popular alternative approach, which is to use Entity
    Framework’s `DbContext` class to manually execute SQL commands to update a database.
    This can be more flexible, as you have complete control over the SQL commands
    that are executed. However, it can also be more time-consuming and error-prone,
    as you have to write and debug the SQL commands yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is, of course, possible to update a database separately from Entity
    Framework using any preferred method, which most likely involves executing SQL
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: I think that it is generally preferable to make use of the built-in migration
    tools and allow Entity Framework to do the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: We saw this process in practice twice – when we created the initial migration
    in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), and when we just updated the
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `Migrations` folder in the `Database` project, you should
    see the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The Migrations folder](img/B19343_Figure_4.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The Migrations folder
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see the `.._InitialSetup.cs` file that contains
    our first pass, the `.._MultiTenant.cs` file that has the modifications that we
    made in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), and the `AdditionalEntities.cs`
    file that we added in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), we added
    the initial migration with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when creating the second migration, we used this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that the work we did in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082)
    to introduce the multi-tenancy has added parameters to the constructor, which
    are defined in the API project. Pointing the migration tool at the API project
    allows it to create migrations via the `HabitService` project.
  prefs: []
  type: TYPE_NORMAL
- en: If you look into either of these generated classes, you will see two methods,
    named `Up` and `Down`. These methods allow the migration to be added to the database,
    or rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of how we have configured the databases for multi-tenancy in [*Chapter
    3*](B19343_03.xhtml#_idTextAnchor082), we do not need to manually update each
    database. However, should you find you need to manually update a database, you
    can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Issuing this command will instruct Entity Framework to look in the `Migrations`
    folder and compare the migrations that it finds there with the migrations that
    are present in the database. If there are any additional migrations that have
    not yet been applied to the database, Entity Framework will apply those migrations.
    Let’s take a closer look at the first one we created, called `initial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code is auto-generated by the migration tool, but it’s perfectly acceptable
    to manually adjust the code here if there is a reason to. We can see two methods
    here. One is called `Up`, and the other `Down`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Up` method creates the table in the database, and the `Down` method drops
    the table. This is converted into SQL code, which is issued to the database engine
    when the `database update` command is issued.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: We learned that data is important in a SaaS application. This can be trying
    not only from a technical point of view but also from the point of view of a user,
    as well as the organization building the application.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to a technical implementation with Entity Framework, demonstrating
    how to build a database in code using C#, and then automatically generate migrations
    and update the database.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about testing strategies and maintaining a database in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build out the API layer and start to interact with
    the data structure we previously created. The application will start to take shape!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is Code-First?: [https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx](https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing with Entity Framework: [https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/](https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data-driven culture: [https://www.smartkarrot.com/resources/blog/data-driven-culture/](https://www.smartkarrot.com/resources/blog/data-driven-culture/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database normalization: [https://www.sqlshack.com/what-is-database-normalization-in-sql-server/](https://www.sqlshack.com/what-is-database-normalization-in-sql-server/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In what ways can a business monetize data that is present in a SaaS application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ethical considerations around data monetization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are foreign key relationships represented in Entity Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a unit test and an integration test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I want to roll back migration in a live database, how do I ensure that no
    data is lost?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
