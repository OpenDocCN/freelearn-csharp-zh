<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating Your First Shader</h1>
                
            
            
                
<p class="calibre3">In this chapter, you will learn about the following recipes:</p>
<ul class="calibre11">
<li class="calibre12">Creating a basic Standard Shader</li>
<li class="calibre12">Adding properties to a shader</li>
<li class="calibre12">Using properties in a Surface Shader</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            
                
<p class="calibre3">This chapter will cover some of the more common diffuse techniques found in today's game development shading pipelines. Let's imagine a cube that has been painted white uniformly in a 3D environment with a directional light. Even if the color used is the same on each face, they will all have different shades of white on them depending on the direction that the light is coming from and the angle that we are looking at it from. This extra level of realism is achieved in 3D graphics through the use of shaders, special programs that are mostly used to simulate how light works. A wooden cube and a metal one may share the same 3D model, but what makes them look different is the shader that they use.</p>
<p class="calibre3">This first chapter will introduce you to shader coding in Unity. If you have little to no previous experience with shaders, this chapter is what you need in order to understand what shaders are, how they work, and how to customize them. By the end of this chapter, you will have learned how to build basic shaders that perform basic operations. Armed with this knowledge, you will be able to create just about any Surface Shader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a basic Standard Shader</h1>
                
            
            
                
<p class="calibre3">In Unity, when we create a game object, we then attach additional functionality through the use of <strong class="calibre5">components</strong>. In fact, every game object is required to have a Transform component; there are a number of components included in Unity already, and we create components of our own when we write scripts that extend from <kbd class="calibre13">MonoBehaviour</kbd>. </p>
<p class="calibre3">All the objects that are part of a game contain a number of components that affect their look and behavior. While scripts determine how objects should behave, renderers decide how they should appear on the screen. Unity comes with several renderers, depending on the type of object that we are trying to visualize; every 3D model typically has a <kbd class="calibre13">MeshRenderer</kbd> component attached to it. An object should have only one renderer, but the renderer itself can contain several materials. Each material is a wrapper for a single shader, the final ring in the food chain of 3D graphics. The relationships between these components can be seen in the following diagram:</p>
<div><img src="img/00028.jpeg" class="calibre35"/></div>
<p class="chapter-content">Understanding the difference between these components is essential for understanding how shaders work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">To get started with this recipe, you will need to have Unity running and must have a project opened. As mentioned before, there will also be a Unity project included with this cookbook, so you can use that one as well and simply add your own custom shaders to it as you step through each recipe. With this completed, you are now ready to step into the wonderful world of real-time shading!</p>
<p class="calibre3">Before getting into our first shader, let's create a small scene for us to work with:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's create a scene by navigating to File | New Scene.</li>
<li value="2" class="calibre12">Once you create the scene, create a plane to act as the ground by going to GameObject | 3D Objects | Plane in the Unity editor. Next, select the object in the Hierarchy tab and then go into the Inspector tab. From there, right-click on the Transform component and select the Reset Position option:</li>
</ol>
<div><img src="img/00029.jpeg" class="calibre36"/></div>
<p class="calibre26"> This will reset the position property of the object to be at <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>:</p>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">To make it easier to see what our shaders will look like when applied, let's add some shapes to visualize what each of our shaders will do. Create a sphere by going to GameObject | 3D Objects | Sphere. Once created, select it and go to the Inspector tab. Next, change the Position to <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">0</kbd> so it is above the origin of the world (which is at <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>) and our previously created plane:</li>
</ol>
<div><img src="img/00030.jpeg" class="calibre25"/></div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Once this sphere is created, create two more spheres, placing them to the left and right of the spheres at positions <kbd class="calibre13">-2</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">0</kbd> and <kbd class="calibre13">2</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">0</kbd> respectively:</li>
</ol>
<div><img src="img/00031.jpeg" class="calibre25"/></div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Lastly, confirm that you have a directional light (it should be seen in the Hierarchy tab). If not, you can add one by selecting GameObject | Light | Directional Light to make it easier to see the effect of your changes and how your shaders react to light.</li>
</ol>
<p>If you are using the Unity project that came with the cookbook, you can open up the <kbd class="calibre37">Chapter 2</kbd> | <kbd class="calibre37">Starting Point</kbd> scene instead as it has been set up already.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">With our scene generated, we can move on to the shader writing steps:</p>
<ol start="1" class="calibre15">
<li value="1" class="calibre12">In the Project tab in your Unity editor, right-click on the <kbd class="calibre13">Chapter 2</kbd> folder and select Create | Folder.</li>
<li value="2" class="calibre12">Rename the folder that you created as <kbd class="calibre13">Shaders</kbd> by right-clicking on it and selecting Rename from the drop-down list, or by selecting the folder and hitting <em class="calibre2">F2</em> on the keyboard.</li>
</ol>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Create another folder and rename it as <kbd class="calibre13">Materials</kbd>.</li>
<li value="4" class="calibre12">Right-click on the <kbd class="calibre13">Shaders</kbd> folder and select Create | Shader | Standard Surface Shader. Then, right-click on the <kbd class="calibre13">Materials</kbd> folder and select Create | Material.</li>
<li value="5" class="calibre12">Rename both the shader and material as <kbd class="calibre13">StandardDiffuse</kbd>.</li>
<li value="6" class="calibre12">Launch the <kbd class="calibre13">StandardDiffuse</kbd> shader by double-clicking on the file. This will automatically launch a scripting editor for you and display the shader's code.</li>
</ol>
<p>You will see that Unity has already populated our shader with some basic code. This, by default, will get you a basic shader that accepts one texture in the Albedo (RGB) property. We will be modifying this base code so that you can learn how to quickly start developing your own custom shaders.</p>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Now let's give our shader a custom folder from which it's selected. The very first line of code in the shader is the custom description that we have to give the shader so that Unity can make it available in the shader drop-down list when assigning to materials. We have renamed our path as <kbd class="calibre13">Shader "CookbookShaders/StandardDiffuse"</kbd>, but you can name it whatever you want and rename it at any time so don't worry about any dependencies at this point. Save the shader in your script editor and return to the Unity editor. Unity will automatically compile the shader when it recognizes that the file has been updated. This is what your shader should look like at this point:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/StandardDiffuse" {<br class="title-page-name"/>  Properties {<br class="title-page-name"/>    _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>    _MainTex ("Albedo (RGB)", 2D) = "white" {}<br class="title-page-name"/>    _Glossiness ("Smoothness", Range(0,1)) = 0.5<br class="title-page-name"/>    _Metallic ("Metallic", Range(0,1)) = 0.0<br class="title-page-name"/>  }<br class="title-page-name"/>  SubShader {<br class="title-page-name"/>    Tags { "RenderType"="Opaque" }<br class="title-page-name"/>    LOD 200<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    // Physically based Standard lighting model, and enable shadows on all light types<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows<br class="title-page-name"/><br class="title-page-name"/>    // Use shader model 3.0 target, to get nicer looking lighting<br class="title-page-name"/>    #pragma target 3.0<br class="title-page-name"/><br class="title-page-name"/>    sampler2D _MainTex;<br class="title-page-name"/><br class="title-page-name"/>    struct Input {<br class="title-page-name"/>      float2 uv_MainTex;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    half _Glossiness;<br class="title-page-name"/>    half _Metallic;<br class="title-page-name"/>    fixed4 _Color;<br class="title-page-name"/><br class="title-page-name"/>    // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.<br class="title-page-name"/>    // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.<br class="title-page-name"/>    // #pragma instancing_options assumeuniformscaling<br class="title-page-name"/>    UNITY_INSTANCING_BUFFER_START(Props)<br class="title-page-name"/>      // put more per-instance properties here<br class="title-page-name"/>    UNITY_INSTANCING_BUFFER_END(Props)<br class="title-page-name"/><br class="title-page-name"/>    void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>      // Albedo comes from a texture tinted by color<br class="title-page-name"/>      fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;<br class="title-page-name"/>      o.Albedo = c.rgb;<br class="title-page-name"/>      // Metallic and smoothness come from slider variables<br class="title-page-name"/>      o.Metallic = _Metallic;<br class="title-page-name"/>      o.Smoothness = _Glossiness;<br class="title-page-name"/>      o.Alpha = c.a;<br class="title-page-name"/>    }<br class="title-page-name"/>    ENDCG<br class="title-page-name"/>  }<br class="title-page-name"/>  FallBack "Diffuse"<br class="title-page-name"/>}</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Technically speaking, this is a Surface Shader based on <strong class="calibre1">physically-based rendering</strong> (<strong class="calibre1">PBR</strong>). As the name suggests, this type of shader achieves realism by simulating how light physically behaves when hitting objects.</li>
<li value="9" class="calibre12">After your shader is created, we need to connect it to a material. Select the material called <kbd class="calibre13">StandardDiffuse</kbd> that we created in <em class="calibre2">step 4</em> and look at the Inspector tab. From the Shader drop-down list, select CookbookShaders | StandardDiffuse. (Your shader path might be different if you chose to use a different path name.) This will assign your shader to your material and make it ready for you to assign to an object.</li>
</ol>
<p>To assign material to an object, you can simply click and drag your material from the Project tab to the object in your scene. You can also drag material to the Inspector tab of an object in the Unity editor in order to assign it.</p>
<p class="calibre3">The screenshot of an example is as follows:</p>
<div><img src="img/00032.jpeg" class="calibre25"/></div>
<p class="calibre3">Not much to look at at this point, but our shader development environment is set up and we can now start to modify the shader to suit our needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">Unity has made the task of getting your shader environment up and running very easy for you. It is simply a matter of a few clicks and you are good to go. There are a lot of elements working in the background with regard to the Surface Shader itself. Unity has taken the Cg shader language and made it more efficient to write by doing a lot of the heavy Cg code lifting for you. The Surface Shader language is a more component-based way of writing shaders. Tasks such as processing your own texture coordinates and transformation matrices have already been done for you, so you don't have to start from scratch any more. In the past, we would have to start a new shader and rewrite a lot of code over and over again. As you gain more experience with Surface Shaders, you will naturally want to explore more of the underlying functions of the Cg language and how Unity is processing all of the low-level <strong class="calibre5">graphics</strong> <strong class="calibre5">processing unit</strong> (<strong class="calibre5">GPU</strong>) tasks for you.</p>
<p>All the files in a Unity project are referenced independently from the folder that they are in. We can move shaders and materials from within the editor without the risk of breaking any connection. Files, however, should never be moved from outside the editor as Unity will not be able to update their references.</p>
<p class="calibre3">So, by simply changing the shader's path name to a name of our choice, we have got our basic diffuse shader working in the Unity environment, with lights and shadows and all that, just by changing one line of code!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">The source code of the built-in shaders is typically hidden in Unity. You cannot open this from the editor as you do with your own shaders. For more information on where to find a large portion of the built-in Cg functions for Unity, go to your Unity install directory and navigate to the <kbd class="calibre13">Editor</kbd> | <kbd class="calibre13">Data</kbd> | <kbd class="calibre13">CGIncludes</kbd> folder:</p>
<div><img src="img/00033.jpeg" class="calibre38"/></div>
<p class="calibre3">In this folder, you can find the source code of the shaders shipped with Unity. Over time, they have changed a lot; you can visit the<strong class="calibre5"> Unity download archive</strong> (<a href="https://unity3d.com/get-unity/download/archive" class="calibre10">https://unity3d.com/get-unity/download/archive</a>) if you need to access the source codes of a shader used in a different version of Unity. After choosing the right version, select Built in shaders from the drop-down list, as shown in the following screenshot:</p>
<div><img src="img/00034.jpeg" class="calibre39"/></div>
<p class="calibre3">There are three files that are of note at this point: <kbd class="calibre13">UnityCG.cginc</kbd>,  <kbd class="calibre13">Lighting.cginc</kbd>, and <kbd class="calibre13">UnityShaderVariables.cginc</kbd>. Our current shader is making use of all these files at the moment. In <a href="part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 11</a>, <em class="calibre14">Advanced Shading Techniques</em>, we will explore in depth how to use CGInclude for a modular approach to shader coding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding properties to a shader</h1>
                
            
            
                
<p class="calibre3">Properties of a shader are very important for the shader pipeline as they are the method that you use to let the artist or user of the shader assign textures and tweak your shader values. Properties allow you to expose GUI elements in a material's Inspector tab without you having to use a separate editor, which provides visual ways to tweak a shader. With your shader opened in your IDE of choice, look at the block of lines two through seven. This is called the <kbd class="calibre13">Properties</kbd> block of the script. Currently, it will have one texture property in it called <kbd class="calibre13">_MainTex</kbd>.</p>
<p class="calibre3">If you look at your material that has this shader applied to it, you will notice that there is one <strong class="calibre5">texture</strong> GUI element in the Inspector tab. These lines of code in our shader are creating this GUI element for us. Again, Unity has made this process very efficient in terms of coding and the amount of time it takes to iterate through changing your properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Let's see how this works in our current shader called <kbd class="calibre13">StandardDiffuse</kbd> by creating our own properties and learning more about the syntax involved. For this example, we will refit the shader previously created. Instead of using a texture, it will only use its color and some other properties that we will be able to change directly from the Inspector tab. Start by duplicating the <kbd class="calibre13">StandardDiffuse</kbd> shader. You can do this by selecting it in the Inspector tab and pressing <em class="calibre14">Ctrl </em>+ <em class="calibre14">D</em>. This will create a copy called <kbd class="calibre13">StandardDiffuse 1</kbd>. Go ahead and rename it as <kbd class="calibre13">StandardColor</kbd>.</p>
<p>You can give a friendlier name to your shader in its first line. For instance, <kbd class="calibre37">Shader "CookbookShaders/StandardDiffuse"</kbd> tells Unity to call this shader <kbd class="calibre37">StandardDiffuse</kbd> and move it to a group called <kbd class="calibre37">CookbookShaders</kbd>. If you duplicate a shader using <em class="calibre21">Ctrl </em>+ <em class="calibre21">D</em>, your new file will share the same name. To avoid confusion, make sure to change the first line of each new shader so that it uses a unique alias in this and future recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Once the <kbd class="calibre13">StandardColor</kbd> shader is ready, we can start changing its properties:</p>
<ol class="calibre15">
<li value="1" class="calibre12">In the first line of the script, update the name to the following:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/Chapter 02/StandardColor" {</pre>
<p>Downloading the example code<br class="calibre40"/>
<br class="calibre40"/> You can download the example code files for all Packt books you have purchased from your account at <a href="http://www.packtpub.com/" class="calibre31">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support" class="calibre31">http://www.packtpub.com/support</a> and register to have the files emailed directly to you.</p>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">In the <kbd class="calibre13">Properties</kbd> block of our shader, remove the current property by deleting the following code from our current shader:</li>
</ol>
<pre class="calibre18">_MainTex ("Albedo (RGB)", 2D) = "white" {} </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">As we have removed an essential property, this shader will not compile until the other references to <kbd class="calibre13">_MainTex</kbd> are removed. Let's remove this other line inside of the <kbd class="calibre13">SubShader</kbd> section:</li>
</ol>
<pre class="calibre18">sampler2D _MainTex; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">The original shader used <kbd class="calibre13">_MainTex</kbd> to color the model. Let's change this by replacing the first line of code of the <kbd class="calibre13">surf()</kbd> function with this:</li>
</ol>
<pre class="calibre18">fixed4 c = _Color; </pre>
<p class="calibre3">Just as you may be used to the <kbd class="calibre13">float</kbd> type being used for floating point values when writing code in C# and other programming languages, <kbd class="calibre13">fixed</kbd> is used for fixed-point values and is the type used when writing shaders. You may also see the <kbd class="calibre13">half</kbd> type used as well, which is like the <kbd class="calibre13">float</kbd> type but takes up half the space. This is useful for saving memory but is less precise in how it is presented. We will be discussing this in much greater detail in the <em class="calibre14">Techniques to make shaders more efficient</em> recipe in <a href="part0212.html#6A5N80-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 8</a>, <em class="calibre14">Mobile Shader Adjustment</em>.</p>
<p>For more information on fixed-point values, check out <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic" class="calibre31">https://en.wikipedia.org/wiki/Fixed-point_arithmetic</a>.</p>
<p class="calibre3">The <kbd class="calibre13">4</kbd>  in <kbd class="calibre13">fixed4</kbd> stands for the fact that the color is a single variable that contains four <kbd class="calibre13">fixed</kbd> values: red, green, blue, and alpha. You will learn more about how this works and how to modify these values in more detail in the next chapter, <a href="part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 3</a>, <em class="calibre14">Surface Shaders and Texture Mapping</em>.</p>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">When you save and return to Unity, the shader will compile, and you will see that now our material's Inspector tab doesn't have a texture swatch any more. To complete the refit of this shader, let's add one more property to the <kbd class="calibre13">Properties</kbd> block and see what happens. Enter the following code:</li>
</ol>
<pre class="calibre18">_AmbientColor ("Ambient Color", Color) = (1,1,1,1) </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">We have added another color swatch to the material's Inspector tab. Now let's add one more in order to get a feel for other kinds of properties that we can create. Add the following code to the <kbd class="calibre13">Properties</kbd> block:</li>
</ol>
<pre class="calibre18">_MySliderValue ("This is a Slider", Range(0,10)) = 2.5 </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">We have now created another GUI element that allows us to visually interact with our shader. This time, we created a slider with the name This is a Slider, as shown in the following screenshot:</li>
</ol>
<div><img src="img/00035.jpeg" class="calibre41"/></div>
<ol start="8" class="calibre15">
<li class="calibre12" value="8">Properties allow you to create a visual way to tweak shaders without having to change values in the shader code itself. The next recipe will show you how these properties can actually be used to create a more interesting shader.</li>
</ol>
<p>While properties belong to shaders, the values associated with them are stored in materials. The same shader can be safely shared between many different materials. On the other hand, changing the property of a material will affect the look of all the objects that are currently using it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">Every Unity shader has a built-in structure that it is looking for in its code. The Properties block is one of those functions that are expected by Unity. The reason behind this is to give you, the shader programmer, a means of quickly creating GUI elements that tie directly into your shader code. These properties (variables) that you declare in the Properties block can then be used in your shader code to change values, colors, and textures. The syntax to define a property is as follows:</p>
<div><img src="img/00036.gif" class="calibre42"/></div>
<p class="calibre3">Let's take a look at what is going on under the hood here. When you first start writing a new property, you will need to give it a <strong class="calibre5">Variable Name</strong>. The <strong class="calibre5">Variable Name</strong> is going to be the name that your shader code is going to use in order to get the value from the GUI element. This saves us a lot of time because we don't have to set up this system ourselves. The next elements of a property are the <strong class="calibre5">Inspector GUI Name</strong> and <strong class="calibre5">Type</strong> of the property, which is contained within parentheses. The <strong class="calibre5">Inspector GUI Name</strong> is the name that is going to appear in the material's Inspector tab when the user is interacting with and tweaking the shader. The <strong class="calibre5">Type</strong> is the type of data that this property is going to control. There are many types that we can define for properties inside of Unity shaders. The following table describes the types of variables that we can have in our shaders:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre46"><strong class="calibre1">Surface Shader property types</strong></td>
<td class="calibre46"><strong class="calibre1">Description</strong></td>
</tr>
<tr class="calibre45">
<td class="calibre46"><kbd class="calibre13">Range</kbd> (min, max)</td>
<td class="calibre46">This creates a <kbd class="calibre13">float</kbd> property as a slider from the minimum value to the maximum value</td>
</tr>
<tr class="calibre45">
<td class="calibre46"><kbd class="calibre13">Color</kbd></td>
<td class="calibre46">This creates a color swatch in the Inspector tab that opens up a <kbd class="calibre13">color picker = (float,float,float,float)</kbd></td>
</tr>
<tr class="calibre45">
<td class="calibre47"><kbd class="calibre13">2D</kbd></td>
<td class="calibre48">This creates a texture swatch that allows a user to drag a texture into the shader</td>
</tr>
<tr class="calibre45">
<td class="calibre46"><kbd class="calibre13">Rect</kbd></td>
<td class="calibre46">This creates a non-power of two texture swatch and functions the same as the <kbd class="calibre13">2D</kbd> GUI element</td>
</tr>
<tr class="calibre45">
<td class="calibre47">Cube</td>
<td class="calibre48">This creates a cube map swatch in the Inspector tab and allows a user to drag and drop a cube map into the shader</td>
</tr>
<tr class="calibre45">
<td class="calibre47"><kbd class="calibre13">float</kbd></td>
<td class="calibre48">This creates a float value in the Inspector tab but without a slider</td>
</tr>
<tr class="calibre45">
<td class="calibre47">Vector</td>
<td class="calibre48">This creates a four-float property that allows you to create directions or colors</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">Finally, there is the <strong class="calibre5">Default Value</strong>. This simply sets the value of this property to the value that you place in the code. So, in the previous example diagram, the default value for the property named <kbd class="calibre13">_AmbientColor</kbd>, which is of the <kbd class="calibre13">Color</kbd> type, is set to a value of <kbd class="calibre13">1, 1, 1, 1</kbd>. As this is a <kbd class="calibre13">Color</kbd> property expecting a color that is <kbd class="calibre13">RGBA</kbd> or <kbd class="calibre13">float4</kbd> or <kbd class="calibre13">r, g, b, a = x, y, z, w</kbd>, this <kbd class="calibre13">Color</kbd> property, when first created, is set to white.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<p class="calibre3">The properties are documented in the Unity manual at <a href="http://docs.unity3d.com/Documentation/Components/SL-Properties.html" class="calibre10">http://docs.unity3d.com/Documentation/Components/SL-Properties.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using properties in a Surface Shader</h1>
                
            
            
                
<p class="calibre3">Now that we have created some properties, let's actually hook them up to the shader so that we can use them as tweaks to our shader and make the material process much more interactive. We can use the Properties values from the material's Inspector tab because we have attached a variable name to the property itself, but in the shader code, you have to set up a couple of things before you can start calling the value by its variable name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">The following steps show you how to use the properties in a Surface Shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Continuing from the previous example, let's create another shader with the name <kbd class="calibre13">ParameterExample</kbd>. Just like before, remove the <kbd class="calibre13">_MainTex</kbd> property in the same manner as was done in the <em class="calibre2">Adding properties to a shader</em> recipe of this chapter:</li>
</ol>
<pre class="calibre18">// Inside the Properties block<br class="title-page-name"/>_MainTex ("Albedo (RGB)", 2D) = "white" {} <br class="title-page-name"/><br class="title-page-name"/>// Below the CGPROGRAM line
sampler2D _MainTex; <br class="title-page-name"/><br class="title-page-name"/>// Inside of the surf function
fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Afterward, update the <kbd class="calibre13">Properties</kbd> section to the following code:</li>
</ol>
<pre class="calibre18">Properties {<br class="title-page-name"/>  _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/><strong class="calibre1">  _AmbientColor ("Ambient Color", Color) = (1,1,1,1) </strong><br class="title-page-name"/><strong class="calibre1">  _MySliderValue ("This is a Slider", Range(0,10)) = 2.5</strong> <br class="title-page-name"/><br class="title-page-name"/>  _Glossiness ("Smoothness", Range(0,1)) = 0.5<br class="title-page-name"/>  _Metallic ("Metallic", Range(0,1)) = 0.0<br class="title-page-name"/>}</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Next, add the following lines of code to the shader, below the <kbd class="calibre13">CGPROGRAM</kbd> line:</li>
</ol>
<pre class="calibre18">float4 _AmbientColor; 
float _MySliderValue; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">With <em class="calibre2">step 3</em> complete, we can now use the values from the properties in our shader. Let's do this by adding the value from the <kbd class="calibre13">_Color</kbd> property to the <kbd class="calibre13">_AmbientColor</kbd> property and giving the result of this to the <kbd class="calibre13">o.Albedo</kbd> line of code. So, let's add the following code to the shader in the <kbd class="calibre13">surf()</kbd> function:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>      // We can then use the properties values in our shader <br class="title-page-name"/>      fixed4 c = pow((_Color + _AmbientColor), _MySliderValue); <br class="title-page-name"/><br class="title-page-name"/>      // Albedo comes from property values given from slider and colors<br class="title-page-name"/>      o.Albedo = c.rgb;<br class="title-page-name"/><br class="title-page-name"/>      // Metallic and smoothness come from slider variables<br class="title-page-name"/>      o.Metallic = _Metallic;<br class="title-page-name"/>      o.Smoothness = _Glossiness;<br class="title-page-name"/>      o.Alpha = c.a;<br class="title-page-name"/>    }<br class="title-page-name"/>    ENDCG</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Finally, your shader should look like the following shader code. If you save your shader and re-enter Unity, your shader will compile. If there were no errors, you will now have the ability to change the ambient and emissive colors of the material as well as increase the saturation of the final color using the slider value. Pretty neat:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/Chapter02/ParameterExample" {<br class="title-page-name"/>  // We define Properties in the properties block <br class="title-page-name"/>  Properties {<br class="title-page-name"/>    _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>    _Glossiness ("Smoothness", Range(0,1)) = 0.5<br class="title-page-name"/>    _Metallic ("Metallic", Range(0,1)) = 0.0<br class="title-page-name"/>  }<br class="title-page-name"/>  SubShader {<br class="title-page-name"/>    Tags { "RenderType"="Opaque" }<br class="title-page-name"/>    LOD 200<br class="title-page-name"/><br class="title-page-name"/>    // We need to declare the properties variable type inside of the<br class="title-page-name"/>    // CGPROGRAM so we can access its value from the properties block.<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    // Physically based Standard lighting model, and enable shadows on all light types<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows<br class="title-page-name"/><br class="title-page-name"/>    // Use shader model 3.0 target, to get nicer looking lighting<br class="title-page-name"/>    #pragma target 3.0<br class="title-page-name"/><br class="title-page-name"/>    float4 _AmbientColor; <br class="title-page-name"/>    float _MySliderValue; <br class="title-page-name"/><br class="title-page-name"/>    struct Input {<br class="title-page-name"/>      float2 uv_MainTex;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    half _Glossiness;<br class="title-page-name"/>    half _Metallic;<br class="title-page-name"/>    fixed4 _Color;<br class="title-page-name"/><br class="title-page-name"/>    // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.<br class="title-page-name"/>    // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.<br class="title-page-name"/>    // #pragma instancing_options assumeuniformscaling<br class="title-page-name"/>    UNITY_INSTANCING_BUFFER_START(Props)<br class="title-page-name"/>      // put more per-instance properties here<br class="title-page-name"/>    UNITY_INSTANCING_BUFFER_END(Props)<br class="title-page-name"/><br class="title-page-name"/>    void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>      // We can then use the properties values in our shader <br class="title-page-name"/>      fixed4 c = pow((_Color + _AmbientColor), _MySliderValue); <br class="title-page-name"/><br class="title-page-name"/>      // Albedo comes from property values given from slider and colors<br class="title-page-name"/>      o.Albedo = c.rgb;<br class="title-page-name"/><br class="title-page-name"/>      // Metallic and smoothness come from slider variables<br class="title-page-name"/>      o.Metallic = _Metallic;<br class="title-page-name"/>      o.Smoothness = _Glossiness;<br class="title-page-name"/>      o.Alpha = c.a;<br class="title-page-name"/>    }<br class="title-page-name"/>    ENDCG<br class="title-page-name"/>  }<br class="title-page-name"/>  FallBack "Diffuse"<br class="title-page-name"/>}</pre>
<p>The <kbd class="calibre37">pow(arg1, arg2)</kbd> function is a built-in function that will perform the equivalent <kbd class="calibre37">math</kbd> function of power. So, argument <kbd class="calibre37">1</kbd> is the value that we want to raise to a power and argument <kbd class="calibre37">2</kbd> is the power that we want to raise it to.<br class="calibre40"/>
To find out more about the <kbd class="calibre37">pow()</kbd> function, look at the Cg tutorial. It is a great free resource that you can use to learn more about shading and there is a glossary of all the functions available to you in the Cg shading language at <a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html" class="calibre31">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html</a>.</p>
<p class="calibre3">The following screenshot demonstrates the result obtained using our properties to control our material's colors and saturation from within the material's Inspector tab:</p>
<div><img src="img/00037.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">When you declare a new property in the <kbd class="calibre13">Properties</kbd> block, you are providing a way for the shader to retrieve the tweaked value from the material's Inspector tab. This value is stored in the variable name portion of the property. In this case, <kbd class="calibre13">_AmbientColor</kbd>, <kbd class="calibre13">_Color</kbd>, and <kbd class="calibre13">_MySliderValue</kbd> are the variables in which we are storing the tweaked values.</p>
<p class="calibre3">In order for you to be able to use the value in the <kbd class="calibre13">SubShader</kbd> block, you need to create three new variables with the same names as the property's variable name. This automatically sets up a link between these two so that they know they have to work with the same data. Additionally, it declares the type of data that we want to store in our <kbd class="calibre13">SubShader</kbd> variables, which will come in handy when we look at optimizing shaders in a later chapter. Once you have created the <kbd class="calibre13">SubShader</kbd> variables, you can then use the values in the <kbd class="calibre13">surf()</kbd> function. In this case, we want to add the <kbd class="calibre13">_Color</kbd> and <kbd class="calibre13">_AmbientColor</kbd> variables together and take it to a power of whatever the <kbd class="calibre13">_MySliderValue</kbd> variable is equal to in the material's Inspector tab. The vast majority of shaders start out as Standard Shaders and get modified until they match the desired look. We have now created the foundation for any Surface Shader you will create that requires a diffuse component.</p>
<p>Materials are assets. This means that any change made to them while your game is running in the editor are permanent. If you have changed the value of a property by mistake, you can undo it using <em class="calibre21">Ctrl </em>+ <em class="calibre21">Z</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">Like any other programming language, Cg does not allow mistakes. As such, your shader will not work if you have a typo in your code. When this happens, your materials are rendered in unshaded magenta:</p>
<div><img src="img/00038.gif" class="calibre49"/></div>
<p class="calibre3">When a script does not compile, Unity prevents your game from being exported or even executed. Conversely, errors in shaders do not stop your game from being executed. If one of your shaders appears as magenta, it is time to investigate where the problem is. If you select the incriminated shader, you will see a list of errors displayed in its Inspector tab:</p>
<div><img src="img/00039.jpeg" class="calibre50"/></div>
<p class="calibre3">Despite showing the line that raised the error, it rarely means that this is the line that has to be fixed. The error message shown in the previous screenshot is generated by deleting the <kbd class="calibre13">sampler2D _MainTex</kbd> variable from the <kbd class="calibre13">SubShader{}</kbd> block. However, the error is raised by the first line that tries to access such a variable. Finding and fixing what's wrong with code is a process called <strong class="calibre5">debugging</strong>. The most common mistakes that you should check for are as follows:</p>
<ul class="calibre11">
<li class="calibre12">A missing bracket. If you forgot to add a curly bracket to close a section, the compiler is likely to raise errors at the end of the document, at the beginning, or in a new section.</li>
<li class="calibre12">A missing semicolon. One of the most common mistakes, but luckily one of the easiest to spot and fix. When looking at the Error definition, first check if the line above it has a semicolon or not. </li>
<li class="calibre12">A property that has been defined in the <kbd class="calibre13">Properties</kbd> section but has not been coupled with a variable in the <kbd class="calibre13">SubShader{}</kbd> block.</li>
<li class="calibre12">Compared to what you might be used to in C# scripts, the floating point values in Cg do not need to be followed by an <kbd class="calibre13">f</kbd>. It's <kbd class="calibre13">1.0</kbd>, not <kbd class="calibre13">1.0f</kbd>.</li>
</ul>
<p class="calibre3">The error messages raised by shaders can be very misleading, especially due to their strict syntactic constraints. If you are in doubt about their meaning, it's best to search the internet. The Unity forums are filled with other developers who are likely to have encountered (and fixed) your problem before.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<ul class="calibre11">
<li class="calibre12">More information on how to master Surface Shaders and their properties can be found in <a href="part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 3</a>, <em class="calibre2">Surface Shaders and Texture Mapping</em>.</li>
<li class="calibre12">If you are curious to see what shaders can actually do when used at their full potential, have a look at <a href="part0258.html#7M1H40-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 11</a>, <em class="calibre2">Advanced Shading Techniques</em>, for some of the most advanced techniques covered in this book.</li>
</ul>


            

            
        
    </body></html>