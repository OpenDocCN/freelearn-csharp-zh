<html><head></head><body>
		<div id="_idContainer132">
			<h1 id="_idParaDest-240" class="chapter-number"><a id="_idTextAnchor239"/>10</h1>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor240"/>All About Testing the Solution</h1>
			<p>When creating microservices and using <strong class="bold">continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>), finding errors early is an important part. Having errors in production is costly, and it’s best to find them as early as <a id="_idIndexMarker753"/>possible. Testing helps reduce costs by finding <span class="No-Break">errors early.</span></p>
			<p>This chapter covers different kinds of tests needed with microservices solutions. We start creating unit tests, which should be the major tests used because issues are found fast, followed by integration tests, where multiple components of the solution are tested in collaboration. Integration tests can be done in-process where HTTP requests are simulated and in an environment where services are running on the systems, which allows you to test the environment <span class="No-Break">under load.</span></p>
			<p>In this chapter, you’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Create <span class="No-Break">unit tests</span></li>
				<li>Create .NET Aspire <span class="No-Break">integration tests</span></li>
				<li>Create end-to-end .NET <span class="No-Break">Playwright tests</span></li>
			</ul>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>Technical requirements</h1>
			<p>With this chapter, as with the previous chapters, you need an Azure subscription and a <span class="No-Break">Docker Desktop.</span></p>
			<p>The code for this chapter can be found in this GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</span></a><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">ch10/final</strong> folder, you’ll see these projects with the final result of <span class="No-Break">this chapter.</span></p>
			<p>These projects are unchanged from <span class="No-Break">previous chapters:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.AppHost</strong> – The .NET Aspire <span class="No-Break">host project</span></li>
				<li><strong class="source-inline">Codebreaker.ServiceDefaults</strong> – Common <span class="No-Break">service configuration</span></li>
				<li><strong class="source-inline">Codebreaker.Bot</strong> – The bot service to <span class="No-Break">run games</span></li>
			</ul>
			<p>These projects are unchanged from previous chapters, but of special interest for <span class="No-Break">the tests:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.Analyzers</strong> – This is the project that contains analyzers to verify game moves and <span class="No-Break">return results</span></li>
				<li><strong class="source-inline">Codebreaker.GameApis</strong> – The games API <span class="No-Break">service project</span></li>
			</ul>
			<p>These projects <span class="No-Break">are new:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.Analyzers.Tests</strong> – Unit tests for the <span class="No-Break">analyzer library</span></li>
				<li><strong class="source-inline">Codebreaker.Bot.Tests</strong> – Unit tests for the bot <span class="No-Break">service library</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs.Tests</strong> – Unit tests for the games <span class="No-Break">services project</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs.IntegrationTests</strong> – In-memory <span class="No-Break">integration tests</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs.Playwright</strong> – Tests with <span class="No-Break">Microsoft Playwright</span></li>
			</ul>
			<p>Working through the code with this chapter, you can start using the <strong class="source-inline">start</strong> folder, which contains the same projects without the <span class="No-Break">test projects.</span></p>
			<p>To easily deploy the solution to Microsoft Azure, check out the README file in the source code repo of <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Creating unit tests</h1>
			<p>Unit tests are tests that test a <a id="_idIndexMarker754"/>small piece of testable software. Does this functionality behave as expected? These tests should be fast, used directly on the developer system (and run with CI as<a id="_idIndexMarker755"/> well). With the <strong class="bold">Visual Studio Live Unit Testing</strong> feature (part of Visual Studio Enterprise), unit tests run while the code is updated, even before saving the <span class="No-Break">source code.</span></p>
			<p>The cost of bugs grows during the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>). When bugs are found late (for example, in <a id="_idIndexMarker756"/>production), the cost grows exponentially. For fixing bugs early (for example, while typing the code), Visual Studio can give hints and show errors; as we are already working on the code, it’s not necessary to take the time to dive into the functionality as we are already working on it. For finding bugs with other test types (for example, integration or load tests), the fixes are more expensive – but of course, a lot less expensive than finding a bug <span class="No-Break">in production.</span></p>
			<p>A goal should be to reduce cost, and thus if some functionality can be verified with unit tests and other test types, prefer <span class="No-Break">unit tests.</span></p>
			<p>Before we start creating a unit test, what is the heart of the games service in need of unit tests? It’s the analyzer library. There’s some complexity with the game rules, and it’s easy to make some logical errors writing the code. It’s also a place where some refactoring could be done<a id="_idIndexMarker757"/> to increase performance and reduce memory needs. After refactoring, the application should function in the <span class="No-Break">same way.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">When I was initially developing the games analyzer library, I created unit tests beforehand and enhanced the unit tests <a id="_idIndexMarker758"/>while developing the algorithms. With <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), unit tests are created before <span class="No-Break">the functionality.</span></p>
			<p class="callout">Before fixing bugs, I also created new unit tests. Why did the bug occur? Why was it not covered by a test? With many different projects, I see bugs that have been fixed come back with a later version. If there’s a unit test to verify the functionality, the same issue cannot resurface with a <span class="No-Break">new version.</span></p>
			<p>Next, let’s dive into the <strong class="source-inline">Codebreaker</strong> code, which needs many <span class="No-Break">unit tests.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/>Exploring the games analyzer library</h2>
			<p>Let’s explore <a id="_idIndexMarker759"/>the <strong class="source-inline">GameGuessAnalyzer</strong> class in<a id="_idIndexMarker760"/> the <strong class="source-inline">Codebreaker</strong> <span class="No-Break">analyzer library:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/GameGuessAnalyzer.cs</p>
			<pre class="source-code">
public abstract class GameGuessAnalyzer&lt;TField, TResult&gt; :
  IGameGuessAnalyzer&lt;TResult&gt;
  where TResult : struct
{
  protected readonly IGame _game;
  private readonly int _moveNumber;
  protected TField[] Guesses { get; private set; }
  <strong class="bold">protected GameGuessAnalyzer(IGame game, TField[] guesses, int moveNumber)</strong>
  {
    _game = game;
    Guesses = guesses;
    _moveNumber = moveNumber;
  }
  protected abstract TResult GetCoreResult();
  private void ValidateGuess()
  {
    // code removed for brevity
  }
  protected abstract void SetGameEndInformation(TResult result);
<strong class="bold">  public TResult GetResult()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    ValidateGuess();</strong>
<strong class="bold">    TResult result = GetCoreResult();</strong>
<strong class="bold">    SetGameEndInformation(result);</strong>
<strong class="bold">    return result;</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>The <strong class="source-inline">GetResult</strong> method is the heart of this class. With the constructor of the <strong class="source-inline">GameGuessAnalyzer</strong> abstract base class, the game and the guesses are passed with parameters. The <strong class="source-inline">GetResult</strong> method uses the codes of the game and uses the guesses to return the result – the number of colors that are in the correct position and the number of colors that are correct but<a id="_idIndexMarker761"/> in the wrong position. The implementation of the <strong class="source-inline">GetResult</strong> method is just an invocation of four methods. The <strong class="source-inline">ValidateGuess</strong> method analyses the correctness of guesses and throws an exception if the guesses are not correct. The <strong class="source-inline">GetCoreResult</strong> method is abstract and needs to be implemented by a <span class="No-Break">derived class.</span></p>
			<p>One of the classes <a id="_idIndexMarker762"/>deriving from the <strong class="source-inline">GameGuessAnalyzer</strong> class is the <strong class="source-inline">ColorGameGuessAnalyzer</strong> class. This is used by the <strong class="source-inline">Game6x4</strong> and <strong class="source-inline">Game8x5</strong> game types (six colors with four codes and eight colors with <span class="No-Break">five codes):</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Analyzers.Tests/Analyzers/ColorGameGuessAnalyzer.cs</p>
			<pre class="source-code">
public class <strong class="bold">ColorGameGuessAnalyzer</strong>(
  IGame game, ColorField[] guesses, int moveNumber) :
  GameGuessAnalyzer&lt;ColorField, ColorResult&gt;(game, guesses, moveNumber)
{
  protected override <strong class="bold">ValidateGuessValues()</strong>
  {
    // code removed for brevity
  }
  protected override ColorResult <strong class="bold">GetCoreResult()</strong>
  {
    // code removed for brevity
  }
}</pre>
			<p>This class overrides the <strong class="source-inline">ValidateGuessValues</strong> and the <strong class="source-inline">GetCoreResult</strong> methods. <strong class="source-inline">ValidateGuessValues</strong> validates the input data and throws exceptions if the data is not valid. The <strong class="source-inline">GetCoreResult</strong> method<a id="_idIndexMarker763"/> implements the algorithm for the <strong class="source-inline">Codebreaker</strong> game, finds if the guesses are correctly placed and if the guesses are correct but incorrectly placed, and<a id="_idIndexMarker764"/> returns the <span class="No-Break">result accordingly.</span></p>
			<p>Let’s create a unit test project for <span class="No-Break">this library.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>Creating a unit test project</h2>
			<p>Using the .NET CLI, we can <a id="_idIndexMarker765"/>create a new xUnit <span class="No-Break">test project:</span></p>
			<pre class="console">
dotnet new xunit -o Codebreaker.Analyzers.Tests
cd Codebreaker.Analyzers.Tests
dotnet add reference ..\Codebreaker.Analyzers</pre>
			<p>This command creates a <strong class="source-inline">Codebreaker.Analyzers.Tests</strong> project with references to xUnit NuGet packages and a project reference to the <span class="No-Break">analyzer project.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">I’m mainly using xUnit for unit tests. It’s a matter of choice whether to use <strong class="bold">MSTest</strong>, <strong class="bold">NUnit</strong>, or <strong class="bold">xUnit</strong>; you can use any of these frameworks for unit tests, and all of these are greatly integrated within the .NET tools. I myself switched from MSTest to xUnit with early betas of .NET Core 1.0 when xUnit was available, but MSTest was not ready for the new .NET – and most unit tests from the .NET team themselves are done <span class="No-Break">using xUnit.</span></p>
			<p>Before creating the first <a id="_idIndexMarker766"/>tests, some preparations need to <span class="No-Break">be done.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>Mocking the IGame interface</h2>
			<p>With the constructor of the <strong class="source-inline">ColorGameGuessAnalyzer</strong> class, an object implementing the <strong class="source-inline">IGame</strong> interface is required with the constructor. A unit test should only test a small functionality <a id="_idIndexMarker767"/>without testing dependencies that are covered by<a id="_idIndexMarker768"/> their own unit tests. When testing the <strong class="source-inline">ColorGameGuessAnalyzer</strong> class, we don’t want to add a dependency to the <strong class="source-inline">Game</strong> class while testing the analyzer. What’s needed by the <strong class="source-inline">ColorGameGuessAnalyzer</strong> class is the <strong class="source-inline">IGame</strong> interface. To allow the test to run, the <strong class="source-inline">IGame</strong> interface is implemented by a <span class="No-Break">mocking class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/MockColorGame.cs</p>
			<pre class="source-code">
public class MockColorGame : IGame
{
  public Guid Id { get; init; }
  public int NumberCodes { get; init; }
  public int MaxMoves { get; init; }
  public DateTime? EndTime { get; set; }
  public bool IsVictory { get; set; }
  // code removed for brevity
}</pre>
			<p>The <strong class="source-inline">MockColorGame</strong> class is just a simple data holder to implement the <strong class="source-inline">IGame</strong> interface, thus we don’t need to use any mocking library. With another unit test implementation done later, we’ll use <a id="_idIndexMarker769"/>a mocking library to mock functionality that should not be tested by the <span class="No-Break">unit test.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/>Creating test helpers</h2>
			<p>To define common functionality<a id="_idIndexMarker770"/> needed by multiple unit tests, helper methods<a id="_idIndexMarker771"/> are created within the <strong class="source-inline">ColorGame6x4AnalyzerTests</strong> <span class="No-Break">test class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
private static MockColorGame CreateGame(string[] codes) =&gt; new()
{
  GameType = GameTypes.Game6x4,
  NumberCodes = 4,
  MaxMoves = 12,
  IsVictory = false,
  FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
  {
    [FieldCategories.Colors] = [.. TestData6x4.Colors6]
  },
  Codes = codes
};
private static ColorResult <strong class="bold">AnalyzeGame</strong>(
  string[] codes,
  string[] guesses,
  int moveNumber = 1)
{
  MockColorGame game = CreateGame(codes);
<strong class="bold">  ColorGameGuessAnalyzer analyzer = new(game, [.. guesses.</strong>
    <strong class="bold">ToPegs&lt;ColorField&gt;()], moveNumber);</strong>
<strong class="bold">  return analyzer.GetResult();</strong>
}</pre>
			<p>The <strong class="source-inline">AnalyzeGame</strong> method <a id="_idIndexMarker772"/>receives a string array representing the valid code, a string array representing the guesses, and the move number. This information is used to create a mocked game instance and to invoke the <strong class="source-inline">GetResult</strong> method of the analyzer class. The result of the<a id="_idIndexMarker773"/> analysis is returned with a <strong class="source-inline">ColorResult</strong> type. This helper method can now be used to easily create <span class="No-Break">unit tests.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/>Creating a simple unit test</h2>
			<p>The first unit test is <a id="_idIndexMarker774"/>implemented with the <span class="No-Break"><strong class="source-inline">GetResult_Should_ReturnThreeWhite</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[Fact]</strong>
public void GetResult_Should_ReturnThreeWhite()
{
  <strong class="bold">ColorResult expectedKeyPegs = new(0, 3);</strong>
  ColorResult? resultKeyPegs = <strong class="bold">AnalyzeGame</strong>(
    [Green, Yellow, Green, Black],
    [Yellow, Green, Black, Blue]
  );
<strong class="bold">  Assert.Equal(expectedKeyPegs, resultKeyPegs);</strong>
}</pre>
			<p>Using xUnit, the <strong class="source-inline">Fact</strong> attribute declares a method to be a unit test. A unit test consists of three parts: <strong class="bold">arrange, act, and assert</strong> (<strong class="bold">AAA</strong>). With <em class="italic">arrange</em>, the expected result is defined using the <strong class="source-inline">expectedKeyPegs</strong> variable. Invoking the <strong class="source-inline">AnalyzeGame</strong> method is the act. The <strong class="source-inline">Green</strong> – <strong class="source-inline">Yellow</strong> – <strong class="source-inline">Green</strong> – <strong class="source-inline">Black</strong> code is passed as valid code, and <strong class="source-inline">Yellow</strong> – <strong class="source-inline">Green</strong> – <strong class="source-inline">Black</strong> – <strong class="source-inline">Blue</strong> as a guess. With this guess, no color is in the correct position, but three colors are correct in the wrong positions, thus three whites should be returned. If this <a id="_idIndexMarker775"/>result is correct, this is verified using the <span class="No-Break"><strong class="source-inline">Assert.Equal</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>Passing test data to unit tests</h2>
			<p>With this scenario, it’s useful to just<a id="_idIndexMarker776"/> define one method that’s used with<a id="_idIndexMarker777"/> different test data to verify the <span class="No-Break">different outcomes:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[InlineData(1, 2, Red, Yellow, Red, Blue)]</strong>
<strong class="bold">[InlineData(2, 0, White, White, Blue, Red)]</strong>
<strong class="bold">[Theory]</strong>
<strong class="bold">public void GetResult_ShouldReturn_InlineDataResults(</strong>
<strong class="bold">  int expectedBlack, int expectedWhite,</strong>
<strong class="bold">  params string[] guessValues)</strong>
{
  string[] code = [Red, Green, Blue, Red];
  ColorResult expectedKeyPegs = new (expectedBlack, expectedWhite);
  ColorResult resultKeyPegs = AnalyzeGame(code, guessValues);
  Assert.Equal(expectedKeyPegs, resultKeyPegs);
}</pre>
			<p>With xUnit, using the <strong class="source-inline">Theory</strong> attribute instead of the <strong class="source-inline">Fact</strong> attribute allows the test method to be invoked multiple times, passing different test data. The <strong class="source-inline">GetResult_ShouldReturn_InlineResults</strong> method uses arguments that are specified with the <strong class="source-inline">InlineData</strong> attribute. With every <strong class="source-inline">InlineData</strong> attribute, the parameter values for the arguments defined with the method are passed. Here, two tests are covered with one<a id="_idIndexMarker778"/> implementation. This feature allows for quickly extending test cases by just adding new <span class="No-Break"><strong class="source-inline">InlineData</strong></span><span class="No-Break"> attributes.</span></p>
			<p>Instead of <a id="_idIndexMarker779"/>using the <strong class="source-inline">InlineDataAttribute</strong> class, a class can be created implementing <strong class="source-inline">IEnumerable&lt;object[]&gt;</strong> to supply <span class="No-Break">test data:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
public class TestData6x4 : <strong class="bold">IEnumerable&lt;object[]&gt;</strong>
{
  public static readonly string[] Colors6 = [Red, Green, Blue, Yellow,
    Black, White];
<strong class="bold">  public IEnumerator&lt;object[]&gt; GetEnumerator()</strong>
<strong class="bold">  {</strong>
    yield return new object[]
    {
      new string[] { Green, Blue,  Green, Yellow },
      new string[] { Green, Green, Black, White },
      new ColorResult(1, 1) // expected
    };
    yield return new object[]
    {
      new string[] { Red,   Blue,  Black, White },
      new string[] { Black, Black, Red,   Yellow },
      new ColorResult(0, 2)
    };
    // code removed for brevity – more test cases here
  }
  IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}</pre>
			<p><strong class="source-inline">object[]</strong> defines all the values for one method invocation. The first argument passed defines the valid code for the <a id="_idIndexMarker780"/>game, the second argument the guess data, and the third argument the expected <a id="_idIndexMarker781"/>result. With every iteration of <strong class="source-inline">IEnumerable</strong>, a new test run is done. The next code snippet shows the test method implementation using the <span class="No-Break">data class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[Theory]</strong>
<strong class="bold">[ClassData(typeof(TestData6x4))]</strong>
<strong class="bold">public void GetResult_ShouldReturn_UsingClassdata(</strong>
<strong class="bold">  string[] code,</strong>
<strong class="bold">  string[] guess,</strong>
<strong class="bold">  ColorResult expectedKeyPegs)</strong>
<strong class="bold">{</strong>
  ColorResult actualKeyPegs = AnalyzeGame(code, guess);
  Assert.Equal(expectedKeyPegs, actualKeyPegs);
}</pre>
			<p>Instead of using the <strong class="source-inline">InlineData</strong> attribute, here <strong class="source-inline">ClassData</strong> is used. Using an object returning the test data is more flexible. The <strong class="source-inline">InlineData</strong> attribute requires constant values that are stored by<a id="_idIndexMarker782"/> the compiler. With the <strong class="source-inline">ClassData</strong> attribute, data can <a id="_idIndexMarker783"/>also be <span class="No-Break">created dynamically.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>Expecting exceptions with a unit test</h2>
			<p>Another test case where we<a id="_idIndexMarker784"/> expect an exception to be thrown is shown in the next <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
[Fact]
public void GetResult_Should_ThrowOnInvalidGuessValues()
{
  <strong class="bold">Assert.Throws&lt;ArgumentException&gt;</strong>(() =&gt;
    AnalyzeGame(
      ["Black", "Black", "Black", "Black"],
      ["Black", "Der", "Blue", "Yellow"] // "Der" is wrong
  ));
}</pre>
			<p><strong class="source-inline">Assert.Throws</strong> defines the exception type that should be thrown by the implementation when the test data is passed. If an exception is not thrown, the <span class="No-Break">test fails.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor250"/>Using a mocking library</h2>
			<p>With some classes that<a id="_idIndexMarker785"/> should be tested, it’s great to have a mocking library. The <strong class="source-inline">GamesService</strong> class injecting the <strong class="source-inline">IGamesRepository</strong> interface is shown in the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
<strong class="bold">public class GamesService(IGamesRepository dataRepository) : IGamesService</strong>
{
  public async Task&lt;(Game Game, Move Move)&gt; <strong class="bold">SetMoveAsync</strong>(
    Guid id, string gameType, string[] guesses,
    int moveNumber,
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    Game? game = await dataRepository.GetGameAsync(id, </strong>
<strong class="bold">    cancellationToken);</strong>
<strong class="bold">    CodebreakerException.ThrowIfNull(game);</strong>
<strong class="bold">    CodebreakerException.ThrowIfEnded(game);</strong>
<strong class="bold">    CodebreakerException.ThrowIfUnexpectedGameType(game, gameType);</strong>
    Move move = game.ApplyMove(guesses, moveNumber);
<strong class="bold">    await dataRepository.AddMoveAsync(game, move, cancellationToken);</strong>
    return (game, move);
  }
  // code removed for brevity
}</pre>
			<p>With the <strong class="source-inline">GamesService</strong> class, the <strong class="source-inline">IGamesRepository</strong> interface is injected using constructor injection. When<a id="_idIndexMarker786"/> testing the <strong class="source-inline">SetMoveAsync</strong> method, the implementation of the <strong class="source-inline">IGamesRepository</strong> interface should not be part of this test. There’s another test for the games repository. Instead, a mocking implementation of this class is used for the unit test. The <strong class="source-inline">SetMoveAsync</strong> method invokes the <strong class="source-inline">GetGameAsync</strong> method of the <strong class="source-inline">IGamesRepository</strong> interface. The real implementation of this method should not be part of the test, but we need some different results that can be used with the methods used afterward. When this method returns <strong class="source-inline">null</strong> because it didn’t find the game, <strong class="source-inline">CodebreakerException.ThrowIfNull</strong> should throw an exception. If the method returns a game that already ended, the next method should throw an exception because a new move <a id="_idIndexMarker787"/>cannot be set to a game that already ended. The <strong class="source-inline">ThrowIfUnexpectedGameType</strong> method should throw an exception if the game type passed is different from the game type of the game retrieved. This can easily be solved by using a <span class="No-Break">mocking library.</span></p>
			<p>Let’s create another xUnit test project named <strong class="source-inline">Codebreaker.GameAPIs.Tests</strong> to test the <strong class="source-inline">GamesService</strong> class. To mock the <strong class="source-inline">IGamesRepository</strong> interface, add the <strong class="source-inline">moq</strong> <span class="No-Break">NuGet package.</span></p>
			<p>The following code snippet shows fields for games and game IDs that are used by the <span class="No-Break">unit test:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
public class GamesServiceTests
{
<strong class="bold">  private readonly Mock&lt;IGamesRepository&gt; _gamesRepositoryMock = new();</strong>
  private readonly Guid <strong class="bold">_endedGameId</strong> = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E6");
  private readonly Game <strong class="bold">_endedGame</strong>;
  private readonly Guid <strong class="bold">_running6x4GameId</strong> = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E7");
  private readonly Game <strong class="bold">_running6x4Game</strong>;
  private readonly Guid <strong class="bold">_notFoundGameId </strong>= Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E8");
  private readonly Guid _running6x4MoveId1 = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E9");
  private readonly string[] _guessesMove1 = ["Red", "Green", "Blue", "Yellow"];</pre>
			<p>The <strong class="source-inline">IGamesRepository</strong> interface is mocked creating a new instance by using the generic <strong class="source-inline">Mock</strong> type. After this, games are <a id="_idIndexMarker788"/>predefined for a game not found in the repository (<strong class="source-inline">_notFoundGameId</strong>), a game that already ended (<strong class="source-inline">_endedGame</strong>), and a running game that is <span class="No-Break">active (</span><span class="No-Break"><strong class="source-inline">_running6x4Game</strong></span><span class="No-Break">).</span></p>
			<p>The constructor of the <strong class="source-inline">GamesServiceTests</strong> class initializes the <span class="No-Break">game objects:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
public GamesServiceTests()
{
<strong class="bold">  _endedGame</strong> = new(_endedGameId, "Game6x4", "Test", DateTime.Now, 4, 12)
  {
    Codes = ["Red", "Green", "Blue", "Yellow"],
    FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
    {
      { FieldCategories.Colors, ["Red", "Green", "Blue", "Yellow", 
<strong class="bold">        </strong>"Purple", "Orange"] }
    },
    EndTime = DateTime.Now.AddMinutes(3)
  };
  // code removed for brevity
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.GetGameAsync(_endedGameId, </strong>
<strong class="bold">     CancellationToken.None)).ReturnsAsync(_endedGame);</strong>
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.GetGameAsync</strong>
  <strong class="bold">(_running6x4GameId, CancellationToken.None)).ReturnsAsync</strong>
  <strong class="bold">(_running6x4Game);</strong>
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.AddMoveAsync</strong>
  <strong class="bold">(_running6x4Game, It.IsAny&lt;Move&gt;(), CancellationToken.None));</strong>
}</pre>
			<p>With the constructor, instances of the different game types are created. The game already ended has the <strong class="source-inline">EndTime</strong> property set. To specify the behavior of the mocking implementation, the <strong class="source-inline">Setup</strong> method is invoked. With this, if the <strong class="source-inline">GetGameAsync</strong> method receives the ended <a id="_idIndexMarker789"/>game ID with the parameter, it returns the configured game instance that already ended. Passing the game ID of the running game, the corresponding instance is returned. With the third invocation of the <strong class="source-inline">Setup</strong> method, it’s defined that the <strong class="source-inline">AddMoveAsync</strong> method contains an implementation when passing the running game. <strong class="source-inline">It.IsAny&lt;Move&gt;</strong> allows us to invoke this method with any <span class="No-Break"><strong class="source-inline">Move</strong></span><span class="No-Break"> instance.</span></p>
			<p>Now, we can implement unit tests. The first unit test is to verify that the <strong class="source-inline">SetMoveAsync</strong> method throws an exception if the game <span class="No-Break">already ended:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMoveAsync_Should_ThrowWithEndedGame()
{
  GamesService gamesService = new(<strong class="bold">_gamesRepositoryMock.Object</strong>);
  await <strong class="bold">Assert.ThrowsAsync</strong>&lt;CodebreakerException&gt;(async () =&gt;
  {
<strong class="bold">    await gamesService.SetMoveAsync(_endedGameId, "Game6x4", ["Red", </strong>
<strong class="bold">    "Green", "Blue", "Yellow"], 1, CancellationToken.None);</strong>
  });
  <strong class="bold">_gamesRepositoryMock.Verify</strong>(repo =&gt; repo.GetGameAsync(_endedGameId, 
<strong class="bold">   </strong>CancellationToken.None), <strong class="bold">Times.Once</strong>);
}</pre>
			<p>In the <em class="italic">arrange</em> step, the <strong class="source-inline">GamesService</strong> class is instantiated with the mocking object of the <strong class="source-inline">IGamesRepository</strong> implementation. With the unit test act – as already used before – <strong class="source-inline">Assert.ThrowAsync</strong> is used to check if an exception was thrown when invoking the <strong class="source-inline">SetMoveAsync</strong> method with the specified game that already ended. Another check that is done here<a id="_idIndexMarker790"/> is using the <strong class="source-inline">Verify</strong> method on the <strong class="source-inline">Mock</strong> class to check if the method is exactly <span class="No-Break">called once.</span></p>
			<p>The <strong class="source-inline">SetMoveAsync_Should_ThrowWithUnexpcectedGameType</strong> and <strong class="source-inline">SetMoveAsync_Should_ThorwWithNotFoundGameType</strong> unit test methods are very similar, thus are not listed here. Check the source code repo <span class="No-Break">for details.</span></p>
			<p>The test method to test the normal flow is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
[Fact]
public async Task SetMoveAsync_Should_UpdateGameAndAddMove()
{
  GamesService gamesService = new(_gamesRepositoryMock.Object);
  var result = await gamesService.SetMoveAsync(_running6x4GameId, 
<strong class="bold">    </strong>"Game6x4", ["Red", "Green", "Blue", "Yellow"], 1, 
<strong class="bold">    </strong>CancellationToken.None);
<strong class="bold">  Assert.Equal(_running6x4Game, result.Game);</strong>
<strong class="bold">  Assert.Single(result.Game.Moves);</strong>
  _gamesRepositoryMock.Verify(repo =&gt; repo.GetGameAsync
  (_running6x4GameId, CancellationToken.None), Times.Once);
  _gamesRepositoryMock.Verify(repo =&gt; repo.AddMoveAsync
  (_running6x4Game, It.IsAny&lt;Move&gt;(), CancellationToken.None), Times.
  Once);
}</pre>
			<p>The <strong class="source-inline">SetMoveAsync_Should_UpdateGameAndAddMove</strong> method verifies that the <strong class="source-inline">GetGameAsync</strong> and <strong class="source-inline">AddMoveAsync</strong> methods are called once, and with the first move in the game, the <strong class="source-inline">Moves</strong> property<a id="_idIndexMarker791"/> contains exactly <span class="No-Break">one value.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor251"/>Running unit tests</h2>
			<p>To start unit tests, you can use the <strong class="source-inline">dotnet test</strong> .NET CLI command to run all the tests. Using Visual Studio, the <strong class="bold">Test</strong> menu is <a id="_idIndexMarker792"/>available to run all the tests. Using <strong class="bold">Test Explorer</strong>, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em>, you can start testing by test, a group of tests, or all tests, see the outcome of every test, debug tests, run tests until they fail, define a playlist of tests, <span class="No-Break">and more:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B21217_10_01.jpg" alt="Figure 10.1 – Visual Studio Test Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Visual Studio Test Explorer</p>
			<p>When using Visual Studio 2022 Enterprise Edition, you can start Live Unit Testing. With Live Unit Testing, a unit test runs while you change the source code. Here, you can also monitor which code lines are <a id="_idIndexMarker793"/>covered by a unit test and which lines are missed. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> shows the Visual Studio Code editor with Live Unit Testing turned on, and code line <em class="italic">53</em> missed from all <span class="No-Break">unit tests:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B21217_10_02.jpg" alt="Figure 10.2 – Visual Studio Live Unit Testing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Visual Studio Live Unit Testing</p>
			<p>After working through some unit tests, let’s move over to other <span class="No-Break">test types.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Creating .NET Aspire integration tests</h1>
			<p>While unit tests should be the primary tests, integration tests not only test a small functionality but include testing<a id="_idIndexMarker794"/> of multiple components within one test, such as including infrastructure – for example, <span class="No-Break">a database.</span></p>
			<p>.NET Aspire contains a library and test templates using xUnit, which easily allows creating integration tests to directly access the <span class="No-Break">app model.</span></p>
			<p>Let’s create a .NET Aspire test project using .NET Aspire and xUnit, <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Codebreaker.IntegrationTests</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
dotnet new aspire-xunit -o Codebreaker.IntegrationTests</pre>
			<p>This project includes references to the <strong class="source-inline">Aspire.Hosting.Testing</strong> NuGet package, as well as <strong class="source-inline">Microsoft.NET.Test.Sdk</strong>, xUnit, and <strong class="source-inline">xunit.runner.visualstudio</strong>. To allow accessing the app model, add a project reference to <strong class="source-inline">Codebreaker.AppHost</strong>. With the integration test we implement, we need types from the game APIs project, thus we also add a reference <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Codebreaker.GameAPIs</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>Creating asynchronous initialization</h2>
			<p>With all the integration tests of the <a id="_idIndexMarker795"/>game APIs, we need an <strong class="source-inline">HttpClient</strong> instance. xUnit allows for asynchronous initialization by implementing the <span class="No-Break"><strong class="source-inline">IAsyncLifetime</strong></span><span class="No-Break"> interface:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
public class GameAPIsTests : <strong class="bold">IAsyncLifetime</strong>
{
<strong class="bold">  private DistributedApplication? _app;</strong>
<strong class="bold">  private HttpClient? _client;</strong>
  public async Task <strong class="bold">InitializeAsync</strong>()
  {
    // code removed for brevity
  }
  public async Task <strong class="bold">DisposeAsync</strong>()
  {
    if (_app is null) throw new InvalidOperationException();
<strong class="bold">    await _app.DisposeAsync();</strong>
  }
  // code removed for brevity</pre>
			<p>Renaming the class created from the<strong class="source-inline"> IAsyncLifetime</strong> interface defines the  <strong class="source-inline">InitializeAsync</strong> and <strong class="source-inline">DisposeAsync </strong>methods. Field members that will be initialized within the InitalizeAsync <a id="_idIndexMarker796"/>method are the <strong class="source-inline">DistributedApplication</strong> and <strong class="source-inline">HttpClient</strong> classes. You already know the <strong class="source-inline">DistributedApplication</strong> class from the app model in the <strong class="source-inline">AppHost</strong> project. You’ll see how this will be used in the <span class="No-Break"><strong class="source-inline">InitalizeAsync</strong></span><span class="No-Break"> method.</span></p>
			<p>While we didn’t dispose of the <strong class="source-inline">DistributedApplication</strong> instance in the <strong class="source-inline">AppHost</strong> project (because there’s only one instance running for the lifetime of the application, and the resources are freed on the application end), it’s important to dispose of it with unit tests, as it initialized providers and file watchers. With many tests, the user limit of <strong class="source-inline">INotify</strong> instances and the process limit of open file descriptors can be reached – thus, don’t forget to dispose of this resource in <span class="No-Break">test projects.</span></p>
			<p>Let’s see how to create <strong class="source-inline">DistributedApplication</strong> and <span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break"> classes:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
public async Task InitializeAsync()
{
<strong class="bold">  var appHost = await DistributedApplicationTestingBuilder.</strong>
<strong class="bold">    CreateAsync&lt;Projects.Codebreaker_AppHost&gt;();</strong>
<strong class="bold">  _app = await appHost.BuildAsync();</strong>
<strong class="bold">  await _app.StartAsync();</strong>
<strong class="bold">  </strong><strong class="bold">_client = _app.CreateHttpClient("gameapis");</strong>
}</pre>
			<p>Using <strong class="source-inline">DistributedApplicationTestingBuilder</strong> (defined in the <strong class="source-inline">Aspire.Hosting.Testing</strong> namespace), invoking the <strong class="source-inline">CreateAsync</strong> method, a new instance of <strong class="source-inline">DistributedApplicationTestingBuilder</strong> is returned. The generic parameter references the <strong class="source-inline">Codebreaker</strong> <strong class="source-inline">AppHost</strong> project. Similar to what you’ve seen when using the generic parameter with the projects referenced in the <strong class="source-inline">AppHost</strong> project, the same<a id="_idIndexMarker797"/> mechanism is used here, referencing the <strong class="source-inline">AppHost</strong> project itself. Invoking the <strong class="source-inline">BuildAsync</strong> method returns a <strong class="source-inline">DistributedApplication</strong> instance that we may forget to dispose of. Using this instance, we can access the app model definition. In the app model specified by the <strong class="source-inline">Codebreaker.AppHost</strong> project, we have <strong class="source-inline">gameapis</strong> defined, which is the name of the <strong class="source-inline">Codebreaker.GameAPIs</strong> project. <strong class="source-inline">CreateHttpClient</strong> returns an <strong class="source-inline">HttpClient</strong> object to reference this service. Both the <strong class="source-inline">HttpClient</strong> and the <strong class="source-inline">DistributedApplication</strong> objects returned are assigned to field members. Now, we are ready to <span class="No-Break">create tests.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>Creating a test to verify an HTTP bad request status</h2>
			<p>With the first test, let’s verify if the correct status code is returned when an invalid move number is sent. First, we need to<a id="_idIndexMarker798"/> start a <span class="No-Break">new game:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMove_Should_ReturnBadRequest_WithInvalidMoveNumber()
{
  if (_client is null) throw new InvalidOperationException();
<strong class="bold">  CreateGameRequest request = new(GameType.Game6x4, "test");</strong>
<strong class="bold">  var response = await _client.PostAsJsonAsync("/games", request);</strong>
<strong class="bold">  var gameResponse = await response.Content.</strong>
<strong class="bold">    ReadFromJsonAsync&lt;CreateGameResponse&gt;();</strong>
<strong class="bold">  Assert.NotNull(gameResponse);</strong>
  // code removed for brevity</pre>
			<p>Starting the game, we already use the <strong class="source-inline">HttpClient</strong> instance and invoke an HTTP <strong class="source-inline">POST</strong> request, passing the <strong class="source-inline">CreateGameRequest</strong> object. <strong class="source-inline">CreateGameRequest</strong> is available in the test project <a id="_idIndexMarker799"/>because we added a project reference to the <strong class="source-inline">Codebreaker.GameAPIs</strong> project on creation of the <span class="No-Break">test project.</span></p>
			<p>Continue the implementation of this method by setting a <span class="No-Break">game move:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMove_Should_ReturnBadRequest_WithInvalidMoveNumber()
{
  // code removed for brevity
<strong class="bold">  int moveNumber = 0;</strong>
<strong class="bold">  UpdateGameRequest updateGameRequest = new(gameResponse.Id, </strong>
<strong class="bold">  gameResponse.GameType, gameResponse.PlayerName, moveNumber)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    GuessPegs = ["Red", "Red", "Red", "Red"]</strong>
<strong class="bold">  };</strong>
  string uri = $"/games/{updateGameRequest.Id}";
<strong class="bold">  var updateGameResponse = await _client.PatchAsJsonAsync(uri, </strong>
<strong class="bold">    updateGameRequest);</strong>
<strong class="bold">  Assert.Equal(HttpStatusCode.BadRequest, updateGameResponse.</strong>
<strong class="bold">    StatusCode);</strong>
}</pre>
			<p>We use <strong class="source-inline">HttpClient</strong> once more – this time to send a <strong class="source-inline">PATCH</strong> request. Passing <strong class="source-inline">moveNumber</strong> with a <strong class="source-inline">0</strong> value<a id="_idIndexMarker800"/> specifies an incorrect move. The first correct move starts with <strong class="source-inline">1</strong>. This way, we expect to receive a <strong class="source-inline">BadRequest</strong> result, which is verified <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Assert.Equal</strong></span><span class="No-Break">.</span></p>
			<p>Let’s create another test to play a <span class="No-Break">complete game.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>Creating a test to play a complete game</h2>
			<p>The following code snippet shows<a id="_idIndexMarker801"/> an integration test setting <span class="No-Break">multiple moves:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMoves_Should_WinAGame()
{
  // code removed for brevity
<strong class="bold">  int moveNumber = 1;</strong>
  UpdateGameRequest updateGameRequest = new(gameResponse.Id, 
<strong class="bold">    </strong>gameResponse.GameType, gameResponse.PlayerName, moveNumber)
  {
    GuessPegs = ["Red", "Red", "Red", "Red"]
  };
  string uri = $"/games/{updateGameRequest.Id}";
<strong class="bold">  response = await _client.PatchAsJsonAsync(uri, updateGameRequest);</strong>
  var updateGameResponse = await response.Content.
<strong class="bold">    </strong>ReadFromJsonAsync&lt;UpdateGameResponse&gt;();
  Assert.NotNull(updateGameResponse);
  // code removed for brevity</pre>
			<p>Starting the game is the same as before, thus the code is not shown here. Sending the first move is just a little<a id="_idIndexMarker802"/> bit different in that we send the correct move number. From there, we continue sending a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> request:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
  // code remove for brevity
  if (!<strong class="bold">updateGameResponse.IsVictory</strong>)
  {
    Game? game = await _client.GetFromJsonAsync&lt;Game?&gt;(uri);
    Assert.NotNull(game);
    moveNumber = 2;
<strong class="bold">    updateGameRequest = new UpdateGameRequest(gameResponse.Id, </strong>
<strong class="bold">      gameResponse.GameType, gameResponse.PlayerName, moveNumber)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      GuessPegs = game.Codes</strong>
<strong class="bold">    };</strong>
    response = await _client.PatchAsJsonAsync(uri, updateGameRequest);</pre>
			<p>Before sending a <strong class="source-inline">GET</strong> request, we check if the game was won with the first move. This should happen about once in 1,296 invocations; thus, it will happen when running the test often. We don’t want to fail the test if the game was won with the first move. If the game has not been won <a id="_idIndexMarker803"/>yet, a <strong class="source-inline">GET</strong> request is done to find out the correct values, then the correct values are used to make the <span class="No-Break">second move.</span></p>
			<p>Sending the correct move, we should get a <span class="No-Break">successful result:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
    // code removed for brevity
    Assert.True(response.IsSuccessStatusCode);
    updateGameResponse = await response.Content.
<strong class="bold">      </strong>ReadFromJsonAsync&lt;UpdateGameResponse&gt;();
    Assert.NotNull(updateGameResponse);
    Assert.True(updateGameResponse.Ended);
    Assert.True(updateGameResponse.IsVictory);
  }
  // delete the game
  response = await _client.DeleteAsync(uri);
  Assert.True(response.IsSuccessStatusCode);
}</pre>
			<p>After sending the second move, the result is verified. Finally, the game is deleted. In between all these invocations, results <span class="No-Break">are verified.</span></p>
			<p>Run all the integration tests either using the <strong class="source-inline">dotnet test</strong> .NET CLI command or with Visual Studio Test Explorer, just as before with the unit tests. Just remember not to use integration tests with Live <span class="No-Break">Unit Testing.</span></p>
			<p>With CI, as covered in <a href="B21217_08.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, all these tests should run as well. This can simply be done using <span class="No-Break"><strong class="source-inline">dotnet test</strong></span><span class="No-Break">.</span></p>
			<p>Using .NET Aspire testing for integration tests has the advantage that the server doesn’t need to be started. However, creating<a id="_idIndexMarker804"/> load tests, testing the solution before a switch to the production environment, and directly sending HTTP requests should be done from a test environment as well. We’ll do this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>Creating end-to-end .NET Playwright tests</h1>
			<p><strong class="bold">Microsoft Playwright</strong> (<a href="https://playwright.dev">https://playwright.dev</a>) offers tools and libraries from Microsoft for web tests, which<a id="_idIndexMarker805"/> include tests on <span class="No-Break">web APIs.</span></p>
			<p>Playwright offers several tools (including <a id="_idIndexMarker806"/>generating tests by recording actions with web pages, inspecting web pages, generating selectors, and viewing traces), tests across different platforms, and test libraries for TypeScript, JavaScript, Python, .NET, and Java. With UI automation, Playwright can replace manual testers! Here, we’ll use Playwright to test APIs – <span class="No-Break">using .NET!</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>Creating a test project with Playwright</h2>
			<p>Let’s start creating a test <a id="_idIndexMarker807"/>project with Playwright. Because xUnit has a focus on unit tests and there’s an issue with limiting concurrent test runs, Playwright <a id="_idIndexMarker808"/>supports NUnit and MSTest. Here, we <span class="No-Break">use NUnit:</span></p>
			<pre class="console">
dotnet new nunit -o Codebreaker.GameAPIs.Playwright
cd Codebreaker.GameAPIs.Playwright
dotnet add package Microsoft.Playwright.NUnit
dotnet build</pre>
			<p>Using <strong class="source-inline">dotnet new</strong>, we create a new .NET project, this time using NUnit for the testing framework. <strong class="source-inline">Microsoft.Playwright.NUnit</strong> is the Playwright package for NUnit. After <strong class="source-inline">dotnet build</strong>, a <strong class="source-inline">playwright.ps1</strong> PowerShell script file is created in the <strong class="source-inline">bin/debug/net8.0</strong> folder<a id="_idIndexMarker809"/> that installs <span class="No-Break">required </span><span class="No-Break"><a id="_idIndexMarker810"/></span><span class="No-Break">browsers:</span></p>
			<pre class="console">
pwsh bin/debug/net8.0/playwright.ps1 install</pre>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>Creating a context</h2>
			<p>Playwright has its own API for <a id="_idIndexMarker811"/>creating HTTP requests. This needs to be initialized, together with <span class="No-Break">some housekeeping:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[assembly: Category("SkipWhenLiveUnitTesting")]</strong>
namespace Codebreaker.APIs.PlaywrightTests;
[Parallelizable(ParallelScope.Self)]
public class GamesApiTests : <strong class="bold">PlaywrightTest</strong>
{
  private <strong class="bold">IAPIRequestContext</strong>? _requestContext;</pre>
			<p>Because this test class shouldn’t participate in live unit testing, the <strong class="source-inline">Category</strong> assembly attribute is used to mark the complete assembly with <strong class="source-inline">SkipWhenLiveUnitTesting</strong>. Contrary to xUnit where the <strong class="source-inline">AssemblyTrait</strong> attribute was used, NUnit uses the <span class="No-Break"><strong class="source-inline">Category</strong></span><span class="No-Break"> attribute.</span></p>
			<p>With Playwright, the test class needs to derive from the <strong class="source-inline">PlaywrightTest</strong> base class. The field of type <strong class="source-inline">IAPIRequestContext</strong> is Playwright’s API to create HTTP requests. This field is initialized with the next source <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[SetUp]</strong>
public async Task SetupApiTesting()
{
  ConfigurationBuilder configurationBuilder = new();
  configurationBuilder.SetBasePath(
    Directory.GetCurrentDirectory());
  configurationBuilder.AddJsonFile("appsettings.json");
  var config = configurationBuilder.Build();
  if (!int.TryParse(config["ThinkTimeMS"], out _thinkTimeMS))
  {
    _thinkTimeMS = 1000;
  }
  Dictionary&lt;string, string&gt; headers = new()
  {
    { "Accept", "application/json" }
  };
<strong class="bold">  _requestContext = await Playwright.APIRequest.NewContextAsync(new()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    BaseURL = config["BaseUrl"] ?? "http://localhost",</strong>
<strong class="bold">    ExtraHTTPHeaders = headers</strong>
<strong class="bold">  });</strong>
}</pre>
			<p>The <strong class="source-inline">SetupAPITesting</strong> method is<a id="_idIndexMarker812"/> invoked before every test. With NUnit, such an initialization method needs to be annotated with the <strong class="source-inline">Setup</strong> attribute. To initialize <strong class="source-inline">IAPIRequestContext</strong>, the <strong class="source-inline">Playwright.APIRequest.NewContextAsync</strong> method is invoked. Here, the HTTP headers and the base address for the service are specified. To allow this to be configured with the <strong class="source-inline">appsettings.json</strong> file, the <strong class="source-inline">ConfigurationBuilder</strong> class is used. To simulate a think time, <strong class="source-inline">_thinkTimeMS</strong> is retrieved from the configuration, which is then used before setting every <span class="No-Break">game move.</span></p>
			<p>As the API context is created, it also needs to be <span class="No-Break">disposed of:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[TearDown]</strong>
public async Task TearDownAPITesting()
{
  if (_requestContext != null)
  {
<strong class="bold">    await _requestContext.DisposeAsync();</strong>
  }
}</pre>
			<p>A method that’s invoked after the test has run is annotated with the <strong class="source-inline">TearDown</strong> attribute. The context <a id="_idIndexMarker813"/>needs to be disposed of <span class="No-Break">after use.</span></p>
			<p>After the preparation, let’s create <span class="No-Break">our test.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor259"/>Playing a game with Playwright</h2>
			<p>Tests created with NUnit are<a id="_idIndexMarker814"/> annotated with the <span class="No-Break"><strong class="source-inline">Test</strong></span><span class="No-Break"> attribute:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[Test]</strong>
<strong class="bold">[Repeat(20)]</strong>
public async Task PlayTheGameToWinAsync()
{
  // code removed for brevity
  string playerName = "test";
  (Guid id, string[] colors) = await <strong class="bold">CreateGameAsync</strong>(playerName);
  int moveNumber = 1;
  bool gameEnded = false;
  while (moveNumber &lt; 10 &amp;&amp; !gameEnded)
  {
    await Task.Delay(_thinkTimeMS);
    string[] guesses = [.. Random.Shared.GetItems&lt;string&gt;(colors, 4)];
    gameEnded = await <strong class="bold">SetMoveAsync</strong>(id, playerName, moveNumber++, 
    guesses);
  }
  if (!gameEnded)
  {
    await Task.Delay(_thinkTimeMS);
    string[] correctCodes = await <strong class="bold">GetGameAsync</strong>(id, moveNumber – 1);
    gameEnded = await <strong class="bold">SetMoveAsync</strong>(id, playerName, moveNumber++, 
      correctCodes);
  }
  <strong class="bold">Assert.That</strong>(gameEnded, Is.True);
}</pre>
			<p>NUnit uses the <strong class="source-inline">Test</strong> attribute to specify a test. The <strong class="source-inline">Repeat</strong> attribute can be used to specify the number of runs the test should be repeated running one test. This attribute is useful in generating a longer load on the server. The <strong class="source-inline">PlayTheGameToWin</strong> method defines the flow with the API. First, a new game is created invoking the <strong class="source-inline">CreateGameAsync</strong> method. After <a id="_idIndexMarker815"/>this, for up to 10 moves, moves are placed with the <strong class="source-inline">SetMoveAsync</strong> method. If – with the randomly chosen guesses – the game is already finished, we are done. Otherwise, information about the game is retrieved using <strong class="source-inline">GetGameAsync</strong>, and one more time, <strong class="source-inline">SetMoveAsync</strong> is invoked – this time with the <span class="No-Break">correct move.</span></p>
			<p>One of these invocations is shown in the next code snippet. For the other ones, check the source <span class="No-Break">code repository:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
private async Task&lt;bool&gt; SetMoveAsync(Guid id, string playerName, int moveNumber, string[] guesses)
{
  Dictionary&lt;string, object&gt; request = new()
  {
    ["id"] = id.ToString(),
    ["gameType"] = "Game6x4",
    ["playerName"] = playerName,
    ["moveNumber"] = moveNumber,
    ["guessPegs"] = guesses
  };
<strong class="bold">  </strong><strong class="bold">var response = await _requestContext.PatchAsync($"/games/{id}", new()</strong>
<strong class="bold">  </strong><strong class="bold">{</strong>
<strong class="bold">    DataObject = request</strong>
<strong class="bold">  });</strong>
<strong class="bold">  Assert.That(response.Ok, Is.True);</strong>
  var json = await response.JsonAsync();
  JsonElement results = json.Value.GetProperty("results");
<strong class="bold">  Assert.Multiple(() =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    Assert.That(results.EnumerateArray().Count(), </strong>
<strong class="bold">      Is.LessThanOrEqualTo(4));</strong>
<strong class="bold">    </strong><strong class="bold">Assert.That(results.EnumerateArray().All(x =&gt; x.ToString() is </strong>
<strong class="bold">      "Black" or "White"));</strong>
<strong class="bold">  });</strong>
  bool hasEnded = bool.Parse(json.Value.GetProperty("ended").
<strong class="bold">    </strong>ToString());
  return hasEnded;
}</pre>
			<p>The <strong class="source-inline">SetMoveAsync</strong> method sets a move by using the <strong class="source-inline">IAPIRequestContext</strong> interface’s <strong class="source-inline">PatchAsync</strong> method. Depending<a id="_idIndexMarker816"/> on the HTTP verb used, <strong class="source-inline">GetAsync</strong>, <strong class="source-inline">PostAsync</strong>… methods are available. The HTTP body that is sent to the service is specified with the <strong class="source-inline">DataObject</strong> property. The <strong class="source-inline">PatchAsync</strong> method returns an <strong class="source-inline">IAPIResponse</strong> response. Using this response, the JSON data can be retrieved using the <strong class="source-inline">JsonAsync</strong> method. The <strong class="source-inline">Ok</strong> property that is used with an <strong class="source-inline">Assert</strong> verification returns <strong class="source-inline">true</strong> with a status code in the range of 200 <span class="No-Break">to 299.</span></p>
			<p>With this test in place, we can run the test using <strong class="source-inline">dotnet test</strong> or with Test Explorer within Visual Studio. Just this time, the service needs to <span class="No-Break">be running!</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/>Creating test loads</h1>
			<p>The Playwright tests can now be used to simulate a user load, to run multiple users concurrently. For this, just compute<a id="_idIndexMarker817"/> resources are needed to run the needed load. By reducing the delay time, a few “virtual users” can be used to simulate the load of a bigger number of real users. How long real users are thinking between moves needs to be analyzed monitoring the solution <span class="No-Break">in production.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Reducing the delay between moves, you can use fewer compute resources to simulate a large number of real users with just a few virtual users. There’s also a good reason to increase the delay time for the time used by real users. In <a href="B21217_12.xhtml#_idTextAnchor294"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, we’ll enhance the solution with caching. What if the cached game is not available after a user has a long delay between moves? Does the application still behave correctly? You should also run such <span class="No-Break">integration tests.</span></p>
			<p>Using the <strong class="bold">Microsoft Playwright Testing</strong> cloud service, compute resources are available to test web applications. This <a id="_idIndexMarker818"/>service is – at the time of this writing – not available to test REST APIs. Another service to run load tests is <strong class="bold">Azure Load Testing</strong>. With this tool, you can write <strong class="bold">JMeter</strong> scripts to run the tests or specify web<a id="_idIndexMarker819"/> requests from the web portal. In <a href="B21217_12.xhtml#_idTextAnchor294"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, we’ll use this service to create load<a id="_idIndexMarker820"/> tests to increase the replica count of the games API. This tool not only runs the load but also gives a great report to show information about all resources interacting with <span class="No-Break">the requests.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the tests covered here can also be used with GitHub actions. After building the .NET libraries and applications, <strong class="source-inline">dotnet test</strong> should be triggered to start all the unit tests. After deploying the services to the test environment, integration tests should run before the solution is deployed to the next environment – for example, the staging environment. Automated load tests should make sure the solution is working <span class="No-Break">under load.</span></p>
			<p class="callout">Continuously – for workflows triggered on a timely basis – you should check if new security issues are found in <a id="_idIndexMarker821"/>dependencies, and these dependencies should be updated. For this, with GitHub, just <em class="italic">Dependabot</em> needs to <span class="No-Break">be configured.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor261"/>Summary</h1>
			<p>In this chapter, you learned to create <em class="italic">unit tests</em> to test simple functionality. These tests can be used with Live Unit Testing where test errors immediately show up during development. With unit tests, you learned to use a <em class="italic">mocking library</em> to replace functionality that is not in the scope of the unit test and is covered by a different <span class="No-Break">unit test.</span></p>
			<p>You learned how .NET Aspire makes <em class="italic">integration tests</em> simple using <strong class="source-inline">Aspire.Hosting.Testing</strong>. There’s no need to start the service, as the handler of <strong class="source-inline">HttpClient</strong> is replaced to send requests to the <span class="No-Break">service in-process.</span></p>
			<p>Using Microsoft Playwright, you created an integration test that makes HTTP requests to the API and can be used to test the solution <span class="No-Break">under load.</span></p>
			<p>While you monitored metrics data in this chapter, the next chapter expands on this so that you can create your own metric counts and add logging and distributed tracing to the <span class="No-Break">microservices solution.</span></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor262"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li>Martin Fowler on testing <span class="No-Break">microservices: </span><a href="https://martinfowler.com/articles/microservice-testing"><span class="No-Break">https://martinfowler.com/articles/microservice-testing</span></a></li>
				<li>Live Unit <span class="No-Break">Testing: </span><a href="https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing"><span class="No-Break">https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing</span></a></li>
				<li>Integration <span class="No-Break">tests: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests</span></a></li>
				<li><em class="italic">Testing .NET Aspire </em><span class="No-Break"><em class="italic">apps</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing</span></a></li>
				<li>Microsoft <span class="No-Break">Playwright: </span><a href="https://playwright.dev/"><span class="No-Break">https://playwright.dev/</span></a></li>
				<li><em class="italic">Guide to Secure .NET Development with OWASP Top </em><span class="No-Break"><em class="italic">10</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/"><span class="No-Break">https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/</span></a></li>
				<li><em class="italic">Working with </em><span class="No-Break"><em class="italic">Dependabot</em></span><span class="No-Break">: </span><a href="https://docs.github.com/en/code-security/dependabot/working-with-dependabot"><span class="No-Break">https://docs.github.com/en/code-security/dependabot/working-with-dependabot</span></a></li>
			</ul>
		</div>
	</body></html>