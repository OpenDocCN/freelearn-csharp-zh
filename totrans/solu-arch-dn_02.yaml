- en: '*Chapter 1*: Principles of the Software Development Life Cycle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern digital workplace, the role of the .NET solution architect is
    becoming crucial in the software development life cycle. Having a technology leader
    and a solution creator who can design and build robust and efficient solutions
    is a key factor to delivering successful products.
  prefs: []
  type: TYPE_NORMAL
- en: This book will highlight the fundamentals that you need to know, as a .NET professional
    developer, to become an effective solution architect in this growing and rapidly
    changing field.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept and principles of the **Software Development Life
    Cycle** (**SDLC**) is a great starting point toward planning a software product.
    This chapter aims to explain the notion of SDLC, its phases, and modern methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what the SDLC is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the different SDLC stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with the popular SDLC models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe the SDLC stages and
    explain the difference between the popular SDLC models, such as **Scrum**, **Spiral**,
    and **DevOps**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the software development life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's digital world, every company is looking to deliver a good quality
    software product in a short period, which means the efficiency and the speed of
    the development team are game changers. To achieve this goal, companies must apply
    a set of well-defined activities and structured stages that define the **software
    development life cycle**, also known as the **SDLC**.
  prefs: []
  type: TYPE_NORMAL
- en: The SDLC is a methodology of work and best practices that aim to ease the process
    of software development and make it more efficient, ensuring the final product
    is delivered on time within the project budget and is totally in line with the
    expectations of the client.
  prefs: []
  type: TYPE_NORMAL
- en: There are different variations and models of the SDLC, such as the **Waterfall
    model**, the **Spiral model**, and the **Agile model**. They are popular and widely
    used by most software development organizations. Selecting the right model depends
    mainly on the size of the project and other factors. In the following sections,
    we are going to explore these models in detail to help you decide which model
    is right for your team and the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the six stages that are defined in the SDLC process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The six stages of the SDLC](img/Figure_1.1_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The six stages of the SDLC'
  prefs: []
  type: TYPE_NORMAL
- en: We have just looked at an overview of the software development life cycle and
    its importance. In the next section, we will explore the different stages of the
    SDLC process.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the different SDLC stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What are the main activities in the SDLC?* No matter which model you choose
    to follow to implement your product, there are six different stages that are considered
    as common stages in most of the existing models. However, depending on the model,
    those stages can be executed sequentially or in parallel. By executing this series
    of stages, it is expected that you will be able to avoid typical and costly pitfalls
    and achieve the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Lower costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved overall quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortened production time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent customer satisfaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these stages since understanding them is very important to the
    solution architect, who will be involved with all of them. On the other hand,
    knowing those stages is necessary to organize and facilitate the development of
    the product, as well as to make the entire development process more transparent.
    We'll understand each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Planning and requirement analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the requirements analysis is the first stage, it is the most important
    and fundamental stage in SDLC. This stage starts by identifying the client's stakeholders,
    and then conducting several meetings and workshops to define the expectations
    and gather the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This stage is performed by the business analyst, the project manager, and the
    senior technical members of the team. They conduct meetings and workshops with
    the client to gather all the functional and non-functional requirements, such
    as the purpose of building the product, what problems it will solve, how it will
    improve the efficiency of the work, what it will include in terms of functionalities
    and services, who the target audience or the end user is, identifying the user
    journeys, detailed use cases and test cases, hardware requirements, backup strategies,
    and failover processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Planning** is the process of creating a detailed but high-level plan for
    how and when each module or task in the project will be developed. The aim is
    to identify the tasks and their dependencies, along with the expected output of
    each task. This should be aligned with the client''s expectations, as defined
    in the requirement analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: After this stage, everyone in the team should have a clear view of the scope
    of the project, including its budget, resources, and deadline, as well as possible
    risks and quality assurance needs. This will be shared with the client to align
    them with the execution of the project and to give them better transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different techniques and activities that we usually
    use when executing the requirements analysis phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use cases**: This is an effective technique that is widely used to capture
    user requirements. It allows us to identify the possible flow of each feature
    to be implemented in the system, along with how it will interact with the end
    users. You may be wondering, *how many use cases should I write?* This might sound
    difficult at first, but the simple answer to this question is to make sure that
    you write down as many use cases as possible, to make sure you cover all possible
    actions and functionalities that should be included in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the common sections of a use case:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a. Use Case Name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Summary Description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Actors
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Pre-Conditions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e. Post-Conditions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f. Level
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: g. Stakeholders
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Business Process Modeling Notation** (**BPMN**): This is used globally to
    create graphs that describe and document a business sequence using symbols and
    elements. This technique is recommended if you are implementing business automation
    processes or the product contains business workflows such as approval cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the basic shapes of BPMN diagrams in **Visio**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.2: Basic shapes of BPMN diagrams](img/Figure_1.2_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Basic shapes of BPMN diagrams'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** (**UML**): UML is used to create flowcharts and
    diagrams to visualize and document software components, such as classes and interfaces.
    UML is a good design practice and a very useful technique for creating object-oriented
    software; it helps software developers model and communicate any complex architectural
    software design:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.3: Sample class diagram](img/Figure_1.3_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Sample class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flowchart technique**: This is another graphical representation that''s used
    to describe the different steps of a sequential and logical process flow. In the
    following diagram, we have a sample flowchart for a checkout process. The green
    box is the starting point for when the user attempts to add items to the checkout
    cart before settling the payment and receiving confirmation at the end. The red
    box represents the end of the process; that is, its completion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_1.4_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Sample flowchart diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data flow diagram** (**DFD**): A diagram is worth a thousand words. You can
    use a DFD to visually represent the way data flows through a process or service
    in the system. This diagram is used to identify and describe the input data and
    how it is moving through the system to reach its storage location and form the
    output data. Here is a sample DFD diagram describing the flow of the data in a
    purchase order process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.5: Sample data flow diagram](img/Figure_1.5_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Sample data flow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role Activity Diagrams** (**RAD**): This is a role-oriented representation
    of every possible action in the system. It is used to easily describe and visualize
    the different roles that are involved in executing each process or service in
    the system. The following is a sample role activity diagram describing an ATM
    transaction and showing the steps that are accomplished by each key role:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.6: Sample role activity diagram](img/Figure_1.6_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Sample role activity diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gantt charts**: These are used in project management to assist with planning
    and scheduling projects of all sizes. They provide a visual representation of
    tasks, their delivery dates, and the order and dependencies of each task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This makes the execution plan more simplified and transparent for the client.
    The following is a sample Gantt chart representing a project plan. The tasks are
    grouped based on a specific context and linked through the predecessor column,
    along with the start date and end date:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.7: Sample Gantt chart plan](img/Figure_1.7_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Sample Gantt chart plan'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gap analysis**: This is a technique that helps compare the current actual
    results of the system with what was expected by the client in the early stages
    of the project. It helps denote any missing strategic capability or feature in
    the system. It should also recommend ways you can make improvements that will
    help the client meet their initial targets. The following is a sample template
    that can be used to conduct a gap analysis exercise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.8: Sample gap analysis template](img/Figure_1.8_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Sample gap analysis template'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building prototypes**: Building a mock-up, or a **Minimum Viable Product**
    (**MVP**) model, of the product will give the end users an idea of what the final
    version of the product will look like once all the features have been implemented.
    Using this technique, you can identify any feasibility challenges that you may
    face when you actually implement the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While performing your analysis, consider grouping the requirements into the
    following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional requirements**: These represent all the detailed features and
    functionalities of the system. They are very important for both the development
    team, to find out what to implement, and the client''s stakeholders, to help them
    align on the final results of the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational requirements**: These define the scenarios and the performance
    measures, along with the associated requirements, that are needed for the product
    to operate properly in accordance with the client''s expectations. This includes
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. Establishing critical and desired user performance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Defining constraints
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Establishing the infrastructure needed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Establishing measures of effectiveness
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Technical requirements**: These describe the technical part that must be
    fulfilled to easily and successfully deploy the product and make it functional
    with good performance, as per the client''s expectations. This includes the technology
    that will be used, the technical architecture, the hardware, third-party integration,
    testing, and deployment plans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a couple of things that should be considered during this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main challenges in the requirements gathering phase is that each
    member of the client's stakeholders is seeing the product from his/her point of
    view. For the success of the project, consider listening and capturing all users'
    perspectives and document them in user stories or use cases. This will help you
    identify the full picture of what the product will look like and what it will
    provide as features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first meeting with the client, try to identify the different stakeholders
    and discuss the scope of work to make it clear for all parties. After that, you
    will have to meet with all the stakeholders to collect the detailed requirements.
    During these workshops, make sure you keep all your discussions within the scope
    set forth. This is important to keep the requirements aligned with the business
    needs and to avoid adding functionalities that the product was never expected
    to provide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we've explored the different activities and techniques we can use for
    planning and conducting the requirement analysis workshop, which is essential
    for the success of the project. In the next section, we will learn how to document
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Defining requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step after completing the requirements analysis workshop is to document
    all the information that was gathered in the previous step to define the product
    requirements. Usually, the output result of this activity is the **Software Requirement
    Specification** (**SRS**) document, which consists of all the detailed requirements
    to be designed and developed during all the phases of the project, from the beginning
    to its end, until the desired product is delivered. This SRS becomes the *requirements
    contract* that will be used to develop the product. It will address all the business
    needs of your client.
  prefs: []
  type: TYPE_NORMAL
- en: Once the SRS document has been finalized and reviewed by all the parties involved
    in this project, make sure you send it back to the key stakeholders, or the representatives
    of the key stakeholders, to sign it. The purpose of signing the SRS is to agree
    that the requirements that are presented and defined in the document are clear
    and reflect the business needs, as discussed in the analysis workshop. This formal
    commitment, which is expressed by all parties involved, will play a crucial role
    in the project life cycle to ensure that the project will not struggle from **scope
    creep** during its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: In project management, scope creep (or requirement creep) refers to a situation
    where the client is continuously requesting changes and adding new features to
    the product, even after project kickoff. As a result, the project's scope will
    continue to grow, which will affect the delivery time and the final cost of the
    product. This should not occur and to prevent it, you must make sure that all
    the business needs (that is, the scope of the project) are very detailed and properly
    defined, and that the client has officially committed to the scope of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic outline for an SRS document may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1.1 Purpose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.2 Intended Audience
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3 Intended Use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.4 Scope
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.5 Definitions and Acronyms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall Description
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.1 User Needs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.2 Design and Implementation Constraints
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.3 Assumptions and Dependencies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: System Features
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3.1 Functional Requirements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: External Interface Requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.1 User Interfaces
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.2 Software Interfaces
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.3 Hardware Interfaces
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Non-Functional Requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.1 Performance Requirements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.2 Security Requirements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.3 Software Quality Attributes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feel free to use this outline and modify it as per your needs, but keep in mind
    that this document should describe the functionality the product needs to fulfill,
    along with the technical specifications. Therefore, it should be simple, easy
    to read, and understand by the project stakeholders. In the next section, we are
    going to learn about the architecture design phase.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How will we build the product?* This a crucial question to answer, especially
    if you''re building a complex or large-scale product that will be used by a wide
    range of users.'
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we need to start the **architectural design phase**,
    which consists of converting the software specifications that were defined and
    documented in the previous stages into an abstract design specification plan called
    the **architectural design**.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point of this phase is to go through the SRS document and understand
    every single detail in the requirements. This will help you create the best architecture
    design, which will ensure you deliver a high-quality product. It is the responsibility
    of the technical team to document their design in a **Design Document Specification**
    (**DDS**) document. The intended audience of this document is the designers, software
    developers, and QA testers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this document is to present a comprehensive architectural overview
    and depict all the technical details of the system components. More specifically,
    it should present the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The system architecture, components, classes, their attributes, and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database's design, including the definition of the tables and fields, along
    with the relationships between tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graphical interface design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware or software environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End user environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance requirements and capacity limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This DDS is reviewed by all the key technical stakeholders. Based on various
    factors such as design modularity, performance, security, capacity limitations,
    risks, budget, and time constraints, the best design approach is selected to build
    the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic outline for a DDS document may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1.1 Purpose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.2 Scope
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3 Design Goals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.1 Maintainability
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.2 Optimized Performance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.3 Designed Friendly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: System Overview
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.1 Algorithms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.2 Technologies Used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.3 Architecture Diagrams
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.4 Database Design
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Design Considerations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3.1 Assumptions and Dependencies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.2 General Constraints
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.3 Goals and Guidelines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.4 Development Methods
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Architectural Strategies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.1 Strategy-1 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.2 Strategy-2 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.3 ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: System Architecture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.1 Component-1 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.2 Component-2 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.3 ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Policies and Tactics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.1 Policy/tactic-1 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.2 Policy/tactic-2 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.3 ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Detailed System Design
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 7.1 Module-1 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7.2 Module-2 name or description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7.3 ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Traceability
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Glossary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use this outline to describe your architecture and prepare the DDS document.
    The more you make it clear and detailed, the more you make it easy for the developers
    and testers during the implementation and testing phases. Next, we will explore
    the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: Software development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this stage of SDLC, the software developers start actually developing the
    product. The technology that's used and the programming language, including all
    the technical standards, should be aligned with what was agreed on in the DDS
    document. Keep in mind that the development activities can be accomplished very
    smoothly when the design specifications are detailed and organized in a proper
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Did we get what we want?* Testing the product is a must before launching it
    to the end users. This stage starts alongside the development stage, where the
    developers are responsible for testing what they are developing. At this time,
    it is just basic testing and not enough to say that the product is ready to go
    live.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, an official testing cycle should be conducted once the development
    activities of a specific module or the entire set of features have been completed.
    During this phase, several types of testing should be conducted, every single
    functionality should be tested thoroughly, and the identified defects should be
    reported to the developers to get them fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The quality assurance team can use the test cases that have been documented
    in the SRS, or they can refer to the use cases to test the product. It is recommended
    to run the test cases every time the developers release a new version of the product
    until it reaches a stable version. This is to make sure all the defects that were
    reported in the previous cycles have been closed.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software developers tend to invest the majority of their time in the design
    and development activities of the product, which is good. Despite its importance,
    I have learned from several projects that this is not enough. Setting a strategic
    plan for deployment and maintenance is a key factor for the success of the product.
  prefs: []
  type: TYPE_NORMAL
- en: The focus at this stage is to make the product available for end users so that
    they can start using it. To do so, the product should be deployed to the production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is recommended that you deploy the product in a testing or staging
    environment. This is where the **User Acceptance Testing** (**UAT**) activities
    should be performed. All the issues will be solved and deployed back to this environment.
    Once the product reaches a stable version that is accepted by the client and meets
    all the specifications that were approved in the previous phases, the product
    can be moved to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: User acceptance testing is the final round of testing. It is performed by the
    client to verify that every single functionality provided by the software works,
    and to confirm that all the requirements have been covered. This will ensure that
    the software behaves exactly as the users expect and that they can easily use
    it without any errors or crashes occurring. At the end of the UAT, the client
    should accept the software or request some improvements before moving the software
    to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The maintenance phase starts immediately after the product is fully operational
    in the production environment and signed off by the client. This is a crucial
    step from the client's point of view because it ensures that their product continues
    to perform as designed after its deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Types of maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four types of software maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corrective maintenance**: This is used mainly to rectify some errors and
    faults that are observed while the system is in use or to improve the performance
    of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive maintenance**: This may be needed when the client requests to run
    the software on a new environment such as new hardware or a new operating system.
    Sometimes, clients request to move their products from an on-premises environment
    to **Azure Cloud**. Moreover, it can cover integrating the product with third-party
    software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perfective maintenance**: This type of maintenance focuses on implementing
    new features in the product. These features can be requested by the client to
    accommodate new business cases, or they can be reported by users who have already
    started interacting with the product and noticed some missing functionalities
    that can help facilitate their work and improve the overall experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventive maintenance**: This is commonly used to detect and correct errors
    that may cause software failure in the future. It helps reduce the risk of the
    issues that aren''t significant at this moment but may cause serious problems
    in the future; for example, assuming the clients are expecting to have an increased
    number of users who will start using their product after 2 months, but this load
    cannot be accommodated by the current environment''s specs. In this case, planning
    and updating the software environment in advance to serve the load that will be
    caused by the new users is considered preventive maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following table to understand when and why we should
    apply these maintenance types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Software maintenance types ](img/Figure_1.9_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Software maintenance types'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore the difference between software
    maintenance and warranty.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance versus warranty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People may get confused about maintenance and warranty. A software warranty
    is a formal and legal guarantee that the product will perform properly, as per
    the specifications, for a certain period. It is a promise to fix any errors or
    malfunctions in the system at no cost during the warranty period.
  prefs: []
  type: TYPE_NORMAL
- en: The maintenance agreement is sold to the client for long-term and ongoing maintenance
    activities such as upgrades, updates, or product enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: We have just explained the different stages of the SDLC and highlighted the
    expected output of each stage. In the next section, we are going to provide an
    overview of the popular SDLC models.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored all the SDLC phases, from planning and requirements
    analysis to deploying and sign-off. In the next section, we will get to know the
    most popular SDLC models.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the popular SDLC models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every product requires a suitable approach to developing it. Usually, this decision
    is made based on multiple factors, such as if the requirements are well-documented,
    the requirements are not ambiguous, the project is short, and so on. In this section,
    we will highlight some of the most popular models that are used in software development.
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Waterfall model** is a straightforward and sequential approach to building
    a software product. Each stage of the development cycle should be completed before
    you move on to the next stage and usually, the output of each stage is considered
    to be the input for the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a representation of the different stages of this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: Waterfall stages](img/Figure_1.10_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Waterfall stages'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of the Waterfall model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stages are clearly defined and easy to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stages are well-documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works well for smaller projects where the requirements are well-defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the disadvantages of this model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The working version of the product will be delivered at a late stage of the
    development cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not a good model for complex and ongoing projects since the stakeholders won't
    be able to give their feedback at the early stages of the development process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not a good model when there is a high risk of requirements changing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Agile model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Agile model**, an example of which is Scrum, is one of the most well-known
    development methodologies and is widely adopted by many IT organizations. It is
    also applied to non-tech projects.
  prefs: []
  type: TYPE_NORMAL
- en: The approach of this model is to break the product into cycles or iterations.
    Each iteration lasts for about 2-4 weeks (usually, it shouldn't be a long time).
    At each iteration, the development team should deliver a complete working version
    of the software. The idea is to take the use cases and split them into iterations
    so that you get a functioning part of the product at the end of the iteration.
    In this way, the development team is producing ongoing and incremental releases
    that have been well tested.
  prefs: []
  type: TYPE_NORMAL
- en: This approach helps teams identify and address issues early on. It also involves
    the stakeholders throughout the development process to get their feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a quick representation of the Agile stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Agile stages](img/Figure_1.11_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Agile stages'
  prefs: []
  type: TYPE_NORMAL
- en: The Spiral model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Spiral model** is a combination of the Iterative model and the Waterfall
    sequential model. Usually used for large projects, it provides support for risk
    handling at the early stages of each iteration. With this model, the project passes
    through four phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying objectives by gathering the business requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing risk analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing and evaluating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a diagram depicting the Spiral model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Spiral model](img/Figure_1.12_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Spiral model'
  prefs: []
  type: TYPE_NORMAL
- en: With each iteration, you can build a prototype of the new feature and functionalities
    that will be delivered in this iteration.
  prefs: []
  type: TYPE_NORMAL
- en: These phases are repeated in a *spiral* until the entire product is delivered,
    allowing for multiple rounds of refinement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of the Spiral model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This model provides an early indication of the existence of risks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical high-risk functionalities are developed first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stakeholders are closely tied to the entire development life cycle phases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can see the system in action at early stages with the use of prototypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stakeholders can incorporate early and continuous feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the Spiral model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This model is costly and is not recommended for small projects that have low
    risks in most cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the process is somewhat complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk assessment expertise is required to run this model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DevOps model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a **DevOps model**, the developers and operations teams work together. You
    may be wondering, *well, what does this mean?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the traditional models that we talked about earlier, companies were splitting
    up their resources into teams that handled specific responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: A development team to architect and build the product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operations team to prepare the environment and host the product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test team to prepare the test cases and conduct thorough QA testing and to
    report back to the development team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the DevOps methodology, the developers and operations teams are requested
    to collaborate closely – as one team – in all the stages of the SDLC process.
    A successful DevOps model ensures continuous feedback, accelerates the deployment,
    improves the development process, and automates manual processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a representation showing the different steps in the DevOps model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: DevOps model](img/Figure_1.13_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: DevOps model'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of the DevOps model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast delivery of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better responsiveness to problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better communication and collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More productive team members, with more time to innovate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the DevOps model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps requires culture change and new methods of communication, which is a
    big challenge in a traditional environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a need to upgrade the infrastructure to optimize the process, which
    can be expensive for some companies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast development can lead to critical security shortfalls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's learn how to choose the right model.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When selecting the right SDLC model to build a particular product, it's important
    to remember that each model offers a unique process that may help you overcome
    the challenges that you will encounter during the development cycle. One model
    would never fit every project or every client's needs, which is why you should
    understand these popular models and know when to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right model depends heavily on the factors the project will be executed
    with, such as your current infrastructure, the culture adopted by your team, and
    how the client would like the project to be managed. Certain projects may run
    best with a Waterfall approach, while others would benefit from the flexibility
    of the Agile model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following table, which highlights the main factors
    when it comes to choosing the right model for your product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: How to choose the right SDLC model](img/Figure_1.14_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: How to choose the right SDLC model'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you explored the most popular SDLC models. Each one offers
    a unique methodology that can help you overcome different challenges you may encounter
    in your career. You also learned how to choose the right model for your product.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the definition and the importance of the
    SDLC, as well as how it can help the organization deliver products in an efficient
    way. Then, you learned about the different stages of the SDLC, the most popular
    models, along with their advantages and disadvantages, and how to choose the right
    model for your team.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the different team roles, along with
    their responsibilities, and how they fit into the SDLC process and the team structure.
  prefs: []
  type: TYPE_NORMAL
