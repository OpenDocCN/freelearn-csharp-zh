- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software architect needs to be aware of any technology that can help them
    solve problems faster and ensure they can create better quality software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure helps software architects by providing scalable cloud infrastructure,
    diverse development tools, and services for building, deploying, and managing
    enterprise applications efficiently, with strong support for security and compliance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best software development process model depends on the kind of project,
    team, and budget you have. As a software architect, you need to consider all these
    variables and understand different process models so that you can fit the environment’s
    needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A software architect pays attention to any user or system requirement that can
    influence performance, security, usability, system architecture, structure, organization,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A software architect should verify both functional and non-functional requirements,
    with a special focus on system architecture, performance, scalability, security,
    maintainability, and compatibility in the requirements specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design thinking and design sprint help a software architect to understand user
    needs deeply and rapidly prototyping solutions, ensuring the requirements gathered
    align closely with user expectations and project goals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User stories are good when we want to define functional requirements. They can
    be written quickly and commonly deliver not only the feature required but also
    the acceptance criteria for the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Effective techniques for developing high-performance software include optimizing
    code, using efficient algorithms, leveraging parallel processing, and implementing
    effective memory management.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check that the implementation is correct, a software architect compares it
    with models and prototypes that have already been designed and validated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vertically and horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you can deploy automatically to an already-defined web app or create a
    new one directly using Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To take advantage of available hardware resources by minimizing the time they
    remain idle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code behavior is deterministic, so it is easy to debug. The execution flow mimics
    the flow of sequential code, which means it is easier to design and understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the right order minimizes the number of gestures that are needed to
    fill in a form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it allows for the manipulation of path files in a way that is independent
    of the operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can be used with several .NET Core versions, as well as with several versions
    of the classic .NET Framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Console, .NET Core, .NET (5+), and .NET Standard class libraries; ASP.NET Core,
    test projects, microservices, and much more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No, it is available for several platforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic, manual, and load test plans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, they can – through Azure DevOps feeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To manage requirements and organize the whole development process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Epic work items represent higher-level system subparts that are made up of several
    features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A parent-child relationship.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They can organize projects using the same concept we have in Azure DevOps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both options are great tools for running agile projects. The best option depends
    on your team’s experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintainability gives you the opportunity to deliver the software you designed
    quickly. It also allows you to fix bugs easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cyclomatic complexity is a measure of code complexity based on the control flow
    graph. It detects the number of nodes a method has. The higher the number, the
    worse the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A version control system will guarantee the integrity of your source code, giving
    you the opportunity to analyze the history of each modification that you’ve made.
    It offers the possibility of branching your code development, then merging different
    branches, and much more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A garbage collector is a system in .NET Core, .NET (5+), and .NET Framework
    that monitors your application and detects objects that you aren’t using anymore.
    It disposes of these objects to free up memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `IDisposable` interface is important firstly because it is a good pattern
    for deterministic cleanup. Secondly, it is required in classes that instantiate
    objects that need to be disposed of by the programmer, since the garbage collector
    cannot dispose of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET 8 encapsulates some key design patterns in some of its libraries, such
    as dependency injection and the Builder pattern, in a way that can guarantee safer,
    more reliable code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well-written code is code that any person skilled in that programming language
    can handle, modify, and evolve.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roslyn is the .NET compiler that’s used for code analysis inside Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code analysis is a practice that considers the way code is written to detect
    bad practices before compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code analysis can find problems that happen even with apparently good software,
    such as memory leaks and bad programming practices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roslyn is an engine that provides an API that enables analyzers to inspect your
    code for style, quality, maintainability, design, and other issues. This is done
    during design time, so you can check the mistakes before compiling your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio extensions are tools that have been programmed to run inside Visual
    Studio. These tools can help you out in some cases where the Visual Studio IDE
    doesn’t have the appropriate feature for you to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SonarLint` and the `SonarAnalyzer.CSharp` NuGet package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy-and-paste is an inadequate form of code reuse, since it leads to duplicated
    code, making maintenance and updates more difficult. In fact, there is no safe
    way to discover all duplicates, and then it is very difficult to modify all of
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best approaches for code reuse are creating libraries, using generics, object-oriented
    inheritance, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. You can find components that have already been created in the libraries
    you’ve created before, and then you increase these libraries by creating new components
    that can be reused in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET Standard is a specification that allows compatibility across different
    .NET frameworks, from .NET Framework to Unity. .NET Core is one .NET implementation
    of .NET and is open source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By creating a .NET Standard library, you will be able to use it in different
    .NET implementations, such as .NET Core, .NET, .NET Framework, and Xamarin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can enable code reuse using object-oriented principles (e.g., inheritance,
    encapsulation, abstraction, and polymorphism).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics is a sophisticated implementation that simplifies how objects with
    the same characteristics are treated, by defining a placeholder that will be replaced
    with the specific type at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The answer to this question is well explained by Immo Landwerth on the .NET
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET versions 5 and above need to be thought of as the
    foundation for sharing code moving forward.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The challenges related to refactoring include ensuring that changes don’t introduce
    bugs, maintaining the functionality and performance of code, and improving readability
    and maintainability without altering the external behavior of software components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are good solutions to common problems in software development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While design patterns give you code implementation for typical problems we face
    in development, design principles help you select the best options when it comes
    to implementing the software architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Builder pattern will help you generate sophisticated objects without the
    need to define them in the class you are going to use them in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Factory pattern is useful in situations where you have multiple kinds of
    objects from the same abstraction, and you don’t know which of them needs to be
    created at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Singleton pattern is useful when you need a class that has only one instance
    during the software’s execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Command pattern is used when you need to execute a command that will affect
    the behavior of an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Publisher/Subscriber pattern is useful when you need to provide information
    about an object to a group of other objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DI pattern is useful if you want to implement the Inversion of Control principle.
    Instead of creating instances of the objects that the component depends on, you
    just need to define their dependencies, declare their interfaces, and enable the
    reception of the objects by injection. Typically, you can do this by using the
    constructor of the class to receive the objects, tagging some class properties
    to receive the objects, or defining an interface with a method to inject all the
    necessary components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changes in the language used by experts and changes in the meaning of words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context mapping is the main tool used to coordinate the development of a separate
    bounded context, helping to define and manage interactions between different contexts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; the whole communication passes through the entity, that is, the aggregate
    root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a single aggregate root in a part-subpart hierarchy to ensure the consistency
    of and enforce rules across all elements of the aggregate, acting as the main
    entry point for external interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just one, since repositories are aggregate-centric.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application layer manipulates repository interfaces. Repository implementations
    are registered in the dependency injection engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To coordinate operations on several aggregates in single transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specifications for updates and queries are usually quite different, especially
    in simple **CRUD** systems. The reason for its strongest form is mainly the optimization
    of query response times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dependency injection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; a serious impact analysis must be performed so that we can adopt it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is the approach of delivering value to the end user continuously. To
    do this with success, continuous integration, continuous delivery, and continuous
    feedback must be undertaken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) allows you to check the quality of the
    software you are delivering every single time you commit a change. You can implement
    this by turning on this feature in Azure DevOps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous delivery** (**CD**) allows you to deploy a solution once you are
    sure that all the quality checks have passed the tests you designed. Azure DevOps
    helps you with that by providing you with relevant tools.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you can have DevOps separately and then enable **CI** later. You can also
    have CI enabled without **CD** enabled. Your team and process need to be ready
    and attentive for this to happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might confuse **CI** with a CD process, which could cause damage to your
    production environment. In the worst-case scenario, for example, a feature that
    is not ready might be deployed, causing disruptions at inconvenient times for
    your customers, or you could even suffer a bad collateral effect due to an incorrect
    fix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A multi-stage environment protects production from bad releases when fully automated
    build and deployment pipelines are in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automated tests anticipate bugs and bad behaviors in preview scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull requests allow code reviews before commits are made in the master branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; pull requests can help you in any development approach where you have Git
    as your source control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous feedback is the adoption of tools in the DevOps life cycle that enable
    fast feedback when it comes to performance, usability, and other aspects of the
    application you are developing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The build pipeline will let you run tasks to build and test your application,
    while the release pipeline will give you the opportunity to define how the application
    will be deployed in each scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application Insights is a helpful tool for monitoring the health of the system
    you’ve deployed, which makes it a fantastic continuous feedback tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test and Feedback is a tool that allows stakeholders to analyze the software
    you are developing and enables a connection with Azure DevOps to open tasks and
    even bugs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main goal of service design thinking is to enhance user experience and satisfaction
    by optimizing the service’s usability, efficiency, and effectiveness in meeting
    user needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure DevOps is a tool that can automate the whole application life cycle when
    it comes to software development. However, many software architects tend to also
    use GitHub to do so, and Microsoft has developed the platform a lot in the last
    few years.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because most of the tests must be repeated after any software change occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the probability of the same error occurring in a unit test and its associated
    application code is very low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[Theory]` is used when the test method defines several tests, while `[Fact]`
    is used when the test method defines just one test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Setup`, `Returns`, and `ReturnsAsync`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, with `ReturnAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; it depends on the complexity of the user interface and how often it changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET Core pipeline isn’t executed, but inputs are passed directly to
    controllers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usage of the `Microsoft.AspNetCore.Mvc.Testing` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usage of the `AngleSharp` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaaS is a good option when you are migrating from an on-premises solution or
    if you have an infrastructure team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PaaS is the best option for fast and safe software delivery in systems where
    the team is focused on software development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the solution you intend to deliver is provided by a well-known player, such
    as a SaaS, you should consider using it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serverless is an option when you are building a new system if you don’t have
    people who specialize in infrastructure and you don’t want to worry about it for
    scaling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure SQL Database can be up in minutes, and you will have all the power of
    Microsoft SQL Server afterward. Moreover, Microsoft will handle the database server
    infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure provides a set of services called Azure Cognitive Services. These services
    provide solutions for vision, speech, language, search, and knowledge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a hybrid scenario, you have the flexibility to decide on the best solution
    for each part of your system, while respecting the solution’s development path
    in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modularity of code and deployment modularity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Other important advantages include handling the development team and the
    whole **CI**/**CD** cycle well, and the possibility of mixing heterogeneous technologies
    easily and effectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A library that helps us implement resilient communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve installed Docker on your development machine, you can develop, debug,
    and deploy Dockerized .NET applications. You can also add Docker images to Service
    Fabric applications that are handled with Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Orchestrators are software that manages microservices and nodes in microservice
    clusters. Azure supports two relevant orchestrators: Azure Kubernetes Service
    and Azure Service Fabric.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it decouples the actors that take place in a communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A message broker. It takes care of service-to-service communication and events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same message can be received several times because the sender doesn’t receive
    confirmation of reception before its time-out period, so the sender resends the
    message again. Therefore, the effect of receiving a single message once or several
    times must be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is a distributed in-memory storage based on key-value pairs and supports
    distributed queuing. Its most well-known usage is for distributed caching, but
    it can be used as an alternative to relational databases, since it is able to
    persist data to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, they are. Most of this chapter’s sections are dedicated to explaining why.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main weaknesses of NoSQL databases are their consistency and transactions,
    while their main advantage is performance, especially when it comes to handling
    distributed writes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventual, Consistency Prefix, Session, Bounded Staleness, and Strong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, they are not efficient in a distributed environment. GUID-based strings
    perform better, since their uniqueness is automatic and doesn’t require synchronization
    operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OwnsMany` and `OwnsOne`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, they can. Once you use `SelectMany`, indices can be used to search for
    nested objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of database-dependent providers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either by calling them `Id` or by decorating them with the `Key` attribute.
    This can also be done with a fluent configuration approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `MaxLength` and `MinLength` attributes, or with their equivalent fluent
    configuration methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With something similar to `builder.Entity<Package>().HasIndex(m => m.Name);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `Add-Migration` and `Update-Database` in the package-manager console, or
    with `dotnet ef migrations` `add` and `dotnet` `ef` `database` `update` in the
    operating system console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, but you can forcefully include them with the `Include` `LINQ` clause or
    by using the `UseLazyLoadingProxies` option when configuring your `DbContext`.
    With Include, related entities are loaded together with the main entities, while
    with `UseLazyLoadingProxies`, related entities are lazy-loaded; that is, they
    are loaded as soon as they are required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it is, thanks to the `Select LINQ` clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling `context.Database.Migrate()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because using queues are the only way to avoid time-consuming blocking calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `import` declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the standard `Duration` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Version compatibility and interoperability while maintaining good performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Better horizontal scalability, and support for the Publisher/Subscriber pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For two reasons. The operation is very fast, and the insertion in the first
    queue of a communication path must necessarily be a blocking operation. At least
    one blocking operation is always necessary to store the message in some permanent
    storage (usually a queue), so it can be recovered if the ongoing processing might
    fail for some reason.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the following XML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where `Protos\file1.proto` and `Protos\file2.proto` must be replaced with the
    actual paths to the `ProtoBuf` files within our project. Moreover, the `GrpcServices`
    attribute must be set to `"Server"` or `"Client"`, depending on whether the `proto`
    file describes a server or not.
  prefs: []
  type: TYPE_NORMAL
- en: With `channel.BasicPublish(…)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `channel.WaitForConfirmsOrDie(timeout)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No, since this would violate the principle that a service reaction to a request
    must depend on the request itself, and not on other messages/requests that had
    previously been exchanged with the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, implementing a service with a custom communication protocol is generally
    not good practice because it compromises interoperability, increases development
    and maintenance complexity, and isolates the service from widely used standards
    and tools. Standard protocols such as HTTP/REST, `gRPC`, and others are preferred
    for their broad support, ease of integration, and community backing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it can. The primary action of a POST must be creation, but deletion can
    be performed as a side effect. The HTTP verb to use is determined by the virtual
    table named in the URL (in our case, a POST, since the operation is an addition),
    but other operations can be performed on other virtual tables that are not mentioned
    in the URL as side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three; they are `Base64` encoding of the header, `Base64` encoding of the body,
    and the signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the request body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ApiController` attribute sets up some default behaviors that help in the
    implementation of REST services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ProducesResponseType` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using API controllers, they are declared with the `Route` and `Http<verb>`
    attributes. When using a minimal API, they are declared in the first argument
    of `MapGet`, `MapPost`, `…` `Map{Http verb}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adding something like `builder.Services.AddHttpClient<MyProxy>()` in the
    dependency injection part of the host configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions is an Azure PaaS component that allows you to implement FaaS
    solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can program Azure Functions in different languages, such as C#, F#, PHP,
    Python, and Node.js. You can also create functions using the Azure portal and
    Visual Studio Code. Additional stacks can be used by using custom handlers: [https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers](https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two plan options in Azure Functions. The first plan is the Consumption
    Plan, where you are charged according to the amount you use. The second plan is
    the App Service Plan, where you share your App Service resources with the function’s
    needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process of deploying functions in Visual Studio is the same as in web app
    deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are lots of ways we can trigger Azure Functions, such as using Blob Storage,
    Cosmos DB, Event Grid, Event Hubs, HTTP, Microsoft Graph Events, Queue Storage,
    Service Bus, Timer, and Webhooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Functions v1 needs the .NET Framework Engine, whereas v2 needs .NET Core
    2.2, and v3 needs .NET Core 3.1 and .NET 5-6\. v4 is the current version for .NET
    6, 7, and 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution of every Azure function can be monitored by Application Insights.
    Here, you can check the time it took to process, resource usage, errors, and exceptions
    that happened in each function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are functions that will let us write stateful workflows, managing the state
    behind the scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typical middleware modules scaffolded by Visual Studio in an ASP.NET Core project
    include a developer exception page, request routing, static file serving, HTTPS
    redirection, authentication, and authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False. Several tag helpers can be invoked on the same tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ModelState.IsValid`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@RenderBody()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use `@RenderSection("Scripts", required: false)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `return View("viewname", ViewModel)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three providers are included in ASP.NET Core, but they must be configured. If
    different providers are needed, they must be implemented by the developers and
    added to the providers list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, `ViewModels` are not the only way for controllers to communicate with views
    in ASP.NET Core. Controllers can also use `ViewData`, `ViewData`, and `TempData`
    to pass data to views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API gateways work as interfaces for API microservices, while frontends take
    care of building web pages’ HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Robust web servers optimize the whole request/response handling and ensure the
    needed level of security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because they have an impact on performance that is usually unacceptable for
    high-traffic microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When transactions are quite fast and the probability of collision between transactions
    is low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A better decoupling of the aggregates and commands methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a W3C standard: the assembly of a virtual machine running in W3C-compliant
    browsers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A web UI where dynamic HTML is created in the browser itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting a page based on the current browser URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Blazor component with routes attached to it. For this reason, the Blazor router
    can select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the .NET namespace of a Blazor component class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A local service that takes care of storing and handling all form-related information,
    such as validation errors and changes in HTML inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either `OnInitialized` or `OnInitializedAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Callbacks and services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blazor’s way to interact with JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting a reference to a component or HTML element instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are needed to dispatch communication to pods, since a pod has no stable
    IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes offers higher-level entities called Ingresses that are built on top
    of services, empowering clusters with all the advanced capabilities offered by
    a web server, such as routing HTTP/HTTPS URLs from outside the cluster to internal
    service URLs inside the cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm charts are a way to organize the templating and installation of complex
    Kubernetes applications that contain several `.yaml` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, with the `---` separator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes detects container faults through liveness and readiness probes that
    check the health and availability of containers, ensuring they run as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because Pods, having no stable location, can’t rely on the storage of the node
    where they are currently running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StatefulSet` is assumed to have state and achieve write/update parallelism
    through sharding, while `ReplicaSet` has no state, so as it is indistinguishable,
    it can achieve parallelism by splitting the load.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is because it doesn’t support TCP/IP communications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio’s recommended tool to debug Kubernetes applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it works with any Kubernetes cluster that has been configured as the default
    cluster in the local Kubectl installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With something like `minikube` `image` `load` `grpcmicroservice:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is enough to start Minikube, and Minikube’s start procedure will do it for
    you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
