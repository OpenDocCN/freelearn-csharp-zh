- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: User Interface and Menus
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面和菜单
- en: The collection of visual information and components laid out across the screen
    of a video game is known as the **User Interface** (**UI**). An intuitive UI and
    menu system creates an opportunity for your players to have quality experiences.
    This interactivity and direct influence of a game’s playable outcome is called
    **player agency**.Designing for this agency is crucial to creating an intuitive
    and successful interactive experience within your game world. This agency allows
    players to interact with the game’s narrative and engage within that game space
    accurately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏屏幕上排列的视觉信息和组件集合被称为**用户界面**（**UI**）。一个直观的用户界面和菜单系统为玩家提供了优质体验的机会。这种互动性和游戏可玩结果的直接影响被称为**玩家代理**。为这种代理设计是创建游戏世界中直观且成功的交互体验的关键。这种代理允许玩家与游戏的叙事互动，并准确地在游戏空间中参与。
- en: User interfaces and menu systems throughout your game also provide player affordances.
    Player affordances are the communication with your player about how to use an
    object within the game, conveying controls, and navigating your game world from
    start to finish.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您游戏中的用户界面和菜单系统也提供了玩家便利性。玩家便利性是与玩家沟通如何在游戏中使用对象，传达控制方式，并从游戏开始到结束导航游戏世界的方式。
- en: Game menu systems specifically give the player agency over the various modes
    of gameplay. These gameplay modes signal to a player when to start and the options
    and actions available before, during, and after gameplay. Getting the player into
    the game is important, but during the game, your interface may be more important
    to the experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏菜单系统特别赋予玩家对各种游戏模式的控制权。这些游戏模式向玩家表明何时开始，以及游戏开始前、进行中和结束后可用的选项和动作。让玩家进入游戏很重要，但在游戏过程中，您的界面可能对体验更为重要。
- en: 'There are four forms of user interface: **Diegetic**, **Non-diegetic**, **Spatial**,
    and **Meta**. Spending some time breaking down these UI definitions will give
    a better understanding of how we will be using them in our project. Then we will
    look into scripting each of them to give an idea of the proper way to implement
    them.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的四种形式是：**叙事性**、**非叙事性**、**空间性**和**元**。花一些时间来分解这些UI定义将更好地理解我们将在项目中如何使用它们。然后我们将查看每个的脚本编写，以提供一个正确实现它们的想法。
- en: This chapter will cover the following topics.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题。
- en: Defining UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义UI
- en: UI elements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI元素
- en: UI in our project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们项目中的UI
- en: Unity Canvas system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity画布系统
- en: Unity UI objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity UI对象
- en: Let’s begin by explaining the user interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下用户界面。
- en: User interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: The need for a user interface is a double-edged sword. You will need to put
    user interface features in place for the experience to move forward, but this
    can also easily distract the player from that experience when not done correctly.
    There isn’t always a mechanic that can be made to teach players how to interact
    with the world they are playing in. This can break immersion, which isn’t always
    bad, but there needs to be an understanding of how one can break this immersion
    without ruining the experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的需求是一把双刃剑。您需要设置用户界面功能以使体验继续进行，但如果不正确执行，这也可能很容易让玩家从该体验中分心。并不是总有一种机制可以用来教玩家如何与他们正在玩的世界互动。这可能会破坏沉浸感，这并不总是坏事，但需要理解如何在不破坏体验的情况下打破这种沉浸感。
- en: We’re going to talk about the four forms of UI, which are broken down across
    two defined spaces, **Narrative** and **Internal**. **Narrative** lends itself
    to UI-driven storytelling, whereas **Internal** is functional UI within the game
    world itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论UI的四种形式，这些形式被分为两个定义空间，**叙事**和**内部**。**叙事**适合UI驱动的叙事，而**内部**是游戏世界本身的功能性UI。
- en: When reading through the various forms of the user interface, realize that these
    are not exhaustive explanations and will need to be understood more as a tool
    to help design the right UI for the experience you wish to provide.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读用户界面的各种形式时，请记住，这些并不是详尽的解释，而更多的是作为一个工具来帮助设计适合您希望提供的体验的正确UI。
- en: While we are going through **Diegetic**, **Non-diegetic**, **Spatial**, and
    **Meta** UI forms, we will be explaining how the UI fits into a simple 2x2 diagram
    of Internal and Narrative functions. The 2x2 grid below, in *Figure 8.1*, is a
    visual representation of how to integrate a holistic view of the UI and incorporate
    it throughout the overall gameplay experience. In the following paragraphs, each
    section header of the UI forms will also be supplemented with an “if this, then
    that” double-answer response.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正在通过 **叙事界面**、**非叙事界面**、**空间界面** 和 **元界面** 形式时，我们将解释 UI 如何适应一个简单的 2x2 图表，该图表表示内部和叙事功能。下面的
    2x2 网格，在 *图 8.1* 中，是 UI 整体视图的视觉表示，以及如何将其整合到整个游戏体验中。在接下来的段落中，UI 形式的每个部分标题也将补充一个“如果这样，那么就那样”的双答案响应。
- en: '![Diagram  Description automatically generated](img/B17304_08_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图解 描述自动生成](img/B17304_08_01.png)'
- en: 'Figure 8.1: 2x2 user interface design'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：2x2 用户界面设计
- en: Answering with **Yes** or **No** on both Narrative and Internal on the 2x2 grid
    above helps us to understand what UI form is needed. Follow along as we describe
    each of these four forms in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 2x2 网格上用 **是** 或 **否** 回答叙事和内部问题有助于我们了解需要哪种 UI 形式。随着我们详细描述这四种形式，请跟随我们的描述。
- en: Diegetic – Narrative Yes, Internal Yes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 叙事 – 叙事是，内部是
- en: A user interface that blends internal and external spaces is called **Diegetic**.
    This type of interface commits to not breaking the immersion while providing the
    information to the player that they need to understand the internal game space.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将内部和外部空间融合的用户界面被称为 **叙事界面**。这种类型的界面承诺在提供玩家所需信息以理解内部游戏空间的同时，不会打破沉浸感。
- en: You may want to convey the location the player needs to go, but you want to
    give a sense of difficulty. You may, during the story, give the player a direction
    and provide a compass. When you press a button to pull up the compass, this is
    giving the player the information without breaking out of the internal space.
    We will consider this compass when discussing the rest of the four types to see
    if we can convert it into a different type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要传达玩家需要前往的位置，但同时又想给人一种困难的感觉。在故事中，你可以给玩家一个方向并提供指南针。当你按下按钮拉起指南针时，这就是在不脱离内部空间的情况下给玩家提供信息。我们将在讨论剩余的四种类型时考虑这个指南针，看看我们能否将其转换为另一种类型。
- en: Now that we have explained the Diegetic UI form type, let us take a look at
    a great example that is within a published game. When explaining Diegetic UI,
    there is an eerie game that comes to mind, called *Dead Space*. Electronic Arts
    (EA)’s Visceral Games studio (dissolved and merged into EA Vancouver and EA Montreal;
    October 17, 2017) created a gritty, survival cosmic horror video game that drew
    inspiration from other works of horror such as *Resident Evil 4* and the *Silent
    Hill* series.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了叙事界面形式，让我们来看一个在已发布游戏中存在的优秀例子。当解释叙事界面时，会想到一个令人毛骨悚然的电子游戏，名为 *Dead Space*。艺电（Electronic
    Arts，简称 EA）的 Visceral Games 工作室（于 2017 年 10 月 17 日解散并合并到 EA Vancouver 和 EA Montreal）创造了一款粗糙、生存宇宙恐怖视频游戏，该游戏从其他恐怖作品如
    *Resident Evil 4* 和 *Silent Hill* 系列中汲取灵感。
- en: The game designers of Visceral Games needed to think of ways the player could
    look dead center on the screen and focus their attention there as much as possible.
    That way the player could simultaneously witness the abominations, jump scares,
    gore, and horrors of *Dead Space’s* world, and navigate the narrative of Isaac
    Clarke. Isaac is the main character of *Dead Space* and the unfortunate spaceship
    systems engineer that is thrown into a variety of unfortunate situations over
    a span of years.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Visceral Games 的游戏设计师需要考虑玩家如何能够将视线集中在屏幕的正中央，并尽可能多地集中注意力在那里。这样，玩家可以同时见证 *Dead
    Space* 世界的丑陋、跳跃惊吓、血腥和恐怖，并导航 Isaac Clarke 的叙事。Isaac 是 *Dead Space* 的主角，也是那位不幸的太空船系统工程师，在多年的时间里被卷入各种不幸的情况。
- en: How can you do that in a role-playing game where you have a lot of information
    that your player needs to know? You put that important player information on the
    character itself. When done this way, the information becomes 3^(rd) person on
    the screen, allowing the player to still retain a view of the screen and its environment.
    Isaac’s health indicators are on a health bar that is integrated into the lit-up
    nodes on his spine, seen in *Figure 8.2*, and the stasis meter is incorporated
    on his right shoulder blade as a partial glowing circular ring. Now the player
    doesn’t need to look away from the main character to know his health and character
    statistics.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个角色扮演游戏中，你如何做到让玩家需要知道的大量信息得以呈现？你将重要的玩家信息放在角色本身上。这样做的话，信息就会变成屏幕上的第三人称视角，让玩家仍然能够看到屏幕及其环境。艾萨克的健康指示器位于他脊柱上发光的节点上，如*图8.2*所示，而静止计则集成在他的右肩胛骨上，呈现为一个部分发光的圆形环。现在玩家不需要从主要角色上转移视线就能知道他的健康和角色统计数据。
- en: '![A picture containing metalware, chain  Description automatically generated](img/B17304_08_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![包含金属器具、链条的图片，描述自动生成](img/B17304_08_02.png)'
- en: 'Figure 8.2: Dead Space health visualization'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.2*：死亡空间健康可视化'
- en: Non-diegetic – Narrative No, Internal No
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非叙事式 – 叙事否，内部否
- en: Looking at the grid, you may think, how can you have any UI that isn’t in the
    narrative or the game space? This is a great question and it’s more common than
    you think! Virtually every menu system and, unintegrated **heads-up display**
    (**HUD**) is non-diegetic, as seen in *Figure 8.3*. Pressing play in a game isn’t
    part of the game narrative, but it’s part of the game and an important part too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看着网格，你可能想知道，如何拥有不在叙事或游戏空间中的UI？这是一个很好的问题，而且比你想象的更常见！几乎每个菜单系统和不集成**抬头显示**（**HUD**）都是非叙事式的，如*图8.3*所示。在游戏中按下播放键不是游戏叙事的一部分，但它确实是游戏的一部分，也是重要的一部分。
- en: '![A car driving on a road  Description automatically generated with medium
    confidence](img/B17304_08_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![一辆汽车在道路上行驶，描述自动生成，中等置信度](img/B17304_08_03.png)'
- en: 'Figure 8.3: Forza non-diegetic HUD'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3*：Forza非叙事式HUD'
- en: Let’s think about the compass and see if we can convert it into a non-diegetic
    UI element. Its purpose is to help the player know the direction of where to go.
    Can we do this without the game characters being aware of it? You could make a
    minimap that shows the direction the player needs to go and shape it like a compass
    on the screen. With this being defined, we’ve decided that yes, you can convert
    the compass into a non-diegetic form. There are so many examples of a non-diegetic
    UI element in production, but one of our favorites is in a racing game UI. *Forza*
    has a clean UI that shows the gear you’re in, the speed, and the location in the
    world to help you along your path on the minimap.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下罗盘，看看我们能否将其转换为一个非叙事式UI元素。它的目的是帮助玩家知道去哪里的方向。我们能否在不让游戏角色意识到它的情况下做到这一点？你可以制作一个迷你地图，显示玩家需要去的方向，并在屏幕上将其形状设计成罗盘。既然已经定义了这一点，我们就决定可以将罗盘转换成非叙事式形式。在生产的许多例子中，非叙事式UI元素有很多，但我们最喜欢的一个是在赛车游戏UI中。*Forza*有一个干净的UI，显示了你的档位、速度和在世界中的位置，以帮助你沿着迷你地图上的路径前进。
- en: Spatial – Narrative No, Internal Yes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间 – 叙事否，内部是
- en: Here is a fun case for user interface design. Spatial UIs exist in the game
    world, but the characters inside the game are not aware of their existence.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的用户界面设计案例。空间UI存在于游戏世界中，但游戏内的角色并没有意识到它们的存在。
- en: Taking another look at the compass, maybe we want it to be spatial. How can
    we convey the direction we need to go without the character being aware of it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看罗盘，也许我们希望它具有空间感。我们如何在角色没有意识到的情况下传达我们需要去的方向？
- en: There could be a projected compass on the ground that shows the direction of
    the next waypoint or goal. It only shows up when you look topdown from your character
    so it doesn’t always disturb the gameplay in general. One of the best spatial
    UI elements in a game is in *Path of Exile*. The items that are on the ground
    have a colored spire to denote certain item types and the names of the items give
    a description of what the item may be, as seen in *Figure 8.4* below.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 地面上可能有一个投影罗盘，显示下一个航点或目标的方向。它只有在玩家从角色上方俯视时才会出现，所以它不会总是干扰游戏的整体玩法。游戏中最好的空间UI元素之一在*暗黑破坏神*中。地面上放置的物品有一个彩色尖塔来表示特定的物品类型，而物品的名称则描述了该物品可能是什么，如*图8.4*所示。
- en: '![A screenshot of a video game  Description automatically generated with medium
    confidence](img/B17304_08_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图，自动生成描述，中等置信度](img/B17304_08_04.png)'
- en: 'Figure 8.4: Path of Exile spatial item names'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：流放之路空间物品名称
- en: The character in the game doesn’t know about this screen but it is in the game’s
    space as you need to move your mouse over it to view it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的角色并不知道这个屏幕，但它位于游戏空间中，因为你需要将鼠标移过它才能查看。
- en: Meta – Narrative Yes, Internal No
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元 – 叙事是，内部否
- en: Meta is interesting for a user interface as we can’t have the interface in the
    game world, but the character needs to have knowledge of it. If we look at our
    compass example and try to transform it into the meta space, we will need to think
    a bit harder. Breaking the fourth wall by interacting directly with the user while
    the character is aware of the scenario is rather unique. Let’s give it a try.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面来说，元界面很有趣，因为我们不能在游戏世界中拥有界面，但角色需要了解它。如果我们看看我们的指南针示例，并尝试将其转换到元空间，我们需要更深入地思考。在角色意识到场景的同时直接与用户互动，打破第四面墙是相当独特的。让我们试试看。
- en: The outer area of the screen houses the compass degrees and follows the character’s
    rotations. The character looks at their compass and you can see that the direction
    is or isn’t close to the correct location due to the screen UI. This is cumbersome
    and doesn’t feel intuitive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的外围区域包含指南针度数，并跟随角色的旋转。角色查看他们的指南针，你可以看到由于屏幕UI的原因，方向是否接近正确的位置。这很麻烦，并且感觉不直观。
- en: A much better example of meta is in first-person shooter games. Have you ever
    played an FPS game and were hit? There is a splatter of blood and a red vignette
    around the screen. The character knows they were hit and generally makes a sound;
    the meta UI lets the player know the possibility of death if they keep getting
    hit. The camera showing the player isn’t the player’s vision, and we know this,
    but our rendering with a bloody vignette that darkens and intensifies gives the
    sense of dramatic life-ending anxiety.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称射击游戏中，元界面的一个更好的例子。你有没有玩过FPS游戏并且被击中过？屏幕周围会出现血迹和红色的边缘。角色知道他们被击中了，通常会发出声音；元UI让玩家知道如果他们继续被击中，就有死亡的可能性。显示给玩家的摄像头不是玩家的视角，我们知道这一点，但我们的渲染通过带有血迹的边缘，使其变暗并增强，给人一种戏剧性的生命终结焦虑感。
- en: '![A screenshot of a video game  Description automatically generated](img/B17304_08_05.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图，自动生成描述](img/B17304_08_05.png)'
- en: 'Figure 8.5: Call of Duty Meta screen UI'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：使命召唤元界面UI
- en: What we have just discussed are the design methodologies to understand what
    your UI elements are displaying for the user. As shown, there are several ways
    to break down a UI element. We will now go over some common terminology in the
    UI development for games.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的是设计方法，以了解您的UI元素向用户显示什么。如图所示，有几种方法可以分解UI元素。现在我们将讨论游戏UI开发中的一些常见术语。
- en: UI elements
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI元素
- en: 'There are common UI elements that are used during any game. Whether it’s the
    main menu, inventory system, health representation, or a spatial item interaction
    system, they all serve a single purpose: give the player as much information as
    possible without directly affecting their immersion too much that it pulls them
    away from the experience.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中都会使用到一些常见的UI元素。无论是主菜单、库存系统、生命值表示，还是空间物品交互系统，它们都只有一个目的：尽可能多地给玩家提供信息，同时不会过多地影响他们的沉浸感，以免让他们从体验中脱离出来。
- en: In the next few sections, we will cover the topics previously mentioned. These
    are generalized terms for the user interface and are not supposed to be set in
    concrete. These are design thoughts following common topics that currently exist
    for the UI portion of game development.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将涵盖之前提到的主题。这些是用户界面的通用术语，不应被固定化。这些是针对游戏开发用户界面部分现有常见主题的设计思路。
- en: Use these sections as references for design when thinking about your game projects
    in the future. We will begin with the **main menu**; coincidentally, this is the
    menu that will appear first for your players.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑未来的游戏项目时，将这些部分用作设计参考。我们将从**主菜单**开始；巧合的是，这是玩家首先看到的菜单。
- en: Main menu
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主菜单
- en: When a game menu pops up for the first time after loading the game up, this
    is the first time the developers get to create an emotional response. Is your
    game a horror game? The font and imagery should reflect this. There are many ways
    to set up a menu. Do you need a news screen to pop up before you pick your characters
    when logging in? Does the main menu jump right into gameplay when you press play?
    Are there several layers of menus that need to be there as the game is focused
    on menu systems? All of these are legitimate questions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏加载完成后第一次弹出游戏菜单时，这是开发者第一次有机会创造情感反应。你的游戏是恐怖游戏吗？字体和图像应该反映这一点。有许多设置菜单的方法。在你选择角色登录之前，你需要一个新闻屏幕弹出吗？当你按下播放时，主菜单直接进入游戏吗？游戏是否专注于菜单系统，需要多层菜单？所有这些问题都是合法的。
- en: The simplest way to go about building a menu system is to ensure that it isn’t
    difficult to play the game with its intended difficulty, or connection if it’s
    a multiplayer game. We tend to call this “**low barrier of entry**.” If a player
    wants to come in and press play without looking into the settings, they should
    be able to do so. This includes looking at the recommended specs and building
    the system to allow for that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 建立菜单系统的最简单方法就是确保它不会使游戏难以以预期的难度或连接性进行游戏，如果它是多人游戏的话。我们倾向于称之为“**低门槛**”。如果玩家想进来按下播放而不查看设置，他们应该能够做到。这包括查看推荐规格并构建系统以允许这样做。
- en: The player’s experience shouldn’t rely on them understanding what their system
    can handle. A good way to think about this is the game experience from arcade
    machines or consoles. PlayStation and Xbox require game developers to ensure framerates
    are high, so the experience is of a good standard. This should also be the case
    for PC as well as mobile.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的体验不应该依赖于他们理解自己的系统可以处理什么。思考这个问题的好方法是从街机或游戏机中的游戏体验。PlayStation和Xbox要求游戏开发者确保帧率要高，以保证体验达到良好标准。PC和移动设备也应该如此。
- en: Inventory systems
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背包系统
- en: There are other forms of menu systems that are similar in nature but not part
    of the initial player experience. **Role-playing games** (**RPGs**) often use
    an inventory system that shows what you have stored on your character in the form
    of armor or equipment. This can be used as a bottlenecking system to force players
    back to the city to sell or upgrade their equipment. It can also be used to help
    define the experience as the character couldn’t possibly hold 30 sets of armor
    and 200 weapons on them at once while roaming the world. This is an attempt to
    straddle the line between breaking immersion and keeping realism in check.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类似但不是初始玩家体验一部分的菜单系统形式。**角色扮演游戏**（**RPG**）通常使用一种背包系统，以盔甲或装备的形式显示你存储在角色上的物品。这可以用作瓶颈系统，迫使玩家回到城市出售或升级他们的装备。它也可以用来帮助定义体验，因为角色在漫游世界时不可能同时携带30套盔甲和200件武器。这是试图在打破沉浸感和保持现实感之间找到平衡。
- en: Some interesting forms of inventory systems are quest logs and achievements.
    A quest log is just an inventory of quests that can be completed or removed by
    finishing the required quest. Achievements are the opposite in that you gain them
    by performing certain tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有趣的背包系统形式是任务日志和成就。任务日志只是可以完成或通过完成所需任务删除的任务清单。成就则相反，通过执行某些任务来获得。
- en: Health representation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健康表示
- en: Health can be represented by “lives left,” as in Super Mario Bros. It can also
    be represented by how many more times you can be hit, such as in the Dead Space
    reference above. It may not even be represented by a specific value, but an amount
    of blood on the screen, as seen in Call of Duty. Even more abstract is not health,
    but a timer left on the screen of how much time you have left to complete a quest
    or level. All of these can be considered health representations and can look different
    on the screen using any of the forms we previously spoke about.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 健康可以表示为“剩余生命”，例如在《超级马里奥兄弟》中。它也可以表示为你可以被击中的次数，例如在上述《死亡空间》的参考中。它甚至可能不是通过一个特定的值来表示，而是通过屏幕上的血量，如在《使命召唤》中看到的那样。更抽象的是，不是健康，而是一个屏幕上剩余时间的计时器，显示你完成任务或关卡还有多少时间。所有这些都可以被认为是健康表示，并且可以在屏幕上使用我们之前提到的任何形式来显示。
- en: Item interaction system
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物品交互系统
- en: There may be items in your game with which your player needs some help to know
    that they are interactable. There are two main ways to work through this and both
    of them can be spatial. Sometimes this will be non-diegetic, which we will go
    over next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，可能会有一些物品需要玩家获得一些帮助才能知道它们是可以交互的。有两种主要的方法来处理这个问题，它们都可以是空间性的。有时这将是非叙事的，我们将在下一节中讨论。
- en: One way is to make a tooltip on the screen that is only available when your
    mouse or crosshair is covering the item. This is usually when you want something
    to be contextual to that specific item. This can be done when the tooltip is in
    the screen space — this means it’s always the same size and is more akin to a
    floating window. This is the same concept that was shown in the Path of Exile
    image above. You may also see instead a floating icon around or above the item
    under the context. This could be for the player to know that they can interact
    with something. These are similar in nature, but screen space denotes that it’s
    not part of the world and the character isn’t aware of it either. This makes it
    non-diegetic. The second example of the icon floating above the item is spatial
    as it shows itself in the world, but the character doesn’t know about it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在屏幕上创建一个仅在鼠标或十字准星覆盖物品时才可用的工具提示。这通常是在你希望某物与特定物品相关时。这可以在工具提示在屏幕空间中完成时进行——这意味着它始终是相同的大小，更像是浮动窗口。这与上面
    Path of Exile 图像中展示的概念相同。你也许还会看到在物品周围或上方浮动的一个图标。这可能是为了让玩家知道他们可以与之交互。这些在本质上相似，但屏幕空间表示它不是世界的一部分，角色也不知道它的存在。这使得它是非叙事的。第二个例子是图标在物品上方浮动，它是空间性的，因为它在世界中显示出来，但角色并不知道它的存在。
- en: UI in our project
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们项目中的 UI
- en: Our project is not user interface-heavy. We purposefully wanted to keep it as
    light as possible to create a tight immersion within the environment. To keep
    it as light as possible, we have three major portions to talk about.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目不是用户界面密集型的。我们故意想要尽可能保持轻量，以在环境中创造紧密的沉浸感。为了尽可能保持轻量，我们有三大部分要讨论。
- en: Main menu
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单
- en: Escape menu
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出菜单
- en: Spatial UI
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间 UI
- en: To begin, we will talk about the main menu and how that starts our immersion
    into the game right from the beginning.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论主菜单以及它是如何从游戏开始时就让我们沉浸其中的。
- en: Main menu
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主菜单
- en: Our menu is going to be primarily a non-diegetic menu system. From the start
    of the application, Myvari will be in the woods looking at her book. The menu
    will be off to the left with the **Title**, **Play**, and **Quit**options available
    to select. When the **Play** button is pressed, there will be a camera movement
    with a small cinematic animation that triggers the beginning of the game. Possession
    of our character happens right after Myvari starts her idle animation after the
    cinematic animation finishes from the **Play** button press. This system gives
    a feel that it is within the world as the camera is not fading to black for a
    scene transition, but it is not part of the world or part of the narrative. Myvari
    doesn’t know the menu system exists and it’s not affecting the game world in any
    way, therefore it is non-diegetic. The screenshot we are showing below in *Figure
    8.6* is a mock-up to illustrate the logic without the need for all the art. This
    is a common tactic when working within game development. In further sections we
    will go over the implementation of the actual UI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主菜单将主要是一个非叙事菜单系统。从应用程序开始，Myvari 将在森林中看着她的书。菜单将位于左侧，提供**标题**、**播放**和**退出**选项供选择。当按下**播放**按钮时，会有相机移动和一个小型电影动画，触发游戏的开始。从**播放**按钮按下后，
    cinematic 动画结束，Myvari 开始她的空闲动画，这时我们的角色就会获得控制权。这个系统给人一种感觉，就像是在这个世界中一样，因为相机在场景转换时不会变黑，但它既不是世界的一部分，也不是叙事的一部分。Myvari
    并不知道菜单系统的存在，它也没有以任何方式影响游戏世界，因此它是非叙事的。下面我们展示的 *图 8.6* 是一个没有所有艺术作品的草稿，以说明逻辑。这在游戏开发中是一个常见的策略。在接下来的章节中，我们将讨论实际
    UI 的实现。
- en: '![A picture containing text, grass, outdoor  Description automatically generated](img/B17304_08_06.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、草地、户外场景的图片，描述自动生成](img/B17304_08_06.png)'
- en: 'Figure 8.6: Main menu mock-up'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：主菜单草稿
- en: We like the concept of a UI that allows the player to feel like the game they
    are playing is immediately immersive. When you hit **Play**, the menu should go
    away and the camera should move into a position where you then take control of
    the main character. The goal is to not have a loading screen. Keep the players
    involved as much as possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢这种UI的概念，它能让玩家感觉他们正在玩的游戏立即就能沉浸其中。当你点击**播放**时，菜单应该消失，摄像机应该移动到一个位置，然后你就可以控制主要角色。目标是不要有加载屏幕。尽可能让玩家保持参与。
- en: Escape menu
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逃脱菜单
- en: 'To give as much immersion as possible, we wanted to utilize one of the core
    features of our character’s personality: exploration. To us, this means that we
    needed the book on her right hip to be a feature of her passage through the game
    experience. We also knew that we would need to have in-game settings somewhere,
    which we could also place in the book. This is spatial in that it breaks the immersion
    of the game as the settings aren’t part of the narrative. When Myvari flips to
    the **Options** portion of the journal, this will feel disjointed enough but will
    be familiar to someone who is used to playing games. This portion will be spatial
    as it is part of the world but Myvari doesn’t know that it’s a menu to close the
    game. When she is on the left pane, this is all story-driven elements that are
    part of the world and both Myvari and the player are using it as hints to move
    forward in the game. In this case, we will call this portion of the menu diegetic
    as we will be selecting the art to fit as though someone from Myvari’s race made
    this book.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能提供沉浸感，我们希望利用我们角色个性的核心特征之一：探索。对我们来说，这意味着我们需要让她的右腰上的书成为她游戏体验中行进的一部分。我们也知道我们需要在游戏中设置某个地方，我们也可以把设置放在书中。这是空间性的，因为它打破了游戏的沉浸感，因为设置不是叙事的一部分。当Myvari翻到日记本的**选项**部分时，这会感觉足够不连贯，但对于习惯于玩游戏的人来说却是熟悉的。这部分将是空间性的，因为它属于世界的一部分，但Myvari不知道这是一个关闭游戏的菜单。当她处于左侧面板时，这些都是故事驱动的元素，是世界的组成部分，Myvari和玩家都在用它作为前进游戏的线索。在这种情况下，我们将称这个菜单部分为“存在”，因为我们将会选择艺术作品，好像来自Myvari种族的人制作了这本书。
- en: How we will do this is through a small cinematic animation of Myvari pulling
    the book out and it opening to the journal, which will have small updates depending
    on where you have been in the game. The book has art to look as though she didn’t
    write in it, but another person of her race did. The book is old and has led her
    to this cave. There will be markers with small notes to help guide the player
    if need be. This is a linear progression game, so we will update this at every
    milestone or sub-milestone. If she is standing still, we will also have her get
    the book out and read from it, which will bring the immersion of the book being
    her journal into a closer convergence to keep the experience as congruent as possible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何实现这一点是通过一个小型的电影动画，Myvari拉出书并打开到日记本，这会根据你在游戏中的位置进行小更新。这本书有艺术作品看起来像她没有在其中写东西，但她的种族中的另一个人写了。这本书很旧，并引导她来到这个洞穴。将会有带有小笔记的标记来帮助玩家指引，如果需要的话。这是一个线性进程游戏，所以我们将在每个里程碑或子里程碑时更新这个内容。如果她站着不动，我们也会让她拿出书并阅读，这将使书的沉浸感与她的日记更紧密地结合，以尽可能保持体验的一致性。
- en: '![A picture containing grass, outdoor  Description automatically generated](img/B17304_08_07.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![包含草地、户外描述自动生成](img/B17304_08_07.png)'
- en: 'Figure 8.7: Journal UI mock-up'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：日记本UI原型
- en: The journal is an interesting menu system for us. It’s acting as an escape menu
    as well as giving the players more clues about the engagement that Myvari is working
    through. *Figure 8.7* above shows our mock-up, which we use to visualize what
    it may look like. This helps us understand where to put the camera, as well as
    helping the animator know how to animate her grabbing her book out of its holster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 日记本对我们来说是一个有趣的菜单系统。它不仅作为逃脱菜单，还向玩家提供了更多关于Myvari正在经历的游戏参与度的线索。*图8.7* 上方展示了我们的原型，我们用它来可视化它可能的样子。这有助于我们了解如何放置摄像机，同时也帮助动画师知道如何动画她从枪套中拿出书。
- en: Spatial tooltip
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间提示
- en: When designing feedback to the player, there are quite a few options as we saw
    with the compass problem. In our case, we thought about how we could best show
    the ability to interact with the environment. We settled on a spatial system.
    This system will be in the form of what is called a tooltip. This tooltip is a
    small icon that is in the world space above the GameObject that is interactable
    by the player. We chose to use a spatial system to keep the item within the world
    for spatial context to the UI element; however, we did not want it to be part
    of the narrative. This allows us to use a slight bit of immersion breaking to
    be in stark contrast to the rest of the game. When the player sees the tooltip
    pop up, it will be interesting. We can use this system throughout the entire vertical
    slice! We are creating a simple key item example, which will be an icon that floats
    in the game world, but Myvari will not be privy to its existence. This allows
    us to make a robust system; if we choose to use a different button for a different
    type of interaction, we can just change out the icon for the correct button to
    press.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计玩家反馈时，有相当多的选项，正如我们在指南针问题中看到的那样。在我们的案例中，我们考虑了如何最好地展示与环境交互的能力。我们决定采用一个空间系统。这个系统将以所谓的工具提示的形式出现。这个工具提示是一个小图标，位于玩家可交互的GameObject之上的世界空间中。我们选择使用空间系统来保持项目在世界的空间内，以便为UI元素提供空间上下文；然而，我们不想让它成为叙事的一部分。这允许我们使用一点沉浸感破坏，与游戏的其他部分形成鲜明对比。当玩家看到工具提示弹出时，这将很有趣。我们可以在整个垂直切片中使用这个系统！我们正在创建一个简单的关键物品示例，它将在游戏世界中漂浮，但Myvari不会知道它的存在。这允许我们创建一个健壮的系统；如果我们选择为不同类型的交互使用不同的按钮，我们只需更换正确的按钮图标即可。
- en: '![](img/B17304_08_08.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B17304_08_08.png](img/B17304_08_08.png)'
- en: 'Figure 8.8: Spatial UI mock-up'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：空间UI原型
- en: This very pink circle is just an item placeholder to be our indicator later
    on. With it being bright pink, there is no mistaking it for a “completed” item
    later on!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常粉红色的圆圈只是一个物品占位符，稍后将成为我们的指示器。由于它是明亮的粉红色，所以后来不会将其误认为是“完成”的物品！
- en: We have gone over the definition of the user interface and explained our project’s
    use of UI. Now we need to take some time to go over how we actually made the UI
    work.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了用户界面的定义，并解释了我们项目对UI的使用。现在我们需要花些时间来回顾我们是如何使UI工作的。
- en: Unity UI
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity UI
- en: 'Before we dive fully into our implementation of UI in our project, we will
    go over the basics of Unity’s UI system. This will give you an understanding of
    what items we are using in our systems as well as a couple that we aren’t using
    that you could use in your projects later. There are two main parts to make this
    work:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全深入到我们项目中的UI实现之前，我们将回顾Unity UI系统的基本知识。这将让你了解我们在系统中使用哪些项目，以及一些我们未使用但在你以后的项目中可以使用的项目。使这个系统工作有两个主要部分：
- en: Unity Canvas system
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity画布系统
- en: Unity UI components
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity UI组件
- en: We need to go over the Unity Canvas system in a bit of detail first before we
    start implementing the UI with code so you have a good foundation of its inner
    workings before trying to add art to it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用代码实现UI之前，我们需要先详细了解一下Unity的画布系统，这样你就可以在尝试添加艺术之前对其内部工作有一个良好的基础。
- en: Unity canvas system
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity画布系统
- en: Unity places its UI inside a canvas system. This is a GameObject that has several
    components on it by default. To make a canvas, right-click in the **Hierarchy**
    window and choose **UI**, then **Canvas**. This can be seen in *Figure 8.9* below.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Unity将其UI放置在画布系统中。这是一个具有默认多个组件的GameObject。要创建画布，在**层次结构**窗口中右键单击，然后选择**UI**，然后**画布**。这可以在下面的*图8.9*中看到。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_09.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_08_09.png)'
- en: 'Figure 8.9: Menu to create a canvas'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：创建画布的菜单
- en: When this gets created, you will have a `Canvas` GameObject and an `Event System`
    GameObject. If there is already an `Event System` on that level where it was created,
    only the `Canvas` would be created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个创建完成后，你将有一个`Canvas` GameObject和一个`Event System` GameObject。如果在该级别上已经有一个`Event
    System`，则只会创建`Canvas`。
- en: The `Canvas` has a `Rect` transform, and it also has a `Canvas` component, a
    `Canvas Scalar` component, and a `Graphic Raycaster` component. We will look into
    each of these in light detail to explain their purpose.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`有一个`Rect`变换，它还有一个`Canvas`组件、一个`Canvas Scalar`组件和一个`Graphic Raycaster`组件。我们将详细探讨每个组件，以解释它们的作用。'
- en: There is also an `Event System` that could’ve been created if there wasn’t another
    in the scene hierarchy already. This will house the messaging for input to the
    UI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景层次结构中已经存在另一个，则还可以创建一个`Event System`。这将容纳对UI的输入消息。
- en: If you are using the new input system, please make sure to click on this and
    replace the `StandaloneInputModule` with the `InputSystemUIInputModule`. This
    allows the event system to know which input systems are working in the project.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用新的输入系统，请确保点击此处，并将`StandaloneInputModule`替换为`InputSystemUIInputModule`。这允许事件系统知道项目中正在使用哪些输入系统。
- en: Why don’t we take a look at the components individually, starting with the `Rect`
    transform, `Canvas`, `Canvas Scalar`, and then the `Graphic Raycaster` in more
    detail?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不逐个查看组件，从`Rect`变换、`Canvas`、`Canvas Scalar`开始，然后更详细地查看`Graphic Raycaster`呢？
- en: Rect transform
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rect变换
- en: The canvas itself has a `Rect` transform, but it’s meant to be a parent of the
    other UI, so its `Rect` transform needs to be read-only. Right-click on the canvas
    and choose **UI** > **Button** to make a child button inside the canvas so we
    can look at the `Rect` transform clearly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 画布本身有一个`Rect`变换，但它的目的是作为其他UI的父级，所以它的`Rect`变换需要是只读的。在画布上右键点击，选择**UI** > **Button**，在画布内创建一个子按钮，这样我们就可以清楚地查看`Rect`变换。
- en: Below in *Figure 8.10*, you can see the button’s `Rect` transform component
    in the inspector where you may be expecting the regular `Transform` component.
    We still have the position, rotation, and scale options in our `Rect` transform,
    but we also have the width, height, pivot, and anchors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的*图8.10*中，你可以在检查器中看到按钮的`Rect`变换组件，你可能期望看到常规的`Transform`组件。我们仍然在我们的`Rect`变换中有位置、旋转和缩放选项，但我们还有宽度、高度、中心点和锚点。
- en: When working with UI, it’s best to leave the scale as *1*, *1*, *1*. This allows
    the canvas to set the scaling if needed. The safest way to make size changes is
    through the width and height values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当与UI一起工作时，最好将缩放设置为*1*、*1*、*1*。这允许画布在需要时设置缩放。通过宽度值和高度值进行尺寸更改是最安全的。
- en: Rotation will rotate from the pivot location, which is a small blue circle and
    can be changed from the values of the **Pivot** fields.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转将从中心点位置旋转，这是一个小蓝色圆圈，可以通过**中心点**字段的值进行更改。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_08_10.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，中等置信度](img/B17304_08_10.png)'
- en: 'Figure 8.10: Rect Transform component'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：Rect变换组件
- en: The position fields will set the local location of the GameObject. When you
    need to make changes to the size of the UI element, it’s best to use the `Rect`
    tool instead of scaling. Inside the scene view, there is a `Rect` tool button,
    shown in *Figure 8.11* below, which will allow you to change the size of the UI,
    which will update the position, width, and height.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 位置字段将设置GameObject的本地位置。当你需要更改UI元素的尺寸时，最好使用`Rect`工具而不是缩放。在场景视图中，有一个`Rect`工具按钮，如图8.11所示，它允许你更改UI的尺寸，这将更新位置、宽度和高度。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_11.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，描述自动生成](img/B17304_08_11.png)'
- en: 'Figure 8.11: Rect tool used on the selected button'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：在所选按钮上使用的Rect工具
- en: The pivot of the UI element is an *x* or *y* value that is a normalized value
    to the width and height of the element. This means that a value of 0.5 in both
    will place the pivot at 50% of the width and height, or local center, of the item.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: UI元素的中心点是一个*x*或*y*值，它是元素宽度和高度的归一化值。这意味着两个值都是0.5将中心点放置在宽度和高度的50%，即项目的本地中心。
- en: The last unique item is the anchors. The anchors are designed to allow the UI
    elements to remain in place, even if the canvas scales. This could happen if you
    have multiple devices or resolution changes. There are **Anchors** options of
    **Min**/**Max**, which will set each anchor to its corresponding normalized value
    similar to the pivot location. Doing this by hand sometimes takes a little while,
    so we have a handy tool to make it easier. If you click on the top left of the
    **Rect Transform** it opens up a useful tool that allows you to select from common
    anchor options.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个独特的项目是锚点。锚点设计用来允许UI元素保持位置不变，即使画布缩放。这可能会发生在你有多个设备或分辨率变化的情况下。有**锚点**选项**最小值**/**最大值**，这将设置每个锚点为其相应的归一化值，类似于中心点位置。手动这样做有时需要一点时间，所以我们有一个方便的工具来简化这个过程。如果你点击**Rect变换**的左上角，它将打开一个有用的工具，允许你从常见的锚点选项中进行选择。
- en: This looks like *Figure 8.12* below.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来就像下面的**图8.12**。
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B17304_08_12.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，置信度低](img/B17304_08_12.png)'
- en: 'Figure 8.12: Anchor common options'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：锚点常用选项
- en: 'What this tool allows you to do is select the most common anchor positions
    for the GameObject you are working on. There are two primary types of anchoring:
    **Positional** and **Stretched**. The 3x3 grid in the middle of this tool will
    make it so the UI in question will be anchored and not stretch or change when
    the screen resolution is different from what you have built for. This is a good
    option only if the resolution will not change drastically. The second type is
    stretching, which is located around the right and bottom edges. If your game is
    built with 1920x1080 resolution and the player chooses to play on an ultra-wide
    monitor, you may want to allow for some scaling on certain UI elements. If it
    is a 4k monitor with a 16:9 aspect ratio, then you will need to think about stretching
    all your elements; otherwise, the UI will appear very small.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具允许你选择你正在工作的GameObject最常用的锚点位置。主要有两种锚定类型：**位置**和**拉伸**。这个工具中间的3x3网格将确保相关的UI在屏幕分辨率不同于你构建的分辨率时不会拉伸或改变。只有在分辨率不会发生剧烈变化的情况下，这是一个好选项。第二种类型是拉伸，位于右侧和底部边缘。如果你的游戏是以1920x1080分辨率构建的，并且玩家选择在超宽显示器上玩游戏，你可能希望允许某些UI元素进行一些缩放。如果是一个16:9宽高比的4k显示器，那么你可能需要考虑拉伸所有元素；否则，UI将显得非常小。
- en: Anchoring is a bit of an art form. The tricks above that were outlined will
    treat you well. The best way to go about properly anchoring is by playing the
    game in the editor and resizing it. It may not give you every scenario, but it
    will give you a good perspective on how the UI elements are reacting to a resolution
    change.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 锚定是一种艺术形式。上面概述的技巧会对你大有裨益。正确锚定的最佳方法是使用编辑器玩游戏并调整大小。它可能不会给你每一个场景，但它会给你一个很好的视角，了解UI元素如何对分辨率变化做出反应。
- en: Canvas component
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布组件
- en: The canvas component only houses a few options, but they are crucial! In *Figure
    8.13* below you can see the sections that we will go through.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 画布组件只包含一些选项，但它们至关重要！在下面的**图8.13**中，你可以看到我们将要讨论的部分。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_13.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，描述自动生成](img/B17304_08_13.png)'
- en: 'Figure 8.13: Canvas component'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：画布组件
- en: 'We have **Render Mode** with a few options below it: **Pixel Perfect**, **Sort
    Order**, and **Target Display**. After that, we have **Additional Shader Channels**.
    Let’s look at these options one by one.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有**渲染模式**，下面有一些选项：**像素完美**、**排序顺序**和**目标显示**。之后，我们有**附加着色器通道**。让我们逐一查看这些选项。
- en: Render Mode
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染模式
- en: 'There are three render modes that can be chosen: **Screen Space - Overlay**,
    **Screen Space - Camera**, and **World Space**. They each have a certain type
    of use and games can have multiple canvases in their world that fit their needs.
    As we go through them, think about how we might use them in our current project.
    After we describe all the features of the Unity UI we will get into the implementation.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择三种渲染模式：**屏幕空间 - 覆盖**、**屏幕空间 - 摄像头**和**世界空间**。它们各自有特定的用途，游戏可以在其世界中拥有多个画布，以满足其需求。随着我们逐一介绍它们，考虑一下我们如何在我们的当前项目中使用它们。在描述完所有Unity
    UI的功能后，我们将进入实现阶段。
- en: Screen Space - Overlay
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 屏幕空间 - 覆盖
- en: This is a common canvas rendering mode. What is nice about this mode is that
    it can be used within its own scene and loaded additively to your game for runtime.
    This allows you to make mobile menus that are separate from the PC monitor menu
    systems with ease. This works very well; however, it should only be used with
    simple UI. If you are going to be dragging around UI elements or animating them
    from a mouse context, such as rollover, then it’s best to use the **Camera** option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的画布渲染模式。这个模式的好处是它可以在自己的场景中使用，并在运行时以增量方式加载到你的游戏中。这使得你可以轻松地创建与PC监视器菜单系统分开的移动菜单。这非常有效；然而，它应该只用于简单的UI。如果你打算拖动UI元素或从鼠标上下文（如悬停）动画它们，那么最好使用**摄像头**选项。
- en: A good example of this type of canvas is the main menu or a HUD, which isn’t
    very interactive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型画布的一个好例子是主菜单或HUD，它不太具有交互性。
- en: Screen Space - Camera
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 屏幕空间 - 摄像头
- en: As with the overlay option, this is a great mode if you are going to be making
    functions that utilize the `EventTrigger` class. You also cannot instantiate this
    like overlay mode. It must already be in the scene and have a camera that it will
    be referencing for bounds. It will attach itself to the camera, so if you make
    this change and it disappears on you, double-click your camera and it will be
    right there!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与叠加选项一样，如果你将要制作利用`EventTrigger`类的函数，这是一个非常好的模式。你也不能像叠加模式那样实例化它。它必须已经在场景中，并且有一个它将引用边界范围的相机。它将附着到相机上，所以如果你做出这个更改而它从你那里消失，双击你的相机，它就会出现在那里！
- en: A great example of this mode is something similar to an ARPG where you need
    to drag and drop equipment to equip the items.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的绝佳例子类似于ARPG，你需要拖放装备来装备物品。
- en: World Space
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 世界空间
- en: This rendering mode for the canvas is used when you need a menu that is in the
    world space. The best way to explain this is through best use cases. You would
    use this when you want chat bubbles over your character’s head in space. You could
    want landmarks in UI that are selectable, which could potentially use a **World
    Space** canvas. It would be best if that landmark had text or another form of
    UI attached to it as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个位于世界空间的菜单时，这种画布渲染模式会被使用。最好的解释方式是通过最佳用例。当你想在空间中角色的头上显示聊天气泡时，你会使用它。你可能希望在UI中可选择的标志，这可能会使用一个**世界空间**画布。如果这个标志有文本或其他形式的UI附加到它上，那就更好了。
- en: Render Mode options
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染模式选项
- en: 'Underneath the **Render Mode** are three options:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在**渲染模式**下方有三个选项：
- en: '**Pixel Perfect** – This is only used if you are working within 2D space where
    the UI needs to be exact to every pixel. It helps develop the UI to the constraints
    of the pixels in creation.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素完美** – 仅在你在2D空间内工作，且UI需要精确到每个像素时使用。它有助于将UI开发到创建中的像素限制。'
- en: '**Sort Order** – By default the sort order is set to work through the hierarchy
    under the **Canvas**. The higher up an item is on the hierarchy, the sooner it
    will be rendered. You can overwrite this by typing in a value. Lower values will
    render first. Higher values are sent lower down the list. This is helpful if you
    want a single item to always be at the back. Just put `999` in for the value and
    it will always be rendered after the others regardless of the hierarchy order.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序顺序** – 默认排序顺序设置为在**画布**下的层次结构中工作。一个项目在层次结构中的位置越高，它将被渲染得越早。你可以通过输入一个值来覆盖它。较低的值将首先渲染。较高的值将被发送到列表的较低位置。如果你想让一个单独的项目始终在后面，只需将值设置为`999`，它将始终在其他人之后渲染，无论层次结构顺序如何。'
- en: '**Target Display** – Should be used if you need another UI for a second display.
    You can set this up to display only on the second display. This can be used for
    up to eight displays. The use case for this would be for games similar to racing
    games, which commonly use three curved monitors.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标显示** – 如果你需要第二个显示器的另一个UI，则应使用此选项。你可以将其设置为仅在第二个显示器上显示。这可以用于多达八个显示器。这种用例可能是类似于赛车游戏的游戏，这些游戏通常使用三个弯曲的显示器。'
- en: Additional Shader Channels
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的着色器通道
- en: When in overlay, the UI generally will not include normals, tangents, and so
    on. Use dropdown shown in *Figure 8.14* to select them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于叠加模式时，UI通常不会包括法线、切线等。使用*图8.14*中显示的下拉菜单来选择它们。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_14.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_08_14.png)'
- en: 'Figure 8.14: Additional Shader Channel options'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：额外的着色器通道选项
- en: These would need to be selected if you specifically need them in your UI elements.
    Otherwise, leave it on **Nothing**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在UI元素中特别需要它们，则需要选择这些。否则，请将其保留为**无**。
- en: Canvas Scaler
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布缩放器
- en: This component is in charge of making sure the scaling is correct for all the
    child UI objects under the GameObject with this component attached. It is not
    only in charge of scaling the UI itself, but also the font sizes and any image
    borders attached to images.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件负责确保具有此组件附加的GameObject下的所有子UI对象的比例正确。它不仅负责缩放UI本身，还负责字体大小和任何附加到图像上的图像边框。
- en: There are several unique parameters with the Canvas Scaler component. They are
    placed in the window depending on which of the UI scale modes are chosen. There
    are three UI scale modes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas Scaler组件有几个独特的参数。它们根据选择的UI缩放模式放置在窗口中。有三种UI缩放模式。
- en: Constant Pixel Size
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常数像素大小
- en: This is used when you need to keep the pixel size the same regardless of the
    screen changing. The use case for this is if you know that you will be playing
    this game with a single resolution. If your game can be scaled at all, then you
    must work through dynamically setting the scale factor and ensuring your pixels
    per unit are the same as well. These parameters are seen in *Figure 8.15* below.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要保持像素大小不变，而屏幕发生变化时，会用到这个选项。这个用例是如果你知道你将使用单一分辨率来玩游戏。如果你的游戏可以缩放，那么你必须通过动态设置缩放因子，并确保每单位像素相同来工作。这些参数在下面的*图8.15*中可以看到。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_15.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序自动生成描述](img/B17304_08_15.png)'
- en: 'Figure 8.15: Canvas Scaler component Constant Pixel Size UI Scale Mode'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：画布缩放组件常量像素大小UI缩放模式
- en: If you think that your game will be adjusted at any point then consider working
    with the **Scale With Screen Size** option.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你的游戏在任何时候都会进行调整，那么请考虑使用**根据屏幕大小缩放**选项。
- en: Scale With Screen Size
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根据屏幕大小缩放
- en: When you choose **Scale With Screen Size**, there are different parameters that
    pop up than with the **Constant Pixel Size** option. As seen below in *Figure
    8.16*, we have **Reference Resolution**, **Screen Match Mode**, the **Match**
    slider, and **Reference Pixels Per Unit**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择**根据屏幕大小缩放**时，与**常量像素大小**选项相比，会出现不同的参数。如下面的*图8.16*所示，我们有**参考分辨率**、**屏幕匹配模式**、**匹配**滑块和**每单位参考像素**。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_16.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序自动生成描述](img/B17304_08_16.png)'
- en: 'Figure 8.16: Canvas Scaler component Scale With Screen Size mode'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：画布缩放组件根据屏幕大小缩放模式
- en: '**Reference Resolution** – The resolution you’d expect the most-used screen
    resolution to be. From there it will scale down or up from the different resolutions
    the players may be playing from.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考分辨率** – 你期望最常用的屏幕分辨率。从那里，它将根据玩家可能使用的不同分辨率进行缩放或放大。'
- en: '**Screen Match Mode** – Contains three options:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕匹配模式** – 包含三个选项：'
- en: '**Match Width Or Height** – This will allow the application to match a blend
    of width to height when it’s changed. This works pretty well overall until you
    hit ultra-wide monitors. This is also the only option where the **Match** slider
    is available to change. With the next two options, this slider will not be visible.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配宽度和高度** – 当宽度和高度发生变化时，这将允许应用程序匹配宽度和高度的混合比例。整体来说，这个选项效果不错，直到你遇到超宽显示器。这也是唯一一个**匹配**滑块可用的选项。在接下来的两个选项中，这个滑块将不可见。'
- en: '**Expand** – This means that the canvas will scale up but will be no smaller
    than the reference resolution. This is excellent as it expands width or height
    needs. This option is by far my favorite to work with.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展** – 这意味着画布会放大，但不会小于参考分辨率。这对于扩展宽度和高度的需求来说非常出色。这是我最喜欢的选项之一。'
- en: '**Shrink** – This option is just like the **Expand** option but it will scale
    down and not get larger than the **Reference Resolution**. This works well, but
    you have to work from a large resolution from the start.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小** – 这个选项与**扩展**选项类似，但它会缩小而不是超过**参考分辨率**。这效果很好，但你必须从高分辨率开始工作。'
- en: '**Reference Pixels Per Unit** – This option refers to how many pixels are in
    a centimeter (which is a Unity unit). This is very important to pay attention
    to when you are making a 2D game with sprite options. If you have your sprite
    set to 100 pixels per unit and this **Reference pixels per unit** is set to 50,
    your sprite will be twice as big as expected.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每单位参考像素** – 这个选项指的是每厘米有多少像素（这是一个Unity单位）。当你使用精灵选项制作2D游戏时，这一点非常重要。如果你的精灵设置为每单位100像素，而此**每单位参考像素**设置为50，则你的精灵将比预期大两倍。'
- en: Constant Physical Size
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常量物理大小
- en: This is similar to the **Constant Pixel Size** mode; however, this works with
    physical units, as seen below in *Figure 8.17*. You may be comfortable with sizing
    in these units rather than pixels.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这与**常量像素大小**模式类似；然而，它使用物理单位，如下面的*图8.17*所示。你可能更习惯于使用这些单位而不是像素来设置大小。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_17.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序自动生成描述](img/B17304_08_17.png)'
- en: 'Figure 8.17: Canvas Scaler component Constant Physical Size'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：画布缩放组件常量物理大小
- en: If it is the case that these units are better for you to use, then make sure
    you change the scale of all your fonts to these scales. The list of the physical
    options is shown below in *Figure 8.18*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些单位更适合您使用，请确保您更改所有字体的缩放比例到这些刻度。物理选项的列表如下所示，在*图8.18*中。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_18.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序 描述自动生成](img/B17304_08_18.png)'
- en: 'Figure 8.18: Physical unit options'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：物理单位选项
- en: Working with any of these options will force you to change all of your UI items
    to fit within the scale units of the same type. For example, it is common for
    sizing in pixels to be 300 wide, whereas 300 centimeters is massive! The scale
    should probably be 0.1\. For this reason we would recommend that you work through
    your systems and know which one you will be using if you want to use this scaling
    mode from the beginning.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项中的任何一个都会迫使您更改所有UI项目，以适应相同类型的刻度单位。例如，以像素为单位的大小通常是300宽，而300厘米则非常巨大！刻度可能应该是0.1。因此，我们建议您在您的系统中进行工作，并了解如果您想从一开始就使用这种缩放模式，您将使用哪种刻度。
- en: The last component is the **Graphic Raycaster**. This is the second-to-last
    default item that comes with the canvas. Let’s explain how the **Graphic Raycaster**
    works with the canvas.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件是**Graphic Raycaster**。这是与画布一起提供的倒数第二个默认项目。让我们解释一下**Graphic Raycaster**是如何与画布一起工作的。
- en: Graphic Raycaster Component
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Graphic Raycaster 组件
- en: 'This component is created on the canvas. The purpose for this is to be the
    function of what your mouse is clicking on. Below are the available parameters
    for the **Graphic Raycaster**, in *Figure 8.19*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件是在画布上创建的。这样做的原因是，它是您鼠标点击的功能。以下是在*图8.19*中**Graphic Raycaster**的可用参数：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_08_19.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 描述自动生成，中等置信度](img/B17304_08_19.png)'
- en: 'Figure 8.19: GraphicRaycaster Component'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：GraphicRaycaster 组件
- en: There are three parameters to quickly go over here.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三项参数需要快速浏览。
- en: '**Ignore Reversed Graphics** – This parameter ensures that you cannot click
    on objects that are turned around. Remember that backfaces are culled in the camera.
    You can flip elements of the UI off by flipping them around, but they would still
    be clickable without this being checked.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略反转图形** – 此参数确保您不能点击被反转的对象。请记住，相机中裁剪了背面。您可以通过翻转它们来关闭UI的元素，但即使这样检查，它们仍然可以点击。'
- en: '**Blocking Objects** – This allows for items that are 2D or 3D in front of
    the UI to block clicking the UI. This defaults to `none`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻挡对象** – 这允许在UI前面的2D或3D项目阻挡点击UI。默认为`none`。'
- en: '**Blocking Mask** – This parameter allows you to place layers to block the
    UI. Since UIs are sprites, they are generally a rectangle and can overlap fairly
    easily. To get around this you can make a UI block layer, which will allow you
    to place objects in front to block clicking even if it’s invisible, with alpha
    being 0.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻挡遮罩** – 此参数允许您放置图层以阻挡UI。由于UI是精灵，它们通常是矩形，并且可以相当容易地重叠。为了解决这个问题，您可以创建一个UI阻挡层，这将允许您放置对象在前面以阻挡点击，即使它是不可见的，alpha值为0。'
- en: We took the time to go over these default items as they are the primary items
    you will see when you start working with Unity’s UI. There are quite a few more
    options to learn in time as you create more UI, but this foundation will help
    you get started. Next, we will look into some UI objects to add to your canvas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花时间介绍了这些默认项目，因为它们是您开始使用Unity的UI时将看到的初级项目。随着您创建更多的UI，您将有机会学习更多选项，但这个基础将帮助您开始。接下来，我们将探讨一些要添加到画布中的UI对象。
- en: Unity UI objects
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity UI对象
- en: 'We now have a canvas! This is great because we’ve learned how it works with
    dynamic resolutions and how to set it up for your game’s needs. Now we need to
    add some objects for it to be useful. Unity UI objects are broken up into two
    types: **Visual** and **Interactive**.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个画布了！这很好，因为我们已经了解了它是如何与动态分辨率一起工作的，以及如何为您的游戏需求设置它。现在我们需要添加一些对象，使其变得有用。Unity
    UI对象分为两种类型：**视觉**和**交互**。
- en: 'Visual elements are what you expect. They are items that are meant to be visual
    elements only, but they can be attached to interactive items. The following are
    examples of these objects, including a description and a visual example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉元素正是您所期望的。它们是仅作为视觉元素的项目，但它们可以附加到交互元素上。以下是一些这些对象的示例，包括描述和视觉示例：
- en: '**Image** – There are two types of images: **Raw Image** and **Image**. **Raw
    Image** is only used where you want no border; however, it’s generally best to
    just use the **Image** object. **Images** take sprites and a border can be added
    to them. You can also tint the sprite within the **Image** component in the inspector.
    There is also another UI option named **Panel**. This is another UI object with
    an image component attached designed to be a panel of UI. The only difference
    between **Image** and **Panel** is that **Panel** will be set to stretch and fill
    in the entire canvas by default.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像** – 有两种图像类型：**原始图像**和**图像**。**原始图像**仅用于您不需要边框的地方；然而，通常最好只使用**图像**对象。**图像**可以接受精灵，并且可以为其添加边框。您还可以在检查器中的**图像**组件内着色精灵。还有一个名为**面板**的另一个UI选项。这是一个带有图像组件的UI对象，设计为UI面板。**图像**和**面板**之间的唯一区别是**面板**默认将设置为拉伸并填充整个画布。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_20.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_08_20.png)'
- en: 'Figure 8.20: Default Image and Image UI component'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：默认图像和图像UI组件
- en: '**Mask** – A **Mask** component will cut out the GameObjects underneath it.
    This is great for masking out extra items underneath it that may not want to be
    seen. Below, we added a mask to the image and added another image below it. The
    outline is the mask; the image that should be a square is cropped on the top and
    bottom due to the mask hiding it.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮罩** – **遮罩**组件将剪除其下方的GameObject。这对于遮罩掉可能不想看到的下方额外项目非常有用。下面，我们在图像上添加了一个遮罩，并在其下方添加了另一个图像。轮廓是遮罩；应该为正方形的图像由于遮罩而顶部和底部被裁剪。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_21.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_08_21.png)'
- en: 'Figure 8.21: Masked default image from Figure 8.20'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：来自图8.20的遮罩默认图像
- en: '**Text** – This is text! Sometimes this is also known as a **Label**. You are
    able to add a specific font to your UI if you need it. When you create it, you
    will see **TextMeshPro** after the text option. This is due to **TextMeshPro**
    (**TMP**) being so popular that it’s been integrated into the core Unity features.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本** – 这就是文本！有时这也被称为**标签**。如果您需要，您可以为您的UI添加特定的字体。当您创建它时，您将在文本选项后看到**TextMeshPro**。这是由于**TextMeshPro**（**TMP**）非常受欢迎，以至于它已被集成到Unity的核心功能中。'
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_22.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_08_22.png)'
- en: 'Figure 8.22: TextMeshPro UI component'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：TextMeshPro UI组件
- en: 'Interactive items can house visual elements, but they come with interactive
    `UnityEvents`. The following are examples of these, including a description and
    a visual example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式项目可以包含视觉元素，但它们带有交互`UnityEvents`。以下是一些示例，包括描述和视觉示例：
- en: '**Button** – This interactive object comes with a label by default in its hierarchy.
    It also comes with a `UnityEvent` for when it’s clicked. It has the ability to
    be tinted if it’s highlighted, pressed, or disabled. This is a primary function
    of UI with interaction.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮** – 这个交互对象在其层次结构中默认带有标签。它还带有点击时的`UnityEvent`。如果它被高亮、按下或禁用，它具有着色能力。这是UI交互的主要功能。'
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_23.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_08_23.png)'
- en: 'Figure 8.23: Button UI component'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：按钮UI组件
- en: '**Dropdown** – A **Dropdown** is a user-selectable field of a predefined group
    of options. When the user makes a change to this value, it will invoke the `OnValueChanged`
    `UnityEvent`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下拉列表** – **下拉列表**是一个用户可以选择的预定义选项组字段。当用户更改此值时，它将触发`OnValueChanged` `UnityEvent`。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_24.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_08_24.png)'
- en: 'Figure 8.24: Dropdown UI component'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：下拉列表UI组件
- en: '**Input Field** – This is a standard input field where the user clicked into
    it or “focused” on it. There is an interesting property we’d like to mention called
    **Content Type**. This allows the developer to error check without needing to
    write code. Setting this to **Integer Number**, for example, will only allow the
    user to input numbers. This interactable object has two `UnityEvents`:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入字段** – 这是一个标准的输入字段，用户点击进入或“聚焦”到它。有一个我们想提到的有趣属性，称为**内容类型**。这允许开发者进行错误检查，而无需编写代码。例如，将其设置为**整数数字**将只允许用户输入数字。这个交互式对象有两个`UnityEvents`：'
- en: '`OnValueChanged` – This will return the string of what value is currently in
    the input value every time a change has happened'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnValueChanged` – 每次发生更改时，这将返回当前输入值中的字符串'
- en: '`EndEdit` – This will return the string once the user clicks somewhere else
    or otherwise loses focus on that input field![Graphical user interface, text,
    application  Description automatically generated](img/B17304_08_25.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndEdit` – 当用户点击其他位置或失去对该输入字段的关注时，这将返回字符串![图形用户界面，文本，应用程序描述自动生成](img/B17304_08_25.png)'
- en: 'Figure 8.25: Input Field UI component'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.25：输入字段UI组件
- en: '**Scrollbar** – The **Scrollbar** is used generally in conjunction with a **Scroll**
    `Rect`. Its purpose is to be a scrollbar for a field if you need something that
    might be large. The value is from 0 to 1 regardless of how large the scrollbar
    is, and it can be vertical or horizontal. It also has a `UnityEvent` that can
    be used to know the `OnValueChanged`, so that you can return the value when you
    move the scrollbar.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动条** – **滚动条**通常与**滚动** `矩形`结合使用。其目的是在需要可能很大的字段时作为滚动条。无论滚动条有多大，值都是从0到1。它可以垂直或水平。它还有一个`UnityEvent`，可以用来知道`OnValueChanged`，这样你就可以在移动滚动条时返回值。'
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17304_08_26.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件描述自动生成](img/B17304_08_26.png)'
- en: 'Figure 8.26: Scrollbar UI component'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：滚动条UI组件
- en: '**Scroll** **Rect** – This can also be called a scroll view. This can be put
    in conjunction with two scroll bars to set up vertical and horizontal scrolling
    if needed. This is also set up with a mask to hide information outside the mask
    itself. It also has an `OnValueChanged UnityEvent` on the scrolling of the **Scroll**
    `Rect`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动** **矩形** – 这也可以称为滚动视图。如果需要，可以与两个滚动条结合使用，以设置垂直和水平滚动。这还通过一个遮罩来隐藏遮罩本身之外的信息。它还在**滚动**
    `矩形`的滚动上有一个`OnValueChanged UnityEvent`。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_27.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_08_27.png)'
- en: 'Figure 8.27: Scroll Rect UI component'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：滚动矩形UI组件
- en: '**Slider** – This is a slider that has a draggable object, which will set the
    value of the slider from a minimum value and a maximum value that you set. It
    also has a `UnityEvent`, which returns a value from that min and max value `OnValueChanged`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑块** – 这是一个带有可拖动对象的滑块，它将滑块的值从你设置的最低值和最高值设置。它还有一个`UnityEvent`，从那个最小值和最大值返回`OnValueChanged`。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_28.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_08_28.png)'
- en: 'Figure 8.28: Slider UI component'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：滑块UI组件
- en: '**Toggle** – This is a checkbox that has a label assigned to it. When clicked,
    you can use the `OnValueChanged UnityEvent` to evaluate if it’s on or off.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换** – 这是一个带有标签的复选框。点击时，可以使用`OnValueChanged UnityEvent`来评估它是开启还是关闭。'
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_29.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B17304_08_29.png)'
- en: 'Figure 8.29: Toggle UI component'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：切换UI组件
- en: '**Toggle Group** – If you add toggles to a group, you can set this group to
    allow only one within the group to be selectable. If you select another one in
    the assigned grouping, it will switch off the previously on toggle and switch
    on the selected toggle. There is an **Allow Switch Off** option, which lets you
    select the currently selected toggle to make none of the groups selected. There
    is no unique `UnityEvent` connected to the group itself; however, each toggle
    still has its own `OnValueChanged` event that will trigger. One small note, if
    you are going to make a toggle group, make sure that each toggle has that **Group**
    assigned in their **Toggle** component.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换组** – 如果你将切换添加到一组中，你可以设置该组只允许组内一个切换可被选择。如果你在分配的分组中选择了另一个切换，它将关闭之前开启的切换并开启所选的切换。有一个**允许关闭**选项，它允许你选择当前选中的切换以取消选择所有组。与该组本身连接的`UnityEvent`没有唯一性；然而，每个切换仍然有自己的`OnValueChanged`事件，这将触发。一个小提示，如果你要创建一个切换组，请确保每个切换在其**切换**组件中分配了该**组**。'
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_08_30.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B17304_08_30.png)'
- en: 'Figure 8.30: Toggle Group UI component'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30：切换组UI组件
- en: These are all good examples of UI items available for the Unity UI. From here,
    we need to go through the implementations of the Unity UI to fit our game. We
    previously went over the design; now we need to look into the code to see how
    it works when players need to interact with it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是Unity UI中可用的UI项的好例子。从这里，我们需要通过Unity UI的实现来适应我们的游戏。我们之前讨论了设计；现在我们需要查看代码以了解当玩家需要与之交互时它是如何工作的。
- en: Implementation
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We need to now look at our implementation. Knowing what all of the UI objects
    look like and their purpose is helpful, but we now need to see what it looks like
    to have them in practice. We will start off with the **Main Menu** before the
    game starts for the player. After that, we will break into the journal or escape
    menu. Then we will finish up with the spatial UI for interaction with the game’s
    mechanics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要查看我们的实现。了解所有UI对象的外观和它们的目的很有帮助，但我们现在需要看到它们在实际中的样子。我们将从游戏开始前玩家的**主菜单**开始。之后，我们将进入日志或逃生菜单。然后我们将完成与游戏机制交互的空间UI。
- en: When reading this part, remember that we will not be going over all of the lines
    of the script as at this point we assume that you’ve gotten comfortable with looking
    at the code that we have on GitHub.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这部分内容时，请记住，我们不会覆盖脚本的所有行，因为此时我们假设你已经习惯了查看我们在GitHub上的代码。
- en: If at any time you feel confused about how the book is laid out for explaining
    the code, ensure that you pull up the scripts that are being referenced and get
    yourself realigned. The primary goal of us explaining code in this manner is to
    be as concise as possible about what we are doing and why. Seeing every line of
    code doesn’t help with that!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你对本书如何布局来解释代码感到困惑，确保你调出被引用的脚本并重新调整你的方向。我们以这种方式解释代码的主要目标是尽可能简洁地说明我们在做什么以及为什么这样做。查看每一行代码并不能帮助达到这个目的！
- en: That being said, let’s get into the main menu implementation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们进入主菜单的实现。
- en: Main menu implementation
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主菜单实现
- en: As we wanted this menu to be non-diegetic, but sitting in the world space to
    give an illusion of space, we chose to go with a **World Space** canvas. Below
    in *Figure 8.31* is the hierarchy and the inspector with collapsed components
    that have no changes from the default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望这个菜单是非叙事性的，但位于世界空间中以产生空间错觉，我们选择使用**世界空间**画布。在下面的*图8.31*中是层次结构和带有未更改的折叠组件的检查器。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_08_31.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B17304_08_31.png)'
- en: 'Figure 8.31: Left, hierarchy for MainMenuCanvas; Right, Inspector for Canvas'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31：左，MainMenuCanvas的层次结构；右，Canvas的检查器
- en: 'The `MainMenuUIControl.cs` script is how we will control our main menu. When
    working with the UI, you need to make sure that you import the UI library:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainMenuUIControl.cs`脚本是我们控制主菜单的方式。在处理UI时，你需要确保你导入了UI库：'
- en: '[PRE0]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you use the UI library you will be able to access all the UI objects and
    their methods. Though the next line I’d like to place here isn’t specifically
    part of the UI, I’d like to show you something we haven’t talked about yet. This
    method is called `FindObjectOfType`. We know that there will only be one `MyvariThirdPersonMovement`
    class in the scene ever, so we are using this method to get it and then ask for
    its parent so we know the player root.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用UI库时，你将能够访问所有UI对象及其方法。尽管下一行我想要放置在这里的不是UI的特定部分，但我想要向你展示我们还没有讨论过的东西。这个方法被称为`FindObjectOfType`。我们知道场景中永远只有一个`MyvariThirdPersonMovement`类，所以我们使用这个方法来获取它，然后请求它的父级，这样我们就知道玩家根。
- en: '[PRE1]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also need to disable the character and set up listeners for the event system
    so it knows what to do when we click on the buttons in the canvas.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要禁用角色并为事件系统设置监听器，这样它就知道当我们点击画布中的按钮时要做什么。
- en: To disable the character, we have a method we call `on awake` to turn off what
    we need to. When using Cinemachine, you want to disable all the cameras that are
    available or Cinemachine will go to one of the cameras. Then we disable the player’s
    control script only. This allows the characters’ animations to keep playing in
    place, but we just can’t control her.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用角色，我们有一个我们称之为`on awake`的方法来关闭我们需要关闭的东西。当使用Cinemachine时，你想要禁用所有可用的相机，否则Cinemachine会转到其中一个相机。然后我们只禁用玩家的控制脚本。这允许角色的动画在原地继续播放，但我们无法控制她。
- en: 'On awake:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`awake`时：
- en: '[PRE2]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Separate private implementation on line 50:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第50行有一个独立的私有实现：
- en: '[PRE3]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve set up listeners several times before, but let’s take a look at them
    as well:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经设置了几次监听器，但让我们也看看它们：
- en: '[PRE4]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What is happening here is that the respective buttons that are in place for
    `startGameButton` and `quitButton` will activate the methods in their listeners
    when they are clicked.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，对于`startGameButton`和`quitButton`中放置的相应按钮，当它们被点击时，将激活它们监听器中的方法。
- en: 'The `OnStartGameButtonPressed` method looks like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStartGameButtonPressed`方法看起来是这样的：'
- en: '[PRE5]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When it’s pressed it sets the character to enabled so we can use the input
    to move her around, lock and hide the mouse cursor, and disable the main menu
    so you can’t see it anymore. If you hit the quit button, you will close the application.
    Unity has an easy way to quit the application:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被按下时，将角色设置为启用，这样我们就可以使用输入来移动她，锁定并隐藏鼠标光标，并禁用主菜单，这样你就再也看不到它了。如果你点击退出按钮，你将关闭应用程序。Unity有一个简单的方法来退出应用程序：
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the entire main menu! The trickiest part of what we needed to do was
    to lock the player down. Otherwise, they would’ve been moveable while the main
    menu is up, which is not what we wanted in this case. Next, we need to work on
    the journal.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个主菜单！我们需要的最难的部分是锁定玩家。否则，当主菜单打开时，他们将是可移动的，而这在我们这个情况下不是我们想要的。接下来，我们需要处理日志。
- en: Journal implementation
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志实现
- en: In most games, there is a common concept of an escape menu. This is to say,
    when you press the *Escape* key, you will encounter a menu that generally pauses
    the gameplay. In our case, we wanted it so when you pressed *Escape*, our character
    would open up her book and look at it. This would be good as, it allows the game
    to pause a bit as the camera moves in to see the book and we can house the normal
    escape menu options, such as resume and quit the game. There will be some similar
    concepts from the main menu here in this, such as locking and unlocking the cursor.
    There is also a player enabling method, which is the same as in the main menu
    as well.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏中，有一个常见的概念，即逃生菜单。也就是说，当你按下*Escape*键时，你会遇到一个通常暂停游戏玩法的菜单。在我们的情况下，我们希望当你按下*Escape*时，我们的角色会打开她的书并查看。这将很好，因为它允许游戏暂停一下，当相机移动到书本附近时，我们可以放置正常的逃生菜单选项，如继续和退出游戏。在这里，主菜单中的一些类似概念也会出现，比如锁定和解锁光标。还有一个玩家启用方法，它与主菜单中的方法相同。
- en: Below, in *Figure 8.32*, is another representation of the hierarchy and script
    in the inspector for the Journal UI. One of the unique items in the public fields
    is that we are using an input system as opposed to only relying on the mouse inputs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，在*图8.32*中，是日志UI检查器中层次结构和脚本的另一种表示。在公共字段中，我们使用输入系统而不是仅仅依赖鼠标输入，这是其中独特的一项。
- en: For us to load up the journal, we can press the letter *B* or the *Escape* key.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载日志，我们可以按字母*B*或*Escape*键。
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B17304_08_32.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B17304_08_32.png)'
- en: 'Figure 8.32: Left, Journal hierarchy; Right, Book inspector panel'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32：左，日志层次结构；右，书籍检查器面板
- en: This is an interesting turning point in the book for us. All of the coding involved
    with this script has been done previously. I recommend opening the script and
    looking at it to help remember the prior coding lessons.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书对我们来说是一个有趣的转折点。与这个脚本相关的所有编码工作都已完成。我建议打开脚本并查看它，以帮助记住之前的编码课程。
- en: The last piece of UI is the spatial UI that helps players know that the item
    they are looking at is interactable. Let’s break this implementation down.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个UI元素是空间UI，它帮助玩家知道他们正在查看的项目是可交互的。让我们分解这个实现。
- en: Interaction UI implementation
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互UI实现
- en: This is unique to set up as there is no canvas for this item. We will have a
    single GameObject that is in the scene and we will move it to the location that
    is needed and turn it off or on depending on what we are looking at if it’s intractable.
    We have a simple GameObject, which is a sphere without a material on it so it’s
    bright pink.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这项设置是独特的，因为没有画布用于此项目。我们将有一个单独的GameObject，它位于场景中，我们将将其移动到所需的位置，并根据我们正在查看的内容打开或关闭它，如果它是不可交互的。我们有一个简单的GameObject，它是一个没有材质的球体，因此它是明亮的粉色。
- en: In the script `InteractiveHighlight.cs`, `on awake` we find this GameObject
    and grab its renderer. If it’s not found, then we have an error that lets us know
    we can’t find it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InteractiveHighlight.cs`脚本中，`on awake`我们找到这个GameObject并获取其渲染器。如果没有找到，则我们有一个错误，告诉我们我们找不到它。
- en: We grab the mesh renderer so that we can disable it when we don’t need to see
    it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取网格渲染器，这样我们就可以在我们不需要看到它时禁用它。
- en: '[PRE7]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have the highlight indicator, we should perform the hiding and movement
    of the indicator itself. We are using a raycast to know if we are hitting an interactable
    item or a piece of the game’s puzzle pieces. This is a physics method, so we will
    put this on the fixed update. This will ensure that the code is run in accordance
    with the physics update timing that we talked about in *Chapter 7*, *Rigid Bodies
    and Physics Interaction*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了高亮指示器，我们应该执行指示器的隐藏和移动。我们使用射线投射来知道我们是否击中了可交互的项目或游戏拼图的一部分。这是一个物理方法，所以我们将它放在固定更新中。这将确保代码按照我们在第7章“刚体和物理交互”中讨论的物理更新时间运行。
- en: '[PRE8]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As stated previously, the fixed update here runs on physics timing and is checking
    to see if what is raycast from the center of the screen is hitting items on the
    two masks. If it is hit and it’s within the max distance, then move the highlighted
    piece and turn on its renderer. If not, then turn it off!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这里的固定更新在物理时间上运行，并检查从屏幕中心射出的光线是否击中了两个遮罩上的项目。如果是击中并且距离在最大距离内，则移动高亮的项目并打开其渲染器。如果不是，则关闭它！
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was quite meaty with information. Even though we only had three
    pieces of UI to go over, we needed to break it into all of these pieces to help
    you with your future projects. You will now also have a strong sense of how other
    game developers design their UI for their games. During *Chapter 12*, *Final Touches*,
    we will be going over the clean-up of it and how polishing the UI makes a difference
    to the player’s experience. In the next chapter, we will go over visual effects
    and some particle systems.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容丰富，信息量大。尽管我们只讨论了三个UI元素，但我们不得不将其分解成所有这些部分，以帮助您在未来的项目中。您现在也将对其他游戏开发者如何为他们的游戏设计UI有一个强烈的认识。在第12章“最终润色”中，我们将讨论它的清理以及如何通过润色UI来改善玩家的体验。在下一章中，我们将讨论视觉效果和一些粒子系统。
