- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Real-Time Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a multi-player, head-to-head game app with real-time
    communication. In the app, you will be able to connect to a game server and view
    a list of other players that are also connected. You can then select a player
    to request a game with them and, provided they accept, play a game of *Sticks
    & Stones*. We will look at how we can use SignalR to implement a real-time connection
    with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use SignalR in a .NET MAUI app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use control templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use XAML triggers to update the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use XAML styling in a .NET MAUI app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start building the app for this project, you need to build the backend
    that we detailed in *Chapter 9*, *Setting Up a Backend for a Game Using Azure
    Services*. You will also need to have Visual Studio for Mac or PC installed, as
    well as the .NET MAUI components. See *Chapter 1*, *Introduction to .NET MAUI*,
    for more details on how to set up your environment. The source code for this chapter
    is available in this book’s GitHub repository: [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main).'
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a head-to-head game app, it is really important to have real-time
    communication because the user expects the other players’ moves to arrive more
    or less immediately. To achieve this, we will use SignalR, which is a library
    for real-time communication. SignalR will use WebSockets if they are available
    and, if not, it will have several fallback options it can use instead. In the
    app, we will use SignalR to send updates on player and game status through the
    Azure Functions that we built in *Chapter 9*.
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 180 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use either Visual Studio on a PC or Mac to complete this project. To
    build an iOS app using Visual Studio for PC, you have to have a Mac connected.
    If you don’t have access to a Mac at all, you can choose to just build the Android
    part of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review from *Chapter 9* what the game is all about.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sticks & Stones* is a turn-based social game based on the concepts of two
    childhood games mashed into one, Dots and Boxes ([https://en.wikipedia.org/wiki/Dots_and_boxes](https://en.wikipedia.org/wiki/Dots_and_boxes))
    and Tic-Tac-Toe ([https://en.wikipedia.org/wiki/Tic-tac-toe](https://en.wikipedia.org/wiki/Tic-tac-toe)).
    The game board is laid out in a three-by-three grid. Each player will take a turn
    placing a stick along the side of a box, between two dots, to earn one point.
    If a stick completes a box, then the player takes ownership of the box, earning
    five points. The game is won when a player owns three boxes in a row, horizontally,
    vertically, or diagonally. If no player can own three boxes in a row, the winner
    of the game is determined by the player with the highest score.'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the app and the service side relatively simple, we will eliminate a
    lot of state management. When the player opens the app, they will have to connect
    to the game service. They will have to provide a gamer tag, or username, and an
    email address. Optionally, they can upload a picture of themselves to use as a
    profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, the player will then see a list of all the other players connected
    to the same game service; this is called the Lobby. The player’s status of either
    **Ready to play** or **In a match** is displayed along with the player’s gamer
    tag and profile picture. If the player is not in a match, a button is available
    to challenge the player to a match.
  prefs: []
  type: TYPE_NORMAL
- en: Challenging a player to a match will cause the app to prompt the opponent to
    respond to the challenge, either accept or decline it. If the opponent accepts
    the challenge, then both players are navigated to a new game board where the player
    who received the challenge will have the first turn. Both players’ statuses will
    update to **In a match** in all the other players’ lobbies.
  prefs: []
  type: TYPE_NORMAL
- en: Play will alternate between players as they choose a location to place a single
    stick. Each time a stick is placed by a player, the game board and score will
    update on both players’ devices. When a stick is placed that completes one or
    more squares, the player then wins that square, and a pile of stones is placed
    in the center of the square. When all sticks have been placed, or a player owns
    three stones in a row, the game is over, the players navigate back to the Lobby,
    and their status is updated to “Ready to play.”
  prefs: []
  type: TYPE_NORMAL
- en: If a player leaves the app during a game, then they will have forfeited the
    match and the remaining opponent will be credited with the win and navigated back
    to the Lobby.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what we want to build, let’s get down to the details.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you use the same solution we used in *Chapter 9*, *Setting
    Up a Backend for a Game Using Azure Services*, because this will make code sharing
    easier. If you don’t want to go through all of *Chapter 9*, you can get the completed
    source from *Chapter 9**,* at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build this app in four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Services** – All the classes that are needed to connect and interact with
    the Azure Functions backend that was built in *Chapter 9*, *Setting Up a Backend
    for a Game Using* *Azure Services*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connect page** – This will consist of the view and view model needed to allow
    a user to connect to the game server as a player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lobby page** – The Lobby is where the player can send and receive challenges
    with other players. In this section, we will build the view and view model for
    the lobby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game page** – This is where players can take turns playing a game of *Sticks
    and Stones*. In this section, we will build the view and view model needed to
    make that happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating the project for the .NET MAUI app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to start building the app. Open the `SticksAndStones` solution from
    the previous chapter and follow these steps to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Create a new project** wizard by selecting **File**, **Add**, then
    **New Project…** from the Visual Studio menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – File | Add | New Project…](img/B19214_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – File | Add | New Project…
  prefs: []
  type: TYPE_NORMAL
- en: 'In the search field, type `maui` and select the **.NET MAUI App** item from
    the list, or select it from **Recent project templates** if it is listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 10.2 – Create a new p\uFEFFroject](img/B19214_10_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Create a new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `SticksAndStones.App` as the name of the app and, under **Solution**,
    select **Add to solution**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Configure your new project](img/B19214_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Configure your new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For the purposes of this book, we
    will assume that you will be using .NET 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Additional information](img/B19214_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Additional information
  prefs: []
  type: TYPE_NORMAL
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have created the .NET MAUI project for our game screens, let’s configure
    it so that it’s ready to add the services and views. We will need to add a project
    reference to the `SticksAndStones.Shared` project, as well as a few NuGet packages.
    Follow these steps to complete the setup of the `SticksAndStones.App` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `SticksAndStones.App` project in **Solution Explorer** and select
    **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Default namespace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `$(MSBuildProjectName.Split(".")[0].Replace(" ", "``_"))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will split the project name on `"."`, using only the first part and replacing
    any spaces with underscores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a NuGet Package reference to `CommunityToolkit.Mvvm` as, in other chapters,
    we will be using this package to simplify the implementation of data bindings
    to properties and commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a NuGet Package reference to `CommunityToolkit.Maui`. We will be using the
    `GravatarImageSource` class from this package to render an avatar for the user.
    For .NET 7, you will need to use version 6.1.0 of the NuGet package. 7.0+ has
    .NET 8 as a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MauiProgram.cs` file and add the highlighted line shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will configure `CommunityToolkit` for use within the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a NuGet package reference to `Microsoft.Extensions.Logging.Abstractions`.
    This package is used to log messages from the Azure Functions functions for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a NuGet package reference to `Microsoft.Extensions.Logging.Debugging`. This
    package is used to log messages from the Azure Functions functions for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a NuGet package reference to `Microsoft.AspNetCore.SignalR.Client`. This
    package is required for the app to connect to the SignalR Hub we created in *Chapter
    9* and receive messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Project reference to the `SticksAndStones.Shared` project. This will give
    us access to the messages and objects we created in *Chapter 9*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for project creation. Next, we will start with creating classes that
    interact directly with our service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will do is create a service that will be used to communicate
    with the Azure Functions functions service created in *Chapter 9*, *Setting Up
    a Backend for a Game Using Azure Services*. The service will be broken down into
    three main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameService` – Methods and properties for calling the Azure Functions and
    receiving SignalR messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceConnection` – Holds the references to `HttpClient` and SignalR Hub
    instances. Also provides methods for safely making calls using `HttpClient`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Settings` – Stores and retrieves the URL for the server used by `HttpClient`.
    It also stores the connection details provided by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with the `Settings` class since both `GameService` and `ServiceConnection`
    will depend on `Settings`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Settings service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Settings` service is used to store values that are needed between app
    runs. It will use the .NET MAUI `Preferences` class to store these values in a
    cross-platform manner. Use the following steps to implement the `Settings` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SticksAndStones.App` project, create a new folder named `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the newly created `Services` folder, create a new class named `Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `const string` field named `LastPlayerKey` and initialize it like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `const string` field named `ServerUrlKey` and initialize it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two fields are used by the .NET MAUI `Preferences` class to store the
    values for the server URL and the login details for the last time the user logged
    in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `private const string` field named `ServerUrlDefault` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may need to adjust the port number, highlighted in the preceding listing,
    for your specific development environment. Azure Functions will display the server
    URL when started from Visual Studio, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Azure Functions console output](img/B19214_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Azure Functions console output
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Functions hosted in Azure
  prefs: []
  type: TYPE_NORMAL
- en: If you followed the steps in the *Chapter 9* section called *Deploying the functions
    to Azure*, then you can use the URL for the Azure Function App created in *Chapter
    9*, in the *Creating the Azure service for functions* section. The URL is displayed
    on the **Overview** tab of the Azure Functions App.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a `public string` property named `ServerUrl` with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will get the server URL from the `Preferences` store if it is present;
    if not, it will use the `serverUrlDefault` value. The property will store the
    new value in the `Preferences` store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `using` declarations at the top of the `Settings.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will enable us to use our model and the `JsonSerializer` classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new property named `LastPlayer` that is of the `Player` type, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the property `set` method will convert the `Player` object to a `Json`
    string before storing it in `Preferences` and, when getting the property, if it
    exists in the `Preferences` store, convert the stored `Json` to a `Player` object.
    If there is no value in the `Preferences` store, then the `get` method will return
    an empty `Player` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step for the `Settings` class is to register it with the dependency
    injection container. Open the `MauiProgram.cs` file in the `SticksAndStones.App`
    project, then add the following highlighted code to the `CreateMauiApp` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `Settings` class complete, we can now focus on the `ServiceConnection`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ServiceConnection class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ServiceConnection` class encapsulates the functionality needed to communicate
    with the Azure Functions service. It has methods to call the function methods
    and return the results, with appropriate error handling. It is also responsible
    for initializing the SignalR Hub instance that is used for real-time communication.
    The `ServiceConnection` class has a couple of dependencies that we need, so let’s
    put them together first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to add is logging. Having logging during debugging can be very
    helpful in figuring out problems, especially when dealing with asynchronous processes.
    Communicating with Azure Functions will have a lot of asynchronous operations.
    To enable logging while debugging, add the highlighted code to the `CreateMauiApp`
    method in the `MauiProgram` class in the `SticksAndStones.App` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will add an instance of `ILoggingProvider` to the services container. The
    `ILoggerProvider` instance will provide instances of `ILogger<T>`. This will enable
    the use of `ILogger<T>` as a dependency in the `ServiceConnection` class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: More on logging providers
  prefs: []
  type: TYPE_NORMAL
- en: Read more about how logging providers work, and logging in general, at [https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers).
  prefs: []
  type: TYPE_NORMAL
- en: Now, when making requests to APIs using HTTP, it is a common and good practice
    to use asynchronous calls so that you do not block the main or UI thread. All
    UI updates, such as animation, button clicks, taps on the screen, or text changes,
    happen on the UI thread. HTTP calls can take a non-trivial amount of time to complete,
    which can cause the app to become unresponsive to a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error handling in asynchronous programming can be difficult. To help with errors
    when making API calls, we are going to use a couple of classes to encapsulate
    the exceptions; these classes are `AsyncError` and `AsyncExceptionError`. We need
    `AsyncError` and `AsyncExceptionError` because it is a bad practice to serialize
    and deserialize any class instances that derive from `System.Exception`. Not all
    classes derived from `System.Exception` are serializable, and even if they are,
    you may not be able to deserialize them due to a missing type – for example, the
    type is available on the server but not on the client. Create a new file named
    `AsyncError.cs` in the `SticksAndStones.App` project and replace the contents
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `AsyncError` class has a single property, `Message`. The `Message` property
    is decorated with the `JsonPropertyName` attribute so that it can be serialized
    if needed, using a lowercase version of the property name. `AsyncExceptionError`
    inherits from `AsyncError` and adds an additional property, `InnerException`.
    The `InnerException` property is also attributed with `JsonPropertyName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last class we will need is `AsyncLazy<T>`. You may have already used `Lazy<T>`
    in other applications you have written. It’s very handy when you want to delay
    the creation of a class until right before you need it. If you never need it,
    it doesn’t get created. But `Lazy<T>` does not work great with asynchronous programming,
    so if you wanted to lazy instantiate a class that is created asynchronously, that
    becomes tedious. Luckily for us, Stephen Toub, who works for Microsoft on the
    .NET team, created `AsyncLazy<T>`. To add it to the `SticksAndStones.App` project,
    create a new file named `AsyncLazy~1.cs` and replace the contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about AsyncLazy<T>
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the .NET blog to learn more about how Stephen Toub created the `AsyncLazy<T>`
    class: [https://devblogs.microsoft.com/pfxteam/asynclazyt/](https://devblogs.microsoft.com/pfxteam/asynclazyt/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the changes needed to start implementing the `ServiceConnection`
    class. To create the class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `ServiceConnection` in the `SticksAndStones.App` project
    in the `Services` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class to `public sealed` and inherit from `IDisposable`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the namespace declarations at the top of the file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are needed to reference the types needed in the following steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `private` fields to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `serializerOptions` is used to make sure the JSON that is sent and received
    from the Azure Functions functions can be serialized and deserialized properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add a `public` property named `Hub`. The type for `Hub` is `AsyncLazy<HubConnection>`.
    `HubConnection` is the type from the SignalR client library that is used to receive
    messages from the SignalR service. The property should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HubConnection` is initialized in the `ConnectHub` method. But first, let’s
    add the constructor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The constructor for the `ServiceConnection` class has two parameters: `ILogger`
    **<ServiceConnection>** and a `Settings` parameter. In the body of the constructor,
    the `private` fields created in *step 3* are initialized as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `logger` and `settings` parameters are provided by the .NET MAUI dependency
    injection service. The `httpClient` field is initialized and it’s `BaseAddress`
    is assigned the settings `ServerUrl` property as a URI. Then, `DefaultHeaders`
    is modified to indicate to the server that the results are expected to be in JSON
    format. The `serializerOptions` instance is initialized to the defaults for `Web`,
    which is consistent with the formatting used by Azure Functions. Finally, the
    `log` field is initialized with the `logger` parameter value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s implement the `Dispose` method. It will clean up any values that
    will potentially hold on to any native resources, such as networks, file handles,
    and so on. The two values that this class has references to that need to be disposed
    of are `httpClient` and `Hub`. Note that we will not have to call `Dispose` ourselves
    as the .NET MAUI dependency injection system will do that. Add the following code
    to the `ServiceConnection` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the class to dependency injection by adding the following highlighted
    line of code to the `MauiProgram.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initializing the `Hub` property will happen in the `ConnectHub` method. The
    configuration for the SignalR SignalR Hub connection is returned to the app in
    the `Connect` function result. Since we haven’t and won’t make that call before
    this class is constructed, we can’t create the `Hub` in the constructor. The configuration
    is needed before you can initialize the `Hub` instance. The `ConnectHub` method
    has a single parameter of `ConnectionInfo`. Add the method using the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method initializes the `Hub` property to a new `AsyncLazy<HubConnection>`
    instance. The constructor for `AsyncLazy<T>` takes `Func<T>`, which is provided
    using the anonymous method syntax. The anonymous method is also decorated as an
    `async` method, meaning that it will contain an awaited method call. The anonymous
    method takes no parameters and, in the body, starts by creating a new `HubConnectionBuilder`.
    Then, the `WithUrl` extension method is called on `HubConnectionBuilder` to set
    the URL for the SignalR service and provide the `AccessToken` value needed to
    make the connection. `AccessTokenProvider` is a `Task<string>` so the `config.AccessToken`
    is provided through another `async` anonymous function. The `WithAutomaticReconnect`
    method sets `HubConnection` instance to automatically try reconnecting the SignalR
    service if the connection is lost. If `WithAutomaticReconnect` isn’t called, then
    the app is responsible for reconnecting if the connection is lost. The `HubConnection`
    instance is created by calling `HubConnectionBuilder.Build`. The `Hub` instance
    is then started with `StartAsync`, which is awaited, and then the `Hub` is returned.
    The thing to remember here is that when `ConnectHub` is called, the anonymous
    function isn’t executed. The method won’t be called until the first time a property
    or method of the `Hub` property is accessed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `ServiceConnection` class contains two helper functions that are used from
    the `GameService` class to make HTTP requests to the Azure Functions service.
    The first, `GetAsync<T>`, takes two parameters: a URL and a dictionary of query
    parameters to pass along with the URL. It returns an instance, `T`, and `AsyncError`
    as a `Tuple`. The `GetAsync` method will use the `GET` HTTP method when making
    the HTTP request. The other helper method, `PostAsync<T>`, uses the `POST` HTTP
    method and accepts two parameters: a URL, and an object to send in the body of
    the request formatted as JSON. It will return an instance of `T` from the response.'
  prefs: []
  type: TYPE_NORMAL
- en: '`The` `GetAsync<T>` and `PostAsync<T>` use a couple of helper methods; use
    the following code snippet to add them to the `ServiceConnection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `GetUriBuilder` method will return a new `UriBuilder` from the provided
    URL and `Dictionary` of key-value pairs to use in the query string. The `GetError`
    method will return either an `AsyncError` object or `AsyncExceptionError` object
    based on the status code or the contents of the response from the HTTP method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the `GetAsync<T>` method to the `ServiceConnection` class using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While this method is a little long, what it is doing is not all that complicated.
    First, it uses the `GetUriBuilder` method to create the `UriBuilder` instance
    and build the `fullUri` string value from that. Then, it makes an HTTP `GET` call
    using `the HttpClient` instance to the URL. If there is any failure, the exception
    handler will catch it and return an `AsynExceptionError`. If there are no errors
    in making the request and the response code indicates success, then the result
    is processed and returned. Otherwise, the result content is read for an error,
    and if it is found, it is returned. When the `GetAsync<T>` method returns, it
    will always return two items: the response of the `T` type and `AsyncError`. If
    either one of them isn’t present, then their default value is returned or `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review and add the following code snippet to the `ServiceConnection` class
    to implement the `PostAsync<T>` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This method is mostly the same as `GetAsync<T>` with a couple of minor changes.
    First, it does not need to call `GetUriBuilder` to add the parameters to the `Uri`
    `QueryString`, as the parameters are sent as part of the request body. Second,
    it uses the HTTP `POST` method instead of `GET`. With those changes, much of the
    method is error handling to make sure that we return the right data.
  prefs: []
  type: TYPE_NORMAL
- en: And that completes the `ServiceConnection` class. `ServiceConnection` and the
    `Settings` service classes will be used in the next section, where we create the
    `GameService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GameService class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GameService` class is a layer between the UI and the network. It uses the
    `ServiceConnection` class, which handles the specific network calls to create
    the logic we need to interact with the Azure Functions functions. For each of
    the functions that we created in *Chapter 9*, there is a corresponding method
    in the `GameService` class to make the call to the function and return the result,
    if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create and initialize the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `GameService` in the `SticksAndStones.App` project
    under the `Services` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class definition to `public sealed` and inherit from the `IDisposable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following namespace declarations to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `GameService` class will depend on both the `Settings` service and the
    `ServiceConnection` service, so we need to add them to the constructor and store
    the references in class fields, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `IDisposable` interface by adding the following method to the
    `GameService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the class to dependency injection by adding the following highlighted
    line of code to the `MauiProgram.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will start with the `Connect` method. `Connect` will accept a `Player` object
    to connect as and return an updated `Player` object. Additionally, if the connection
    is successful, it will configure the SignalR Hub. To create the `Connect` function,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `private` field of `SemaphoreSlim` called `semaphoreSlim` and initialize
    the field with a new instance with an initial and maximum count of `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`The SemaphoreSlim` class is a great way to limit the number of threads performing
    an operation at a time. In our case, we only want one thread making the network
    calls at a time. It will be used in all the methods that make network calls from
    the `GameService` class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameService` will track the current player in a `public` property called `CurrentPlayer`;
    add the property to the class using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The property is initialized to an empty `Player` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the user has connected as a player, we will also need somewhere to store
    the list of online players. To do that, add the following property to the `GameService`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`The GameService` class also tracks the current status of the connection in
    a property called `IsConnected`; add the property using the following code snippet
    to the `GameService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `public async` method named `Connect` to the `GameService` class. It
    should return `Task<Player>` and take a single `Player` as a parameter, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `Connect` method, the first step is to make sure there is only one
    thread operating in the method at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the `async`/`await` structures in C# to create a lock that only releases
    when there are enough open slots in `SemaphoreSlim`. Since `the` `SemaphoreSlim`
    instance was only initialized with a single slot, only one thread can process
    the `Connect` method at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make sure `the` `SemaphoreSlim` instance releases the slot, we need to add
    exception handling around the rest of the method and call `Release` at the end.
    Add the following code snippet to the `Connect` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `try`/`finally` block ensures that we will always call `Release` at the
    conclusion of the method, which will prevent `the` `SemaphoreSlim` instance from
    being starved, preventing any additional thread from entering the method. Lastly,
    we return the value of `CurrentPlayer`, which we will set next within the `try`
    block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is another way to handle SemaphoreSlim
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `try`/`catch`/`finally` block works, but it is a little clunky if you
    handle all your exceptions properly, or don’t have any. Tom Dupont has published
    a helper class on his blog that allows you to use a `using` statement to manage
    the lifetime of `the` `SemaphoreSlim` instance. You can read his post at [http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html](http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html).
    Here is an example of using his extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using var handle =` `semaphoreSlim.UseWaitAsync();`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `try` block, add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This block of code handles the call to the `Connect` function in the Azure Functions
    service. We start by setting the passed-in player details as the `CurrentPlayer`
    property. Then, `the player` instance is packaged into a `ConnectRequest` object
    and we pass that into a call to `PostAsync<T>` on the `ServiceConnection` instance.
    The URL is created from the `ServerUrl` property stored in the `Settings` service
    concatenated with `/Connect`. The response is expected to be of the `ConnectResponse`
    type and we store that in response. If we do not get any error, then we can call
    `ConnectHub` on the `ServiceConnection` instance, populate our `Players` collection,
    and set `the` `CurrentPlayer` property to the returned `Player` instance, which
    will have additional details from the server. If anything goes awry, then the
    error object will be populated, and we will send a message that contains that
    error to the UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ServiceError` is the first message that we need to send to `ViewModel` instances
    from `the GameService` class. It is used to send errors from `the` `ServiceConnection`
    instance to `ViewModel` instances. We will add the `ServiceError` class in the
    next steps.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `SticksAndStones.App` project, create a new folder named `Messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class named `ServiceError` in the `Messages` folder of the `SticksAndStones.App`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ServiceError` message is a simple wrapper around the `AyncError` object
    that can be used to send a message back to a view model. Replace the contents
    of the `ServiceError.cs` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, since we are using `SemaphoreSlim` and it can hold onto native resources,
    we should make sure that those are released properly. Add the following highlighted
    code to the `Dispose` method to clean up the `semaphoreSlim` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The concludes the `Connect` method for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three methods are called from the `Lobby` page. The first method is
    used to refresh the list of players. It is called when the user pulls down the
    list causing a refresh, or if the SignalR Hub is reconnected. To implement `the`
    `RefreshPlayerList` method, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`the` `RefreshPlayerList` method takes no arguments and returns `Task`; add
    the method to the `GameService` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To refresh the list of players when the SignalR Hub reconnects, add the following
    highlighted code to the `Connect` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line of code is interesting. First, we await `service.Hub`, then set the
    `Reconnected` event to an anonymous function that calls `RefreshPlayerList`. If
    you recall, the `Hub` property in the `ServiceConnection` class is `AsyncLazy<T>`.
    The first time we reference the `Hub` property, it will initialize itself, asynchronously,
    hence the `await` call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next method that is used from the `Lobby` page is `IssueChallenge`. The
    `IssueChallenge` method is called from the `Lobby` page when a player wishes to
    play a match against another player. The `IssueChallenge` method does not return
    any value since the actual response to the challenge will come back through the
    SignalR Hub. The method will send the request to the server and handle any errors,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the preceding code to the `GameService` class. The `SendChallengeResponse`
    method, which is called when the opposing player responds to a challenge, is very
    similar to the `IssueChallenge` method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `SendChallengeResponse` method to the `GameService` class. That completes
    the methods needed to support the `Lobby` page. The final page in our app is the
    `Game` page. There are three more methods that are needed by the `Game` page.
    Follow these steps to add them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `EndTurn` method, which will send the player’s move to the `Game` server,
    using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`EndTurn` is very similar to the `IssueChallenge` and `SendChallengeResponse`
    methods, with a minor exception: it returns the updated `Game` object and an error
    message if present.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`the` `GetPlayerId` method is a small helper function to search the `Players`
    list and return the `Player` instance that matches the ID passed in. Use the following
    code snippet to add the `GetPlayerById` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`the` `GetMatchById` method is the last method that will make a call to the
    backend. In this case, it will retrieve a `Match` object given an ID. Using the
    following code snippet, add `GetMatchById` to the `GameService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final piece to `the` `GameService` class is the handling of the events
    received through the SignalR Hub. To refresh our memory from *Chapter 9*, the
    backend functions will send the following events to the clients via SignalR:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerUpdatedEventArgs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChallengeEventArgs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameStartedEventArgs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameUpdatedEventArgs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will handle each of these events in the `GameService` method. To implement
    the handlers for these events, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `Hub` receives `PlayerUpdatedEventArgs`, we will need to update `Player`
    in the `Players` collection with the new values. We will create a helper function
    to handle that work, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PlayerStatusChangedHandler` method will locate the changed player in the
    `Players` collection and update the relevant fields of the instance or add it
    if it doesn’t exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To call `the` `PlayerStatusUpdateHandler` class when the `PlayerUpdated` event
    is received, add the following highlighted code to the `Connect` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other three events will send messages to the `ViewModel` instance using
    `WeakReferenceManager`. First, we need to add the message types, using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class named `ChallengeReceived` to the `Messages` folder in the `SticksAndStones.App`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the `ChallengeReceived.cs` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class named `MatchStarted` in the `Messages` folder of the `SticksAndStones.App`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the `MatchStarted.cs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class named `MatchUpdated` to the `SticksAndStones.App` project in
    the `Messages` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the `MatchUpdated.cs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To send a message when the event is received, add the following highlighted
    code to the `Connect` method in the `GameService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That concludes the `GameService` class. We have all the methods needed to interact
    with the backend functions and we are handling the events that are being sent
    to the clients. The next portion of the chapter will add the pages needed to present
    the screens to the user, starting with the **Connect** page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Connect page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Connect** page, as shown in *Figure 10**.6*, is the first screen a user
    is presented with after the app loads. The page contains four main elements: an
    entry box for the player’s gamer tag, an entry box for the player’s email address,
    an image control for the player’s avatar, and the **Connect** button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The Connect page](img/B19214_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The Connect page
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Connect** page will consist of several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A `ViewModel` file called `ConnectViewModel.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A XAML file called `ConnectView.xaml`, which contains the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code-behind file called `ConnectView.xaml.cs`, which will carry out the data-binding
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A XAML file containing the layout for a custom button control, called `ActivityButton.xaml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code-behind for `ActivityButton` in `ActivityButton.xaml.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin the implementation of the `ConnectViewModel` first.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ConnectViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ConnectViewModel` – along with `LobbyViewModel` and `GameView` model – will
    inherit from a single base class called `ViewModelBase`. The `ViewModelBase` class
    provides the necessary functionality to implement refreshing the page. Not all
    pages will use this feature, but it will be available. To add `ViewModelBase`,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `ViewModels` in the `SticksAndStones.App` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class named `ViewModelBase` in the `ViewModels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespace declarations at the top of the `ViewModelBase.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the class declaration to `public abstract partial` and derive the class
    from `ObservableRecipient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `private bool` field named `canRefresh` with the `ObservableProperty`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `private bool` field named `isRefreshing` with the `ObservableProperty`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `private` method named `CanExecuteRefresh` that takes no parameters and
    returns a `bool`. The method signature and implementation are in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `protected virtual` method named `RefreshInternal` that returns a
    `Task` and its implementation returns `Task.CompletedTask`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Refresh` method as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Refresh` method is a `Command`, meaning that it can be bound to XAML elements
    as `RefreshCommand`. The `CanExecuteRefresh` method is used to determine the enabled/disabled
    state for the command. The command itself flips the `IsRefreshing` Boolean and
    calls the `RefreshInternal` method where classes derived from `ViewModelBase`
    would put the specific implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that `ViewModelBase` has been implemented, we can implement `ConnectViewModel`.
    The `ConnectViewModel` class has bindable properties for the player’s gamer tag
    and email address and various states for commands. Finally, there is a command
    to establish a connection to the game services. Let’s implement the `ConnectViewModel`
    class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `ConnectViewModel` in the `ViewModels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the class definition to `public partial` and derive from `ViewModelBase`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ConnectViewModel` depends on `GameService` and the `Settings` service so let’s
    add a constructor to acquire them through dependency injection and `private` fields
    to store their values, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the `GameService` and `Settings` classes, you’ll need to add a namespace
    declaration to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `private string` field named `gamerTag` attributed with `ObservableProperty`
    to make it bindable, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `private string` field named `emailAddress` attributed with `ObservableProperty`
    to make it bindable, as shown in this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor for `ConnectViewModel`, initialize the bindable properties
    from the last time the user connected, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **Connect** page does not need to refresh the view, so disable that functionality
    by adding the following line of code to the beginning of the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the `Connect` command, we will need four things: a `string` indicating
    the status of the command, a `bool` to indicate the current state of the command,
    a method to return if the command is enabled, and the method for the command itself.
    To add the status as a string, add the following code above the constructor in
    the `ConnectViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We mark this field with `ObservableProperty` so that it is bindable into the
    view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add the `isConnecting` field to track the state of the command, add the
    following code under the `connectStatus` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `CanExecuteConnect` method will return `true` if the command is enabled,
    and `false` if not. Add the method using the following code snippet under the
    `isConnecting` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Connect` command will call a `Connect` method to establish the connection
    with the game server. This is mostly just to keep the methods small and manageable.
    Add the following private `Connect` method to the `ConnectViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will call the `Connect` method on the `GameService` class passing
    in the player details. If the connection is successful, then the user is navigated
    to the Lobby page, unless they are currently in a game, in which case, they are
    navigated to the Game page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigation in .NET MAUI Shell
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET MAUI, navigation is performed by calling `GotoAsync` from the `Shell`
    object. The `Shell` object can be obtained by either casting `App.Current.MainPage`
    to a `Shell` object, or by using the `Shell.Current` property. The route passed
    to `GotoAsync` can be either relative to the current location or absolute. The
    valid forms of relative and absolute routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`• route` – The route will be searched for upward from the current position
    and, if found, pushed onto the navigation stack'
  prefs: []
  type: TYPE_NORMAL
- en: '`• /route` – The route will be searched for downward from the current position
    and, if found, pushed onto the navigation stack'
  prefs: []
  type: TYPE_NORMAL
- en: '`• //route` – The route will be searched for upward from the current position
    and, if found, will replace the navigation stack'
  prefs: []
  type: TYPE_NORMAL
- en: '`• ///route` – The route will be searched for downward from the current position
    and, if found, will replace the navigation stack'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about routes and navigation, visit [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the method implementing the `Connect` command to the bottom of the `Connect`
    **ViewModel** class using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command is very straightforward. It sets the `IsConnecting` and `ConnectStatus`
    properties, then updates the `Player` values from the view. Then, it calls `Connect`,
    passing in the current `Player` instance. The ID of the returned player is captured
    and set back on `LastPlayer` in `Settings`. Finally, the `ConnectStatus` and `IsConnecting`
    properties are set back to their defaults.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To wrap things up, we need to add a couple of attributes to make sure that
    properties are updated appropriately as values change. For instance, when the
    `IsConnecting` property is changed, we need to ensure that the `CanExecuteConnect`
    method is evaluated again. To do this, we add the `NotifyCanExecuteChangeFor`
    attribute to the `IsConnecting` field, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `gamerTag` field and `emailAddress` field are also referenced in
    the `CanExecuteConnect` method, we should add the attribute to those fields as
    well, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have nearly completed `ConnectViewModel`. The final feature to implement
    is the handling of messages that we may receive from `GameService`. The `ObservableObject`
    implementation from `CommunityToolkit` provides a feature to make subscribing
    and unsubscribing to these messages clean. To implement the message handlers,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `private` method named `OnServiceError` to the `ConnectViewModel`
    class, using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will subscribe to the `ServiceError` messages from the `OnActivated` event
    method of the `ObservableObject` class, Add the following method to the `ConnectViewModel`
    class to subscribe to the `ServiceError` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To unsubscribe from the `ServiceError` messages, add the following method to
    the `ConnectViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor for `ConnectViewModel`, we need to enable the `OnActivated`
    and `OnDeactivated` events that are raised by `ObservableObject`. These events
    are the recommended places to subscribe and unsubscribe to messages. Add the following
    line of code to the end of the constructor to enable the events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting `IsActive` to `true` will cause the `OnActivated` event to fire. Setting
    it to `false` will cause the `OnDeactivated` event to fire.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To have the `OnDeactivated` event fire, we need to set `IsActive` to `false`.
    In the `Connect` method, add the highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `MauiProgram.cs` file in the `SticksAndStones.App` project and add
    the following highlighted line to register `ConnectViewModel` with dependency
    injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes the implementation of `ConnectViewModel`. The `ConnectViewModel`
    class controls the entry of the user’s gamer tag and email. It connects the user
    to the game server using their player details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Connect view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Connect` view looks fairly simple, but there is a lot to it. We will break
    down the creation of the view into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the `ActivityButton` control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ActivityButton` control is the button used to initiate a connection to
    the backend services. While a simple button might do the trick, what if we had
    an animation that indicated the `connect` operation was in progress and the text
    of the button updated as well? That is what `ActivityButton` will do, in a reusable
    control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating the images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few images used on this page. All of them were generated using AI.
    We’ll explore how that was done.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Building the view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where we bring `ActivityButton` together with our custom images and
    the built-in controls of .NET MAUI to make `ConnectView` appear as it does in
    the figures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s start by building the `ActivityButton` control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ActivityButton control
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So, what is this `ActivityButton` control? It’s basically a button with an `ActivityIndicator`
    that will only show up while the task behind the button is doing its work. The
    complexity of this control comes from the fact that we are making a general-purpose
    control instead of a specialized control. So, for all intents and purposes, it
    needs to act like a normal `Button` and `ActivityIndicator`. We are only going
    to implement the feature that we need for this application, but even then, it’s
    still a reusable control.
  prefs: []
  type: TYPE_NORMAL
- en: 'From `Button`, we want to have the following XAML attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text`, `FontFamily`, and `FontSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command` and `CommandParameter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From `ActivityIndicator`, we will have `IsRunning`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these XAML elements will be bindable, like their original properties.
    An example of what the XAML might look like for declaring this control as an element
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This listing comes from the actual XAML we will be creating for `ConnectView.xaml`
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attributes that are copied from the two underlying controls need to be
    able to bind to the view model. This requires that they are implemented as bound
    properties. To create a bound property, you need two things: a property and a
    `BindableProperty` that references the property. The `BindableProperty` provides
    the functionality to keep the view model property, which implements `INotifyPropertyChanged`,
    with the property of the control. Let’s create the `Command` bindable property
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Controls` in the `SticksAndStones.App` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new .NET MAUI `ContentView` (XAML) called `ActivityButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ActivityButton.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `public ICommand` property named `Command`, as shown in the following
    listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BindableProperty` properties have a circular reference with the properties
    they are bound to, so you will get red squigglies until we complete the next step.
    This looks like almost every other property we have created, except that the `get`
    and `set` methods are just delegating to the `GetValue` and `SetValue` methods,
    respectively. `GetValue` and `SetValue` are provided by the `BindableObject` class,
    which `ContentView` ultimately inherits from. `GetValue` and `SetValue` are the
    `BindableObject` equivalents to `INotifyPropertyChanged` for view models. Calling
    them not only stores the values but also sends notifications that the value has
    changed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the `BindableProperty` property for the `Command` property, using
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CommandProperty` is of the `BindableProperty` type and is created by using
    the `Create` factory method of the `BindableProperty` class. We pass in the name
    of the property we are binding to (`Command`), the type that property returns
    (`Icommand`), the declaring type (which is `ActivityButton` in this case), and
    then what mode we want the binding to have. There are four options for `BindingMode`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OneWay` – The default, propagates changes from the source (the view model)
    to the target (the control)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneWayToSource` – This is the reverse of `OneWay`, propagating changes from
    the target (the control) to the source (the view model)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoWay` – This propagates changes in both directions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneTime` – This propagates the changes only when `BindingContext` changes
    and all `INotifyPropertyChanged` events are ignored'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These two pieces – the normal property that you would use in most of your C#
    classes, and `BindableProperty` – provide the complete functionality we need to
    create the custom control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we understand how to implement `BindableProperty` on a XAML control,
    we can complete the implementation of `ActivityButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by updating the XAML and then we will follow that with the remaining
    `BindableProperty` implementations. The following steps will walk you through
    creating the control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template we chose to create the XAML and `.cs` files is not quite what
    we need for `ActivityButton`. We will need to alter the underlying root control
    from `ContentView` to `Frame`. We use `Frame` to wrap our layout with a border.
    Open the `ActivityButton.cs` file and update the class definition to inherit from
    `Frame` instead of `ContentView`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Frame
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Class="SticksAndStones.Controls.ActivityButton">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ContentView to Frame, also remove the contents of Frame as we won’t be reusing
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s name our control to make it easier to reference it later. Typically, in
    C#, if you want to reference the instance of the class, you will use the `this`
    keyword. That doesn’t exist by default in XAML so add the `x:Name` attribute with
    the value of `this` to mimic C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `Frame` element and add the `BackgroundColor` attribute with a value
    of `{x:StaticResource Primary}`. `Primary` is defined in the `Resources/Styles/Colors.xaml`
    file and we can reference it using the `StaticResource` extension method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `Frame` element and add the `CornerRadius` attribute with a value
    of `5`. This will give our button rounded corners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Padding` attribute with a value of `12` to the `Frame` element. This
    will ensure that there is plenty of whitespace around the control. The `Frame`
    element should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get `ActivityIndicator` and `Label` centered side by side within `Frame`,
    we will use `HorizontalStackLayout` contained in `VerticalStackLayout`. `StackLayout`
    controls ignore the alignment options for the direction of the control, so, for
    example, `VerticalStackLayout` ignores the `VerticalOptions` property of its children
    and `HorizontalStackLayout` ignores the `HorizontalOptions` property of its children.
    This is because, by its nature, `HorizontalStackLayout` is in control of laying
    out its children in the horizontal plane, and the same is true for `VerticalStackLayout`,
    except in the vertical plane. Add the following highlighted code to the XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `HorizontalStackLayout` element, add the following XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ActivityIndicator` will have a `Height` and `Width` value of `15` and a `Color`
    value of `White`. The `IsRunning` and `IsVisible` properties are bound to the
    control’s `IsRunning` property. We haven’t created the `IsRunning` property yet,
    so this won’t work until we do. The `x:Reference` markup extension allows us to
    bind the property to the parent control, which we named `this` in *step 3*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can add `Label` within `HorizontalStackLayout` using the following
    XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user taps or clicks anywhere in `Frame`, `Command` should be run.
    To configure that, we will use `GestureRecognizer`. `GestureRecognizer` is XAML’s
    way of providing event handlers. There are several different kinds of `GestureRecognizer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DragGestureRecognizer` and `DropGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PanGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PinchGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PointerGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwipeGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TapGestureRecognizer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `ActivityButton`, we are interested in `TapGestureRecognizer`. Since the
    action to take is undefined until this control is used on a view, `TapGestureRecognizer`
    will invoke a command when `Frame` is tapped. Add the following XAML to the `Frame`
    element to create `TapGestureRecognizer`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Command` attribute and the `CommandParameter` attribute of `TapGestureRecognizer`
    are set to bind to the parent controls’ `Command` and `CommandParameter` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the `IsRunning` property is `true`, then `Frame` should be disabled, and
    the reverse is true as well. `DataTrigger` is a XAML way of setting properties
    of one control based on changes in another control’s properties. To add the triggers
    for `Frame`, add the highlighted XAML to the control:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That concludes the XAML portion of the control. Open the `ActivityButton.xaml.cs`
    file and we can add the missing properties, starting with `CommandParameter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the previous code listing to the `ActivityButton` class. Other than the
    name, there isn’t anything significant about this property from the `Command`
    property. `CommandParameter` allows you to specify parameters to pass to `Command`,
    but using XAML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Label` control is populated from the `Text` property. To add the `Text`
    property, add the following code to the `ActivityButton` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of the `Text` property, `returnType` has changed to `string`, but
    otherwise, it’s similar to `Command` and `CommandParameter`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next property we need to implement is the `IsRunning` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To allow the size and font of the text to be changed, we implement the `FontSize`
    and `FontFamily` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completed `ActivityButton`. We will use `ActivityButton` in the *Creating
    the Connect view* section right after we create the images we need for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images using Bing Image Creator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a few images that are used in the game. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A horizontal stick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vertical stick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pile of stones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating these images can be quite time-consuming and, based on your artistic
    abilities, not quite what you expected. It is quite possible that for your app
    you may opt to hire a graphics designer or artist to create your digital assets
    for you. Recently, a new option has become available, and that is to use AI to
    generate images. In this section, we will look at how to use **Bing Image Creator**
    to create the images that are needed for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Bing Image Creator uses an English description of the scene that you would like
    to see and attempts to create it. There are a few keywords that you can use to
    direct the Image Creator in the artistic style of the image to create, such as
    *game art*, *digital art*, or *photorealistic*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by creating the stick image:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://bing.com/create](https://bing.com/create) in Microsoft Edge or
    your favorite web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If asked, log in with your Microsoft account. This can be the same account that
    you used in *Chapter 9* to log in to the Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the prompt box, type in the following prompt, then press **Create**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Image Creator will generate four different images based on your description.
    If you aren’t satisfied with the result, adjust the description slightly and try
    again. The more descriptive you are, the better your result. Try to get a stick
    that is nearly vertical or horizontal since it will be easier to rotate and crop
    the image. It will also look much better if it is on a bright white background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.7 – An Image Creator sample set of images](img/B19214_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – An Image Creator sample set of images
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an image you are satisfied with, click on the image to open it
    up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Download** button to save the image to your local computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the downloaded file in your favorite image editor. The images created
    by Image Creator are roughly 1024 x 1024, and ideally, the image should be a 3:9
    ratio, or around 300 x 900 pixels. Using your image editor tools, crop the image
    so that it is roughly 300 x 900 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the image as either `hstick.jpeg` if the stick is orientated horizontally,
    or `vstick.jpeg` if vertically, in the `Resources/Images` folder of the `SticksAndStones.App`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the same image editing tools, rotate the image 90 degrees so that it is
    the opposite orientation and save the image in the `Resources/``I``mages` folder
    as `hstick.jpeg` if the stick is now orientated horizontally, or `vstick.jpeg`
    if vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have nearly half of the images that we need to create. Let’s work on creating
    the stones next:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://bing.com/create](https://bing.com/create) in Microsoft Edge or
    your favorite web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If asked, log in with your Microsoft account. This can be the same account that
    you used in *Chapter 9* to log in to the Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the prompt box, type in the following prompt, then press **Create**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Work the prompt to get three stones nicely piled together, preferably on a
    white background, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Three stones on a white background](img/B19214_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Three stones on a white background
  prefs: []
  type: TYPE_NORMAL
- en: When you are satisfied with the generated image, click the image to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Download** button to save the image to your local computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the downloaded file in your favorite image editor. Since the stones
    are supposed to be a square image, we can just save the file into the `Resources/Images`
    folder as `stones.jpeg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t have an image editor?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t have a favorite image editor? If you are on Windows, Paint does the job
    nicely, or you can use Visual Studio to edit images. On macOS, you can use Preview.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent, we now have the sticks and the stones needed to play the game, and
    that concludes the use of Image Creator to generate our game’s images. You can
    always go back to the site and review previous results, which is a nice feature.
    Now, we can move forward with creating the `Connect` view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Connect view
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Connect` view is the first UI other than the splash screen the user is
    going to see in the app. *Figure 10**.6* provides a representation of what the
    final view will look like. The images may be different if you decide to generate
    your own of course. We will break this section into three parts. First, we will
    create the top portion of the view containing the static content, then move on
    to creating the middle portion of the view containing the entry controls, and
    then, finally, the **Connect** button. Let’s get started with the top section
    of the view by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SticksAndStones.App` project, create a folder named `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show** **All** **Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `ConnectView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)](img/B19214_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)
  prefs: []
  type: TYPE_NORMAL
- en: Change the title of the view to `Sticks &amp; Stones`. Since XAML is a dialect
    of XML, the ampersand (`&`) must be escaped as `&amp;` in the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted namespaces to the `ContentView` element. They
    will provide us access to the classes in the `ViewModels`, `Controls`, and `Toolkit`
    namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `ContentView` element, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We don’t want the user to use any navigation, such as the `Shell`-provided
    `Back` button, other than what is provided on this page, so disable it using the
    highlighted code in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Class=“SticksAndStones.Views.ConnectView”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:DataType=“viewModels:ConnectViewModel”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Title=“Sticks &amp; Stones”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NavigationPage.HasNavigationBar=“False”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Grid control that has four rows defined; add the following code within the
    ContentPage element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Grid` uses a `Margin` value of `40` to provide plenty of whitespace around
    the images and controls. The first row at `8` units will contain the logo for
    the app. The second row will contain the text `Sticks & Stones`. The third row
    will have the avatar image, email, and gamer tag entry controls. The final row
    will contain the `Connect` button.Recall that the `Height` units are relative,
    so row `0`, the first row, will be four times higher than row `1` and eight times
    higher than row `3`, the final row. The `*` symbol in the `Height` value indicates
    that the row can expand if needed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To arrange our generated images into a box-like layout, another `Grid` control
    is used. Add the following listing to the view between the `</Grid.RowDefinitions>`
    and `</``Grid>` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `Grid` control defines three rows and three columns. The content of `Grid`
    is entirely made up of `Image` controls. `Grid` is positioned in row `0` of its
    parent `Grid`. The children of the grid, the `Image` controls, are positioned
    by setting the `Grid.Row` and `Grid.Column` attributes on the `Image` control.
    The stick images use the `Aspect` attribute set to `Fill`. `Fill` allows the image
    to scale to completely fill the content area; to do so, it may not scale uniformly
    along both the *x* and *y* axis. The stones use an `Aspect` value of `AspectFit`.
    This will uniformly scale the image till at least one side fits, which may cause
    letterboxing. There are two more options for the `Aspect` property: `Center`,
    which does no scaling, and `AspectFill`, which will scale until both axes have
    filled the view, which may cause clipping.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`A Label` element containing the text `Connect to Sticks & Stones` is added
    to the outer `Grid` control and it’s placed in row `1`, which is the second row
    of `Grid`. Add the following code to the outer `Grid` control after the inner
    `Grid` control added in *step 11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next section of the page contains the avatar image, gamer tag entry, and
    email entry controls. `HorizontalStackLayout` and `VerticalStackLayout` controls
    are used to arrange the controls. Add the following snippet to the outer `Grid`
    control after the `Label` control added in *step 12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `HorizontalStackLayout` control is assigned to the `Grid` row `2`, the
    third row. It is also centered horizontally within the row. The first `VerticalStackLayout`
    arranges the controls that make up the avatar. It contains an `Image` element,
    whose source is set to an instance of `GravatarImageSource`. `GravatarImageSource`
    uses the `EmailAddress` property of `ConnectViewModel` is bound to the `Email`
    property of `GravatarImageSource`. The image will automatically update on changes
    to `EmailAddress`. The `Image` property uses the `MysteryPerson` value to provide
    a plain profile when there isn’t a Gravatar available for the email address. The
    second `VerticalStackLayout` contains two `Entry` controls: the first, for the
    gamer tag, is bound to the `Username` property of `ConnectViewModel`, and the
    second is bound to the `EmailAddress` property of `ConnectViewModel`. The `Keyboard`
    attribute determines which virtual keyboard is displayed when the focus is on
    the control. See [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard)
    for more information on customizing the keyboard.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final control to add to `ConnectView` is the `Connect` button. Use the
    following snippet to add the button to the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Connect` button uses the `ActivityButton` control created in the *Creating
    the ActivityButton control*. The control is positioned in row `3`, the fourth
    row, and the `IsRunning` attribute is bound to the `ConnectViewModel.IsConnecting`
    method. The `Text` attribute of the button is bound to the `ConnectViewModel.ConnectStatus`
    property, and finally, `Command` is bound to the `ConnectViewModel.Connect` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MauiProgram.cs` file in the `SticksAndStones.App` project and add
    the following highlighted line to register `ConnectView` with dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to consume the `ConnectViewModel` instance through dependency
    injection and set it as the binding object. Open the `ConnectView.Xaml.cs` file
    and modify it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to set `ConnectView` as the first view displayed. Open the
    `AppShell.xaml` file in the `SticksAndStones.App` project and update the contents
    of the `Shell` element as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first of the three views in the app is complete. To test it out, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, right-click the `SticksAndStones.Functions` project in **Solution
    Explorer**, then select **Debug** | **Start** **Without Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `SticksAndStones.App` project and select **Set as** **Startup Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F5* to start the `SticksAndStones.App` project using the debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Lobby` page, which will allow us to start games with other players.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lobby page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Lobby` page displays the list of connected players and allows a player
    to challenge another to a match. As additional players connect to the server,
    they are added to the list of available players. *Figure 10**.10* shows the two
    views for the page, one with connected players, and the empty view when there
    are no additional players connected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The Lobby views](img/B19214_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The Lobby views
  prefs: []
  type: TYPE_NORMAL
- en: Each player is displayed on a card with their avatar image, gamer tag, status,
    and a button to allow the player to challenge the other to a match.
  prefs: []
  type: TYPE_NORMAL
- en: This page is comprised of two `ViewModel` classes, not one. As you might expect,
    there is the `LobbyViewModel` class, the `LobbyViewModel` which class has a collection
    of `PlayerViewModel` instances. In addition to the `ViewModel` classes, there
    is the `LobbyView` class. Let’s get started by creating the `PlayerViewModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding PlayerViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PlayerViewModel` is very much like all our other `ViewModel` classes but with
    one slight difference: it isn’t bound directly to a view in the same way. Otherwise,
    it has the same purpose: abstract the model, in this case, `Player`, away from
    the UI that displays it. `PlayerViewModel` provides all the needed binding properties
    to display each individual player card in `LobbyView`. To add `PlayerViewModel`,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SticksAndStones.App` project, under the `ViewModels` folder, create
    a new class named `PlayerViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespaces to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds two `private` fields to hold the values of the arguments passed to
    the constructor. As with `ConnectViewModel`, the constructor arguments are provided
    by dependency injection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The player card displays the player’s gamer tag, avatar, and status. Add the
    following code to the `PlayerViewModel` class to add the `Id` and `GamerTag` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `PlayerViewModel`, some of the properties that we bind to are not implemented
    with `ObservablePropertyAttribute`. That is because we are providing their values
    from the `Player` model directly. So, the `get` method of the property just returns
    the corresponding property of the model object. There is no defined `set` method,
    so this property is essentially a one-way data binding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Status` property is a little different since it does not exist on our
    `Player` model. The `Status` property is a textual indication of whether the player
    is in a match or not. The `Player` model does have a `MatchId` property, so if
    the `Player` model has a valid `MatchId` (i.e., not `Guid.Empty`), then the status
    would be `"In a match"`; otherwise, that status would be `"Waiting for opponent"`.
    Add the following code to `PlayerViewModel` to implement the `Status` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `IsInMatch` property is used to simplify the `Status` property implementation.
    It will also be used later in the class. The `Status` property is a simple switch
    on `IsInMatch` and returns the proper `string` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add a command to handle the `Challenge` button, add the following code to
    the `PlayerViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command is prevented from executing while it is currently waiting for a
    challenge response, which makes sense – no need to nag the other player. The `IsChallenging`
    property is set to `true` while challenging and `false` when it is complete. The
    `CanChallenge` property is a combination of `IsInMatch` and `IsChallenging`, meaning
    that you can’t challenge the same player while you have an existing challenge
    in progress, and you can’t challenge a player who is already in a match with another
    player. `ChallengeStatus`, which is used as the text for the button, is bound
    to the `IsChallenging` value and updates when that property is updated. You may
    have noticed that our command takes a single parameter. This is used to operate
    on the correct player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That completes `PlayerViewModel`. Next, `LobbyViewModel` is used to encapsulate
    the collection of `PlayerViewModel` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding LobbyViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LobbyViewModel` is a fairly straightforward implementation. It has a collection
    of `PlayerViewModel` objects that are exposed to the UI, it allows the user to
    pull to refresh the view, and it handles the messages of `ChallengeReceived`,
    `MatchStarted`, and `ServiceError`. Follow these steps to implement `LobbyViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SticksAndStones.App` project, inside the `ViewModels` folder, create
    a new class named `LobbyViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespaces to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the class declaration to a `public partial` class that inherits from
    `ViewModelBase`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private readonly GameService gameService;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public ObservableCollection<PlayerViewModel> Players { get; init; }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public LobbyViewModel(GameService gameService)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this.gameService = gameService;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Players = new(from p in gameService.Players
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where p.Id != gameService.CurrentPlayer.Id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: select new PlayerViewModel(p, gameService));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CanRefresh = true;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IsActive = true;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `GameService.Players` list will be updated as players connect to the server.
    However, these changes do not get propagated to the `LobbyViewModel.Players` collection
    automatically. By implementing a handler for the `CollectionChanged` event of
    the `GameService.Players` property, we can then update the `LobbyViewModel.Players`
    collection appropriately. Add the following method to the `LobbyViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OnPlayersCollectionChanged` method is an implementation of `Notify` **CollectionChangedEventHandler**.
    It is called by the `Observable` **Collection.CollectionChanged** event. The event
    is called whenever an item in the collection is added, removed, or updated. It
    is also called when the entire collection is cleared. This method handled the
    `NotifyCollectionChangedAction` values of `Add`, `Remove`, and `Reset`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Players.CollectionChanged` event is assigned to the `OnPlayers` **CollectionChanged**
    method in the `OnActivated` event handler. Add the `OnActivated` and `OnDeactivated`
    methods using the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `OnActivated` method, the `CollectionChanged` event is assigned to the
    `OnPlayersCollectionChanged` method and unassigned in the `OnDeactivated` method.
    In `OnActivated`, there is also a check to see whether the player is already in
    a match. If they are, then the app navigates to the `Match` view immediately.
    When navigating to the `Match` view, we send an argument for `Match`. This will
    be either the `MatchId` or the `Match` model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Constants.cs` file in the `SticksAndStones.Shared` project to add
    the following code snippet to the `Constants` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While in the Lobby, there are three messages that need to be handled: `ChallengeReceived`,
    `MatchStarted`, and `ServerError`. Add the code in the following listing to add
    the handlers for each of these messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `OnChallengeReceived`, the user is prompted to accept or decline the challenge.
    Their response is then sent to the challenger via the `SendChallengeResponse`
    method of the `GameService` class. `OnMatchStarted` will navigate the user to
    the `Match` view. Finally, `OnServiceError` will display the error to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following snippet to the top of the `OnActivated` method to register
    to receive the messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following snippet to the end of the `OnDecactived` method to stop receiving
    messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To refresh the `Players` list when the user pulls down on the list in the UI,
    add the following method to the `LobbyViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LobbyViewModel` needs to be registered with dependency injection, so open
    the `MauiProgram.cs` file and add the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LobbyViewModel` is now complete, and it is time to create the view!'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Lobby view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`The Lobby` view simply displays a list of connected players with their avatar,
    gamertag and current status. To build the `LobbyView` follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Views` folder of the `SticksAndStone.App` project, select
    **Add**, and then click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `LobbyView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B19214_10_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.11 – Adding a new .NET MAUI ContentPage (XAML)
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `LobbyView.xaml.cs` file and add the following `using` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the following highlighted changes to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These changes allow for dependency injection to supply the `LobbyViewModel`
    instance to the view, which is then assigned to `BindingContext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `AppShell.xaml` file and add the following code snippet to the `ContentPage`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers the `"Lobby"` route and directs it to `LobbyView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will register `LobbyView` with dependency injection so that `DataTemplate`
    can locate it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `LobbyView.xaml` file and change the `Title` attribute of the `ContentPage`
    element to `"Lobby"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted namespaces to the `LobbyView` element; they will
    provide us access to the classes in the `ViewModels`, `Controls`, and `Toolkit`
    namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `LobbyView` element, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We don’t want the user to use any navigation, such as the `Shell`-provided
    `Back` button, other than what is provided on this page, so disable it using the
    highlighted code in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:controls=“clr-namespace:SticksAndStones.Controls”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Class=“SticksAndStones.Views.ConnectView”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:DataType=“viewModels:ConnectViewModel”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Title=“ConnectView”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NavigationPage.HasNavigationBar=“False”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ContentPage with the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `LobbyView`, there is a vertical scrolling list of players. The root element
    is `RefreshView`. Its `IsRefreshing` attribute is bound to the `IsRefreshing`
    property of `LobbyViewModel`. `The` `Command` attribute for `RefreshView` is bound
    to `RefreshCommand`, which will end up executing the `RefreshInternal` method
    of `LobbyViewModel`. `IsRefreshing` and `RefreshCommand` are implemented in the
    `BaseViewModel` class. Inside `RefreshView` is `ScrollView`, which provides scrolling
    capability to have a large list. Inside `ScrollView` is `CollectionView`, which
    will display each `Player` instance as an individual item, so `ItemsSource` is
    bound to the `Players` property of `LobbyViewModel`. As there is no real need
    to select individual `Player` items, `SelectionMode` is set to `none`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the list is empty, it is nice to display something to the user so that
    they aren’t left wondering what happened. `CollectionView` has an `EmptyView`
    property that is used to configure what is displayed when there are no items.
    Add the following code snippet immediately following the `ContentPage` start opening
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a page resource containing `ContentView` with a `Key` value of
    `"BasicEmptyView"`. The view contains `StackLayout`, which has `Label` as a child
    with the text `"No players available"`. Appropriate styling is applied to make
    sure it’s large enough and has enough surrounding whitespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following attribute to the `CollectionView` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This binds `BasicEmptyView` to the `EmptyView` property of `CollectionView`.
    *Figure 10**.12* shows the result if you run the app and log in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Lobby with no players](img/B19214_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Lobby with no players
  prefs: []
  type: TYPE_NORMAL
- en: 'The player card will also use a static resource, which just makes the file
    a little easier to read, and less indenting. Add the following code snippet to
    the `ContentView.Resources` element, under the `BasicEmptyView` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DataTemplate` will display the player’s avatar. To do so, it will use an `Image`
    control and `GravatarImageSource` the same way as was done in the *Creating the
    Connect view* section. A `DataTemplate` element is needed since this is used for
    `ItemTemplate`, then the obligatory `ContentView`. Then, `Border` is defined.
    It uses a special `Stroke` shape to round out the edges of the rectangle instead
    of having square corners, and a color of `AntiqueWhite` is applied as the `BackgroundColor`
    value. Additional shapes to use for `Border` include `Ellipse`, `Line`, `Path`,
    `Polygon`, `Polyline`, and `Rectangle`. See the `Border` documentation at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border)
    for more details. Inside `Border`, there is a `Grid` control that defines three
    columns. The first column contains the avatar image and has a width of `50`, the
    next column contains the gamer tag and the status of the player, stacked vertically,
    and the third column contains the `Challenge` button.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the avatar, the `AvatarView` control from `CommunityToolkit` is used. It
    provides a round version of the image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Challenge` button uses the `ActivityButton` control, and is bound to the
    `IsChallenging`, `CanChallenge`, `ChallengeStatus`, and `ChallengeCommand` properties
    of `PlayerViewModel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use `PlayerCardViewTemplate` as `ItemTemplate` of `CollectionView`, add
    the following attribute to the `CollectionView` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the `Lobby` page. At this point, you should be able to launch
    `SticksAndStone.Functions` and connect with the `SticksAndStones.App` project
    to see the different layouts provided by the `Lobby` view. There is only one more
    page to create to complete the game, and that is the `Match` page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Match page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Match` page displays the game board with the players and score. It also
    manages the gameplay, allowing each player to take their turn placing a stick.
    As each player takes their turn, the board updates to show the current state of
    the match. Let’s get started with creating the `ViewModel` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ViewModel classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two different `ViewModel` classes used in the `Match` page, just as
    there were in the `Lobby` page, one for the game and a second for the player details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding MatchPlayerViewModel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`MatchPlayerViewModel` is the abstraction between the `Player` model and `MatchView`.
    `MatchPlayerViewModel` needs to expose the `Id`, `GamerTag`, and `EmailAddress`
    values from the `Player` model to `MatchView`. In addition, since each player
    has a score, the player’s score from the `Match` model is exposed to `MatchView`.
    There are a couple of additional properties that are needed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsPlayersTurn`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is used to determine whether `MatchPlayerViewModel` is the current player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PlayerToken`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is used to map each player to a token to track which player has placed
    which stick. A token, either `-1` or `1`, is used because it makes determining
    a winner easier than if it was using the `Id` property, which is a `Guid`. Review
    the *Processing turns section of* *Chapter 9*, for a refresher on how the winner
    is determined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create `MatchPlayerViewModel`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `MatchPlayerViewModel` in the `ViewModels` folder of
    the `SticksAndStones.App` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `using` declarations to the following at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `public` and `partial` modifiers to the class and make it inherit from
    `ObservableObject`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MatchPlayerViewModel` is an abstraction of both the `Player` and `Match` models,
    which will be passed in through the constructor. Create the fields and the constructor,
    as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `PlayerToken` property is `1` if the `Player` model is `PlayerOne` in the
    `Match` model; otherwise, it is `-1`. Add the `PlayerToken` property using as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `IsPlayersTurn` property will return `true` if the `Player` model is the
    `NextPlayer` of the `Match` model, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Id`, `GamerTag`, and `EmailAddress` properties all just map directly to
    the corresponding property from the `Player` model. This is the same implementation
    that was used in `PlayerViewModel` for the `Lobby` page. Use the following listing
    to add the properties to `MatchPlayerViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final property that is needed for `MatchPlayerViewModel` is the `Score`
    property. The `Score` property is mapped to either the `PlayerOneScore` or `PlayerTwoScore`
    property from the `Match` model, depending on which player the `Player` model
    is. Use the following listing to add the `Score` property to `MatchPlayerViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all there is to `MatchPlayerViewModel`. The next section will walk you
    through creating `MatchViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding MatchViewModel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`MatchViewModel` needs to provide the functionality for all the gameplay. It
    provides the two `MatchPlayerViewModel` objects for display in the header of the
    page, and the board to display where sticks have been played and which stones
    have been captured. It also provides the needed functionality for players to take
    their turn and forfeit the game if they choose. To implement `MatchViewModel`,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `ViewModels` folder of the `SticksAndStones.App` project
    named `MatchViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `using` declarations section at the top of the page to match the
    following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `public` and `partial` class modifiers to the class, inherit from `ViewModelBase`,
    and implement `IQueryAttributable`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recall that in `ConnectViewModel` and `LobbyViewModel`, when they navigate to
    `Match`, they pass an argument – either `MatchId` or the `Match` instance itself.
    `IQueryAttributable` is how that argument is passed to `MatchViewModel`. The implementation
    for `IQueryAttributable` is provided in a later step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MatchViewModel` only has a single dependency, `GameService`, so add a field
    to store the instance and a constructor to accept the instance as a parameter,
    as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `MatchViewModel` is loaded, it will need to process the arguments, either
    the `Match` instance or a `MatchId` value. Either argument will end up with a
    `Match` instance that is used for displaying the board in the view, and from that,
    create two instances of `MatchPlayerViewModel` for player one and player two.
    Add `match`, `playerOne`, and `playerTwo` fields to the `MatchViewModel` class
    to hold those instances, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IQueryAttributable` is used to process the arguments passed to the view model.
    Well, it is one way of doing it. The `IQueryAttributable` interface has only one
    method defined, `ApplyQueryAttributes`. The .NET MAUI routing system will automatically
    call the `ApplyQueryAttributes` method if the view model implements the `IQueryAttributable`
    interface. To add the implementation for `IQueryAttributable`, use the following
    listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ApplyQueryAttributes` has a single parameter query, which is a dictionary
    of key-value pairs with the key as a string and the value as an object. The key
    ID is the name of the parameter as was passed in – for example, `"Match"` or `"MatchId"`.
    The method will check for the existence of the `"Match"` key being present and
    get the value as `Match` if it is. If the `"MatchId"` key is present, then `GameService`
    is used to get the `Match` model from `Id`. If there is no value for `match`,
    then the method returns; otherwise; initialize the two instances of `GamePlayerViewModel`
    and store them and `Match` in the `ViewModel` properties. The `LoadMatch` method
    is called from `ApplyQueryAttributes` since we will need the same functionality
    when the `UpdateMatch` event is received.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we can allow a player to choose a location to place a stick, it must
    be their turn. Create a property named `IsCurrentPlayersTurn` using the following
    listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Anytime the `Match` object is updated, `IsCurrentPlayersTurn` needs to be updated
    as well, since it depends on values in the `Match` property. To have this happen
    automatically, use the `NotifyPropertyChangedFor` attribute from `CommunityToolkit`.
    Add the highlighted line in the following code listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, whenever the `Match` property is changed, the `NotfiyPropertyChanged` method
    will also be called for `IsCurrentPlayersTurn`. See *the Defining a ViewModel
    base class* sectionin *Chapter 2*, for a refresher on implementing the `INotifyPropertyChanged`
    interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The game allows the player to try out different positions of the stick before
    committing. If this is the current player’s turn, the one connected and using
    the app, then the `SelectStick` method will place a stick at the location chosen
    by the user. The choice is not sent to the server until the user clicks the `lastSelectedStick`
    field. Add the following listing to implement the `SelectStick` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The value of `-1` for `lastSelectedStick` is used to mean no stick. The `SelectStick`
    method is exposed as a `Command` instance via `RelayCommandAttribute`. The `Is`
    **CurrentPlayersTurn** property is used to determine whether the command can execute.
    Recall from *Chapter 9* that the `Sticks` elements will have one of three values:
    `-1` for player one, `0` for empty, and `1` for player two. After determining
    whether the stick position is valid, the method raises the `OnPropertyChanged`
    event for the `Match` property, which causes the bindings to update.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After deliberating on which position to place their next stick, the player
    has three options: send their move to the server and end their turn, be indecisive
    and undo their move, or give up and exit the match. Add the `Play` method to `MatchViewModel`
    using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Play` method is exposed as a `Command` so that it can be bound to by UI
    elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Undo` method is called when the player taps the `lastSelectedStick` position
    and the value of `lastSelectedStick`. Add the `Undo` method, as shown in the following
    code listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, the `RelayCommand` attribute is applied to the method to allow it to
    be bound to by UI elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Forfeit` method is called when the player uses the `Forfeit` method to
    the `MatchViewModel` class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the opposing player sends their move to the server, it is received in
    the app as a `MatchUpdated` event from the SignalR service. Add the handler for
    the `MatchUpdated` event using the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To register the `MatchUpdated` event handler, the `Register` method is called
    from `OnActivated`, and `UnRegister` is called from `OnDeactivated`, as shown
    in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register `MatchViewModel` with dependency injection by adding the following
    highlighted line of code to the `CreateMauiApp` method in the `MauiProgram.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why is it called IQueryAttributable? That feels awkward
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind the name of the interface is that naming things is hard. The
    system for passing arguments to a view model can be either declarative or not.
    The declarative way uses `QueryPropertyAttribute` to map the query parameter to
    a property on the view model. If you choose not to use the attributes, but instead
    handle the mapping yourself manually, you declare your class `IQueryAttributable`,
    as in I could have used `QueryPropertyAttribute` but I choose not to. For more
    information, visit [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Match view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This page is complex, so we are going to break it down into smaller, more manageable
    chunks. First, the basic page layout is defined including the commands that are
    available to the player: `Play`, `Undo`, and `Forfeit`. Next, the scoreboard area
    is defined with the player’s gamer tag, Gravatar, and scores. Finally, the game
    board is defined and laid out in a three-by-three grid. Let’s get started by creating
    the view and the layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the view
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Match` view is not unlike any of the other views that have been created
    except that it has many more elements than preview views. Let’s get started by
    creating the view and some basic elements by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Views` folder of the `SticksAndStone.App` project, select
    **Add**, and then click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up; otherwise, move to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `MatchView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)](img/B19214_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MatchView.xaml.cs` file and add the following `using` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the following highlighted changes to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These changes allow for dependency injection to supply the `MatchViewModel`
    instance to the view, which is then assigned to `BindingContext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `AppShell.xaml` file and add the following code snippet to the `ContentPage`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers the `"Match"` route and directs it to `MatchView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will register `MatchView` with dependency injection so that `DataTemplate`
    can locate it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `MatchView.xaml` file and remove the `Title` attribute of the `ContentPage`
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted namespaces to the `MatchView` element. They will
    provide us access to the classes in the `ViewModels`, `Converters`, and `Controls`
    namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make IntelliSense happy with the bindings we will be adding, define the
    view model that the view is using by adding the `x:DataType` attribute to the
    `MatchView` element, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MatchView` uses a few icons from the Font Awesome font library, so we will
    need to download and install the library so that it is available in the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and configuring Font Awesome
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Font Awesome is a free collection of images packaged into a font. .NET MAUI
    has excellent support for using Font Awesome in toolbars, navigation bars, and
    all over the place. It’s not strictly needed to make this app, but we think that
    it’s worth the extra round trip since you are most likely going to need something
    like this in your new killer app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Downloading the font is straightforward. Please note the renaming of the file
    – it is not really needed but it’s easier to edit configuration files and such
    if they have a simpler name. Follow these steps to acquire and copy the font to
    each project:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://fontawesome.com/download](https://fontawesome.com/download).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Free for Desktop** button to download Font Awesome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded file, then locate the `otfs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Font Awesome 5 Free-Solid-900.otf` file to `FontAwesome.otf` (you
    can keep the original name, but it’s just less to type if you rename it). Your
    filename may be different since Font Awesome is continually updating but it should
    be similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `FontAwesome.otf` to the `Resources/Fonts` folder in the `SticksAndStones.App`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It would be nice if all that was needed was to copy the font file into the
    project folders. A lot does happen with just that action. The default .NET MAUI
    template includes all the fonts in the `Resources/Fonts` folder with the following
    item definition in the `News.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the font files are processed and included in the app package
    automatically. What is left is to register the font with the .NET MAUI runtime
    so it is available to our XAML resources. To do that, add the following highlighted
    line to the `MauiProgram.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: This line adds an alias that we can use in the next section to create static
    resources. The first parameter is the filename for the font file, and the second
    is the alias for the font that you can use in the `FontFamily` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the layout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that Font Awesome is installed and configured in .NET MAUI, `TitleView`
    can use it. Add the custom title area and the main layout by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, override `TitleView` of the `Shell` element and provide a new container
    to hold the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The buttons are arranged in two segments, one aligned to the left or start of
    the window and the other aligned to the right or end of the window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The player can at any point decide they no longer wish to continue playing.
    To exit the match, the player can use the `Start` section of `TitleView` and bind
    `ForfeitCommand` in `MatchViewModel`, add the highlighted code from the following
    snippet :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When it is the player’s turn, they have two buttons that are enabled, `Play`
    and `Undo`. The `Play` and `Undo` buttons are placed in the `TitleView` area of
    the .NET MAUI page. Add the following highlighted code to add the `Play` and `Undo`
    buttons to `TitleView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the default `VerticalStackLayout` element in `ContentView` and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds a `Grid` control with four rows. The first and third rows will contain
    the scoreboard and the game board, respectively, while the second and fourth rows
    are padding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The main layout is ready. Next, the scoreboard is added to the first row of
    the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scoreboard
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The scoreboard contains each player’s avatar, gamer tag, and score. The elements
    are bound to the respective fields of `MatchPlayerViewModel` for the player. The
    `Match` object has two properties, `PlayerOne` and `PlayerTwo`, each of which
    is a `MatchPlayerViewModel`. To add the scoreboard, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each player is identified by a different color. To add each color as a resource,
    open the `Colors.xaml` file in the `Resources/Styles` folder of the `SticksAndStones.App`
    project and add the following lines to the `ResourceDictionary` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The scoreboard uses `HorizontalStackLayout` for the outer container. Add the
    following code to the `Grid` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HorizontalStackLayout` is assigned to row `0` of the `Grid`, and its contents
    are bound to the `Players` property of the view model, using `BindableLayout.ItemsSource`.
    `BindableLayout` is the underlying interface that supports all layout controls,
    such as `AbsoluteLayout` and `FlexLayout`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each player will have their own card within `HorizontalStackLayout`. Since
    the control is bound to the `Players` property, which is an array of `MatchPlayerViewModels`,
    the `BindableLayout.ItemTemplate` property provides the view that each item in
    `Players` is displayed with. The cards are laid out using a `Border` element and
    nested `VerticalStackLayout` elements. Add the following highlighted code to `HorizontalStackLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Border` element is the outermost container for the player card. To set
    the border color and background color of the `Border` element based on `PlayerToken`,
    triggers are used ([https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers))
    – specifically, `DataTrigger` is used to set attribute values based on some other
    value. Add the following code to the `Border` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DataTrigger` binding attribute is compared to the `Value` attribute. If
    they are equal, then the `Setter` elements of `DataTrigger` are executed. In this
    case, if the `PlayerToken` property is `-1`, then set the `Stroke` and `BackgroundColor`
    attributes of `Border` to the `PlayerOne` color that was defined in *step 1*.
    Otherwise, if the `PlayerToken` property is equal to `-1`, then set the `Stroke`
    and `BackgroundColor` attributes to the `PlayerTwo` color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`VerticalStackLayout` contains another `VerticalStackLayout` and `Border` element,
    as shown in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the second `VerticalStackLayout` are a `Label` and a `FlexLayout`. Add
    the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <FlexLayout Margin="3">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <toolkit:AvatarView FlexLayout.Order="0" Margin="0" BackgroundColor="LightGrey"
    HeightRequest="85" WidthRequest="85" CornerRadius="50" VerticalOptions="Center"
    HorizontalOptions="Center">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <toolkit:AvatarView.ImageSource>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <toolkit:GravatarImageSource
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Email="{Binding EmailAddress}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Image="MysteryPerson" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </toolkit:AvatarView.ImageSource>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <toolkit:AvatarView.Triggers>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <DataTrigger TargetType="toolkit:AvatarView" Binding="{Binding Path=PlayerToken}"
    Value="-1">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Setter Property="FlexLayout.Order" Value="1" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </DataTrigger>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </toolkit:AvatarView.Triggers>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </toolkit:AvatarView>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Label FlexLayout.Order="1" Text="{Binding Score}" FontSize="48" Padding="5"
    MinimumWidthRequest="65" HorizontalTextAlignment="Center">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Label.Triggers>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <DataTrigger TargetType="Label" Binding="{Binding Path=PlayerToken}" Value="-1">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Setter Property="FlexLayout.Order" Value="0" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </DataTrigger>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Label.Triggers>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Label>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FlexLayout control, the order in which the FlexLayout children are displayed
    is governed by the FlexLayout.Order attribute. Similar to Grid with its Grid.Row
    and Grid.Column properties on its children, the Order attribute is set on the
    child. The order of the children in FlexLayout is changed through the use of Trigger.
    On AvatarView, DataTrigger will set the FlexLayout.Order attribute to "1" if the
    PlayerToken property is equal to -1, which is PlayerTwo. On the Label, DataTrigger
    sets the FlexLayout.Order attribute to "0", effectively swapping the two elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that concludes the scoreboard. The final part of `MatchView` is the largest:
    the board. Read on to learn how to create the board visuals.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game board
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The game board is composed of three different elements. These elements are
    dots in the corners of each square, sticks (both horizontal and vertical), and
    stones. These elements are laid out as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The game board](img/B19214_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The game board
  prefs: []
  type: TYPE_NORMAL
- en: 'The board uses a `Grid` control to provide the basic layout. Using 7 columns
    and 7 rows will provide cells for each of the elements: 16 dots, 9 stones, and
    24 sticks. Add the following code to provide the basic layout of the game board
    to the top-level `Grid` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by adding the corners to the grid, since they are the simplest.
    To define a corner, use a `Label` with the text `"&#x26AB;"`, which is the hexadecimal
    character code for a dot. To center the dot horizontally and vertically, set `HorizontalOptions`
    and `VerticalOptions` to `"Center"`. Your basic element would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `Grid.Row` and `Grid.Column` attributes, the `Label` will be put
    into row `0` and column `0`. There are 16 corners in the grid, and they occupy
    all the even-numbered cells, so `(0,0)`, `(0,2)`, `(0,4)`, `(0,6)`, `(2,0)`, `(2,2)`,
    and so on. Fully defined labels for the first row would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'When you work this out for all 16 rows, that’s a lot of duplication of the
    `Text`, `HorizontalOptions`, and `VerticalOptions` attributes. By using a `Style`
    element, that duplication can be eliminated. A `Style` element contains `Setter`
    elements such as the `DataTrigger` elements. When `Style` is applied to the element,
    the `Setter` elements are used to update the target element’s attributes. Use
    the following steps to add the corner elements to the `Grid` control using `Style`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `Style` element to the `ContentPage.Resources` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `Style` element is identified by the `x:Key` attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a `Label` to the `Grid` control created at the start of this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Grid.Row` attribute of the `Label` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Grid.Column` attribute of the `Label` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Style` attribute to the `{StaticResource dotLabel}` value. The `Style`
    attribute is used to specify which style should be applied to the element. Since
    `Style` is defined in the `ContentView.Resources` element, it is a `StaticResource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The completed `Label` should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, copy the `Label` just created and increase the `Grid.Column` value by two,
    and repeat this step until you have four `Label` elements with the same `Grid.Row`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the last `Label` created in *step 7* and increase the `Grid.Row` value
    by two and reset the value of `Grid.Column` to `0`. Now, repeat *step 7* using
    the updated `Grid.Row` value, and stop when there are four labels with a `Grid.Row`
    value of `6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The labels should look like the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the corners are done, we can start on the game pieces: the sticks
    and stones. Since the sticks and stones have some similarities, we can create
    a common control to help display them all. However, they are visualized entirely
    differently. What is needed is a common interface to define the `BindableProperty`
    properties and use that on different layouts.`.NET` `MAUI` `uses` `ControlTemplate`
    resources to allow for the customization, or even complete replacement, of the
    visual elements that comprise a control. Many controls in .NET MAUI can be customized
    using a `ControlTemplate`, if they derive from `ContentView` or `ContentPage`.
    Let’s get started with the sticks and stones by adding the custom control, then
    the `ControlTemplate` resources for sticks and stones, by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `Controls` folder of the `SticksAndStones.App` project
    named `GamePieceView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the class definition to match the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `string` property and a `BindableProperty` property named `GamePiecePosition`
    and `GamePiecePositionProperty`, respectively, as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GamePiecePosition` is used to determine the array index in either `Sticks`
    or `Stones` properties on `GameViewModel`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an `int` property and `BindableProperty` named `GamePieceState` and `GamePieceStateProperty`,
    respectively, as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GamePieceState` is the owner of the piece: `1` for `PlayerOne`, `0` for no
    one, and `-1` for `PlayerTwo`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `string` property and `BindableProperty` named `GamePieceDirection` and
    `GamePieceDirectionProperty`, respectively, as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GamePieceDirection` is only needed for `Sticks` and is either `Horizontal`
    or `Vertical`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MatchView.Xaml` file again and let’s add a control template for all
    the sticks. Add the following snippet to the `ContentView.Resources` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a `ControlTemplate` element with a key of `StickViewControlTemplate`.
    The key is used to apply the `ControlTemplate` element to the control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are two elements to each stick visual: the number displayed on a label,
    and the stick image, which uses the `Image` control inside a border to give it
    the outline, colored by the player that placed the stick. The other interesting
    aspect is that the `Label` and `Border` controls need to be layered on top of
    one another. To accomplish this, a `Grid` control is used and both elements are
    placed in the same cell. To add the `Grid`, `Label`, `Border`, and `Image` controls,
    use the following listing, and add them to the `ControlTemplate` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Grid` has `Margin` and `Padding` values of `0` so that it doesn’t occupy any
    screen real estate. The `Label` control’s `Text` attribute is bound using `TemplateBinding`
    to the `GamePiecePosition` property. `TemplateBinding` differs slightly from `Binding`
    in that `TemplateBinding` uses the control this `ControlTemplate` is applied to
    as `DataContext`. Since this `ControlTemplate` will be applied to instances of
    `GamePieceView`, it will bind to the `Bindable` properties of those controls.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inspecting the `Image` control from *step 7*, you’ll find that it doesn’t specify
    which image is displayed. For `Sticks`, one of two images is displayed: either
    `hstick.jpeg` for horizontal sticks or `vstick.jpeg` for vertical sticks, and
    if there is no stick at that location, then the control should not be visible.
    The following listing uses `DataTrigger` to set the values of `IsVisible` and
    `Source` of the `Image` control using `TemplateBinding` to the `GamePieceState`
    and `GamePieceDirection` properties. Add this code to the `Image` control of `ControlTemplate`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Border` control also uses `DataTrigger` to outline the stick in the color
    of the player that placed the stick. Add the following code to the `Border` element,
    after `Image`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Two triggers are needed to switch between `PlayerOne` (`1`) and `PlayerTwo`
    (`-1`). The `Stroke` attribute of the `Border` control is set to the color resource
    of the player. If neither trigger is active, then the default `Stroke` value of
    `Transparent` from the `Border` element is used. In this way, if there is no stick,
    `GamePieceState` is `0`, and the border is transparent. If `GamePieceState` is
    `1`, then `Stroke` will have the color defined by the resource named `PlayerOne`,
    and if `GamePieceState` is `-1`, then the `Stroke` value will be the resource
    named `PlayerTwo`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the user is making their move during their turn, they will tap or click
    on the label to place their stick in that position. To call `SelectStickCommand`
    when that occurs, the `Border` control binds `TapGestureRecognizer` to the `GameViewModel.SelectStickCommand`
    property and passes `GamePiecePosition` along as a parameter. Add the following
    listing to the `Border` element, after the `Border.Triggers` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, take a close look at the `Label` element; you will see that the `IsVisible`
    attribute is set to `False`. If there is no stick placed at this position, then
    we need the label with the position displayed. That can be accomplished by using
    `DataTrigger`; the label’s `IsVisible` property can be set to `True`, making the
    label visible if `GamePieceState` is `0`, meaning no stick has been placed there
    yet. Add the following listing to the `Label` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That completes the control template for the sticks. Next, create the control
    template for `Stones` by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right below the `ControlTemplate` created for the sticks, add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like with the control template for sticks, the `ControlTemplate` uses a
    key to locate the right template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Stones` template is a little less complex than the `Sticks` template.
    Here, we just have the `Border` control with an `Image` control as a child. `DataTrigger`
    is used again to select the right border color, and if the stones are not present,
    then the border is not visible. Use the following code sample and add it to the
    `ControlTemplate` created in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may have noticed a difference between the triggers in this listing versus
    the triggers in the `Sticks` control template. In `Sticks`, the `IsVisible` attribute
    was set on `Image`, not `Border`, and you may want to know why that is. The explanation
    is simple; if the border is not visible, it will not receive `TapGuesture` events.
    The `Grid` element cannot register `GestureRecognizer`, so the event cannot be
    captured there either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `ControlTemplates` that are needed for the stick and stone images are in
    place; now, they need to be associated with the `GamePieceView` control elements.
    A `Style` can set the `ControlTemplate` property of a `GamePieceView` element,
    but how will it determine that this element is a stick or a stone? `Style` elements
    have a `Class` property that can be used to further refine which styles are applied
    to a control. If the control has a matching class name listed in its `StyleClass`
    attribute, then that `Style` element is applied. Let’s use sticks as an example,
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `Style` element to the `ContentView.Resources` element, as shown
    in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This style is only applied to elements that are of the `GamePiece` type and
    have the `Stick` class listed in the `StyleClass` attribute. A matching element
    might look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted sections show the parts of the control that are used to match
    the `Style` element. `StyleClass` can have more than one name listed; just use
    a comma to separate the names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new `Style` element. This time, it will be to apply `StoneViewControlTemplate`,
    as shown in the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all that is required for the stick and stone elements to be added to
    the game board grid. To add the remaining elements, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven rows of sticks: four rows of three and three rows of four.
    They are nearly identical, but not quite. Locate the `Grid` that defines the gameboard;
    it will already have the corner dots added. Right after the 16 dot elements, add
    the following listing for the first row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each stick in the first row is displayed horizontally. Each stick is given its
    own position in the `GamePiecePosition` attribute and `GamePieceState` is bound
    to the `Game.Sticks` object for this stick. The `Sticks` array is zero-based so
    the indexes for the array are one less than `GamePiecePosition`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the code for the second row of sticks using the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These elements are all `Vertical` instead of `Horizontal`; otherwise, they follow
    the same pattern as the previous step. Keep on going to add the remaining rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following listing to add the third row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following listing to add the fourth row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following listing to add the fifth row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following listing to add the sixth row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following listing to add the seventh row of sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sticks are all added, so now we need to add the stones. Use the following
    listing to add the nine `Stone` elements to the game board `Grid` control following
    the sticks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a wrap on the game app. You can now test out the project in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the completed project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project has spanned two chapters, with *Chapter 9**, Setting Up a Backend
    for a Game Using Azure Services , and this chapter, Building a Real-Time Game*.
    Since this is a two-player turn-based game, getting all the components configured
    correctly can be a challenge. Follow these steps to test out your game locally
    on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to get the service running in the background. In Visual Studio,
    right-click the `SticksAndStones.Functions` project and select **Debug** | **Start
    Without Debugging** or press *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Starting the Azure Functions service](img/B19214_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Starting the Azure Functions service
  prefs: []
  type: TYPE_NORMAL
- en: That should launch a terminal window with the Azure Functions service running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, two clients are needed to play the game. On Windows, that means the Windows
    client and the Android client. Start with the Windows client first, and use the
    same method that was used for Functions. Make sure the Windows target is selected
    in the **Debug** options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Selecting Windows as the Debug target](img/B19214_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Selecting Windows as the Debug target
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `SticksAndStones.App` project and then select **Debug** | **Start
    Without Debugging** or press *Ctrl* + *F5*. A new window should open with the
    login page displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, switch the **Debug** target to Android:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Selecting Android as the Debug target](img/B19214_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Selecting Android as the Debug target
  prefs: []
  type: TYPE_NORMAL
- en: Now, either use *F5* to debug the app in an Android emulator, or *Ctrl* + *F5*
    to just run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to each app using a different email and gamer tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Log in to the game](img/B19214_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Log in to the game
  prefs: []
  type: TYPE_NORMAL
- en: Challenge the other player to a match!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Challenge issued](img/B19214_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Challenge issued
  prefs: []
  type: TYPE_NORMAL
- en: Try to best yourself in a game of *Sticks* *and Stones*!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – The match has started](img/B19214_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – The match has started
  prefs: []
  type: TYPE_NORMAL
- en: 'Android: cleartext http traffic to 10.0.2.2 not permitted'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are attempting to test the game using the Android client, you will probably
    hit this error when you try to send a move to the server. Fortunately, the resolution
    is easy. Open the `MainApplication.cs` file in the `Platforms/Android` folder
    and modify the `Application` attribute on the `MainApplication` class to match
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Application(UsesCleartextTraffic =` `true)]`'
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter any errors or something just doesn’t work the way you expect
    it to, go back through all the steps and make sure you didn’t miss anything. Otherwise,
    congratulations on making it through this project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s that! Excellent work! There is so much in the chapter that it is hard
    to keep this summary short. In this chapter, we created a game app that connects
    to our backend. We created a service that managed the calls to the backend service
    and handled errors, all asynchronously. We have learned how to respond to messages
    from SignalR, and how to send and receive messages within the app using the `IMessenger`
    interface. We created custom controls and used them across multiple pages. We
    learned how to style an app with XAML styling, how to use control templates, and
    how to select them using styles. We explored routes and how they work in a multi-page
    .NET MAUI app. We examined triggers and how we can use them to update the interface
    without using C# code and converters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, reward yourself and challenge a friend to a match in your new game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into Blazor and .NET MAUI together.
  prefs: []
  type: TYPE_NORMAL
