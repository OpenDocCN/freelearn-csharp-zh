- en: Chapter 7. Storage and Logistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at how companies work with ERP in production
    and trade businesses. All these companies work together to bring finished products
    to the stores where end consumers can buy them.
  prefs: []
  type: TYPE_NORMAL
- en: During this process, the products move around between the companies. This is
    done using different kinds of transportation, such as trucks, ships, trains, and
    airplanes. It may also be necessary to store the products in a warehouse until
    they are sold or moved to the shops.
  prefs: []
  type: TYPE_NORMAL
- en: More and more companies make a decision to outsource logistics rather than having
    their own transportation. When this is the case, logistics can be a separate part
    of the supply chain. This chapter discusses the process and the effects on the
    ERP system.
  prefs: []
  type: TYPE_NORMAL
- en: One of the specific aspects of logistics companies is that the products they
    handle are not their property. Although they are a part of the total cost of the
    consumer product, they don't care about the detailed value of their inventory.
    Logistics companies sell warehouse handling, storage, and transportation as services.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV does not have built-in functionality to handle this so,
    in this chapter, we will discuss how to design an application to do this.
  prefs: []
  type: TYPE_NORMAL
- en: There are several add-on solutions for this business and in a real-world situation
    those add-ons should be evaluated as potential solutions. In this chapter, we
    will discuss how to design and create a basic framework for such an add-on application
    that can be easily extended without adding too much complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The objects provided with this chapter should never be implemented at a real-customer
    scenario. They are for the purpose of this chapter's examples only.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a better understanding of how to design
    a solid add-on solution and how to integrate it into the standard Microsoft Dynamics
    NAV product.
  prefs: []
  type: TYPE_NORMAL
- en: How to read this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate how an add-on for Microsoft Dynamics NAV
    should be designed. In this example, we create a solution for a Storage & Logistics
    company. This is chosen because the functionality is similar to the existing functionality
    in Microsoft Dynamics NAV (warehousing) and is a good example of building on top
    of standard application features.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by analyzing the business process and then discuss the reasons
    why we won't use standard application features and explain the modules our new
    application will have.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to go deeper into these modules and define the design patterns
    for each of them. We will then walk through the application like we did in the
    previous chapters and reverse engineer it to explain how all the pieces were designed.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to download and install the application. As we progress
    in the chapter, we will discuss most of the objects that can be opened and analyzed
    in the Microsoft Dynamics NAV development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the objects as we move along in the chapter to learn more. The objects
    are rich in functionality, which cannot all be discussed in detail in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this chapter, some objects and **Dynamic-link library** (**DLL**) files
    are required. The [Appendix](apa.html "Appendix A. Installation Guide"), *Installation
    Guide*, describes how to import and activate them.
  prefs: []
  type: TYPE_NORMAL
- en: After the import process is complete, make sure that your current database is
    the default database for the Role Tailored Client and run **Page 123456701**,
    **Storage & Logistics Setup** from the **Object Designer** in the **Classic Client**.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this page, select the **Initialize Storage & Logistics** option, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter objects](img/0365EN_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To design a solid solution for a specific market, we first need to analyze the
    business processes and see where the fits and gaps are with the standard product.
  prefs: []
  type: TYPE_NORMAL
- en: The companies that will be using this solution are logistics providers. These
    companies do not buy and sell products but sell logistics services such as transportation
    and storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be various moments in the supply chain where these companies are
    required. Products are often manufactured in companies all over the world and
    shipped to consumers elsewhere. Products can cover great distances, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The process](img/0365EN_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using standard features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV, like many ERP systems, is designed for people to handle
    their own products and supports the process of costing as we have seen in the
    previous chapters. For logistics service providers, this inventory control and
    valuation functionality is not necessary since the products are not their property.
    This means that they would want to use the warehouse functionality without the
    item ledger entries, which is very difficult in Microsoft Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: Logistics service providers also offer transportation solutions. They will pick
    up the products and deliver them to the customer. The process includes combining
    different stops in routes resulting in a more cost-efficient way of transportation.
    This functionality is not available in Microsoft Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will design three new modules on top of Microsoft Dynamics
    NAV that integrate with each other and could still be used separately. These modules
    also integrate with the standard application through **Sales & Purchase Documents**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the modules](img/0365EN_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the application is the storage module. This allows us to receive
    and ship products and move them internally in the warehouse. The design of this
    module is very similar to the warehouse documents in the standard application
    that we discussed in [Chapter 6](ch06.html "Chapter 6. Trade"), *Trade*.
  prefs: []
  type: TYPE_NORMAL
- en: Logistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logistics module supports the planning of routes, delivering the products
    to the consumers. This is integrated into the storage module but can also be used
    from sales shipment documents in the standard application.
  prefs: []
  type: TYPE_NORMAL
- en: For the design of this module, we have looked at the production orders in Microsoft
    Dynamics NAV that we discussed in [Chapter 5](ch05.html "Chapter 5. Production"),
    *Production*. The routes and shipments have a **Status** field that indicates
    the progress, similar to a production order.
  prefs: []
  type: TYPE_NORMAL
- en: Invoicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The storage and transportation services are then invoiced to the customer periodically
    or when the products leave the warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will use the standard Microsoft Dynamics NAV invoicing solutions
    but we will add a new **Income & Expenses** module in between the logistical solution
    and the invoicing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at the design of Job Ledger Entries and how they are invoiced.
    This will be discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The storage application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a storage warehouse, products come and go all the time. A big difference
    between a storage company and a production plant is that the storage company does
    not care about what exact products they have; they care about the amount of space
    they require for storage. The business is selling storage handling, storage space,
    and transportation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we''ll assume that our warehouse has a receipt and a shipping
    region, an in-between staging region and a bulk storage region. If we simplify
    the warehouse, it might look like the following floor plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The storage application](img/0365EN_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the various sections in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receipt**: When products come in, they are first unloaded from the truck
    onto a receipt region. This is often located close to the unloading dock, so the
    truck can quickly move on to its next stop after the products are unloaded and
    the loading documents are checked. From the receiving location, the products should
    be stored away as quickly as possible since another truck might come and we need
    the space. The products can now go to either the staging region or the bulk region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging**: The staging region is an in-between region where products can
    be stored but will leave the warehouse quickly when it is too busy to properly
    store in the bulk area and we need the space in the receipt region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shipment**: When products leave the warehouse, they will first be moved to
    the shipment region. This allows us to quickly load the trucks when they arrive
    and easily compare the loading documents with the real products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulk**: When we expect products to be in the warehouse for a longer period,
    they will be stored in the bulk area where we can define shelves. A shelf can
    have a capacity for one or more products depending on the setup in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to have a registration of what will be coming to our warehouse
    by creating the receipt documents. In the old days, we would often receive this
    information by phone or fax, but today most companies use interfaces, such as
    EDI and web portals for this. This keeps us from making mistakes when typing the
    information in the system and allows us to automatically populate the receipt
    document.
  prefs: []
  type: TYPE_NORMAL
- en: The receipt documents will be combined into put-away documents that register
    the transfer from one region to the other. The software will also suggest a shelf
    to store the products.
  prefs: []
  type: TYPE_NORMAL
- en: When the products leave the warehouse, our customers will also register a shipment
    document. On their call, we will start the order picking process and combine the
    shipments. The pick documents will tell us on which shelf the products are stored.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, it may also be necessary to move the products in the warehouse.
    This will be registered in internal movement documents.
  prefs: []
  type: TYPE_NORMAL
- en: The storage documents are connected to the logistics document structure, which
    we will see later in this chapter, while discussing logistics.
  prefs: []
  type: TYPE_NORMAL
- en: Look, learn, and love
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. A Sample Application"), *A Sample Application*,
    we learned how to use a journal and entry design patterns to register usage. In
    this chapter, we will continue with this and add some document design pattern
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: To design our application, we will look at how existing pieces of Microsoft
    Dynamics NAV are designed and reuse them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On [https://community.dynamics.com/nav/w/designpatterns/default.aspx](https://community.dynamics.com/nav/w/designpatterns/default.aspx),
    you'll find dozens of design patterns for Microsoft Dynamics NAV including many
    used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Journal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core of our application is the **Storage Journal**, which is created from
    the same template as the **Squash Journal** earlier. The difference is that people
    in a warehouse use documents rather than journals.
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will support the five types of documents we discussed earlier, namely, Receipt,
    Shipment, Put-away, Pick, and Movement. The documents can be created manually
    by end users or created automatically. We will also provide an interface structure
    to allow customers to register receipts and shipments.
  prefs: []
  type: TYPE_NORMAL
- en: As all the documents have the same structure and mostly the same fields, they
    are in the same table to share business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sharing the same table for multiple document types allows easier sharing of
    business logic across the application.
  prefs: []
  type: TYPE_NORMAL
- en: This is also done in the standard Microsoft Dynamics NAV application for sales
    and purchase documents as we discussed in [Chapter 6](ch06.html "Chapter 6. Trade"),
    *Trade*.
  prefs: []
  type: TYPE_NORMAL
- en: Master data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To define what we are storing in the warehouse, we will use a new table called
    **Product**, which is similar to the Item table in the standard system. By creating
    a new table, we will improve upgradability of our solution, which will help us
    be more in control of our own application or in other words, less likely to be
    impacted by the changes Microsoft implements in the standard product.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we combine this information into a table and transaction structure, it would
    look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the design pattern](img/0365EN_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The actual inventory is kept in **Storage Entries**. By filtering on a warehouse
    code, region code, or shelf number, the inventory can be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Storage & Logistics** add-on application also has some shared tables.
    It does not make sense to have a product or warehouse table for each part of the
    add-on. We choose to also share the setup and the cue tables for the Role Center
    definition. The Storage & Logistics application has four Role Centers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By sharing the cue table, it is much easier to place the same cues on different
    Role Centers. If we were to create one table for each Role Center, we would need
    to copy and paste the cue definition to the table for each change request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our scenario, we'll ship and receive products for a company called CRONUS
    International Ltd. for whom we do shipping. We have warehouses in Austria, Belgium,
    Czech Republic, Denmark, Germany, Great Britain, Iceland, Netherlands, Norway,
    Sweden, Slovenia, Slovakia, and the USA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each warehouse has the same basic layout as explained earlier in this chapter.
    From the warehouse, we plan routes to transport the products to the consumer.
    After initializing the application and restarting the application, the **Role
    Center** should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/0365EN_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the various sections in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activities**: This window shows the workflow for the warehouse floor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**My Products**: This contains all customer products we have on inventory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**My Regions**: This allows us to see what inventory is where in our warehouses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opening balance was created using the Storage Journal. By using the journal
    to create opening entries, we are sure that business rules are followed.
  prefs: []
  type: TYPE_NORMAL
- en: In our design, we have decided that end users are not allowed to directly register
    inventory on the bulk location. We start by receiving it, and then we create a
    put-away document to move it to the bulk location. We'll see how this is done
    later in this chapter when we discuss the storage documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have a look on the **Storage & Logistics Setup (123456701)** page to see how
    this was done in the `CreateOpeningBalance()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Products are references to the items of our customers that we keep in inventory.
    They contain a **Bill-to Customer No.** and a **Customer Item No**. This allows
    us, for example, to keep the item with number **70000** for two different customers.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see and set up **Storage Prices** for this product, which we will
    later use for the invoicing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Products](img/0365EN_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Warehouse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A warehouse is a physical building with an address. To move products from one
    warehouse to another warehouse, we would need to ship them, create a route, and
    then physically receive them in the other building.
  prefs: []
  type: TYPE_NORMAL
- en: '![Warehouse](img/0365EN_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A region is a part of the warehouse that is used for a specific storage activity.
    In our example, we have a receipt, staging, bulk, and shipment region. To move
    products from one region to another, we should create a put-away, movement, or
    pick document.
  prefs: []
  type: TYPE_NORMAL
- en: '![Regions](img/0365EN_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shelves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A shelf is a specific part of a region. The specific code of a shelf often indicates
    its position in the warehouse. For example, our warehouses have two rows, A and
    B, with 18 lines and 8 levels where each shelf can contain one pallet.
  prefs: []
  type: TYPE_NORMAL
- en: Registration worksheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The warehouse process starts with receiving products. To save time when the
    products arrive on the dock, we ask our customers to register their products in
    advance. This is done in the storage registration worksheet.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we have simulated an interface with our customer CRONUS
    International Ltd. We can start the interface from the Role Center directly.
  prefs: []
  type: TYPE_NORMAL
- en: We start the **CRONUS Storage Import Receipt** report from the **Role Center**,
    as shown in the following screenshot:![Registration worksheet](img/0365EN_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system pops up and asks for a **Storage Registration Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will choose **CRONUS** from the list and start the import process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we open **Registration Worksheets**.![Registration worksheet](img/0365EN_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we now open the registration worksheet, we see what CRONUS will send us
    today. This allows us to prepare our business, maybe move around some products,
    and schedule resources.![Registration worksheet](img/0365EN_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now register this worksheet, which will create the receipt documents
    for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storage documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use documents to determine which product goes where. Creating those documents
    in the system manually requires a large amount of work, so in our application,
    this is done automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Receipt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, all products that are received are stored in the **RECEIPT** region.
    This region does not have shelves. If required, we can change the region code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we register the receipt document, we have inventory on the **RECEIPT**
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Receipt](img/0365EN_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since this is a relatively small region, we need to move the products to the
    bulk location as quickly as possible. This is done using a put-away document.
  prefs: []
  type: TYPE_NORMAL
- en: Put-away
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A put-away document is used to move products from the receipt region into the
    bulk region. The storage entries tell us what is in the receipt region, so we
    copy that information into a new put-away document. These documents can be created
    manually, and based on the warehouse information on the document, we can pull
    the data into the document.
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement is to have an automated process that creates put-away documents
    based on the entire content of the receipt region.
  prefs: []
  type: TYPE_NORMAL
- en: To provide for this functionality, we have created the **Receipts to Put-Away
    (123456715)** report. This processing-only report reads the storage entries for
    the receipt region, and creates the put-away documents based on certain predefined
    rules.![Put-away](img/0365EN_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The report filters down the storage entries-based regions of type **Receipt**
    and with inventory.![Put-away](img/0365EN_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It creates a put-away document for each warehouse suggesting the first put-away
    region in the warehouse. For each `StorageEntry`, the `CreateLine` function is
    started. Let''s have a look at the C/AL code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step is to check whether it's necessary to create a new storage document.
    We create a new document for each `Warehouse` and `StorageDate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the system filters on the region table to find a put-away region. For
    each `StorageEntry`, a `StorageLine` is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running the report, our put-away document looks like this:![Put-away](img/0365EN_07_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The suggested **Region Code** is **BULK** and the **Apply-to Region Code** is
    **RECEIPT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we now try to register this document, we will receive an error since we did
    not enter any `Shelves` because this is mandatory on this region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This check is done in the codeunit Storage Jnl.-Check Line. By moving these
    checks into this codeunit, we make sure these rules are mandatory in each posting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we rely on the system to keep track of our inventory, we can also have
    it suggest available shelves for us. This is also done using batch report **123456716
    Generate Put-Away Shelves**. Let''s design the report and look at the C/AL code
    in `StorageLineDataItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each `StorageLine` in the put-away document, it finds another shelf by filtering
    on availability based on `Inventory` and `BlockedByStorage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `BlockedByStorage` field is a flow field that returns true if the shelf
    is used on a warehouse document preventing two forklift trucks from stopping at
    the same shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this report is executed, we can register this put-away document and we
    can see the **Storage Entries** that are generated from the **Product Card** using
    the **Ledger Entries** action:![Put-away](img/0365EN_07_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we can see that the put-away document has applied its entries to the receipt
    entries. Since we moved everything, the original entry is closed and the remaining
    quantity is set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is similar to what we created in [Chapter 2](ch02.html "Chapter 2. A
    Sample Application"), *A Sample Application*, when applying an invoice entry to
    a reservation.
  prefs: []
  type: TYPE_NORMAL
- en: Shipment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After a while when the products are in inventory, the customer may send a request
    to ship them. The shipping documents are sent using the same interface as the
    receipt documents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipment](img/0365EN_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CRONUS Storage Import Shipment option
  prefs: []
  type: TYPE_NORMAL
- en: Running the **CRONUS Storage Import Shipment** report will create the **Storage
    Registration Worksheet**, which we can check and register to a shipment document,
    the same way as the receipt documents earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The system creates a shipment document for each **Ship-to Address**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipment](img/0365EN_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have to start the process of moving the products from the storage region
    to the shipment region.
  prefs: []
  type: TYPE_NORMAL
- en: Picks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The products that will be shipped need to be picked from the bulk or staging
    region using a pick document. As with the put-away functionality, our application
    design provides an automated process that supports this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the document, we use batch **Report 123456717 Shipments to Pick**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picks](img/0365EN_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This report can combine shipments into one or more pick documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, the system checks whether the products are in inventory in this warehouse.
    If they are here, it starts browsing through the storage entries to look for available
    shelves. Here, we also use the **Blocked by Storage flow** field to avoid two
    employees fighting over the same product.
  prefs: []
  type: TYPE_NORMAL
- en: One of the functional requirements in our application is to avoid having half
    a shipment to be picked and block the **SHIPMENT** region being incomplete. If
    there are not enough inventories available for the pick, the system will display
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the pick is created, we update the **Pick Status on the Shipment** field.
    In the following screenshot, we can see that there are three **Pick Lines** attached
    to this shipment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picks](img/0365EN_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we click on **3**, the system opens the lines. Double-clicking on the lines
    will open the pick document.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To influence the double-click event, assign the **RETURN** shortcut to one of
    the actions on a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'After registration of the pick document, the status of the shipment moves to
    **Completely Picked**. We can see that the **Pick Lines** are registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picks](img/0365EN_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last step before the shipment can be registered is updating the storage
    lines with the **Apply-to Storage Entry No.** from the pick document. For this
    step, we have designed a dedicated report **Update Storage Shipment (123456718)**
    that can be started from the **Storage Shipment Document**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picks](img/0365EN_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After this, the shipment can be registered. The products have now left our warehouse
    and are on the road to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: The logistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to production orders in the standard application, the processes in our
    logistics application are status-driven rather than transaction-driven. This is
    why this part of the application does not have a journal with entries. The tables
    can have archived copies but they are not part of a normal registering or posting
    routine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the examples in this part of the chapter, we should change the default **Role
    Center to Logistics Role Center (123456700)** in the **Profile table (2000000072)**.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look at the structure of the logistics application, we can see that the
    typical posting transactions are missing. The application uses a status-driven
    workflow based on events that are defined in the triggers of the tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the design patterns](img/0365EN_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The logistics shipment and shipment details have a lot of similarity with the
    shipments from the warehouse. We have chosen to move them into new tables for
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: In Microsoft dynamics NAV, the table level is most important
    for security. If we share this table, it would be impossible to set up users to
    have access to logistics and not to the warehouse or vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locking**: If two departments use the same table for different purposes,
    they will most likely have a different locking mechanism. For example, in logistics,
    shipments are bound to the route object. The warehouse shipments are bound to
    other shipment documents. Filtering the same table in main processes in different
    ways will significantly increase the probability of blocks and deadlocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table size**: The storage documents are registered shortly after they are
    created. Most documents are deleted and moved to registered tables on the same
    day that they are created. Logistics shipments have a longer life cycle. It takes
    longer to take the products from our warehouse to the customer and during this
    process, many things can go wrong because of outside events. The transport tables
    may be periodically cleaned up like manufacturing or jobs in the standard Microsoft
    Dynamics NAV product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start the logistics process, we can create some shipments manually but the
    application also provides an interface to the sales shipments and warehouse shipments.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the **Combine Shipments (Sales)** option from **Activities** on
    the **Logistics Role Center** to generate some data to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Shipments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logistics shipments are products moving from one physical address to another
    physical address.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the shipments are created from our warehouse to the customer
    but a shipment can also be from another address to a customer. Tracking the status
    of a shipment is very important for the planners. A shipment starts with the **Ready
    to Ship** status as soon as all mandatory fields are checked.
  prefs: []
  type: TYPE_NORMAL
- en: When the shipments are combined into routes, the shipment moves to shipping
    and the status is changed to **Shipping**. During this stage, the products are
    picked up from the warehouse. When this happens, the **Pickup Date Time** is populated.
    This is done from the route.
  prefs: []
  type: TYPE_NORMAL
- en: After delivery, the **Delivery Date Time** is populated and the status is set
    to **Shipped**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipments](img/0365EN_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The planners can follow the shipments from their Role Centers in a workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shipments are combined into a route. For the planners to make a product planning,
    it is very important that the shipment details are correct. The length, width,
    height, and weight of the products determine whether they can fit in a truck,
    ship, airplane, or train.
  prefs: []
  type: TYPE_NORMAL
- en: Our example add-on system has a report to combine shipments into a route. The
    shipments in a route will be combined into stops if they have the same address
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Combining shipments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Combined shipping is done in the **Shipment To Route & Warehouse (123456701)**
    report. The shipments are grouped per warehouse. For each warehouse, a new route
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each shipment, the system creates a route stop. The stops have different
    types, Pickup, Delivery, Pickup Group, and Delivery Group. Each shipment then
    gets a Pickup and Delivery stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the routes are created and the shipments are assigned to a stop, a grouping
    and optimizing algorithm is started. This is codeunit `Route Optimizer (123456700)`.
  prefs: []
  type: TYPE_NORMAL
- en: Route optimizer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm in our example is designed to find the optimal route to deliver
    the products to the addresses by calculating the distance of each address from
    the warehouse. The route starts from the address that is closest to our warehouse
    and ends at the address that is the farthest away.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just an example of a simple algorithm. Each company will have its own
    algorithm that needs to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The calculation of the distance is done by calling a web service from Bing Maps.
    This is explained in [Chapter 9](ch09.html "Chapter 9. Interfacing"), *Interfacing*.
  prefs: []
  type: TYPE_NORMAL
- en: Each distance is stored as a record into the **Optimizer** table, which is a
    helper table. This table is a temporary variable in this codeunit.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary tables have multiple benefits that make them interesting to use. As
    they are not stored in the database, they have much better performance compared
    to real tables. This also has a benefit for concurrency since there can be no
    locking.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Temporary tables are free to use. They are not checked in the license file when
    used. To create and modify the definition, a valid license is still required.
    The video at [https://www.youtube.com/watch?v=QHn5oEOJv0Q](https://www.youtube.com/watch?v=QHn5oEOJv0Q)
    shows how to use temporary datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'After generating the distances, all Pickup shipments are combined into one
    stop by assigning them all to the same `Sequence No.` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By sorting the distance helper table on distance, we can easily assign the
    correct `Sequence No.` to the delivery stops. For each `Sequence No.` value, we
    will also generate a group record in the stop table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After optimizing the route, it should look something like what is shown in the
    following screenshot. We pick up two shipments at the warehouse and drive them
    to two addresses in the country.
  prefs: []
  type: TYPE_NORMAL
- en: '![Route optimizer](img/0365EN_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Route follow up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the route, the planner needs to follow up with the driver. This will
    result in the status update of the shipment.
  prefs: []
  type: TYPE_NORMAL
- en: In our solution, the planner should populate the **Date Time Completed** field.
    This field is automatically updated in the shipment using a flow field.
  prefs: []
  type: TYPE_NORMAL
- en: Incidents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A special status for a shipment is an incident. If, for any reason, we cannot
    deliver the shipment, it should be taken back to the warehouse and shipped again.
    Based on the reason of the incident, we might need to invoice extra services.
  prefs: []
  type: TYPE_NORMAL
- en: The incident can be on a stop group or on an individual shipment and can have
    status **Undeliverable**, **Closed**, or **Other**. The planner can add extra
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Incidents](img/0365EN_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other shipments that do not have incidents get the new status, while the
    incidents move to another place on the Role Center.
  prefs: []
  type: TYPE_NORMAL
- en: '![Incidents](img/0365EN_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Follow up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The incidents can be followed up by the planner via the Role Center. Incidents
    that have not been handled, keep the status open until someone decides what to
    do with it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Follow up](img/0365EN_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The invoicing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. A Sample Application"), *A Sample Application*,
    we introduced invoicing for an add-on solution. For the solution in this chapter,
    we'll take this one step further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our company is invoicing different logistics services, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling costs for storage receipt and shipments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage costs for the period we keep the inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs for transporting the products to the end consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these costs need to be combined in one invoice. Some customers may require
    monthly invoicing or some weekly and for incidental customers, we invoice directly.
    This requires a special module to handle the invoicing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the examples in this part of the chapter, the **Default Role Center** in
    the **Profile table (2000000072)** should be changed to **Income & Expenses Role
    Center (123456761)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the process to see where the invoicing is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The invoicing application](img/0365EN_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Income and expense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything that we want to invoice at one time to a customer, we store in a
    new table that we will call Income & Expense. This is a container where they will
    be kept until the periodical invoicing is done for this customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Income & Expense records can be created manually by end users or automatically
    by the system. Let''s have a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Income and expense](img/0365EN_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a new Income & Expense record, we need to fill in the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Income & Expense Code**: This is a reference to the group of Income & Expense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: This can be either Income or Expense. The former will be used on
    sales invoices and the latter is reserved for future use on purchase invoices
    if we decide to hire other companies to handle our logistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This is the description that will be printed on the sales
    invoice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantity**: This is the number of services that we have done. For example,
    the number of storage days or number of kilometers or miles in a route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Cost/Total Cost**: This can be used to calculate the profit of a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Price/Total Price**: This is the price the customer will see on the
    sales invoice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit of Measure Code**: This is a reference to the calculation method such
    as `BOX`, `KM`, `MILES`, or `DAY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applies-to Document Subtype**: This is a reference to Storage Header, Registered
    Storage Header, Logistics Shipment, or Logistics Route. If necessary, this can
    be expanded to accommodate other add-ons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applies-to Document (Line) No.**: This is a reference to the Storage and
    Logistics documents that this Income & Expense record belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applies-to Entry No.**: This is a reference to the Storage Invoice Entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the Income & Expenses are created, we can start the invoicing process.
    To support this, some minor changes are done in the invoicing part of Microsoft
    Dynamics NAV and as an example, we choose a slightly different approach compared
    to [Chapter 2](ch02.html "Chapter 2. A Sample Application"), *A Sample Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Sales Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Sales Line** table (37) has gotten some minor modifications. We have
    added an extra type for **Income** and implemented a table relation for the **No.**
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sales Line](img/0365EN_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This enables us to also create new entries on a sales invoice without having
    to create an Income & Expense first.
  prefs: []
  type: TYPE_NORMAL
- en: The Sales Line also has a reference to the **Income & Expense Entry No.** and
    the **Apply-to** fields. This enables us to create the **Income & Expense Journal
    Lines** in the **Sales Post Code Unit**.
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit Sales-Post (80)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sales post code unit has only one change to populate the Income & Expense
    Journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is done in the same way as the Resource Journal, however, we moved the
    code that creates the journal line to a function, and this improves readability
    and upgradability of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the Sales Line has all the **Posting Group** and **Amount** fields populated,
    the General Ledger Entries, VAT Entries, and Customer Ledger Entries are automatically
    generated by the standard application.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our add-on solution has three levels of automatic price calculation that are
    more or less identical. We can calculate prices for storage documents, logistics
    shipments, and routes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the storage prices as an example of how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Storage prices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the **Storage Price** table, we can register prices for different storage
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Storage prices](img/0365EN_07_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the price is calculated, the system will filter down in this table to find
    the price that matches best. For example, if a product has a price for receipt
    without a warehouse code, this price is used in all warehouses, but if one warehouse
    code is populated, this warehouse has a special price.
  prefs: []
  type: TYPE_NORMAL
- en: Prices can be differentiated to receipt, shipment, pick, put-away, movement,
    and storage. The first options are used on the storage documents, the latter when
    calculating storage cost.
  prefs: []
  type: TYPE_NORMAL
- en: The **Income & Expense Code** determines which type of Income & Expense will
    be created for this combination. A storage document can have more than one Income
    & Expense, for example, a normal receipt line and a customs surplus.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Income & Expenses are created using a Price Calc. Mgt. Codeunit, which we
    are familiar with from [Chapter 2](ch02.html "Chapter 2. A Sample Application"),
    *A Sample Application*, only this time we will not update the Unit Price but create
    the Income & Expenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation for storage is done in codeunit 123456710:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindStorageLinePrice` function will call the standard `StorageLinePriceExists`
    function to find the storage prices that match the criteria. For all the storage
    prices in the filter, it calls the `CreateIncExp` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each price will create a separate Income & Expense record.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Income & Expense table is set to **Auto Increment**. This means that SQL
    Server will generate the entry number for us. This enables multiple users to generate
    entries in this table at the same time without blocking each other.
  prefs: []
  type: TYPE_NORMAL
- en: Result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When new documents are generated by the system or end users, the prices are
    automatically calculated. The user can see the total cost and price on the **Fact
    Box** and change, remove, or add records if necessary, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Result](img/0365EN_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Periodic invoicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the services we are providing is storage. This means that sometimes products
    can be in our warehouse for several days or even weeks or months. Our customers
    will be invoiced for the time they use our warehouse space.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we receive a product in our warehouse or move a product to another
    region or shelf, a storage entry is created to keep track. For invoicing, we also
    create a Storage Invoice Entry. This is mainly because the inventory handling
    and invoicing are done on different moments by different persons. The products
    can be shipped to the customer when we start the invoicing process.
  prefs: []
  type: TYPE_NORMAL
- en: The Storage Invoice Entry is created with a **From Storage Date** that is inherited
    from the Storage Date of the Storage Entry. The Storage Invoice Entry also has
    a **To Storage Date** that maintains blank until the product leaves the warehouse
    or moves to another location that might have another price. The Income & Expense
    Code determines which price will be invoiced and is determined when posting a
    **Storage Document**.
  prefs: []
  type: TYPE_NORMAL
- en: The batch report **Storage Invoicing (123456703)** is used for the creation
    of the Income & Expenses. Let's have a look at how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: '![Periodic invoicing](img/0365EN_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The report only has one Storage Invoice Entry `DataItem`, which is filtered
    on **Open=Yes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the report, all the Storage Invoice Entries are moved to a buffer table
    first and handled later. There are two important reasons for implementing a solution
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing Record Set**: This report filters on Storage Invoice Entries, which
    are open for invoicing. When the Storage Invoice Entry is completely invoiced,
    we want to change this value. This means that the record set we use is changing
    during the process. This is something the SQL Server backend cannot handle and
    this will result in very poor performance. By first moving all records to a buffer
    table, the filtering will be done on a virtual table that is maintained on the
    Service Tier rather than SQL Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locking**: If we were to filter on open entries and modify our dataset, it
    would result in locking more records than necessary. Filtering on a non-clustered
    index will result in SQL Server moving to Range Locks rather than Row Locks. By
    reading the actual Storage Invoice Entry one by one using the clustered index,
    we will make sure that SQL Server only locks the records we use for this process,
    allowing other users to keep creating new records at the end of this table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When processing the buffer, we first check whether this entry has been invoiced
    before. If this is the case, we start invoicing from the previous date, if not;
    we use the From Storage Date.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check whether the products have already left the warehouse or have
    been moved. If this is the case, we can close this entry by invoicing until this
    date; otherwise, we will invoice until the Workdate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users can change the systems Workdate and influence the systems behavior this
    way and invoice until another date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The next step in our code is to calculate the number of workdays between the
    two dates. This will prevent our customer from paying for storage on Saturday
    and Sunday. We do this by using the virtual date table. This table contains all
    dates, weeks, months, quarters and years between January 1 0000 and December 31
    9999 and can be very useful in date calculations.
  prefs: []
  type: TYPE_NORMAL
- en: With this result, we can now create the Income & Expense records that will be
    invoiced later. If the **To Storage Date** is populated, we close the Storage
    Invoice Entry.
  prefs: []
  type: TYPE_NORMAL
- en: Combined invoicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data model we use allows us to combine invoicing on all the services we
    provide for our customers. We can create one invoice that contains handling, storage,
    and transportation costs for our customers.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by batch report 123456704 Combine Storage & Logistics, which works
    exactly the same as the report in [Chapter 2](ch02.html "Chapter 2. A Sample Application"),
    *A Sample Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Add-on flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The add-on we have created in this chapter is definitely not ready to be used
    by a real company but it demonstrates how to create a flexible solution that can
    be easily expanded by others.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern logistic service providers offer other services to customers, such
    as value-added logistics, item tracking, and third- and fourth-party logistics.
  prefs: []
  type: TYPE_NORMAL
- en: Value-added logistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a company offers value-added logistics services, they not only keep products
    on inventory but they also offer services around this, such as display packaging.
  prefs: []
  type: TYPE_NORMAL
- en: This can be best compared with manufacturing in Microsoft Dynamics NAV. A list
    of items called a bill of materials is combined into a new product. This new product
    is then shipped to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: When the displays are no longer necessary, for example, when a marketing campaign
    is finished, the displays need to be picked up from the customer and disassembled
    into the original products.
  prefs: []
  type: TYPE_NORMAL
- en: '![Value-added logistics](img/0365EN_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our solution, this could be implemented by creating a VAL region where the
    products are moved to.
  prefs: []
  type: TYPE_NORMAL
- en: Item tracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our customers also want to know the whereabouts of their products, which warehouse
    they are in, and which product was shipped to which customer. This is especially
    important in the food and medicine industry to be able to call back a lot, if
    something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this in our solution, it requires some changes. First, we need
    to implement a Tracking Code in the Storage Entries, and secondly, we need to
    implement some kind of Tracking Entries when we ship a product outside our warehouse
    since our logistics solution currently does not have any entries, only status
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![Item tracking](img/0365EN_07_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Third- and fourth-party logistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example database, we plan shipments on routes and drive them to the end
    customer with our own trucks. This is called second-party logistics. First-party
    logistics would be if we were to handle our own products with our own trucks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the increasing complexity of logistics if it gets
    outsourced and combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third- and fourth-party logistics](img/0365EN_07_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we provide third-party logistics, we would use other companies to offer parts
    of the services to our customers. We will then tell them which part of the service
    to handle and report back to us when it is finished. The third party involved
    does not know the details of the complete transaction.
  prefs: []
  type: TYPE_NORMAL
- en: If we offer fourth-party logistics, we would outsource a complete warehouse
    or route to another company. We would only tell them which product should be moved
    where and they would handle it, without us knowing the details.
  prefs: []
  type: TYPE_NORMAL
- en: Very often, third- and fourth-party logistics are mixed but they are usually
    handled by interfaces between different companies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the Microsoft Dynamics NAV product from a completely
    different viewpoint compared to the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The goal was not to design a rock-solid storage and logistics add-on solution
    for Microsoft Dynamics NAV as this would require much more than one chapter. The
    information in this chapter is intended to demonstrate how to integrate new functionality
    on top of Microsoft Dynamics NAV. We analyzed business processes and designed
    new data and transaction models to handle them in the product and implemented
    this.
  prefs: []
  type: TYPE_NORMAL
- en: For our solution, we designed two new document structures and two new journals
    and entry structures. We stayed close to the standard methodology of Microsoft
    Dynamics NAV by creating a framework that can easily be expanded. We also spend
    some time looking at how to prevent unnecessary locking in the database and how
    to avoid changing a filtered dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at some examples of how our add-on solution can be enhanced
    to better suit other demands in the market.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does not end here. The C/AL objects provided with this chapter
    can be studied in order to understand even better how the pieces are put together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will design an application inside Microsoft Dynamics
    NAV. We will look at how it can be used for a consultancy company using the Jobs
    module and extending this with new functionality to meet specific requirements.
  prefs: []
  type: TYPE_NORMAL
