<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Xamarin.Forms</h1></div></div></div><p class="calibre8">Since the beginning of Xamarin's lifetime as a company, their motto has always been to expose the native APIs on iOS and Android directly to C#. This was a great strategy at the beginning, because applications built with Xamarin.iOS or Xamarin.Android were pretty much indistinguishable from a native Objective-C or Java application. Code sharing was generally limited to non-UI code that left a potential gap to fill in the Xamarin ecosystem: a cross-platform UI abstraction. Xamarin.Forms is the solution to this problem, a cross-platform<a id="id698" class="calibre1"/> UI framework that renders native controls on each platform. Xamarin.Forms is a great solution for those who know C# (and XAML), but also might not want to get into the full details of using the native iOS and Android APIs. </p><p class="calibre8">In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem">Create "Hello World" in Xamarin.Forms</li><li class="listitem">Discuss Xamarin.Forms architecture</li><li class="listitem">Use XAML with Xamarin.Forms</li><li class="listitem">Cover data binding and MVVM with Xamarin.Forms</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec74" class="calibre1"/>Creating Hello World in Xamarin.Forms</h1></div></div></div><p class="calibre8">To understand<a id="id699" class="calibre1"/> how a Xamarin.Forms application is put together, let's begin by creating a simple "Hello World" application.</p><p class="calibre8">Open Xamarin Studio and <a id="id700" class="calibre1"/>perform the following steps:</p><div><ul class="itemizedlist"><li class="listitem">Create a new solution.</li><li class="listitem">Navigate to the <strong class="calibre2">C#</strong> | <strong class="calibre2">Mobile Apps</strong> section.</li><li class="listitem">Create a new <strong class="calibre2">Blank App (Xamarin.Forms Portable)</strong> solution.</li><li class="listitem">Name your solution something appropriate such as <code class="literal">HelloForms</code>.</li></ul></div><p class="calibre8">Notice the three new projects that were successfully created: <code class="literal">HelloForms</code>, <code class="literal">HelloForms.Android</code>, and <code class="literal">HelloForms.iOS</code>. In Xamarin.Forms applications, the bulk of your code will be shared, and each platform-specific project is just a small amount of code that starts the Xamarin.Forms framework.</p><p class="calibre8">Let's examine the minimal <a id="id701" class="calibre1"/>parts of a Xamarin.Forms application:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">App.cs</code> in the <code class="literal">HelloForms</code> PCL library. This class holds the startup page of the Xamarin.Forms application. A simple static method, <code class="literal">GetMainPage()</code>, returns<a id="id702" class="calibre1"/> the startup page of the application. In the default project template, </li><li class="listitem">A <code class="literal">ContentPage</code> is created with a single label that will be rendered as a <code class="literal">UILabel</code> on iOS and a <code class="literal">TextView</code> on Android.</li><li class="listitem"><code class="literal">MainActivity.cs</code> in the <code class="literal">HelloForms.Android</code> Android project. This is the main launcher activity of the Android application. The important part for Xamarin.Forms here is the call to <code class="literal">Forms.Init(this, bundle)</code> that initializes the Android-specific portion of the Xamarin.Forms framework. Next is a call to <code class="literal">SetPage(App.GetMainPage())</code> that displays the native version of the main Xamarin.Forms page. </li><li class="listitem"><code class="literal">AppDelegate.cs</code> in the <code class="literal">HelloForms.iOS</code> iOS project. This is very similar to Android, except iOS applications startup via a <code class="literal">UIApplicationDelegate</code> class. <code class="literal">Forms.Init()</code> will initialize<a id="id703" class="calibre1"/> the iOS-specific parts of Xamarin.Forms, while <code class="literal">App.GetMainPage().CreateViewController()</code> will generate a native controller that can be used as the <code class="literal">RootViewController</code> of the main window of the application.</li></ul></div><p class="calibre8">Go ahead and run the iOS project; you should see something similar to the following screenshot:</p><div><img src="img/00085.jpeg" alt="Creating Hello World in Xamarin.Forms" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If you run the Android<a id="id704" class="calibre1"/> project, you will get a UI very similar<a id="id705" class="calibre1"/> to the iOS, but using the native Android controls, as shown in the following screenshot:</p><div><img src="img/00086.jpeg" alt="Creating Hello World in Xamarin.Forms" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8">Even though not covered in this book, Xamarin.Forms also supports Windows Phone applications. However, a PC running Windows and Visual Studio is required to develop for <a id="id706" class="calibre1"/>Windows Phone. If you can<a id="id707" class="calibre1"/> get a Xamarin.Forms application working on iOS and Android, then getting a Windows Phone version working should be a piece of cake.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec75" class="calibre1"/>Understanding the architecture behind Xamarin.Forms</h1></div></div></div><p class="calibre8">Getting started with Xamarin.Forms is very easy, but it is always good to look behind the curtain to understand what is happening behind the scenes. In the earlier chapters of this book, we created a cross-platform application using native iOS and Android APIs directly. Certain applications<a id="id708" class="calibre1"/> are much more suited for this development approach, so understanding the difference between a Xamarin.Forms application and a plain Xamarin application is important to know when choosing what framework is best suited for your app.</p><p class="calibre8">Xamarin.Forms is an <a id="id709" class="calibre1"/>abstraction over the native iOS and Android APIs that you can call directly from C#. So, Xamarin.Forms is using the same APIs you would in a plain Xamarin application, while providing a framework that allows you to define your UIs in a cross-platform way. An abstraction layer such as this is in many ways a very good thing because it gives you the benefit of sharing the code driving your UI as well as any backend C# code that could have also been shared in a standard Xamarin app. The main disadvantage, however, is a slight hit in performance and being limited by the Xamarin.Forms framework as far as what types of controls are available. Xamarin.Forms also gives the option of writing<a id="id710" class="calibre1"/> <strong class="calibre2">renderers</strong> that allow you to override your UI in a platform-specific way. However, in my opinion, renderers are still somewhat limited in what can be achieved.</p><p class="calibre8">See the difference in a Xamarin.Forms application and a traditional Xamarin app in the following diagram:</p><div><img src="img/00087.jpeg" alt="Understanding the architecture behind Xamarin.Forms" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">In both the applications, the business logic and backend code of the application can be shared, but Xamarin.Forms gives<a id="id711" class="calibre1"/> you an enormous benefit by allowing your UI code to be shared as well.</p><p class="calibre8">Additionally, Xamarin.Forms applications have two project templates to choose from, so let's cover each option:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Xamarin.Forms Shared</strong>: This creates a<a id="id712" class="calibre1"/> shared project with all of your Xamarin.Forms code, an iOS project, and an Android project. </li><li class="listitem"><strong class="calibre2">Xamarin.Forms Portable</strong>: This <a id="id713" class="calibre1"/>creates a portable class library that contains all the shared Xamarin.Forms code, an iOS project, and an Android project.</li></ul></div><p class="calibre8">In general, both the options will work fine for any application. Shared projects are basically a collection of code files that get added automatically to another project referencing it. Using a shared project allows you to use preprocessor statements to implement platform-specific code. Portable class library projects, on the other hand, create a portable .NET assembly that can be used on iOS, Android, and various other platforms. PCLs can't use<a id="id714" class="calibre1"/> preprocessor statements, so you generally set up platform-specific code with an interface or abstract/base classes. In most cases, I think a portable class library is a better option since it inherently encourages better programming practices. You can refer to <a class="calibre1" title="Chapter 3. Code Sharing between iOS and Android" href="part0029_split_000.html#page">Chapter 3</a>, <em class="calibre12">Code Sharing between iOS and Android</em>, for details on the advantages and disadvantages of these two code-sharing techniques.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec76" class="calibre1"/>Using XAML in Xamarin.Forms</h1></div></div></div><p class="calibre8">In addition to<a id="id715" class="calibre1"/> defining Xamarin.Forms controls from C# code, Xamarin has provided the tool to develop your UI in <strong class="calibre2">Extensible Application Markup Language</strong> (<strong class="calibre2">XAML</strong>). XAML is a declarative language that is basically a set of XML elements that map to a certain control in the Xamarin.Forms framework. Using XAML is comparable to what you would think of using HTML to define the UI on a web page, with the exception that XAML in <a id="id716" class="calibre1"/>Xamarin.Forms creates C# objects that represent a native UI.</p><p class="calibre8">To understand how XAML works in Xamarin.Forms, let's create a new page with lots of UI on it:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new Xamarin.Forms Portable solution by navigating to <strong class="calibre2">C#</strong> | <strong class="calibre2">Mobile Apps</strong> | <strong class="calibre2">Blank App (Xamarin.Forms Portable)</strong>.</li><li class="listitem" value="2">Name the project something appropriate such as <code class="literal">UIDemo</code>.</li><li class="listitem" value="3">Add a new file by navigating to the <strong class="calibre2">Forms</strong> | <strong class="calibre2">Forms ContentPage XAML</strong> item template. Name the page <code class="literal">UIDemoPage</code>.</li><li class="listitem" value="4">Open <code class="literal">UIDemoPage.xaml</code>.</li></ol><div></div><p class="calibre8">Now, let's edit the XAML code. Add the following XAML code between the <code class="literal">&lt;ContentPage.Content&gt;</code> tag:</p><div><pre class="programlisting">&lt;StackLayout Orientation="Vertical" Padding="10,20,10,10"&gt; &lt;Label Text="My Label" XAlign="Center" /&gt; &lt;Button Text="My Button" /&gt; &lt;Entry Text="My Entry" /&gt; &lt;Image Source="xamagon.png" /&gt; &lt;Switch IsToggled="true" /&gt; &lt;Stepper Value="10" /&gt; &lt;/StackLayout&gt;</pre></div><p class="calibre8">Go ahead and run the application on iOS and Android. Your application will look something like the following screenshot:</p><div><img src="img/00088.jpeg" alt="Using XAML in Xamarin.Forms" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Then, on<a id="id717" class="calibre1"/> Android, Xamarin.Forms <a id="id718" class="calibre1"/>will render the screen in the same way, but with the native Android controls:</p><div><img src="img/00089.jpeg" alt="Using XAML in Xamarin.Forms" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">First, we created a <code class="literal">StackLayout</code> control, which is a container for other controls. It can layout controls either <a id="id719" class="calibre1"/>vertically or horizontally one by one as<a id="id720" class="calibre1"/> defined by the <code class="literal">Orientation</code> value. We also applied a padding of 10 around the sides and bottom, and 20 from the top to adjust the iOS status bar. You might be familiar with this syntax for defining rectangles if you are familiar with WPF or Silverlight. Xamarin.Forms uses the same syntax of the left, top, right, and bottom values delimited by commas.</p><p class="calibre8">We also used several of the built-in Xamarin.Forms controls to see how they work:</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="literal">Label</code>: We used this earlier in the chapter. This is used only to display the text. This maps to a <code class="literal">UILabel</code> on iOS and a <code class="literal">TextView</code> on Android.</li><li class="listitem" value="2"><code class="literal">Button</code>: This is a general purpose button that can be tapped by a user. This control maps to a <code class="literal">UIButton</code> on iOS and a <code class="literal">Button</code> on Android.</li><li class="listitem" value="3"><code class="literal">Entry</code>: This control is a single-line text entry. It maps to a <code class="literal">UITextField</code> on iOS and an <code class="literal">EditText</code> on Android.</li><li class="listitem" value="4"><code class="literal">Image</code>: This is a simple control to display an image on the screen, which maps to a <code class="literal">UIImage</code> on iOS and an <code class="literal">ImageView</code> on Android. We used the <code class="literal">Source</code> property of this control that loads an image from the <code class="literal">Resources</code> folder on iOS and the <code class="literal">Resources/drawable</code> folder on Android. You can also set URLs on this property, but it is best to include the image in your project for the performance.</li><li class="listitem" value="5"><code class="literal">Switch</code>: This is an on/off switch or a toggle button. It maps to a <code class="literal">UISwitch</code> on iOS and a <code class="literal">Switch</code> on Android.</li><li class="listitem" value="6"><code class="literal">Stepper</code>: This is<a id="id721" class="calibre1"/> a general-purpose input to enter numbers via two plus and minus buttons. On iOS, this maps to a <code class="literal">UIStepper</code>, while on Android Xamarin.Forms implements this functionality with two <code class="literal">Button</code>.</li></ol><div></div><p class="calibre8">This is just some of the controls provided by Xamarin.Forms. There are also more complicated controls <a id="id722" class="calibre1"/>such as the <code class="literal">ListView</code> and <code class="literal">TableView</code> you would expect to develop mobile UIs.</p><p class="calibre8">Even though we used XAML in this example, you can also implement this Xamarin.Forms page from C#. Here is an example of what this would look like:</p><div><pre class="programlisting">public class UIDemoPageFromCode : ContentPage
{
  public UIDemoPageFromCode()
  {
    var layout = new StackLayout 
    {
      Orientation = StackOrientation.Vertical,
      Padding = new Thickness(10, 20, 10, 10),
    };

    layout.Children.Add(new Label 
    {
      Text = "My Label",
      XAlign = TextAlignment.Center,
    });

    layout.Children.Add(new Button 
    {
      Text ="My Button",
    });

    layout.Children.Add(new Image 
    {
      Source = "xamagon.png",
    });

    layout.Children.Add(new Switch 
    {
      IsToggled = true,
    });

    layout.Children.Add(new Stepper 
    {
      Value = 10,
    });

    Content = layout;
  }
}</pre></div><p class="calibre8">So you can see that<a id="id723" class="calibre1"/> using XAML can be a bit more readable and is generally a bit better at declaring UIs. However, using C# to define your UIs is still a viable, straightforward <a id="id724" class="calibre1"/>approach.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec77" class="calibre1"/>Using data binding and MVVM</h1></div></div></div><p class="calibre8">At this point, you <a id="id725" class="calibre1"/>should be grasping the basics of Xamarin.Forms, but you may be wondering how the MVVM design pattern fits into the picture. The MVVM design pattern was originally <a id="id726" class="calibre1"/>conceived for its use along with XAML and the powerful data binding features XAML provides, so it is only natural that it is a perfect <a id="id727" class="calibre1"/>design pattern to be used with<a id="id728" class="calibre1"/> Xamarin.Forms.</p><p class="calibre8">Let's cover the basics of how data binding and MVVM is set up with Xamarin.Forms:</p><div><ol class="orderedlist"><li class="listitem" value="1">Your Model and ViewModel layers will remain mostly unchanged from the MVVM pattern we covered earlier in the book.</li><li class="listitem" value="2">Your ViewModel layer should implement the <code class="literal">INotifyPropertyChanged</code> interface, which facilitates data binding. To simplify things in Xamarin.Forms, you can use the <code class="literal">BindableObject</code> base class and call <code class="literal">OnPropertyChanged</code> when the values change on your ViewModel.</li><li class="listitem" value="3">Any page or control in Xamarin.Forms has a <code class="literal">BindingContext</code> property, which is the object that it is data bound to. In general, you can set a corresponding ViewModel to each view's <code class="literal">BindingContext</code> property.</li><li class="listitem" value="4">In XAML, you can set up data binding using the syntax of the form <code class="literal">Text="{Binding Name}"</code>. This example will bind the Text property of the control to a Name property of the object residing in the <code class="literal">BindingContext</code>.</li><li class="listitem" value="5">In conjunction with data<a id="id729" class="calibre1"/> binding, events can be translated to commands using the <code class="literal">ICommand</code> interface. So, for example, a button's click event can be data bound to a command exposed by a ViewModel. There is a built-in <code class="literal">Command</code> class in Xamarin.Forms to support this.</li></ol><div></div><div><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre8">Data binding can also be set up from C# code in Xamarin.Forms via the <code class="literal">Binding</code> class. However, it is generally much easier to set up bindings from XAML, since the syntax has been simplified there.</p></div><p class="calibre8">Now that we have covered the basics, let's go through it step by step and partially convert our XamChat sample <a id="id730" class="calibre1"/>application discussed earlier in the book to use Xamarin.Forms. For the most part, we can reuse most of the Model and ViewModel layers, although we will have to make a few minor changes to support data binding from XAML.</p><p class="calibre8">Let's begin by creating a new Xamarin.Forms application backed by a PCL named <code class="literal">XamChat</code>:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, create three folders in the <code class="literal">XamChat</code> project named <code class="literal">Views</code>, <code class="literal">ViewModels</code>, and <code class="literal">Models</code>.</li><li class="listitem" value="2">Add the appropriate <code class="literal">ViewModels</code> and <code class="literal">Models</code> classes from the XamChat application in the earlier chapter. These are found in the <code class="literal">XamChat.Core</code> project.</li><li class="listitem" value="3">Build the project and just make sure that everything is saved. You will get a few compiler errors that we will resolve shortly.</li></ol><div></div><p class="calibre8">The first class that we will need to edit is the <code class="literal">BaseViewModel</code> class. Open it and make the following changes:</p><div><pre class="programlisting">public class BaseViewModel : BindableObject
{
  protected readonly IWebService service = DependencyService.Get&lt;IWebService&gt;();
  protected readonly ISettings settings = DependencyService.Get&lt;ISettings&gt;();

  private bool isBusy = false;
  public bool IsBusy
  {get {return isBusy;}
      set {isBusy = value; OnPropertyChanged();}}
}</pre></div><p class="calibre8">First of all, we removed the calls to the <code class="literal">ServiceContainer</code> class, because Xamarin.Forms provides its own IoC container called <code class="literal">DependencyService</code>. It functions very similar to the container we built in the previous chapters, except that it only has one method, <code class="literal">Get&lt;T&gt;</code>, and the registrations are set up via an assembly attribute that we will set up shortly.</p><p class="calibre8">Additionally, we removed the <code class="literal">IsBusyChanged</code> event in favor of the <code class="literal">INotifyPropertyChanged</code> interface that supports data binding. Inheriting from <code class="literal">BindableObject</code> gives us the helper method, <code class="literal">OnPropertyChanged</code>, which<a id="id731" class="calibre1"/> we use to inform bindings that the value has <a id="id732" class="calibre1"/>changed in Xamarin.Forms. Notice that we didn't pass <code class="literal">string</code>, which contains the property name, to <code class="literal">OnPropertyChanged</code>. This method uses a lesser-known feature<a id="id733" class="calibre1"/> of .NET 4.0 called <code class="literal">CallerMemberName</code>, which will automatically fill in the calling property's name at runtime.</p><p class="calibre8">Next, let's set up our required services with <code class="literal">DependencyService</code>. Open <code class="literal">App.cs</code> in the root of the PCL project, and add the following two lines above the namespace declaration:</p><div><pre class="programlisting">[assembly: Dependency(typeof(XamChat.Core.FakeWebService))]
[assembly: Dependency(typeof(XamChat.Core.FakeSettings))]</pre></div><p class="calibre8">
<code class="literal">DependencyService</code> will automatically pick up these attributes and inspect the types that we declared. Any interfaces that these types implement will be returned for any future callers of <code class="literal">DependencyService.Get&lt;T&gt;</code>. I normally put all <code class="literal">Dependency</code> declarations in the <code class="literal">App.cs</code> file so that they are easy to manage and in one place.</p><p class="calibre8">Next, let's modify <code class="literal">LoginViewModel</code> by adding a new property:</p><div><pre class="programlisting">public Command LoginCommand { get; set; }</pre></div><p class="calibre8">We'll use this shortly to data bind a button's command. One last change in the View Model layer is to set up <code class="literal">INotifyPropertyChanged</code> for the <code class="literal">MessageViewModel</code>:</p><div><pre class="programlisting">Conversation[] conversations;

public Conversation[] Conversations
{get {return conversations; }
  set {conversations = value; OnPropertyChanged();}
}</pre></div><p class="calibre8">Likewise, you can repeat this pattern for the remaining public properties throughout the ViewModel layer, but this<a id="id734" class="calibre1"/> is all that we will need for this example. Next, let's create<a id="id735" class="calibre1"/> a new <code class="literal">Foms ContentPage Xaml</code> item under the <code class="literal">Views</code> folder named <code class="literal">LoginPage</code>. In the code-behind file <code class="literal">LoginPage.xaml.cs</code>, we'll just need to make a few changes:</p><div><pre class="programlisting">public partial class LoginPage : ContentPage
{
  readonly LoginViewModel loginViewModel = new LoginViewModel();

  public LoginPage()
  {
    Title = "XamChat";
    BindingContext = loginViewModel;

    loginViewModel.LoginCommand = new Command(async () =&gt;
    {
      try
      {
        await loginViewModel.Login();

        await Navigation.PushAsync(new ConversationsPage());
      }
      catch (Exception exc)
      {
        await DisplayAlert("Oops!", exc.Message, "Ok");
      }
    });

    InitializeComponent();
  }
}</pre></div><p class="calibre8">We did a few important things here, including setting the <code class="literal">BindingContext</code> to our <code class="literal">LoginViewModel</code>. We set up <code class="literal">LoginCommand</code>, which basically invokes the<a id="id736" class="calibre1"/> <code class="literal">Login</code> method and displays a message if something goes wrong. It also navigates to a new page if successful. We also set the title, which will show up in the top navigation bar of the application.</p><p class="calibre8">Next, open <code class="literal">LoginPage.xaml</code>, and we'll add the following XAML code inside the content page's content:</p><div><pre class="programlisting">&lt;StackLayout Orientation="Vertical" Padding="10,10,10,10"&gt;
  &lt;Entry Placeholder="Username" Text="{Binding Username}" /&gt;
  &lt;Entry Placeholder="Password" Text="{Binding Password}" IsPassword="true" /&gt;
  &lt;Button Text="Login" Command="{Binding LoginCommand}" /&gt;
  &lt;ActivityIndicator IsVisible="{Binding IsBusy}" IsRunning="true" /&gt;
&lt;/StackLayout&gt;</pre></div><p class="calibre8">This will set up the basics of two<a id="id737" class="calibre1"/> text fields, a button, and a spinner complete with all the bindings to make everything work. Since we set up the <code class="literal">BindingContext</code> from<a id="id738" class="calibre1"/> the <code class="literal">LoginPage</code> code behind, all the properties are bound to the <code class="literal">LoginViewModel</code>.</p><p class="calibre8">Next, create <code class="literal">ConversationsPage</code> as a XAML page as we did earlier, and edit the <code class="literal">ConversationsPage.xaml.cs</code> code behind:</p><div><pre class="programlisting">public partial class ConversationsPage : ContentPage
{
  readonly MessageViewModel messageViewModel = new MessageViewModel();

  public ConversationsPage()
  {
    Title = "Conversations";
    BindingContext = messageViewModel;

    InitializeComponent ();

    Appearing += async (sender, e) =&gt; 
    {
      try
      {
        await messageViewModel.GetConversations();
      }
      catch (Exception exc)
      {
        await DisplayAlert("Oops!", exc.Message, "Ok");
      }
    };
  }
}</pre></div><p class="calibre8">In this case, we repeated a lot of the same steps. The exception is that we used the <code class="literal">Appearing</code> event as a way to load the conversations to display on the screen.</p><p class="calibre8">Now let's add the <a id="id739" class="calibre1"/>following XAML code to <code class="literal">ConversationsPage.xaml</code>:</p><div><pre class="programlisting">&lt;ListView ItemsSource="{Binding Conversations}"&gt;
  &lt;ListView.ItemTemplate&gt;
    &lt;DataTemplate&gt;
      &lt;TextCell Text="{Binding Username}" /&gt;
    &lt;/DataTemplate&gt;
  &lt;/ListView.ItemTemplate&gt;
&lt;/ListView&gt;</pre></div><p class="calibre8">In this example, we used <code class="literal">ListView</code> to data bind a list of items and display on the screen. We defined a <code class="literal">DataTemplate</code> class that represents a set of cells for each item in the list that <code class="literal">ItemsSource</code> is data <a id="id740" class="calibre1"/>bound to. In our case, a <code class="literal">TextCell</code> displaying the <code class="literal">Username</code> is created for each item in the <code class="literal">Conversations</code> list.</p><p class="calibre8">Last but not least, we must return to the <code class="literal">App.cs</code> file and modify the startup page:</p><div><pre class="programlisting">public static Page GetMainPage()
{
  return new NavigationPage(new LoginPage());
}</pre></div><p class="calibre8">We used <code class="literal">NavigationPage</code> here so that Xamarin.Forms can push and pop between different pages. This uses a <code class="literal">UINavigationController</code> on iOS so you can see how the native APIs are being used on each platform.</p><p class="calibre8">At this point, if you <a id="id741" class="calibre1"/>compile and run the application, you will get a functional iOS and an Android application that can login and view a list of conversations:</p><div><img src="img/00090.jpeg" alt="Using data binding and MVVM" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec78" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered the basics of Xamarin.Forms and learned how it can be very useful to build your own cross-platform applications. Xamarin.Forms shines for certain types of apps, but can be limiting if you need to write more complicated UIs or take advantage of native drawing APIs. We discovered how to use XAML to declare our Xamarin.Forms UIs and understood how Xamarin.Forms controls are rendered on each platform. We also dived into the concepts of data binding and discovered how to use the MVVM design pattern with Xamarin.Forms. Last but not least, we began porting the XamChat application that was discussed earlier in the book to Xamarin.Forms and we were able to reuse most of the backend code.</p></div></body></html>