<html><head></head><body>
<div><div><h1 id="_idParaDest-83"><em class="italic"><a id="_idTextAnchor082"/>Chapter </em><em class="italic">5</em>: Asynchronous Programming with C#</h1>
<p>The .NET <code>async</code> and <code>await</code> keywords, was<a id="_idIndexMarker226"/> introduced in .NET Framework 4.5. The C# language’s support for these keywords was released at the same time in C# 5. Now, a decade later, the TAP model is an integral part of most .NET developers’ toolsets. </p>
<p>This chapter will explain asynchronous programming in C#, explore how to use <code>Task</code> objects, and delve into best practices of using <code>async</code> and <code>await</code> for <strong class="bold">I/O-bound</strong> and <strong class="bold">CPU-bound</strong> scenarios with .NET.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>More about asynchronous programming in .NET</li>
<li>Working with Task objects</li>
<li>Interop with synchronous code</li>
<li>Working with multiple background tasks</li>
<li>Asynchronous programming best practices</li>
</ul>
<p>By the end of this chapter, you will have a deeper understanding of asynchronous programming and should feel confident enough to add advanced async features to your team’s projects.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Technical requirements</h1>
<p>In this chapter, we will be using the .NET <strong class="bold">command-line interface </strong>(<strong class="bold">CLI</strong>) and Visual Studio Code to build and run the sample projects. To follow along with the examples, the following software is recommended:</p>
<ul>
<li>Visual Studio Code version 1.65 or later</li>
<li>.NET 6 or later</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 version 17.0 or later if you are using Windows 10 or 11, Visual Studio 2022 for Mac on macOS 10.13 or later, or JetBrains Rider will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05</a>.</p>
<p>Let’s get started by working our way through some examples that use the TAP model with <code>async</code> and <code>await</code>.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>More about asynchronous programming in .NET</h1>
<p>There are <a id="_idIndexMarker227"/>two types of scenarios where async code is usually introduced:</p>
<ul>
<li><strong class="bold">I/O-bound operations</strong>: These involve resources fetched from the network or disk.</li>
<li><strong class="bold">CPU-bound operations</strong>: These are in-memory, CPU-intensive operations.</li>
</ul>
<p>In this section, we will create some real-world examples that use <code>async</code> and <code>await</code> for each type of operation. Whether you are waiting for an external process to complete or performing CPU-intensive operations within your application, you can leverage asynchronous code to improve your application’s performance. </p>
<p>Let’s start by looking at some examples of I/O-bound operations.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>I/O-bound operations</h2>
<p>When you <a id="_idIndexMarker228"/>are working with I/O-bound code that is <a id="_idIndexMarker229"/>constrained by file or network operations, your code should use <code>async</code> and <code>await</code> to wait for the operations to complete. </p>
<p>The .NET methods<a id="_idIndexMarker230"/> to perform network and file I/O are asynchronous, so the use of <code>Task.Run</code> will not be necessary:</p>
<ul>
<li><code>ReadToEndAsync</code> method, splits the text where <code>Environment.NewLine</code> characters are found, and returns the data as a <code>List&lt;string&gt;</code> instance. Each line of text from the file is an item in the list:<pre>public async Task&lt;List&lt;string&gt;&gt; GetDataAsync
    (string filePath)
{
    using var file = File.OpenText(filePath);
    var data = await file.ReadToEndAsync();
    return data.Split(new[] { Environment.NewLine },
        StringSplitOptions.RemoveEmptyEntries)
            .ToList();
}</pre></li>
<li><code>HttpClient</code> class to download a file from the provided URL with the <code>await</code> keyword before splitting and returning the lines of text in a list:<pre>public async Task&lt;List&lt;string&gt;&gt; GetOnlineDataAsync
    (string url)
{
    var httpClient = new HttpClient();
    var data = await httpClient.GetStringAsync(url);
    return data.Split(new[] { Environment.NewLine },
        StringSplitOptions.RemoveEmptyEntries)
            .ToList();
}</pre></li>
</ul>
<p>Those are some <a id="_idIndexMarker231"/>common I/O-bound operations, but what is a CPU-bound operation and how does it differ?</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>CPU-bound operations</h2>
<p>In this <a id="_idIndexMarker232"/>case, your application is not <a id="_idIndexMarker233"/>waiting for an external process to complete. The application itself is performing a CPU-intensive operation that takes time to complete, and you want the application to remain responsive until the operation has finished.</p>
<p>In this example, we<a id="_idIndexMarker234"/> have a method that accepts a <code>List&lt;string&gt;</code> instance where each item in the list contains an XML representation of this <code>JournalEntry</code> class:</p>
<pre class="source-code">[Serializable]</pre>
<pre class="source-code">public class JournalEntry</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    public string Title { get; set; }</pre>
<pre class="source-code">    public string Description { get; set; }</pre>
<pre class="source-code">    public DateTime EntryDate { get; set; }</pre>
<pre class="source-code">    public string EntryText { get; set; }</pre>
<pre class="source-code">}</pre>
<p>Let’s assume that <code>EntryText</code> can be extremely large because some users who write in the journal application will add dozens of pages of text to a single entry. Each entry is stored in a database as XML and the application that loads the entries has a <code>DeserializeEntries</code> method to deserialize each XML string and return the data as a <code>List&lt;JournalEntry&gt;</code> instance:</p>
<pre class="source-code">private List&lt;JournalEntry&gt; DeserializeEntries(List&lt;string&gt; </pre>
<pre class="source-code">    journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    var serializer = new XmlSerializer(typeof</pre>
<pre class="source-code">        (JournalEntry));</pre>
<pre class="source-code">    foreach (var xmlEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (xmlEntry == null) continue;</pre>
<pre class="source-code">        using var reader = new StringReader(xmlEntry);</pre>
<pre class="source-code">        var entry = (JournalEntry)serializer.Deserialize</pre>
<pre class="source-code">            (reader)!;</pre>
<pre class="source-code">        if (entry == null) continue;</pre>
<pre class="source-code">        deserializedEntries.Add(entry);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<p>After months<a id="_idIndexMarker235"/> of adding journal entries, users are complaining about the time it takes to load the existing entries. They would like to start creating a new entry while the data is loading. </p>
<p>Luckily, using <a id="_idIndexMarker236"/>asynchronous .NET code can keep an application’s user interface responsive while waiting for a long-running process to complete. The thread is free to perform other work until the non-blocking call is completed. By adding an async method named <code>DeserializeJournalDataAsync</code> that calls the existing method with an awaited <code>Task.Run</code> method, the client code can remain responsive while users create new journal entries:</p>
<pre class="source-code">public async Task&lt;List&lt;JournalEntry&gt;&gt; </pre>
<pre class="source-code">    DeserializeJournalDataAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    return await Task.Run(() =&gt; DeserializeEntries</pre>
<pre class="source-code">        (journalData));</pre>
<pre class="source-code">}</pre>
<p>If you’re <a id="_idIndexMarker237"/>working with serialized data in JSON format instead of XML, the synchronous and asynchronous methods of deserialization are very similar. This is because .NET provides both<a id="_idIndexMarker238"/> the <code>Deserialize</code> and <code>DeserializeAsync</code> methods in the <code>System.Text.Json.JsonSerializer</code> class. Here are both methods with their differences highlighted:</p>
<pre class="source-code">public <strong class="bold">List&lt;JournalEntry&gt;</strong> DeserialzeJsonEntries</pre>
<pre class="source-code">    (List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    foreach (var jsonEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (string.IsNullOrWhiteSpace(jsonEntry)) continue;</pre>
<pre class="source-code">        <strong class="bold">deserializedEntries.Add(JsonSerializer.Deserialize</strong></pre>
<pre class="source-code"><strong class="bold">            &lt;JournalEntry&gt;(jsonEntry)!);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<pre class="source-code">public <strong class="bold">async Task&lt;List&lt;JournalEntry&gt;&gt;</strong> Deserialize</pre>
<pre class="source-code">     JsonEntriesAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    foreach (var jsonEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (string.IsNullOrWhiteSpace(jsonEntry)) continue;</pre>
<pre class="source-code">        <strong class="bold">using var stream = new MemoryStream(Encoding</strong></pre>
<pre class="source-code"><strong class="bold">            .Unicode.GetBytes(jsonEntry));</strong></pre>
<pre class="source-code"><strong class="bold">        deserializedEntries.Add((await JsonSerializer</strong></pre>
<pre class="source-code"><strong class="bold">            .DeserializeAsync&lt;JournalEntry&gt;(stream))!);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<p>The <code>Deserialize</code> method accepts <code>string</code>, but <code>DeserializeAsync</code> does not. Instead, we must create a <code>MemoryStream</code> instance from the <code>jsonEntry</code> string to pass to <code>DeserializeAsync</code>. Other than that, only the return types of the methods differ.</p>
<p>Let’s wrap<a id="_idIndexMarker239"/> up this section by <a id="_idIndexMarker240"/>looking at one more method for handling JSON deserialization of a list of journal entries. In this example, the method that deserializes the data only processes a single JSON entry. A parent method named <code>GetJournalEntriesAsync</code> uses a LINQ <code>Select</code> operator to call <code>DeserializeJsonEntryAsync</code> for each string in the list and stores an <code>IEnumerable&lt;Task&lt;JournalEntry&gt;&gt;</code> instance in a <code>getJournalTasks</code> variable:</p>
<pre class="source-code">public async Task&lt;List&lt;JournalEntry&gt;&gt; </pre>
<pre class="source-code">    GetJournalEntriesAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var journalTasks = journalData.Select(entry =&gt; </pre>
<pre class="source-code">        DeserializeJsonEntryAsync(entry));</pre>
<pre class="source-code">    return (<strong class="bold">await Task.WhenAll(journalTasks)</strong>).ToList();</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task&lt;JournalEntry&gt; DeserializeJsonEntryAsync</pre>
<pre class="source-code">    (string jsonEntry)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    if (string.IsNullOrWhiteSpace(jsonEntry)) return new </pre>
<pre class="source-code">        JournalEntry();</pre>
<pre class="source-code">    using var stream = new MemoryStream</pre>
<pre class="source-code">        (Encoding.Unicode.GetBytes(jsonEntry));</pre>
<pre class="source-code">    return (await JsonSerializer.DeserializeAsync</pre>
<pre class="source-code">        &lt;JournalEntry&gt;(stream))!;</pre>
<pre class="source-code">}</pre>
<p>The highlighted <a id="_idIndexMarker241"/>code awaits all the <code>Task</code> objects in <code>journalTasks</code>, returning the results of every call as an array of <code>JournalEntry</code> objects. You can either declare <code>GetJournalEntriesAsync</code> with a return type of <code>Task&lt;JournalEntry[]&gt;</code> or use <code>ToList</code>, as we have in this sample, to return <code>Task&lt;List&lt;JournalEntry&gt;&gt;</code>. You can see how LINQ streamlines your code when it is necessary to iterate over a list of items and make an async call with each item.</p>
<p>You have seen some different ways to use async and await in your code for both I/O-bound and CPU-bound operations. </p>
<p>Next, we will discuss how <strong class="bold">nested async methods</strong> are chained and how to start the top level of that chain.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Nested async methods</h2>
<p>When it <a id="_idIndexMarker242"/>comes to using async methods, it is important to use <code>await</code> when you want to preserve the order of execution. It is also important to preserve that chain of awaited calls to the entry point for the current thread.</p>
<p>For example, if your <a id="_idIndexMarker243"/>application is a console application, the primary entry point is the <code>Main</code> method in <code>Program.cs</code>. If you cannot make this <code>Main</code> method <code>async</code>, then none of the method calls beneath <code>Main</code> are made with the <code>await</code> keyword. That is the reason why .NET now supports <code>async</code> <code>Main</code> methods. Now, when you create a new console application with .NET 6, it has an <code>async</code> <code>Main</code> method by default.</p>
<p>If the entry point for execution is an event handler, you should mark the event handler method as <code>async</code>. This is the only time you will see <code>async</code> methods with a <code>void</code> return type:</p>
<pre class="source-code">private async void saveButton_Click(object sender, </pre>
<pre class="source-code">    EventArgs e)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await SaveData();</pre>
<pre class="source-code">}</pre>
<p>Let’s look at <a id="_idIndexMarker244"/>an example of the right way to chain multiple nested async methods in a console application:</p>
<ol>
<li>Start by creating a new console application. Inside a folder named <code>AsyncSamples</code>, run the following command:<pre>dotnet new console –framework net6.0</pre></li>
<li>When the process completes, open the new <code>AsyncSamples.csproj</code> in Visual Studio Code or your editor of choice.</li>
<li>Add a new class to the project named <code>TaskSample</code></li>
<li>Add the following code to the <code>TaskSample</code> class:<pre>public async Task DoThingsAsync()
{
    Console.WriteLine($"Doing things in 
        {nameof(DoThingsAsync)}");
    await DoFirstThingAsync();
    await DoSecondThingAsync();
    Console.WriteLine($"Did things in 
        {nameof(DoThingsAsync)}");
}
private async Task DoFirstThingAsync()
{
    Console.WriteLine($"Doing something in 
        {nameof(DoFirstThingAsync)}");
    await DoAnotherThingAsync();
    Console.WriteLine($"Did something in 
        {nameof(DoFirstThingAsync)}");
}
private async Task DoSecondThingAsync()
{
    Console.WriteLine($"Doing something in 
        {nameof(DoSecondThingAsync)}");
    await Task.Delay(500);
    Console.WriteLine($"Did something in 
        {nameof(DoSecondThingAsync)}");
}
private async Task DoAnotherThingAsync()
{
    Console.WriteLine($"Doing something in 
        {nameof(DoAnotherThingAsync)}");
    await Task.Delay(1500);
    Console.WriteLine($"Did something in 
        {nameof(DoAnotherThingAsync)}");
}</pre></li>
<li>Now <a id="_idIndexMarker245"/>open <code>Program.cs</code> and<a id="_idIndexMarker246"/> add some code to call <code>DoThingsAsync</code>:<pre>using AsyncSamples;
Console.WriteLine("Start processing"…");
var taskSample = new TaskSample();
await taskSample.DoThingsAsync();
Console.WriteLi"e("Done processing"..");</pre></li>
</ol>
<p>Let’s illustrate the order and hierarchy of the methods being called by our project. The <code>Main</code> method calls <code>DoThingsAsync</code>, which in turn calls <code>DoFirstThingAsync</code> and <code>DoSecondThingAsync</code>. Finally, within <code>DoFirstThingAsync</code>, <code>DoAnotherThingAsync</code> is called. When each of these <code>async</code> methods is called with the <code>await</code> operator, the order of operations is predictable:</p>
<div><div><img alt="Figure 5.1: The order of operations for awaited methods " height="472" src="img/Figure_5.1_B18552.jpg" width="953"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: The order of operations for awaited methods</p>
<ol>
<li value="6">Run <a id="_idIndexMarker247"/>the program and examine the<a id="_idIndexMarker248"/> order of the console output. Everything should be executing in the expected order:</li>
</ol>
<div><div><img alt="Figure 5.2: Examining the output of the AsyncSamples console application " height="404" src="img/Figure_5.2_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Examining the output of the AsyncSamples console application</p>
<ol>
<li value="7">Next, we <a id="_idIndexMarker249"/>will add two additional <a id="_idIndexMarker250"/>methods to the <code>TaskSample</code> class:<pre>public async Task DoingThingsWrongAsync()
{
    Console.WriteLine($"Doing things in 
        {nameof(DoingThingsWrongAsync)}");
    DoFirstThingAsync();
    await DoSecondThingAsync();
    Console.WriteLine($"Did things in 
        {nameof(DoingThingsWrongAsync)}");
}
public async Task DoBlockingThingsAsync()
{
    Console.WriteLine($"Doing things in 
        {nameof(DoBlockingThingsAsync)}");
    DoFirstThingAsync().Wait();
    await DoSecondThingAsync();
    Console.WriteLine($"Did things in 
        {nameof(DoBlockingThingsAsync)}");
}</pre></li>
</ol>
<p>The <code>DoingThingsWrongAsync</code> method has removed the <code>await</code> from the call to <code>DoFirstThingAsync</code>. So, the execution of <code>DoSecondThingAsync</code> will begin before <code>DoFirstThingAsync</code> has been completed. That might be OK if none of the subsequent code relies on the processing that happens within <code>DoFirstThingAsync</code>. However, any unhandled exceptions inside a method that is not<a id="_idIndexMarker251"/> awaited will not automatically bubble up to the <code>calling</code> method. The <code>Task</code> instance for the call will have a <code>Status</code> value of <code>Faulted</code>, the <code>IsFaulted</code> property will be <code>true</code>, and the <code>Exception</code> property will contain the unhandled exception information.</p>
<p>In the<a id="_idIndexMarker252"/> preceding case, any unhandled exceptions in <code>DoFirstThingAsync</code> will go undetected. If you have a case where you are not awaiting a <code>Task</code> instance, be sure to monitor the status of the <code>Task</code> instance in case of exceptions. This is one of the reasons why you should never have an <code>async void</code> method. It does not return a <code>Task</code> instance to be awaited.</p>
<p>The <code>DoBlockingThings</code> method will maintain the correct order of operations, but by calling <code>DoFirstThingAsync().Wait()</code> instead of awaiting the call, the thread executing <code>DoBlockingThings</code> will be blocked. It will wait for the call to <code>DoFirstThingAsync</code> to complete instead of being free to pick <a id="_idIndexMarker253"/>up other work until the long-running async method completes. Using blocking calls such as <code>Wait()</code> or <code>Result</code> can quickly deplete the available threads in <code>ThreadPool</code>.</p>
<ol>
<li value="8">Update <code>Program.cs</code> to call all three of the public <code>TaskSample</code> methods:<pre>using AsyncSamples;
Console.WriteLine("Start processing...");
var taskSample = new TaskSample();
await taskSample.DoThingsAsync();
Console.WriteLine("Continue processing...");
await taskSample.DoingThingsWrongAsync();
Console.WriteLine("Continue processing...");
await taskSample.DoBlockingThingsAsync();
Console.WriteLine("Done processing...");</pre></li>
<li>Now <a id="_idIndexMarker254"/>run the program and examine the console output to see how it is impacted by omitting <code>await</code> inside <code>DoingThingsWrongAsync</code>:</li>
</ol>
<div><div><img alt="Figure 5.3: Console output when calling all the TaskSample methods " height="685" src="img/Figure_5.3_B18552.jpg" width="1262"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Console output when calling all the TaskSample methods</p>
<p>The <a id="_idIndexMarker255"/>output <a id="_idIndexMarker256"/>may differ a little each time, depending on how the <code>ThreadPool</code> threads are allocated. In this case, the second call to <code>DoFirstThingAsync</code> remains incomplete until the third call to that same method starts. Even though <code>Program.cs</code> awaits its call to <code>DoingThingsWrongAsync</code>, the code inside of that method was still executing after the next call to <code>DoBlockingThingsAsync</code> was invoked.</p>
<p>Things can get very unpredictable when async tasks are not awaited. You should always await a task unless you have a good reason not to do so. Next, let’s explore some properties and methods available in the <code>Task</code> class.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Working with Task objects</h1>
<p>Working<a id="_idIndexMarker257"/> directly with <code>Task</code> objects can be extremely useful when introducing threading to existing projects. As we saw in the previous section, it is important to update the entire call stack when introducing <code>async</code> and <code>await</code>. On a large code base, those changes could be extensive and would require quite a bit of regression testing.</p>
<p>You can<a id="_idIndexMarker258"/> instead use <code>Task</code> and <code>Task&lt;TResult&gt;</code> to wrap the existing methods that you want to run asynchronously. Both <code>Task</code> types represent the asynchronous work being done by a method or action. You use <code>Task</code> when a method would have otherwise returned void. Use <code>Task&lt;TResult&gt;</code> with methods that have a non-void return type. </p>
<p>Here are examples of two synchronous method signatures and their async equivalents:</p>
<pre class="source-code">public interface IAsyncExamples</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    void ProcessOrders(List&lt;Order&gt; orders);</pre>
<pre class="source-code">    Task ProcessOrdersAsync(List&lt;Order&gt; orders);</pre>
<pre class="source-code">    List&lt;Order&gt; GetOrders(int customerId);</pre>
<pre class="source-code">    Task&lt;List&lt;Order&gt;&gt; GetOrdersAsync(int customerId);</pre>
<pre class="source-code">}</pre>
<p>We have seen some examples of using <code>Task</code> objects in this chapter. Now it is time to explore additional properties, methods, and uses of these two types.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Exploring Task methods</h2>
<p>To start, we will <a id="_idIndexMarker259"/>discover some commonly used <code>Task</code> methods in practical examples. Consider the ProcessOrders method that accepts a list of orders to be processed and submitted. The four <code>Task</code> methods used are as follows:</p>
<ul>
<li><code>Task.Run</code>: Runs a <a id="_idIndexMarker260"/>method on a thread on the thread pool</li>
<li><code>Task.Factory.StartNew</code>: Runs <a id="_idIndexMarker261"/>a method on a thread on the thread pool, with <code>TaskCreationOptions</code> provided</li>
<li><code>processOrdersTask.ContinueWith</code>: When the <code>processOrdersTask</code> completes, it <a id="_idIndexMarker262"/>will execute the method provided on the same thread pool thread.</li>
<li><code>Task.WaitAll</code>: This<a id="_idIndexMarker263"/> method will block the current thread and wait for all tasks in the array.</li>
</ul>
<p>These <a id="_idIndexMarker264"/>methods have been highlighted in the following code:</p>
<pre class="source-code">public void ProcessOrders(List&lt;Order&gt; orders, int </pre>
<pre class="source-code">    customerId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task&lt;List&lt;Order&gt;&gt; processOrdersTask = Task.<strong class="bold">Run</strong>(() =&gt; </pre>
<pre class="source-code">        PrepareOrders(orders));</pre>
<pre class="source-code">    Task labelTask = Task.Factory.<strong class="bold">StartNew</strong>(() =&gt; </pre>
<pre class="source-code">        CreateLabels(orders), TaskCreationOptions</pre>
<pre class="source-code">            .LongRunning);</pre>
<pre class="source-code">    Task sendTask = processOrdersTask.<strong class="bold">ContinueWith</strong>(task =&gt; </pre>
<pre class="source-code">        SendOrders(task.Result));</pre>
<pre class="source-code">    Task.<strong class="bold">WaitAll</strong>(new[] { labelTask, sendTask });</pre>
<pre class="source-code">    SendConfirmation(customerId);</pre>
<pre class="source-code">}</pre>
<p>This is what is happening on each line of the preceding example:</p>
<ol>
<li value="1"><code>Task.Run</code> will create a new background thread and queue it on <code>ThreadPool</code></li>
<li><code>Task.Factory.StartNew</code> will also create a new background thread and queue it on <code>ThreadPool</code>. In addition, we are providing <code>TaskCreattionOptions.LongRunning</code> as a parameter of <code>StartNew</code> to indicate that creating additional threads is warranted because this task may take a while to complete. This will prevent delays for other tasks queued on <code>ThreadPool</code>.</li>
<li><code>ContinueWith</code> will queue <code>SendOrders</code> on a <code>ThreadPool</code> thread, but the thread will not start until <code>processOrdersTask</code> has been completed.</li>
<li><code>Task.WaitAll</code> is the synchronous equivalent of the <code>async</code> method, <code>Task.WhenAll</code>. It will block the current thread until <code>labelTask</code> and <code>sendTask</code> are complete.</li>
<li>Finally, <code>SendConfirmation</code> is called to notify the customer that their orders have been processed and sent.</li>
</ol>
<p>Using<a id="_idIndexMarker265"/> tasks in this way can achieve the same result as an <code>async</code> method that awaits tasks to achieve parallel processing. The main difference is that the current thread will be blocked at <em class="italic">step 4</em> when <code>WaitAll</code> is called.</p>
<p>Another useful method we will explore next is <code>RunSynchronously</code>. This starts a task but executes it synchronously on the current thread. The asynchronous equivalent is to call <code>Start</code> on a task. </p>
<p>In this example, the <code>ProcessData</code> method accepts a parameter indicating whether the data must be processed on the UI thread. It is possible that some data processing requires interacting with the UI to present the user with some options or other feedback:</p>
<pre class="source-code">public void ProcessData(object data, bool uiRequired)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task processTask = new(() =&gt; DoDataProcessing(data));</pre>
<pre class="source-code">    if (uiRequired)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        // Run on current thread (UI thread assumed for </pre>
<pre class="source-code">            example)</pre>
<pre class="source-code">        processTask.RunSynchronously();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    else</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        // Run on ThreadPool thread in background</pre>
<pre class="source-code">        processTask.Start();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Next, let’s explore <a id="_idIndexMarker266"/>some of the properties of the <code>Task</code> and <code>Task&lt;TResult&gt;</code> classes.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Exploring Task properties</h2>
<p>In this section, we<a id="_idIndexMarker267"/> will review the properties available on a <code>Task</code> object. Most of the properties are related to the status of a task, so we will start with the <code>Status</code> property. The <code>Status</code> property returns <code>TaskStatus</code>, which is an enumeration with eight possible values:</p>
<ul>
<li><code>Created (0)</code>: The task has been created and initialized but has not been scheduled on <code>ThreadPool</code>.</li>
<li><code>WaitingForActivation (1)</code>: The task is waiting to be scheduled by .NET</li>
<li><code>WaitingToRun (2)</code>: The task has been scheduled but has not started executing yet</li>
<li><code>Running (3)</code>: The task is currently running.</li>
<li><code>WaitingForChildrenToComplete (4)</code>: The task has been completed but there are attached child tasks that are still running or waiting to run</li>
<li><code>RanToCompletion (5)</code>: The task successfully ran to completion</li>
<li><code>Canceled (6)</code>: The task was canceled and acknowledged the cancellation</li>
<li><code>Faulted (7)</code>: An unhandled exception was encountered while executing the task</li>
</ul>
<p>The following properties of <code>Task</code> and <code>Task&lt;TResult&gt;</code> are shortcuts to check statuses:</p>
<ul>
<li><code>IsCanceled</code>: Returns <code>true</code> if the task’s <code>Status</code> is <code>Canceled</code></li>
<li><code>IsCompleted</code>: Returns <code>true</code> if the task’s <code>Status</code> is <code>RanToCompletion</code>, <code>Canceled</code>, or <code>Faulted</code></li>
<li><code>IsCompletedSuccessfully</code>: Returns <code>true</code> if the task’s <code>Status</code> is <code>RanToCompletion</code></li>
<li><code>IsFaulted</code>: Returns <code>true</code> if the task’s <code>Status</code> is <code>Faulted</code></li>
</ul>
<p>Using<a id="_idIndexMarker268"/> these properties can streamline status checks in your code. The remaining instance properties of the <code>Task</code> object follow:</p>
<ul>
<li><code>AsyncState</code>: Returns the state that was provided when creating the task. If no state was provided, this property returns <code>null</code></li>
<li><code>CreationOptions</code>: Returns the <code>CreationOptions</code> values that were provided when creating the task. If no options were provided, it defaults to <code>TaskCreationOptions.None</code>.</li>
<li><code>Exception</code>: Returns an <code>AggregateException</code> instance containing unhandled exceptions encountered while the task was running. <code>Wait</code> or <code>WaitAll</code> should be called in a <code>try</code>/<code>catch</code> block that handles the <code>AggregateException</code> type.</li>
<li><code>Id</code>: A system-assigned identifier for the task</li>
</ul>
<p>Let’s take a quick look at how to correctly catch an <code>AggregateException</code> instance and inspect the <code>Exception</code> property of the faulted task:</p>
<pre class="source-code">Task ordersTask = Task.Run(() =&gt; ProcessOrders(orders, </pre>
<pre class="source-code">    123));</pre>
<pre class="source-code">try</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    ordersTask.Wait();</pre>
<pre class="source-code">    Console.WriteLine($"ordersTask Status: </pre>
<pre class="source-code">        {ordersTask.Status}");</pre>
<pre class="source-code">} </pre>
<pre class="source-code">catch (AggregateException)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine($"Exception in ordersTask! Error </pre>
<pre class="source-code">        message: {ordersTask.Exception.Message}");</pre>
<pre class="source-code">}   </pre>
<p>This <a id="_idIndexMarker269"/>code will write the status of the task to the console after completion. If an unhandled exception is encountered, the error message will be written to the console in the <code>catch</code> block.</p>
<p>Now that you’re more familiar with the members of <code>Task</code> and <code>Task&lt;TResult&gt;</code>, let’s discuss some use cases for calling synchronous code from async code and vice versa.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Interop with synchronous code</h1>
<p>When working with<a id="_idIndexMarker270"/> existing projects and introducing async code to the system, there will be points where synchronous and asynchronous code intersect. We have already seen some examples of how to handle this interop in this chapter. In this section, we will focus on that interop in both directions: sync calling async and async calling sync. </p>
<p>We will create a sample project with classes containing synchronous methods representing legacy code and another set of classes with modern <code>async</code> methods.</p>
<p>Let’s start by discussing how to consume <code>async</code> methods in your legacy synchronous code.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Executing async from synchronous methods</h2>
<p>In this example, we will be<a id="_idIndexMarker271"/> working with a .NET console application that gets a patient and their list of medications. The application will call a synchronous <code>GetPatientAndMedications</code> method that in turn calls an async <code>GetPatientInfoAsync</code> method:</p>
<ol>
<li value="1">Start by <a id="_idIndexMarker272"/>creating a new .NET console application</li>
<li>Add <code>Patient</code>, <code>Provider</code>, and <code>Medication</code> classes to a <code>Models</code> folder and <code>HealthcareService</code> and <code>MedicationLoader</code> classes to a <code>SyncToAsync</code> folder:</li>
</ol>
<div><div><img alt="Figure 5.4: The initial project structure for calling async from sync code " height="572" src="img/Figure_5.4_B18552.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: The initial project structure for calling async from sync code</p>
<ol>
<li value="3">Add the necessary properties for the model classes:<pre>public class Medication
{
    public int Id { get; set; }
    public string? Name { get; set; }
}
public class Provider
{
    public int Id { get; set; }
    public string? Name { get; set; }
}
public class Patient
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public List&lt;Medication&gt;? Medications { get; set; }
    public Provider? PrimaryCareProvider { get; set; }
}</pre></li>
<li>Create<a id="_idIndexMarker273"/> the <code>GetPatientInfoAsync</code> method in the <code>HealthcareService</code> class. This method creates a patient with a provider and two medications after injecting a 2-second async delay:<pre>public async Task&lt;Patient&gt; GetPatientInfoAsync
    (int patientId)
{
    await Task.Delay(2000);
    Patient patient = new()
    {
        Id = patientId,
        Name = "Smith, Terry",
        PrimaryCareProvider = new Provider
        {
            Id = 999,
            Name = "Dr. Amy Ng"
        },
        Medications = new List&lt;Medication&gt;
        {
            new Medication { Id = 1, Name = 
                "acetaminophen" },
            new Medication { Id = 2, Name = 
                "hydrocortisone cream" }
        }
    };
    return patient;
}</pre></li>
<li>Add the<a id="_idIndexMarker274"/> implementation for the <code>MedicationLoader</code> service:<pre>public class MedicationLoader
{
    private HealthcareService _healthcareService;
    public MedicationLoader()
    {
        _healthcareService = new HealthcareService();
    }
    public Patient? GetPatientAndMedications(int 
        patientId)
    {
        Patient? patient = null;
        try
        {
            <strong class="bold">patient = _healthcareService</strong>
<strong class="bold">               .GetPatientInfoAsync(patientId).Result;</strong>
        }
        catch (AggregateException ae)
        {
            Console.WriteLine($"Error loading patient. 
                Message: {ae.Flatten().Message}");
        }
        if (patient != null)
        {
            patient = ProcessPatientInfo(patient);
            return patient;
        }
        else
        {
            return null;
        }
    }
    private Patient ProcessPatientInfo(Patient 
        patient)
    {
        // Add additional processing here.
        return patient;
    }
}</pre></li>
</ol>
<p>The <code>GetPatientAndMedications</code> method calls <code>GetPatientInfoAsync</code> and uses the <code>Result</code> property to synchronously wait for the <code>async</code> method to complete and return the value. Using <code>Result</code> is the same <a id="_idIndexMarker275"/>as using the <code>Wait()</code> method on an <code>async</code> method that returns no value. The current thread is blocked until the method completes.</p>
<p>We have wrapped the call in a <code>try</code>/<code>catch</code> block that handles an <code>AggregateException</code> instance. If the call was successful, and the <code>patient</code> variable is not <code>null</code>, <code>ProcessPatientInfo</code> is called before returning the patient data to the caller.</p>
<ol>
<li value="6">Add this code to <code>Program.cs</code> to call the synchronous method:<pre>using SyncAndAsyncSamples.Models;
using SyncAndAsyncSamples.SyncToAsync;
Console.WriteLine("Hello, sync to async world!");
var medLoader = new MedicationLoader();
Patient? patient = medLoader.GetPatientAndMedications
    (123);
Console.WriteLine($"Loaded patient: {patient.Name} 
    with {patient.Medications.Count} medications.");</pre></li>
<li>Run the program. You should see this output in the window:</li>
</ol>
<pre>Hello, sync to async world!
Loaded patient: Smith, Terry with 2 medications.</pre>
<p>Next, let’s try to load the same data but with an <code>async</code> method calling some legacy synchronous code.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Executing synchronous code as async</h2>
<p>In this <a id="_idIndexMarker276"/>example, we will mirror the previous example. There will be a <code>PatientLoader</code> instance with async methods calling a <code>PatientService</code> instance with a synchronous method:</p>
<ol>
<li value="1">Add a <code>PatientService</code> class to a new <code>AsyncToSync</code> folder in your project.</li>
<li>Create a <code>GetPatientInfo</code> method with a similar implementation to the <code>GetPatientInfoAsync</code> method in the previous example:<pre>public Patient GetPatientInfo(int patientId)
{
    <strong class="bold">Thread.Sleep(2000);</strong>
    Patient patient = new()
    {
        Id = patientId,
        Name = "Smith, Terry",
        PrimaryCareProvider = new Provider
        {
            Id = 999,
            Name = "Dr. Amy Ng"
        },
        Medications = new List&lt;Medication&gt;
        {
            new Medication { Id = 1, Name = 
                "acetaminophen" },
            new Medication { Id = 2, Name = 
                "hydrocortisone cream" }
        }
    };
    return patient;
}</pre></li>
</ol>
<p>The differences here are that the method is not <code>async</code>, it returns a <code>Patient</code> instance instead of a <code>Task&lt;Patient&gt;</code> instance, and we’re injecting a delay with <code>Thread.Sleep</code> instead of <code>Task.Delay</code>.</p>
<ol>
<li value="3">Create <a id="_idIndexMarker277"/>the <code>PatientLoader</code> class in the <code>AsyncToSync</code> folder, and start its implementation by creating a new instance of <code>PatientService</code>:<pre>private PatientService _patientService = new 
    PatientService();</pre></li>
<li>Now create the async version of <code>ProcessPatientInfo</code> from the previous example:<pre>private async Task&lt;Patient&gt; ProcessPatientInfoAsync
    (Patient patient)
{
    await Task.Delay(100);
    // Add additional processing here.
    return patient;
}</pre></li>
<li>Now create the <code>GetPatientAndMedsAsync</code> method:<pre>public async Task&lt;Patient?&gt; GetPatientAndMedsAsync
    (int patientId)
{
    Patient? patient = null;
    try
    {
        <strong class="bold">patient = await Task.Run(() =&gt; </strong>
<strong class="bold">           _patientService.GetPatientInfo(patientId));</strong>
    }
    catch (<strong class="bold">Exception e</strong>)
    {
        Console.WriteLine($"Error loading patient. 
            Message: {e.Message}");
    }
    if (patient != null)
    {
        <strong class="bold">patient = await ProcessPatientInfoAsync</strong>
<strong class="bold">            (patient);</strong>
        return patient;
    }
    else
    {
        return null;
    }
}</pre></li>
</ol>
<p>The <a id="_idIndexMarker278"/>primary differences from the last example are highlighted. The <code>synchronous</code> class to <code>GetPatientInfo</code> is wrapped in a call to <code>await Task.Run</code>, which will wait for the call without blocking the current thread from performing other work.</p>
<p>We are now using <code>Exception</code> instead of <code>AggregateException</code> in the <code>catch</code> block. You should always use <code>AggregateException</code> with blocking <code>Wait</code> and <code>Result</code> calls and use <code>Exception</code> with <code>async</code> and <code>await</code>.</p>
<p>Finally, the async call to <code>ProcessPatientInfoAsync</code> is awaited if the <code>patient</code> variable is not <code>null</code>.</p>
<ol>
<li value="6">Next <a id="_idIndexMarker279"/>update <code>Program.cs</code> to call the new <code>PatientLoader</code> code:<pre>using SyncAndAsyncSamples.AsyncToSync;
using SyncAndAsyncSamples.Models;
Console.WriteLine("Hello, async to sync world!");
var loader = new PatientLoader();
Patient? patient = await loader.GetPatientAndMedsAsync
    (123);
Console.WriteLine($"Loaded patient: {patient.Name} 
    with {patient.Medications.Count} medications.");</pre></li>
<li>Run the program, and the output should look similar to the previous example:</li>
</ol>
<pre>Hello, async to sync world!
Loaded patient: Smith, Terry with 2 medications.</pre>
<p>By now, you should have a solid understanding of how to interop between asynchronous and synchronous code. Let’s move forward and create an example of loading data from several <code>async</code> methods in parallel.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Working with multiple background tasks</h1>
<p>In this section, we will<a id="_idIndexMarker280"/> see code samples for loading data from multiple sources in parallel, not waiting until the method is ready to return the data to the caller. The technique is slightly different for synchronous and asynchronous code, but the general idea is the same.</p>
<p>First, review this method that calls three async methods and uses <code>Task.WhenAll</code> to wait before returning the patient data:</p>
<pre class="source-code">public async Task&lt;Patient&gt; LoadPatientAsync(int patientId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var taskList = new List&lt;Task&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        LoadPatientInfoAsync(patientId),</pre>
<pre class="source-code">        LoadProviderAsync(patientId),</pre>
<pre class="source-code">        LoadMedicationsAsync(patientId)</pre>
<pre class="source-code">    };</pre>
<pre class="source-code">    <strong class="bold">await Task.WhenAll(taskList.ToArray());</strong></pre>
<pre class="source-code">    _patient.Medications = _medications;</pre>
<pre class="source-code">    _patient.PrimaryCareProvider = _provider;</pre>
<pre class="source-code">    return _patient;</pre>
<pre class="source-code">}</pre>
<p>Now, review this synchronous version of the method, which uses <code>Task.WaitAll</code>:</p>
<pre class="source-code">public Patient LoadPatient(int patientId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var taskList = new List&lt;Task&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        LoadPatientInfoAsync(patientId),</pre>
<pre class="source-code">        LoadProviderAsync(patientId),</pre>
<pre class="source-code">        LoadMedicationsAsync(patientId)</pre>
<pre class="source-code">    };</pre>
<pre class="source-code">    <strong class="bold">Task.WaitAll(taskList.ToArray());</strong></pre>
<pre class="source-code">    _patient.Medications = _medications;</pre>
<pre class="source-code">    _patient.PrimaryCareProvider = _provider;</pre>
<pre class="source-code">    return _patient;</pre>
<pre class="source-code">}</pre>
<p>Even this <a id="_idIndexMarker281"/>version of the code, which uses a blocking <code>WaitAll</code> call, will perform faster than making separate synchronous calls to the three methods.</p>
<p>The complete implementation of this <code>ParallelPatientLoader</code> class is available in the GitHub repository for this chapter. Let’s finish up the chapter by listing some best practices for using <code>async</code>, <code>await</code>, and <code>Task</code> objects.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Asynchronous programming best practices</h1>
<p>When<a id="_idIndexMarker282"/> working with async code, there are many best practices of which you should be aware. In this section, we will list the most important ones to remember in your day-to-day development. <strong class="bold">David Fowler</strong>, who is a veteran member of the ASP.NET team at Microsoft and a .NET expert, maintains an open source list of many other best practices. I recommend bookmarking this page for later reference while working with your own projects: <a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming">https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming</a>. </p>
<p>These are my top recommendations (in no particular order) to follow when working with async code:</p>
<ol>
<li value="1">Always prefer <code>async</code> and <code>await</code> over synchronous methods and blocking calls such as <code>Wait()</code> and <code>Result</code>. If you are creating a new project, you should build with async in mind from the start.</li>
<li>Unless you are using <code>Task.WhenAll</code> to wait for multiple operations simultaneously, you should directly await a method rather than creating a <code>Task</code> instance and awaiting it.</li>
<li>Do <a id="_idIndexMarker283"/>not use <code>async</code> <code>void</code>. Your async methods should always return <code>Task</code>, <code>Task&lt;TResult&gt;</code>, <code>ValueTask</code>, or <code>ValueTask&lt;TResult&gt;</code>. The only exceptions are event handlers that have existing signatures that return <code>void</code>. Event <code>Main</code> methods can be async in .NET 6.</li>
<li>Do not mix blocking code and asynchronous code. Use <code>async</code> calls through the call stack.</li>
<li>Use <code>Task.Run</code> instead of <code>Task.Factory.StartNew</code> unless you need to pass additional parameters to one of the <code>StartNew</code> overloaded methods.</li>
<li>Long-running <code>async</code> methods should support cancellation. We will discuss cancellation in depth in <a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>.</li>
<li>Synchronize the usage of shared data. Your code should add locks to prevent any overwriting of data in objects used across threads.</li>
<li>Always use <code>async</code> and <code>await</code> for I/O-bound work such as network and file access.</li>
<li>When you create an <code>async</code> method, add the <code>Async</code> suffix to its name. This helps to differentiate <code>sync</code> and <code>async</code> methods at a glance. An <code>async</code> method to return user information should be named <code>GetUserInfoAsync</code>, not <code>GetUserInfo</code>.</li>
<li>Do not use <code>Thread.Sleep</code> in async methods. If your code must wait for a fixed period, use <code>await Task.Delay</code>.</li>
</ol>
<p>Those are my 10 rules to get you started, but there are many more best practices for async development with .NET. We will discover more of them as we progress through the remaining chapters.</p>
<p>Let’s wrap up and review what we have learned about async programming in this chapter.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Summary</h1>
<p>In this chapter, we have covered quite a bit of information about asynchronous development with C# and. NET. We started by covering some of the ways to handle I/O-bound and CPU-bound operations in your applications. </p>
<p>Next, we created some practical examples that use the <code>Task</code> and <code>Task&lt;TResult&gt;</code> classes and discovered how to work with multiple <code>Task</code> objects. You got some practical advice for interop between modern asynchronous code and legacy synchronous methods. Finally, we covered some of the most important rules to remember when working with asynchronous code and <code>Task</code> objects.</p>
<p>In the next chapter, <a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, you will learn the ins and outs of parallel programming in .NET using the <strong class="bold">Task Parallel Library </strong>(<strong class="bold">TPL</strong>) and learn how to the avoid common pitfalls of parallel programming.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Questions</h1>
<ol>
<li value="1">Which property of <code>Task</code> makes a blocking call to return data from the underlying method?</li>
<li>Which <code>async</code> method of the <code>Task</code> class should be used to await multiple tasks?</li>
<li>What is the blocking equivalent of <code>Task.WhenAll()</code>?</li>
<li>What type should an <code>async</code> method always return?</li>
<li>Are <code>async</code> methods more suited to I/O-bound or CPU-bound operations?</li>
<li><em class="italic">True or false</em>: <code>Async</code> methods should never end with <code>Async</code> as their suffix.</li>
<li>What method can be used to wrap a synchronous method in an <code>async</code> call?</li>
</ol>
</div>
</div>
</body></html>