- en: Chapter 7. Patterns in the .NET Base Class Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. .NET基础类库中的模式
- en: 'In this chapter, we will focus on areas where the creators of the .NET Framework
    library have leveraged GoF design patterns for creating **Application Programming
    Interfaces** (**APIs**). This will give you an enormous insight into the usage
    of design patterns as a mechanism to expose well-defined software interfaces.
    Most developers consume design pattern-based software interfaces without knowing
    much about their underpinnings. This chapter will demystify API design based on
    patterns. As a reader, you will find real-world application of the following GoF
    patterns in the .NET Framework library:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注.NET Framework库的创建者如何利用GoF设计模式来创建**应用程序编程接口**（**APIs**）。这将使你对设计模式作为暴露定义良好的软件接口的机制有巨大的洞察力。大多数开发者消费基于设计模式的软件接口，而不太了解其基础。本章将揭示基于模式的API设计。作为读者，你将在.NET
    Framework库中找到以下GoF模式的实际应用：
- en: Adapter pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Strategy pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Builder pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者模式
- en: Decorator pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Chain of responsibility pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Bridge pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Factory pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Observer pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Composite pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: Facade pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Iterator pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Adapter pattern in the .NET BCL
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL中的适配器模式
- en: The adapter pattern (aka wrapper) translates one interface for a class into
    a compatible interface expected by the client. This allows objects to work together,
    which normally wouldn't because of incompatible interfaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式（也称为包装器）将一个类的接口转换为客户端期望的兼容接口。这允许对象协同工作，而这些对象通常因为接口不兼容而无法协同工作。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is achieved by providing its cooperating interface to clients while using
    the original interface to invoke the core functionality provided by the object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过向客户端提供其协作接口，同时使用原始接口调用对象提供的核心功能来实现。
- en: 'The amount of code necessary to do this is most often small. The adapter is
    also responsible for transforming data into appropriate forms expected by the
    library that implements the actual logic. The adapter can be a class adapter or
    an object adapter. The `SQLDataAdapter` class in .NET Framework represents a set
    of data commands (`select`, `update`, and `delete`) and a database connection
    that is used to fill the `DataSet` (in the case of select), or update the data
    source:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码量通常很小。适配器还负责将数据转换为库期望的适当形式，该库实现了实际逻辑。适配器可以是类适配器或对象适配器。.NET Framework中的`SQLDataAdapter`类代表一组数据命令（`select`、`update`和`delete`）和数据库连接，用于填充`DataSet`（在`select`的情况下），或更新数据源：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Strategy pattern in the .NET BCL
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL中的策略模式
- en: The strategy pattern (aka policy pattern) is a design pattern where we can choose
    algorithms depending upon the context. The pattern is intended to provide a means
    to define a family of algorithms encapsulated as an object to make them interchangeable.
    The strategy pattern lets the algorithms vary independently from the clients that
    use them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式（也称为策略模式）是一种设计模式，其中我们可以根据上下文选择算法。该模式旨在提供一种定义算法家族的方法，这些算法封装为对象以使它们可互换。策略模式允许算法独立于使用它们的客户端而变化。
- en: 'The `Array` and the `ArrayList` classes provide the capability to sort objects
    contained in them through the `Sort` method. One can use different strategies
    to sort by leveraging the strategy design pattern-based API provided by the .NET
    BCL. The designers of .NET Framework have given us the `IComparer<T>` interface
    to provide a sorting strategy. `Array` and `ArrayList` provide the capability
    to sort the objects contained in the collection via the `Sort` method. Strategy
    design pattern is used with `Array` and `Arraylist` to enable sorting using different
    strategies, without changing any client code, via an `IComparable` interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`和`ArrayList`类通过`Sort`方法提供了对它们包含的对象进行排序的能力。可以通过利用基于策略设计模式的API来使用不同的策略进行排序。.NET
    Framework的设计者为我们提供了`IComparer<T>`接口来提供排序策略。`Array`和`ArrayList`通过`Sort`方法提供了对集合中包含的对象进行排序的能力。策略设计模式与`Array`和`ArrayList`一起使用，以启用使用不同策略的排序，而无需更改任何客户端代码，通过`IComparable`接口：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To sort an `Employee` list, we need to create a class that implements the `IComparer<T>`
    interface. An instance of this class needs to be passed to the `Sort` routine
    of the `List<T>` instance. The `Compare` method of `IComparer<T>` should implement
    a `SIGNUM` function that returns `1`, `0`, or `-1`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 `Employee` 列表进行排序，我们需要创建一个实现 `IComparer<T>` 接口的类。这个类的实例需要传递给 `List<T>` 实例的
    `Sort` 例程。`IComparer<T>` 的 `Compare` 方法应该实现一个 `SIGNUM` 函数，该函数返回 `1`、`0` 或 `-1`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippets show how we can change sorting criteria depending
    on the context:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何根据上下文更改排序标准：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To sort by name, we need to create another object implementing the same interface:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要按名称排序，我们需要创建另一个实现相同接口的对象：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will leverage the `SortByName` class to sort the object based on the lexicographical
    order. We will also use the `StringBuilder` class to create a string object to
    be printed on the console. The `StringBuilder` class is an instance where the
    builder pattern is leveraged by the designers of .NET Framework:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 `SortByName` 类根据字典顺序对对象进行排序。我们还将使用 `StringBuilder` 类来创建一个要在控制台上打印的字符串对象。`StringBuilder`
    类是 .NET 框架设计者利用构建器模式的一个实例：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Builder pattern in the .NET BCL
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL 中的构建器模式
- en: 'The builder pattern is a creational pattern, which separates the construction
    of a complex object from its representation. Usually, it parses a complex representation
    to create one or more target objects. Most often, builders create composites.
    In the `System.Data.SqlClient` namespace, `SqlConnectionStringBuilder` helps one
    build connection strings for the purpose of connecting to an RDBMS engine:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式是一种创建型模式，它将复杂对象的构建与其表示分离。通常，它解析复杂的表示以创建一个或多个目标对象。大多数情况下，构建器创建复合对象。在 `System.Data.SqlClient`
    命名空间中，`SqlConnectionStringBuilder` 帮助构建连接字符串，用于连接到 RDBMS 引擎：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The .NET BCL also contains a class that will help us create a URI by assembling
    its constituents. The following code snippet creates a secured HTTP (`https`)
    URL, which sends data to port `3333`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL 也包含一个类，可以帮助我们通过组装其组成部分来创建 URI。以下代码片段创建了一个安全的 HTTP (`https`) URL，该 URL
    将数据发送到端口 `3333`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Decorator pattern in the .NET BCL
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL 中的装饰器模式
- en: 'The decorator pattern attaches additional responsibilities to an object dynamically.
    The inheritance is always not feasible, because it is static and applies to an
    entire class. Decorators provide a flexible alternative to sub-classing for extending
    functionality. The pattern helps add behavior or state to individual objects at
    runtime. The .NET Framework uses decorators in the case of stream processing classes.
    The hierarchy of stream processing classes are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式动态地为对象附加额外的职责。继承并不总是可行的，因为它总是静态的，并且适用于整个类。装饰器为扩展功能提供了对子类化的灵活替代方案。该模式有助于在运行时向单个对象添加行为或状态。.NET
    框架在流处理类的情况下使用了装饰器。流处理类的层次结构如下：
- en: '`System.IO.Stream`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.Stream`'
- en: '`System.IO.BufferedStream`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.BufferedStream`'
- en: '`System.IO.FileStream`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.FileStream`'
- en: '`System.IO.MemoryStream`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.MemoryStream`'
- en: '`System.Net.Sockets.NetworkStream`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.Sockets.NetworkStream`'
- en: '`System.Security.Cryptography.CryptoStream`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Security.Cryptography.CryptoStream`'
- en: 'The following code snippets show how one can use `FileStream` to read contents
    from an operating system disk file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用 `FileStream` 从操作系统磁盘文件中读取内容：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `StreamReader` is a decorator object, which uses the additional functionality
    of buffering the avoid disk access to speed up operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamReader` 是一个装饰器对象，它使用额外的缓冲功能来避免磁盘访问，从而加快操作速度。'
- en: Chain of responsibility pattern in ASP.net
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.net 中的责任链模式
- en: 'The chain of responsibility pattern is a design pattern consisting of a series
    of processing objects through which we pass a data stream for filtration or modification.
    Ultimately, the process terminates when the data stream passes the last processing
    object at the end of the chain. The ASP.NET pipeline is a wonderful example where
    the chain of responsibility pattern is leveraged to provide an extensible programming
    model. The ASP.NET infrastructure implements WebForms API, ASMX Web services,
    WCF, ASP.NET Web API, and ASP.NET MVC using HTTP modules and handlers. Every request
    in the pipeline passes through a series of modules (a class that implements `IHttpModule`)
    before it reaches its target handler (a class that implements `IHttpHandler`).
    Once a module in the pipeline has done its duty, it passes the responsibility
    of the request processing to the next module in the chain. Finally, it reaches
    the handler. The following code snippet shows how one can write an object that
    leverages the chain of responsibility pattern to create a module that filters
    an incoming request. These filters are configured as chains and will pass the
    request content to the next filter in the chain by the ASP.net runtime:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式是一种设计模式，它由一系列处理对象组成，我们通过这些对象传递数据流进行过滤或修改。最终，当数据流通过链尾的最后处理对象时，处理过程终止。ASP.NET
    管道是一个很好的例子，其中利用了责任链模式来提供一个可扩展的编程模型。ASP.NET 基础设施通过 HTTP 模块和处理器实现了 WebForms API、ASMX
    Web 服务、WCF、ASP.NET Web API 和 ASP.NET MVC。管道中的每个请求在到达目标处理器（实现 `IHttpHandler` 的类）之前都会通过一系列模块（实现
    `IHttpModule` 的类）。一旦管道中的模块完成了它的任务，它将请求处理的责任传递给链中的下一个模块。最后，它到达处理器。以下代码片段展示了如何编写一个利用责任链模式创建过滤传入请求的模块的对象。这些过滤器配置为链，并由
    ASP.net 运行时将请求内容传递给链中的下一个过滤器：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can configure the preceding HTTP module in the `Web.config` file as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Web.config` 文件中配置前面的 HTTP 模块如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the ASP.NET pipeline, a request passes through a series of HTTP modules
    before it hits a handler. A simple HTTP handler routine is given as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 管道中，一个请求在到达处理器之前会通过一系列 HTTP 模块。以下是一个简单的 HTTP 处理器例程：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can configure the handler as given next. Whenever we create an ASP.NET resource
    with the `.smp` extension, the handler will be `SimpleHttpHandler`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式配置处理器。每次我们创建一个具有 `.smp` 扩展名的 ASP.NET 资源时，处理器将是 `SimpleHttpHandler`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding technique of leveraging the chain of responsibility pattern is
    available in other web technologies such as Java Servlets (called Servlet filters)
    and also available in IIS as ISAPI filters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前利用责任链模式的技术在其他 Web 技术中也是可用的，例如 Java Servlets（称为 Servlet 过滤器），同样在 IIS 中也作为 ISAPI
    过滤器可用。
- en: Bridge pattern in the .NET RCW
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET RCW 中的桥接模式
- en: The **Component Object Model** (**COM**) technology solutions packaged as libraries
    can be consumed through **Runtime Callable Wrapper** (**RCW**), available in the
    .NET platform. By allowing managed classes and COM components to interact, despite
    their interface disparity, RCWs are an example of bridge pattern (implemented
    as an adapter!). Please consult the documentation on **Com Callable Wrapper**
    (**CCW**) and RCW to understand how the bridge pattern is implemented to interoperate
    with components written in other languages (mostly C++/ATL). Technically speaking,
    even ADO.NET API also leverages the bridge pattern, to interact with ODBC and
    other native drivers implemented by respective database vendors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为库打包的 **组件对象模型**（**COM**）技术解决方案可以通过 .NET 平台中的 **运行时调用包装器**（**RCW**）来使用。通过允许托管类和
    COM 组件交互，尽管它们的接口不同，RCWs 是桥接模式的一个例子（实现为一个适配器！）。请查阅有关 **Com Callable Wrapper**（**CCW**）和
    RCW 的文档，以了解桥接模式是如何实现与其他语言（主要是 C++/ATL）编写的组件进行互操作的。从技术上讲，ADO.NET API 也利用了桥接模式，以与数据库供应商实现的
    ODBC 和其他本地驱动程序进行交互。
- en: Factory pattern in the .NET BCL
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL 中的工厂模式
- en: 'The factory design pattern has been used by `System.Data.Common` to create
    an instance of the provider, connection, command, or adapter objects in order
    to fetch data from a relational database. The following code snippets demonstrates
    the idea:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式已被 `System.Data.Common` 用于创建提供程序、连接、命令或适配器对象实例，以便从关系型数据库中获取数据。以下代码片段展示了这一概念：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Observer pattern in the WPF
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WPF 中的观察者模式
- en: 'The `ObservableCollection` can be considered as a data structure, which leverages
    the observer pattern to provide notifications when items get added or removed,
    or when the whole list is refreshed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableCollection` 可以被视为一种数据结构，它利用观察者模式在项目被添加或删除，或者整个列表被刷新时提供通知：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code snippet creates an instance of an `Observableconnection` based
    `ObservableDataSource` class. When we add items to the class, we get a notification
    in the `OnCollectionDataChanged` method of the `ObservableDataSource` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个基于`Observableconnection`的`ObservableDataSource`类的实例。当我们向该类添加项目时，我们会在`ObservableDataSource`类的`OnCollectionDataChanged`方法中获得通知：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Composite pattern in the .NET Framework
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Framework中的组合模式
- en: To create complex UI screens, the .NET Framework leverages composite patterns
    extensively. The WPF, ASP.NET Web Forms, and Winforms are some of the key examples
    in this regard. In a UI scenario, one can have a frame class, which acts as a
    container for all the child controls. Typically, developers place panels to divide
    the physical screen to some kind of logical grouping and child controls are placed
    inside these panels. The controls like list, grid can embed other controls. Thus,
    these are wonderful examples of the composite pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建复杂的UI屏幕，.NET Framework广泛地利用组合模式。WPF、ASP.NET Web Forms和Winforms是这方面的关键示例。在UI场景中，可以有一个框架类，它充当所有子控件的容器。通常，开发者将面板放置以将物理屏幕划分为某种逻辑分组，并将子控件放置在这些面板中。列表、网格等控件可以嵌入其他控件。因此，这些都是组合模式的绝佳示例。
- en: Facade pattern in the .NET BCL
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL中的门面模式
- en: 'The GoF facade pattern is used in scenarios where a lot of work happens in
    the background and the interfaces to those classes are exposed using a simple
    API. The `XMLSeralizer` class in the .NET BCL does quite a bit of its work behind
    the scenes and access to those routines are given using a very simple interface.
    The following code snippets create a `DataSet` to store a multiplication table
    for the number `42` (remember Douglas Adams!) and the `XMLSeralizer` class persists
    the table to a text file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: GoF门面模式在后台发生大量工作且这些类的接口通过简单的API公开的场景中使用。.NET BCL中的`XMLSeralizer`类在其幕后做了大量工作，并通过一个非常简单的接口提供对这些例程的访问。以下代码片段创建了一个`DataSet`来存储数字`42`（记住道格拉斯·亚当斯！）的乘法表，并且`XMLSeralizer`类将表持久化到文本文件中：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Iterator pattern in the .NET BCL
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET BCL中的迭代器模式
- en: 'The iterator pattern is so common that most platforms and frameworks provide
    a mechanism to support it. The .NET BCL has got `IEnumerable` and its generic
    variant , that is, `IEnumerable<T>` to implement custom iterators. To iterate,
    we have got the `foreach` loop construct in C#. Similar constructs are available
    in Java as well. The following program creates a custom list by leveraging the
    .NET fixed length array facility:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式如此常见，以至于大多数平台和框架都提供了一种机制来支持它。.NET BCL有`IEnumerable`及其泛型变体，即`IEnumerable<T>`来实现自定义迭代器。为了迭代，我们有C#中的`foreach`循环结构。Java中也有类似的构造。以下程序通过利用.NET固定长度数组功能创建了一个自定义列表：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how the designers of the .NET BCL leverage design
    patterns to expose a well-defined programming model and a flexible API for the
    same. You learned about how some important patterns are put to use by the designers
    of the .NET Framework. In the next chapter, you will learn about concurrent and
    parallel programming in the .NET platform.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了.NET BCL的设计者如何利用设计模式来公开一个定义良好的编程模型和灵活的API。你学习了.NET Framework的设计者如何使用一些重要的模式。在下一章中，你将学习.NET平台中的并发和并行编程。
