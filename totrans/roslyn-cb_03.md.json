["```cs\n    public class MyClass\n    {\n       public static void Main()\n       {\n          int a = 0;   // CS0219 for '*a'*\n          int b = 1, c = 2; // CS0219 for '*b'*\n          System.Console.WriteLine(c);\n       }\n    }\n\n```", "```cs\npublic class Class1\n{\n  public void Method1()\n  {\n    // Local declaration statement with unused local ('a')\n    int a = 0;\n\n    // Local declaration statement with a used ('c') and ununused local ('b').\n    int b = 1, c = 2;\n    System.Console.WriteLine(c);\n\n    // Local declaration statement where unused local ('d') initializer is non-constant.\n    int d = c;\n\n    // Local declaration statement with errors ('e').\n    if (true)\n      var e = 1;\n  }\n}\n\n```", "```cs\n public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)\n {\n   var diagnostic = context.Diagnostics.First();\n\n   // Get syntax node to remove for the unused local.\n   var nodeToRemove = await GetNodeToRemoveAsync(context.Document, diagnostic, context.CancellationToken).ConfigureAwait(false);\n   if (nodeToRemove == null)\n   {\n     return;\n   }\n\n```", "```cs\nprivate async Task<SyntaxNode> GetNodeToRemoveAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken)\n{\n  var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n  var diagnosticSpan = diagnostic.Location.SourceSpan;\n\n  // Find the variable declarator identified by the diagnostic.\n  var variableDeclarator = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<VariableDeclaratorSyntax>().First();\n\n```", "```cs\nint b = 1, c = 2;\n\n```", "```cs\n  if (variableDeclarator == null)\n  {\n   return null;\n  }\n\n  // Bail out if the initializer is non-constant (could have side effects if removed).\n  if (variableDeclarator.Initializer != null)\n  {\n   var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);\n   if (!semanticModel.GetConstantValue(variableDeclarator.Initializer.Value).HasValue)\n   {\n    return null;\n   }\n  }\n\n  // Bail out for code with syntax errors - parent of a declaration is not a local declaration statement.\n  var variableDeclaration = variableDeclarator.Parent as VariableDeclarationSyntax;\n  var localDeclaration = variableDeclaration?.Parent as LocalDeclarationStatementSyntax;\n  if (localDeclaration == null)\n  {\n   return null;\n  }\n\n```", "```cs\n  // If the statement declares a single variable, the code fix should remove the whole statement.\n  // Otherwise, the code fix should remove only this variable declaration.\n  SyntaxNode nodeToRemove;\n  if (variableDeclaration.Variables.Count == 1)\n  {\n   if (!(localDeclaration.Parent is BlockSyntax))\n   {\n    // Bail out for error case where local declaration is not embedded in a block.\n    // Compiler generates errors CS1023 (Embedded statement cannot be a declaration or labeled statement)\n    return null;\n   }\n\n   nodeToRemove = localDeclaration;\n  }\n  else\n  {\n   nodeToRemove = variableDeclarator;\n  }\n\n  return nodeToRemove;\n }\n\n```", "```cs\n  // Register a code action that will invoke the fix.\n  var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n  context.RegisterCodeFix(\n   CodeAction.Create(\n    title: title,\n    createChangedDocument: c => RemoveDeclarationAsync(context.Document, root, nodeToRemove, c),\n    equivalenceKey: title),\n   diagnostic);\n }\n\n```", "```cs\n private Task<Document> RemoveDeclarationAsync(Document document, SyntaxNode root, SyntaxNode declaration, CancellationToken cancellationToken)\n {\n  var syntaxGenerator = SyntaxGenerator.GetGenerator(document);\n  var newRoot = syntaxGenerator.RemoveNode(root, declaration);\n  return Task.FromResult(document.WithSyntaxRoot(newRoot));\n }\n\n```", "```cs\npublic class Class1\n{\n public class Class2\n {\n }\n}\n\npublic class Class3\n{\n}\n\n```", "```cs\npublic class Class4\n{\n}\n\n```", "```cs\npublic class Class5\n{\n}\n\n```", "```cs\npublic class MyClass\n{\n   public static void M()\n   {\n      int a = 0;   // CS0219 for 'a'\n      int b = 1, c = 2; // CS0219 for 'b' and 'c'\n      int d = 3, e = 4; // CS0219 for 'd'\n      System.Console.WriteLine(e);\n   }\n}\n\n```", "```cs\npublic class Class1\n{\n public static void M()\n {\n  int a = 0; // CS0219 for 'a'\n  int b = 1, c = 2; // CS0219 for 'b' and 'c'\n  int d = 3, e = 4; // CS0219 for 'd'\n  System.Console.WriteLine(e);\n }\n}\n\n```", "```cs\npublic class Class2\n{\n public static void M()\n {\n  int a = 0; // CS0219 for 'a'\n  int b = 1, c = 2; // CS0219 for 'b' and 'c'\n  int d = 3, e = 4; // CS0219 for 'd'\n  System.Console.WriteLine(e);\n }\n}\n\n```", "```cs\npublic class Class3\n{\n public static void M()\n {\n  int a = 0; // CS0219 for 'a'\n  int b = 1, c = 2; // CS0219 for 'b' and 'c'\n  int d = 3, e = 4; // CS0219 for 'd'\n  System.Console.WriteLine(e);\n }\n}\n\n```", "```cs\n public override async Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)\n {\n  var diagnosticsToFix = new List<KeyValuePair<Document, ImmutableArray<Diagnostic>>>();\n  string titleFormat = \"Remove all unused locals in {0} {1}\";\n  string title = null;\n  var documentsToFix = ImmutableArray<Document>.Empty;\n\n  switch (fixAllContext.Scope)\n  {\n   case FixAllScope.Document:\n   {\n    documentsToFix = ImmutableArray.Create(fixAllContext.Document);\n    title = string.Format(titleFormat, \"document\", fixAllContext.Document.Name);\n    break;\n   }\n\n   case FixAllScope.Project:\n   {\n    documentsToFix = fixAllContext.Project.Documents.ToImmutableArray();\n    title = string.Format(titleFormat, \"project\", fixAllContext.Project.Name);\n    break;\n   }\n\n   case FixAllScope.Solution:\n   {\n    foreach (Project project in fixAllContext.Solution.Projects)\n    {\n     documentsToFix = documentsToFix.AddRange(project.Documents);\n    }\n\n    title = \"Add all items in the solution to the public API\";\n    break;\n   }\n\n   case FixAllScope.Custom:\n    return null;\n   default:\n    break;\n  }\n\n```", "```cs\n foreach (Document document in documentsToFix)\n {\n  ImmutableArray<Diagnostic> diagnostics = await fixAllContext.GetDocumentDiagnosticsAsync(document).ConfigureAwait(false);\n  diagnosticsToFix.Add(new KeyValuePair<Document, ImmutableArray<Diagnostic>>(document, diagnostics));\n }\n\n return new CustomFixAllCodeAction(title, fixAllContext.Solution, diagnosticsToFix);\n\n```", "```cs\n  protected override async Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)\n  {\n   var nodesToRemoveMap = new Dictionary<Document, HashSet<SyntaxNode>>();\n   foreach (KeyValuePair<Document, ImmutableArray<Diagnostic>> pair in _diagnosticsToFix)\n   {\n    Document document = pair.Key;\n    ImmutableArray<Diagnostic> diagnostics = pair.Value;\n    var nodesToRemove = new HashSet<SyntaxNode>();\n    foreach (var diagnostic in diagnostics)\n    {\n     var nodeToRemove = await CSharpAnalyzersCodeFixProvider.GetNodeToRemoveAsync(document, diagnostic, cancellationToken).ConfigureAwait(false);\n     if (nodeToRemove != null)\n     {\n      nodesToRemove.Add(nodeToRemove);\n     }\n    }\n\n```", "```cs\n    var candidateLocalDeclarationsToRemove = new HashSet<LocalDeclarationStatementSyntax>();\n    foreach (var variableDeclarator in nodesToRemove.OfType<VariableDeclaratorSyntax>())\n    {\n     var localDeclaration = (LocalDeclarationStatementSyntax)variableDeclarator.Parent.Parent;\n     candidateLocalDeclarationsToRemove.Add(localDeclaration);\n    }\n\n    foreach (var candidate in candidateLocalDeclarationsToRemove)\n    {\n     var hasUsedLocal = false;\n     foreach (var variable in candidate.Declaration.Variables)\n     {\n      if (!nodesToRemove.Contains(variable))\n      {\n       hasUsedLocal = true;\n       break;\n      }\n     }\n\n     if (!hasUsedLocal)\n     {\n      nodesToRemove.Add(candidate);\n      foreach (var variable in candidate.Declaration.Variables)\n      {\n       nodesToRemove.Remove(variable);\n      }\n     }\n    }\n\n```", "```cs\n   Solution newSolution = _solution;\n\n   foreach (KeyValuePair<Document, HashSet<SyntaxNode>> pair in nodesToRemoveMap)\n   {\n    var document = pair.Key;\n    var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n    var syntaxGenerator = SyntaxGenerator.GetGenerator(document);\n    var newRoot = syntaxGenerator.RemoveNodes(root, pair.Value);\n    newSolution = newSolution.WithDocumentSyntaxRoot(document.Id, newRoot);\n   }\n\n   return newSolution;\n\n```", "```cs\nprivate int MethodReturningTwoValues(out int x)\n{\n x = 0;\n return 0;\n}\n\nprivate int MethodReturningThreeValues(out int x, int y, out int z)\n{\n x = 0;\n z = 1;\n return y;\n}\n\n```", "```cs\nprivate (int, int) MethodReturningTwoValues()\n{\n int x;\n x = 0;\n return (0, x);\n}\n\nprivate (int, int, int) MethodReturningThreeValues(int y)\n{\n int x;\n int z;\n x = 0;\n z = 1;\n return (y, x, z);\n}\n\n```", "```cs\nprivate static IEnumerable<ParameterSyntax> GetOutParameters(MethodDeclarationSyntax methodDecl)\n => methodDecl.ParameterList.Parameters.Where(parameter => parameter.Modifiers.Any(m => m.Kind() == SyntaxKind.OutKeyword));\n\n```", "```cs\nprivate int MethodReturningTwoValues(out int x)\n{\n x = 0;\n return 0;\n}\n\nprivate int MethodReturningThreeValues(out int x, int y, out int z)\n{\n x = 0;\n z = 1;\n return y;\n}\n\n```", "```cs\npublic sealed override async Task ComputeRefactoringsAsync(CodeRefactoringContext context)\n{\n var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);\n\n // Find the node at the selection.\n var node = root.FindNode(context.Span);\n\n```", "```cs\n// Only offer a refactoring if the selected node is a method declaration node with non-void return type and at least one 'out' var.\n var methodDecl = node as MethodDeclarationSyntax;\n if (methodDecl == null ||\n  methodDecl.ReturnType.Kind() == SyntaxKind.VoidKeyword ||\n  !GetOutParameters(methodDecl).Any())\n {\n  return;\n }\n\n // Check if the compilation references System.ValueTuple\n var hasValueTuple = false;\n if (context.Document.Project.SupportsCompilation)\n {\n  var compilation = await context.Document.Project.GetCompilationAsync(context.CancellationToken).ConfigureAwait(false);\n  var systemValueTuple = compilation?.GetTypeByMetadataName(@\"System.ValueTuple\");\n  if (systemValueTuple != null && systemValueTuple.ContainingAssembly.Name.Equals(@\"System.ValueTuple\"))\n  {\n   hasValueTuple = true;\n  }\n }\n\n```", "```cs\n if (hasValueTuple)\n {\n  // Create a code action to transform the method signature to use tuples.\n var action = CodeAction.Create(\"Use ValueTuple return type\", c => UseValueTupleAsync(context.Document, methodDecl, c));\n\n  // Register this code action.\n  context.RegisterRefactoring(action);\n }\n\n```", "```cs\n // Compute the new parameter list with all the out parameters removed.\n var outParameters = GetOutParameters(methodDecl);\n var newParameters = methodDecl.ParameterList.Parameters.Where(p => !outParameters.Contains(p));\n var newParameterList = methodDecl.ParameterList.Update(\n  methodDecl.ParameterList.OpenParenToken,\n  new SeparatedSyntaxList<ParameterSyntax>().AddRange(newParameters),\n  methodDecl.ParameterList.CloseParenToken);\n methodDecl = methodDecl.WithParameterList(newParameterList);\n\n // Compute the new return type: Tuple type with the original return type as first element and\n // types for all original out parameters as subsequent elements.1\n var newReturnType = GenerateTupleType(methodDecl.ReturnType, outParameters);\n methodDecl = methodDecl.WithReturnType(newReturnType);\n\n```", "```cs\n // Add local declaration statements as the start of the method body to declare locals for original out parameters.\n var newStatements = new List<StatementSyntax>(outParameters.Count());\n foreach (var outParam in outParameters)\n {\n  var variableDeclarator = SyntaxFactory.VariableDeclarator(outParam.Identifier);\n  var variableDeclarationSyntax = SyntaxFactory.VariableDeclaration(outParam.Type, SyntaxFactory.SingletonSeparatedList(variableDeclarator));\n  var localDeclarationStatement = SyntaxFactory.LocalDeclarationStatement(variableDeclarationSyntax);\n  newStatements.Add(localDeclarationStatement);\n }\n\n var statements = methodDecl.Body.Statements;\n var newBody = methodDecl.Body.WithStatements(methodDecl.Body.Statements.InsertRange(0, newStatements));\n methodDecl = methodDecl.WithBody(newBody);\n\n```", "```cs\n // Replace all return statement expressions with tuple expressions: original return expression\n // as the first argument and identifier name for original out parameters as subsequent arguments.\n var returnStatements = methodDecl.Body.DescendantNodes().OfType<ReturnStatementSyntax>();\n var replacementNodeMap = new Dictionary<ReturnStatementSyntax, ReturnStatementSyntax>(returnStatements.Count());\n foreach (var returnStatement in returnStatements)\n {\n  var tupleExpression = GenerateTupleExpression(returnStatement.Expression, outParameters);\n  var newReturnStatement = SyntaxFactory.ReturnStatement(tupleExpression);\n  replacementNodeMap.Add(returnStatement, newReturnStatement);\n }\n\n methodDecl = methodDecl.ReplaceNodes(returnStatements, computeReplacementNode: (o, n) => replacementNodeMap[o]);\n\n```", "```cs\n // Add formatter annotation to format the edited method declaration and body.\n methodDecl = methodDecl.WithAdditionalAnnotations(Formatter.Annotation);\n\n // Return new document with replaced method declaration.\n var newRoot = root.ReplaceNode(originalMethodDecl, methodDecl);\n return document.WithSyntaxRoot(newRoot);\n}\n\n```", "```cs\nprivate void M()\n{\n int x;\n int y = MethodReturningTwoValues(out x);\n}\n\nprivate int MethodReturningTwoValues(out int x)\n{\n x = 0;\n return 0;\n}\n\n```", "```cs\nprivate void M()\n{\n int x;\n (int, int) t1 = MethodReturningTwoValues();\n x = t1.Item2;\n int y = t1.Item1;\n}\n\n```", "```cs\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<PackageManifest Version=\"2.0.0\"  >\n <Metadata>\n <Identity Id=\"CompletionProvider.Vsix.ccf1c2f5-d03f-42a2-a1b9-c05d10efda2c\" Version=\"1.0\" Language=\"en-US\" Publisher=\"Packt publishing\" />\n <DisplayName>CompletionProvider.Vsix</DisplayName>\n <Description>Roslyn completion provider.</Description>\n </Metadata>\n <Installation>\n <InstallationTarget Id=\"Microsoft.VisualStudio.Pro\" Version=\"[15.0]\" />\n </Installation>\n <Dependencies>\n <Dependency Id=\"Microsoft.Framework.NDP\" DisplayName=\"Microsoft .NET Framework\" d:Source=\"Manual\" Version=\"[4.5,)\" />\n </Dependencies>\n <Assets>\n <Asset Type=\"Microsoft.VisualStudio.MefComponent\" d:Source=\"Project\" d:ProjectName=\"CompletionProvider\" Path=\"|CompletionProvider|\"/>\n </Assets>\n <Prerequisites>\n <Prerequisite Id=\"Microsoft.VisualStudio.Component.CoreEditor\" Version=\"[15.0,16.0)\" DisplayName=\"Visual Studio core editor\" />\n <Prerequisite Id=\"Microsoft.VisualStudio.Component.Roslyn.LanguageServices\" Version=\"[15.0,16.0)\" DisplayName=\"Roslyn Language Services\" />\n </Prerequisites>\n</PackageManifest>\n\n```", "```cs\npublic class Base\n{\n protected static int StaticMemberBase;\n public int InstanceMemberBase;\n}\n\npublic class Derived : Base\n{\n private static int staticMemberDerived;\n internal int InstanceMemberDerived;\n\n private void InstanceMethod()\n {\n  .\n }\n\n private static void StaticMethod()\n {\n  .\n }\n}\n\n```", "```cs\npublic override bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options)\n{\n switch (trigger.Kind)\n {\n  case CompletionTriggerKind.Insertion:\n   return ShouldTriggerCompletion(text, caretPosition);\n\n  default:\n   return false;\n }\n}\n\n```", "```cs\nprivate static bool ShouldTriggerCompletion(SourceText text, int position)\n{\n // Provide completion if user typed \".\" after a whitespace/tab/newline char.\n var insertedCharacterPosition = position - 1;\n if (insertedCharacterPosition <= 0)\n {\n  return false;\n }\n\n var ch = text[insertedCharacterPosition];\n var previousCh = text[insertedCharacterPosition - 1];\n return ch == '.' &&\n  (char.IsWhiteSpace(previousCh) || previousCh == 't' || previousCh == 'r' || previousCh == 'n');\n}\n\n```", "```cs\npublic async override Task ProvideCompletionsAsync(CompletionContext context)\n{\n var model = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);\n var text = await model.SyntaxTree.GetTextAsync(context.CancellationToken).ConfigureAwait(false);\n if (!ShouldTriggerCompletion(text, context.Position))\n {\n  return;\n }\n\n // Only provide completion in method body.\n var enclosingMethod = model.GetEnclosingSymbol(context.Position, context.CancellationToken) as IMethodSymbol;\n if (enclosingMethod == null)\n {\n  return;\n }\n\n```", "```cs\nprivate static ImmutableArray<ISymbol> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, bool isStatic, int position, SemanticModel model)\n{\n var types = GetBaseTypesAndThis(containingType);\n return types.SelectMany(x => x.GetMembers().Where(m => m.IsStatic == isStatic && model.IsAccessible(position, m)))\n .ToImmutableArray();\n}\n\nprivate static IEnumerable<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type)\n{\n var current = type;\n while (current != null)\n {\n  yield return current;\n  current = current.BaseType;\n }\n}\n\n```", "```cs\nvar membersToSuggest = GetAccessibleMembersInThisAndBaseTypes(\n enclosingMethod.ContainingType,\n isStatic: enclosingMethod.IsStatic,\n position: context.Position - 1,\n model: model);\n\n// Add completion for each member.\nforeach (var member in membersToSuggest)\n{\n // Ignore constructors\n if ((member as IMethodSymbol)?.MethodKind == MethodKind.Constructor)\n {\n  continue;\n }\n\n // Add receiver and description properties.\n var receiver = enclosingMethod.IsStatic ? member.ContainingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) : \"this\";\n var description = member.ToMinimalDisplayString(model, context.Position - 1);\n\n var properties = ImmutableDictionary<string, string>.Empty\n  .Add(Receiver, receiver)\n  .Add(Description, description);\n\n // Compute completion tags to display.\n var tags = GetCompletionTags(member).ToImmutableArray();\n\n // Add completion item.\n var item = CompletionItem.Create(member.Name, properties: properties, tags: tags);\n context.AddItem(item);\n}\n\n```", "```cs\npublic override Task<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken)\n{\n return Task.FromResult(CompletionDescription.FromText(item.Properties[Description]));\n}\n\n```", "```cs\npublic override Task<CompletionChange> GetChangeAsync(Document document, CompletionItem item, char? commitKey, CancellationToken cancellationToken)\n{\n // Get new text replacement and span.\n var receiver = item.Properties[Receiver];\n var newText = $\"{receiver}.{item.DisplayText}\";\n var newSpan = new TextSpan(item.Span.Start - 1, 1);\n\n // Return the completion change with the new text change.\n var textChange = new TextChange(newSpan, newText);\n return Task.FromResult(CompletionChange.Create(textChange));\n}\n\n```", "```cs\npublic void TestMethod2()\n{\n var test = @\"\n  namespace ConsoleApplication1\n  {\n   class TypeName\n   {\n    class TypeName2\n {\n }\n   }\n  }\";\n\n ...\n\n var fixtest = @\"\n  namespace ConsoleApplication1\n  {\n   class TYPENAME\n   { \n    class TypeName2\n {\n } \n   }\n  }\";\n\n```", "```cs\nvar expected = new[] {\n new DiagnosticResult {\n  Id = \"CSharpAnalyzers\",\n  Message = String.Format(\"Type name '{0}' contains lowercase letters\", \"TypeName\"),\n  Severity = DiagnosticSeverity.Warning,\n  Locations =\n   new[] { new DiagnosticResultLocation(\"Test0.cs\", 4, 15) }\n },\n new DiagnosticResult {\n Id = \"CSharpAnalyzers\",\n Message = String.Format(\"Type name '{0}' contains lowercase letters\", \"TypeName2\"),\n Severity = DiagnosticSeverity.Warning,\n Locations =\n new[] { new DiagnosticResultLocation(\"Test0.cs\", 6, 19) }\n }\n};\n\n```"]