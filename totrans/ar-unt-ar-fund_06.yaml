- en: '*Chapter 4***: Creating an AR User Framework**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：创建AR用户框架**'
- en: In this chapter, we will develop a framework for building **Augmented Reality**
    (**AR**) applications that manage user interaction modes and the corresponding
    **user interface** (**UI**). The framework includes important **user experience**
    (**UX**) steps when starting up the AR session at runtime and interacting with
    AR features. This framework will form the basis for new scenes for projects later
    in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个用于构建**增强现实**（**AR**）应用的框架，该框架管理用户交互模式和相应的**用户界面**（**UI**）。该框架包括在运行时启动AR会话和与AR功能交互时的重要**用户体验**（**UX**）步骤。这个框架将成为本书后面项目中新场景的基础。
- en: This is a Unity framework for building mode-based applications. It generalizes
    some of the scene structure that I have found myself repeating from one project
    to the next. For example, when an AR app first starts, it must verify that the
    device supports AR. Once the AR session is initialized, the app may prompt the
    user to begin scanning the environment to establish tracking. At some point later
    in the application, the user might be prompted to tap the screen to place a virtual
    object, often in *Add-object mode*. These steps are common to many AR applications,
    including the projects in this book, so we will set up some infrastructure beforehand
    in a scene that may be used as a template.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于构建基于模式的Unity框架。它概括了我发现自己从项目到项目重复的一些场景结构。例如，当AR应用首次启动时，它必须验证设备是否支持AR。一旦AR会话初始化，应用可能会提示用户开始扫描环境以建立跟踪。在应用中的某个时候，用户可能会被提示触摸屏幕以放置虚拟对象，通常在*添加对象模式*中。这些步骤对于许多AR应用都是通用的，包括本书中的项目，因此我们将在一个可能用作模板的场景中事先设置一些基础设施。
- en: This chapter involves some advanced C# coding. If you're already an intermediate
    or advanced programmer, you should be able to follow along fairly easily. If you're
    a novice, you can just copy/paste the code provided here and learn from it. Or,
    you have the option of skipping the chapter altogether and using the scene template
    from this chapter found in this book's GitHub repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及一些高级C#编程。如果你已经是中级或高级程序员，你应该能够相当容易地跟随。如果你是新手，你可以直接复制/粘贴这里提供的代码并从中学习。或者，你也可以选择完全跳过本章，并使用本书GitHub仓库中找到的本章的场景模板。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing prerequisite assets for our framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装我们框架的先决资产
- en: Starting with a new scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个新的场景开始
- en: Creating the UI canvas and panels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI画布和面板
- en: Creating the UI controller, using a Singleton class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI控制器，使用Singleton类
- en: Creating an interaction modes controller
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建交互模式控制器
- en: Creating the interaction modes, including startup, scan, main, and non-AR modes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建交互模式，包括启动、扫描、主模式和AR模式
- en: Usng the Unity onboarding UX assets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity入门UX资产
- en: Creating a scene template for new scenes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新场景创建场景模板
- en: By the end of the chapter, you'll have a scene template, named `ARTemplate`,
    with AR onboarding features, and a user interaction framework that can be used
    as a starting point for other AR projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个名为`ARTemplate`的场景模板，其中包含AR入门功能，以及一个用户交互框架，可以作为其他AR项目的起点。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To implement the project in this chapter, you need Unity installed on your
    development computer, connected to a mobile device that supports AR applications.
    We''ll use the Unity project set up for AR development in [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*. In review, the project configuration included
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现本章的项目，你需要在你的开发计算机上安装Unity，并连接到一个支持AR应用的移动设备。我们将使用在[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*中设置的Unity
    AR开发项目。回顾一下，项目配置包括以下内容：
- en: It created a new project (via **Unity Hub**) using the **Universal Render Pipeline**
    template.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Unity Hub**模板创建了一个新的项目（via **Unity Hub**）。
- en: It set **Target Platform** for **Android** or **iOS** in **Build Settings**,
    and the corresponding required **Player Settings**.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在**构建设置**中为**Android**或**iOS**设置了**目标平台**，并配置了相应的**玩家设置**。
- en: It installed an **XR Plugin**, **AR Foundation** package, and configured the
    **URP Forward Renderer** for AR.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它安装了一个**XR插件**，**AR Foundation**包，并为AR配置了**URP前向渲染器**。
- en: It installed the **Input System** package and sets **Active Input Handling**
    (to **Input System Package** or **Both**).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它安装了**输入系统**包，并设置**活动输入处理**（到**输入系统包**或**两者**）。
- en: The completed scene from this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成后的场景可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Understanding AR interaction flow
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AR交互流程
- en: 'In an Augmented Reality application, one of the first things the user must
    do is scan the environment with the device camera, slowly moving their device
    around until it detects geometry for tracking. This might be horizontal planes
    (floor, tabletop), vertical planes (walls), a human face, or other objects. A
    simplistic user flow given in many example scenes is shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在增强现实应用程序中，用户必须做的第一件事是用设备相机扫描环境，慢慢移动设备直到检测到用于跟踪的几何形状。这可能是水平平面（地板、桌面）、垂直平面（墙壁）、人脸或其他对象。以下图表显示了许多示例场景中给出的简单用户流程：
- en: '![Figure 4.1 – A simple AR onboarding user workflow'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 简单的AR入门用户工作流程'
- en: '](img/Figure_4.01-OnboardingFlow.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.01-OnboardingFlow.jpg]'
- en: Figure 4.1 – A simple AR onboarding user workflow
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 简单的AR入门用户工作流程
- en: As shown in the preceding diagram, the app starts by checking for AR support,
    asking the user for permission to access the device camera and other initializations.
    Then, the app asks the user to scan the environment for trackable objects, and
    may need to report scanning problems, such as if the room is too dark or there's
    not enough texture to detect features. Once tracking is achieved, the user is
    prompted to tap the screen to place a virtual object in the scene.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，应用程序首先检查AR支持，请求用户允许访问设备相机和其他初始化。然后，应用程序会要求用户扫描环境以寻找可追踪的对象，并可能需要报告扫描问题，例如房间太暗或纹理不足无法检测特征。一旦实现跟踪，就会提示用户点击屏幕在场景中放置虚拟对象。
- en: 'This is great for demo scenes but is probably too simplistic for a real AR
    application. For example, in the Art Gallery app that we are going to build in
    [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136), *Gallery: Building
    an AR App*, after the application starts, the environment is scanned for vertical
    planes (walls).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于演示场景来说很棒，但对于实际的AR应用程序来说可能过于简单。例如，在我们将在[*第6章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)“*画廊：构建AR应用程序*”中构建的Art
    Gallery应用程序中，应用程序启动后，会扫描垂直平面（墙壁）。
- en: 'Then, the app enters **Main** mode, where the user must tap an **Add** button
    to add a new picture. That, in turn, displays a modal **Select Image** menu. With
    pictures added to the scene, the user can pick one and enter **Edit** mode to
    move, resize, or otherwise modify the virtual object. Part of this general interaction
    flow is shown in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序进入**主**模式，用户必须点击**添加**按钮来添加一张新图片。这反过来会显示一个模态的**选择图片**菜单。当场景中添加了图片后，用户可以选择一张并进入**编辑**模式来移动、调整大小或以其他方式修改虚拟对象。以下图表显示了这部分一般的交互流程：
- en: '![Figure 4.2 – User interaction flow, including Main, Add, and Edit modes'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 用户交互流程，包括主、添加和编辑模式'
- en: '](img/Figure_4.02-userflow-add-edit.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.02-userflow-add-edit.jpg]'
- en: Figure 4.2 – User interaction flow, including Main, Add, and Edit modes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 用户交互流程，包括主、添加和编辑模式
- en: Naturally, each application has its own interaction flows. The framework we
    are building in this chapter supports this scenario and can be adapted for other
    projects that require managing a current modal state and corresponding UI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，每个应用程序都有自己的交互流程。本章中我们构建的框架支持这种场景，并且可以适应其他需要管理当前模式状态和相应UI的项目。
- en: This framework implements a **state machine** design pattern, where the scene
    has a current *state* (interaction mode and visible UI). Specific conditions must
    be met to then transition from one state to another.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架实现了一个**状态机**设计模式，其中场景有一个当前*状态*（交互模式和可见UI）。必须满足特定条件才能从一种状态转换到另一种状态。
- en: There are two major areas of this framework – the UI panels and the interaction
    modes. Generally, there will be a one-to-one correlation between the modes and
    the UI used by the modes. For example, in *Main mode*, there will be the main
    menu UI. In *Add-object mode*, there will be a UI prompt for the user to tap to
    place an object in the scene. This implements a design pattern called **view-controller**,
    with UI views and mode controllers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架有两个主要区域——UI面板和交互模式。通常，模式和使用的UI之间将存在一对一的关联。例如，在*主模式*中，将会有主菜单UI。在*添加对象模式*中，将会有一个UI提示用户在场景中放置对象。这实现了名为**视图控制器**的设计模式，具有UI视图和模式控制器。
- en: Let's now begin to implement this basic workflow in our scene by adding a number
    of additional prerequisite packages to the project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始在我们的场景中实现这个基本工作流程，通过向项目中添加一些额外的必备包。
- en: Installing prerequisite assets
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装必备资源
- en: Our user interaction framework uses several additional packages that need to
    be installed in your project, namely, TextMeshPro, DOTween, and Serialized Dictionary
    Lite. In this section, I will also include some utility assets. Let's install
    them now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户交互框架使用了一些需要安装到您项目中的附加包，即TextMeshPro、DOTween和Serialized Dictionary Lite。在本节中，我还会包括一些实用资产。现在让我们安装它们。
- en: TextMeshPro
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextMeshPro
- en: 'TextMeshPro provides high-quality text assets that replace the built-in text
    element. It is not mandatory, but I strongly recommend it. To import **TextMeshPro**,
    if you haven''t installed it yet in your project, perform the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TextMeshPro提供了高质量的文本资源，可以替换内置的文本元素。这不是强制性的，但我强烈推荐它。要导入**TextMeshPro**，如果您尚未在项目中安装，请执行以下步骤：
- en: Go to **Window | TextMeshPro | Import TMP Essential Resources**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口 | TextMeshPro | 导入 TMP 必要资源**。
- en: In the **Import Unity Package** window, click **Import**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入Unity包**窗口中，点击**导入**。
- en: The TextMeshPro package is now installed. You may also install the **TMP Examples
    and Extras** package, which includes additional fonts and other assets that may
    be useful and fun for your projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文本MeshPro包现已安装。您还可以安装**TMP 示例和额外资源**包，其中包含额外的字体和其他可能对您的项目有用且有趣的资源。
- en: DOTween
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOTween
- en: DOTween is, in my opinion, an indispensable free package for doing small, lightweight
    animation effects on just about any `MonoBehaviour` property. Without it, you
    may need to write a dozen lines of code to do what DOTween does in one. Documentation
    for DOTween can be found online at [http://dotween.demigiant.com/documentation.php](http://dotween.demigiant.com/documentation.php).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，DOTween是一个不可或缺的免费包，用于在几乎任何`MonoBehaviour`属性上执行小型、轻量级的动画效果。没有它，您可能需要编写数十行代码才能完成DOTween在一行中完成的事情。DOTween的文档可以在网上找到：[http://dotween.demigiant.com/documentation.php](http://dotween.demigiant.com/documentation.php)。
- en: 'To add DOTween, perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加DOTween，请执行以下步骤：
- en: 'Go to its Unity Asset Store page: [https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676](https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676).'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往其Unity Asset Store页面：[https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676](https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676)。
- en: Press **Add to My Assets** and/or **Open In Unity**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加到我的资产**和/或**在Unity中打开**。
- en: This will take you to the **Package Manager** window in your Unity project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带您进入Unity项目中的**包管理器**窗口。
- en: Ensure **My Assets** is selected from the **Packages** filter dropdown in the
    upper-left corner of the **Package Manager** window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从**包管理器**窗口左上角的**包**过滤器下拉菜单中选择**我的资产**。
- en: Search for `DOTween` using the search text input field in the upper-right corner
    of the **Package Manager** window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**包管理器**窗口右上角的搜索文本输入字段搜索`DOTween`。
- en: Select the **DOTween** package and then click **Install**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**DOTween**包，然后点击**安装**。
- en: Once imported, you are prompted to **Open DOTween Utility Panel** to set up
    the package.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入后，系统会提示您**打开 DOTween 工具面板**以设置包。
- en: Then, click the **Setup DOTween** button.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**设置 DOTween** 按钮。
- en: DOTween is now installed and set up on your project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DOTween现已安装并设置到您的项目中。
- en: Serialized Dictionary Lite
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serialized Dictionary Lite
- en: 'A C# **dictionary** is a key-value list structure where values in the list
    can be referenced by a key value. For example, we will use dictionaries to look
    up a UI panel or interaction mode object by name. Unfortunately, Unity does not
    provide native support for dictionaries in the Editor''s **Inspector** window.
    **Serialized Dictionary Lite** is a free extension to the Unity Editor that allows
    dictionaries to be edited using **Inspector**. To add Serialized Dictionary Lite
    to your project, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C#的**字典**是一个键值列表结构，其中列表中的值可以通过键值引用。例如，我们将使用字典通过名称查找UI面板或交互模式对象。不幸的是，Unity在编辑器的**检查器**窗口中不提供对字典的原生支持。**Serialized
    Dictionary Lite**是Unity编辑器的免费扩展，允许使用**检查器**编辑字典。要将Serialized Dictionary Lite添加到您的项目中，请执行以下步骤：
- en: Go to its Unity Asset Store page, [https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往其Unity Asset Store页面，[https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)
- en: Press **Add to My Assets** and/or **Open In Unity**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**添加到我的资产**和/或**在Unity中打开**。
- en: This will take you to the **Package Manager** window in your Unity project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带您进入Unity项目中的**包管理器**窗口。
- en: Ensure **My Assets** is selected from the **Packages** filter dropdown in the
    upper-left corner of the **Package Manager** window.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**包管理器**窗口左上角的**包**过滤器下拉菜单中选择**我的资产**。
- en: Search for `Serialized` using the search text input field in the upper-right
    corner of the **Package Manager** window.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**包管理器**窗口右上角的搜索文本输入字段搜索`Serialized`。
- en: Select the **Serialized Dictionary Lite** package and click **Install** (or,
    if prompted, click **Download** and then **Import**).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Serialized Dictionary Lite**包，然后点击**安装**（或，如果提示，点击**下载**然后**导入**）。
- en: Serialized Dictionary Lite is now installed in your project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Serialized Dictionary Lite现在已安装到您的项目中。
- en: Other prerequisite assets
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他先决条件资产
- en: 'In addition to the aforementioned packages, we will assume that you have the
    following already added to your Unity project:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述包之外，我们假设您已经将以下内容添加到您的Unity项目中：
- en: Assets from the Unity `ARF-samples.unity` package created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037),
    *Your First AR Scene*.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)，*您的第一个AR场景*中创建的Unity
    `ARF-samples.unity`包的资产。
- en: In [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your First
    AR Scene*, we also created an **AR Input Actions** asset containing an **Action
    Map** named **ARTouchActions**, including (at least) one **PlaceObject** action.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)，*您的第一个AR场景*中，我们还创建了一个包含名为**ARTouchActions**的**Action
    Map**的**AR输入动作**资产，包括（至少）一个**放置对象**动作。
- en: With our prerequisite assets present, we can get started with building the scene.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备先决条件资产的情况下，我们可以开始构建场景。
- en: Starting with a new scene
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个新的场景开始
- en: 'We start this project with a new empty scene and set it up with the AR Foundation
    objects: `ARFramework` using the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个新的空场景开始这个项目，并按照以下步骤设置AR Foundation对象：使用以下步骤使用`ARFramework`：
- en: Create a new scene using **File | New Scene**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 新场景**创建一个新的场景。
- en: Choose the **Basic (Built-in)** template. Press **Create**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**基本（内置）**模板。按**创建**。
- en: Save the scene using `Assets/Scenes/` folder, give it the name `ARFramework`,
    and then click **Save**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Assets/Scenes/`文件夹保存场景，将其命名为`ARFramework`，然后点击**保存**。
- en: 'Next, we''ll set up the scene with the basic AR Foundation game objects as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式设置场景，使用基本的AR Foundation游戏对象：
- en: Delete **Main Camera** from the **Hierarchy** window by *right-clicking* and
    selecting **Delete** (or the pressing *Del* key on your keyboard).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**删除**（或按键盘上的*Del*键）从**层次结构**窗口中删除**主相机**。
- en: Add an AR session by selecting **GameObject** from the main menu, and then **XR
    | AR Session**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单中选择**GameObject**，然后选择**XR | AR Session**来添加一个AR会话。
- en: Add an **AR Session Origin** object by selecting **GameObject** from the main
    menu, and then **XR | AR Session Origin**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单中选择**GameObject**，然后选择**XR | AR Session Origin**来添加一个**AR会话原点**对象。
- en: Select the `raycast`, and then add an **AR Raycast Manager** component.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`raycast`，然后添加一个**AR Raycast Manager**组件。
- en: Unfold **AR Session Origin** and select its child **AR Camera**. In the **Inspector**
    window, use the **Tag** selector in the upper-left corner to set its tag to **MainCamera**.
    (This is not required, but it is a good practice to have one camera in the scene
    tagged as MainCamera).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**AR 会话原点**并选择其子 **AR 相机**。在 **检查器** 窗口中，使用左上角的 **标签** 选择器将其标签设置为 **MainCamera**。（这不是必需的，但将场景中一个相机标记为
    MainCamera 是一个好习惯）。
- en: In the `audio listener`, and add an **Audio Listener** component to the camera.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `audio listener` 中，并为相机添加一个 **音频监听器** 组件。
- en: 'For demo purposes, we''ll add an **AR Plane Manager** component for detecting
    and tracking horizontal planes. This may change based on the requirements of a
    specific project:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将添加一个 **AR 平面管理器** 组件来检测和跟踪水平平面。这可能会根据特定项目的需求而变化：
- en: With `ar plane manager`, and then add an **AR Plane Manager** component.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ar plane manager`，然后添加一个 **AR 平面管理器** 组件。
- en: Choose an AR plane visualizer prefab and add it to the `ARF-samples/Prefabs`
    folder.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个 AR 平面可视化预制件并将其添加到 `ARF-samples/Prefabs` 文件夹中。
- en: 'We can also set up some basic AR light estimation as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置一些基本的 AR 光照估计，如下所示：
- en: Select **Main Camera** in the **Hierarchy** window. On its **AR Camera Manager**
    component, set **Light Estimation** to **Everything**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中选择 **主相机**。在其 **AR 相机管理器** 组件中，将 **光照估计** 设置为 **全部**。
- en: In the `light estimation`, and then add a **Basic Light Estimation** component.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `light estimation` 中，然后添加一个 **基本光照估计** 组件。
- en: Drag the **AR Camera** object from the **Hierarchy** window onto the **Basic
    Light Estimation | Camera Manager** slot.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR 相机** 对象从 **层次结构** 窗口拖动到 **基本光照估计 | 相机管理器** 槽中。
- en: Save your work using **File | Save**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **文件 | 保存** 来保存你的工作。
- en: We now have a scene named `ARFramework` with a few things set up, including
    the AR Session, AR Session Origin, AR Camera, and basic light estimation. We can
    now begin to construct our framework's UI panels.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 `ARFramework` 的场景，其中设置了一些内容，包括 AR 会话、AR 会话原点、AR 相机和基本光照估计。我们现在可以开始构建我们框架的
    UI 面板。
- en: Creating the UI canvas and panels
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 UI 画布和面板
- en: The main screen space UI canvas will contain various user interface panels that
    may be displayed at various times throughout the application. Presently, we'll
    include the following UI panels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕空间 UI 画布将包含各种用户界面面板，这些面板可能会在应用程序的各个时间点显示。目前，我们将包括以下 UI 面板。
- en: The Startup UI panel with any initialization messages
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有任何初始化信息的启动 UI 面板
- en: The Scan UI panel, which prompts the user to scan for trackable features
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描 UI 面板，提示用户扫描可追踪的特征
- en: The Main UI panel for the main mode that could display the main menu buttons
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主 UI 面板，用于显示主菜单按钮
- en: The NonAR UI panel, which could be shown when the device does not support Augmented
    Reality
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非AR UI 面板，当设备不支持增强现实时可能会显示
- en: Creating the screen space canvas
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建屏幕空间画布
- en: 'First, we need to create a Canvas to contain these panels. Follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个画布来包含这些面板。按照以下步骤操作：
- en: From the main menu, select `UI Canvas`. We can leave the default **Render Mode**
    as **Screen Space – Overlay**. This will also add an **Event System** game object
    to the scene if one is not already present.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择 `UI Canvas`。我们可以将默认的 **渲染模式** 留为 **屏幕空间 – 遮罩**。如果场景中尚未存在，这也会向场景添加一个
    **事件系统** 游戏对象。
- en: By default, the new Canvas is in screen space, and this is what we want here.
    Some people prefer to change **Canvas Scaler UI Scale Mode** from **Constant Pixel
    Size** to **Scale With Screen Size**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，新的画布位于屏幕空间中，这正是我们想要的。有些人更喜欢将 **Canvas Scaler UI Scale Mode** 从 **固定像素大小**
    更改为 **与屏幕大小缩放**。
- en: To edit a Screen Space canvas, let's switch the **Scene** window to a 2D view
    by clicking the **2D** button in the **Scene** window toolbar. Then, double-click
    the **UI Canvas** object in the **Hierarchy** window to focus the **Scene** view
    on this object.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编辑屏幕空间画布，让我们通过在 **场景** 窗口工具栏中单击 **2D** 按钮将 **场景** 窗口切换到 2D 视图。然后，在 **层次结构**
    窗口中双击 **UI Canvas** 对象以将 **场景** 视图聚焦于此对象。
- en: It's also helpful to arrange the **Game** window and **Scene** window side by
    side. Because we're developing for AR, set the **Game** window's display to a
    fixed portrait aspect ratio, such as **2160x1080 Portrait** using the dimension
    select list in the **Game** window's top toolbar.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **游戏** 窗口和 **场景** 窗口并排排列也是有帮助的。因为我们正在为 AR 开发，所以将 **游戏** 窗口的显示设置为固定的纵向宽高比，例如使用
    **游戏** 窗口顶部工具栏中的尺寸选择列表的 **2160x1080 纵向**。
- en: On this canvas, we will add the separate panels. First, let's add an app title
    at the top of the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此画布上，我们将添加单独的面板。首先，让我们在屏幕顶部添加一个应用标题。
- en: Adding an app title
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加应用标题
- en: 'Let''s add a placeholder for an app title as a text panel positioned at the
    top of the screen. Add the title using the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在屏幕顶部添加一个文本面板作为应用标题的占位符。使用以下步骤添加标题：
- en: '*Right-click* on `App Title Panel`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`App Title Panel`。
- en: With the **App Title Panel** object selected, in its **Inspector** window, open
    the **Anchor Presets** menu (found in the upper-left corner of the **Rect Transform**
    component), and click the **Stretch-Top** button. The **Anchor Presets** menu
    is shown open in the following screenshot, to the left of the **Rect Transform**
    component:![Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**App Title Panel**对象后，在其**检查器**窗口中，打开**锚点预设**菜单（位于**Rect Transform**组件的右上角），并点击**拉伸-顶部**按钮。以下截图显示了打开的**锚点预设**菜单，位于**Rect
    Transform**组件的左侧：![图4.3 – 设置为顶部拉伸的App标题面板的锚点预设菜单]
- en: '](img/Figure_4.03-apptitle-anchorpreset.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.03-apptitle-anchorpreset.jpg]'
- en: Figure 4.3 – Anchor Presets menu for App Title Panel set to Top-Stretch
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.3 – 设置为顶部拉伸的App标题面板的锚点预设菜单
- en: Then, press *Shift + Alt +* **Stretch-Top** to set its pivot and position.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按*Shift + Alt +* **拉伸-顶部**以设置其枢轴和位置。
- en: Set `100`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`100`。
- en: Next, *right-click* on `Title Text`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击`Title Text`。
- en: In its `My AR Project`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`My AR Project`中。
- en: Using the **Anchor Presets** menu in the upper-left corner of **Rect Transform**,
    select **Stretch-Stretch**. Then, press *Shift + Alt +* **Stretch-Stretch**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Rect Transform**组件的右上角使用**锚点预设**菜单选择**拉伸-拉伸**。然后，按*Shift + Alt +* **拉伸-拉伸**。
- en: Set **Alignment** to **Center** and **Middle**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐**设置为**居中**和**中间**。
- en: You may also choose to adjust the **Font Size** and **Vertex Color** fields
    as you wish.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以根据需要调整**字体大小**和**顶点颜色**字段。
- en: 'There isn''t much to see, but the **Game** window, along with the title of
    the app, is shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么可看的，但以下截图显示了**游戏**窗口以及应用标题：
- en: '![Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 截图显示带有App标题面板锚点设置为顶部拉伸的游戏窗口]'
- en: '](img/Figure_4.04-apptitlepanel.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.04-apptitlepanel.jpg]'
- en: Figure 4.4 – Game window (cropped) with the App Title panel anchored as Top-Stretch
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 截图显示带有App标题面板锚点设置为顶部拉伸的游戏窗口
- en: Now that you have experience using the **Anchor Presets** menu, I'll abbreviate
    the instructions going forward. Next, we'll add a panel for the start up mode.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用过**锚点预设**菜单，我将简化后续说明。接下来，我们将添加启动模式的面板。
- en: Creating the UI panels
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI面板
- en: We'll now create the UI panels for each of the initial interaction modes supported
    by the framework. Since they are all very similar, we'll create the first one,
    and then duplicate and modify it for the others.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为框架支持的每个初始交互模式创建UI面板。由于它们都非常相似，我们将创建第一个，然后复制并修改它以用于其他面板。
- en: 'The first UI panel, **Startup UI**, will be a text panel displayed when the
    app is initializing. Create it using the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个UI面板，**启动UI**，将在应用初始化时显示文本面板。使用以下步骤创建它：
- en: In the `Startup UI`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup UI`中。
- en: We don't need a background image so, in the **Inspector** window, remove the
    **Image** component using the *3-dot context menu* **| Remove Component**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要背景图像，因此，在**检查器**窗口中，使用*3点上下文菜单* **| 移除组件**移除**Image**组件。
- en: Click the `canvas group`, and add a **Canvas Group** component to the panel.
    We're going to use this component to fade panels on and off later in this chapter.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`canvas group`，并将一个**Canvas Group**组件添加到面板中。我们将使用此组件在本章的后面部分来淡入淡出面板。
- en: '*Right-click* the **Startup UI** object and select **UI | Text – TextMeshPro**.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**启动UI**对象，并选择**UI | 文本 – TextMeshPro**。
- en: Set `Initializing…`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`初始化中...`。
- en: Using its **Anchor Presets** menu, select **Stretch-Stretch**. Then, press *Shift
    + Alt +* **Stretch-Stretch**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其**锚点预设**菜单，选择**拉伸-拉伸**。然后，按*Shift + Alt +* **拉伸-拉伸**。
- en: Set **Alignment** to **Center** and **Middle.**
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐**设置为**居中**和**中间**。
- en: 'Next, we can add a panel that can be displayed if the device we''re running
    on does not support AR. Create this panel as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个面板，如果我们在其上运行的设备不支持AR，则可以显示此面板。按照以下步骤创建此面板：
- en: '*Right-click* the `NonAR UI`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`NonAR UI`。
- en: Unfold the object and select its child text object. Change the text content
    to `Augmented reality not supported on this device`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开对象并选择其子文本对象。将文本内容更改为`此设备不支持增强现实`。
- en: 'The Scan UI panel will be used to prompt the user to scan the room while the
    app tries to detect AR features. Create the panel by following these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描 UI 面板将在应用程序尝试检测 AR 功能时提示用户扫描房间。按照以下步骤创建面板：
- en: '*Right-click* the `Scan UI`.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Scan UI`。
- en: Unfold the object and select its child text object. Change the text content
    to `Scanning… Please move device slowly`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开对象并选择其子文本对象。将文本内容更改为 `Scanning… Please move device slowly`。
- en: 'Lastly, we''ll add a placeholder panel for the main mode UI. This panel could
    later include, for example, a main menu for the app:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为主模式 UI 添加一个占位符面板。这个面板可以后来包含，例如，应用程序的主菜单：
- en: '*Right-click* the `Main UI`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Main UI`。
- en: Unfold the object and select its child text object. For development purposes,
    change the text content to `Main Mode Running`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开对象并选择其子文本对象。出于开发目的，将文本内容更改为 `Main Mode Running`。
- en: 'The current UI Canvas hierarchy is shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 UI Canvas 层级结构如图所示：
- en: '![Figure 4.5 – UI Canvas hierarchy'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – UI Canvas 层级'
- en: '](img/Figure_4.05-uicanvas-hier.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.05 – UI Canvas 层级](img/Figure_4.05-uicanvas-hier.jpg)'
- en: Figure 4.5 – UI Canvas hierarchy
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – UI Canvas 层级
- en: So far, we have created a simple hierarchy of UI panels under a screen space
    UI Canvas. The panels are acting as a placeholder, for the most part, containing
    a text element so that you can see which panel is active at runtime. As you build
    your own apps from this scene, you'll fill in the panels with app-specific UI
    elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在屏幕空间 UI Canvas 下创建了一个简单的 UI 面板层次结构。这些面板大部分作为占位符使用，包含一个文本元素，以便你在运行时可以看到哪个面板是活动的。随着你从这个场景构建自己的应用程序，你将在面板中填充应用程序特定的
    UI 元素。
- en: Next, we'll create the UI controller script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 UI 控制器脚本。
- en: Creating the UI controller
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 UI 控制器
- en: It will be convenient to have a script with a small API that makes it easy to
    switch between UI panels. For the controller scripts in our framework, I've decided
    to define them as singletons.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个具有小型 API 的脚本，使其能够轻松地在 UI 面板之间切换，将会很方便。对于我们的框架中的控制器脚本，我决定将它们定义为单例。
- en: A `Instance` in the class definition. Learn more at [https://wiki.unity3d.com/index.php/Singleton](https://wiki.unity3d.com/index.php/Singleton).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义中的 `Instance`。了解更多信息请访问 [https://wiki.unity3d.com/index.php/Singleton](https://wiki.unity3d.com/index.php/Singleton)。
- en: Then, we'll write a `UIController` script that controls the visibility of your
    UI panels. Lastly, we'll implement some code to fade in and out for a more pleasing
    user experience when we hide and show the panels.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个 `UIController` 脚本来控制 UI 面板的可见性。最后，我们将实现一些代码，以便在隐藏和显示面板时提供更愉悦的用户体验。
- en: Creating a Singleton class script
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单例类脚本
- en: 'We''ll begin by writing a `Singleton` class to use (or, if you already have
    a favorite, feel free to use that `Singleton` class definition instead). You can
    find some singleton implementations available as packages in the Unity Asset Store,
    but all we need is a short script that you can now create as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个 `Singleton` 类来使用（或者，如果你已经有了喜欢的，你也可以自由地使用那个 `Singleton` 类定义）。你可以在 Unity
    Asset Store 中找到一些作为包提供的单例实现，但我们只需要一个简短的脚本，你现在可以创建如下：
- en: In your `Scripts/` folder by *right-clicking* and selecting `Singleton`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Scripts/` 文件夹中，通过右键点击并选择 `Singleton`。
- en: 'Write the script as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写脚本：
- en: '[PRE0]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Info: A singleton as an anti-pattern'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息：单例作为反模式
- en: Note that the singleton pattern can be abused, and some programmers are adamantly
    opposed to using it, as it can cause problems down the road should your application
    grow and get more complex. But it's a powerful tool when you are certain that
    the app will only ever require one instance of the class, as will be the case
    in this interaction framework. One of the main advantages of singletons is that
    you can then reference the object instance as a static variable on the object
    class itself. An alternative technique is to find the instance to the component
    at runtime, for example, by calling `FindObjectOfType<T>()` from the script's
    `Start()` function.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，单例模式可能会被滥用，一些程序员坚决反对使用它，因为如果应用程序增长并变得更加复杂，它可能会在未来造成问题。但当你确定应用程序将始终只需要一个类的实例时，它将是一个强大的工具，就像在这个交互框架中一样。单例的主要优点之一是，你可以将对象实例作为对象类本身的静态变量来引用。另一种技术是在运行时找到组件的实例，例如，通过从脚本的
    `Start()` 函数调用 `FindObjectOfType<T>()`。
- en: This script can be used to declare a singleton's `MonoBehaviour` class, as we'll
    see next in `UIController` and other scripts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可用于声明单例的 `MonoBehaviour` 类，正如我们接下来在 `UIController` 和其他脚本中将要看到的。
- en: Writing the UIController script
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 UIController 脚本
- en: 'With our Singleton class in hand, we can now write a UI controller. This component
    provides a way to switch between UI panels visible to the user. Perform the following
    steps to write the `UIController` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们的 Singleton 类后，我们现在可以编写 UI 控制器。这个组件提供了一个在用户可见的 UI 面板之间切换的方法。按照以下步骤编写 `UIController`
    类：
- en: Begin by creating a new script in your `Scripts/` folder by *right-clicking
    and selecting* `UIController`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Scripts/` 文件夹中创建一个新的脚本，通过 *右键单击并选择* `UIController`。
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* 文件以打开它进行编辑，并替换默认内容，从以下声明开始：'
- en: '[PRE1]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the top, we declare a serializable dictionary, `UIPanelDictionary`, using
    the `CanvasGroup` component.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在顶部，我们使用 `CanvasGroup` 组件声明了一个可序列化的字典，`UIPanelDictionary`。
- en: 'Instead of declaring `UIController` as a `MonoBehaviour` class, we declare
    it a `Singleton` (which itself derives from `MonoBehaviour`). Don''t worry about
    the syntax of the declaration, `public class UIController : Singleton<UIController>`.
    This is what our `Singleton` class expects.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们不是将 `UIController` 声明为 `MonoBehaviour` 类，而是将其声明为 `Singleton`（它本身继承自 `MonoBehaviour`）。不用担心声明的语法，`public
    class UIController : Singleton<UIController>`。这正是我们的 `Singleton` 类所期望的。'
- en: The script declares a `uiPanels` variable as a `UIPanelDictionary`. We also
    declare a `currentPanel` variable to track which panel is presently active.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本声明了一个 `uiPanels` 变量，作为一个 `UIPanelDictionary`。我们还声明了一个 `currentPanel` 变量来跟踪当前哪个面板是活跃的。
- en: 'Next, add the following functions to the script, which ensure all the UI panels
    are disabled when the app is started, by iterating through the `uiPanels` list
    and calling `SetActive(false)`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下函数添加到脚本中，通过遍历 `uiPanels` 列表并调用 `SetActive(false)` 来确保在应用程序启动时所有 UI 面板都被禁用：
- en: '[PRE2]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that `Awake` calls `base.Awake()` because the parent `Singleton` class
    also has an `Awake` that must be called in order for this to work. Then it calls
    `ResetAllUI`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Awake` 调用 `base.Awake()`，因为父 `Singleton` 类也有一个 `Awake` 方法，必须调用它才能使这个方法工作。然后它调用
    `ResetAllUI`。
- en: 'Then, add the following functions to the script:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下函数添加到脚本中：
- en: '[PRE3]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`_ShowUI` is an instance function that, given a panel name, calls `ChangeUI`.
    `ChangeUI` hides the current panel and then activates the required one (note that
    I''m using an underscore prefix to distinguish private instance functions from
    the public one). The C# dictionary, `TryGetValue`, looks up the value for the
    given key.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_ShowUI` 是一个实例函数，给定一个面板名称，调用 `ChangeUI`。`ChangeUI` 隐藏当前面板然后激活所需的那个（注意，我使用下划线前缀来区分私有实例函数和公共函数）。C#
    字典的 `TryGetValue` 方法查找给定键的值。'
- en: The static `ShowUI` class function simply calls the instance's `_ShowUI` function.
    In this way, another script can show a panel by calling `UIController.ShowUI(panelname);`
    without requiring a direct reference to the instance. It uses the null-conditional
    operator ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    as a shortcut to make sure the instance is defined before we reference it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `ShowUI` 类函数只是调用实例的 `_ShowUI` 函数。这样，另一个脚本可以通过调用 `UIController.ShowUI(panelname);`
    来显示一个面板，而不需要直接引用实例。它使用空条件运算符 ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    作为快捷方式，确保在引用它之前实例已经定义。
- en: 'Now, add the script as a component on the UI Canvas and set up its properties
    by performing the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将脚本作为组件添加到 UI Canvas 上，并按照以下步骤设置其属性：
- en: In the **Hierarchy** window, select **UI Canvas**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中，选择 **UI Canvas**。
- en: Drag the `UIController` script onto **UI Canvas**, adding it as a component.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UIController` 脚本拖放到 **UI Canvas** 上，将其作为组件添加。
- en: In the **Inspector** window, on the **UI Controller** component, unfold the
    **UI Panels** dictionary list.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 窗口的 **UI Controller** 组件上，展开 **UI Panels** 字典列表。
- en: Click the **+** button in the bottom-right corner of the UI Panels list.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 UI 面板列表右下角的 **+** 按钮。
- en: In the elements `Startup`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元素 `Startup` 中。
- en: Unfold the element and then, from the **Hierarchy** window, drag the **Startup
    UI** game object onto the **Value** slot.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开元素，然后从 **Hierarchy** 窗口，将 **Startup UI** 游戏对象拖放到 **Value** 槽中。
- en: 'Repeat steps 4 – 6 three times for each of the following: `NonAR` : `Scan`
    : `Main` : **Main UI**.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于以下每个选项重复步骤 4 – 6 三次：`NonAR` : `Scan` : `Main` : **主 UI**。'
- en: 'The UI Controller component should now look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: UI 控制器组件现在应如下所示：
- en: '![Figure 4.6 – UI Controller component populated with UI panel references'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 填充了 UI 面板引用的 UI 控制器组件]'
- en: '](img/Figure_4.06-uipanels-insp.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.06-uipanels-insp.jpg]'
- en: Figure 4.6 – UI Controller component populated with UI panel references
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 填充了 UI 面板引用的 UI 控制器组件
- en: Thus far, we have created a simple UI for an AR application, organized on one
    canvas as a set of separate panels. Our plan is to present only one panel at a
    time to the user, depending on what the application is doing. We also wrote a
    `UIController` script to handle switching between panels.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为 AR 应用程序创建了一个简单的 UI，将其组织在一个画布上作为一组单独的面板。我们的计划是每次只向用户展示一个面板，具体取决于应用程序正在做什么。我们还编写了一个
    `UIController` 脚本来处理面板之间的切换。
- en: Fading the UI panels
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 淡出 UI 面板
- en: 'An improvement we can make is to fade the UI in and out while transitioning
    instead of abruptly hiding/showing a panel. Presently, we call `SetActive` to
    change the panel''s visibility. Instead, we can use the panel''s `CanvasGroup`
    component and animate its Alpha value, and the `DOTween` library is very handy
    for this. (You can skip this modification if you do not want to install DOTween).
    To do this, follow these steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的改进是在转换时淡入和淡出 UI，而不是突然隐藏/显示面板。目前，我们通过调用 `SetActive` 来更改面板的可见性。相反，我们可以使用面板的
    `CanvasGroup` 组件并动画化其 Alpha 值，而 `DOTween` 库对此非常方便。（如果您不想安装 DOTween，可以跳过此修改）。为此，请按照以下步骤操作：
- en: 'Open the `UIController` script for editing and add the following declaration
    at the top of the file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `UIController` 脚本进行编辑，并在文件顶部添加以下声明：
- en: '[PRE4]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add these two fader helper functions at the bottom of the class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类底部添加以下两个淡入器辅助函数：
- en: '[PRE5]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, modify the `ChangeUI` function to call the fader helps instead of `SetActive`,
    as shown here (the lines in comments are replaced):'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改 `ChangeUI` 函数以调用淡入器而不是 `SetActive`，如下所示（注释中的行已被替换）：
- en: '[PRE6]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Eventually, when you run the scene, the UI panels will fade in and out when
    shown and hidden, respectively.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当你运行场景时，UI 面板在显示和隐藏时将淡入和淡出。
- en: Next, we will write an Interaction Controller that handles the application interaction
    modes and uses the UI Controller to display the specific UI it needs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个交互控制器，它处理应用程序的交互模式，并使用 UI 控制器显示它需要的特定 UI。
- en: Creating an Interaction Controller mode
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建交互控制器模式
- en: 'For our user framework, we will make a clever use GameObject with a mode script
    on it to represent interaction modes. Modes will be enabled (and disabled) by
    enabling (and disabling) the corresponding objects. We''ll organize these objects
    in a hierarchy, like the UI panels we created in the previous section, but separated
    to keep the "controllers" apart from the "views," as prescribed by the controller/view
    software pattern. Presently, we''ll include the following modes:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用户框架，我们将巧妙地使用带有模式脚本的 GameObject 来表示交互模式。模式将通过启用（和禁用）相应的对象来启用（和禁用）。我们将按照上一节中创建的
    UI 面板的方式组织这些对象，但将其分开以保持“控制器”与“视图”分离，正如控制器/视图软件模式所规定。目前，我们将包括以下模式：
- en: '**Startup mode**: Active while the AR session is initializing, and then it
    initiates Scan mode.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动模式**：在 AR 会话初始化期间处于活动状态，然后它启动扫描模式。'
- en: '**NonAR mode**: A placeholder should you want your application to run even
    if the device does not support AR.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非 AR 模式**：如果您希望应用程序即使在设备不支持 AR 的情况下也能运行，则应使用占位符。'
- en: '**Scan mode**: This prompts the user to scan for trackable features until the
    AR session is ready, and then it initiates Main mode.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描模式**：此模式提示用户扫描可追踪特征，直到 AR 会话准备就绪，然后它启动主模式。'
- en: '**Main mode**: This displays the main menu and handles non-modal interactions.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主模式**：显示主菜单并处理非模态交互。'
- en: First, we'll create the object hierarchy representing each of these modes, under
    an Interaction Controller game object. With separate GameObjects representing
    each mode, we'll be able to enable one mode or another separately.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在交互控制器游戏对象下创建表示每个模式的对象层次结构。通过使用代表每个模式的单独 GameObject，我们将能够分别启用或禁用某个模式。
- en: Creating the interaction mode hierarchy
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建交互模式层次结构
- en: 'To create the interaction mode hierarchy, perform the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建交互模式层次结构，请执行以下步骤：
- en: From the main menu, select `Interaction Controller`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择 `Interaction Controller`。
- en: '*Right-click* the `Startup Mode`.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `Startup Mode`。'
- en: Repeat *step 2* three more times to create objects named `NonAR Mode`, `Scan
    Mode`, and `Main Mode`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 三次以创建名为 `NonAR Mode`、`Scan Mode` 和 `Main Mode` 的对象。
- en: 'The mode hierarchy game objects now look like the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 模式层次结构游戏对象现在看起来如下所示：
- en: '![Figure 4.7 – Interaction Controller modes hierarchy'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 交互控制器模式层次结构'
- en: '](img/Figure_4.07-internactionmode-hier.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07-internactionmode-hier.jpg)'
- en: Figure 4.7 – Interaction Controller modes hierarchy
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 交互控制器模式层次结构
- en: Now we can write and set up the `InteractionController` script.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写和设置 `InteractionController` 脚本。
- en: Writing the Interaction Controller
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写交互控制器
- en: 'The role of our Interaction Controller is to manage the top-level user interaction
    of the application. We''ll begin by writing the script as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交互控制器的角色是管理应用程序的最高级用户交互。我们将从以下脚本开始编写：
- en: Create a new script in your `Scripts/` folder by *right-clicking* `InteractionController`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `InteractionController` 上 *右键单击* 在 `Scripts/` 文件夹中创建一个新的脚本。
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* 文件以打开它进行编辑，并用以下声明替换默认内容：'
- en: '[PRE7]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the top, we declare a serializable dictionary, `InteractionModeDictionary`,
    using the `InteractionController` as a `MonoBehaviour` class, we declare it a
    `Singleton` (which itself derives from `MonoBehaviour`).
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在顶部，我们声明一个可序列化的字典，`InteractionModeDictionary`，使用 `InteractionController` 作为
    `MonoBehaviour` 类，我们将其声明为 `Singleton`（它本身继承自 `MonoBehaviour`）。
- en: Then we declare the `interactionModes` variable as this type of dictionary.
    We also declare a `currentMode` variable that tracks the current enabled mode.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们声明 `interactionModes` 变量为这种类型的字典。我们还声明一个 `currentMode` 变量，用于跟踪当前启用的模式。
- en: 'Next, add the following functions to the script, which ensures all the modes
    are disabled when the app is started, by iterating through the `interactionModes`
    list by calling `SetActive(false)`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向脚本中添加以下函数，通过遍历 `interactionModes` 列表并调用 `SetActive(false)` 来确保在应用启动时所有模式都被禁用：
- en: '[PRE8]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `Awake` calls `base.Awake()` because the parent `Singleton` class
    also has an `Awake` that must be called in order for this to work. It then calls
    `ResetAllModes`.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Awake` 调用 `base.Awake()`，因为父 `Singleton` 类也有一个 `Awake`，必须调用它才能使此操作生效。然后调用
    `ResetAllModes`。
- en: 'Then, add the following functions to the script:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向脚本中添加以下函数：
- en: '[PRE9]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`_EnableMode` is an instance function that, given a mode name, calls `ChangeMode`.
    `ChangeMode` disables the current mode and then activates the requested one.'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_EnableMode` 是一个实例函数，它接受一个模式名称，然后调用 `ChangeMode`。`ChangeMode` 禁用当前模式，然后激活请求的模式。'
- en: Note that `ChangeMode` is called as a `EnableMode` class function simply calls
    the instance's `_EnableMode` function. In this way, another script can show a
    panel by calling `InteractionController.EnableMode(modename);` without requiring
    a direct reference to the instance. It uses the null-conditional operator ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    as a shortcut to make sure the instance is defined before we reference it.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`ChangeMode` 被调用时，只需简单地调用 `EnableMode` 类函数就调用实例的 `_EnableMode` 函数。这样，另一个脚本可以通过调用
    `InteractionController.EnableMode(modename);` 来显示面板，而不需要直接引用实例。它使用空条件运算符 ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-))
    作为快捷方式，以确保在引用实例之前实例已定义。
- en: 'Lastly, assuming we want the app to start in `Startup` mode, add the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，假设我们希望应用以 `Startup` 模式启动，请添加以下内容：
- en: '[PRE10]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This assumes we will include a `"Startup"` mode in the `interactionModes` dictionary.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这假设我们将包括一个 `"Startup"` 模式在 `interactionModes` 字典中。
- en: '`UIController` will contain references to each of the app''s mode game objects.
    When the app needs to switch modes, it will call `InteractionController.EnableMode(modeName)`
    with the name of the mode. The current mode will be disabled, and the required
    one will be enabled.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIController` 将包含对应用程序每个模式游戏对象的引用。当应用需要切换模式时，它将使用模式的名称调用 `InteractionController.EnableMode(modeName)`。当前模式将被禁用，所需模式将被启用。'
- en: 'Add the script as a component on the Interaction Controller game object and
    set up its properties by following these steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本作为组件添加到交互控制器游戏对象上，并按照以下步骤设置其属性：
- en: In the **Hierarchy** window, select the **Interaction Controller** game object.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**交互控制器**游戏对象。
- en: Drag the `InteractionController` script onto the **Interaction Controller**,
    adding it as a component.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`InteractionController`脚本拖放到**交互控制器**上，添加它作为组件。
- en: In the **Inspector** window, on the **Interaction Controller** component, unfold
    the **Interaction Modes** dictionary list.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在**交互控制器**组件上，展开**交互模式**字典列表。
- en: Click the **+** button in the bottom-right corner of the **Interaction Modes**
    list.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**交互模式**列表右下角的**+**按钮。
- en: On the elements `Startup`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元素`Startup`上。
- en: Unfold the element and then, from the **Hierarchy** window, drag the **Startup
    Mode** game object onto the **Value** slot.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开元素，然后从**层次结构**窗口中，将**启动模式**游戏对象拖放到**值**槽中。
- en: 'Repeat steps 4 – 6 three times for each of the following: `NonAR` : `Scan`
    : `Main` : **Main Mode**.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于以下每个项目重复步骤 4 – 6 三次：`NonAR` : `Scan` : `Main` : **主模式**。'
- en: 'The **Interaction Controller** component should now look like the following:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**交互控制器**组件现在应该看起来如下：'
- en: '![Figure 4.8 – Interaction Controller component populated with interaction
    mode object references'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.8 – 填充了交互模式对象引用的交互控制器组件]'
- en: '](img/Figure_4.08-interactionmode-list-insp.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08-interactionmode-list-insp.jpg)'
- en: Figure 4.8 – Interaction Controller component populated with interaction mode
    object references
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.8 – 填充了交互模式对象引用的交互控制器组件
- en: The **Interaction Controller** component will be responding to user input, so
    we need to add a **Player Input** component (assuming your project is using the
    new Input system).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**交互控制器**组件将响应用户输入，因此我们需要添加一个**玩家输入**组件（假设你的项目正在使用新的输入系统）。'
- en: With **Interaction Controller** selected in the **Hierarchy** window, click
    **Add Component** in the **Inspector** window.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**交互控制器**，然后在**检查器**窗口中点击**添加组件**。
- en: Search for `player inp ut` and add a **Player Input** component.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`player inp ut`并添加一个**玩家输入**组件。
- en: Locate the `Inputs/` folder) and drag it to the **Player Input | Actions** slot.
    (As noted in the *Technical requirements* earlier in the chapter, I assume you
    already have this asset as created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037),
    *Your First AR Scene*).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到`Inputs/`文件夹并将其拖放到**玩家输入 | 动作**槽中。（如本章前面在*技术要求*中所述，我假设你已经根据[*第 2 章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)，*你的第一个
    AR 场景*创建了此资产）。
- en: Set **Player Input | Behavior** to **Broadcast Messages**.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**玩家输入 | 行为**设置为**广播消息**。
- en: '*THIS IS IMPORTANT!* We need to make sure the player actions are forwarded
    to the child mode objects.'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*这很重要!*我们需要确保玩家动作被转发到子模式对象。'
- en: In this section, we have created a hierarchy for interaction modes, organized
    under one Interaction Controller game object that has a script for enabling/disabling
    mode objects. Our plan is to allow only one mode to be active at a time. Of course,
    we still need to write the scripts that control each mode, and handle conditions
    when it's time to transition from one particular mode to a different one.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为交互模式创建了一个层次结构，组织在一个具有启用/禁用模式对象的脚本的交互控制器游戏对象下。我们的计划是允许一次只有一个模式处于活动状态。当然，我们仍然需要编写控制每个模式的脚本，并处理从特定模式过渡到不同模式的情况。
- en: Creating the interaction modes behavior
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建交互模式行为
- en: 'When the app enables a mode, it will enable the corresponding game object,
    which has a script that controls the behavior of that mode. When the app changes
    modes, the current mode object will be disabled, and the new one enabled. Each
    mode is responsible for the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启用一个模式时，它将启用相应的游戏对象，该对象有一个脚本控制该模式的行为。当应用更改模式时，当前模式对象将被禁用，新的对象将被启用。每个模式负责以下内容：
- en: Displaying its corresponding UI
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示其对应的用户界面
- en: Transitioning to a different mode when specific conditions are met
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当满足特定条件时切换到不同的模式
- en: We will write mode scripts for each of the modes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个模式编写模式脚本。
- en: The StartupMode script
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动模式脚本
- en: Startup mode begins when the application starts (it's enabled from the `InteractionController`
    `Start()` function). It displays the Startup UI panel. Then it waits for the `ARSession`
    state to become ready, and transitions to Scan mode. Or, if the `ARSession` reports
    that AR is not supported on the current device, it transitions to NonAR mode.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模式在应用程序启动时开始（它由`InteractionController`的`Start()`函数启用）。它显示启动UI面板。然后它等待`ARSession`状态变为就绪，并过渡到扫描模式。或者，如果`ARSession`报告当前设备不支持AR，则过渡到非AR模式。
- en: 'Follow these steps to create Startup mode:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建启动模式：
- en: Create a new script in your `Scripts/` folder by *right-clicking* and selecting
    `StartupMode`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Scripts/`文件夹中通过**右键单击**并选择`StartupMode`创建一个新的脚本。
- en: Drag the `StartupMode` script onto the **Startup Mode** game object in the **Hierarchy**
    window.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StartupMode`脚本拖动到**启动模式**游戏对象在**层次结构**窗口上。
- en: '*Double-click* the `StartupMode` script file to open it for editing and write
    it as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击**`StartupMode`脚本文件以打开它进行编辑，并按照以下内容编写：'
- en: '[PRE11]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The script uses the AR Foundation''s `ARSession` class state variable, `ARSession.state`,
    to determine when the session is initialized or whether AR is unsupported. The
    state is an `enum ARSessionState` with one of the following values:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用AR Foundation的`ARSession`类状态变量`ARSession.state`来确定会话何时初始化或AR是否不受支持。状态是一个`enum
    ARSessionState`，具有以下值之一：
- en: '`None`: The session has not yet been initialized.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：会话尚未初始化。'
- en: '`Unsupported`: The device does not support AR.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unsupported`：设备不支持AR。'
- en: '`CheckingAvailability`: The session is in the process of checking availability.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckingAvailability`：会话正在检查可用性。'
- en: '`NeedsInstall`: The device needs to install or update AR support software.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NeedsInstall`：设备需要安装或更新AR支持软件。'
- en: '`Installing`: The device is in the process of installing AR support software.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Installing`：设备正在安装AR支持软件。'
- en: '`Ready`: The device supports AR and you can enable the `ARSession` component.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ready`：设备支持AR，您可以启用`ARSession`组件。'
- en: '`SessionInitializing`: The AR session is scanning the environment and trying
    to detect trackable objects.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionInitializing`：AR会话正在扫描环境并试图检测可追踪对象。'
- en: '`SessionTracking`: The AR session has found trackable objects and can determine
    the device''s location within the real-world 3D environment.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionTracking`：AR会话已找到可追踪对象，并可以确定设备在现实世界3D环境中的位置。'
- en: When `state` is `Unsupported`, we transition to NonAR mode.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当`state`为`Unsupported`时，我们过渡到非AR模式。
- en: When `state` is `Ready` (or higher), we transition to Scan mode.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当`state`为`Ready`（或更高）时，我们过渡到扫描模式。
- en: The ScanMode script
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描模式脚本
- en: Scan mode is enabled when the device is scanning the environment, trying to
    detect trackable features in the real world. It displays a prompt asking the user
    to point the camera into the room and slowly move the device.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备正在扫描环境，试图在现实世界中检测可追踪特征时，扫描模式被启用。它显示一个提示，要求用户将相机指向房间并缓慢移动设备。
- en: The conditions for ending Scan mode may vary depending on the AR application.
    For example, it may wait until at least one horizontal or vertical plane has been
    detected, or a reference image has been recognized, or a selfie face is being
    tracked. Presently, we'll check `ARPlaneManager` if any trackables have been detected.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描模式结束的条件可能因AR应用程序而异。例如，它可能等待至少检测到一个水平或垂直平面，或识别到一个参考图像，或正在追踪自拍人脸。目前，我们将检查`ARPlaneManager`以确定是否检测到任何可追踪对象。
- en: 'Perform the following steps to create Scan mode:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建扫描模式：
- en: Create a new script in your `Scripts/` folder by *right-clicking* and selecting
    `ScanMode`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Scripts/`文件夹中通过**右键单击**并选择`ScanMode`创建一个新的脚本。
- en: Drag the `ScanMode` script onto the **Scan Mode** game object in the **Hierarchy**
    window.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScanMode`脚本拖动到**层次结构**窗口中的**扫描模式**游戏对象上。
- en: '*Double-click* the `ScanMode` script file to open it for editing and write
    it as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击**`ScanMode`脚本文件以打开它进行编辑，并按照以下内容编写：'
- en: '[PRE12]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Drag the **AR Session Origin** object from the **Hierarchy** window onto the
    **Scan Mode | Plane Manager** slot.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR会话原点**对象从**层次结构**窗口拖动到**扫描模式 | 平面管理器**槽位。
- en: When Scan mode is enabled, the `planeManager.trackables.count > 0` before switching
    to Main mode.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当扫描模式启用时，在切换到主模式之前，`planeManager.trackables.count > 0`。
- en: The MainMode script
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主模式脚本
- en: Main mode, as its name implies, is the main operating mode of the application.
    It may display the main menu, for example, and handle main user interactions.
    For our default framework, there's not much to do yet apart from display the Main
    UI panel.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 主模式，正如其名称所暗示的，是应用程序的主要操作模式。它可能显示主菜单，例如，并处理主要用户交互。对于我们的默认框架，目前除了显示主UI面板外，没有太多事情要做。
- en: 'Perform the following steps to create Main mode:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建主模式：
- en: Create a new script in your Project's `Scripts/` folder by *right-clicking*
    and selecting `MainMode`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目`Scripts/`文件夹中通过*右键单击*并选择`MainMode`来创建一个新的脚本。
- en: Drag the `MainMode` script onto the **Main Mode** game object in the **Hierarchy**
    window.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainMode`脚本拖放到**主模式**游戏对象上，位于**层次结构**窗口中。
- en: '*Double-click* the `MainMode` script file to open it for editing and write
    it as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* `MainMode` 脚本文件以打开它进行编辑，并按照以下内容编写：'
- en: '[PRE13]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Lastly, we define NonAR mode.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义非AR模式。
- en: The NonARMode script
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NonARMode` 脚本'
- en: NonAR mode will be enabled when the device you're running does not support AR.
    You might simply notify the user that the app cannot run, and gracefully exit.
    Alternatively, you may continue to run the app without AR capabilities if that
    makes sense for your project.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行的设备不支持AR时，将启用非AR模式。你可以简单地通知用户应用无法运行，并优雅地退出。或者，如果你的项目需要，你也可以在没有AR功能的情况下继续运行应用。
- en: 'Perform the following steps to create a NonAR mode placeholder:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建非AR模式占位符：
- en: Create a new script in your Project's `Scripts/` folder by *right-clicking and
    selecting* `NonARMode`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目`Scripts/`文件夹中通过*右键单击并选择* `NonARMode` 来创建一个新的脚本。
- en: Drag the `NonARMode` script onto the **NonAR Mode** game object in the **Hierarchy**
    window.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NonARMode`脚本拖放到**非AR模式**游戏对象上，位于**层次结构**窗口中。
- en: '*Double-click* the `NonARMode` script file to open it for editing and write
    it as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* `NonARMode` 脚本文件以打开它进行编辑，并按照以下内容编写：'
- en: '[PRE14]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That about does it. We've created a hierarchy with each of the interaction modes
    as children of `InteractionController.EnableMode()`, which disables the current
    mode and activates a new one. When a mode is enabled, its mode script begins running,
    showing its UI, and potentially interacting with the user until specific conditions
    are met, and then transitions to a different mode. Let's try running the scene
    on your device.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。我们已经创建了一个层次结构，其中每个交互模式都是`InteractionController.EnableMode()`的子项，它禁用当前模式并激活一个新的模式。当一个模式被启用时，其模式脚本开始运行，显示其UI，并可能与用户交互，直到满足特定条件，然后过渡到不同的模式。让我们尝试在你的设备上运行场景。
- en: Testing it out
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一下
- en: 'Now is a good time to **Build And Run** the scene to make sure things are working
    as expected so far. Perform the following steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是构建场景并确保一切按预期进行的好时机。执行以下步骤：
- en: First, be sure to save your work by using **File | Save**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，务必使用**文件 | 保存**保存你的工作。
- en: Select **File | Build Settings** to open the **Build Settings** window.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 | 构建设置**以打开**构建设置**窗口。
- en: Click `ARFramework` scene to **Scenes In Build**, and ensure it is the only
    scene in the list with a checkmark.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `ARFramework` 场景到**构建场景中**，并确保它是列表中唯一带有勾选标记的场景。
- en: Ensure that your target device is plugged into a USB port and that it is ready.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的目标设备已连接到USB端口，并且已准备好。
- en: Click **Build And Run** to build the project.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建并运行**以构建项目。
- en: Once the project builds without errors and launches on your device in **Startup**
    mode. You'll first see the words **Initializing…** from the **Startup** UI panel.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目无错误构建并在你的设备上以**启动**模式启动。你将首先看到来自**启动**UI面板的**初始化…**文字。
- en: Once the AR Session is started, the app transitions to Scan mode and you will
    see the words **Scanning... Please move device slowly**.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦AR会话开始，应用将切换到扫描模式，你将看到文字**扫描...请缓慢移动设备**。
- en: Once a horizontal plane is being tracked, Scan mode transitions to Main mode.
    You will then see on the screen the words **Main Mode Running...**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦水平平面开始跟踪，扫描模式将过渡到主模式。你将在屏幕上看到**主模式运行...**的文字。
- en: If all goes well, the framework is working as intended. To accomplish this,
    we have implemented the Canvas UI and child panels for the user interface. We
    have implemented the Interaction Controller and child mode controllers with scripts
    that implement the UI and interactions required in each mode. And it's all wired
    together. This is a basic framework for an AR project that we will use for projects
    in this book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，该框架将按预期工作。为了实现这一点，我们已实现了用于用户界面的Canvas UI和子面板。我们使用脚本实现了每个模式所需的UI和交互，并实现了交互控制器和子模式控制器。所有这些都已经连接在一起。这是一个基本的AR项目框架，我们将用它来完成本书中的项目。
- en: There are many ways in which we can improve and build on this framework. For
    one, we can make the UI a little more interesting by replacing some of the text
    prompts with animated graphics from the AR Onboarding UX from Unity.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式改进和构建这个框架。一方面，我们可以通过用Unity的AR Onboarding UX中的动画图形替换一些文本提示来使UI更有趣。
- en: Using the Unity onboarding UX assets
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity入门UX资产
- en: Unity provides a set of AR onboarding UX assets useful for prompting users in
    an AR application. **Onboarding** refers to the user experience when your app
    starts up and prompts the user to interact with AR features. First, I'll explain
    some of what this package provides. Then we'll prepare the assets for use in our
    own projects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一套AR入门UX资产，用于在AR应用中提示用户。**入门**指的是当您的应用启动并提示用户与AR功能交互时的用户体验。首先，我将解释这个包提供的一些内容。然后我们将准备用于我们自己的项目的资产。
- en: Introducing the onboarding assets
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍入门资产
- en: The onboarding UX assets are part of the AR Foundation Demos project found at
    [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).
    (This is different from the *AR Foundation Samples* project we explored in [*Chapter
    2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your First AR Scene*). And
    its documentation can be found on that project's GitHub page.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 入门UX资产是位于[https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos)的AR
    Foundation Demos项目的组成部分。（这与我们在[*第二章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)中探索的*AR
    Foundation Samples*项目不同）。其文档可以在该项目的GitHub页面上找到。
- en: The onboarding UX assets include icons and video graphics to prompt the user
    when scanning is required. It automatically tells the user the reasons why tracking
    may be failing, such as the room is too dark, or the camera view does not see
    sufficient details. It provides components to manage that process that are composed
    into an example prefab, named **ScreenspaceUI**, which can be customized to the
    look and feel of your own project.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 入门UX资产包括图标和视频图形，用于在扫描时提示用户。它会自动告诉用户跟踪可能失败的原因，例如房间太暗，或者摄像头视图没有看到足够的细节。它提供了管理此过程的组件，这些组件组合成一个名为**ScreenspaceUI**的示例预制件，可以根据您自己的项目进行定制。
- en: 'For example, when the app is scanning, you can use an animated graphic prompt
    to *Move Device Slowly* while scanning the room. If there''s a problem, it will
    display the reason, as shown in the left-side panel of the following image (where
    I have my finger covering the camera lens). It says **Look for more textures or
    details in the area**. If you want to prompt the user to tap the screen to place
    an object, there''s a **Tap to Place** animated graphic, and so on:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当应用正在扫描时，您可以使用动画图形提示在扫描房间时*缓慢移动设备*。如果有问题，它将显示原因，如以下图像的左侧面板所示（我在那里用手指遮住了摄像头镜头）。它说**在该区域寻找更多纹理或细节**。如果您想提示用户点击屏幕放置对象，有一个**点击放置**的动画图形，等等：
- en: '![Figure 4.9 – Using the onboarding UX assets'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – 使用入门UX资产'
- en: '](img/Figure_4.09-OnboardingStepsCapture.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.09-OnboardingStepsCapture.jpg)'
- en: Figure 4.9 – Using the onboarding UX assets
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 使用入门UX资产
- en: Furthermore, the package supports localization of the text prompts, should your
    project require multi-language support for various countries. It also includes
    some good default assets for visualizing AR planes and point clouds that you can
    use.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该包支持文本提示的本地化，如果您的项目需要支持多个国家的多语言，则可以使用。它还包括一些用于可视化AR平面和点云的默认资产，您可以使用。
- en: The package includes the following components.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包括以下组件。
- en: '**ARUX Animation Manager**: This displays instructional graphic animations
    to prompt the user to find a plane or tap to place, for example.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARUX动画管理器**：它显示指导图形动画，提示用户找到平面或点击放置，例如。'
- en: '**ARUX Reasons Manager**: This checks the AR Session''s status and displays
    reasons why tracking may be failing as hints to the user.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARUX Reasons Manager**：这个工具检查 AR 会话的状态，并显示可能导致跟踪失败的原因，作为对用户的提示。'
- en: '**Localization Manager**: This supports localized text and graphics for adapting
    the instructional and reasons UI to different languages.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Localization Manager**：这个工具支持本地化文本和图形，以便将指导性和原因 UI 调整为不同的语言。'
- en: '`UIManager` script from the AR Foundation Demos project is a useful control
    script, but it is only an example of how to interface with the `ARUXAnimationManager`.
    Reading the script is informative but not reusable. In our framework, we have
    implemented our own solution for the user flow that replaces the `UIManager` script.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 AR Foundation Demos 项目的 `UIManager` 脚本是一个有用的控制脚本，但它只是如何与 `ARUXAnimationManager`
    接口的一个示例。阅读脚本是有信息的，但不可重用。在我们的框架中，我们已经为用户流程实现了自己的解决方案，以替换 `UIManager` 脚本。
- en: '**UI Manager** lets you set up one or two goals via the **Inspector** window.
    A goal may be **Found a Plane** or **Placed an Object**. You then set the instructional
    UI to prompt the user to perform the current activity until its goal has been
    completed.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI Manager** 允许您通过 **Inspector** 窗口设置一个或两个目标。目标可以是 **Found a Plane** 或 **Placed
    an Object**。然后您设置指导性 UI，提示用户执行当前活动，直到目标完成。'
- en: Preparing the Unity AR onboarding assets
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Unity AR 入门资产
- en: While the onboarding UX assets are also available as a package in the Unity
    Asset Store, I recommend you clone the GitHub project version because it has more
    examples and assets, including **Universal Render Pipeline** (**URP**) shader-graph
    shaders. Both versions are full Unity projects, so either way, you will need to
    open it in a new Unity project and then export the assets into a package that
    you can import into your own projects.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 UX 入门资产也可以在 Unity Asset Store 中作为包提供，但我建议您克隆 GitHub 项目版本，因为它有更多的示例和资产，包括
    **Universal Render Pipeline** （**URP**）着色器图。两个版本都是完整的 Unity 项目，所以无论哪种方式，您都需要在一个新的
    Unity 项目中打开它，然后将资产导出为包，以便您可以将其导入到自己的项目中。
- en: We will clone the project and then export the AR Foundation Demos assets into
    a `.unitypackage` file that we can import into our own project. I will also provide
    a copy of this Unity package with the files for this book in the GitHub repository.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将克隆项目，然后将 AR Foundation Demos 资产导出为 `.unitypackage` 文件，我们可以将其导入到自己的项目中。我还会在
    GitHub 仓库中提供包含此书文件的 Unity 包的副本。
- en: 'To clone the project and export the folders we want, perform the following
    steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要克隆项目并导出我们想要的文件夹，请执行以下步骤：
- en: Clone a copy of the project from GitHub to your local machine. The project can
    be found at [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).
    Please use whatever cloning method you prefer, for example, GitHub Desktop ([https://desktop.github.com/](https://desktop.github.com/))
    or Command Line ([https://git-scm.com/download/](https://git-scm.com/download/)).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 克隆项目的副本到您的本地计算机。项目可以在 [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos)
    找到。请使用您喜欢的任何克隆方法，例如 GitHub Desktop ([https://desktop.github.com/](https://desktop.github.com/))
    或命令行 ([https://git-scm.com/download/](https://git-scm.com/download/))。
- en: Open the **Unity Hub** application on your desktop.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的桌面上打开 **Unity Hub** 应用程序。
- en: Add the project to **Unity Hub** by selecting **Projects | Add**, navigating
    to the cloned project's root folder, and then press **Select Folder**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **Projects | Add**，导航到克隆项目的根文件夹，然后按 **Select Folder**，将项目添加到 **Unity Hub**。
- en: In the **Unity Hub** projects list, if you see a yellow warning icon indicating
    that the Unity version used by the cloned project is not presently installed on
    your system, use the **Unity Version** selection to choose a newer version of
    the editor that you do have installed (preferably the same major release number).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Unity Hub** 的项目列表中，如果您看到一个表示克隆项目使用的 Unity 版本当前未安装在系统上的黄色警告图标，请使用 **Unity
    Version** 选择来选择您已安装的较新版本的编辑器（最好是相同的主版本号）。
- en: Open the project by selecting it from the **Unity Hub** projects list.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 **Unity Hub** 项目列表中选择它来打开项目。
- en: We're going to move selected folders into a root folder named `ARFoundationDemos`
    that we can export into a package.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把选定的文件夹移动到一个名为 `ARFoundationDemos` 的根文件夹中，这样我们就可以将其导出为包。
- en: In Unity, in the `ARFoundationDemos`.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Unity 中，在 `ARFoundationDemos`。
- en: 'With your mouse, move the following four folders into this `ARFoundationDemos/`
    folder: **AddressableAssetsData**, **Common**, **Shaders**, and **UX**.'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标，将以下四个文件夹移动到这个 `ARFoundationDemos/` 文件夹中：**AddressableAssetsData**、**Common**、**Shaders**
    和 **UX**。
- en: In the `ARFoundationDemos/` folder and select **Export Package**.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ARFoundationDemos/` 文件夹中，选择**导出包**。
- en: The **Exporting Package** window will open. Click **Export**.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导出包**窗口将打开。点击**导出**。'
- en: Choose a directory outside of this project's root and name the file (such as
    `ARF-OnboardingUX`). Then, click **Save**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此项目根目录之外的一个目录，并为文件命名（例如`ARF-OnboardingUX`）。然后，点击**保存**。
- en: Before you close the `ARFoundationDemos` project, you may want to look in the
    **Package Manager** window and note the **AR Foundation** package version used
    in the given project, to make sure your own project uses the same or later version
    of AR Foundation.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭`ARFoundationDemos`项目之前，您可能想查看**包管理器**窗口并注意给定项目中使用的**AR Foundation**包版本，以确保您的项目使用相同或更高版本的AR
    Foundation。
- en: You can close the `ARFoundationDemos` project now. You now have an asset package
    you can use in this and other projects.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以关闭`ARFoundationDemos`项目。您现在有一个可以在本项目和其他项目中使用的资源包。
- en: Installing dependency packages
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装依赖包
- en: 'The AR onboarding UX has some dependencies on other Unity packages that you
    must install in your own project: *Addressables* and *Localization*. Open your
    AR project and install them now.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: AR导入UX对其他Unity包有依赖，您必须在您的项目中安装这些包：*Addressables*和*Localization*。现在打开您的AR项目并安装它们。
- en: The Addressable Asset system simplifies loading assets at runtime with a unified
    scheme. Assets can be loaded from any location with a unique address, whether
    they reside in your application or on a content delivery network. Assets can be
    accessed via direct references, traditional asset bundles, or `Resource` folders.
    The **Addressables** package is required by the onboarding UX assets. To learn
    more, see [https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可寻址资源系统通过统一的方案简化了运行时加载资源。资源可以从任何具有唯一地址的位置加载，无论它们位于您的应用程序中还是在内容分发网络上。资源可以通过直接引用、传统资源包或`Resource`文件夹访问。**Addressables**包是导入UX资源所必需的。要了解更多信息，请参阅[https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.16/manual/index.html)。
- en: 'To import the **Addressables** package, perform the following steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入**Addressables**包，请执行以下步骤：
- en: Open the **Package Manager** window by using **Window | Package Manager**.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**窗口 | 包管理器**打开**包管理器**窗口。
- en: Ensure **Unity Registry** is selected from the **Packages** filter dropdown
    in the upper-left corner of the **Package Manager** window.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从**包管理器**窗口左上角的**包**过滤器下拉菜单中选择**Unity注册表**。
- en: Search for `Addressables` using the search text input field in the upper-right
    corner of the **Package Manager** window.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**包管理器**窗口右上角的搜索文本输入字段搜索`Addressables`。
- en: Select the **Addressables** package and click **Install**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Addressables**包并点击**安装**。
- en: The **Addressables** package is now installed.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**Addressables**包现在已安装。'
- en: 'The **Localization** package translates text strings and other assets into
    local languages. See [https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html).
    To import the **Localization** package, perform the following steps (these steps
    may have changed by the time you read this):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**Localization**包将文本字符串和其他资源翻译成本地语言。请参阅[https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@1.0/manual/index.html)。要导入**Localization**包，请执行以下步骤（这些步骤在您阅读时可能已更改）：'
- en: If you have not already done so, enable **Preview Packages** by navigating to
    the **Edit | Project Settings | Package Manager** settings and checking the **Enable
    Preview Packages** checkbox.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未这样做，请通过导航到**编辑 | 项目设置 | 包管理器**设置并勾选**启用预览包**复选框来启用**预览包**。
- en: Then, in the **Package Manager** window, use the **+** button in the top-left
    corner and select **Add Package From Git URL**.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**包管理器**窗口中，使用左上角的**+**按钮并选择**从Git URL添加包**。
- en: Then, type `com.unity.localization` to begin installing the package.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入`com.unity.localization`以开始安装包。
- en: 'Info: Using Preview packages and Git URLs'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息：使用预览包和Git URL
- en: As I write this, the **Localization** package is in *preview*, that is, not
    yet fully released by Unity. Also, it is not yet included in the Unity package
    registry. To enable preview packages, you must click **Enable Preview Packages**
    in **Project Settings**. Also if a package is not included in the built-in Unity
    registry, you can add a package from a Git URL, from disk, or from a tarball file.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我写这篇文章时，**本地化**包处于**预览**状态，也就是说，尚未由Unity完全发布。此外，它尚未包含在Unity包注册表中。要启用预览包，您必须在**项目设置**中点击**启用预览包**。另外，如果一个包不包含在内置的Unity注册表中，您可以从Git
    URL、磁盘或tarball文件中添加一个包。
- en: The **Localization** package is now installed. We can now install the AR onboarding
    UX assets themselves.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地化**包现在已安装。我们现在可以安装AR引导UX资产本身。'
- en: Importing the OnboardingUX package
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入OnboardingUX包
- en: 'We saved the assets exported from the AR Foundation Demos project into a file
    named `OnboardingUX.unitypackage`. Importing the package is straightforward. Follow
    these steps to add it to your project. Back in your own Unity project, do the
    following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将AR Foundation Demos项目导出的资产保存到一个名为`OnboardingUX.unitypackage`的文件中。导入包的过程很简单。按照以下步骤将其添加到您的项目中。回到您的Unity项目中，执行以下操作：
- en: Select `OnboardingUX.unitypackage` file from your Explorer or Finder directly
    into the Unity **Project** window.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的资源管理器或Finder直接将`OnboardingUX.unitypackage`文件选择到Unity的**项目**窗口中。
- en: In the **Import Unity Package** window, click **Import**.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入Unity包**窗口中，点击**导入**。
- en: The assets include materials that use the built-in render pipeline. Since our
    project is using the URP, you need to convert the materials by selecting `ARFoundationDemos/Common/Materials/`
    folder and, in the **Inspector** window, change its **Shader**, using the drop-down
    menu, to **ShaderGraphs/BlurredShadowPlane**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资产包括使用内置渲染管道的材料。由于我们的项目正在使用URP，您需要通过选择`ARFoundationDemos/Common/Materials/`文件夹，并在**检查器**窗口中，使用下拉菜单将**着色器**更改为**ShaderGraphs/BlurredShadowPlane**来转换这些材料。
- en: The onboarding UX assets are now imported into your project. We can now add
    it to our framework scene.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 引导UX资产现在已导入到您的项目中。我们现在可以将其添加到我们的框架场景中。
- en: Currently, our app renders a UI panel with text to prompt the user to scan the
    environment. This panel is a game object that is enabled when needed. Basically,
    we want to replace the panel text with animated graphics.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序渲染一个带有文本的UI面板，提示用户扫描环境。该面板是一个在需要时启用的游戏对象。基本上，我们想要用动画图形替换面板文本。
- en: Writing the AnimatedPrompt script
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写AnimatedPrompt脚本
- en: 'Let''s start by writing a new script, `AnimatedPrompt`, that displays a specific
    animation when it is enabled and hides the animation when disabled:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个新的脚本`AnimatedPrompt`开始，该脚本在启用时显示特定的动画，在禁用时隐藏动画：
- en: Create a new script in your `Scripts/` folder by *right-clicking and selecting*
    `AnimatedPrompt`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Scripts/`文件夹中创建一个新的脚本，通过*右键单击并选择* `AnimatedPrompt`。
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击**文件以打开它进行编辑，并替换默认内容，从以下声明开始：'
- en: '[PRE15]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this script, we declare a public property, `instruction`, whose value is
    an `enum InstructionUI` type that indicates which animation to play (borrowed
    from the `UIManager` script from the onboarding assets, to be consistent).
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此脚本中，我们声明一个公共属性`instruction`，其值是一个`enum InstructionUI`类型，指示要播放哪个动画（从引导资产中的`UIManager`脚本借用，以保持一致性）。
- en: 'When the script is started or enabled, it will initiate the animated graphics.
    Inversely, when the object is disabled, the graphics are turned off:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本启动或启用时，它将启动动画图形。相反，当对象禁用时，图形将关闭：
- en: '[PRE16]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I've added a fix to ensure the animation does not restart when both `Start`
    and `OnEnable` are called at the start.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经添加了一个修复，以确保当在开始时同时调用`Start`和`OnEnable`时，动画不会重新启动。
- en: 'When the script is enabled, it calls the helper function, `ShowInstructions`,
    which calls a corresponding function in `ARUXAnimationManager`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本启用时，它会调用辅助函数`ShowInstructions`，该函数会调用`ARUXAnimationManager`中的相应函数：
- en: '[PRE17]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can add this to our scene.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其添加到场景中。
- en: Integrating the onboarding graphics
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成引导图形
- en: 'To integrate the onboarding graphics, we can add the demo prefab (unfortunately
    named `ScreenspaceUI`) from the AR Foundation Demos package. Follow these steps:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成引导图形，我们可以从AR Foundation Demos包中添加演示预制件（不幸的是命名为`ScreenspaceUI`）。按照以下步骤操作：
- en: In the `ARFoundationDemos/UX/Prefabs/` folder and drag the **ScreenspaceUI**
    prefab into the **Hierarchy** window root of the scene.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ARFoundationDemos/UX/Prefabs/` 文件夹中，将 **ScreenspaceUI** 预制拖放到场景的 **Hierarchy**
    窗口根目录。
- en: Give it a more indicative name; rename the object `OnboardingUX`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它一个更具指示性的名称；重命名对象 `OnboardingUX`。
- en: Our framework replaces the demo **UI Manager** component, so you should remove
    this.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的框架替换了演示中的 **UI Manager** 组件，因此你应该将其移除。
- en: With the **OnboardingUX** object selected in **Hierarchy**, click the *3-dot
    context menu* in the top-right corner of the **UI Manager** component in the **Inspector**
    window and select **Remove Component**.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **OnboardingUX** 对象，点击 **Inspector** 窗口右上角的 *3-dot context
    menu* 并选择 **Remove Component**。
- en: 'We can now use `AnimatedPrompt` to replace the text in our UI prompt panels.
    To use it, perform the following steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `AnimatedPrompt` 来替换我们的 UI 提示面板中的文本。要使用它，请执行以下步骤：
- en: In the `Animated Prompt`.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Animated Prompt`。
- en: With the `AnimatedPrompt` script from the **Project** window onto the object.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Project** 窗口中的 `AnimatedPrompt` 脚本拖放到对象上。
- en: Set the **Animated Prompt | Instruction** to **Cross-Platform Find A Plane.**
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Animated Prompt | Instruction** 设置为 **Cross-Platform Find A Plane**。
- en: From the **Hierarchy** window, drag the **OnboardingUX** object into the **Inspector**
    window and drop it on to the **Animation Manager** slot.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口，将 **OnboardingUX** 对象拖放到 **Inspector** 窗口的 **Animation Manager**
    插槽中。
- en: You can disable the **Text (TMP)** child element of **Scan Prompt Panel** so
    that it won't be rendered.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以禁用 **Scan Prompt Panel** 的 **Text (TMP)** 子元素，这样它就不会被渲染。
- en: If you **Build And Run** the project again, when it enters Scan mode, you will
    be greeted with nice, animated graphics instead of the text prompt.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次 **Build And Run** 项目，当它进入扫描模式时，你将看到漂亮的动画图形而不是文本提示。
- en: With a working AR user framework, let's make this scene into a template that
    we can use when creating new scenes.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有一个工作的 AR 用户框架后，让我们将这个场景制作成一个模板，以便在创建新场景时使用。
- en: Creating a scene template for new scenes
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新场景创建场景模板
- en: We can save this **ARFramework** scene we've been working on as a template to
    use for starting new scenes in this Unity project. To create a scene template,
    perform the following steps.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们一直在工作的这个 **ARFramework** 场景保存为模板，用于在此 Unity 项目中创建新场景。要创建场景模板，请执行以下步骤。
- en: With the **ARFramework** scene open, select **File | Save As Scene Template**.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ARFramework** 场景打开时，选择 **File | Save As Scene Template**。
- en: In the `Scenes/` folder, verify the template name (`ARFramework.scenetemplate`),
    and then press **Save**.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scenes/` 文件夹中，验证模板名称（`ARFramework.scenetemplate`），然后按 **Save**。
- en: Subsequently, when you want to start a new AR scene, use this template. By default,
    Unity will duplicate any dependencies within the scene into a separate folder.
    In our case, this is generally *not* what we want to do.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，当你想要开始一个新的 AR 场景时，请使用此模板。默认情况下，Unity 会将场景中的任何依赖项复制到一个单独的文件夹中。在我们的例子中，这通常**不是**我们想要做的。
- en: To prevent cloning the scene dependencies when the template is used, click on
    this new scene template file in your `Assets/` window.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了防止在模板中使用时克隆场景依赖项，点击你的 `Assets/` 窗口中的这个新场景模板文件。
- en: In its `ARFramework`. Just remember to check the **Dependencies** list in the
    template if you've added any new assets to the scene as these will default to
    be cloned.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其 `ARFramework`。只需记住，如果模板中添加了任何新资产，请检查模板中的 **Dependencies** 列表，因为这些将默认被克隆。
- en: To use the template when creating a new scene in this project, use **File |
    New Scene** as usual. The dialog box will now contain the **ARFramework** template
    as an option. Select the location in your assets folder and press **Create**.
    If the template specifies any assets to be cloned, those copies will be added
    to a subfolder with the same name as the new scene.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此项目中创建新场景时使用模板，像往常一样使用 **File | New Scene**。现在对话框将包含 **ARFramework** 模板作为选项。选择你的资产文件夹中的位置并按
    **Create**。如果模板指定了任何要复制的资产，这些副本将被添加到与新场景同名的一个子文件夹中。
- en: We are now ready to build upon the work we did in this chapter, using the **ARFramework**
    template for new project scenes.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在此基础上构建本章所做的工作，使用 **ARFramework** 模板为新项目场景。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a framework for building AR applications and saved
    it as a template we can use for projects in this book. The framework provides
    a state-machine structure for implementing modes and identifying the conditions
    when to transition to a different mode. The framework also offers a controller-view
    design pattern where, when a mode is active, its corresponding UI is visible,
    keeping the mode control objects separate from the UI view objects.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个用于构建AR应用的框架，并将其保存为一个模板，我们可以用它来构建本书中的项目。该框架提供了一个状态机结构，用于实现模式并识别何时过渡到不同的模式。该框架还提供了一个控制器-视图设计模式，其中当某个模式处于活动状态时，其对应的UI界面可见，从而将模式控制对象与UI视图对象分离。
- en: 'For the framework template, we implemented four modes: Startup mode, Scan mode,
    Main mode, and NonAR mode, along with four UI panels: Startup UI, Scan UI, Main
    UI, and NonAR UI. Scan mode uses the onboarding UX assets from the AR Foundation
    Demos project to prompt the user to scan for trackable features and report problems
    with detection and the AR session.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于框架模板，我们实现了四种模式：启动模式、扫描模式、主模式和NonAR模式，以及四个UI面板：启动UI、扫描UI、主UI和非AR UI。扫描模式使用来自AR
    Foundation Demos项目的onboarding UX资源，提示用户扫描可追踪特征，并报告检测和AR会话中的问题。
- en: In the next chapter, I will demonstrate the use of this framework with a simple
    demo project and then build upon the framework more extensively in subsequent
    chapters.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将通过一个简单的演示项目展示这个框架的使用方法，并在随后的章节中更广泛地构建这个框架。
