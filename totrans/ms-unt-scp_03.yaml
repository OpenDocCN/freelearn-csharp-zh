- en: Chapter 3. Singletons, Statics, GameObjects, and the World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every level or game world in Unity is represented by a scene, and a scene is
    a collection of game objects situated inside a Cartesian 3D coordinate system
    with *x*, *y* and *z* axes. Units in a scene are measured in Unity units, and
    these correspond (for practical purposes) to meters. In order to script masterfully
    with Unity, it's critical to understand the anatomy of both scenes and objects
    and how interobject communication happens; that is, it's important to know how
    separate and independent objects in a scene can communicate with each other to
    make things happen as you expect. Consequently, this chapter focuses on the native
    Unity methods available to optimally search, reference, and access objects in
    a scene. It also focuses on additional concepts such as statics and singletons
    for the creation of objects that travel between scenes, retaining their data as
    they move. Of course, this chapter will not only consider these methods individually,
    but it'll try to appraise them in practical contexts, with performance and efficiency
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GameObject` is, in many senses, the fundamental unit or entity inside
    a scene. It corresponds most naturally to what we''d call a *thing* in the everyday
    sense. It doesn''t really matter what kind of context-specific behaviors or things
    you''ll actually need inside your own games, because in all cases, you''ll need
    `GameObjects` to implement them. `GameObjects` don''t need to be visible to the
    gamer; they can be, and often are, invisible. Sounds, colliders, and manager classes
    are some examples of invisible `GameObjects`. On the other hand, many `GameObjects`
    will be visible: meshes, animated meshes, sprites, and so on. In all cases, however,
    whether visible or invisible, the `GameObject` is instantiated inside a scene
    as a collection of related components. A **component** is essentially a class
    derived from `MonoBehaviour`, and it can be attached to a `GameObject` in the
    scene to change its behavior. Every `GameObject` has at least one minimal component
    in common, and it''s impossible to remove it, namely, the **Transform** component
    (or the RectTransform for GUI objects). This component keeps track of an object''s
    position, rotation, and scale. For example, if you create a blank, empty game
    object in the scene by going to **GameObject** | **Create Empty** from the application
    menu, as shown in the following screenshot, you would end up with a new game object
    in the scene, featuring only a Transform component. Thus, even a new and empty
    `GameObject` is not, strictly speaking, empty, but it''s as empty as a `GameObject`
    ever gets. The object still needs a Transform component to maintain its physical
    location in a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The GameObject](img/0655OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All GameObjects feature a Transform component
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a `GameObject` can have many components, and the behavior of an object
    arises from the combination and interaction of its components. You can add more
    premade components to an object using the **Component** menu, and you can add
    your own custom components by dragging-and-dropping your scripts onto an object.
  prefs: []
  type: TYPE_NORMAL
- en: '![The GameObject](img/0655OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Components are attached to GameObjects
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `GameObjects` are composed of components. At a higher level, scenes are
    composed of a collection of `GameObjects` inside a single world space. Furthermore,
    objects themselves exist in an important relationship with each other, as defined
    by the scene hierarchy. Objects can be the children of others, who are in turn
    their parents (`transform.parent`). This relationship has important implications
    for how objects move and transform. In short, values for an object''s Transform
    component will cascade downwards and be added to the transform of all its children.
    In this way, a child `GameObject` is always offset and transformed relative to
    its parent; the parent position is the origin of the child position. However,
    if an object has no parent, then it would be transformed away from the world origin
    at (0, 0, 0). The following screenshot shows the **Hierarchy** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The GameObject](img/0655OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GameObjects exist in a scene hierarchy that determines their transformations
  prefs: []
  type: TYPE_NORMAL
- en: Component interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen the anatomy of a `GameObject` as a collection of components and nothing
    more. This raises logistical issues about how components should interact and communicate
    with each other. Each component is effectively implemented as a self-contained
    script file, separate from any other component, yet a component must often interact
    with others. Specifically, you'll often need to access variables and call functions
    on other components on the same `GameObject`, and you might even need to do this
    on every frame. This section explores such intercomponent communication.
  prefs: []
  type: TYPE_NORMAL
- en: One way to call functions on other components is to use `SendMessage` and `BroadcastMessage`,
    as shown in [Chapter 1](ch01.html "Chapter 1. Unity C# Refresher"), *Unity C#
    Refresher*. These functions are type agnostic. Specifically, they're functions
    we might call anywhere in the script to invoke methods by names on *all* other
    components attached to the same object, regardless of their type. These functions
    don't care about the component type at all. This makes both `SendMessage` and
    `BroadcastMessage` convenient to use. However, the problem with them is twofold.
    First, they're an all or nothing affair; we might call a function by name on all
    components or on none at all. We can't pick and choose which component the message
    is dispatched to, because it's always dispatched to them all. Second, both methods
    (`SendMessage` and `BroadcastMessage`) rely internally on reflection, which can
    cause performance issues when used often, such as by calling these functions in
    `Update` events or, even worse, in `OnGUI` events. For these reasons, seek to
    use alternative methods wherever practically possible. Let's consider these in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: GetComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need direct access to a specific and single component on an object and
    you know its data type, try using `GetComponent` as shown in the following code
    sample 3-1\. This function gives you access to the first component of a matching
    type attached to a `GameObject`. Once you get a reference to it, you can access
    the component like any regular object, setting and getting its public variables
    and invoking its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments on the code sample 3-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 07 and 13**: The variable `ThisTransform` is declared as private. This
    variable is assigned a reference to the Transform component attached to the `GameObject`,
    and it achieves this inside the `Start` event using the `GetComponent` function.
    In the case of accessing the Transform component specifically, we could also have
    used an inherited `transform` property, such as `ThisTransform= transform;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 20**: Here, the `ThisTransform` variable is used directly to set the
    `localPosition` of the `GameObject`. Again, for the Transform component specifically,
    we could also have used `transform.localPosition`. However, this approach internally
    invokes an extra function call, because the member `transform` is a C# property
    and not a standard variable. More on properties can be found in [Chapter 1](ch01.html
    "Chapter 1. Unity C# Refresher"), *Unity C# Refresher*. For this reason, using
    `GetComponent` inside a `Start` or `Awake` event to retrieve a component reference
    to a private class variable is typically one of the most efficient ways to access
    external components, especially if the component must be accessed regularly, such
    as inside an `Update` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**localPosition versus position**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Transform component exposes two main position members: `position` and `localPosition`.
    Setting either of these will change an object''s position in specific and distinct
    ways. The position member always defines an object''s position in world space
    as a measure from the world origin. Setting this variable in script, therefore,
    might not correspond to the numbers you actually see for the Transform component
    in the Object Inspector when the object is selected. If your object is a child
    of another object that''s not positioned to the world origin, for example, then
    Unity would offset the object''s local position away from its parent, by however
    much is necessary, to position it at the world space location that is specified.
    The `localPosition` member, in contrast, corresponds directly to the `position`
    value shown for the Transform component in the Object Inspector. Specifically,
    it specifies the position of an object as a measured offset away from its parent
    location or else from the world origin if the object has no parent. In the latter
    case, both the `position` and `localPosition` members will be identical.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More information on the `GetComponent` function can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also access the Unity documentation from the MonoDevelop **Help** menu,
    by navigating to **Help** | **Unity API Reference**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting multiple components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally, you''ll want to retrieve multiple components in a list: sometimes,
    a list of all components and sometimes, a list matching only a specific type.
    You can get this using the `GetComponents` function. See the following code sample
    3-2\. As with the `GetComponent` function, it''s good practice to call `GetComponents`
    during one-off events such as `Start` and `Awake` as opposed to frequent events
    such as `Update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More on Components**'
  prefs: []
  type: TYPE_NORMAL
- en: Unity offers additional variations on the `GetComponent` and `GetComponents`
    functions that facilitate interobject communication and not just communication
    between components in the same object. These functions include `GetComponentsInChildren`
    to retrieve an accumulative list of all components in all children and also `GetComponentsInParent`
    to retrieve all components in an object's parent.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the `GetComponents` function can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/Component.GetComponents.html](http://docs.unity3d.com/ScriptReference/Component.GetComponents.html).
  prefs: []
  type: TYPE_NORMAL
- en: Components and messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GetComponent` family of functions work well and should meet almost all
    your needs for intercomponent communication. They certainly perform better than
    either `SendMessage` or `BroadcastMessage` when used appropriately. Yet, there
    are situations where it''d be ideal if, given a `GameObject`, you could invoke
    a method with `SendMessage` on *only one* component as opposed to all, without
    having to know anything about the component type in advance. Now, you could achieve
    this behavior to some extent using delegates and interfaces (covered in the next
    chapter). However, here we''ll consider the `SendMessage` approach. One scenario
    where this would be especially useful is for the creation of extendable behaviors.
    For example, perhaps your game has many enemy types and you need to leave open
    the possibility of adding more, all of which could be implemented in different
    ways. Yet, despite their differences, all enemies will need to save their data
    to a persistent file when the game is saved. It''d then be useful for the enemy
    to handle an `OnSave` function, which will be implemented by a specific component.
    This is fine, but you want the `OnSave` function on that component alone to be
    called by the `SendMessage` system. You don''t want the method invoked for other
    components on the object, in case they too handle a function `OnSave` that you
    don''t want called inadvertently. In short, you can achieve this using the `Invoke`
    method. Consider the following code sample 3-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments on the code sample 3-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 07**: This class features a public reference variable `Handler`. Using
    this field, you can drag-and-drop any component via the Object Inspector into
    the `Handler` slot. This represents the component to which a message will be dispatched.
    Notice that its class type is `MonoBehaviour` or any class derived from this.
    This means type agnosticism is achieved and we don''t need to know the object
    type in advance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 14**: The `Invoke` method of `MonoBehaviour` is called to run any method
    of matching name. The second floating point argument specifies the time in seconds,
    after which the function should be invoked. A time of 0 specifies immediate invoking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `Invoke` function can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GameObjects and the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another pivotal task in Unity involves searching for objects in the scene from
    script, especially if objects are instantiated at runtime. Tasks such as "get
    me the player object" and "get me all enemies in the scene" are important for
    many operations, from respawning enemies and power-ups to repositioning the player
    and checking collisions between objects. To retrieve references to specific `GameObjects`,
    Unity offers a set of functions associated with the `GameObject` class. These
    functions can be useful but expensive, so be sure to call them during one-off
    events, such as `Start` and `Awake`, wherever possible. Let's explore these further,
    in addition to other techniques and methods to work with found objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finding GameObjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding an object in the scene can be achieved through either the `GameObject.Find`
    or `GameObject.FindObjectWithTag` function. Of these two, the latter should almost
    always be preferred for performance reasons. However, let''s consider `GameObject.Find`
    first. This function searches the scene for the first occurrence of an object
    with an exactly matching name (case-sensitive) and then returns that object. The
    name that''s searched should match the object name as it appears in the **Hierarchy**
    panel. Unfortunately, the function performs string comparisons to determine the
    match, so it''s a slow and cumbersome option. Besides, it''s only truly effective
    for objects guaranteed to have unique names, and many times, objects won''t have.
    However, that said, `GameObject.Find` is still highly useful when objects are
    appropriately named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**GameObject Finding**'
  prefs: []
  type: TYPE_NORMAL
- en: If you notice the `GameObject`, you would realize that the `Find` function is
    static. This means that you don't need an instantiation of any specific `GameObject`
    to call the function. You can call it directly from any source file via `GameObject.Find`.
    The concept of static and global scope is considered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the `GameObject.Find` function can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.Find.html](http://docs.unity3d.com/ScriptReference/GameObject.Find.html).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GameObject.Find` can be a slow function. For this reason, use it only inside
    one-fire events, such as `Awake` and `Start`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more effective search is by tag. Every object in the scene has a tag member
    that is assigned **Untagged** by default. This member is a unique identifier that
    can mark a single object or multiple objects bringing them together into a collection.
    Generally, to search for objects by tag, you''ll first need to explicitly assign
    an object with a tag. You can do this in script, using the `GameObject.tag` public
    member. However, you''ll use the Unity Editor more commonly. You can assign a
    tag to a selected object from the Unity Editor by clicking the **Tag** drop-down
    list in the Object Inspector and picking a tag. In addition, you can create new,
    custom tags by selecting the **Add Tag** option. Common tags include **Player**,
    **Enemy**, **Weapon**, **Bonus**, **Prop**, **Environment**, **Light**, **Sound**,
    and **GameController**, among others. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding GameObjects](img/0655OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assigning a tag to an object
  prefs: []
  type: TYPE_NORMAL
- en: 'After one or more objects are assigned a tag in the scene, you can effectively
    search for objects by tag in code. The `GameObject.FindGameObjectWithTag` function
    searches the scene for an object with a matching tag and returns the first occurrence.
    The `GameObject.FindObjectsWithTag` returns an array of all occurrences. See the
    following code sample 3-4 for an example. Note that although the `FindGameObjectsWithTag`
    function requires a string argument, Unity internally converts the string into
    a numerical form to increase the speed of tag comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you'd like to assign multiple tags to a single object. Unfortunately,
    Unity doesn't support this behavior yet. However, you can work around the limitation
    by parenting empty game objects to your main object and assigning each of the
    children the tag you need. When searching for objects by tag, though, just remember
    to get a reference to the parent object, which is actually the object you need.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GameObject` searching functions are helpful when searching scene-wide
    for specific objects, but there are times when you''ll need to compare two objects
    that you''ve found already. Typically, you''ll want compare the names or tags
    of two objects. You can achieve a tag comparison using the `CompareTag` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, you''ll sometimes want to compare two objects for equality to
    determine whether they''re the same object and not simply whether they share the
    same tag. This is especially important when coding decision-making behaviors.
    For example, in determining whether an enemy character should fight or flee from
    the player during combat, it''d be helpful to ascertain whether the enemy has
    supporting units nearby to help him. To answer this, you can find all enemies
    in the scene with a tag search, as we saw earlier. However, the results will also
    include the enemy who made the call originally and who is now deciding what to
    do, so we''ll want to exclude him from the results. Code sample 3-4 demonstrates
    how `GetInstanceID` can help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Getting the nearest object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given an array of `GameObjects`, perhaps returned from a search, how can you
    find the one nearest to you in the scene in terms of linear distance? The following
    code sample 3-5 demonstrates how you can find this object using the `Vector3.Distance`
    function to retrieve the shortest distance (in meters) between any two points
    in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finding any object of a specified type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you just want a list of all the components of a specified type in
    the scene, regardless of which game objects they''re actually attached to; these
    components include all enemies, all collectible objects, all transform components,
    all colliders, and so on. Achieving this from script is simple but expensive,
    as shown in the following code sample 3-6\. Specifically, by calling the `Object.FindObjectsOfType`
    function, you can retrieve a complete list of all instances of a specified object
    in the scene, unless an object is deactivated. Due to the expense of this method,
    avoid calling it during frame-based events such as `Update`. Use the `Start` and
    `Awake` events, as well as infrequent functions instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Clearing a path between GameObjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given any two `GameObjects` in the scene, such as the **Player** and an **Enemy**
    character, it's common to test for a clear path between them, that is, to test
    whether there are any colliders intersecting an imaginary line drawn between the
    two objects. This can be helpful in line-of-sight systems, as we'll see later,
    but also more generally for object culling, to determine AI functionality and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing a path between GameObjects](img/0655OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing for a clear path between two GameObjects using Physics.LineCast
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to achieve this behavior. One way is to use the `Physics.LineCast`
    function, as shown in the following code sample 3-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments on the code sample 3-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 07**: This sample class should be attached to the `Player`; otherwise,
    another source object accepts a public member variable `Enemy` to whom a clear
    path should be tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 10**: The `LayerMask` variable specifies a bitmask, indicating which
    layers in the scene the collision test applies to. More information on bitmasks
    can be found in the online Unity documentation at [http://docs.unity3d.com/Manual/Layers.html](http://docs.unity3d.com/Manual/Layers.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 16**: The `Physics.Linecast` function is used to determine whether a
    clear and nonbroken path exists between two objects in the scene. Note that if
    the two objects themselves have colliders, such as `BoxColliders`, then these
    will be included in the collision detection; they will not be ignored. In other
    words, an object''s own collider can affect the results of any `LineCast` calls.
    For this reason, use the `LayerMask` variable to include or exclude specific layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Physics.LineCast` project is included in the book's companion files in the
    `Chapter03/LineCast` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessing object hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Hierarchy** panel in Unity offers a graphical illustration of the parent-child
    relationship that holds among all `GameObjects` in a scene. This relationship
    is important because child objects are contained by, and inherit, the transformations
    of their parents. However, being able to define and edit the hierarchical relationship
    in the editor is usually not enough. You''ll frequently need to parent one object
    to another in code and also cycle through all children of a specified object to
    process data or invoke functionality on them. Let''s first see how to parent objects.
    The following code sample 3-8 demonstrates how to attach one object X to another
    object Y as its child, through the Transform component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how to cycle through all the child objects attached to a parent.
    Again, this is achieved through the Transform component, as shown in the following
    code sample 3-9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The world, time, and updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Unity scene represents a collection of finite `GameObjects` inside the same
    3D space and that also share the same timeframe. Every game needs to establish
    a unified concept of time to achieve synchronized animation and change, because
    animation means change over time. In Unity, the `Time` class is available for
    reading and understanding time and its passing in script. Working with this class
    is therefore a critical skill for the creation of predictable and consistent motion
    in your games. More on this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every game has a frame rate, which is defined in **frames per second** (**FPS**).
    This rate is viewable from the **Stats** panel in the **Game** tab. The FPS tells
    you how many times in 1 second Unity is able to loop or iterate through your game
    code to draw a new render from the cameras to the screen. Each iteration is called
    a **frame**. The frame rate varies dramatically over time and across different
    computers. It''s influenced by the power of your computer, other processes that
    might be running, and by how much content it needs to render in the current frame,
    among other factors. This means you can never rely on FPS being consistent over
    time or the same across different computers; there''ll often be a different number
    of FPS. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The world, time, and updates](img/0655OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FPS is important for the creation of time-based behavior and animations
  prefs: []
  type: TYPE_NORMAL
- en: 'To approximate the concept of a frame, Unity offers three class events that
    every `MonoBehaviour` class can implement to perform functionality that must continually
    update or change over time. These events have already been seen, but now, we''ll
    consider them in more depth, specifically `Update`, `FixedUpdate` and `LateUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Update`: The `Update` event is called *once* per frame for every active component
    on every active `GameObject` in the scene. If an object is deactivated by the
    `MonoBehaviour.SetActive` method, then `Update` events will not be called for
    that object until it is activated. In short, the `Update` event most accurately
    represents the concept of a frame in Unity, so it''s useful for performing repetitive
    behaviors or functionality that must be updated and monitored over time, such
    as player input events, keyboard presses, and mouse clicks. Note that the order
    in which `Update` events are invoked across all components for each frame is not
    guaranteed; that is, you cannot be sure whether the `Update` function on object
    X will be called before that on object Y during any one frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedUpdate`: Like `Update`, this event is typically called multiple times
    per frame. However, its calling pattern is regular and normalized, with fixed
    time intervals between each call. The most common use of `FixedUpdate` is to work
    with Unity physics. If you need to update the velocity or properties of a Rigidbody
    component over time, then `FixedUpdate` rather than `Update` would be the place
    to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LateUpdate`: This is called on each frame, like `Update`. However, `LateUpdate`
    is always called after `Update` and `FixedUpdate`. This means that when `LateUpdate`
    is called, you can be sure that `Update` and `FixedUpdate` have already been called
    for every object on the current frame. This makes `LateUpdate` a useful place
    to update camera movement, especially third-person cameras, ensuring that the
    camera always follows objects at their latest positions on the current frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The details of `Update`, `FixedUpdate` and `LateUpdate`, in combination with
    the concepts of time and FPS, have significant implications on how you should
    or should not code your games when creating motion over time. Specifically, two
    main guidelines emerge, and these are considered over the next two subsections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule #1 – frames are precious'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frames should occur many times per second; if they don't, your game will look
    laggy and broken. On each frame, an `Update` event is called once for every active
    `MonoBehaviour` in the scene. This means the computational complexity (and performance)
    of your scenes on each frame depends, in large measure, on what you do inside
    `Update` events. More functionality demands more processing time and workload,
    either for the CPU or GPU. For large scenes with many objects and components,
    it would be easy then for things to get out of hand if you don't reduce the workload
    inside `Update` functions by careful code planning. It's important, therefore,
    to think of `Update` events or any regularly called frame-based events as precious.
    In short, you should only put code inside them when you really need to, such as
    to read player input or observe cursor movement. It's helpful to start thinking
    of event-driven programming, as this can help you seriously reduce the workload
    inserted inside `Update` functions. The next chapter considers event-driven programming
    and event systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule #2 – motion must be relative to time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you cannot guarantee the frequency of frames (frame rate differs over time
    and across computers), then you need to code motion and change very carefully
    to achieve a consistent experience for the gamer. Consider the simple case of
    moving a cube object in the scene smoothly over time. One way (a bad way) to create
    motion will be as shown in the following code sample 3-10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is effective insofar as it will move the attached object by the variable
    `AmountToMove` on each frame. The problem is that it's frame-rate dependent. Now,
    because frames are inconsistent over time and across computers, each user will
    ultimately receive a different experience; specifically, they'll see the cube
    moving at different speeds. This is bad because we simply cannot predict how the
    game will run for any specific user. To fix this, we need to map motion to time
    as opposed to frames. Frames are variable, but time is constant; one second is
    exactly that. To achieve this, we can use the `deltaTime` variable, which is part
    of the `Time` class. See the following code sample 3-11\. This is an amended version
    of sample 3-10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `deltaTime` variable is a floating-point value and always expresses how
    much time, in seconds, has elapsed since the previous `Update` function was called.
    A value of 0.5, for example, means half a second has elapsed since the previous
    frame and so on. This is useful because `deltaTime` can act as a multiplier. By
    multiplying a speed variable by `deltaTime` on each frame, we can know how far
    an object should move because *distance = speed x time*. Thus, `deltaTime` gives
    us frame-rate independence for object motion.
  prefs: []
  type: TYPE_NORMAL
- en: Immortal objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Unity regards every object as existing within the self-enclosed
    time and space of a scene. The difference between scenes is like the difference
    between separate universes. Consequently, objects don''t survive outside the scene
    to which they belong; this means that they die whenever the active scene changes.
    This is typically how you want objects to behave, because scenes are usually very
    different and separate from one another. However, even so, there will be objects
    that you don''t want destroyed. There will be objects that you need *carried over*
    between scenes, such as the **Player** character, a high-score system, or a `GameManager`
    class. These are normally high-order objects whose existence shouldn''t be limited
    to specific scenes; they should rather span or arc across multiple scenes. You
    can create object persistence easily using the `DontDestroyOnLoad` function, but
    it has important consequences worth considering. Take a look at the following
    code sample 3-12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Object persistence between scenes is important, but *travelling objects* take
    their baggage with them as they move between scenes. This means any and all child
    objects will survive with the persistent object as well as any assets or resources
    it uses, such as meshes, textures, sounds, and others. This is not a problem per
    se, but it is important to be aware of it. For this reason, many persistent objects
    are created light, that is, as empty game objects with no children, featuring
    only the basic component makeup they need to work properly. This ensures that
    only the essential, critical data survives between scene changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scene Changing**'
  prefs: []
  type: TYPE_NORMAL
- en: To change the active scene in Unity, use the `Application.LoadLevel` function.
    There are variations on this, including `LoadLevelAsync`, `LoadLevelAdditive`,
    and `LoadLevelAdditiveAsync`. More information on the level-loading functions
    can be found online at [http://docs.unity3d.com/ScriptReference/Application.html](http://docs.unity3d.com/ScriptReference/Application.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, the `DontDestroyOnLoad` function is called on an existing
    object in the active scene and prevents that object from being destroyed on future
    scene changes. From this, however, an issue sometimes arises concerning object
    duplication. Specifically, if you later reload or return to the original scene
    in which the persistent object first existed, then a persistent duplicate of the
    object is made, namely, the persistent original that came with you from the previous
    scene and a newer instantiation of the object created for the newly entered instance
    of the scene. This problem is, of course, magnified for each occasion you re-enter
    the scene, as each time a new duplicate will be made. Such duplication is usually
    not what you want. You typically want only one instance of the object to exist
    at any one time: one player, one game manager, or one high-score board. To achieve
    this, you''ll need to create a singleton object, as explained in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding singleton objects and statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some classes are fundamentally different from others in the way they should
    be instantiated. Most classes define a template for a collection of properties
    and behaviors that might be instantiated many times in a scene as `GameObjects`.
    An enemy class can be used to instantiate many enemy objects, a power-up class
    for many power-up objects, and so on. However, some classes such as `GameManager`,
    `HighScoreManager`, `AudioManager`, or `SaveGameManager` are intended to exist
    as a lone entity, one that consolidates a unified set of behaviors. In short,
    there should only ever be one instance of the class at any one time and never
    more than one. To have more than one instance would either be nonsensical or damage
    the object's authority and usefulness in some way. These kinds of objects are
    known as singletons. Singletons are often persistent objects that survive across
    scenes, though they need not be. The only essential ingredient in a singleton
    (which makes it what it is) is that there cannot be more than one instance of
    the class in memory at any one time. Let's now create a singleton object in the
    context of making a sample `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, every game has a `GameManager` or `GameController` class; and
    these are almost always singleton objects that persist. The `GameManager` is essentially
    responsible for all high-level functionality in a game. It must determine whether
    a game is paused, whether the win condition has been satisfied, and have a reliable
    way of knowing what''s happening in the game at any one time, among others. Consider
    the sample beginnings of a `GameManager` in the following code sample 3-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This object will persist across scenes, but how can it (or any class like it)
    become a singleton object? The following code sample 3-14 demonstrates how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments on the code sample 3-14:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 10-20**: A private member `instance` is added to the `Manager` class,
    which is declared as `static`. This means the variable is shared across all instances
    of the class if there are multiple instances, as opposed to being a variable whose
    value is specific to each instance. This allows each new instance, when created,
    to determine whether there is any existing instance of the class in memory. This
    variable is made publically accessible too via the `Instance` property, which
    only has a `get` member to make it read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 36-43**: Here, in the `Awake` event (called at object creation), the
    instance variable is checked to see whether any valid instance of the class exists
    in the current scene already. If it does, then the current object is deleted,
    because only one instance of this class is allowed and already exists. This means
    the `GameManager` will persist across scene changes, and there will always be
    only one original instance of the object in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Awake versus Start**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GameManager` class uses the `Awake` function, as opposed to `Start`, in
    code sample 3-12\. The difference between `Start` and `Awake` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Awake` is always called before `Start`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Awake` is always called at object creation. `Start` is called on the first
    frame in which the `GameObject` becomes active. If a `GameObject` starts the scene
    deactivated, then `Start` will not be called until the object is activated. For
    objects that are activated by default, `Start` is called at the beginning of the
    scene, after the `Awake` event.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to cache component references into local variables of a class, such
    as the Transform component in `ThisTransform`, then use the `Awake` event rather
    than `Start`. During the `Start` event, the assumption should be that all local
    references to objects are already valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great benefit of having a global, static `Instance` property for `GameManager`
    is that it becomes instantly and directly accessible to any other script file,
    without the need for any local variables or object references. This means every
    class has instant access to all `GameManager` properties and can call upon high-order
    game functionality. For example, to set the game score variable on the `GameManager`
    from a different class, the following code sample 3-15 can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on singleton objects can be found online at [http://unitypatterns.com/singletons/](http://unitypatterns.com/singletons/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter considered `GameObjects`, scenes, and components, as well as their
    general usage throughout scenes. These issues might superficially seem simple,
    but understanding their usage and being able to employ them to manage objects
    is a powerful skill that's required in almost all Unity game development projects.
    Specifically, we've seen the `GameObject`, a collection of components that interact
    to produce a unified behavior. The Transform component is especially important.
    We also looked at scenes. A scene is a single time and space inside which `GameObjects`
    exist. Typically, a scene is a self-enclosed entity that prevents any objects
    from existing outside it. Further, every scene works through a concept of time
    that makes change and animation possible. Time can be measured through `deltaTime`,
    which acts like a multiplier and allows us to achieve frame-rate-independent motion.
    Finally, we explored the singleton design pattern, which uses static members to
    define classes that, in practice, can only have one instantiation active in memory
    at any one time. In the next chapter, we'll move on to event-driven programming.
  prefs: []
  type: TYPE_NORMAL
