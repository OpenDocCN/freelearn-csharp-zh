- en: Implementing Design Patterns - Basics Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced FlixOne and the initial development of
    a new inventory management application. Several patterns were used by the development
    team, ranging from patterns designed to limit the scope of a deliverable such
    as a **Minimum Viable Product** (**MVP**) to patterns to assist in the development
    of the project such as **Test Driven Development** (**TDD**). Several patterns
    from the **Gang of Four** (**GoF**) were also applied as a solution to leverage
    how others have solved similar problems in the past so that we don't repeat common
    mistakes. Single responsibility principle, Openâ€“closed principle, Liskov substitution
    principle, Interface Segregation principle, and Dependency inversion principle
    (SOLID principles) were applied to ensure we are creating a stable code base that
    will help in the management and future development of our application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will continue to explain the building of the FlixOne inventory
    management application by incorporating more patterns. More of the GoF patterns
    will be used, including the singleton and factory patterns. A singleton pattern
    will be used to illustrate the repository pattern that is used to maintain the
    FlixOne collection of books. The factory pattern will further the understanding
    of the **Dependency Injection** (**DI**). Finally, we will use the .NET Core framework
    to facilitate an **Inversion of Control** (**IoC**) container that will be used
    to complete the initial inventory management console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio or later. You
    can use your preferred IDE. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions included. Multiple versions are available
    for the installation of Visual Studio; in this chapter, we are using Visual Studio
    for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow the installation instructions for the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is available in GitHub. The source code that is shown
    in this chapter might not be complete, so it is recommended that you retrieve
    the source code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4)).
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern is another GoF design pattern that is used to restrict
    the instantiation of a class to one object. It is used in situations where actions
    within a system need to be coordinated or access to data needs to be limited.
    For example, if access to a file needs to be restricted within an application
    to a single writer, then a singleton could be used to prevent multiple objects
    from trying to write to the file at the same time. In our scenario, we are going
    to use a singleton to maintain the collection of books and their inventory.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the singleton pattern is more apparent when it is illustrated using
    examples. This section will start with a basic class and then go on to identify
    the different issues that the singleton pattern addresses. These issues will be
    identified, and the class will be updated and then verified by unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern should only be used when necessary as it can introduce
    a potential bottleneck for the application. Sometimes, the pattern is viewed as
    an anti-pattern as it introduces global state. With global state, unknown dependencies
    within an application are introduced and it then becomes unclear as to how many
    types might depend on the information. Additionally, many frameworks and repositories
    already limit access when required, so introducing an additional mechanism might
    limit the performance unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core provides support for a number of the patterns discussed. In the next
    chapter, we will take advantage of the `ServiceCollection`class's support for
    both the factory method and the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, the singleton pattern will be used to hold an in-memory repository
    containing a collection of books. The singleton will prevent the collection of
    books from being updated by more than one thread at a time. This will require
    us to *lock* a section of the code to prevent unpredictable updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complexity of introducing a singleton into an application can be subtle;
    so, to gain a solid understanding of the pattern, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: .Net Framework's handling of processes and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing to identify race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the singleton pattern, we need to provide a little context. In
    the .Net Framework, an application will be composed of lightweight, managed subprocesses
    called application domains that can comprise one or more managed threads. For
    the purpose of understanding the singleton pattern, let's define this as a multithreaded
    application that contains one or more threads running simultaneously. Technically,
    the threads are actually not running simultaneously, but this is achieved by dividing
    the available processor time between the threads, so that each thread will execute
    for a small amount of time and then the thread will suspend activity, allowing
    for another thread to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the singleton pattern, in a multithreaded application, special
    care needs to be taken to ensure that access to the singleton is limited so that
    only one thread enters specific areas of logic at a time. Because of this synchronization
    of threads, it is possible for one thread to retrieve a value and update it, and,
    before it can be stored, another thread also updates the value.
  prefs: []
  type: TYPE_NORMAL
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid data being updated incorrectly, some restriction is required to prevent
    more than one thread from executing the same block of logic at the same time.
    There are several mechanisms supported in the .Net Framework and, in the singleton
    pattern, the `lock` keyword is used. In the following code, the `lock` keyword
    is illustrated to show that only one thread at a time can execute the highlighted
    code while all other threads will be blocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The lock is a simple way of restricting access to a section of code and can
    be applied to both object instances, as our previous example shows, and to the
    sections of code marked as static.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern that is introduced to the project is applied to a class
    being used to maintain the inventory's collection of books. The singleton will
    prevent access from multiple threads being handled incorrectly, and, another pattern,
    the repository pattern, will be used to create a facade over the data that is
    being managed.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern provides an abstraction over a repository to provide
    a layer between the business logic of an application and the underlying data.
    This provides several advantages. By having a clean separation, our business logic
    can be maintained and unit tested independently of the underlying data. Often,
    the same repository pattern class can be reused by multiple business objects.
    An example of this could be `GetInventoryCommand`, `AddInventoryCommand`, and
    `UpdateInventoryCommand` objects; all of these objects use the same repository
    class. This allows us to test the logic in these commands in isolation from the
    repository. Another advantage of the pattern is that it enables centralized data-related
    policies to be more easily implemented, such as caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s consider the following interface that describes the methods
    that the repository will implement; it contains a method for retrieving the books,
    adding a book, and updating the quantity of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial version of the repository is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, the book collection is being maintained in the form of an in-memory
    cache, and, in later chapters, this will be moved to a repository providing persistent
    data. Of course, this implementation is not ideal, as, once the application ends,
    all the data will be lost. However, it serves to illustrate the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the issues that the singleton pattern addresses, let''s start
    with a simple unit test that adds 30 books to the repository, updates the quantity
    of the different books, and then verifies the result. The following code shows
    the overall unit test, and we will explain each step individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To add 30 books, the `context` instance is used to add books from `Book_1`to
    `Book_30`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section updates the book quantity by adding the numbers from `1` to
    `10` to the quantity of each book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the next section, we will subtract the numbers from `1` to `10` from
    the quantity of each book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have added and removed the same quantity for each book, the last part
    of our test will verify that the ending quantity is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the test, we can see that the test passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9597d7f3-ef49-419f-b295-077228d9471e.png)'
  prefs: []
  type: TYPE_IMG
- en: So, when the test is run in a single process, the repository works as desired.
    However, what if the update requests are performed in separate threads? In order
    to test this, the unit test will be refactored to perform calls to the `InventoryContext`
    class in separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of the books is moved to a method that performs adding a book
    as a task (that is, in its own thread):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the update quantity step is moved into another method with a
    similar approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The unit test is then updated to call the new methods. It is worth noting that
    the unit test will wait until all books are added before updating the quantity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add thirty books` section now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the update quantity is changed to call both the `Add` and `subtract`
    method in the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the refactor, the unit test no longer successfully completes, and, when
    the unit test runs now, an error is reported indicating that the book was not
    found in the collection. This will be reported as `"The given key was not present
    in the dictionary."`. This is because each time the context is instantiated, a
    new books collection is created. The first step is to restrict the creation of
    the context. This is done by changing the access of the constructor so that the
    class can no longer be instantiated directly. Instead, a new public `static` property
    that only supports a `get` operation is added. This property will return an underlying
    `static`instance of the `InventoryContext` class and, if the instance is missing,
    will create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still not enough to fix the broken unit test, but this is due to a
    different reason. To identify the issue, the unit test is run in debug mode with
    a breakpoint set in the `UpdateQuantity` method. The first time this is run, we
    can see that 28 books have been created and loaded in the book collection, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point in the unit test, we would expect 30 books; however, before we
    start investigating, let''s run the unit test a second time. This time, we get
    an **Object reference not set to an instance of an object** error when we try
    to access the books collection for adding a new book, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/268b58d4-cbbe-4b12-9b77-df3b31df45db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, when the unit test is run a third time, the **Object reference not
    set to an instance of an object** error is not encountered, but there are only
    27 books in our collection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46a4b8bc-48e9-4586-b1af-c64784920993.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This type of unpredictable behavior is typical of race conditions and indicates
    that the shared resource, that is, the `InventoryContext` singleton, is being
    handled by multiple threads without synchronizing the access. The construction
    of the static object still allows more than one instance of the `InventoryContext`
    singleton to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The race condition is where multiple threads evaluate the `if` statement as
    true and they all try to construct the `_context` object. All will succeed, but
    they will overwrite the previously constructed value by doing so. Of course, this
    is inefficient, especially when the constructor is a costly operation, but the
    issue discovered with the unit test is that the `_context` object is actually
    constructed by a thread after another thread or threads have updated the books
    collection. That is why the books collection, `_books`, has a different number
    of elements between runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this issue, the pattern uses a lock around the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the unit tests still fail. This is because although one thread
    at a time can enter the lock, all blocked instances will still enter the lock
    once the blocking thread has completed. The pattern handles this situation by
    having an additional check inside the lock in case the construction has already
    been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lock is essential as it prevents the static `InventoryContext`
    object from getting instantiated multiple times. Unfortunately, our test still
    does not consistently pass; with each change, the unit test becomes closer to
    passing. Some unit test runs will complete without error but, occasionally, the
    test completes with a failed result, as indicated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf03f40-50e7-4459-8209-60388b3b9a71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our instantiation of the static repository is now thread safe, but our access
    to the books collection is not. One thing to note is that the `Dictionary` class
    being used is not thread-safe. Fortunately, there are thread-safe collections
    available as part of the .Net Framework. These classes ensure that **adds and
    removals** from the collection are written for a multithreaded process. Note that
    only adds and removals are thread safe as this will become important a little
    bit later. The updated constructor is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft recommends using the thread-safe collections in `System.Collections.Concurrent`
    over the corresponding collections in `System.Collections`, unless the application
    is targeting .Net Framework 1.1 or earlier.
  prefs: []
  type: TYPE_NORMAL
- en: After running the unit test again, introducing a `ConcurrentDictionary` class
    is still not enough to prevent incorrectly maintaining the books. The unit test
    is still failing. The concurrent dictionary protects from multiple threads being
    added and removed unpredictably, but does not offer any protection on the items
    in the collection themselves. This means that updates to the objects in the collection
    are not thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at race conditions in a multithreaded environment to
    understand why this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: A race condition illustration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sequence of diagrams visualize what is happening conceptually
    between two threads: **ThreadA** and **ThreadB**. The first diagram shows both
    threads without any values from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe27049f-ade1-485f-a255-bcd56290bbc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows that both threads read from the collection of the
    book with the name of `Chester`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b80704-df53-4c39-b3c5-e7176a6c2467.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows that **ThreadA** updates the book by increasing
    the quantity by `4`, while **ThreadB** updates the book by increasing the quantity
    by `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5a8650f-1f3d-4414-9109-f15046958d42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, when the updated book is persisted back to the collection, we have an
    unknown quantity as the result, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a99992-46d0-4eb7-a464-d82126476461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To avoid this race condition, we need to block other threads while an update
    operation is taking place. In `InventoryContext`, blocking other threads takes
    the form of a lock around the update of the book quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The unit test now completes without error, as the additional locks prevent unpredictable
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The `InventoryContext` class is still not complete as it has been completed
    just enough to illustrate the singleton and repository patterns. In later chapters,
    the `InventoryContext` class will be adapted to use Entity Framework, an **Object
    Relational Mapping** (**ORM**) framework. At this point, the `InventoryContext`
    class will be improved to support additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: AddInventoryCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our repository available, the three `InventoryCommand` classes can be
    completed. The first, `AddInventoryCommand`, is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the repository, `IInventoryContext`, is injected
    in the constructor along with the `IUserInterface` interface described in the
    previous chapter. The command also requires a single parameter, `name`*,* to be
    supplied. This is retrieved in the `GetParameters` method that implements the
    `IParameterisedCommand` interface, which was also covered in the previous chapter.
    The command is then run in the `InternalCommand` method, which simply executes
    the `AddBook` method on the repository and returns a bool indicating whether the
    command has executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: TestInventoryContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `TestUserInterface` used in the previous chapter, the `TestInventoryContext`
    class will be used to mock the behavior of our repository by implementing the
    `IInventoryContext` interface. This class will support the three methods of the
    interface, as well as supporting two additional methods for retrieving the books
    that have been added to the collection during the unit test and for retrieving
    the books that have been updated during the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the `TestInventoryContext` class, two collections will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first is used to store the starting collection of the books, while the
    second is used to store the final collection of the books. The constructor is
    shown in the following code; note how the dictionaries are copies of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IInventoryContext` methods are written to update and return just one of
    the collections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the unit test, the two remaining methods can be used to determine
    the difference between the starting and ending collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is some confusion in the software industry around the differences between
    mocks, stubs, fakes, and other terms used to identify and/or categorize types
    or services used in testing that are not suitable for production but are necessary
    for the unit test. These dependencies may have functionality that is different,
    missing, and/or the same as their *real* counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `TestUserInterface` class could be referred to as a mock as
    it provides some expectation (for example, assert statements) of the unit test
    while the `TestInventoryContext` class would be a fake, as it provides a working
    implementation. In this book, we will not follow these classifications too strictly.
  prefs: []
  type: TYPE_NORMAL
- en: AddInventoryCommandTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AddInventoryCommandTest` was updated by the team to verify the `AddInventoryCommand`
    functionality. This test will verify the adding of a single book to an existing
    inventory. The first part of the test is to define what is expected of the interface,
    which is only a single prompt to receive the new book name (remember that the
    `TestUserInterface` class takes three parameters: expected input, expected messages,
    and expected warnings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TestInventoryContext` class will be initialized with a single book simulating
    an existing book collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows the creation of `AddInventoryCommand`, the
    running of the command, and the assert statements used to validate that the command
    ran successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After the command is run, the result is verified to have run without error and
    that the command is not a terminating command. The rest of the `Assert` statements
    validate the expectation that only one book was added with the expected name.
  prefs: []
  type: TYPE_NORMAL
- en: UpdateQuantityCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UpdateQuantityCommand` is very similar to `AddInventoryCommand` and its source
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `AddInventoryCommand`, the `UpdateInventoryCommand` command is a non-terminating
    command with parameters. Therefore, it extends the `NonTerminatingCommand` base
    class and implements the `IParameterisedCommand` interface. Similarly, the dependencies
    for `IUserInterface` and `IInventoryContext` are injected in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateQuantityCommand` class does have an additional parameter, *quantity*,
    which is determined as part of the `GetParameters` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the quantity of a book is updated via the repository''s `UpdateQuantity`
    method in the `InternalCommand` override method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `UpdateQuantityCommand` class has been defined, the following section
    will add a unit test to validate the command.
  prefs: []
  type: TYPE_NORMAL
- en: UpdateQuantityCommandTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UpdateQuantityCommandTest` contains a test to validate a scenario where a
    book is updated in an existing collection. The creation of the expected interface
    and existing collection are shown in the following code (note that the test involves
    adding `6` to the quantity of an existing book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block shows the running of the command and the initial validation
    of the successful run of the non-terminating command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The expectation of the test is that no new books would be added and that the
    existing book''s quantity of 7 will be increased by 6, resulting in a new quantity
    of 13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With the `UpdateQuantityCommand` class added, the ability to retrieve the inventory
    will be added in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GetInventoryCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GetInventoryCommand` command differs from the previous two commands because
    it does not require any parameters. It does use the `IUserInterface` dependency
    and the `IInventoryContext` dependency to write the content of the collection.
    This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With the `GetInventoryCommand` command implemented, the next step is to add
    a new test.
  prefs: []
  type: TYPE_NORMAL
- en: GetInventoryCommandTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GetInventoryCommandTest` covers a scenario when the `GetInventoryCommand`
    command is used to retrieve the collection of books. The test will define the
    expected messages (remember that the first parameter is for the parameters, the
    second parameter is for messages, and the third parameter is for warnings) that
    will occur when testing the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'These messages will correspond to the mock repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit test runs the command with the mock dependencies. It verifies that
    the command executed without error and that the command is not a terminating command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected messages are validating in `TestUserInterface` and, hence, the
    only thing that remains for the unit test to do is to make sure that no books
    were mysteriously added or updated by the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that suitable unit tests for the `GetInventoryCommand` class have been added,
    we'll introduce the factory pattern in order to manage the creation of specific
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next pattern applied by the team is the GoF factory pattern. The pattern
    introduces a **creator** whose responsibility is the instantiation of implementations
    of a specific type. Its purpose is to encapsulate the complexity around constructing
    types. The factory pattern allows for more flexibility as the application changes,
    by limiting the amount of required change compared to whether the construction
    was in the calling class. This is because the complexity of the construction is
    in one location, instead of distributed in multiple locations across the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the FlixOne example, `InventoryCommandFactory` implements the pattern and
    shields the details of constructing each of the different `InventoryCommand` instances.
    In this scenario, the input received from the console application will be used
    to determine the concrete implementation of `InventoryCommand` to return. It is
    important to note that the return type is the `InventoryCommand` abstract class,
    thus shielding the calling class from the details of the concrete class.
  prefs: []
  type: TYPE_NORMAL
- en: '`InventoryCommandFactory` is shown in the following code block. But, for now,
    focus on the `GetCommand` method as this implements the factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`GetCommand` uses a given string to determine the specific implementation of
    `InventoryCommand` to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: All commands require `IUserInterface` to be supplied, but some also require
    access to the repository. These will be supplied with the singleton instance of
    `IInventoryContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern is often used with an Interface as the return type. It is
    illustrated here as the `InventoryCommand` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, the idea of building unit tests for such a simple class seemed
    like a waste of the team's time. Two important issues were uncovered by constructing
    the unit tests that might have gone undetected.
  prefs: []
  type: TYPE_NORMAL
- en: Issue one â€“ UnknownCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first issue was what to do when a command is received that does not match
    any of the defined `InventoryCommand` inputs. After reviewing the requirements,
    the team noticed they missed this requirement, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2609a169-37d7-4a74-8aac-65d25b8c1a77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The team decided to introduce a new `InventoryCommand` class, `UnknownCommand`,
    to handle this situation. The `UnknownCommand` class should print a warning message
    to the console (via the `IUserInterface` `WriteWarning` method), should not cause
    the application to end, and should return false to indicate that the command was
    not run successfully. The implementation details are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit test created for `UnknownCommand` will test for the warning message
    as well as the two Boolean values returned by the `InternalCommand` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`UnknownCommandTests` covers the commands that require testing. Next, tests
    around `InventoryCommandFactory` will be implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: InventoryCommandFactoryTests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InventoryCommandFactoryTests` contains unit tests related to `InventoryCommandFactory`.
    Because each test will have a similar pattern of constructing `InventoryCommandFactory`
    and its `IUserInterface` dependency and then running the `GetCommand` method,
    a shared method is created that will run when the test initializes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Initialize` method constructs a stubbed `IUserInterface` and sets the
    `Factory` property. The individual unit tests then take a simple form of validating
    that the object returned is the correct type. First, an instance of the `QuitCommand`
    class should be returned when the user enters `"q"` or `"quit"`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QuitCommand_Successful` test method validates that when the `InventoryCommandFactory`
    method, `GetCommand`, is run, the object returned is a specific instance of the
    `QuitCommand` type. `HelpCommand` is only available when `"?"` is submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The team did add a test for `UnknownCommand` that validated how `InventoryCommand`
    would respond when given a value not matching an existing command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With the test methods in place, we can now cover a scenario where a command
    is given that does not match a known command in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Issue two â€“ case-insensitive text commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second issue was uncovered when the requirements were reviewed again, stating
    that the commands should not be case-sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the test for `UpdateInventoryCommand`, `InventoryCommandFactory` was found
    to be case-sensitive using the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, this test was easy to solve by applying a `ToLower()` method to
    the input before determining the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This scenario highlights both the value of the `Factory` method and the value
    of leveraging unit tests to help validate requirements during development and
    not relying on user testing.
  prefs: []
  type: TYPE_NORMAL
- en: Features in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns â€“ Basics Part 1,* and the first part of this chapter have illustrated
    the GoF patterns without using any frameworks. It is worth covering this as, sometimes,
    a framework is not available for a specific pattern or applicable in a particular
    scenario. Additionally, it is important to understand what functionality the framework
    is providing in order to know when a pattern should be used. The rest of this
    chapter will look at a couple of features that .NET Core provides that support
    some of the patterns we have covered so far.'
  prefs: []
  type: TYPE_NORMAL
- en: IServiceCollection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core was designed with **Dependency Injection** (**DI**) built-in to the
    framework. Typically, the start of a .NET Core application contains the set up
    of the DI for an application that primarily contains the creation of a collection
    of services. The framework uses these services to supply the dependencies when
    the application requires them. The services provide the foundation of a robust
    **Inversion of Control** (**IoC**) framework and are arguably one of the coolest
    features of .NET Core. This section will complete the console application and
    demonstrate how .NET Core supports building a sophisticated IoC framework based
    on the `IServiceCollection` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IServiceCollection` interface is used to define the services available
    to the container that implements `IServiceProvider` interface. The services themselves
    are types that will be injected at runtime when required by the application. For
    example, `ConsoleUserInterface` interface, which was defined previously, will
    be a service injected at runtime. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `ConsoleUserInterface` interface is being added as a
    service that implements the `IUserInterface` interface. If the DI is providing
    another type that requires a `IUserInterface` interface dependency, then `ConsoleUserInterface`
    interface will be used. For example, `InventoryCommandFactory` is also added to
    the services, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`InventoryCommandFactory` has a constructor that requires an implementation
    of the `IUserInterface` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, an instance of `InventoryCommandFactory` is requested, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, an instance of `IUserInterface` (in this application it is the registered
    `ConsoleUserInterface`) is instantiated and supplied to the constructor of `InventoryCommandFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of service *lifetimes* that can be specified when
    registering a service. A lifetime governs how the types will be instantiated and
    include Transient, Scoped, and Singleton. Transient means the service is created
    each time it is requested. Scope will be covered later when we look at website-related
    patterns and in particular where services are created per web request. Singleton
    behaves like the singleton pattern we covered earlier, and will also be covered
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: CatalogService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CatalogService` interface represents the console application the team
    is building and is described as having a single `Run` method, as shown in the
    `ICatalogService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The service has two dependencies, `IUserInterface` and `IInventoryCommandFactory`,
    and they will be injected into the constructor and stored as local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run` method is based on the earlier design by the team shown in [Chapter
    3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design Patterns
    â€“ Basics Part 1.* It prints a greeting and then loops until the quit inventory
    command is entered by the user. Each loop will perform the command and, if the
    command is not successful, it will print a help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `CatalogService` interface ready, the next step will be
    to put everything together. The next section will do this using .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: IServiceProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `CatalogService` defined, the team is finally able to put everything together
    in .NET Core. The start of all applications, that is, EXE programs, is the `Main`
    method, and .NET Core is no exception. The program is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the `ConfigureServices` method, different types are added to the IoC container
    including `ConsoleUserInterface`, `CatalogService`, and `InventoryCommandFactory`
    classes. The `ConsoleUserInterface` and `InventoryCommandFactory` class will be
    injected as required and the `CatalogService` class will be explicitly retrieved
    from the `IServiceProvider` interface built from the `ServiceCollection` object
    containing the added types. The program *runs* until the `CatalogService` `Run`
    method completes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml), *Implementing Design
    Patterns - .NET Core*, the singleton pattern will be revisited to use the .NET
    Core built-in capabilities by using the `IServiceCollection`, `AddSingleton` method
    to control the `InventoryContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The console application, when running from the command line, is simple, but
    it is a foundation of well-designed code adhering to the SOLID principles discussed
    in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns â€“ Basics Part 1*. When run, the application provides a simple greeting
    and displays a help message, including the command''s supports and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b227f12-9b64-4501-9190-7385cf1f6d34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application then loops through the commands until a quit command is received.
    The following screenshot illustrates its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23375dec-001c-4064-9278-19da5d745827.png)'
  prefs: []
  type: TYPE_IMG
- en: This was not the most impressive of console applications, but it served to illustrated
    many principles and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns â€“ Basics Part 1,* this chapter continued the description of building
    an inventory management console application for FlixOne, in order to show practical
    examples of using **Object-Oriented Programming** (**OOP**) design patterns. In
    this chapter,the GoF's singleton and factory patterns were the focus. These two
    patterns have a particularly important role to play in .NET Core applications
    and will be used often in the following chapters. An introduction to using the
    built-in framework to provide an IoC container was also covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter finished with a working inventory management console application
    based on the requirements determined in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns â€“ Basics Part 1*. These requirements were the basis
    of the unit tests created in both chapters and were used to illustrate TDD. The
    team has a higher level of confidence that the application will pass the **User
    Acceptance Testing** (**UAT**) by having a suite of tests that verify the features
    required for this phase of development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with the description of building the inventory
    management application. The focus will move from basic OOP patterns to using the
    .NET Core framework to implement different patterns. For example, the singleton
    pattern introduced in this chapter will be refactored to use the capability of
    `IServiceCollection` to create a singleton, and we will also take a closer look
    at its DI capabilities. Additionally, the application will be extended to support
    logging using a variety of logging providers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide an example why using a singleton **would not** be a good mechanism for
    limiting access to a shared resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the following statement true? Why or why not? `ConcurrentDictionary` prevents
    items in the collection from being updated by more than one thread at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a race condition and why should it be avoided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the factory pattern help to simplify code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do .NET Core applications require third-party IoC containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
