<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Introducing Dependency Injection in .NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter is a first approach in the implementation of .NET Core Dependency Injection technologies in the most recent version of .NET Core (2.0). </span><span class="koboSpan" id="kobo.2.2">Its main features, functionalities, and the namespaces holding the set of classes support these features.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We will talk about the following in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">In all, we'll talk about how .NET Core includes support for several of the SOLID principles in general and those related to Dependency Injection in particular</span></li>
<li><span class="koboSpan" id="kobo.5.1">We'll start with the main characteristics of .NET Core and its installation and usage from Visual Studio, especially focusing on the latest version, Visual Studio 2017, together with the distinct types of deployment that this version allows</span></li>
<li><span class="koboSpan" id="kobo.6.1">Then, we'll get into the Dependency Injection in .NET Core, the </span><kbd><span class="koboSpan" id="kobo.7.1">ActivatorUtilities</span></kbd><span class="koboSpan" id="kobo.8.1"> class, and the </span><kbd><span class="koboSpan" id="kobo.9.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.10.1"> container</span></li>
<li><span class="koboSpan" id="kobo.11.1">Later on, we'll see some demos related to the implementation of an object's lifetime and how to map interfaces to instance classes, as well as a brief reminder of some more aspects of the Scope when applied to services</span></li>
<li><span class="koboSpan" id="kobo.12.1">Finally, we'll see how this DI functionality is also implemented inside some .NET Core services, especially those related to logging with plenty of demos showing how to use it in pure .NET Core</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The main characteristics of .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We've explained the basics of the architecture proposal of .NET Core in </span><a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.3.1">Chapter 1</span></span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">The SOLID Principles of Software Design</span></em><span class="koboSpan" id="kobo.6.1"> and how it pretends to be a game-changer, since it offers the possibility of creating code in the same language (C# or VB.NET), capable of executing on any device or platform.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.7.1">Please note that VB.NET support of new features always goes behind the advances you'll see in the C# language, so, in case you try some new feature using this language, you should make sure that it has been implemented for the version we're using in this book.</span></div>
<p><span class="koboSpan" id="kobo.8.1">This capability also extends to mobile applications, thanks to the incorporation of the Xamarin environment (and IDE) to the set of tools related to .NET Core development.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The main advantages of .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If we look at this framework from a more developer-like point of view, we could say that what makes .NET Core different from other choices can be summarized in the following points:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Cross-platform:</span></strong><span class="koboSpan" id="kobo.4.1"> This means execution on Windows, macOS and Linux, and also its portability to other operating systems. </span><span class="koboSpan" id="kobo.4.2">You can check the list of supported operating systems on various sites, such as </span><span class="URLPACKT"><a href="https://github.com/dotnet/core/blob/master/roadmap.md"><span class="koboSpan" id="kobo.5.1">https://github.com/dotnet/core/blob/master/roadmap.md</span></a></span><span class="koboSpan" id="kobo.6.1">, and you should bear in mind that CPUs and application scenarios will keep growing, whether they are provided by Microsoft or other companies.</span></li>
<li><strong><span class="koboSpan" id="kobo.7.1">Compatibility:</span></strong><span class="koboSpan" id="kobo.8.1"> .NET Core is not only compatible with the .NET Framework, but also with Xamarin and Mono, thanks to the .NET Standard Library. </span><span class="koboSpan" id="kobo.8.2">As the official documentation states, the .NET Standard Library is,</span></li>
</ul>
<div class="packt_quote"><span class="koboSpan" id="kobo.9.1">"a formal specification of .NET APIs that are intended to be available on all .NET runtimes. </span><span class="koboSpan" id="kobo.9.2">The motivation behind the Standard Library is establishing greater uniformity in the .NET ecosystem. </span><span class="koboSpan" id="kobo.9.3">ECMA 335 continues to establish uniformity for .NET runtime behavior, but there is no similar spec for the .NET Base Class Libraries (BCL) for .NET library implementations."</span></div>
<ul>
<li><strong><span class="koboSpan" id="kobo.10.1">Deployment:</span></strong><span class="koboSpan" id="kobo.11.1"> Perhaps the most interesting feature about runtime is that it can be deployed inside an application or installed in a side-by-side user-or machine-wide basis</span></li>
<li><strong><span class="koboSpan" id="kobo.12.1">Distinct command-line options:</span></strong><span class="koboSpan" id="kobo.13.1"> All distinct scenarios can be used at the command-line tools (and that's extensible to the rest of the platforms)</span></li>
<li><strong><span class="koboSpan" id="kobo.14.1">Open source:</span></strong><span class="koboSpan" id="kobo.15.1"> The .NET Core platform is open source, since its inception. </span><span class="koboSpan" id="kobo.15.2">It uses MIT and Apache 2 licenses, and the documentation is licensed under Creative Commons 4.0 (CC-BY, see </span><a href="https://creativecommons.org/licenses/by/4.0/"><span class="URLPACKT"><span class="koboSpan" id="kobo.16.1">https://creativecommons.org/licenses/by/4.0/</span></span></a><span class="koboSpan" id="kobo.17.1">). </span><span class="koboSpan" id="kobo.17.2">Besides that, .NET Core is a .NET Foundation (</span><a href="http://www.dotnetfoundation.org/"><span class="URLPACKT"><span class="koboSpan" id="kobo.18.1">http://www.dotnetfoundation.org/</span></span></a><span class="koboSpan" id="kobo.19.1">) project</span></li>
<li><strong><span class="koboSpan" id="kobo.20.1">Microsoft's support:</span></strong><span class="koboSpan" id="kobo.21.1"> .NET Core is completely supported by Microsoft, and you'll find plenty of documentation, videos, forums, and so on in promotion sites that the company usually encourages as it is indicated in .NET Core Support (</span><a href="https://www.microsoft.com/net/core/support/"><span class="URLPACKT"><span class="koboSpan" id="kobo.22.1">https://www.microsoft.com/net/core/support/</span></span></a><span class="koboSpan" id="kobo.23.1">)</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installation of .NET Core in the IDE</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 1</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">The SOLID Principles of Software Design</span></em><span class="koboSpan" id="kobo.6.1">, we mentioned that you could use .NET Core (and ASP.NET Core) with any IDE of your choice. </span><span class="koboSpan" id="kobo.6.2">However, in this book, I'm using Visual Studio 2017 due to its integration tools and facilities, and its degree of optimization for .NET Core projects.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Nevertheless, and due to its youth, there's no common installation path for all versions of Visual Studio and, depending on the one you use, you'll find two different approaches.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installation path for .NET Core in Visual Studio 2015</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If you want to use Visual Studio 2015, you should have Update 3.3 installed. </span><span class="koboSpan" id="kobo.2.2">It's available from this link: </span><a href="https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs</span></span></a><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">In this site, you'll see how the update is related to NET Core 1.0.0 and .NET Core 1.0.0 SDK Preview 2.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.5.1">If you're not sure about this version, just check the </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">About Microsoft Visual Studio</span></span><span class="koboSpan" id="kobo.7.1"> in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.8.1">Help</span></span><span class="koboSpan" id="kobo.9.1"> menu and make sure the version number is </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">14.0.25424.00</span></span><span class="koboSpan" id="kobo.11.1"> or higher, and includes Update 3.</span></div>
<p><span class="koboSpan" id="kobo.12.1">You'll also need:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">The </span><strong><span class="koboSpan" id="kobo.14.1">NuGet Manager</span></strong><span class="koboSpan" id="kobo.15.1"> extension for Visual Studio (you know, NuGet is the official package manager for Microsoft development, and we can be sure that it includes .NET Core in all its versions). </span><span class="koboSpan" id="kobo.15.2">You need NuGet 3.5.0-beta or higher to build .NET Core apps.</span></li>
<li><span class="koboSpan" id="kobo.16.1">.</span><strong><span class="koboSpan" id="kobo.17.1">NET Core Tooling Preview 2+</span></strong><span class="koboSpan" id="kobo.18.1">, which takes care of project templates and other tools for Visual Studio 2015, and you can find it at </span><a href="https://go.microsoft.com/fwlink/?LinkID=827546"><span class="URLPACKT"><span class="koboSpan" id="kobo.19.1">https://go.microsoft.com/fwlink/?LinkID=827546</span></span></a><span class="koboSpan" id="kobo.20.1">.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">.NET Core in Visual Studio 2017</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The case for Visual Studio 2017 is quite different, since it takes care of the installation of prerequisites, as long as you have selected the .NET Core and Docker workload during the initial installation process (remember that, in V. </span><span class="koboSpan" id="kobo.2.2">Studio 2017, installation is made in a modular fashion, so, by default, it only installs a minimum set of features).</span></p>
<p><span class="koboSpan" id="kobo.3.1">As it happens in the previous case, if you want to make sure about the installed version, just check in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.4.1">Help/About Visual Studio</span></span><span class="koboSpan" id="kobo.5.1"> menu, and see if you have version </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">15.0.26020.0</span></span><span class="koboSpan" id="kobo.7.1"> or higher.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of deployment</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We've mentioned how .NET Core allows using two distinct kinds of deployment for your apps--</span><strong><span class="koboSpan" id="kobo.3.1">Framework Dependent Deployment</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">FDD</span></strong><span class="koboSpan" id="kobo.6.1">), and </span><strong><span class="koboSpan" id="kobo.7.1">Self-Contained Deployment (SCD).</span></strong><span class="koboSpan" id="kobo.8.1"> Which one to choose? </span><span class="koboSpan" id="kobo.8.2">That will depend on the target system and the amount of knowledge and management control that we might have about it.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's briefly remind ourselves about the main differences between these two types of deployment and its implications facing the management and structure of the assemblies resulted from any .NET Core compilation process:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Framework Dependent relies on a shared version of .NET Core that should be installed on the target system. </span><span class="koboSpan" id="kobo.10.2">If this is the case, the application is portable between installations of .NET Core.</span></li>
<li><span class="koboSpan" id="kobo.11.1">Notice that, in this case, the app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries. </span><span class="koboSpan" id="kobo.11.2">This is because FDDs contain </span><kbd><span class="koboSpan" id="kobo.12.1">.dll</span></kbd><span class="koboSpan" id="kobo.13.1"> files that can be launched by means of the </span><kbd><span class="koboSpan" id="kobo.14.1">dotnet</span></kbd><span class="koboSpan" id="kobo.15.1"> utility from the command line. </span><span class="koboSpan" id="kobo.15.2">Remember that if you launch, for example, the command </span><kbd><span class="koboSpan" id="kobo.16.1">dotnet</span></kbd><kbd><span class="koboSpan" id="kobo.17.1">application1.dll</span></kbd><span class="koboSpan" id="kobo.18.1">, that's enough to run an application named </span><kbd><span class="koboSpan" id="kobo.19.1">application1.dll</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></li>
<li><span class="koboSpan" id="kobo.21.1">On the other side, SCD apps don't rely on any external code installed on the destination system. </span><span class="koboSpan" id="kobo.21.2">That is, all components, (and that includes both .NET Core libraries and the .NET Core runtime), are included in the final, installable package, and are isolated from other .NET Core applications.</span></li>
<li><span class="koboSpan" id="kobo.22.1">Consequently, SCDs include an executable (something like </span><kbd><span class="koboSpan" id="kobo.23.1">app1.exe</span></kbd><span class="koboSpan" id="kobo.24.1"> on Windows platforms for an app of that name). </span><span class="koboSpan" id="kobo.24.2">This is a renamed version of the platform-specific .NET Core host, and a DLL file (such as </span><kbd><span class="koboSpan" id="kobo.25.1">app.dll</span></kbd><span class="koboSpan" id="kobo.26.1">), which is the actual application.</span></li>
<li><span class="koboSpan" id="kobo.27.1">So, you're deploying a concrete version of .NET Core as the executable together with your application, that will always adopt the form of a DLL, and it will run inside the context created by the executable.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">As you can see, it is a very different approach, and perhaps, the first time that we can generate totally independent executable applications with .NET.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Checking other dependencies in .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before we keep on walking through the .NET Core features, it is wise to keep in mind that dependency is not only a matter of classes' relations but also about the components used to build applications, and the IDE might help us when defining and visually analyzing those dependencies even when the application is already compiled.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This is especially important in a framework where these components, are always downloaded from NuGet (or any other valid repository) and updated in our projects within Visual Studio 2017 in a dynamic manner.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Not taking care of these aspects, might lead to several problems. </span><span class="koboSpan" id="kobo.4.2">Among them, I'd like to highlight the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Maintainability issues</span></li>
<li><span class="koboSpan" id="kobo.6.1">Security flaws</span></li>
<li><span class="koboSpan" id="kobo.7.1">License misuse</span></li>
<li><span class="koboSpan" id="kobo.8.1">Unwanted dependencies</span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">In order to help developers to prevent dependency's issues, from version 2010 of Visual Studio, the IDE offers the ability to create layer diagrams, which have evolved continuously since that version.</span></p>
<p><span class="koboSpan" id="kobo.10.1">With these diagrams, you can express dependencies between layers, and these dependencies are not just shown through the diagrams hints but, starting in the latest version (2017), in the code itself.</span></p>
<p><span class="koboSpan" id="kobo.11.1">When you design one of these diagrams, you can express dependencies using symbols provided by the designer that include single and bi-directional dependency, layers, and simple shapes, as you can see in the following screenshot:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img class=" image-border" src="assets/2a19ce2c-cefb-4ede-b3ed-6e210595a7a9.png"/></span></div>
<p><span class="koboSpan" id="kobo.13.1">This diagram is created using the new menu option related to the </span><span class="packt_screen"><span class="koboSpan" id="kobo.14.1">Architecture</span></span><span class="koboSpan" id="kobo.15.1"> menu in the IDE, which also presents some features related to code analysis, such as Code Map generation, the possibility to create graphs of those external files (graph of </span><kbd><span class="koboSpan" id="kobo.16.1">Include Files</span></kbd><span class="koboSpan" id="kobo.17.1">), and other features. </span><span class="koboSpan" id="kobo.17.2">In all, that option presents the following options:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img height="146" width="381" class=" image-border" src="assets/331d0368-7f23-41b6-918c-c77efcda6d18.png"/></span></div>
<div class="packt_infobox packt_tip"><span><span class="koboSpan" id="kobo.19.1">Remember that this </span><span class="packt_screen"><span class="koboSpan" id="kobo.20.1">Architecture</span></span><span class="koboSpan" id="kobo.21.1"> menu is only available in V.Studio 2017 Enterprise.</span></span></div>
<p><span class="koboSpan" id="kobo.22.1">One of this menu's options is the new Dependency Validation diagram, which launches a new editing window, where we can drag and drop elements from the solution, including folders, files (C# and VB.NET) and even assemblies. </span><span class="koboSpan" id="kobo.22.2">We could consider these features as other implementations that the IDE offers to study any applications' dependencies.</span></p>
<p><span class="koboSpan" id="kobo.23.1">This technique, has been rebuilt from scratch using Roslyn (refer my book </span><em><span class="koboSpan" id="kobo.24.1">Mastering C# and .NET Framework</span></em><span class="koboSpan" id="kobo.25.1"> also by Pack, for more details and demos about this feature), and it allows the coder to configure the editor's behavior in a totally customized manner, programming how the IDE should respond when encountering any of these features in code (or even in other assemblies, since the tool accepts drag and drop already-compiled pieces too).</span></p>
<p><span class="koboSpan" id="kobo.26.1">Once you establish relations and dependencies in the diagram, this new Intellisense will be able to validate the existing code, advising the programmer about the conflicting areas inside different application domains.</span></p>
<p><span class="koboSpan" id="kobo.27.1">Actually, you can activate these features in the configuration in a such a way, that, as soon as a problem is detected, you will see a squiggle highlighting your offending code, together with an indication of the root of the problem.</span></p>
<p><span class="koboSpan" id="kobo.28.1">For instance, we can establish which classes are allowed to live in every application's namespace. </span><span class="koboSpan" id="kobo.28.2">If a single class is moved to a namespace forbidden by the dependency diagram, a hint will be presented in the code editor itself and, also, in the Error List window (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.29.1"><img class=" image-border" src="assets/84aa0679-a0fb-4a0d-8f76-410e81044608.png"/></span></div>
<p><span class="koboSpan" id="kobo.30.1">Of course, this behavior is also configurable, and these features are independent from other options we find in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.31.1">Analyze</span></span><span class="koboSpan" id="kobo.32.1"> menu in relation with </span><span class="packt_screen"><span class="koboSpan" id="kobo.33.1">Code Metrics</span></span><span class="koboSpan" id="kobo.34.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.35.1">Performance Profilers</span></span><span class="koboSpan" id="kobo.36.1">, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When dealing with the proper features related to Dependency Injection in .NET Core, there are a bunch of previous approaches to consider. </span><span class="koboSpan" id="kobo.2.2">One of those is the mantra </span><kbd><span class="koboSpan" id="kobo.3.1">new</span></kbd><span class="koboSpan" id="kobo.4.1"> is glue, which we often hear as an advice.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This means that whenever you create a new instance of a class (you use the </span><kbd><span class="koboSpan" id="kobo.6.1">new</span></kbd><span class="koboSpan" id="kobo.7.1"> keyword), there's some code cohesion behind the scenes. </span><span class="koboSpan" id="kobo.7.2">You're establishing that the class that defines that instance is going to have a dependency on the instantiated class.</span></p>
<p><span class="koboSpan" id="kobo.8.1">We've seen how to get rid of that problem via factories, or using third-party libraries focused on the DI problem and how they can be used, but, in this chapter, we're going to rely on those features provided by the framework itself to achieve the same results.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Ideally, that's something that we could define and, once the definition is registered, every time we need an instance of any of the predefined classes, something else should take care of providing that instance.</span></p>
<p><span class="koboSpan" id="kobo.10.1">In other words, the behavior we've seen related to other DI containers should (more or less) be present here as well, and cover the most important features that those veteran containers offer, including an object's lifetime, registration, and definition of generic classes and interfaces, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DI Architecture and Object's Lifetime</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Considering the preceding points, and even knowing that we're dealing with an initial version of the frameworks, the .NET Core team designed Dependency Injection features based on two ideas:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">On one side, there was already existing functionality, that could be perfectly extended to work inside .NET Core</span></li>
<li><span class="koboSpan" id="kobo.4.1">On the other side, they thought that it would be wise to include the most used features present in other initiatives, (either Microsoft's or external) like those present in Prism Patterns &amp; Practices or third party DI Containers (remember the four containers we saw in previous chapters)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.5.1">Consequently (following these ideas), when dealing with an object's lifetime, .NET Core presents three types, depending on the way instances will be configured and used--Singleton, Scoped, and Transient.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">These options do not only have influence in the way we define them, but also in the way we can use them, and in some cases, thread safe precautions, and other aspects should be considered.</span></li>
<li><span class="koboSpan" id="kobo.7.1">In the Singleton option, a unique instance of the object is used (meaning that we only manage a reference to the object). </span><span class="koboSpan" id="kobo.7.2">Any further request uses the same instance, according to the singleton pattern.</span></li>
<li><span class="koboSpan" id="kobo.8.1">The Scoped version is local to the context in which it is used and doesn't extend beyond that context.</span></li>
<li><span class="koboSpan" id="kobo.9.1">Finally, the Transient option creates a new instance of the class every time is requested.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">Although included in the ASP.NET Core documentation, Microsoft provides the following diagram in relation to these options:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="195" width="391" class=" image-border" src="assets/f55299db-672f-4987-ac1d-d401ea3d01b2.png"/></span></div>
<p><span class="koboSpan" id="kobo.12.1">Since, in the real world, this functionality is mainly linked to ASP.NET Core apps, services and middleware show up with functionality that helps in the task (that's why those references are to the </span><em><span class="koboSpan" id="kobo.13.1">request</span></em><span class="koboSpan" id="kobo.14.1">). </span><span class="koboSpan" id="kobo.14.2">But it actually works equally well in pure .NET Core applications.</span></p>
<p><span class="koboSpan" id="kobo.15.1">As we mentioned at the beginning, a big part of this functionality is related to the </span><kbd><span class="koboSpan" id="kobo.16.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.17.1"> namespace, included in a DLL of the same name, which can work in conjunction with another helper DLLs such as </span><kbd><span class="koboSpan" id="kobo.18.1">Microsoft.Extensions.DependencyInjection.Abstractions</span></kbd><span class="koboSpan" id="kobo.19.1"> and others.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Concretely, the </span><kbd><span class="koboSpan" id="kobo.21.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.22.1"> interface is the base of a set of classes that provide methods to instantiate objects (usually called services in this context) via DI using these three options. </span><span class="koboSpan" id="kobo.22.2">We'll see this in action in the next sections, but also in </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></a><span class="koboSpan" id="kobo.24.1">, </span><em><span class="koboSpan" id="kobo.25.1">Dependency Injection in ASP.NET Core,</span></em><span class="koboSpan" id="kobo.26.1"> dedicated to ASP.NET Core.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The class ActivatorUtilities and other helpers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before we get into the demos, keep in mind that the number of classes included in this namespace is pretty large, since it pretends to offer a wide coverage while still being multi-platform.</span></p>
<p><span class="koboSpan" id="kobo.3.1">One of these cases is the class </span><kbd><span class="koboSpan" id="kobo.4.1">ActivatorUtilities</span></kbd><span class="koboSpan" id="kobo.5.1"> class, also included in the </span><kbd><span class="koboSpan" id="kobo.6.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.7.1"> library, which contains static methods to help in the configuration and implementation of services, instances, and factories that ease DI management and control.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Thus, in case you find yourself missing some feature or functionality, take a look at the documentation at </span><a href="http://docs.microsoft.com"><span class="URLPACKT"><span class="koboSpan" id="kobo.9.1">http://docs.microsoft.com</span></span></a><span class="koboSpan" id="kobo.10.1">, but, keep in mind that you'll find that it is related to ASP.NET Core.</span></p>
<p><span class="koboSpan" id="kobo.11.1">This means that most of the implementations that you will see (on the internet and other sources) are not going to be linked to .NET Core apps, but to ASP.NET Core apps, in which, much of this functionality is implemented by default for different scenarios.</span></p>
<p><span class="koboSpan" id="kobo.12.1">Obviously, there's much more inside those classes that we cannot cover in a single chapter.</span></p>
<p><span class="koboSpan" id="kobo.13.1">To give you an idea of the possibilities linked to this class, I'm including a summary of its functionality presented in the official documentation, reminding you of each method and its main purpose:</span></p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong><span class="koboSpan" id="kobo.14.1">Methods summary</span></strong></p>
</td>
<td>
<p><strong><span class="koboSpan" id="kobo.15.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateFactory_System_Type_System_Type___"><span class="koboSpan" id="kobo.16.1">CreateFactory(Type, Type[])</span></a></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.17.1">Create a delegate that will instantiate a type with constructor arguments provided directly and/or from a </span><kbd><span class="koboSpan" id="kobo.18.1">System.IServiceProvider</span></kbd><span class="koboSpan" id="kobo.19.1">.</span></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance_System_IServiceProvider_System_Type_System_Object___"><span class="koboSpan" id="kobo.20.1">CreateInstance(IServiceProvider, Type, Object[])</span></a></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.21.1">Instantiate a type with constructor arguments provided directly and/or from a </span><kbd><span class="koboSpan" id="kobo.22.1">System.IServiceProvider</span></kbd><span class="koboSpan" id="kobo.23.1">.</span></p>
</td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.24.1">&lt;p&gt;</span><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance__1_System_IServiceProvider_System_Object___"><span class="koboSpan" id="kobo.25.1">CreateInstance&lt;T&gt;(IServiceProvider, Object[])</span></a></td>
<td>
<p><span class="koboSpan" id="kobo.26.1">Instantiate a type with constructor arguments provided directly and/or from a </span><kbd><span class="koboSpan" id="kobo.27.1">System.IServiceProvider</span></kbd><span class="koboSpan" id="kobo.28.1">.</span></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance_System_IServiceProvider_System_Type_"><span class="koboSpan" id="kobo.29.1">GetServiceOrCreateInstance(IServiceProvider, Type)</span></a></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.30.1">Retrieve an instance of the given type from the service provider. </span><span class="koboSpan" id="kobo.30.2">If one is not found, then instantiate it directly.</span></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance__1_System_IServiceProvider_"><span class="koboSpan" id="kobo.31.1">GetServiceOrCreateInstance&lt;T&gt;(IServiceProvider)</span></a></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.32.1">Retrieve an instance of the given type from the service provider. </span><span class="koboSpan" id="kobo.32.2">If one is not found, then instantiate it directly.</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.33.1"> </span></p>
<p><span class="koboSpan" id="kobo.34.1">It's now time to start working with the main classes related to DI inside the </span><kbd><strong><span class="koboSpan" id="kobo.35.1">Microsoft.Extensions.DependencyInjection</span></strong></kbd><span class="koboSpan" id="kobo.36.1"> and </span><kbd><strong><span class="koboSpan" id="kobo.37.1">Microsoft.Extensions.DependencyInjection.Abstractions</span></strong></kbd><span class="koboSpan" id="kobo.38.1"> libraries.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Microsoft.Extensions.DependencyInjection container</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Most of the samples that you'll see on the internet about Dependency Injection and .NET Core will reference to ASP.NET Core applications since it comes by default when you use the predefined template inside Visual Studio.</span></p>
<p><span class="koboSpan" id="kobo.3.1">However, the use of ASP.NET Core applications is not mandatory if you want to see how DI works from scratch. </span><span class="koboSpan" id="kobo.3.2">That being said, we will have to configure the registering of our services manually. </span><span class="koboSpan" id="kobo.3.3">This implies certain extra aspects such as severity levels, an object's lifetime, and disposable features if we want this architecture to work seamlessly.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Since .NET Core offers its own container linked to the external library </span><kbd><span class="koboSpan" id="kobo.5.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.6.1"> (now, in version 2.0), we'll have to reference it via NuGet packages.</span></p>
<p><span class="koboSpan" id="kobo.7.1">For a first demo, we can create a simple .NET Core Console application, reference the library using the NuGet package plug-in, and look for its name online. </span><span class="koboSpan" id="kobo.7.2">You'll observe that when you filter for that name, the </span><span class="packt_screen"><span class="koboSpan" id="kobo.8.1">NuGet Package Manager</span></span><span class="koboSpan" id="kobo.9.1">, presents several versions of the library (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img class=" image-border" src="assets/b65efcfb-babb-4daf-81f2-c70983dd38e3.png"/></span></div>
<p><span class="koboSpan" id="kobo.11.1">As you see, other libraries are also declared as complementary (</span><kbd><span class="koboSpan" id="kobo.12.1">Microsoft.Extensions.DependencyInjection.Abstractions</span></kbd><span class="koboSpan" id="kobo.13.1">, and </span><kbd><span class="koboSpan" id="kobo.14.1">Microsoft.Extensions.DependencyInjection.Specification.Tests</span></kbd><span class="koboSpan" id="kobo.15.1">). </span><span class="koboSpan" id="kobo.15.2">The first one (the </span><kbd><span class="koboSpan" id="kobo.16.1">Abstractions</span></kbd><span class="koboSpan" id="kobo.17.1">) should also appear as referenced inside our project once the installation is completed. </span><span class="koboSpan" id="kobo.17.2">But for now, let's focus on the main library.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.18.1">At this moment, don't be scared of the following dialog box. </span><span class="koboSpan" id="kobo.18.2">It will tell you that a whole bunch of libraries is going to be updated, and another set of libraries will be installed anew. </span><span class="koboSpan" id="kobo.18.3">The reason for this might be double--on one side, the use of the latest versions of this library implies updating other previously referenced libraries according to an internal library dependency manager that Visual Studio 2017 uses.</span><br/><span class="koboSpan" id="kobo.19.1">
On the other side, installation of some new libraries, like this one, might imply other dependencies, so we end up with two distinct areas of updates (go to the </span><span class="packt_screen"><span class="koboSpan" id="kobo.20.1">Dependencies</span></span><span class="koboSpan" id="kobo.21.1"> section in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.22.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.23.1"> after installation).</span></div>
<p><span class="koboSpan" id="kobo.24.1">Visual Studio 2017 will offer a list of every library being updated and if you scroll down a bit, also the list of all the dependent libraries:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.25.1"><img height="309" width="341" class=" image-border" src="assets/b5e0f7ef-5266-4279-b903-81b9dde13c74.png"/></span></div>
<p><span class="koboSpan" id="kobo.26.1">After this dialog box, you'll be presented another one with the </span><span class="packt_screen"><span class="koboSpan" id="kobo.27.1">License Acceptance</span></span><span class="koboSpan" id="kobo.28.1"> of each one of the libraries. </span><span class="koboSpan" id="kobo.28.2">Once completed, another entry in your </span><span class="packt_screen"><span class="koboSpan" id="kobo.29.1">Dependencies</span></span><span class="koboSpan" id="kobo.30.1"> section of the </span><span class="packt_screen"><span class="koboSpan" id="kobo.31.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.32.1"> will show up, pointing to NuGet. </span><span class="koboSpan" id="kobo.32.2">That's where you'll find all that new stuff.</span></p>
<p><span class="koboSpan" id="kobo.33.1">A further look at those new entries will reveal all the main and dependent libraries linked to that </span><span class="packt_screen"><span class="koboSpan" id="kobo.34.1">DependencyInjection</span></span><span class="koboSpan" id="kobo.35.1"> reference, which might be a few.</span></p>
<p><span class="koboSpan" id="kobo.36.1">Since, initially, we just want to make a test of how this namespace works, we'll start testing it in a very simple manner (Legit is to say that I was inspired by Jurgen Gustch's blog's entry Using Dependency Injection in .NET Core Console Apps, because, for this initial approach, I found it especially suitable and explanatory).</span></p>
<p><span class="koboSpan" id="kobo.37.1">So, I've modified those ideas to create a couple of classes, in which the first one happens to have dependencies on the other (that is, the first class references the second).</span></p>
<p><span class="koboSpan" id="kobo.38.1">Just for the matter of completeness, I included an extra method to check the right moment in which it was invoked, and also implemented the </span><kbd><span class="koboSpan" id="kobo.39.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.40.1"> interface to be able to convey information about disposal by the Garbage Collector (more about that later).</span></p>
<p><span class="koboSpan" id="kobo.41.1">So, I ended with this code (outside of the class </span><kbd><span class="koboSpan" id="kobo.42.1">Program</span></kbd><span class="koboSpan" id="kobo.43.1"> class that the template creates by default):</span></p>
<pre><span class="koboSpan" id="kobo.44.1">    public class DependencyClass1 : IDisposable 
    { 
      private readonly DependencyClass2 _DC2; 
      public DependencyClass1(DependencyClass2 DC2instance) 
      { 
        _DC2 = DC2instance; 
        Console.WriteLine("Constructor of DependencyClass1 finished"); 
      } 
      public void CurrentTime() 
      { 
        string time = DateTime.Now.Hour.ToString() + ":" + 
           DateTime.Now.Minute.ToString() + ":" + 
           DateTime.Now.Second.ToString(); 
        Console.WriteLine($"Current time: {time}"); 
      } 
      public void Dispose() 
      { 
        _DC2.Dispose(); 
        Console.WriteLine("DependencyClass1 disposed"); 
      } 
    } 
    public class DependencyClass2 : IDisposable 
    { 
      public DependencyClass2() 
      { 
        Console.WriteLine("Constructor of DependencyClass2 finished"); 
      } 
 
      public void Dispose() 
      { 
        Console.WriteLine("DependencyClass2 Disposed"); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.45.1">Notice also that </span><kbd><span class="koboSpan" id="kobo.46.1">DependencyClass1</span></kbd><span class="koboSpan" id="kobo.47.1"> takes care of disposing </span><kbd><span class="koboSpan" id="kobo.48.1">DependencyClass2</span></kbd><span class="koboSpan" id="kobo.49.1">, once it's done with it.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Now it comes when the </span><kbd><span class="koboSpan" id="kobo.51.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.52.1"> classes are needed. </span><span class="koboSpan" id="kobo.52.2">First, we make a reference to the corresponding namespace on top of our code (only two namespaces are required for this simple demo):</span></p>
<pre><span class="koboSpan" id="kobo.53.1">    using Microsoft.Extensions.DependencyInjection; 
    using System; </span></pre>
<p><span class="koboSpan" id="kobo.54.1">Then, inside the </span><kbd><span class="koboSpan" id="kobo.55.1">Program</span></kbd><span class="koboSpan" id="kobo.56.1"> class, we need to register and use these classes. </span><span class="koboSpan" id="kobo.56.2">The first step is performed using a new instance of the </span><kbd><span class="koboSpan" id="kobo.57.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.58.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.59.1">Inside that class, we find methods to register all required services in a way that at the same time, configures the object's lifetime mentioned previously, as you can see in the following screenshot:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.60.1"><img height="166" width="716" class=" image-border" src="assets/73ac9339-cc80-4532-b126-17912c57a125.png"/></span></div>
<p><span class="koboSpan" id="kobo.61.1">As we will see further on, we're provided with two versions of every method--generic and a non-generic. </span><span class="koboSpan" id="kobo.61.2">This gives us more flexibility to integrate different classes and services into our DI architecture.</span></p>
<p><span class="koboSpan" id="kobo.62.1">For this initial version, we're using the </span><kbd><span class="koboSpan" id="kobo.63.1">AddTransient</span></kbd><span class="koboSpan" id="kobo.64.1"> generic version of the methods, which will return new instances of every class, every time we make a reference in the code.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Once our classes are registered, a provider has to be built with that definition. </span><span class="koboSpan" id="kobo.65.2">That's something we perform with a call to </span><kbd><span class="koboSpan" id="kobo.66.1">BuildServiceProvider()</span></kbd><span class="koboSpan" id="kobo.67.1"> on the </span><kbd><span class="koboSpan" id="kobo.68.1">ServicesCollection</span></kbd><span class="koboSpan" id="kobo.69.1"> class just created (we'll go back to service providers later on). </span><span class="koboSpan" id="kobo.69.2">But, for now, suffice to say that an instance of the </span><kbd><span class="koboSpan" id="kobo.70.1">IServiceProvider</span></kbd><span class="koboSpan" id="kobo.71.1"> interface will be created and configured to manage any request for one of the classes previously registered using the </span><kbd><span class="koboSpan" id="kobo.72.1">Add*</span></kbd><span class="koboSpan" id="kobo.73.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.74.1">Another thing to point out is that the way objects are instantiated follows the lazy creation pattern that you, reader, which you might already know from other contexts, such as LINQ. </span><span class="koboSpan" id="kobo.74.2">That means until the first instance of a DI Object is requested, nothing gets created.</span></p>
<p><span class="koboSpan" id="kobo.75.1">So, even if we don't do anything (useful) with these classes, once the </span><kbd><span class="koboSpan" id="kobo.76.1">DependencyClass1</span></kbd><span class="koboSpan" id="kobo.77.1"> is requested, the entire dependency injection mechanism is started.</span></p>
<p><span class="koboSpan" id="kobo.78.1">The following code is modified in the class </span><kbd><span class="koboSpan" id="kobo.79.1">Program</span></kbd><span class="koboSpan" id="kobo.80.1"> class to configure this architecture:</span></p>
<pre><span class="koboSpan" id="kobo.81.1">    static void Main(string[] args) 
    { 
      Console.WriteLine("Dependency Injection Demo"); 
      Console.WriteLine("Basic use of the Microsoft.Extensions.</span><br/><span class="koboSpan" id="kobo.82.1">          DependencyInjection Library"); 
      Console.WriteLine("--------------------------------------</span><br/><span class="koboSpan" id="kobo.83.1">          ---------------------------"); 
      var services = new ServiceCollection(); 
      services.AddTransient&lt;DependencyClass2&gt;(); 
      services.AddTransient&lt;DependencyClass1&gt;(); 
      var provider = services.BuildServiceProvider(); 
      using (var DC1Instance = provider.GetService&lt;DependencyClass1&gt;()) 
      { 
        // Merely by declaring DC1Instance 
        // everything gets launched, but we also call 
        // CurrentTime() just to check functionality 
        DC1Instance.CurrentTime(); 
        // Notice also how classes are properly disposed 
        // after used. 
      </span><span class="koboSpan" id="kobo.83.2">} 
      Console.ReadLine(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.84.1">As you can see in the following output, everything works as expected:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.85.1"><img height="211" width="610" class=" image-border" src="assets/b31ea530-6e2e-4210-bb84-25a5dc0278c6.png"/></span></div>
<p><span class="koboSpan" id="kobo.86.1">The code shows how whenever we need an instance of a class, we issue a call to the generic </span><kbd><span class="koboSpan" id="kobo.87.1">GetService()</span></kbd><span class="koboSpan" id="kobo.88.1"> method and we can start using it in the next sentence.</span></p>
<p><span class="koboSpan" id="kobo.89.1">Another aspect to notice is that the reference to </span><kbd><span class="koboSpan" id="kobo.90.1">DependencyClass2</span></kbd><span class="koboSpan" id="kobo.91.1"> goes first, and so it does its disposal. </span><span class="koboSpan" id="kobo.91.2">Remember that the constructor of </span><kbd><span class="koboSpan" id="kobo.92.1">DependencyClass1</span></kbd><span class="koboSpan" id="kobo.93.1"> receives an instance of </span><kbd><span class="koboSpan" id="kobo.94.1">DependencyClass2</span></kbd><span class="koboSpan" id="kobo.95.1">, so, it doesn't finish until the latter is totally created.</span></p>
<p><span class="koboSpan" id="kobo.96.1">Also, before disposing of the first class, we call on </span><kbd><span class="koboSpan" id="kobo.97.1">Dispose</span></kbd><span class="koboSpan" id="kobo.98.1"> of the second, that's why the order is inverted.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Checking the object's lifetime</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another important aspect of this architecture that we should consider carefully, is the way our instances are obtained from the point of view of its lifetime. </span><span class="koboSpan" id="kobo.2.2">Let's see the differences in this very demo, adding references and changing the way they are registered into the </span><kbd><span class="koboSpan" id="kobo.3.1">IServiceProvider</span></kbd><span class="koboSpan" id="kobo.4.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.5.1">What happens if we create another instance of the first class? </span><span class="koboSpan" id="kobo.5.2">As expected, when we change the </span><kbd><span class="koboSpan" id="kobo.6.1">using</span></kbd><span class="koboSpan" id="kobo.7.1"> block of code to include another instance of </span><kbd><span class="koboSpan" id="kobo.8.1">DependencyClass1</span></kbd><span class="koboSpan" id="kobo.9.1">, such as in the following code:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    using (var DC1Instance = provider.</span><br/><span class="koboSpan" id="kobo.11.1">         GetService&lt;DependencyClass1&gt;()) 
    { 
      // Merely by declaring DependencyClass1  
      // everything gets launched, but we also call 
      // CurrentTime() just to check functionality 
      DC1Instance.CurrentTime(); 
      // Notice also how classes are properly disposed 
      // after used. 
      </span><span class="koboSpan" id="kobo.11.2">var DC1Instance2 = provider.GetService&lt;DependencyClass1&gt;(); 
      DC1Instance2.CurrentTime(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.12.1">The output changes noticeably since we're forcing the engine to create a new instance, instead of reusing the previous one:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="235" width="567" class=" image-border" src="assets/71199e7d-4332-42c9-8a8b-bdf7818bd845.png"/></span></div>
<p><span class="koboSpan" id="kobo.14.1">As seen in the preceding screenshot, we're making the DI engine call the constructor twice, because we're using the </span><kbd><span class="koboSpan" id="kobo.15.1">AddTransient()</span></kbd><span class="koboSpan" id="kobo.16.1"> version of the </span><kbd><span class="koboSpan" id="kobo.17.1">services</span></kbd><span class="koboSpan" id="kobo.18.1"> configuration object.</span></p>
<p><span class="koboSpan" id="kobo.19.1">However, in this scenario, if we change the registration method for </span><kbd><span class="koboSpan" id="kobo.20.1">AddScoped</span></kbd><span class="koboSpan" id="kobo.21.1"> of </span><kbd><span class="koboSpan" id="kobo.22.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.23.1">, we would be reusing the same instance of the objects, and therefore, saving memory and resources.</span></p>
<p><span class="koboSpan" id="kobo.24.1">For instance, by just changing those two lines of code in this manner:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">    services.AddScoped&lt;DependencyClass2&gt;(); 
    services.AddScoped&lt;DependencyClass1&gt;(); </span></pre>
<p><span class="koboSpan" id="kobo.26.1">We can check the different creation behavior with a simple look at the corresponding output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1"><img height="258" width="652" class=" image-border" src="assets/375fd621-ba77-41e2-93b5-ac9f6ca12f07.png"/></span></div>
<p><span class="koboSpan" id="kobo.28.1">As you can see, the </span><kbd><span class="koboSpan" id="kobo.29.1">CurrentTime</span></kbd><span class="koboSpan" id="kobo.30.1"> function is still called twice, but the number of instances in use is only one.</span></p>
<p><span class="koboSpan" id="kobo.31.1">And, in this case, we would get exactly the same output using the </span><kbd><span class="koboSpan" id="kobo.32.1">AddSingleton&lt;&gt;()</span></kbd><span class="koboSpan" id="kobo.33.1"> methods, since, in this scenario, there is a coincidence and no more than one instance is going to be used.</span></p>
<p><span class="koboSpan" id="kobo.34.1">Another interesting aspect of the functionality provided by this service is that being a generic collection itself, it is possible to add/remove/clear instances of services at runtime, so we can always have total control of what it is inside the collection and the order in which is defined and instantiated.</span></p>
<p><span class="koboSpan" id="kobo.35.1">To that purpose, we find methods such as </span><kbd><span class="koboSpan" id="kobo.36.1">Clear()</span></kbd><span class="koboSpan" id="kobo.37.1">, </span><kbd><span class="koboSpan" id="kobo.38.1">Contains()</span></kbd><span class="koboSpan" id="kobo.39.1">, </span><kbd><span class="koboSpan" id="kobo.40.1">IndexOf()</span></kbd><span class="koboSpan" id="kobo.41.1">, </span><kbd><span class="koboSpan" id="kobo.42.1">Insert()</span></kbd><span class="koboSpan" id="kobo.43.1">, </span><kbd><span class="koboSpan" id="kobo.44.1">InsertAt()</span></kbd><span class="koboSpan" id="kobo.45.1">, </span><kbd><span class="koboSpan" id="kobo.46.1">Remove</span></kbd><span class="koboSpan" id="kobo.47.1"> and </span><kbd><span class="koboSpan" id="kobo.48.1">RemoveAt()</span></kbd><span class="koboSpan" id="kobo.49.1">, just like we would find in any other generic collection.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Mapping interfaces to instance classes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The previous demo is simple enough to understand the basics of DI inside the </span><kbd><span class="koboSpan" id="kobo.3.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.4.1"> library, but, most likely, in a real application, you will have some interfaces defined and a series of classes that implement those interfaces.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In such a case, it is more convenient to be able to map interfaces to classes that implement them, so you just have to ask for an implementation of the corresponding interface, thinking on the functionality the interface provides (the business problem to be solved), rather than in the concrete class that implements it.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Another advantage is that we're able to change the definitions at runtime (remember, it's a collection where we can add/remove items), so it is perfectly possible to redefine any previous mapping to a new one, according to our applications' needs.</span></p>
<p><span class="koboSpan" id="kobo.7.1">As in the preceding demo, we're using a very simple approach to see this in action. </span><span class="koboSpan" id="kobo.7.2">I've created two interfaces, and two classes that implement them, with a single method that writes a basic message to the </span><kbd><span class="koboSpan" id="kobo.8.1">Console</span></kbd><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">This is the initial code:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    public interface IXMLWriter 
    { 
      void WriteXML(); 
    } 
    public interface IJSONWriter 
    { 
      void WriteJSON(); 
    } 
    public class XMLWriter : IXMLWriter 
    { 
      public void WriteXML() 
      { 
        Console.WriteLine("&lt;message&gt;Writing in XML Format&lt;/message&gt;"); 
      } 
    } 
    public class JSONWriter : IJSONWriter 
    { 
      public void WriteJSON() 
      { 
        Console.WriteLine("{'message': 'Writing in JSON Format'}"); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.11.1">There is a correspondence between classes and interfaces, so we can now refer to the interface and let the DI engine decide which class instance is returned to us. </span><span class="koboSpan" id="kobo.11.2">This is quite similar to the demos we saw in the previous chapter when using third-party DI containers.</span></p>
<p><span class="koboSpan" id="kobo.12.1">With that purpose, the </span><kbd><span class="koboSpan" id="kobo.13.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.14.1"> class supports an alternative way of defining references in which you can pass (generic signature) an interface name and the class that maps such interface when a </span><kbd><span class="koboSpan" id="kobo.15.1">GetService&lt;Interface&gt;()</span></kbd><span class="koboSpan" id="kobo.16.1"> is called.</span></p>
<p><span class="koboSpan" id="kobo.17.1">At the time of requesting one of these implementations, we will ask for an instance of the predefined interface, rather than a concrete class.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.18.1">Note that we also have an alternative way to ask for a service by means of the </span><kbd><span class="koboSpan" id="kobo.19.1">GetRequiredService&lt;Interface&gt;()</span></kbd><span class="koboSpan" id="kobo.20.1"> method, that throws an exception if the service type isn't registered.</span></div>
<p><span class="koboSpan" id="kobo.21.1">Assuming this change, the implementation of the demo is quite simple:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">    static void Main(string[] args) 
    { 
      var services = new ServiceCollection(); 
      services.AddTransient&lt;IXMLWriter, XMLWriter&gt;(); 
      services.AddTransient&lt;IJSONWriter, JSONWriter&gt;(); 
      var provider = services.BuildServiceProvider(); 
      Console.WriteLine("Dependency Injection Demo (2)"); 
      Console.WriteLine("Mapping Interfaces to instance classes"); 
      Console.WriteLine("--------------------------------------"); 
      Console.WriteLine("Please, select message format </span><br/><span class="koboSpan" id="kobo.23.1">          (1):XML // (2):JSON"); 
       var res = Console.ReadLine(); 
      if (res == "1") 
      { 
        var XMLInstance = provider.GetService&lt;IXMLWriter&gt;(); 
        XMLInstance.WriteXML(); 
      } 
      else 
      { 
         var JSONInstance = provider.GetService&lt;IJSONWriter&gt;(); 
         JSONInstance.WriteJSON(); 
      } 
      Console.ReadLine(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.24.1">Unlike the previous case, we don't ask for a given class, but the class implements the required interface.</span></p>
<p><span class="koboSpan" id="kobo.25.1">The output is, again, as expected (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="205" width="506" class=" image-border" src="assets/8eb2f516-7118-402d-a140-fc036cdb5850.png"/></span></div>
<p><span class="koboSpan" id="kobo.27.1">Notice that the registration works in a similar way to what we already saw in other DI containers. </span><span class="koboSpan" id="kobo.27.2">That is, if we use this syntax, that latest registered mapping is the one returned, although that can be changed dynamically.</span></p>
<p><span class="koboSpan" id="kobo.28.1">Another very useful feature is the </span><kbd><span class="koboSpan" id="kobo.29.1">GetServices&lt;Interface&gt;</span></kbd><span class="koboSpan" id="kobo.30.1"> method, since it allows us to recover all registered services and invoke them at will.</span></p>
<p><span class="koboSpan" id="kobo.31.1">We can prove this by adding a couple of new classes that implement the same interfaces and register them together with the previous ones:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">    public class XMLWriter2 : IXMLWriter 
    { 
      public void WriteXML() 
      { 
        Console.WriteLine("&lt;message&gt;Writing in XML Format (2)&lt;/message&gt;"); 
      } 
    } 
    public class JSONWriter2 : IJSONWriter 
    { 
      public void WriteJSON() 
      { 
        Console.WriteLine("{'message': 'Writing in JSON Format (2)'}"); 
      } 
   } </span></pre>
<p><span class="koboSpan" id="kobo.33.1">After these definitions, we register both classes under the same Interface contracts, so they can be accessed altogether:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">    services.AddTransient&lt;IXMLWriter, XMLWriter&gt;(); 
    services.AddTransient&lt;IXMLWriter, XMLWriter2&gt;(); 
    services.AddTransient&lt;IJSONWriter, JSONWriter&gt;(); 
    services.AddTransient&lt;IJSONWriter, JSONWriter2&gt;(); 
    Now we can use a whole collection by asking for it by means of the </span><br/><span class="koboSpan" id="kobo.35.1">       GetServices&lt;Interface&gt;() method that I mentioned above: 
    var registeredXMLServices = provider.GetServices&lt;IXMLWriter&gt;(); 
    foreach (var svc in registeredXMLServices) 
    { 
      svc.WriteXML(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.36.1">Since we're using the defined interface functionality, we know all of them will implement the </span><kbd><span class="koboSpan" id="kobo.37.1">WriteXML()</span></kbd><span class="koboSpan" id="kobo.38.1"> function, even if they do it differently.</span></p>
<p><span class="koboSpan" id="kobo.39.1">You can appreciate the different calls in the corresponding output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.40.1"><img height="165" width="449" class=" image-border" src="assets/bf46316e-d5cd-4b7f-ba67-9aa2e14c886d.png"/></span></div>
<p><span class="koboSpan" id="kobo.41.1">Another alternative way to get the whole list of services is, of course, from the </span><kbd><span class="koboSpan" id="kobo.42.1">services</span></kbd><span class="koboSpan" id="kobo.43.1"> collection itself. </span><span class="koboSpan" id="kobo.43.2">To perform this, we need another helper class also provided by the </span><kbd><span class="koboSpan" id="kobo.44.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.45.1"> library.</span></p>
<p><span class="koboSpan" id="kobo.46.1">In this case, the procedure is to create a </span><kbd><span class="koboSpan" id="kobo.47.1">ServiceDescriptor</span></kbd><span class="koboSpan" id="kobo.48.1"> collection that holds the information of all services in our </span><kbd><span class="koboSpan" id="kobo.49.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.50.1"> class. </span><span class="koboSpan" id="kobo.50.2">We use an enumerator and the </span><kbd><span class="koboSpan" id="kobo.51.1">CopyTo()</span></kbd><span class="koboSpan" id="kobo.52.1"> method (which expects a </span><kbd><span class="koboSpan" id="kobo.53.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.54.1"> as the first argument) to create such a collection:</span></p>
<pre><span class="koboSpan" id="kobo.55.1">    var myServiceArray = new ServiceDescriptor[services.Count]; 
    // Copy the services into an array. 
    </span><span class="koboSpan" id="kobo.55.2">services.CopyTo(myServiceArray, 0); 
    IEnumerator myEnumerator = myServiceArray.GetEnumerator(); 
    Console.WriteLine("The Implementation Types in the array are"); 
    while (myEnumerator.MoveNext()) 
    { 
      var myService1 = (ServiceDescriptor)myEnumerator.Current; 
      Console.WriteLine(myService1.ImplementationType); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.56.1">When the collection is copied to the </span><kbd><span class="koboSpan" id="kobo.57.1">ServiceDescriptor</span></kbd><span class="koboSpan" id="kobo.58.1"> collection, we can see at least five interesting properties that might, later on, be used to determine the service we need in a given scenario:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.59.1"><img height="176" width="613" class=" image-border" src="assets/f6b2b26e-c182-48c3-8ab1-81c0b127b75e.png"/></span></div>
<p><span class="koboSpan" id="kobo.60.1">Notice that here we're asking for the </span><kbd><span class="koboSpan" id="kobo.61.1">ImplementationType</span></kbd><span class="koboSpan" id="kobo.62.1"> property to obtain all defined types:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.63.1"><img height="177" width="399" class=" image-border" src="assets/99b1f3a4-c3c8-418d-81de-acb1b0149376.png"/></span></div>
<p><span class="koboSpan" id="kobo.64.1">This gives us a clue on how to select a single service independently of its position in the collection. </span><span class="koboSpan" id="kobo.64.2">Another helper method linked to this functionality is the simple </span><kbd><span class="koboSpan" id="kobo.65.1">Contains()</span></kbd><span class="koboSpan" id="kobo.66.1"> that asks for a </span><kbd><span class="koboSpan" id="kobo.67.1">ServiceDescriptor</span></kbd><span class="koboSpan" id="kobo.68.1"> object as its unique argument.</span></p>
<p><span class="koboSpan" id="kobo.69.1">Another easy way to get information about the currently registered components in our services container is by iterating through it directly, using a simple </span><kbd><span class="koboSpan" id="kobo.70.1">foreach</span></kbd><span class="koboSpan" id="kobo.71.1"> loop:</span></p>
<pre><span class="koboSpan" id="kobo.72.1">    //Description of properties in the service collection  
    foreach (var svc in services) 
    { 
      Console.WriteLine($"Type: {svc.ImplementationType} \n" + 
         $"Lifetime: {svc.Lifetime} \n" + 
         $"Service Type: {svc.ServiceType}"); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.73.1">Notice that depending on the way the services are registered and other programming features, not all the properties will have a value (in this case, it only makes sense asking for the interfaces (</span><kbd><span class="koboSpan" id="kobo.74.1">ServiceType</span></kbd><span class="koboSpan" id="kobo.75.1">), the implementations (</span><kbd><span class="koboSpan" id="kobo.76.1">Types</span></kbd><span class="koboSpan" id="kobo.77.1">) and their lifetimes).</span></p>
<p><span class="koboSpan" id="kobo.78.1">This is also useful when we have more than a class that implements the same interface, because we can decide which one we need based on these values:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.79.1"><img height="294" width="413" class=" image-border" src="assets/76036b1f-e60a-49f7-b72d-93e854a66e4c.png"/></span></div>
<p><span class="koboSpan" id="kobo.80.1">Additionally, it's possible to use some helper classes linked to the namespaces here implied, to perform registrations </span><kbd><span class="koboSpan" id="kobo.81.1">a posteriori</span></kbd><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">For instance, the </span><kbd><span class="koboSpan" id="kobo.83.1">ServiceProviderServiceExtensions</span></kbd><span class="koboSpan" id="kobo.84.1"> class contains a static method capable of obtaining a given </span><kbd><span class="koboSpan" id="kobo.85.1">ServiceType</span></kbd><span class="koboSpan" id="kobo.86.1"> linked to a certain provider.</span></p>
<p><span class="koboSpan" id="kobo.87.1">In other words, you can get an instance of a registered service without using the </span><kbd><span class="koboSpan" id="kobo.88.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.89.1"> that registered it, as long as you can pass the corresponding provider as an argument.</span></p>
<p><span class="koboSpan" id="kobo.90.1">I've created a variant of the previous demo, this time including a read-only property in each of the </span><kbd><span class="koboSpan" id="kobo.91.1">*writer</span></kbd><span class="koboSpan" id="kobo.92.1"> classes to hold a unique identifier (a </span><kbd><span class="koboSpan" id="kobo.93.1">GUID</span></kbd><span class="koboSpan" id="kobo.94.1">), so it is easy to determine if we're using the same or another instance of the service.</span></p>
<p><span class="koboSpan" id="kobo.95.1">Consider the following code (a variant of the previous demo):</span></p>
<pre><span class="koboSpan" id="kobo.96.1">    static void Main(string[] args) 
    { 
      var services = new ServiceCollection(); 
      services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
      var provider = services.BuildServiceProvider(); 
      Console.WriteLine("Dependency Injection Demo (3)"); 
      Console.WriteLine("Choice between implementations"); 
      Console.WriteLine("------------------------------"); 
      // Instance via services class 
      var XMLInstance = provider.GetService&lt;IXMLWriter&gt;(); 
      XMLInstance.WriteXML(); 
      // Instance via ServiceProviderServiceExtensions 
      var XMLInstance2 = ServiceProviderServiceExtensions. 
                       </span><span class="koboSpan" id="kobo.96.2">GetService&lt;IXMLWriter&gt;(provider); 
      XMLInstance2.WriteXML();     
      Console.ReadLine(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.97.1">As you can see, we're using two distinct approaches to get the same instance (identified by its </span><kbd><span class="koboSpan" id="kobo.98.1">GUID</span></kbd><span class="koboSpan" id="kobo.99.1">). </span><span class="koboSpan" id="kobo.99.2">We can test it by comparing both outputs (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.100.1"><img height="203" width="452" class=" image-border" src="assets/76e66637-4315-42cd-b072-4ebfcd7403b3.png"/></span></div>
<p><span class="koboSpan" id="kobo.101.1">This could be especially useful in situations in which, for whatever reason, a call to services is not suitable or convenient.</span></p>
<p><span class="koboSpan" id="kobo.102.1">Providers can also be obtained via helper classes, besides the </span><kbd><span class="koboSpan" id="kobo.103.1">BuildServiceProvider</span></kbd><span class="koboSpan" id="kobo.104.1"> method of </span><kbd><span class="koboSpan" id="kobo.105.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.106.1">. </span><span class="koboSpan" id="kobo.106.2">To do so, we can use the </span><kbd><span class="koboSpan" id="kobo.107.1">CreateDefaultServiceProvider</span></kbd><span class="koboSpan" id="kobo.108.1"> class, which also has instance methods to create, either a provider or a </span><kbd><span class="koboSpan" id="kobo.109.1">Builder</span></kbd><span class="koboSpan" id="kobo.110.1">.</span></p>
<p><span class="koboSpan" id="kobo.111.1">For the time being, those two are the only possibilities available to that class, but it can also be quite useful in certain scenarios where we prefer the service collection not to be used:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.112.1"><img height="138" width="661" class=" image-border" src="assets/be316783-9b1c-4f05-af4f-579fb1b2ed8e.png"/></span></div>
<p><span class="koboSpan" id="kobo.113.1">The following code has the provider created via the </span><kbd><span class="koboSpan" id="kobo.114.1">DefaultServiceProvider</span></kbd><span class="koboSpan" id="kobo.115.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.116.1">    var services = new ServiceCollection(); 
    services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
    // Provider via DefaultServiceProviderFactory 
    var factory = new DefaultServiceProviderFactory(); 
    IServiceProvider prov = factory.CreateServiceProvider(services); 
    var XMLInstance = prov.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); </span></pre>
<p><span class="koboSpan" id="kobo.117.1">I omit the output here, since it's exactly the same as in the previous demos, and you can check it yourself within the code accompanying this chapter.</span></p>
<p><span class="koboSpan" id="kobo.118.1">This is not the only way in which we can obtain a service provider. </span><span class="koboSpan" id="kobo.118.2">Yes, there's another one, linked to the static method </span><kbd><span class="koboSpan" id="kobo.119.1">BuildServiceProvider</span></kbd><span class="koboSpan" id="kobo.120.1"> of the </span><kbd><span class="koboSpan" id="kobo.121.1">ServiceCollectionContainerBuilderExtensions</span></kbd><span class="koboSpan" id="kobo.122.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.123.1">In this case, programming it is even easier, since we don't need any instance of the class, and the code gets reduced to the following code:</span></p>
<pre><span class="koboSpan" id="kobo.124.1">    var services = new ServiceCollection(); 
    services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
    // Provider via ServiceCollectionContainerBuilderExtensions 
    IServiceProvider prov = ServiceCollectionContainerBuilderExtensions. 
        </span><span class="koboSpan" id="kobo.124.2">BuildServiceProvider(services); 
    var XMLInstance = prov.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); </span></pre>
<p><span class="koboSpan" id="kobo.125.1">Just to get exactly the same results as we did before (again, I omit the output).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The concept of Scope Applied to services</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When dealing with services and other DI-related functionality, an important point to define is its scope. </span><span class="koboSpan" id="kobo.2.2">DI documentation defines the scope of a service closely related to its lifetime, and therefore, with the moment in which that service should be disposed of by the Garbage Collector.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We have talked about the Transient and Singleton lifetimes previously, but the Scope lifetime is, indeed, a bit more confusing.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Concretely, the </span><kbd><span class="koboSpan" id="kobo.5.1">IServiceDispose</span></kbd><span class="koboSpan" id="kobo.6.1"> interface, which implements the </span><kbd><span class="koboSpan" id="kobo.7.1">IDispose</span></kbd><span class="koboSpan" id="kobo.8.1"> interface, holds the method </span><kbd><span class="koboSpan" id="kobo.9.1">Disposed of()</span></kbd><span class="koboSpan" id="kobo.10.1">, method which, when called, ends the scope lifetime. </span><span class="koboSpan" id="kobo.10.2">It is included inside the </span><kbd><span class="koboSpan" id="kobo.11.1">Microsoft.Extensions.DependencyInjection.Abstractions.dll</span></kbd><span class="koboSpan" id="kobo.12.1">.</span></p>
<p><span class="koboSpan" id="kobo.13.1">In more detail, the documentation states: "</span><em><span class="koboSpan" id="kobo.14.1">Once this is disposed of, any scoped services that have been resolved from the</span></em> <em><span class="koboSpan" id="kobo.15.1">M</span></em><em><span class="koboSpan" id="kobo.16.1">icrosoft.Extensions.DependencyInjection.IServiceScope.ServiceProvider will also be disposed of"</span></em><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Its declaration is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    public interface IServiceScope : IDisposable </span></pre>
<p><span class="koboSpan" id="kobo.20.1">If you remember in the first demos of this chapter, our </span><kbd><span class="koboSpan" id="kobo.21.1">DependencyClass1</span></kbd><span class="koboSpan" id="kobo.22.1"> and </span><kbd><span class="koboSpan" id="kobo.23.1">DependencyClass2</span></kbd><span class="koboSpan" id="kobo.24.1"> classes implemented the </span><kbd><span class="koboSpan" id="kobo.25.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.26.1"> interface, so we could call those methods after the classes' main operations were finished.</span></p>
<p><span class="koboSpan" id="kobo.27.1">As we'll see in </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.28.1">Chapter 4</span></a><span class="koboSpan" id="kobo.29.1">, </span><em><span class="koboSpan" id="kobo.30.1">Dependency Injection in ASP.NET Core,</span></em><span class="koboSpan" id="kobo.31.1"> this concept adapts especially well to some internet applications' scenarios in which it makes a lot of sense to have a specific control for the lifetime of some services, and always have access to the execution context in the form of an instance class.</span></p>
<p><span class="koboSpan" id="kobo.32.1">In </span><span class="ChapterrefPACKT"><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.33.1">Chapter 4</span></a><span class="koboSpan" id="kobo.34.1">,</span></span> <em><span class="koboSpan" id="kobo.35.1">Dependency Injection in ASP.NET Core</span></em><span class="koboSpan" id="kobo.36.1">, you'll see that this feature can be important to face performance issues, resources of the server, scalability issues, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other extensions with DI functionality</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Linked to the </span><kbd><span class="koboSpan" id="kobo.3.1">Microsoft.Extensions</span></kbd><span class="koboSpan" id="kobo.4.1"> global namespace, we find related namespaces that are becoming popular among developers, because they help in different areas of the application's lifecycle.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Two of the most used are </span><kbd><span class="koboSpan" id="kobo.6.1">Microsoft.Extensions.Logging</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">Microsoft.Extensions.Logging.Console</span></kbd><span class="koboSpan" id="kobo.9.1">, which you can use to configure and code logging services using the techniques of Dependency Injection that we've seen in this chapter. </span><span class="koboSpan" id="kobo.9.2">They offer functionality similar to other popular frameworks, such as Serilog, Log4Net or NLog.</span></p>
<p><span class="koboSpan" id="kobo.10.1">I'm talking about </span><kbd><span class="koboSpan" id="kobo.11.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.12.1"> and </span><kbd><span class="koboSpan" id="kobo.13.1">ILogger&lt;T&gt;</span></kbd><span class="koboSpan" id="kobo.14.1">, mainly used (especially in ASP.NET Core apps) to emit information at runtime, with the ability to redirect that information to different targets (console, output window, and so on).</span></p>
<p><span class="koboSpan" id="kobo.15.1">But they can also be used to monitor and debug applications in .NET Core, and, even not offering the whole set of resources we find in those, more specialized, frameworks, they can be, many times, enough to cover our needs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">A reflection on the structure of .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's quite interesting to see how .NET Core creators have designed this technology based on the Dependency Injection principles. </span><span class="koboSpan" id="kobo.2.2">That's why, besides its value as a tool for the developer, we can see the extra value of seeing DI really implemented by default in .NET Core libraries.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Both classes are available inside the </span><kbd><span class="koboSpan" id="kobo.4.1">Microsoft.Extensions.Logging</span></kbd><span class="koboSpan" id="kobo.5.1"> namespace, but other complementary namespaces, such as </span><kbd><span class="koboSpan" id="kobo.6.1">Microsoft.Extensions.Logging.Console</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">Microsoft.Extensions.Logging.Debug</span></kbd><span class="koboSpan" id="kobo.9.1">, also permit extended logging functionality that we'll use in the next demo. </span><span class="koboSpan" id="kobo.9.2">They can be easily referenced via NuGet packages, as we did before.</span></p>
<p><span class="koboSpan" id="kobo.10.1">To keep on demoing things with the simplest possible code, I'll use a simplified version of the previous demo, only this time using a single external class </span><kbd><span class="koboSpan" id="kobo.11.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.12.1"> and its corresponding interface, with slight changes.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Just like with the </span><kbd><span class="koboSpan" id="kobo.14.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.15.1"> namespace, </span><kbd><span class="koboSpan" id="kobo.16.1">Microsoft.Extensions.Logging</span></kbd><span class="koboSpan" id="kobo.17.1"> appears next to </span><kbd><span class="koboSpan" id="kobo.18.1">Configuration</span></kbd><span class="koboSpan" id="kobo.19.1"> and </span><kbd><span class="koboSpan" id="kobo.20.1">Dependency</span></kbd><span class="koboSpan" id="kobo.21.1"> libraries when filtering for this criterion in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.22.1">Search</span></span><span class="koboSpan" id="kobo.23.1"> box (notice that we'll need a total of four extra libraries, including </span><kbd><span class="koboSpan" id="kobo.24.1">Logging.Console</span></kbd><span class="koboSpan" id="kobo.25.1"> and </span><kbd><span class="koboSpan" id="kobo.26.1">Logging.Debug</span></kbd><span class="koboSpan" id="kobo.27.1">):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.28.1"><img height="294" width="660" class=" image-border" src="assets/1db817ef-3a61-47fd-a814-8191e9bc8896.png"/></span></div>
<p><span class="koboSpan" id="kobo.29.1">After installing those libraries, if you're curious about these API's possibilities, you can also inspect the references that will show up in the </span><kbd><span class="koboSpan" id="kobo.30.1">Solution Explorer</span></kbd><span class="koboSpan" id="kobo.31.1">, next to the NuGet references' entry.</span></p>
<p><span class="koboSpan" id="kobo.32.1">The functionality provided by these logging services include the ability to write to the </span><kbd><span class="koboSpan" id="kobo.33.1">Console</span></kbd><span class="koboSpan" id="kobo.34.1">, using distinct types of messages (depending on the nature of the output: debug, information, warning, or error) and using several colors and formats to express these categories.</span></p>
<p><span class="koboSpan" id="kobo.35.1">Mark Michaelis clearly explains in his MSDN article </span><em><span class="koboSpan" id="kobo.36.1">Essential .NET - Dependency Injection with .NET Core</span></em><span class="koboSpan" id="kobo.37.1"> some of the advantages of these DI implementations that we find linked to .NET Core.</span></p>
<p><span class="koboSpan" id="kobo.38.1">He points out that, when you want to switch between different implementations of some service and avoid hard-coding a reference to any service implementation, it is much more extensible and maintainable to ask for a factory of such instance, just like we did in other demos. </span><span class="koboSpan" id="kobo.38.2">The </span><kbd><span class="koboSpan" id="kobo.39.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.40.1"> implements that functionality.</span></p>
<p><span class="koboSpan" id="kobo.41.1">He goes even further, highlighting that: "</span><em><span class="koboSpan" id="kobo.42.1">you ask for an interface (such as ILoggerFactory</span></em><em><span class="koboSpan" id="kobo.43.1">) with the expectation that the service provider (in this case, NLog, Log4Net or Serilog) will implement the interface"</span></em><span class="koboSpan" id="kobo.44.1">.</span></p>
<p><span class="koboSpan" id="kobo.45.1">Thus, </span><kbd><span class="koboSpan" id="kobo.46.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.47.1"> is extensible even with third-party libraries! </span><span class="koboSpan" id="kobo.47.2">He also remarks that: "</span><em><span class="koboSpan" id="kobo.48.1">the result is that while the client will directly reference the abstract assembly (Logging.Abstractions), defining the service interface, no references to the direct implementation will be needed"</span></em><span class="koboSpan" id="kobo.49.1">.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Actually, you may have noticed that the </span><kbd><span class="koboSpan" id="kobo.51.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.52.1"> itself owns a method called </span><kbd><span class="koboSpan" id="kobo.53.1">AddLogging()</span></kbd><span class="koboSpan" id="kobo.54.1">, which is a convenient method to activate logging functionality for the collection. </span><span class="koboSpan" id="kobo.54.2">This call is really translated to an internal registry of the </span><kbd><span class="koboSpan" id="kobo.55.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.56.1"> service as part of the services collection we are configuring.</span></p>
<p><span class="koboSpan" id="kobo.57.1">Considering that we can also concatenate calls to configure our service collections, let's see the first part of our new </span><kbd><span class="koboSpan" id="kobo.58.1">Main()</span></kbd><span class="koboSpan" id="kobo.59.1"> method, including that call:</span></p>
<pre><span class="koboSpan" id="kobo.60.1">    // Enabling logging with the ServiceCollection 
    var services = new ServiceCollection() 
      .AddSingleton&lt;IXMLWriter, XMLWriter&gt;() 
      .AddLogging(); 
   var serviceProvider = services.BuildServiceProvider(); </span></pre>
<p><span class="koboSpan" id="kobo.61.1">Consequently, we enable logging inside the </span><kbd><span class="koboSpan" id="kobo.62.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.63.1"> via </span><kbd><span class="koboSpan" id="kobo.64.1">AddLogging()</span></kbd><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">So, what happened? </span><span class="koboSpan" id="kobo.65.3">Let's check the new members that our collection now has, by iterating through the resulting services object, like in a previous demo:</span></p>
<pre><span class="koboSpan" id="kobo.66.1">    // Test the register of AddLoggin() 
    foreach (var svc in services) 
   { 
      Console.WriteLine($"Type: {svc.ImplementationType} \n" + 
        $"Lifetime: {svc.Lifetime} \n" + 
        $"Service Type: {svc.ServiceType}"); 
   } </span></pre>
<p><span class="koboSpan" id="kobo.67.1">We'll obtain a collection containing three services (see the following output), because the </span><kbd><span class="koboSpan" id="kobo.68.1">AddLogging()</span></kbd><span class="koboSpan" id="kobo.69.1"> method has, indeed, registered a </span><kbd><span class="koboSpan" id="kobo.70.1">LoggingFactory</span></kbd><span class="koboSpan" id="kobo.71.1"> class with the </span><kbd><span class="koboSpan" id="kobo.72.1">ILoggingFactory</span></kbd><span class="koboSpan" id="kobo.73.1"> interface, and another generic one, </span><kbd><span class="koboSpan" id="kobo.74.1">ILogger&lt;&gt;</span></kbd><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">That </span><kbd><span class="koboSpan" id="kobo.76.1">ILogger&lt;&gt;</span></kbd><span class="koboSpan" id="kobo.77.1"> class will later be configured to provide any other class with the ability to send logging messages to the console:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.78.1"><img height="194" width="597" class=" image-border" src="assets/66c9e26a-bf30-486b-a816-6289e9dbd476.png"/></span></div>
<p><span class="koboSpan" id="kobo.79.1">Therefore, the next step is to obtain an </span><kbd><span class="koboSpan" id="kobo.80.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.81.1"> object and link that object to the </span><kbd><span class="koboSpan" id="kobo.82.1">Console</span></kbd><span class="koboSpan" id="kobo.83.1">, which we perform with a call to </span><kbd><span class="koboSpan" id="kobo.84.1">AddConsole()</span></kbd><span class="koboSpan" id="kobo.85.1"> in this fashion:</span></p>
<pre><span class="koboSpan" id="kobo.86.1">    //Obtain service and configure logging 
    serviceProvider.GetService&lt;ILoggerFactory&gt;() 
      .AddConsole(LogLevel.Debug); </span></pre>
<p><span class="koboSpan" id="kobo.87.1">As you see, </span><kbd><span class="koboSpan" id="kobo.88.1">AddConsole</span></kbd><span class="koboSpan" id="kobo.89.1"> expects some additional configuration in the form of an </span><kbd><span class="koboSpan" id="kobo.90.1">enum</span></kbd><span class="koboSpan" id="kobo.91.1"> value of type </span><kbd><span class="koboSpan" id="kobo.92.1">LogLevel</span></kbd><span class="koboSpan" id="kobo.93.1">, which determines the minimum level of severity the runtime will filter when sending messages to the console--whenever the logging system receives an entry, it will ignore it if it is below that level.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">LogLevels Severity</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">LogLevel</span></kbd><span class="koboSpan" id="kobo.4.1"> enumeration also establishes the priority of messages (pretty useful in case we want to distinguish low-level from high-level messages, and even redirect them to different output windows).</span></p>
<p><span class="koboSpan" id="kobo.5.1">According to the official documentation these levels are organized as follows (it goes from least to highest severity):</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.6.1">Trace = 0</span></strong><span class="koboSpan" id="kobo.7.1">: For information that is valuable only to a developer debugging an issue. </span><span class="koboSpan" id="kobo.7.2">These messages may contain sensitive application data and so should not be enabled in a production environment. </span><span class="koboSpan" id="kobo.7.3">Disabled by default. </span><span class="koboSpan" id="kobo.7.4">For example, credentials: </span><kbd><span class="koboSpan" id="kobo.8.1">{"User":"someuser", "Password":"P@ssword"}</span></kbd></li>
<li><strong><span class="koboSpan" id="kobo.9.1">Debug = 1</span></strong><span class="koboSpan" id="kobo.10.1">: </span><span><span class="koboSpan" id="kobo.11.1">For information that has short-term usefulness during development and debugging. </span><span class="koboSpan" id="kobo.11.2">For example, entering the </span><kbd><span class="koboSpan" id="kobo.12.1">Configure</span></kbd><span class="koboSpan" id="kobo.13.1"> method with</span></span><span class="koboSpan" id="kobo.14.1"> fl the g </span><span><span class="koboSpan" id="kobo.15.1">set to true.</span></span></li>
<li><strong><span class="koboSpan" id="kobo.16.1">Information = 2</span></strong><span class="koboSpan" id="kobo.17.1">: </span><span><span class="koboSpan" id="kobo.18.1">For tracking the general flow of the application. </span><span class="koboSpan" id="kobo.18.2">These logs typically have some long-term value. </span><span class="koboSpan" id="kobo.18.3">For example, the request received for path </span><kbd><span class="koboSpan" id="kobo.19.1">/</span></kbd></span><kbd><span class="koboSpan" id="kobo.20.1">api</span><span><span class="koboSpan" id="kobo.21.1">/todo</span></span></kbd><span class="koboSpan" id="kobo.22.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.23.1">Warning = 3</span></strong><span class="koboSpan" id="kobo.24.1">: </span><span><span class="koboSpan" id="kobo.25.1">For abnormal or unexpected events in the application flow. </span><span class="koboSpan" id="kobo.25.2">These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated. </span><span class="koboSpan" id="kobo.25.3">Handled exceptions are a common place to use the warning log level. </span><span class="koboSpan" id="kobo.25.4">For example, </span><kbd><span class="koboSpan" id="kobo.26.1">FileNotFoundException</span></kbd><span class="koboSpan" id="kobo.27.1"> for file </span><kbd><span class="koboSpan" id="kobo.28.1">quotes.txt</span></kbd><span class="koboSpan" id="kobo.29.1">.</span></span></li>
<li><strong><span class="koboSpan" id="kobo.30.1">Error = 4</span></strong><span class="koboSpan" id="kobo.31.1">: </span><span><span class="koboSpan" id="kobo.32.1">For errors and exceptions that cannot be handled. </span><span class="koboSpan" id="kobo.32.2">These messages indicate a failure in the current activity or operation (such as the current HTTP request), not an application-wide failure. </span><span class="koboSpan" id="kobo.32.3">For example, log message: </span><kbd><span class="koboSpan" id="kobo.33.1">Cannot insert record due to duplicate key violation</span></kbd><span class="koboSpan" id="kobo.34.1">.</span></span></li>
<li><strong><span class="koboSpan" id="kobo.35.1">Critical = 5</span></strong><span class="koboSpan" id="kobo.36.1">: For failures that require immediate attention. </span><span><span class="koboSpan" id="kobo.37.1">For example,</span></span><span class="koboSpan" id="kobo.38.1"> data loss scenarios, out of disk space.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.39.1">The IDE also shows those levels through the IntelliSense services, together with an explanation of each purpose and functionality:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.40.1"><img height="170" width="556" class=" image-border" src="assets/3f7d1638-39ba-41ce-9149-55c0adae1e7f.png"/></span></div>
<p><span class="koboSpan" id="kobo.41.1">In this way, the returned </span><kbd><span class="koboSpan" id="kobo.42.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.43.1"> service we get when asking for a reference will redirect any output to the console using the debug level configuration, if not instructed otherwise.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.44.1">The </span><kbd><span class="koboSpan" id="kobo.45.1">ILogger</span></kbd><span class="koboSpan" id="kobo.46.1"> and </span><kbd><span class="koboSpan" id="kobo.47.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.48.1"> interfaces are located in </span><kbd><span class="koboSpan" id="kobo.49.1">Microsoft.Extensions.Logging.Abstractions</span></kbd><span class="koboSpan" id="kobo.50.1">, and default implementations of them are in </span><kbd><span class="koboSpan" id="kobo.51.1">Microsoft.Extensions.Logging</span></kbd><span class="koboSpan" id="kobo.52.1">.</span></div>
<p><span class="koboSpan" id="kobo.53.1">Now, if we want both classes (</span><kbd><span class="koboSpan" id="kobo.54.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.55.1"> and </span><kbd><span class="koboSpan" id="kobo.56.1">Program</span></kbd><span class="koboSpan" id="kobo.57.1">) to use these logging services, we need an </span><kbd><span class="koboSpan" id="kobo.58.1">ILogger</span></kbd><span class="koboSpan" id="kobo.59.1"> instance for each one. </span><span class="koboSpan" id="kobo.59.2">We'll start creating one for </span><kbd><span class="koboSpan" id="kobo.60.1">Program</span></kbd><span class="koboSpan" id="kobo.61.1"> and presenting a first set of messages in the console:</span></p>
<pre><span class="koboSpan" id="kobo.62.1">    // Create a logger class from ILoggerFactory 
    // and print an initial set of messages. 
    </span><span class="koboSpan" id="kobo.62.2">var ILoggerService = serviceProvider.GetService&lt;ILoggerFactory&gt;(); 
    var logger = ILoggerService.CreateLogger&lt;Program&gt;(); </span></pre>
<p><span class="koboSpan" id="kobo.63.1">Notice that the creation of the logger class implies calling the </span><kbd><span class="koboSpan" id="kobo.64.1">CreateLogger&lt;Program&gt;()</span></kbd><span class="koboSpan" id="kobo.65.1"> generic method. </span><span class="koboSpan" id="kobo.65.2">Once instantiated, the logger has methods to declare different scopes, (marking the beginning and the end of each scope) and to send six different types of messages to the console, each one representing a different severity level:</span></p>
<pre><span class="koboSpan" id="kobo.66.1">    logger.LogCritical("Critical format message from Program"); 
    logger.LogDebug("Debug format message from Program"); 
    logger.LogError("Error format message from Program"); 
    logger.LogInformation("Information format message from Program"); 
    logger.LogTrace("Trace format message from Program"); 
    logger.LogWarning("Warning format message from Program");  </span></pre>
<p><span class="koboSpan" id="kobo.67.1">If we take a look at the output, we can appreciate the differences between those messages' formats:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.68.1"><img height="185" width="378" class=" image-border" src="assets/606837b0-ae76-44ad-804d-dc8669814a7a.png"/></span></div>
<p><span class="koboSpan" id="kobo.69.1">As you can see, the different messages' severity levels generate different formats in the output using distinct colors and prefixes to denote its </span><kbd><span class="koboSpan" id="kobo.70.1">LogLevel</span></kbd><span class="koboSpan" id="kobo.71.1"> category. </span><span class="koboSpan" id="kobo.71.2">But, wait a minute! </span><span class="koboSpan" id="kobo.71.3">There's one missing (the </span><kbd><span class="koboSpan" id="kobo.72.1">Trace</span></kbd><span class="koboSpan" id="kobo.73.1"> message).</span></p>
<p><span class="koboSpan" id="kobo.74.1">Well, not quite. </span><span class="koboSpan" id="kobo.74.2">What happens is that the </span><kbd><span class="koboSpan" id="kobo.75.1">Trace</span></kbd> <kbd><span class="koboSpan" id="kobo.76.1">LogLevel</span></kbd><span class="koboSpan" id="kobo.77.1"> doesn't output to the console, and it is prepared to be used mainly in web applications in which the trace switch is enabled (we will see more on that in </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.78.1">Chapter 4</span></a><span class="koboSpan" id="kobo.79.1">, </span><em><span class="koboSpan" id="kobo.80.1">Dependency Injection in ASP.NET Core</span></em><span class="koboSpan" id="kobo.81.1">).</span></p>
<p><span class="koboSpan" id="kobo.82.1">So, all that said, how can we use this architecture and logging services from our </span><kbd><span class="koboSpan" id="kobo.83.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.84.1"> class? </span><span class="koboSpan" id="kobo.84.2">Let's change the implementation, so we use one of the DI patterns that we saw in the previous chapter--the constructor dependency model.</span></p>
<p><span class="koboSpan" id="kobo.85.1">To use that model, we have to change our </span><kbd><span class="koboSpan" id="kobo.86.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.87.1"> class a little to include a read-only property that holds the </span><kbd><span class="koboSpan" id="kobo.88.1">ILogger&lt;&gt;</span></kbd><span class="koboSpan" id="kobo.89.1"> instance and assign its value in the class' constructor. </span><span class="koboSpan" id="kobo.89.2">So, the final format of our, this time, unique </span><kbd><span class="koboSpan" id="kobo.90.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.91.1"> classes will be (the interface definition is not affected yet, so it's just the same as in previous demos):</span></p>
<pre><span class="koboSpan" id="kobo.92.1">    public class XMLWriter : IXMLWriter 
    { 
      private readonly ILogger&lt;XMLWriter&gt; logger; 
      public XMLWriter(ILoggerFactory loggerFactory) 
      { 
        logger = loggerFactory.CreateLogger&lt;XMLWriter&gt;(); 
      } 
      public void WriteXML() 
      { 
        logger.LogInformation("&lt;message&gt;Writing in XML Format</span><br/><span class="koboSpan" id="kobo.93.1">          (via Logger)&lt;/message&gt;"); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.94.1">The only thing remaining is to use the </span><kbd><span class="koboSpan" id="kobo.95.1">logger</span></kbd><span class="koboSpan" id="kobo.96.1"> instead of the previous calls to </span><kbd><span class="koboSpan" id="kobo.97.1">Console</span></kbd><span class="koboSpan" id="kobo.98.1"> and call one of the </span><kbd><span class="koboSpan" id="kobo.99.1">Log*</span></kbd><span class="koboSpan" id="kobo.100.1"> methods to generate the intended output. </span><span class="koboSpan" id="kobo.100.2">And that's it.</span></p>
<p><span class="koboSpan" id="kobo.101.1">We have totally replaced the functionality provided by the </span><kbd><span class="koboSpan" id="kobo.102.1">Console</span></kbd><span class="koboSpan" id="kobo.103.1"> class with the logging services delivered by the </span><kbd><span class="koboSpan" id="kobo.104.1">ILogginFactory</span></kbd><span class="koboSpan" id="kobo.105.1"> and </span><kbd><span class="koboSpan" id="kobo.106.1">ILogger</span></kbd><span class="koboSpan" id="kobo.107.1"> objects, and we can also configure the severity level to generate distinct output formats.</span></p>
<p><span class="koboSpan" id="kobo.108.1">So, with all that in mind, we end up with a final version of our </span><kbd><span class="koboSpan" id="kobo.109.1">Main</span></kbd><span class="koboSpan" id="kobo.110.1"> method with this implementation:</span></p>
<pre><span class="koboSpan" id="kobo.111.1">    static void Main(string[] args) 
    { 
      // Enabling logging in the ServiceCollection 
      // via AddLogging() 
      var services = new ServiceCollection() 
        .AddSingleton&lt;IXMLWriter, XMLWriter&gt;() 
        .AddLogging(); 
      var serviceProvider = services.BuildServiceProvider(); 
      //Obtain service and configure logging 
      serviceProvider.GetService&lt;ILoggerFactory&gt;() 
        .AddConsole(LogLevel.Debug); 
 
      // Create a logger class from ILoggerFactory 
      // and print all types of messages. 
      </span><span class="koboSpan" id="kobo.111.2">var ILoggerService = serviceProvider.GetService&lt;ILoggerFactory&gt;(); 
      var logger = ILoggerService.CreateLogger&lt;Program&gt;(); 
      logger.LogCritical("Critical format message from Program"); 
      logger.LogDebug("Debug format message from Program"); 
      logger.LogError("Error format message from Program"); 
      logger.LogInformation("Information format message from Program"); 
      logger.LogTrace("Trace format message from Program"); 
      logger.LogWarning("Warning format message from Program"); 
 
      //Instantiation of XMLInstance 
      var XMLInstance = serviceProvider.GetService&lt;IXMLWriter&gt;(); 
      XMLInstance.WriteXML(); 
 
      logger.LogDebug("Process finished!"); 
      Console.Read(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.112.1">As we can see in the final output (see the following screenshot), all messages are presented in the console in the same sequence they're invoked, using the predefined formats that .NET Core configures, and including our </span><kbd><span class="koboSpan" id="kobo.113.1">XMLWriter</span></kbd><span class="koboSpan" id="kobo.114.1"> message:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.115.1"><img height="271" width="505" class=" image-border" src="assets/1d65f85e-fa1c-4fc9-8e55-3a85320b9fdf.png"/></span></div>
<p><span class="koboSpan" id="kobo.116.1">This is not all. </span><span class="koboSpan" id="kobo.116.2">We still have other options available that allow us to separate and filter the output message destination. </span><span class="koboSpan" id="kobo.116.3">This possibility is correlated to the </span><kbd><span class="koboSpan" id="kobo.117.1">Microsoft.Extensions.Logging.Debug</span></kbd><span class="koboSpan" id="kobo.118.1"> library, which should also be referenced just like the others we're using here.</span></p>
<p><span class="koboSpan" id="kobo.119.1">One of the features included in this library is the </span><kbd><span class="koboSpan" id="kobo.120.1">AddDebug()</span></kbd><span class="koboSpan" id="kobo.121.1"> method of </span><kbd><span class="koboSpan" id="kobo.122.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Once activated, it permits us to send messages to the Debug window, enabling a separation of messages conditional to its severity level, for instance.</span></p>
<p><span class="koboSpan" id="kobo.124.1">To test this functionality, we'll make a few changes in our definitions of the </span><kbd><span class="koboSpan" id="kobo.125.1">IXMLWriter</span></kbd><span class="koboSpan" id="kobo.126.1"> interface and update the implementation accordingly. </span><span class="koboSpan" id="kobo.126.2">Our new interface will have another method that also sends messages to the predefined output (which, in this case, will show up in several places at runtime):</span></p>
<pre><span class="koboSpan" id="kobo.127.1">    public interface IXMLWriter 
    { 
        void WriteXML(); 
        void WriteXMLWithSeverityLevel(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.128.1">So, the updated code of XMLWriter will be:</span></p>
<pre><span class="koboSpan" id="kobo.129.1">    public class XMLWriter : IXMLWriter 
    { 
      private readonly ILogger&lt;XMLWriter&gt; logger; 
      public XMLWriter(ILoggerFactory loggerFactory) 
      { 
        loggerFactory.AddDebug().AddConsole(LogLevel.Information); 
        logger = loggerFactory.CreateLogger&lt;XMLWriter&gt;(); 
      } 
      public void WriteXML() 
      { 
        logger.LogDebug( 
            "&lt;msg&gt;First Message (LogDebug/SeverityLevel: </span><br/><span class="koboSpan" id="kobo.130.1">                 Information)&lt;/msg&gt;"); 
      } 
      public void WriteXMLWithSeverityLevel() 
      { 
        logger.LogDebug( 
            "&lt;msg&gt;Second Message (LogDebug/SeverityLevel: </span><br/><span class="koboSpan" id="kobo.131.1">                 Information&lt;/msg&gt;"); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.132.1">So, now we have two distinct methods to write messages. </span><span class="koboSpan" id="kobo.132.2">To test this functionality, we can configure the </span><kbd><span class="koboSpan" id="kobo.133.1">ILoggerService</span></kbd><span class="koboSpan" id="kobo.134.1"> object in the </span><kbd><span class="koboSpan" id="kobo.135.1">Main()</span></kbd><span class="koboSpan" id="kobo.136.1"> method (which, remember, is of type </span><kbd><span class="koboSpan" id="kobo.137.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.138.1">). </span><span class="koboSpan" id="kobo.138.2">Once the new namespace is loaded and available, we can write:</span></p>
<pre><span class="koboSpan" id="kobo.139.1">    var ILoggerService = serviceProvider.GetService&lt;</span><br/><span class="koboSpan" id="kobo.140.1">          ILoggerFactory&gt;(); 
    ILoggerService.AddDebug(); </span></pre>
<p><span class="koboSpan" id="kobo.141.1">In this manner, we allow sending messages to the </span><kbd><span class="koboSpan" id="kobo.142.1">Debug</span></kbd><span class="koboSpan" id="kobo.143.1"> or </span><kbd><span class="koboSpan" id="kobo.144.1">Output</span></kbd><span class="koboSpan" id="kobo.145.1"> windows, either for console or web applications.</span></p>
<p><span class="koboSpan" id="kobo.146.1">It's easy to test different options, changing the types of severity levels used in the calls to this method, and the already existing ones. </span><span class="koboSpan" id="kobo.146.2">For example, we can make a call to </span><kbd><span class="koboSpan" id="kobo.147.1">WriteXMLWithSeverityLevel()</span></kbd><span class="koboSpan" id="kobo.148.1"> and observe the two outputs (now we have two), that are generated during execution:</span></p>
<pre><span class="koboSpan" id="kobo.149.1">    //Instantiation of XMLInstance 
    var XMLInstance = serviceProvider.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); 
    XMLInstance.WriteXMLWithSeverityLevel(); </span></pre>
<p><span class="koboSpan" id="kobo.150.1">On one side, the output now presents the new message (nothing unexpected):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.151.1"><img height="308" width="594" class=" image-border" src="assets/324caea3-87c7-41a9-9eb7-285ad3cf41e7.png"/></span></div>
<p><span class="koboSpan" id="kobo.152.1">But, now, we have more messages. </span><span class="koboSpan" id="kobo.152.2">If we take a look at the </span><kbd><span class="koboSpan" id="kobo.153.1">Output</span></kbd><span class="koboSpan" id="kobo.154.1"> window, we'll see the new entries depending on the </span><kbd><span class="koboSpan" id="kobo.155.1">LogLevel</span></kbd><span class="koboSpan" id="kobo.156.1"> we configure--some of them will be presented, and others, ignored (as you can see, in this version, only the first four messages are replicated in the Output window, and all XMLWriter messages are ignored):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.157.1"><img height="149" width="600" class=" image-border" src="assets/d33a0f69-0e87-4e06-ae02-edc6de0e2883.png"/></span></div>
<p><span class="koboSpan" id="kobo.158.1">This is only a first approach to some of the services that adopt the DI architecture and that are available inside .NET Core. </span><span class="koboSpan" id="kobo.158.2">We will see much more on these implementations when dealing with ASP.NET Core coding, in </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.159.1">Chapter 4</span></a><span class="koboSpan" id="kobo.160.1">, </span><em><span class="koboSpan" id="kobo.161.1">Dependency Injection in ASP.NET Core</span></em><span class="koboSpan" id="kobo.162.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we have made a first approach to how Dependency Injection technologies are supported and implemented in the current version of the .NET Core (2.0) and how we can use them, even outside of ASP.NET projects.</span></p>
<p><span class="koboSpan" id="kobo.3.1">To summarize, we've seen the main characteristics of NET Core and its installation and usage from Visual Studio, especially focused on the latest version, Visual Studio 2017, together with the distinct types of deployment linked to this version of the framework, along with the main features and functionality included in the namespaces related to DI and, especially, inside the </span><kbd><span class="koboSpan" id="kobo.4.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.5.1"> and </span><kbd><span class="koboSpan" id="kobo.6.1">Microsoft.Extensions.Logging</span></kbd><span class="koboSpan" id="kobo.7.1"> containers.</span></p>
<p><span class="koboSpan" id="kobo.8.1">We've also analyzed the classes and interfaces related to this architecture, together with its implementation through a bunch of samples, ending with some real implementations, that are already part of .NET Core 2.0, such as the logging services, and how to use them, from any class.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In </span><a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank"><span class="koboSpan" id="kobo.10.1">Chapter 4</span></a><span><span class="koboSpan" id="kobo.11.1">,</span></span> <em><span class="koboSpan" id="kobo.12.1">Dependency Injection in ASP.NET Core</span></em><span class="koboSpan" id="kobo.13.1">, our approach will be more real, since it deals with web applications and how the new architecture and configuration of websites manage these new concepts, such as middleware and services configuration, in which DI plays an important role since the very beginning.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>