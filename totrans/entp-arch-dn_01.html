<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The Sad State of Information Systems</h1>
<p>Before jumping to solutions, it is essential to share a thorough diagnostic of a situation. In the case of information systems and, more generally, computer use, any user knows of the term “bug” and has experienced the frustration associated with malfunction, sometimes with a high personal impact (loss of personal data, consequences regarding revenue, and so on). For companies, a malfunction in IT can have harsh consequences since they depend more and more on computers to realize their business operations, hence their financial objectives.</p>
<p>After defining what an information system is and explaining how its efficiency (or lack thereof) can be calculated, an attempt at classifying the causes of such problems will be exposed. As for solutions, this will be the subject of the rest of this book. But for now, we must understand what is going wrong with information systems, how this happens, and – more importantly – why.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>What is an information system?</li>
<li>Why is software building still a craftsmanship, with good and bad consequences?</li>
<li>How the efficiency of an information system can be evaluated</li>
<li>How to classify the different impacts that can happen on information systems, as well as what their causes and consequences are</li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What is an information system?</h1>
<p>Before talking<a id="_idIndexMarker000"/> about the state of information systems, it might be useful to give a clear definition of what an information system is and even what a system is.</p>
<p>A <strong class="bold">system</strong> is a <a id="_idIndexMarker001"/>group of items that operate together to reach a common goal. This is the basic difference between a system and a union of individualities: the parts of a system work together toward a vision.</p>
<p>An <strong class="bold">information system</strong> (we will sometimes abbreviate it as <strong class="bold">IS</strong>) furthers this definition as a group of items that share information to reach a common objective. Strictly speaking, an IS is not necessarily made of software, even though most of what we will talk about in this book is about computerized information systems. And, even in the most sophisticated IS, there remains a non-neglectable part of information that is not software-contained. This is a situation that we will talk about, but for the main part of this book, we will put ourselves in the hypothesis of software-based information systems as they are now pervasive in almost every company and organization.</p>
<p>So, an IS is understood as a set of software tools that operate toward a goal. This goal is typically designed as a business process for most of the companies that own the system. It should be noted that software always depends on hardware, but this tends to be more and more hidden in the background and the IS is more and more considered as the software means, organized together to reach a business goal, by implementing functional processes efficiently.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>A quick history of information systems</h2>
<p>When dealing with <a id="_idIndexMarker002"/>general subjects, such as the quality of information systems, it is always interesting to have a look at the past and analyze the evolution toward the current situation.</p>
<p>If we follow the definition stated previously, information systems only appear when at least two entities collaborate. In our hypothesis of software-based information systems, this means at least two computers have been connected. This means that initial room-sized computers that are operated on-premises should not be considered systems, though they were often called “large systems” (the items that were assembled, in this case, were computation mechanisms, short-life memory, and long-life memory).</p>
<p>Let’s go forward in time a little bit and talk about IBM’s client-server mainframes: those are the first ones that we can consider as information systems since there were client stations connected to a central computer, with information flowing between them. The protocol was <a id="_idIndexMarker003"/>proprietary, which made it easier for IBM to reach the high quality of the service provided by these systems (lots of them are still in operation nowadays). Since a unique implementation of a protocol was defined by the same team, compatibility, and interoperability were a very light issue. This is legacy, but when the system is working and when modernizing it is highly risky, the businesses logically make the choice of not moving anything (this is the first rule in information systems management: if it works, do not touch it).</p>
<p>Fast-forward again and we are in the nineties. This<a id="_idIndexMarker004"/> is the era of <strong class="bold">personal computers</strong> (<strong class="bold">PCs</strong>). Though there is a worldwide attempt at keeping compatibility between the machines, anybody using computers at this time who was unable to use a given piece of software, because it did not support the embedded video card, knows this was partly a failure. Of course, things have greatly improved<a id="_idIndexMarker005"/> since then, with <strong class="bold">Video Electronics Standards Association</strong> (<strong class="bold">VESA</strong>) international standards being created for video cards and screens, such as VGA or VESA, and lots of other norms that make it possible, in the present time, to change components of a PC without breaking down the whole system. Still, the toll on information systems has been quite high: how can we expect networks of machines to work well together when even a single machine’s components are hard to assemble? Proprietary formats, different encodings, an almost complete absence of strong data exchange protocols: everything led to a difficult situation, and only high-budget companies could operate complex computerized systems with the help of experts, who would twitch about anything from jumpers on an electronic board to compilers parameters to make the system work.</p>
<p>Fortunately, Y2K came with the internet expansion and its radical approach to normalizing the exchanges between computers. Now, every single computer that abided by TCP/IP, HTTP, Unicode, and other internet-born standards could exchange data with another one anywhere in the world, regardless of its hardware and operating system implementation. This is one of the biggest steps forward in the history of IT and the root definition of what our “modern” information systems are today.</p>
<p>A few software layers were added to this to make it easy to reuse functions in a system. It started low, with local reuse of code through routines, then libraries and components. With the advent of network capacities, this evolved to distributed components, web services, and <a id="_idIndexMarker006"/>finally <strong class="bold">service-oriented architecture</strong> (<strong class="bold">SOA</strong>). This is also the time when n-tier architectures were put in place, establishing a first layer of responsibility separation<a id="_idIndexMarker007"/> inside the software application, between <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) management, the exposition of functional services, the implementation of business rules, and persistence management.</p>
<p>The last bit, SOA, has<a id="_idIndexMarker008"/> led many companies to costly failures, and the vast majority of attempts at putting such architectures in place resulted in important financial loss and abandonment of projects. The technological step was too high to operate smoothly, and lighter alternatives have appeared to remove local difficulties of the SOA approach:</p>
<ul>
<li><strong class="bold">Standardized message-oriented middleware</strong>: To counter the proprietary exchange protocols put forward by large software companies operating on SOA and using it to lock their customers in their system</li>
<li><strong class="bold">The REST approach</strong>: To lighten the weight of SOAP/WSDL web services and the weight of all associated norms</li>
<li><strong class="bold">Enterprise Service Bus</strong>: This technique is used to reduce the importance of the middleware and reach a “dumb pipes” paradigm where the software applications participating in the system would be able to communicate with each other without needing a central piece of software that would necessarily become a single point of failure</li>
</ul>
<p>As the presence of a few reference books (Sassoon, Longépé, and Caseau) show, the best practices to design a strong and evolution-capable IS were already available in the late nineties, though not very well known. But it was during the 2000s that these practices came to a larger share in the community and SOA and other service-based approaches flourished, leading to the microservices architecture in the beginning of the 2010s. This set of practices is still considered as the reference architecture at the time of writing, though we will see that not all its recommendations should be applied without a strong analysis of its usefulness in the studied context. As we will see, the granularity of services is key to obtaining an efficient IS. But for now, we will talk about software building in general and try to understand the current limits of this so-called “industry.”</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Software building – still craftsmanship</h1>
<p>The <a id="_idIndexMarker009"/>precise definition of an information system, as interpreted in this book, has been given together with a brief history of its evolution. This history is not only very short but shows many recent evolutions, most of them radically different from the previous state of the art. This very rapid evolution is a sign that information systems design is not something that can be considered stabilized and completely understood.</p>
<p>There remains a <a id="_idIndexMarker010"/>large part of craftsmanship in the design and <a id="_idIndexMarker011"/>deployment of a software information system. Craftsmanship has its advantages: human attention to detail, custom-tailored functions, uniqueness, and more. It also has numerous drawbacks, such as high costs, difficulty in evolving in a controlled way, dependence on a few creators, and many others. These drawbacks outgrow the advantages in modern companies for which the information system has become the operational backbone.</p>
<p>Well-crafted information systems are an evolution from arbitrarily evolving ones, and there is nothing to be ashamed of with a craftsman’s job, but the way forward today is toward an industrialized approach to information systems. This is what this book is all about.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Craftsmanship as opposed to previous lack of quality</h2>
<p>Craftsmanship<a id="_idIndexMarker012"/> is used in several domains of IT where opposition is established with older, more arbitrary, and self-organized methods where used. For example, numerous IT conferences include the word “craftsmanship” in their names as a statement of their will to address quality and heterogeneity issues.</p>
<p>Information systems have long appeared simply because pieces of the system were put together and linked without any reflection on the whole system itself. This is generally what happens with so-called “point-to-point integrations,” where connections are made between different software modules while considering only the source and the destination of the link, without any map of all the links that exist, sometimes reproducing an already existing link or reversing the initially intended direction of the functional dependency between the two modules.</p>
<p>Such systems that are born without anybody thinking of the whole functioning have very few chances to remain stable for long. In the rare cases where only a few connections are created, the system can operate fine, but we all know that IT evolves very quickly, and <a id="_idIndexMarker013"/>business needs are added all the time (“the only stable thing in a system is its need to evolve”). If nobody has a global view of the whole system, there is no way that its overall evolution is going to develop ideally. It would be pure chance and Murphy’s Law states that, if something can go wrong in a software system, it most definitely will.</p>
<p>Software craftsmanship<a id="_idIndexMarker014"/> involves a will to not let the system create itself and develop in the wrong direction, but to take extra care of the software quality and methods to build time-enduring and evolution-capable systems. When applied to code (where it mostly happens), software craftsmanship includes test automation, a refactoring approach, quality indicators monitoring, and many other methods and techniques that go beyond minimal practices.</p>
<p>We could argue that these practices are contrary to craftsmanship, but this is only true in established industries, where craftsmanship lives in opposition to standardized industrial production. In the world of IT, industrialization has not happened yet. The word “craftsmanship” has been used by artisans of IT who pride themselves on analyzing problems and solving them with code more elegantly and sustainably than usual slack in their analysis and in the realization (many of us have seen code without any analysis documentation and a single unit test, and yet that has been sent into production just because “it worked”). Craftsmanship – as the word is used in the IT movement – could even be said to be the very first step into industrializing the software domain since this is the first resolute action into making code clean and not letting it derive into what is commonly named in the IT jargon as a “big ball of mud.”</p>
<p>It might look like I oppose craftsmanship and industrialization, but one isn’t better than the other: they are simply two phases of the development of a domain – in our case, software. Personally, after 38 years of programming with the desire to do things cleanly, I consider myself a craftsman; my goal with this book – and the past 15 years of my architect career – is to humbly help make another step so that software gets out of its infancy problems and becomes an adult industry.</p>
<p>As a side note, a subject of discussion among software architects is about our working domain to be able to ever become an industry. I tend to think that the amount of creativity needed to be a good software engineer will make it impossible to fully industrialize software production, but that a lot of things should be industrialized to reach this mature, adult phase, where IT will finally deliver its complete value.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>A word about “emerging architecture”</h2>
<p>The <a id="_idIndexMarker015"/>concept of emerging architecture is that, in some human constructions (mainly software applications), architecture is not established upfront, but appears gradually with the construction of the object. This concept is often used together with Agile methods, where the software construction is iterative and not done in a single succession of phases, such as in the “V-cycle” method. Instead of a single design/development/test series of steps, Agile software development loops many times over these steps, each time building on the previous cycle to gradually work toward a final vision that may even evolve during the steps.</p>
<p>In this case, each step involves the<a id="_idIndexMarker016"/> minimal design activity necessary to realize the cycle, in a <strong class="bold">Keep It Simple</strong> mindset. Thus, there is no initial complete vision of the final architecture, which sometimes can be seen as a serious limitation of Agile methods, but is at the same time their force, as they continually adapt. There are ways for this to go awry, though, and it mostly happens where participants in the project expect the architecture to emerge naturally. This confusion is often seen in software developments where no architect is involved and where developers believe individual best practices, goodwill, and craftsmanship will have a quality impact on the outcome. The reality is that these practices will positively affect the individual results of each Agile step but will not guide the overall architecture in any sound place since there is no long-term direction.</p>
<p>Therefore, it is very important to understand that emerging architecture does exist but necessitates an active engagement in making it happen gradually. It naturally happens at the module level, where a single developer carefully refines and refactors the code. But to work at the system level, there needs to be the same level of engagement.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Craftsmanship as opposed to an industrialized approach</h2>
<p>In the<a id="_idIndexMarker017"/> previous section, we have opposed craftsmanship to lack of quality intention in the code and thus shown how positive craftsmanship can be. Here, we will point out its limits when opposed to industrialization. Craftsmanship bears the idea of a highly skilled individual operating carefully, where time spent is of little importance compared to quality.</p>
<p>Though craftsmanship – in its noble sense of dedication to hand-polished, high-quality work – is worth praise, it also states that the level of maturity of the domain is still low. When reaching maturity,<a id="_idTextAnchor022"/> disciplines tend to separate different steps of the work, automate some of them, standardize practices and tools, and overall become more efficient, even<a id="_idIndexMarker018"/> bringing quality to a higher level that cannot be obtained with an individual human approach alone. Moreover, industrialization normalizes the whole process and makes it possible for anyone following the norms – and not only highly skilled people – to reach this high level of quality.</p>
<p>This is what has been done in all industries (and this is even why we call them this), and it is the natural evolution human workers try and reach. In the software field, predictability, quality, and time-to-market are sought-after qualities and an industrial approach is necessary to reach them.</p>
<p>It is essential to point out that there is nothing wrong with a non-industrial approach. Software is not an industry yet. After all, bridges have been built for more than 4,000 years, so it is quite understandable that this has become something of a controlled and well-established way of working. Software building, on the other hand, has only been there for a few decades and still is in its infancy.</p>
<p>But the important information here is that craftsmanship, despite all its advantages, is the step before industrialization, and lots of information systems owners nowadays really crave an IT team that reaches this next step. Stakes are huge for some of them, where competitive advantages come mostly from the information system. It has been said that “all companies today are software companies” and this stresses once more the importance of the information system and the absolute necessity of reaching higher levels of quality.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Concept of technical debt</h2>
<p><strong class="bold">Technical debt</strong> is a<a id="_idIndexMarker019"/> concept that has been created to explain, through a metaphor, how the low quality of software development can negatively <a id="_idIndexMarker020"/>affect its future development. In financial debt, you must pay regular interest, depending on the amount you have borrowed. In the software side of the metaphor, buying some time by cutting corners and lowering overall quality will have to be paid regularly, so long as the low-quality module remains active. Bug correction and maintaining the module will take some time, and the team will not be able to spend on new features that have value for the users. The lower the quality of the module, the higher the “rate of interest” – in our case, the time spent on maintenance. In the worst case, the quality of the software is so low that all available money/development time<a id="_idIndexMarker021"/> is spent only on paying for the interest of the debt (keeping the application running), which means that no money remains available to reimburse the debt/correct the software, let alone paying for features with more value.</p>
<p>This concept<a id="_idIndexMarker022"/> will be discussed at length in <a href="B21293_04.xhtml#_idTextAnchor121"><em class="italic">Chapter 4</em></a>, but since we are talking about craftsmanship, now’s a good time to explain the link between bot<a id="_idTextAnchor024"/>h concepts right away.</p>
<p>Craftsmanship is often seen as a software development approach where technical debt is maintained at its lowest level possible, sometimes being virtually nonexistent. A good craftsman developer will take pride in having zero-defect software, 100% coverage via automated tests, with a fully automated integration and deployment system.</p>
<p>The industrialized approach that was opposed to craftsmanship results mostly in an improvement of the overall quality, but also goes beyond in how it de<a id="_idTextAnchor025"/>als with technical debt. Where craftsmanship tends to have an individual and binary approach toward technical debt, as opposed to careless development that lets it potentially go unleashed and out of control, the industrialized approach manages technical debt. The financial metaphor still stands: instead of refusing any debt altogether, a well-thought operator will carefully manage their capital, borrowing if the advantages are indeed higher than <a id="_idTextAnchor026"/>the costs of the loan. Co<a id="_idTextAnchor027"/>mpared to a craftsman, an industrially-oriented developer will be more aware of the importance of time-to-market and assume a controlled level of technical debt if it helps them reach users before their competitors, thus bringing benefits that will partly be affected in reducing the technical debt afterward.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor028"/>The long-standing comparison of software to mechanical systems</h2>
<p>Comparison<a id="_idIndexMarker023"/> of software and mechanical industries (in most known cases, the automotive industry in particular) is such a habitual position of contenders of both sides that it has been worn out. Also, comparisons do not necessarily bear logic, depending on the way they are realized. For example, in the famous <em class="italic">Microsoft versus General Motors</em> meme, comparing a single car with a single piece of software brings strange conclusions from each side (<em class="italic">If the car industry evolved as quickly as software, we would have cars driving 1,000 miles per gallon</em>”/“<em class="italic">If car industry worked as the software industry, a car would crash inadvertently every 1,000 miles</em>”). The underlying error in this ill comparison is that the level of complexity is not the same on both sides. If you were to compare a single car created in an industrial factory, the cost should be compared to the single operation of a functional process in an information system, since only one function is individually operated (transporting a few people in the case of a car, calculating a payroll – for example – in<a id="_idIndexMarker024"/> the case of the software application). If we turn the problem the other way around and want to compare the internal operation of the software with its tens, maybe hundreds of thousands of lines of code, the right comparison would be with the car factory itself as it has the necessary modularity to change its car model production, and it also contains thousands of functions and many more moving parts to perform such a moving task.</p>
<p>In short, wrongly-calibrated comparisons can be very misleading and of little practical interest. But comparing information systems building to the design of a car factory, for example, is closer to the reality of the complexity of each system and can provide interesting insights, so long as you contextualize them carefully. As stated previously, comparing information systems to bridges can be pertinent if we stay on the criteria of the age of the industry. How could IT, an activity that is only a few decades old, reach the same level of maturity as an activity that has been developed over several millennia?</p>
<p>We will stop this comparison for now, but you will be introduced to several comparisons between the software “industry” and more traditional industries that better deserve this qualification throughout this book. We will try to keep the comparison as helpful and legitimate as possible. Again, there is no judgment in saying that IT is not completely industrialized yet: some systems undoubtedly are, and some are not. And this should not be taken against anyone as industries took many human generations to reach their current level. Software-based information systems simply have not had the time to do so. This book is about the means to help go in this direction, taking into account experiments from other industries, while keeping in mind that comparisons may sometimes be misleading and should be used while paying attention to their applicability.</p>
<p>Now that we have established what an information system is and the many infancy problems that it may have because the field is not industrialized yet, a sound engineering approach is needed to evaluate this lack of maturity.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor029"/>The efficiency of an IS</h1>
<p>Engineering<a id="_idIndexMarker025"/> is about<a id="_idIndexMarker026"/> making things in a controlled way; information systems will not escape this much-awaited transition as their efficiency could be improved. To do so, we need indicators, measures, and a method to get the results on a given information system. Fortunately, there is a consensus on this in the field of expertise, as we will see now.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor030"/>The measure of efficiency of a system</h2>
<p>Since a system<a id="_idIndexMarker027"/> is a group of items working together toward a goal, as defined previously, measuring the efficiency of the whole means more than just knowing the efficiency measures of each item and summing them one way or another. It is often said that the value of a good information system is much more than the value of each of its moving parts and that the most positive effects come from their interactions.</p>
<p>A good way to measure the efficiency of an information system is to evaluate how much time and money it helps save on the functional processes it supports. However, this is quite complicated to measure since a single IS generally operates several processes, and their respective importance and costs should be evaluated. If you consider that processes are also partly human-operated and that the gain of efficiency does not come only from the software part but from the way the functional teams use the application, how they have been trained, what investment has been put in the hardware for performance, and so on, it starts getting difficult to evaluate the efficiency of a complete system with these metrics. Furthermore, the output may be closer to a return-on-investment calculation than that of an efficiency metric.</p>
<p>This is why the efficiency of IS is often evaluated through simpler, more attainable metrics, namely the percentage of cost used for maintenance. This simple ratio allows us to know how much money is put to keep the system working (this is an operational cost) versus how much has been put into designing it and making it better (which is an investment cost). As functional features are what is asked of the system, the more maintenance there is to keep it operating, the less money is related to getting value out of the system. Of course, there are many points of view on software efficiency, and we are going to browse a lot of them together in this book. But maintenance is simply the easiest way to start evaluating the state of an IS.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor031"/>The cost of maintenance</h2>
<p>Maintenance <a id="_idIndexMarker028"/>may be the field where software is still lacking the most. Methodologies have arisen on the subject of software design and development that are starting to help turn craftsmanship into a more industrial approach. But <a id="_idIndexMarker029"/>design and development are just the beginning of the journey for a piece of software. Once in production, the application has to be deployed, patched (sometimes while functioning), improved, and maintained in the long run. This is where bad design, technical debt, and high costs of maintenance show the shortcomings of the design phase.</p>
<p>Again, the picture is not all that bad. After all, there are proven methods to upgrade software applications while running, which is quite an achievement if we compare this to its mechanical counterpart of changing a car’s wheel while running. But an analysis of the total costs of maintenance of ISs shows that this is only the tip of the iceberg and the general situation is quite awry.</p>
<p>A study from Gartner dated around 10 years ago and based on 3,700 companies indicates that 72% of the budget of IT is used for maintenance. You read that correctly: almost three-quarters of the cost of an IS is affected not by designing and improving it, but by adjusting and keeping it working while in production. Again – and with all the care that should be taken with such a comparison – imagine a house that, once you have paid for its building, would cost you three times as much every year just to prevent it from collapsing! This shows the sad state of information systems today.</p>
<p>You will find many other studies on this, but the Gartner one may be the most well-known. To give just another confirming point of view, another study from the same period showed that “roughly 20% of technology-supported initiatives are failures, and that number increases with the size and complexity of the project. However, unsuccessful projects often show unmistakable symptoms of failure before execution even starts.”</p>
<p>The good news is that we are not condemned to go on this way. In its infancy, car manufacturing had the same problem, with a huge maintenance cost compared to the initial production toll. The first cars were not industrialized but hand-built and their yearly maintenance was almost as costly as the car itself, with tires that had to be changed every few thousand kilometers, oil that had to be added so often that dedicated tanks were present in addition to gas ones, and engines had to be revised by mechanics every few months.</p>
<p>Today, when you look at maintenance metrics in industrialized goods, the situation is magnitudes better. A brand-new car from a trustworthy company will happily drive tens of thousands of kilometers before its first garage review and, with the improvement of engine <a id="_idIndexMarker030"/>manufacturing, adding oil is something of an old story nowadays. Another example is oil filters, which are so standardized that two sizes cover almost all of the European market of individual cars.</p>
<p>In factories, where <a id="_idIndexMarker031"/>statistics of maintenance are keenly observed because the financial yield highly depends on them, we have numbers available to quantify this in terms of maintenance cost. Generally speaking, the costs of a factory are divided into three groups, the ratio of which is important to determine the efficiency of the whole:</p>
<ul>
<li><strong class="bold">Fixed expenses</strong>: These<a id="_idIndexMarker032"/> are the expenses that are not correlated with the production volume. Typically, the cost of the building (through debt reimbursement or lease, depending on whether the company owns or rents the premises) does not depend on how much you produce. To improve efficiency, you are looking at reducing these costs, but augmenting your production level will also help you because it will reduce their relative impact on your revenue.</li>
<li><strong class="bold">Value-adding related expenses</strong>: These are the expenses that are directly related<a id="_idIndexMarker033"/> to your production. The more you produce, the more you will pay your suppliers for the goods they provide you with. You will get more benefits, except if you are selling below the revenue price, which is not only forbidden in most countries but is generally a very bad business decision. All in all, these expenses are considered good expenses because the higher they are, the more money comes in as well!</li>
<li><strong class="bold">Maintenance expenses</strong>: These are expenses that you need to plan for your production <a id="_idIndexMarker034"/>tool to continue operating smoothly. Maintenance expenses are a hard beast to tame because, if you neglect them for small economies, they might come back at you and bite strongly (a little economy on cheap lubricating oil and your million-dollar machine may fall apart in a few years). Maintenance costs have two drawbacks. First, contrarily to fixed expenses, maintenance expenses grow with production (the more your machines operate, the more maintenance they need, and this<a id="_idIndexMarker035"/> continues exponentially as old machines need more maintenance). Second, the opposite of the second kind of expenses, they do not add visible value to your product: if you include a better engine in the cars you sell, the associated value is immediately perceived; if you buy better oil to maintain the machines that are used to build those engines parts, no customer will ever realize it, let alone pay for it.</li>
</ul>
<p>With that, we<a id="_idIndexMarker036"/> understand why factory managers are very attentive to maintenance costs: they are the “bad” expenses and the difficult ones to manage. Fixed prices need less attention, simply because… well, they are fixed! And value-adding costs are not such a problem because, when they increase, that means your business is growing. So, maintenance is the key and most factory managers will be judged by the owner or their boss on their maintenance metrics. If you do not control maintenance and the costs are soaring, they will be replaced by another manager. If they are too restrictive on the maintenance budget, very costly failures may start to appear, and, again, they will be considered responsible for the mess.</p>
<p>Statistics help managers find the right way in this difficult equation by comparing it to what has been done in the past in similar situations. For example, in heavy industry factories, a fair repartition of cost is considered the following:</p>
<ul>
<li><strong class="bold">Fixed expenses</strong>: 10% of the budget</li>
<li><strong class="bold">Value-added related expenses</strong>: 85% of the budget</li>
<li><strong class="bold">Maintenance expenses</strong>: 5% of the budget</li>
</ul>
<p>There are, of course, tolerated differences in these numbers, but a maintenance ratio higher than 7% has to be justified and, beyond 10%, this is a strong alert regarding the maintenance not being in control anymore.</p>
<p>Now, let’s go back to the Gartner studies, where the admitted average of budget used to “keep the lights on” by the 3,700 IT leaders interrogated was 72%. Again, the comparison seems negative to the so-called IT industry: 10 times worse! But there are a few circumstances that must be considered. First, the natural and optimal sharing of costs in IT is necessarily different since the design is only made in the mind and does not need expensive material prototypes like in the heavy industry. Also, the fixed costs share is becoming lower and lower due to the availability of “as a service” artifacts. When, a few decades ago, buying a huge computer had a large toll on the budget, particularly in the first years when it was only partially used, cloud operations allowed us to buy computer power as needed, which made these costs fall into the investment costs group.</p>
<p>So, we could <a id="_idIndexMarker037"/>consider that the numbers are not directly comparable. Nonetheless, the IT industry has a problem with maintenance costs. And as engineers, the question that immediately pops to mind is: Where does this come from? The next section will hopefully show you that the causes are – most of the time – easy to establish since some generic errors are made when designing information systems. These are at the root of the observed shortcomings.</p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor032"/>Examples of the prohibited evolution of IT systems</h1>
<p>So far, things <a id="_idIndexMarker038"/>may been a bit theoretical. Most information systems are created without a defined plan and global, architected vision and this is reflected in the cost of maintenance – and thus the total cost of ownership – of the whole system. But what does this mean in practice? Is it that bad?</p>
<p>You may have heard expressions such as “spaghetti dish” or “data silos.” In the first case, the modules of the IS are so intertwined that it becomes impossible to touch a given part of the system without causing side effects on another one. In this case, evolution becomes complicated. The second expression is associated with modules of an IS that are so tightly separated from each other that they cannot share common data. This generally leads to duplicated data, loss of quality, and sometimes contradictory processes in the whole system. These are just a few examples of the designation of generic problems that can happen.</p>
<p>The following sections dive much deeper into such mishaps and detail what chains of reaction make information systems get slower, harder to operate, and, in the worst cases, stop them from working completely. As an architect for almost 10 years and then a consultant on information system evolution for small to very large companies, I have observed enough hindered information systems to be able to create a classification of what went wrong and how this can be analyzed. This experience, shared with a research lab in France, led to several scientific papers where this analysis was formalized and business/IT alignment anti-patterns were documented. Some of them will be detailed in the upcoming sections.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor033"/>Classification of the causes</h2>
<p>The <a id="_idIndexMarker039"/>following diagram has been extracted from a scientific article that was published in 2021 – <em class="italic">Business-IT Alignment Anti-Patterns: A Thought from an Empirical Point of View</em> – and that Dalila Tamzalit, LS2N / CNRS, and myself presented at the INFORSID conference in June 2022:</p>
<div><div><img alt="Figure 1.1 – Classification of business/IT alignment anti-patterns" src="img/B21293_01_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Classification of business/IT alignment anti-patterns</p>
<p>The small diagrams are a visual code to identify the different patterns of misalignment, the meaning of which will become clearer in the next chapter. For now, only the position of the different blocks is to be defined.</p>
<p>The horizontal axis expresses the frequency of finding the pattern in information systems that have been studied. Admittedly, those were ISs with problems, since consultants like me were hired to work on them. However, a decade of experience on almost 100 organization/industry systems from many different contexts showed that this is – sadly – something extremely current in ISs and that high-quality, rapidly evolving, and cost-efficient ones are extremely scarce. These are reserved for very small companies with limited needs or very large and rich ones that have known from the beginning that their IT system was their spine and brain and invested accordingly.</p>
<p>The vertical<a id="_idIndexMarker040"/> axis of the schema evaluates the impact the anti-pattern has on the functioning of the system. The higher the position of the anti-pattern, the more it hinders the correct working and/or evolution of the IS.</p>
<p>The consequence of this classification mode is that the anti-pattern at the top right position (<strong class="bold">LEVEL 1</strong>) is the most impactful and most often observed. This case corresponds to when the business processes are directly implemented in the software layer of the system. In <a href="B21293_03.xhtml#_idTextAnchor069"><em class="italic">Chapter 3</em></a>, we will consider the decomposition of IS on four different layers, but for now, suffice it to say that the good alignment between these layers is the most important source of quality and that the four-layer diagram is of such importance that the symbols of the 14 anti-patterns documented are based on it.</p>
<p>The following three anti-patterns, as shown in the top-right corner of the preceding diagram (<strong class="bold">LEVEL 2</strong>), are a bit less spread and harmful than the first one but account for a lot of observed difficulties. They correspond to the following three cases:</p>
<ul>
<li><strong class="bold">Feature with multiple implementations</strong>: This leads to different business rules, depending on which software is used, and obvious mistakes as consequences</li>
<li><strong class="bold">Silos</strong>: These cause duplication of data and additional work, together with errors due to synchronization or lack thereof</li>
<li><strong class="bold">Monoliths</strong>: Heer, a single software application concentrates so many business functions that its evolution is complex and it becomes a bottleneck for the whole system and sometimes even a blocking point</li>
</ul>
<p>The remaining 19 anti-patterns (<strong class="bold">LEVEL 3</strong>) are less observed and/or less dangerous for the evolution or correct functioning of the information systems, but their knowledge can help us spot them in maps of systems and improve the situation.</p>
<p>The following diagram (<em class="italic">voluntarily blurred to protect customer information</em>) shows how a quick map of an information system can help us visually find the “hot spots.” In this case, two applications that received lots of “hard-coupled” (we will come back to this notion of coupling in <a href="B21293_04.xhtml#_idTextAnchor121"><em class="italic">Chapter 4</em></a>) streams of data caused evolutionary problems, particularly since one of them was obsolete and the other one difficult to evolve for commercial and regulatory reasons:</p>
<div><div><img alt="Figure 1.2 – A hand-made map of an information system, revealing the high coupling for two software applications" src="img/B21293_01_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A hand-made map of an information system, revealing the high coupling for two software applications</p>
<p>The story behind<a id="_idIndexMarker041"/> this diagram and the reason it is displayed here, while not readable, is that when designing this map of an information system, a non-technical board member came into the room and immediately pointed at the two notes with a lot of red wires pointing to them, saying “I think I know where the problem is.” It made us realize that we did not need to continue mapping more precisely as the existing analysis was clear enough that we could start acting on the main coupling problems. It also was discovered that the two applications were also the ones with the highest obsolescence.</p>
<p>It is outside the scope of this book to study all the groups of anti-patterns that can cause problems in an information system as the subject is the architecture of such systems and we will mostly concentrate on how to avoid these problems right from the design phase. Nonetheless, if you’re curious, you are invited to read the <em class="italic">Business-IT Alignment Anti-Patterns: A Thought from an Empirical Point of View</em> paper (refer to the <em class="italic">Further reading</em> section) for an academic and more formal presentation of the classification.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor034"/>The classical symptoms of a blocked IS</h2>
<p>Behind <a id="_idIndexMarker042"/>the causes, there are symptoms of ISs that include some (and sometimes many) of these anti-patterns. If you’re experienced, then you will certainly be familiar with some of them:</p>
<ul>
<li>The testing time of a software application or a process increases exponentially. Release time increases, reaching sometimes up to several years</li>
<li>A version impacts customers or users who are not concerned with an included evolution or feature as it is on a function that they do not use</li>
<li>Some side effects of an IS module cannot be explained (well-established bugs, but also effects on performance, non-predictable behavior, and more)</li>
<li>Low levels of satisfaction for internal information systems, loss of market share for applications that participate in external/customer information systems</li>
</ul>
<h2 id="_idParaDest-31"><a id="_idTextAnchor035"/>Rate of renewal of large systems</h2>
<p>When such <a id="_idIndexMarker043"/>impacts happen and become larger and more difficult with time, the perceived solution is often to throw the existing IS away and build a new one, which is often called the <strong class="bold">Big Bang approach</strong>. Not <a id="_idIndexMarker044"/>only is this the most expensive way of tackling the problem, but it happens to also be the riskiest one as the bugs that have been found in the existing legacy applications are bound to reappear for some of them or be replaced with new ones, making it extremely slow to reach a satisfactory situation. There is even a high probability that, by the end of the rewriting process, the new system will also be far from the expected behavior since business needs have changed again in the meantime.</p>
<p>This is why it is always better to gradually improve an existing system, leaning on its good behaviors and progressively improving the modules that cause the most trouble for users.</p>
<p>Depending on the level of quality of an information system, the following can occur:</p>
<ul>
<li>It can be in such a fine condition that all evolutions can be realized without any side effects on functions that are not concerned</li>
<li>It can require a few days’ work to implement a simple new working feature and deploy it</li>
<li>It can present some couplings that make it longer, but not more difficult, to do so</li>
<li>It can be so full of problems that implementing new features is complicated and necessitates dedicated project management and impact analysis</li>
<li>It can be in such a state that evolution is almost impossible or at the price of a higher instability of the whole system</li>
</ul>
<p>The <a id="_idIndexMarker045"/>evolution of ISs is often based on phases with a duration of a few years. After 2 to 3 years, and in the best cases 5 years, the future of the business is so difficult to predict that planning the evolution of the underlying IS does not make any sense. In highly volatile activities, even a plan of 2 years may be considered too long.</p>
<p>Of course, many ISs cannot be fully corrected in only a few years and several plans will be necessary to re-align them. In this case, the approach is the same as in an Agile software development project: a first step – though much longer, generally around a semester – is realized to realign the most urgent problem, at which point objectives are re-analyzed and a following re-alignment step is undertaken, and so on, in a continuous improvement approach.</p>
<p>Although much more tempting in some cases (and in particular very appealing to non-technical profiles that do not grasp the difficulties linked to stabilization), the Big Bang approach is rarely the solution, and if you have to deal with an inefficient information system, you will most likely have to plan for a step-by-step evolution. While you will be doing such a change in an IS, this will quickly come in handy with legacy modules. And though the IT industry is quick to consider older technologies as garbage (just type any technology name, followed by “is dead,” into a browser and you will realize the extent of this), a responsible approach to IS evolution is to observe respect toward the legacy. The reason it became legacy is that it has been providing value for a long time.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor036"/>Summary</h1>
<p>In this chapter, we discussed what an IS is and why, despite all the expertise and care that can be given by true craftsmanship in software design, the system that links all these applications together can present many issues, mainly in terms of maintenance costs and the ability to evolve in time and rise to the challenges of new business processes and requests for features. Many symptoms can alert us of the state of a given IS but they all boil down to one main reason: IT has not reached the state of a truly industrialized domain since it is still a very recent human activity compared to other actual industries.</p>
<p>In the next chapter, we will talk about how industrialization principles can be applied to software. This can be summed up in two actions: cutting down complexity and standardizing the interfaces.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor037"/>Further reading</h1>
<ul>
<li>Longépé, C. (2019). <em class="italic">Le projet d’urbanisation du S.I.</em> – 4th edition. Dunod/InfoPro. EAN 9782100802432. <a href="https://www.dunod.com/sciences-techniques/projet-d-urbanisation-du-si-cas-concret-d-architecture-d-entreprise-0">https://www.dunod.com/sciences-techniques/projet-d-urbanisation-du-si-cas-concret-d-architecture-d-entreprise-0</a>.</li>
<li>Sassoon, J. (1998). <em class="italic">Urbanisation des Systèmes d’Information</em>. Hermès. EAN 9782866016937. <a href="https://www.fnac.com/a270920/Jacques-Sassoon-L-urbanisation-des-systemes-d-information">https://www.fnac.com/a270920/Jacques-Sassoon-L-urbanisation-des-systemes-d-information</a>.</li>
<li>Caseau, Y. (2011). <em class="italic">Urbanisation, SOA et BPM</em> – 4th edition. Dunod / InfoPro. EAN 9782100566365. <a href="https://www.dunod.com/sciences-techniques/urbanisation-soa-et-bpm-point-vue-du-dsi">https://www.dunod.com/sciences-techniques/urbanisation-soa-et-bpm-point-vue-du-dsi</a>.</li>
<li>Gouigoux, J. P. &amp; Tamzalit, D. (2021). <em class="italic">Business-IT Alignment Anti-Patterns: A Thought from an Empirical Point of View</em>. In E. Insfran, F. González, S. Abrahão, M. Fernández, C. Barry, H. Linger, M. Lang, &amp; C. Schneider (Eds.), Information Systems Development: Crossing Boundaries between Development and Operations (DevOps) in Information Systems (ISD2021 Proceedings). Valencia, Spain: Universitat Politècnica de València. <a href="https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/">https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/</a>.</li>
</ul>
</div>
</body></html>