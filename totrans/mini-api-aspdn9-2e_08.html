<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-104">
    <a id="_idTextAnchor132">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-105">
    <a id="_idTextAnchor133">
    </a>
    
     Integrating Minimal APIs with Data Sources
    
   </h1>
   <p>
    
     Despite us working with minimal APIs, an API would have to be even more minimal not to work with an external state, which is not to say that it doesn’t happen.
    
    
     For example, an API might be in place to simply perform a calculation or validate data, which, on their own, are not necessarily use cases that require some kind of
    
    
     
      managed data.
     
    
   </p>
   <p>
    
     However, it is fair to say that a wide range of production APIs have some element of
    
    <strong class="bold">
     
      create, read, update, delete
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CRUD
     
    </strong>
    
     ) functionality.
    
    
     In the examples shown in previous chapters, such as the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API and the
    
    <strong class="source-inline">
     
      Todo Item
     
    </strong>
    
     API, we have referred to entities or objects, all
    
    <a id="_idIndexMarker275">
    </a>
    
     of which would be potentially created, updated, deleted, or retrieved.
    
    
     The examples we explored stored these domain objects in memory, meaning that they would disappear with the application when it is stopped.
    
    
     It is now time to move that data into an external data source, where it can be persisted and managed separately from the minimal APIs
    
    
     
      we write.
     
    
   </p>
   <p>
    
     We will explore two fundamental methods of moving data between data sources in this book.
    
    
     Firstly, in this chapter, we will explore direct database connections with the
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     type in addition to MongoDB Driver for SQL and NoSQL database types, respectively.
    
    
     The next chapter will cover the second
    
    <a id="_idIndexMarker276">
    </a>
    
     method, which is
    
    <strong class="bold">
     
      object-relational mapping
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ORM
     
    </strong>
    
     ).
    
    
     Each method has its own
    
    
     
      configuration requirements.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding data integration in
     
     
      
       minimal APIs
      
     
    </li>
    <li>
     
      Connecting to SQL Server
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        SQLConnection
       
      </strong>
     
    </li>
    <li>
     
      Connecting to a NoSQL database with a
     
     
      
       MongoDB Driver
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-106">
    <a id="_idTextAnchor134">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter is quite hands-on, using several different technologies.
    
    
     As a result, you will need the following to be installed on
    
    
     
      your machine:
     
    
   </p>
   <ul>
    <li>
     
      Visual
     
     
      
       Studio 2022
      
     
    </li>
    <li>
     
      Microsoft SQL Server 2022
     
     
      
       Developer Edition
      
     
    </li>
    <li>
     
      Microsoft SQL Server
     
     
      
       Management Studio
      
     
    </li>
    <li>
     
      MongoDB
     
     
      
       Community Server
      
     
    </li>
    <li>
     
      
       MongoDB Compass
      
     
    </li>
   </ul>
   <p>
    
     You will need to download and install all of the listed software.
    
    
     Installation for all products is wizard-based, so follow each of the wizards until you have
    
    
     
      them installed.
     
    
   </p>
   <p>
    
     You might already have Visual Studio 2022 installed if you have been following along with the code examples in
    
    
     
      previous chapters.
     
    
   </p>
   <p>
    
     If you have been using Visual Studio Code, it is recommended that you now switch to Visual
    
    
     
      Studio 2022.
     
    
   </p>
   <p>
    
     Alternatively, you can host your SQL and MongoDB servers on a cloud platform, such as Microsoft Azure or
    
    <strong class="bold">
     
      Amazon Web Services
     
    </strong>
    
     (
    
    <strong class="bold">
     
      AWS
     
    </strong>
    
     ).
    
    
     Please note that the configuration and deployment of these data sources in the cloud are outside of the scope of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     The code for this chapter is available in the GitHub repository
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
   </p>
   <h1 id="_idParaDest-107">
    <a id="_idTextAnchor135">
    </a>
    
     Understanding data integration in minimal APIs
    
   </h1>
   <p>
    
     In the first chapter, we defined
    
    <a id="_idIndexMarker277">
    </a>
    
     APIs and their purpose.
    
    
     It is worth reiterating this definition in relation to data sources.
    
    
     APIs act as a gateway to a system, offering programmatic access to
    
    
     
      that system.
     
    
   </p>
   <p>
    
     In many cases, the objective of a client connecting to a system via an API is to work with data.
    
    
     That data has to be stored somewhere – preferably a source separate from the API itself so that it can be externally managed
    
    
     
      and persistent.
     
    
   </p>
   <p>
    
     minimal APIs offer various connection methods to data sources.
    
    
     For the purposes of this chapter, we are
    
    <a id="_idIndexMarker278">
    </a>
    
     going to focus on the
    
    <a id="_idIndexMarker279">
    </a>
    
     most common persistent data storage types, those being
    
    <strong class="bold">
     
      SQL
     
    </strong>
    
     
      and
     
    
    
     <strong class="bold">
      
       NoSQL
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     SQL versus NoSQL
    
   </p>
   <p class="callout">
    
     It’s highly
    
    <a id="_idIndexMarker280">
    </a>
    
     likely that as a reader of this book, you are at least somewhat familiar with SQL and
    
    <a id="_idIndexMarker281">
    </a>
    
     NoSQL, but by way of a brief primer, SQL databases are relational databases, meaning that data is stored in a collection of tables, with records represented by rows and columns in each table.
    
    
     NoSQL is less structured than SQL in that the data can be stored in various formats, including documents, key-value pairs, column families, or graphs.
    
    
     Data is stored in these various formats in collections
    
    
     
      of entities.
     
    
   </p>
   <p>
    
     There are many SQL and NoSQL
    
    <a id="_idIndexMarker282">
    </a>
    
     products to
    
    <a id="_idIndexMarker283">
    </a>
    
     choose from, with
    
    <a id="_idIndexMarker284">
    </a>
    
     the mainstream ones outlined in
    
    
     <em class="italic">
      
       Table 8.1
      
     </em>
    
    
     
      :
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Relational Databases
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           NoSQL Databases
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          MySQL
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Mongo DB (
        
        
         
          document store)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          PostgreSQL
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Cassandra (column
        
        
         
          family store)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Microsoft
        
        
         
          SQL Server
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Redis (
        
        
         
          key-value store)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Oracle Database
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         DynamoDB (
        
        
         
          key-value store)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          SQLite
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         CouchDB (
        
        
         
          document store)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          MariaDB
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Cosmos DB (
        
        
         
          multi-model database)
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 8.1: Examples of mainstream database platforms
    
   </p>
   <p>
    
     Regardless
    
    <a id="_idIndexMarker285">
    </a>
    
     of whether the data stores are SQL- or NoSQL-based, there are numerous ways that minimal APIs can access them, with different design patterns that can be adopted to ensure the consistency and integrity of the data being managed between the database and
    
    
     
      the API.
     
    
   </p>
   <p>
    
     We’re going to start exploring data sources via minimal APIs with a direct connection to a
    
    
     
      SQL database.
     
    
   </p>
   <p>
    
     Depending on your use case, the data connection method you choose is really important for optimal performance and security resilience, as is the way you manage connection lifetimes, the way queries are written, and how you pass parameters into commands
    
    
     
      and queries.
     
    
   </p>
   <p>
    
     Direct SQL commands offer a lot of flexibility, as they act in the same way as they would if you had a database IDE open and you were writing queries in them.
    
    
     A connection is initiated to a database, a query or command is executed, and then the connection is
    
    
     
      disposed
     
    
    
     <a id="_idIndexMarker286">
     </a>
    
    
     
      of.
     
    
   </p>
   <p>
    
     Let us start by exploring direct connection methods.
    
    
     We will continue to use the example of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API, first connecting to a Microsoft SQL database, and then connecting to a MongoDB
    
    
     
      instance (NoSQL).
     
    
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor136">
    </a>
    
     Connecting to and integrating with SQL databases
    
   </h1>
   <p>
    
     We will start with an
    
    <a id="_idIndexMarker287">
    </a>
    
     example that uses Microsoft SQL.
    
    
     First, open SQL Server Management Studio and create a database called
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     , with one
    
    
     
      table,
     
    
    
     <strong class="source-inline">
      
       Employees
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     You can use the SQL script in the following code block to create the table with the relevant columns and data types for
    
    
     
      this example:
     
    
   </p>
   <pre class="source-code">
CREATE TABLE dbo.Employees
    (
    Id int NOT NULL IDENTITY (1, 1),
    Name varchar(MAX) NOT NULL,
    Salary decimal(10, 2) NOT NULL,
    Address varchar(MAX) NOT NULL,
    City varchar(50) NOT NULL,
    Region varchar(50) NOT NULL,
    Country varchar(50) NOT NULL,
    Phone varchar(200) NOT NULL,
    PostalCode varchar(10) NOT NULL
    )</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table, we have set the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     column as an identity column, meaning that it will be populated by SQL Server on insertion of any record, with the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     value incrementing by
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     on
    
    
     
      each insertion.
     
    
   </p>
   <p>
    
     We now have
    
    <a id="_idIndexMarker288">
    </a>
    
     everything we need to set up a connection to the database from our minimal
    
    
     
      API project.
     
    
   </p>
   <p>
    
     Let us go back into the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API and set up the
    
    
     
      database connection.
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor137">
    </a>
    
     Configuring the connection to the database and retrieving records
    
   </h2>
   <p>
    
     SQL databases use a
    
    <strong class="bold">
     
      connection string
     
    </strong>
    
     to
    
    <a id="_idIndexMarker289">
    </a>
    
     allow access from a code base.
    
    
     In this case, I am using Windows Authentication with my local SQL server, so I can use a simple connection string that assumes the currently logged-in Windows user is able to access my SQL server.
    
    
     Alternatively, if you are using a SQL server, you will need to generate a slightly different connection string.
    
    
     The simplest way to form the connection string
    
    <a id="_idIndexMarker290">
    </a>
    
     is to use the guides for Microsoft SQL servers found at
    
    <a href="https://connectionstrings.com">
     
      https://connectionstrings.com
     
    </a>
    
     , where (based on your authentication type) you can generate the appropriate string.
    
    
     The following code shows some simple examples of connection strings for each
    
    
     
      authentication type:
     
    
   </p>
   <pre class="source-code">
//Windows Auth (Trusted Connection)
Server=myServerAddress;
Database=myDataBase;
Trusted_Connection=True;
// SQL Server Authentication
Server=myServerAddress;
Database=myDataBase;
User Id=myUsername;
Password=myPassword;</pre>
   <p>
    
     Now that we have a
    
    <a id="_idIndexMarker291">
    </a>
    
     connection string, we can store it somewhere within the API where it can be easily retrieved.
    
    
     A good place to do this would be in a configuration file, which is, by default, offered to us in the form
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Open
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     and add your connection string as shown (I am using SQL authentication in my JSON example, but you will need to add your Windows Authentication connection string
    
    
     
      if appropriate):
     
    
   </p>
   <pre class="source-code">
{
  "ConnectionStrings": {
      "DefaultConnection":
          "Server=localhost;Database=MyCompany;
          User Id=your_user;Password=your_password;"
  }
}</pre>
   <p>
    
     Your
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file may
    
    <a id="_idIndexMarker292">
    </a>
    
     have extra template values when you create your project.
    
    
     For simplicity, when following this example, it might be best to overwrite the content of the existing
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file with the example content shown in the
    
    
     
      preceding code.
     
    
   </p>
   <p>
    
     Next, we will create a service that will manage the interactions with the database.
    
    
     This service will be injected into our API endpoints using dependency injection (see
    
    <a href="B20968_07.xhtml#_idTextAnchor119">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     for more details on
    
    
     
      dependency injection).
     
    
   </p>
   <p>
    
     We will register the service as
    
    <a id="_idIndexMarker293">
    </a>
    
     a
    
    <strong class="bold">
     
      singleton
     
    </strong>
    
     .
    
    
     Doing this allows us to cleanly specify that there should only be one instance of the service, meaning that any requests coming into the API will share that service.
    
    
     Let us first get started with the creation of this database service by creating a new interface called
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     .
    
    
     This interface will lay out the
    
    <strong class="bold">
     
      contract
     
    </strong>
    
     for
    
    <a id="_idIndexMarker294">
    </a>
    
     any services that are created for the purposes of speaking to
    
    
     
      a database:
     
    
   </p>
   <pre class="source-code">
public interface IDatabaseService
{
    Task&lt;IEnumerable&lt;Employee&gt;&gt; GetEmployeesAsync();
    Task AddEmployeeAsync(Employee employee);
}</pre>
   <p>
    
     Don’t worry if you see an error at this point stating that
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     isn’t a known type.
    
    
     When it is created later, this error
    
    
     
      will clear.
     
    
   </p>
   <p>
    
     We can now create our service
    
    <a id="_idIndexMarker295">
    </a>
    
     in the form of a concrete class that implements
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     .
    
    
     Create the class, calling
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       SQLService
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Once the
    
    <strong class="source-inline">
     
      SQLService
     
    </strong>
    
     class has been created, add a constructor that receives
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     as a parameter, saving its value to a local
    
    
     <strong class="source-inline">
      
       readonly
      
     </strong>
    
    
     
      field.
     
    
   </p>
   <p class="callout-heading">
    
     More on IConfiguration
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     is already registered for dependency injection in an ASP.NET application.
    
    
     It represents the content
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This field will contain the connection string, and will allow it to be referenced in all queries and commands executed by the service, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
public class SqlService : IDatabaseService
{
    private readonly string _connectionString;
    public SqlService(IConfiguration configuration)
    {
        _connectionString =
             configuration.GetConnectionString(
                 "DefaultConnection"
             );
    }
}</pre>
   <p>
    
     Next, we’re going to finish off this service by adding the ability to add and retrieve employee records from
    
    
     
      the database.
     
    
   </p>
   <p>
    
     We will use the same
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     class that we added in the examples from previous chapters.
    
    
     As a convenient reminder, this code block shows the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     class that will act as the model for the
    
    <a id="_idIndexMarker296">
    </a>
    
     
      database records:
     
    
   </p>
   <pre class="source-code">
    public class Employee
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public decimal Salary { get; set; }
        public string Address { get; set; }
        public string City { get; set; }
        public string Region { get; set; }
        public string PostalCode { get; set; }
        public string Country { get; set; }
        public string Phone { get; set; }
    }</pre>
   <p>
    
     You will be seeing errors by now (in the Visual Studio error list, and in the form of red lines under the code) stating that the class does not fully implement the
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     interface.
    
    
     We should add the two functions specified in the interface to the
    
    <strong class="source-inline">
     
      SqlService
     
    </strong>
    
     class to
    
    
     
      correct this.
     
    
   </p>
   <p>
    
     Let’s start with
    
    <strong class="source-inline">
     
      GetEmployeesAsync()
     
    </strong>
    
     .
    
    
     The aim of this function is to return a list containing all the employees in the database.
    
    
     Start by creating the function definition and, in the body, instantiate a new
    
    
     <strong class="source-inline">
      
       Employee
      
     </strong>
    
    
     
      list:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;Employee&gt;&gt;
    GetEmployeesAsync()
{
    var employees = new List&lt;Employee&gt;();
}</pre>
   <p>
    
     Before going further, make sure you add the
    
    <strong class="source-inline">
     
      Microsoft.Data.SqlClient
     
    </strong>
    
     NuGet package, as this will be required.
    
    
     You can do this by going to
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Manage NuGet Packages
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Package Manager Console
     
    </strong>
    
     , and then typing
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
dotnet add package Microsoft.Data.SqlClient</pre>
   <p>
    
     Next, we will open a new
    
    <a id="_idIndexMarker297">
    </a>
    
     connection to SQL Server using
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     .
    
    
     By wrapping the instance in a
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement, we are ensuring that once the control flow ha
    
    <a id="_idTextAnchor138">
    </a>
    
     s exited the body of the
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement, the connection is automatically disposed of, thanks to
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     
      implementing
     
    
    
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
using (var connection = new
    SqlConnection(_connectionString))
{
    await connection.OpenAsync();
}</pre>
   <p>
    
     At this point, you have a connection open that will be automatically disposed of.
    
    
     This is good because we’re responsibly managing the use of an
    
    
     
      external resource.
     
    
   </p>
   <p>
    
     Next, inside the
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement, another
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement is added, but this time, for the creation of a
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     object.
    
    
     This
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     object represents the query we wish to execute, targeting the connection we now
    
    
     
      have open:
     
    
   </p>
   <pre class="source-code">
using (var command = new
    SqlCommand("SELECT * FROM Employees", connection))
{
}</pre>
   <p>
    
     Following this, we nest another
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement inside this one.
    
    
     This creates
    
    <strong class="source-inline">
     
      SqlDataReader
     
    </strong>
    
     , reading
    
    <a id="_idIndexMarker298">
    </a>
    
     any returned rows from the query in
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     , creating a new
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     instance for each record, and adding it to
    
    
     
      the list:
     
    
   </p>
   <pre class="source-code">
using (var reader = await command.ExecuteReaderAsync())
{
    while (await reader.ReadAsync())
    {
        var employee = new Employee
        {
            Id = reader.GetInt32(0),
            Name = reader.GetString(1),
            Salary = reader.GetDecimal(2),
            Address = reader.GetString(3),
            City = reader.GetString(4),
            Region = reader.GetString(5),
            PostalCode = reader.GetString(6),
            Country = reader.GetString(7),
            Phone = reader.GetString(8)
        };
        employees.Add(employee);
    }
}</pre>
   <p>
    
     Finally, we can finish the function by returning the list of type
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     , meaning the finished function looks like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;Employee&gt;&gt;
    GetEmployeesAsync()
{
    var employees = new List&lt;Employee&gt;();
    using (var connection = new
        SqlConnection(_connectionString))
    {
        await connection.OpenAsync();
        using (var command = new SqlCommand(
            "SELECT * FROM Employees", connection))
        {
            using (var reader = await
                command.ExecuteReaderAsync())
            {
                while (await reader.ReadAsync())
                {
                    var employee = new Employee
                    {
                        Id = reader.GetInt32(0),
                        Name = reader.GetString(1),
                        Salary = reader.GetDecimal(2),
                        Address = reader.GetString(3),
                        City = reader.GetString(4),
                        Region = reader.GetString(5),
                        PostalCode = reader.GetString(6),
                        Country = reader.GetString(7),
                        Phone = reader.GetString(8)
                    };
                    employees.Add(employee);
                }
            }
        }
    }
    return employees;
}</pre>
   <p>
    
     Take a look
    
    <a id="_idIndexMarker299">
    </a>
    
     at the
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     usage in the previous code.
    
    
     Notice how we don’t build the SQL command string using concatenation, passing in the values from
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     as part of the string being put together.
    
    
     Instead, the best practice is to use SQL parameters.
    
    
     Parameterized queries allow us to guard against a security vulnerability called
    
    
     
      SQL injection.
     
    
   </p>
   <p>
    
     In a SQL injection attack, a malicious value is passed in as a value, which can alter the originally intended behavior of a command.
    
    
     By passing in parameters, we avoid this, with parameters represented by the
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     character in the command string and added to the
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     after the string is formed (we see this in the
    
    
     
      next section).
     
    
   </p>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor139">
    </a>
    
     Inserting Employee records
    
   </h2>
   <p>
    
     We have now
    
    <a id="_idIndexMarker300">
    </a>
    
     completed our first connection to SQL with a transaction.
    
    
     Armed with this knowledge, we can also create the
    
    <strong class="source-inline">
     
      AddEmployeeAsync()
     
    </strong>
    
     function.
    
    
     The connection method is the same but the command is different, with
    
    <strong class="source-inline">
     
      INSERT
     
    </strong>
    
     being used instead
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       SELECT
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public async Task AddEmployeeAsync(Employee employee)
{
    using (var connection = new
        SqlConnection(_connectionString))
    {
        await connection.OpenAsync();
        using (var command = new SqlCommand(
            "INSERT INTO Employees (Name, Salary, " +
            Address, City, Region, Country, Phone, " +
            PostalCode) VALUES (@Name, @Salary, " +
            @Address, @City, @Region, @Country, " +
            @Phone, @PostalCode)", " +
            connection))
        {
            command.Parameters.AddWithValue(
                "@Name", employee.Name);
            command.Parameters.AddWithValue(
                "@Salary", employee.Salary);
            command.Parameters.AddWithValue(
                "@Address", employee.Address);
            command.Parameters.AddWithValue(
                "@City", employee.City);
            command.Parameters.AddWithValue(
                "@Region", employee.Region);
            command.Parameters.AddWithValue(
                "@Country", employee.Country);
            command.Parameters.AddWithValue(
                "@Phone", employee.Phone);
            command.Parameters.AddWithValue(
                "@PostalCode", employee.PostalCode);
            await command.ExecuteNonQueryAsync();
        }
    }
}</pre>
   <p>
    
     Let us now turn our attention to the minimal
    
    
     
      API endpoints.
     
    
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor140">
    </a>
    
     Executing database transactions from API endpoints
    
   </h2>
   <p>
    
     These endpoints will need to have
    
    <a id="_idIndexMarker301">
    </a>
    
     the SQL service
    
    <a id="_idIndexMarker302">
    </a>
    
     injected into them in order for them to be used in the
    
    
     
      endpoint body.
     
    
   </p>
   <p>
    
     Go back to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     and register the service as
    
    
     
      a singleton:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;IDatabaseService,
SqlLService&gt;(); var app = builder.Build();</pre>
   <p>
    
     Because we have created a service for managing interaction with the SQL server and we have made it easily available through dependency injection, getting and creating employees from minimal API endpoints is very easy.
    
    
     Simply add a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint for retrieval and a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint for creation, adding calls to the appropriate functions we created
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       SqlService
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapGet(
    "/employees",
    async (IDatabaseService dbService) =&gt;
{
    var employees = await dbService.GetEmployeesAsync();
    return Results.Ok(employees);
});
app.MapPost(
    "/employees",
    async (IDatabaseService dbService,
           Employee employee) =&gt;
{
    await dbService.AddEmployeeAsync(employee);
    return Results.Created(
        $"/employees/{employee.Id}", employee);
});</pre>
   <p>
    
     Give the new
    
    <a id="_idIndexMarker303">
    </a>
    
     endpoints a try.
    
    
     If successful, you
    
    <a id="_idIndexMarker304">
    </a>
    
     should be able to retrieve the employees in the data source as a list or add new employees via
    
    
     
      the API.
     
    
   </p>
   <p>
    
     As alluded to earlier in the chapter, because we have created an interface, we should be able to swap out the service for one that uses a different data source without having to change the endpoint.
    
    
     This leads us nicely to an example of a database connection to a
    
    
     
      NoSQL database.
     
    
   </p>
   <h1 id="_idParaDest-112">
    <a id="_idTextAnchor141">
    </a>
    
     Connecting to MongoDB
    
   </h1>
   <p>
    
     For demonstrative purposes, we will connect
    
    <a id="_idIndexMarker305">
    </a>
    
     to
    
    <strong class="bold">
     
      MongoDB
     
    </strong>
    
     , a widely used NoSQL
    
    
     
      database platform.
     
    
   </p>
   <p>
    
     Before we create the service, we should first add some data to a MongoDB database.
    
    
     As per the technical requirements, you
    
    <a id="_idIndexMarker306">
    </a>
    
     should have installed a MongoDB server, along with
    
    <strong class="bold">
     
      MongoDB Compass
     
    </strong>
    
     , a
    
    <strong class="bold">
     
      graphical user interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GUI
     
    </strong>
    
     )
    
    
     
      for
     
    
    
     <a id="_idIndexMarker307">
     </a>
    
    
     
      MongoDB.
     
    
   </p>
   <p>
    
     Start by opening
    
    <a id="_idIndexMarker308">
    </a>
    
     MongoDB Compass and creating a connection to your installed MongoDB server instance.
    
    
     If you’ve installed MongoDB locally without modifying the installation, you should be able to just
    
    
     
      click
     
    
    
     <strong class="bold">
      
       Connect
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.1: Creating a new MongoDB connection" src="img/B20968_08_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1: Creating a new MongoDB connection
    
   </p>
   <p>
    
     Once connected, you
    
    <a id="_idIndexMarker309">
    </a>
    
     will be able to see the existing databases on
    
    
     
      your server:
     
    
   </p>
   <div><div><img alt="Figure 8.2: View of existing MongoDB connections" src="img/B20968_08_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2: View of existing MongoDB connections
    
   </p>
   <p>
    
     In the navigation
    
    <a id="_idIndexMarker310">
    </a>
    
     bar on the left-hand side, click the plus icon to add a new database.
    
    
     Once again, we will call the database
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     .
    
    
     Compass will also require you to create a collection.
    
    
     Just as we created an
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table in our SQL database, we will create an
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     collection
    
    
     
      in MongoDB:
     
    
   </p>
   <div><div><img alt="Figure 8.3: MongoDB Database creation in Compass" src="img/B20968_08_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3: MongoDB Database creation in Compass
    
   </p>
   <p>
    
     Notice how we haven’t
    
    <a id="_idIndexMarker311">
    </a>
    
     been specified a schema for the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     collection.
    
    
     This is because the collection is document-based.
    
    
     We can import data in JSON format, which mirrors the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     class in
    
    
     
      our API.
     
    
   </p>
   <p>
    
     Create a couple of fake employees and save them to a local JSON file.
    
    
     Here is some example JSON to get
    
    
     
      you started:
     
    
   </p>
   <pre class="source-code">
[
    {
        "Id": 1,
        "Name": "John Doe",
        "Salary": 55000.75,
        "Address": "123 Elm Street",
        "City": "Springfield",
        "Region": "IL",
        "PostalCode": "62701",
        "Country": "USA",
        "Phone": "555-1234"
    },
    {
        "Id": 2,
        "Name": "Jane Smith",
        "Salary": 62000.50,
        "Address": "456 Oak Avenue",
        "City": "Metropolis",
        "Region": "NY",
        "PostalCode": "10001",
        "Country": "USA",
        "Phone": "555-5678"
    }
]</pre>
   <p>
    
     Once you’ve saved the
    
    <a id="_idIndexMarker312">
    </a>
    
     JSON file, you can import it into the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     collection in
    
    
     
      MongoDB Compass:
     
    
   </p>
   <div><div><img alt="Figure 8.4: Importing data into a MongoDB database in Compass" src="img/B20968_08_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4: Importing data into a MongoDB database in Compass
    
   </p>
   <p>
    
     Our MongoDB collection is now set up with example data.
    
    
     Let us turn our attention back to the minimal API, where we will write a new service to interact with this
    
    
     
      NoSQL database.
     
    
   </p>
   <p>
    
     First, we’ll need to
    
    <a id="_idIndexMarker313">
    </a>
    
     install the MongoDB driver in order to support interactions with a MongoDB database.
    
    
     You can do this via the
    
    <strong class="bold">
     
      Package Manager Console
     
    </strong>
    
     in
    
    <a id="_idIndexMarker314">
    </a>
    
     
      Visual Studio:
     
    
   </p>
   <pre class="console">
dotnet add package MongoDB.Driver</pre>
   <p>
    
     Create a new class called
    
    <strong class="source-inline">
     
      MongoDbService
     
    </strong>
    
     , implementing the
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     interface.
    
    
     Make sure you reference
    
    <strong class="source-inline">
     
      MongoDB.Bson
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       MongoDB.Driver
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
using MongoDB.Bson;
using MongoDB.Driver;
using System.Collections.Generic;
using System.Threading.Tasks;
public class MongoDbService : IDatabaseService
{
}</pre>
   <p>
    
     Next, we will create a constructor that, as before, receives an injected
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     object containing the database connection string, before initiating the connection with an instance
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       MongoClient
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Following this, a reference
    
    <a id="_idIndexMarker315">
    </a>
    
     to the collection of type,
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     can be retrieved and stored in a
    
    
     <strong class="source-inline">
      
       private
      
     </strong>
    
    
     
      field:
     
    
   </p>
   <pre class="source-code">
private readonly IMongoCollection&lt;Employee&gt;
    _employeesCollection;
    public MongoDbService(IConfiguration configuration)
    {
        var connectionString =
            configuration.GetConnectionString(
                "MongoDbConnection");
        var mongoClient = new
            MongoClient(connectionString);
        var mongoDatabase =
            mongoClient.GetDatabase("MyCompany");
        _employeesCollection =
            mongoDatabase.GetCollection&lt;Employee&gt;(
                "Employees");
    }</pre>
   <p>
    
     Next, complete the implementation of the
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     interface by adding the required functions.
    
    
     These functions can simply utilize the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     collection for querying and
    
    
     
      inserting records:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;Employee&gt;&gt;
    GetEmployeesAsync()
    {
        return await _employeesCollection
            .Find(new BsonDocument())
            .ToListAsync();
    }
    public async Task AddEmployeeAsync(Employee employee)
    {
        await _employeesCollection
            .InsertOneAsync(employee);
    }</pre>
   <p>
    
     The connection string
    
    <a id="_idIndexMarker316">
    </a>
    
     needs to be changed to point to the MongoDB server and database.
    
    
     MongoDB connection strings are fairly simple in format.
    
    
     By default, the server should be running on port
    
    <strong class="source-inline">
     
      27017
     
    </strong>
    
     .
    
    
     Here is how a default connection string would look for
    
    
     
      this configuration:
     
    
   </p>
   <pre class="console">
mongodb://localhost:27017/MyCompany</pre>
   <p>
    
     This connection string can then be added to the
    
    <strong class="source-inline">
     
      ConnectionStrings
     
    </strong>
    
     object in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     .
    
    
     We should also add a Boolean flag to the JSON that allows us to specify whether MongoDB should be used, or whether the default SQL connection should
    
    
     
      be adopted.
     
    
   </p>
   <p>
    
     Once complete, the
    
    <strong class="source-inline">
     
      ConnectionStrings
     
    </strong>
    
     section of
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     should look like the example
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
"UseMongoDB": true,
"ConnectionStrings": {
    "DefaultConnection":
        "Server=.\\SQLEXPRESS;Database=MyCompany;
        Trusted_Connection=True;
        TrustServerCertificate=True;",
    "MongoDbConnection":
        "mongodb://localhost:27017/MyCompany"
  }</pre>
   <p>
    
     Having added a new data source connection string and an option to switch from the default source to MongoDB, we must register the new
    
    <strong class="source-inline">
     
      MongoDbService
     
    </strong>
    
     class for dependency injection.
    
    
     We will, however, also need to specify a new rule for how the dependency is resolved depending on whether the
    
    <strong class="source-inline">
     
      UseMongoDB
     
    </strong>
    
     flag is enabled
    
    
     
      or not.
     
    
   </p>
   <p>
    
     Back in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , register the new
    
    
     <strong class="source-inline">
      
       MongoDbService
      
     </strong>
    
    
     
      class
     
    
   </p>
   <pre class="source-code">
builder.Services.AddSingleton&lt;MongoDbService&gt;();</pre>
   <p>
    
     Next, add the following singleton
    
    <a id="_idIndexMarker317">
    </a>
    
     registration for
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     , along with logic that checks the MongoDB flag in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     before resolving the correct database service to
    
    
     
      be used:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddSingleton&lt;IDatabaseService&gt;(sp =&gt;
{
    var config = sp.GetRequiredService&lt;IConfiguration&gt;();
    var useMongoDB = config.GetValue&lt;bool&gt;("UseMongoDB");
    if (useMongoDB)
    {
        return sp.GetRequiredService&lt;MongoDbService&gt;();
    }
    else
    {
        return sp.GetRequiredService&lt;SqlService&gt;();
    }
});</pre>
   <p>
    
     You might not have realized it yet if you haven’t run the code, but we have
    
    
     
      a problem.
     
    
   </p>
   <p>
    
     The aim of using an interface for
    
    <strong class="source-inline">
     
      IDatabaseService
     
    </strong>
    
     was to ensure that we could easily switch between data sources by modifying a Boolean flag
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This would be fine if the data
    
    <a id="_idIndexMarker318">
    </a>
    
     structures in the two data sources had identical schemas.
    
    
     Unfortunately, they don’t because, in SQL Server,
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     is an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     type, whereas, in MongoDB, the equivilent identifier is called
    
    <strong class="source-inline">
     
      _id
     
    </strong>
    
     and its data type is
    
    
     
      a string.
     
    
   </p>
   <p>
    
     This means that as it exists currently,
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     is interchangeable between the two sources.
    
    
     This means that if we switch to MongoDB and try to deserialize data to
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     , it will fail with
    
    <strong class="source-inline">
     
      FormatException
     
    </strong>
    
     due to the differing
    
    
     
      data type.
     
    
   </p>
   <p>
    
     To fix this, we should create separate models for different data sources.
    
    
     This sounds like it goes against the idea of having a flexible system, but we can still ensure that we don’t have to modify existing endpoints for different data sources by using
    
    
     
      another interface.
     
    
   </p>
   <p>
    
     Create a new interface called
    
    <strong class="source-inline">
     
      IEmployee
     
    </strong>
    
     .
    
    
     It does not require any fields at
    
    
     
      the moment:
     
    
   </p>
   <pre class="source-code">
public interface IEmployee
{
}</pre>
   <p>
    
     We can use this interface to represent an employee model generically, regardless of whether it is a SQL Server model or a
    
    
     
      MongoDB model.
     
    
   </p>
   <p>
    
     Create a new model called
    
    <strong class="source-inline">
     
      EmployeeMongoDb
     
    </strong>
    
     and set it up as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;
{
    public class EmployeeMongoDb : IEmployee
    {
        [BsonId]
        [BsonRepresentation(
            MongoDB.Bson.BsonType.ObjectId)]
        public string Id { get; set; }
        public string Name { get; set; }
        public decimal Salary { get; set; }
        public string Address { get; set; }
        public string City { get; set; }
        public string Region { get; set; }
        public string PostalCode { get; set; }
        public string Country { get; set; }
        public string Phone { get; set; }
    }
}</pre>
   <p>
    
     By adding the attributes shown
    
    <a id="_idIndexMarker319">
    </a>
    
     in the previous code to the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     field, we are mapping
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     to the string-based
    
    <strong class="source-inline">
     
      _id
     
    </strong>
    
     field in the MongoDB collection.
    
    
     We have also
    
    
     
      implemented
     
    
    
     <strong class="source-inline">
      
       IEmployee
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We will treat
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     as the default model, seeing as SQL Server is the default connection string in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     .
    
    
     Ensure that it also
    
    
     
      implements
     
    
    
     <strong class="source-inline">
      
       IEmployee
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, we must change any area in the MongoDB service or SQL service that returns a concrete class to instead return
    
    <strong class="source-inline">
     
      IEmployee
     
    </strong>
    
     .
    
    
     You’ll also need to change any code that receives
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     as an argument.
    
    
     This then requires the service to cast
    
    <strong class="source-inline">
     
      IEmployee
     
    </strong>
    
     to a compatible concrete implementation, such as
    
    <strong class="source-inline">
     
      EmployeeMongoDb
     
    </strong>
    
     for the
    
    
     <strong class="source-inline">
      
       MongoDb
      
     </strong>
    
    
     
      service.
     
    
   </p>
   <p>
    
     Changes to both
    
    <strong class="source-inline">
     
      SqlServerService
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      MongoDbService
     
    </strong>
    
     can be seen in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
private readonly IMongoCollection&lt;EmployeeMongoDb&gt;
    _employeesCollection;
public MongoDbService(IConfiguration configuration)
{
    var connectionString =
        configuration.GetConnectionString(
            "MongoDbConnection");
    var mongoClient = new MongoClient(connectionString);
    var mongoDatabase =
        mongoClient.GetDatabase("MyCompany");
    _employeesCollection =
        mongoDatabase.GetCollection&lt;EmployeeMongoDb&gt;(
            "Employees");
}</pre>
   <p>
    
     Continuing the previous code, we
    
    <a id="_idIndexMarker320">
    </a>
    
     add the
    
    <strong class="source-inline">
     
      GetEmployeesAsync()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      AddEmployeeAsync()
     
    </strong>
    
     methods using MongoDB.
    
    
     Notice how, in the
    
    <strong class="source-inline">
     
      AddEmployeeAsync()
     
    </strong>
    
     method, we can still take in
    
    <strong class="source-inline">
     
      IEmployee
     
    </strong>
    
     but then simply convert it to an
    
    <strong class="source-inline">
     
      EmployeeMongoDb
     
    </strong>
    
     object so that MongoDB can take care of generating a
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     ID, unlike the
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     ID used in
    
    
     
      SQL Server:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;IEmployee&gt;&gt;
    GetEmployeesAsync()
{
    var result = await _employeesCollection
        .Find(new BsonDocument())
        .ToListAsync();
    return result;
}
public async Task AddEmployeeAsync(IEmployee employee)
{
    var employeeToAdd = new EmployeeMongoDb
{
    Name = employee.Name,
    Salary = employee.Salary,
    Address = employee.Address,
    City = employee.City,
    Region = employee.Region,
    PostalCode = employee.PostalCode,
    Country = employee.Country,
    Phone = employee.Phone
};
    await _employeesCollection
        .InsertOneAsync(employeeToAdd);
}</pre>
   <p>
    
     The following method
    
    <a id="_idIndexMarker321">
    </a>
    
     shows the same code using
    
    
     
      SQL Server:
     
    
   </p>
   <pre class="source-code">
// GetEmployeesAsync only needs the return type to be
// changed
public async Task&lt;IEnumerable&lt;IEmployee&gt;&gt;
    GetEmployeesAsync()
public async Task AddEmployeeAsync(IEmployee employee)
{
    var employeeToAdd = (Employee)employee;
    using (var connection = new
        SqlConnection(_connectionString))
    {
        await connection.OpenAsync();
        using (var command = new SqlCommand(
            "INSERT INTO Employees (Name, Salary, " +
            Address, City, Region, Country, Phone, " +
            PostalCode) VALUES (@Name, @Salary, " +
            @Address, @City, @Region, @Country, " +
            @Phone, @PostalCode)", " +
            connection))
        {
            command.Parameters.AddWithValue(
                "@Name", employeeToAdd.Name);
            command.Parameters.AddWithValue(
                "@Salary", employeeToAdd.Salary);
            command.Parameters.AddWithValue(
                "@Address", employeeToAdd.Address);
            command.Parameters.AddWithValue(
                "@City", employeeToAdd.City);
            command.Parameters.AddWithValue(
                "@Region", employeeToAdd.Region);
            command.Parameters.AddWithValue(
                "@Country", employeeToAdd.Country);
            command.Parameters.AddWithValue(
                "@Phone", employeeToAdd.Phone);
            command.Parameters.AddWithValue(
                "@PostalCode", employeeToAdd.PostalCode);
            await command.ExecuteNonQueryAsync();
        }
    }
}</pre>
   <p>
    
     Because
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      EmployeeMongoDb
     
    </strong>
    
     both implement
    
    <strong class="source-inline">
     
      IEmployee
     
    </strong>
    
     , the endpoint logic no longer has to change.
    
    
     We are preserving genericness at the highest level of abstraction, while dealing with more concrete classes lower down the abstraction layer within
    
    <a id="_idIndexMarker322">
    </a>
    
     
      the services.
     
    
   </p>
   <p class="callout-heading">
    
     Open-closed principle
    
   </p>
   <p class="callout">
    
     The changes we have made using interfaces help us adhere to the open-closed principle, where we aim to allow new data sources to be added in the future without having to alter the original code base invasively.
    
    
     We will discuss this principle in more detail in
    
    <a href="B20968_13.xhtml#_idTextAnchor183">
     
      <em class="italic">
       
        Chapter 13
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     This was quite an intense chapter, so let’s review what we’ve covered before
    
    
     
      moving on.
     
    
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor142">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we have covered some basic examples of direct communication with a database from minimal
    
    
     
      API endpoints.
     
    
   </p>
   <p>
    
     We started by defining the different kinds of databases, with examples of various SQL- and NoSQL-based
    
    
     
      database platforms.
     
    
   </p>
   <p>
    
     Following this, we talked about how using services with dependency injection can allow minimal API projects to seamlessly provide minimal API endpoints with interoperability with our chosen
    
    
     
      data source.
     
    
   </p>
   <p>
    
     We created a service that interacts with a SQL Server database, using
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     to define the specific properties of our data source for use in the service.
    
    
     We leveraged the functionality of
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     to execute commands and queries against the SQL Server database containing relational
    
    
     
      employee data.
     
    
   </p>
   <p>
    
     Next, we created a counterpart service that interacts with MongoDB, demonstrating the differences between
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     and the
    
    
     
      MongoDB driver.
     
    
   </p>
   <p>
    
     Finally, we modified the project using interfaces to make differing data source models interchangeable, while preserving the generic style of the API
    
    
     
      endpoint code.
     
    
   </p>
   <p>
    
     In the next chapter, we will take our exploration of data sources further by implementing two ORMs within the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API – Dapper and Entity
    
    
     
      Framework Core.
     
    
   </p>
  </div>
 </body></html>