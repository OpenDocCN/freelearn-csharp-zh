- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Testing Your Enterprise Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的企业应用程序
- en: When developing software, it is essential to ensure that an application is as
    bug-free as possible and that it satisfies all requirements. This can be done
    by testing all the modules while they are being developed or when the overall
    application has been either completely or partially implemented. This need has
    become more and more compelling in today’s agile and DevOps-driven software development
    landscape, where integrating testing at every stage of the development process
    is essential for the continuous delivery of reliable software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，确保应用程序尽可能没有错误并满足所有要求是至关重要的。这可以通过在开发过程中测试所有模块或在整体应用程序完全或部分实现后进行测试来实现。在今天的敏捷和DevOps驱动的软件开发环境中，这种需求变得越来越迫切，因为在开发过程的每个阶段集成测试对于可靠软件的持续交付至关重要。
- en: While most of the key concepts covered by this chapter apply to a wide range
    of applications and environments, this chapter focuses on essential testing strategies
    for enterprise-level applications in C# and .NET environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章涵盖的大部分关键概念适用于广泛的应用程序和环境，但本章重点介绍C#和.NET环境中企业级应用程序的必要测试策略。
- en: Performing all the tests manually is not a feasible option since most of the
    tests must be executed each time the application is modified, and, as explained
    throughout this book, modern software is continuously being modified to adapt
    applications to the needs of a fast-changing market. Therefore, automated tests
    are indispensable in today’s fast-paced environment of continuous development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行所有测试不是一个可行的选择，因为大多数测试必须在每次修改应用程序时执行，正如本书中所述，现代软件是持续修改以适应快速变化市场的需求。因此，在今天的快速开发环境中，自动化测试是必不可少的。
- en: 'This chapter discusses the most common types of tests needed to deliver reliable
    software and how to organize and automate them. More specifically, this chapter
    covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了交付可靠软件所需的最常见测试类型以及如何组织和自动化它们。更具体地说，本章涵盖了以下主题：
- en: Understanding unit and integration tests and their usage, which are the main
    tools to ensure software reliability and stability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单元测试和集成测试及其用法，它们是确保软件可靠性和稳定性的主要工具
- en: Understanding the basics of **test-driven development** (**TDD**) and how and
    why it can dramatically reduce the probability of undiscovered bugs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**测试驱动开发**（**TDD**）的基本原理以及它如何以及为什么可以显著降低未发现错误的概率
- en: Functional tests, which are the main tool for enforcing software specifications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试，这是强制执行软件规范的主要工具
- en: Defining C# test-specific projects in Visual Studio to take full advantage of
    the testing tools available in the .NET ecosystem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中定义C#测试特定项目以充分利用.NET生态系统中可用的测试工具
- en: Automating functional tests in C#
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化C#中的功能测试
- en: This chapter will not only teach you the different types of tests and how to
    implement them but also how to effectively apply these techniques in your role
    as a .NET software architect to build robust, scalable enterprise applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不仅将教你不同类型的测试及其实现方法，还将教你如何有效地将这些技术应用于你的.NET软件架构师角色，以构建健壮、可扩展的企业应用程序。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2022 free Community Edition or better,
    with all database tools installed. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2022免费社区版或更高版本，并安装所有数据库工具。本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到。
- en: Understanding unit and integration tests
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单元测试和集成测试
- en: 'Testing is an essential part of software development since it verifies both
    that the software is bug-free and that it conforms to the agreed specification.
    Delaying application testing until immediately after most of the application’s
    functionalities have been implemented in their entirety must be avoided for the
    following reasons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个基本组成部分，因为它验证软件是否无错误以及是否符合约定的规范。在应用程序的大部分功能完全实现后立即进行应用程序测试的做法必须避免，以下是一些原因：
- en: If a class or module has been incorrectly designed or implemented, it might
    have already influenced the way other modules were implemented. Therefore, at
    this point, fixing the problem might have a very high cost.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类或模块设计或实现不当，它可能已经影响了其他模块的实现方式。因此，在这个阶段，修复问题可能代价非常高。
- en: The possible combination of input that is needed to test all possible paths
    that execution can take grows exponentially with the number of modules or classes
    that are tested together. Thus, for instance, if the execution of a class method
    `A` can take three different paths, while the execution of another method `B`
    can take four paths, then testing `A` and `B` together would require 3 x 4 different
    inputs. In general, if we test several modules together, the total number of paths
    to test is the product of the number of paths to test in each module. If modules
    are tested separately, instead, the number of inputs required is just the sum
    of the paths needed to test each module. That’s why so-called unit tests verify
    each class method separately in an exhaustive way as soon as each class is designed.
    After that, the overall behavior correctness can be verified with an acceptably
    small number of so-called *integration tests*, *because integration tests* just
    need to verify the various classes’ interaction patterns without analyzing all
    methods’ execution paths.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要测试所有可能执行路径的输入组合数量会随着测试的模块或类的数量呈指数增长。例如，如果一个类方法 `A` 的执行可以采取三条不同的路径，而另一个方法 `B`
    的执行可以采取四条路径，那么同时测试 `A` 和 `B` 就需要 3 x 4 种不同的输入。一般来说，如果我们一起测试几个模块，需要测试的总路径数是每个模块测试路径数的乘积。如果模块分别测试，所需的输入数量只是测试每个模块所需路径的总和。这就是为什么所谓的单元测试会在每个类设计完成后立即以详尽的方式分别验证每个类方法。之后，可以通过接受的小数量所谓的
    *集成测试* 来验证整体行为的正确性，因为集成测试只需要验证各种类的交互模式，而不需要分析所有方法的执行路径。
- en: If a test of an aggregate made of *N* modules fails, then locating the origin
    of the bug among the *N* modules is usually a very time-consuming activity.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个由 *N* 个模块组成的聚合体测试失败，那么在 *N* 个模块中定位错误源头通常是一个非常耗时的活动。
- en: When *N* modules are tested together, we have to redefine all tests involving
    the *N* modules, even if just one of the *N* modules changes during the application’s
    life cycle.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一起测试 *N* 个模块时，我们必须重新定义涉及 *N* 个模块的所有测试，即使应用程序生命周期中只有一个 *N* 个模块发生变化。
- en: These considerations show that we need both to test each class method separately
    as soon as possible and to test for correct module integration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑表明，我们需要尽快分别测试每个类方法，并且还需要测试正确的模块集成。
- en: 'That is why tests are organized into three stages, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，测试被组织成三个阶段，如下所示：
- en: '**Unit tests**: These verify that all or almost all execution paths of each
    method behave properly. They should be free from external dependencies, such as
    storage and databases, and should be quite complete; that is, they should cover
    most of the possible paths. This is usually feasible at an acceptable time cost
    because there are not too many possible execution paths for each method as compared
    to the possible execution paths of the whole application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试验证每个方法的所有或几乎所有执行路径的行为是否正常。它们应该没有外部依赖，例如存储和数据库，并且应该相当完整；也就是说，它们应该覆盖大多数可能的路径。这通常在可接受的时间成本内是可行的，因为与整个应用程序的可能执行路径相比，每个方法可能的执行路径并不多。'
- en: '**Integration tests**: These are executed once the software passes all its
    unit tests. Integration tests verify that all modules interact properly to get
    the expected results. Integration tests do not need to be complete since unit
    tests will have already verified that all the execution paths of each module work
    properly. They need to verify as many patterns of interaction as possible, that
    is, as many ways in which the various modules may cooperate.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试在软件通过所有单元测试后执行。集成测试验证所有模块是否能够正确交互以获得预期结果。由于单元测试已经验证了每个模块的所有执行路径都正常工作，因此集成测试不需要完全覆盖。它们需要验证尽可能多的交互模式，即各种模块可能合作的各种方式。'
- en: '**Acceptance tests**: These are executed at the end of each sprint and/or before
    releasing the application. They verify that the output of a sprint or the final
    application satisfies both functional and non-functional requirements. Tests that
    verify functional requirements are called **functional tests**, while tests that
    verify performance requirements are called **performance tests**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：这些测试在每个冲刺的末尾以及/或发布应用程序之前执行。它们验证冲刺输出或最终应用程序是否满足功能性和非功能性要求。验证功能性要求的测试称为**功能测试**，而验证性能要求的测试称为**性能测试**。'
- en: 'Usually, each interaction pattern has more than one test associated with it:
    a typical activation of a pattern and some extreme cases of activation. For instance,
    if a whole pattern of interaction receives an array as input, we will write a
    test for the typical size of the array, a test with a `null` array, a test with
    an empty array, and a test with a very big array. This way, we verify that the
    way the single module was designed is compatible with the needs of the whole interaction
    pattern. It is worth pointing out that, in our array example, `null`, `0`, `1`,
    and *many* are equivalence classes that represent the whole universe of array
    values in an efficacious way.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个交互模式都与多个测试相关联：一个典型的模式激活和一些激活的极端情况。例如，如果一个完整的交互模式接收一个数组作为输入，我们将为典型大小的数组编写一个测试，一个`null`数组的测试，一个空数组的测试，以及一个非常大的数组的测试。这样，我们验证单个模块的设计方式是否与整个交互模式的需求兼容。值得注意的是，在我们的数组示例中，`null`、`0`、`1`和*许多*是等价类，它们以有效的方式代表了数组值的整个宇宙。
- en: With the preceding strategy in place, if we modify a single module without changing
    its public interface, we need to change the unit tests for that module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施上述策略的情况下，如果我们修改单个模块而不改变其公共接口，我们需要更改该模块的单元测试。
- en: If, instead, the change involves the way some modules interact, then we also
    have to add new integration tests or modify existing ones. However, usually, this
    is not a big problem since most of the tests are unit tests, so rewriting a large
    percentage of all integration tests does not require too much effort. Moreover,
    if the application was designed according to the **Single Responsibility**, **Open/Closed**,
    **Liskov Substitution**, **Interface Segregation**, or **Dependency Inversion**
    (**SOLID**) principles, the number of integration tests that must be changed after
    a single code modification should be small since the modification should affect
    just a few classes that interact directly with the modified method or class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，相反，更改涉及某些模块交互的方式，那么我们也必须添加新的集成测试或修改现有的测试。然而，通常这并不是一个大问题，因为大多数测试都是单元测试，所以重写大部分集成测试并不需要太多的努力。此外，如果应用程序是根据**单一职责**、**开闭原则**、**里氏替换原则**、**接口隔离原则**或**依赖倒置原则**（**SOLID**）设计的，那么在单次代码修改后必须更改的集成测试数量应该很小，因为修改应该只影响直接与修改的方法或类交互的几个类。
- en: Automating unit and integration tests
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化单元和集成测试
- en: At this point, it should be clear that both unit tests and integration tests
    will be reused during the entire lifetime of the software. That is why it is worth
    automating them. The automation of unit and integration tests avoids the possible
    errors of manual test execution and saves time. A whole battery of several thousand
    automated tests can verify software integrity following each small modification
    in a few minutes, thereby enabling the frequent changes needed in the CI/CD cycles
    of modern software.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，应该很清楚，单元测试和集成测试在整个软件生命周期中都将被重用。这就是为什么自动化它们值得。单元和集成测试的自动化避免了手动测试执行可能出现的错误，并节省了时间。数千个自动化测试的整个系列可以在几分钟内验证软件的完整性，从而使得现代软件的CI/CD周期中需要的频繁更改成为可能。
- en: As new bugs are found, new tests are added to discover them so that they cannot
    reappear in future versions of the software. This way, automated tests always
    become more reliable and protect the software more from bugs added as a result
    of new changes. Thus, the probability of adding new bugs (that are not immediately
    discovered) is greatly reduced.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新错误的发现，会添加新的测试来发现它们，以确保它们不会在未来版本的软件中再次出现。这样，自动化测试始终变得更加可靠，并使软件免受新更改导致的错误的影响。因此，添加新错误（未立即发现）的概率大大降低。
- en: The next subsection will give us the basics for organizing and designing automated
    unit and integration tests, as well as practical details on how to write a test
    in C# in the *Defining C# test projects in Visual Studio* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将为我们提供组织和设计自动化单元和集成测试的基础，以及在“在 Visual Studio 中定义 C# 测试项目”部分中如何编写测试的实用细节。
- en: Writing automated (unit and integration) tests
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自动化（单元和集成）测试
- en: Tests are not written from scratch; all software development platforms have
    tools that help us to both write tests and launch them (or some of them). Once
    the selected tests have been executed, these tools usually show a report and offer
    the possibility to debug the code of all failed tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不是从头开始编写的；所有软件开发平台都有工具帮助我们编写测试并运行它们（或其中一些）。一旦选定的测试被执行，这些工具通常会显示报告并提供调试所有失败测试代码的可能性。
- en: 'More specifically, by and large, all unit and integration test frameworks are
    composed of three important parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，总的来说，所有单元和集成测试框架都由三个重要的部分组成：
- en: '**Facilities for defining all tests**: They verify whether the actual results
    correspond to the expected results. Usually, a test is organized into test classes,
    where each test call tests either a single application class or a single class
    method. Each test is split into three stages:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义所有测试的设施**: 它们验证实际结果是否与预期结果相符。通常，一个测试被组织成测试类，其中每个测试调用测试单个应用程序类或单个类方法。每个测试分为三个阶段：'
- en: '**Test preparation (***Arrange***)**: The general environment needed by the
    test is prepared. This stage only prepares the global environment for tests, such
    as objects to inject into class constructors or simulations of database tables;
    it doesn’t prepare the individual inputs for each of the methods we’re going to
    test. Usually, the same preparation procedure is used in several tests, so test
    preparations are factored out into dedicated modules.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试准备（**安排****）**: 准备测试所需的一般环境。此阶段仅准备测试的全局环境，例如注入到类构造函数中的对象或数据库表的模拟；它不准备我们将要测试的每个方法的个别输入。通常，相同的准备程序在多个测试中使用，因此测试准备被提取到专门的模块中。'
- en: '**Test execution (***Act***/***Assert***)**: The methods to test are invoked
    with adequate input (*Act*), and all results of their executions are compared
    with expected results (*Assert*) with constructs such as `Assert.Equal(x,y)` and
    `Assert.NotNull(x)`.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试执行（**执行**/**断言****）**: 要测试的方法使用适当的输入（**执行**）被调用，并且它们的执行结果通过诸如 `Assert.Equal(x,y)`
    和 `Assert.NotNull(x)` 等构造与预期结果（**断言**）进行比较。'
- en: '**Tear-down**: The whole environment is cleaned up to avoid the execution of
    a test influencing other tests. This step is the converse of *step 1*.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理**: 整个环境被清理，以避免测试的执行影响其他测试。这一步是 *步骤 1* 的逆操作。'
- en: '**Mock facilities**: While integration tests use all (or almost all) classes
    involved in a pattern of object cooperation, in unit tests, the use of other application
    classes should be avoided because their purpose is to test each isolated method.
    Thus, if a class under test, say, `A`, uses a method of another application class,
    `B`, that is injected into its constructor in one of its methods, `M`, and then,
    in order to test `M`, we must inject a fake implementation of `B`. It is worth
    pointing out that only classes that do some processing cannot be used by other
    classes being unit tested, while pure data classes can. Mock frameworks contain
    facilities to define implementations of interfaces and interface methods that
    return data that can be defined by the test designer. Typically, mock implementations
    are also able to report information on all mock method calls. Such mock implementations
    do not require the definition of actual class files but are done online in the
    test code by calling methods such as `new Mock<IMyInterface>()`.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟设施**: 虽然集成测试使用所有（或几乎所有）参与对象合作模式的类，但在单元测试中，应避免使用其他应用程序类，因为它们的目的是测试每个独立的方法。因此，如果正在测试的类，例如
    `A`，在其方法 `M` 中使用另一个应用程序类 `B` 的方法，该类通过其构造函数注入，为了测试 `M`，我们必须注入 `B` 的模拟实现。值得注意的是，只有执行某些处理的类不能被正在单元测试的其他类使用，而纯数据类可以。模拟框架包含定义接口及其方法实现的设施，这些实现可以由测试设计者定义的数据。通常，模拟实现也能够报告所有模拟方法调用的信息。这样的模拟实现不需要定义实际的类文件，而是在测试代码中通过调用如
    `new Mock<IMyInterface>()` 等方法在线完成。'
- en: '**Execution and reporting tool**: This is a visual configuration-based tool
    that the developer may use to decide which tests to launch and when to launch
    them. Moreover, it also shows the final outcome of the tests as a report containing
    all successful tests, all failed tests, each test’s execution time, and other
    information that depends on the specific tool and how it was configured. Usually,
    execution and reporting tools that are executed in development IDEs, such as Visual
    Studio, also give you the possibility of launching a debug session on each failed
    test.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行和报告工具**：这是一个基于视觉配置的工具，开发者可以使用它来决定要启动哪些测试以及何时启动它们。此外，它还以包含所有成功测试、所有失败测试、每个测试的执行时间以及其他依赖于特定工具及其配置的信息的报告形式显示测试的最终结果。通常，在开发IDE（如Visual
    Studio）中执行的和报告的工具还提供了在每个失败的测试上启动调试会话的可能性。'
- en: Since only interfaces allow a complete mock definition of all their methods,
    we should inject interfaces or pure data classes (that don’t need to be mocked)
    in class constructors and methods if we want to mock all dependencies in our unit
    tests. Therefore, for each cooperating class that we want to inject into another
    class and that we want to mock, we must define a corresponding interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有接口允许完全模拟所有方法，因此如果我们想在单元测试中模拟所有依赖项，我们应该在类构造函数和方法中注入接口或纯数据类（不需要模拟）。因此，对于每个我们想要注入到另一个类中并想要模拟的协作类，我们必须定义一个相应的接口。
- en: Moreover, classes should use instances that are injected in their constructors
    or methods and not class instances available in the public static fields of other
    classes; otherwise, the results of the unit tests might appear not to be deterministic
    since these static values might not be set properly during the tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类应该使用在它们的构造函数或方法中注入的实例，而不是其他类公共静态字段中可用的类实例；否则，单元测试的结果可能看起来不是确定的，因为这些静态值可能在测试期间没有正确设置。
- en: The subsection that follows focuses on functional and performance tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将重点介绍功能和性能测试。
- en: 'Acceptance tests: writing functional and performance tests'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试：编写功能和性能测试
- en: Acceptance tests define the contract between the project stakeholders and the
    development team. They are used to verify that the software developed actually
    behaves as it was agreed it would. Acceptance tests verify not only functional
    specifications but also constraints on the software usability and **user interface**
    (**UI**). Since they also have the purpose of showing how the software appears
    and behaves on actual computer monitors and displays, they are never completely
    automatic but consist mainly of lists of recipes and verifications that must be
    followed by an operator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试定义了项目利益相关者和开发团队之间的合同。它们被用来验证开发的软件实际上表现如预期。接受测试不仅验证功能规范，还验证软件可用性和**用户界面**（**UI**）的约束。由于它们还有展示软件在真实计算机监视器和显示器上如何显示和表现的目的，因此它们永远不会完全自动化，主要由必须由操作员遵循的食谱和验证列表组成。
- en: Sometimes, automatic **functional tests** are developed to verify just functional
    requirements, but some of these tests may also bypass the UI and inject the test
    input directly into the logic that is immediately behind the user interface. For
    instance, in the case of an ASP.NET Core MVC application (see *Chapter 17*, *Presenting
    ASP.NET Core*), the whole website can be run in a complete environment that includes
    all the necessary storage filled with test data. Input is not provided to HTML
    pages but is injected directly into the ASP.NET Core controllers. Tests that bypass
    the user interface are called subcutaneous tests. ASP.NET Core supplies various
    tools to perform subcutaneous tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动**功能测试**被开发来仅验证功能需求，但其中一些测试也可能绕过UI，直接将测试输入注入到用户界面后面的逻辑中。例如，在ASP.NET Core
    MVC应用程序的情况下（见*第17章*，*展示ASP.NET Core*），整个网站可以在一个包含所有必要存储并填充测试数据的完整环境中运行。输入不是提供给HTML页面，而是直接注入到ASP.NET
    Core控制器中。绕过用户界面的测试被称为皮下测试。ASP.NET Core提供各种工具来执行皮下测试。
- en: 'If possible, most automated acceptance tests should be defined as subcutaneous
    tests for the following reasons:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，大多数自动接受测试应该定义为皮下测试，以下是一些原因：
- en: Automating the actual interaction with the user interface is a very time-consuming
    task.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化与用户界面的实际交互是一个非常耗时的工作。
- en: User interfaces are changed frequently to improve their usability and to add
    new features, and small changes in a single application screen may force a complete
    rewrite of all tests that operate on that screen.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户界面经常被修改以提升其可用性并添加新功能，单个应用程序屏幕上的微小更改可能迫使对该屏幕上运行的全部测试进行完全重写。
- en: In a few words, user interface tests are very expansive and have low reusability,
    so usually, complete adherence to specifications is tested with subcutaneous tests,
    and full tests involving the whole user interface are performed just to test the
    more common and/or more error-prone scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，用户界面测试成本很高且可重用性低，因此通常使用辅助测试来完全遵守规范，而完整的测试则涉及整个用户界面，仅用于测试更常见和/或更容易出错的情况。
- en: A common approach for testing the user interface is the usage of playback tools
    like **Selenium IDE** ([https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/))
    during manual tests so that each manual test can be repeated automatically. It’s
    likely that the code generated automatically by such tools is not robust enough
    to resist non-trivial changes in the HTML. The Selenium IDE playback code tries
    to resist HTML changes by attempting several selectors to identify each HTML element,
    but this only helps with small changes. Therefore, in general, playback code can
    be reused only for the parts of the application UI that are not affected by changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用户界面的常见方法是在手动测试期间使用回放工具，如 **Selenium IDE** ([https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/))，这样每个手动测试都可以自动重复。这样的工具自动生成的代码可能不够健壮，无法抵抗
    HTML 中的非平凡变化。Selenium IDE 的回放代码试图通过尝试多个选择器来识别每个 HTML 元素，以抵抗 HTML 变化，但这仅有助于小范围的变化。因此，通常，回放代码只能用于应用程序
    UI 中不受变化影响的那些部分。
- en: The Selenium software may also be used programmatically, that is, by describing
    user interface tests directly in the code. Selenium will be discussed in more
    detail in the *Automating functional tests in C#* section, while functional tests,
    in general, are discussed in the *Functional tests* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 软件也可以通过编程方式使用，即通过在代码中直接描述用户界面测试。Selenium 将在 *使用 C# 自动化功能测试* 部分中更详细地讨论，而功能测试通常在
    *功能测试* 部分中讨论。
- en: '**Performance tests** apply a fake load to an application to see whether it
    can handle the typical production load, discover its load limits, and locate bottlenecks.
    The application is deployed in a staging environment that is a copy of the actual
    production environment in terms of hardware resources.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能测试**通过对应用程序施加模拟负载来查看其是否能够处理典型的生产负载，发现其负载限制，并定位瓶颈。应用程序部署在一个临时环境中，该环境在硬件资源方面是实际生产环境的副本。'
- en: Then, fake requests are created and applied to the system, and response times
    and other metrics are collected. Fake request batches should have the same composition
    as the actual production batches. They can be generated from the actual production
    request logs if they are available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建并应用模拟请求到系统中，并收集响应时间和其他指标。模拟请求批次应与实际生产批次具有相同的组成。如果可用，它们可以从实际生产请求日志中生成。
- en: If response times are not satisfactory, other metrics are collected to discover
    possible bottlenecks (low memory, slow storage, or slow software modules). Once
    located, a software component that is responsible for the problem can be analyzed
    in the debugger to measure the execution time of the various method calls involved
    in a typical request.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应时间不令人满意，则会收集其他指标以发现可能的瓶颈（内存低、存储慢或软件模块慢）。一旦定位到，负责问题的软件组件就可以在调试器中进行分析，以测量典型请求中涉及的各个方法调用的执行时间。
- en: Failures in the performance tests may lead either to a redefinition of the hardware
    needed by the application or to the optimization of some software modules, classes,
    or methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试中的失败可能导致重新定义应用程序所需的硬件，或者对某些软件模块、类或方法进行优化。
- en: Both Azure and Visual Studio offer tools to create fake loads and to report
    execution metrics. However, they have been declared obsolete and will be discontinued,
    so we will not describe them. As an alternative, there are both open-source and
    third-party tools that can be used. Some of them are listed in the *Further reading*
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 和 Visual Studio 都提供创建模拟负载和报告执行指标的工具。然而，它们已被宣布为过时，并将被停止使用，因此我们不会描述它们。作为替代，有开源和第三方工具可以使用。其中一些在
    *进一步阅读* 部分中列出。
- en: The next section describes a software development methodology that plays a central
    role in tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将描述一种在测试中扮演核心角色的软件开发方法。
- en: Understanding the basics of test-driven development
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试驱动开发的基本原理
- en: '**Test-driven development** (**TDD**) is a software development methodology
    that gives a central role to unit tests. According to this methodology, unit tests
    are a formalization of the specifications of each class, so they must be written
    before the code of the class. Actually, a full test that covers all code paths
    univocally defines the code behavior, so it can be considered a specification
    for the code. It is not a formal specification that defines the code behavior
    through some formal language but a specification based on examples of behavior.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种软件开发方法，其中单元测试扮演着核心角色。根据这种方法，单元测试是每个类规范的正式化，因此它们必须在类的代码之前编写。实际上，一个覆盖所有代码路径的完整测试明确定义了代码行为，因此它可以被视为代码的规范。这不是通过某种正式语言定义代码行为的正式规范，而是一种基于行为示例的规范。'
- en: The ideal way to test software would be to write formal specifications of the
    whole software behavior and to verify with some wholly automatic tools whether
    the software that was actually produced conforms to them. In the past, some research
    effort was spent defining formal languages for describing code specifications,
    but expressing the behavior the developer has in mind with similar languages was
    a very difficult and error-prone task. Therefore, these attempts were quickly
    abandoned in favor of approaches based on examples. At that time, the main purpose
    was the automatic generation of code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件的理想方式是编写整个软件行为的正式规范，并使用一些完全自动化的工具来验证实际产生的软件是否符合这些规范。在过去，一些研究工作被投入到定义用于描述代码规范的正式语言中，但用类似的语言表达开发者心中的行为是非常困难和容易出错的。因此，这些尝试很快就被基于示例的方法所取代。当时，主要目的是自动生成代码。
- en: Nowadays, automatic code generation has been largely abandoned and survives
    in small application areas, such as the creation of device drivers. In these areas,
    the effort of formalizing the behavior in a formal language is worth the time
    saved in trying to test difficult-to-reproduce behaviors of parallel threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，自动代码生成已被大量放弃，仅在少数应用领域幸存，例如设备驱动程序的创建。在这些领域，用正式语言形式化行为所花费的努力值得在尝试测试难以复现的并行线程行为时节省的时间。
- en: Unit tests were initially conceived as a way to encode example-based specifications
    in a completely independent way as part of a specific agile development methodology
    called **extreme programming**. However, since TDD proved to be very efficacious
    in preventing bugs, nowadays, TDD is used independently of extreme programming
    and is included as an obligatory prescription in other agile methodologies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最初被构想为一种方式，以完全独立的方式将基于示例的规范编码为特定敏捷开发方法（**极限编程**）的一部分。然而，由于TDD被证明在防止错误方面非常有效，如今，TDD被独立于极限编程使用，并作为其他敏捷方法中的强制性规定。
- en: The practice of TDD proved that well-designed initial unit tests are enough
    to ensure an acceptable level of software stability, despite the fact that, usually,
    initial tests are not a “perfect” specification of the code. However, it is undoubtedly
    true that unit tests refined after finding hundreds of bugs act as reliable and
    substantially perfect code specifications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的实践证明，精心设计的初始单元测试足以确保软件达到可接受的稳定性水平，尽管通常初始测试并不是代码的“完美”规范。然而，无疑的事实是，在发现数百个错误后经过细化的单元测试作为可靠且实质上完美的代码规范。
- en: Well-designed unit tests can’t be based on random inputs since you might need
    an infinite or at least an immense number of examples to define a code’s behavior
    this way univocally. However, the behavior can be defined with an acceptable number
    of inputs if you have all possible execution paths in mind. In fact, at this point,
    it is enough to select a typical example for each execution path.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 精心设计的单元测试不能基于随机输入，因为你可能需要无限或至少是大量的示例来以这种方式明确地定义代码的行为。然而，如果你考虑到了所有可能的执行路径，行为可以用可接受的输入数量来定义。实际上，在这个点上，选择每个执行路径的典型示例就足够了。
- en: 'That’s why writing a unit test for a method after that method has been completely
    coded is easy: it simply requires the selection of a typical instance for each
    execution path of the already-existing code. However, writing unit tests this
    way does not protect from errors in the design of the execution paths themselves.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么在方法完全编码之后编写该方法的单元测试很容易：它只需要为现有代码的每个执行路径选择一个典型实例。然而，以这种方式编写单元测试并不能防止执行路径设计本身的错误。
- en: Therefore, a unit test must be written before a method has been completely coded,
    but while writing unit tests, the developer must somehow forecast all execution
    paths by looking for extreme cases and by possibly adding more examples than are
    strictly needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在方法完全编码之前必须编写单元测试，但在编写单元测试时，开发者必须通过寻找极端情况并可能添加比严格需要的更多示例来预测所有执行路径。
- en: 'For instance, while writing the code that sorts an array, we might start considering
    all possible extreme cases we are able to forecast before any line of useful method
    code has been written, that is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在编写排序数组的代码时，我们可能会在编写任何有用的方法代码之前考虑所有可能预测的极端情况，即：
- en: An empty array
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空数组
- en: A null array
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空数组
- en: A single-element array
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只有一个元素的数组
- en: An array with a few elements
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只有几个元素的数组
- en: An array with several elements
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含几个元素的数组
- en: An already-ordered array
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已经排序的数组
- en: A partially ordered array
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个部分排序的数组
- en: An extremely unordered array
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个极度无序的数组
- en: After the first version of the algorithm has been written and passes all of
    the above tests, other inputs that might cause different execution paths might
    be discovered by analyzing all execution paths. If this is the case, we add a
    new unit test for each different execution path discovered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第一版编写并通过上述所有测试之后，通过分析所有执行路径可能会发现可能导致不同执行路径的其他输入。如果这种情况发生，我们将为发现的每个不同执行路径添加一个新的单元测试。
- en: For instance, in the case of the array sorting method, suppose that we use a
    divide-and-conquer algorithm, like merge-sort, that recursively splits the array
    into two halves to recursively reduce the problem to a simpler one. For sure,
    the way that arrays with even or odd lengths are processed will be different,
    so we must add at least two new tests, one with an even-length array and the other
    with an odd-length array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数组排序方法的情况下，假设我们使用像归并排序这样的分而治之算法，该算法递归地将数组分成两半，以递归地将问题简化为一个更简单的问题。当然，处理长度为偶数或奇数的数组的方式将不同，因此我们必须至少添加两个新的测试，一个用于偶数长度的数组，另一个用于奇数长度的数组。
- en: However, as developers can make mistakes while writing application code, they
    can also make mistakes in forecasting all possible execution paths while designing
    unit tests!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于开发者在编写应用程序代码时可能会犯错，他们在设计单元测试时预测所有可能的执行路径时也可能犯错！
- en: 'It seems we have identified a possible drawback of TDD: unit tests themselves
    may be wrong. That is, not only application code but also its associated TDD unit
    tests may be inconsistent with the behavior the developer has in mind. Therefore,
    in the beginning, unit tests can’t be considered software specifications but rather
    a possibly incorrect and incomplete description of the software behavior.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经识别了TDD的一个可能的缺点：单元测试本身可能是错误的。也就是说，不仅应用程序代码，而且与其相关的TDD单元测试可能与开发者的预期行为不一致。因此，在开始时，单元测试不能被视为软件规范，而是一种可能不正确和不完整的软件行为描述。
- en: 'Therefore, we have two descriptions of the behavior we have in mind: the application
    code itself and its TDD unit tests that were written before the application code.
    However, this is not an issue because the theory of probability helps us!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种关于我们预期行为的行为描述：应用程序代码本身以及在其之前编写的TDD单元测试。然而，这不是问题，因为概率论帮助我们！
- en: What makes TDD work well in practice is the fact that the probability of making
    exactly the same error while writing the tests and while writing the code is very
    low. Therefore, whenever a test fails, there is an error either in the tests or
    in the application code, and conversely, if there is an error either in the application
    code or in the test, there is a very high probability that a test will fail. That
    is, the use of TDD ensures that most bugs are found immediately!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在实践中能够很好地工作的事实是，在编写测试和编写代码时犯完全相同错误的概率非常低。因此，每当测试失败时，测试或应用程序代码中就存在错误，反之亦然，如果应用程序代码或测试中存在错误，那么测试失败的概率非常高。也就是说，使用TDD确保大多数错误都能立即被发现！
- en: Now that we have understood why TDD is efficacious in preventing bugs and have
    learned how to select the inputs for our unit tests, we can move to the description
    of the TDD-based code-writing process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了TDD如何有效地防止错误，并且已经学会了如何选择单元测试的输入，我们可以转向基于TDD的代码编写过程的描述。
- en: 'Writing a class method or a chunk of code, say for finding the maximum of an
    array of integers with TDD, is a loop composed of three stages:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD编写一个类方法或一段代码，比如用TDD找到整数数组的最大值，是一个由三个阶段组成的循环：
- en: '**Red stage**: At this stage, the developer writes an empty method, say `MaximumGrade`,
    that throws `NotImplementedException`, and also writes new unit tests for this
    method. These tests must necessarily fail because, at this time, no code implements
    the behavior they describe:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**红色阶段**：在这个阶段，开发者编写一个空方法，比如`MaximumGrade`，它抛出`NotImplementedException`，并为这个方法编写新的单元测试。这些测试必然会失败，因为在这个时候，没有任何代码实现了它们所描述的行为：'
- en: '[PRE0]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Green stage**: In this stage, the developer writes the minimum code or makes
    the minimum modifications to existing code necessary to make all unit tests pass.
    Say we test `MaximumGrade` with a null array, an array with `0` elements, an array
    with just one element, and an array with several elements; the code that passes
    all tests might be:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绿色阶段**：在这个阶段，开发者编写最少的代码或对现有代码进行最少的修改，以确保所有单元测试通过。比如说，我们用空数组、包含`0`个元素的数组、只有一个元素的数组和包含多个元素的数组来测试`MaximumGrade`；通过所有测试的代码可能如下所示：'
- en: '[PRE1]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Refactoring stage**: Once the test is passed, the code is refactored to ensure
    good code quality and the application of best practices and patterns. In particular,
    in this stage, some code can be factored out in other methods or other classes.
    During this stage, we may also discover the need for other unit tests because
    new execution paths or new extreme cases are discovered or created. In the case
    of `MaximumGrade`, at this stage, we might notice the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构阶段**：一旦测试通过，代码就会重构以确保良好的代码质量、应用最佳实践和模式。特别是，在这个阶段，某些代码可以被提取到其他方法或其他类中。在这个阶段，我们可能会发现需要其他单元测试，因为发现了新的执行路径或新的极端情况。在`MaximumGrade`的情况下，在这个阶段，我们可能会注意到以下情况：'
- en: Instead of returning 0 when the array is `null`, it would be better to define
    a new exception and throw it.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数组为`null`时，而不是返回`0`，定义一个新的异常并抛出它会更好。
- en: '`foreach` is more efficient and more readable than `for`.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach`比`for`更高效、更易读。'
- en: 'What if all numbers are negative? We must create a new test with an array of
    negative numbers:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有数字都是负数怎么办？我们必须为负数数组创建一个新的测试：
- en: '[PRE2]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The loop stops as soon as all tests pass without writing new code or modifying
    the existing code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试通过，而无需编写新代码或修改现有代码，循环就会停止。
- en: 'When we repeat the red stage, the newly added test for the negative array will
    fail because of our inadequate initialization:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重复红色阶段时，由于我们的初始化不足，新添加的针对负数数组的测试将会失败：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we need to replace it with:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将其替换为：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, all tests pass again, and we move to the green stage again.
    There is no need for further refactoring, so the refactoring stage doesn’t modify
    our code, meaning we can exit the test loop: we are done!'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，所有测试再次通过，我们再次进入绿色阶段。没有必要进行进一步的重构，所以重构阶段不会修改我们的代码，这意味着我们可以退出测试循环：我们完成了！
- en: Sometimes, it is very difficult to design the initial unit tests because it
    is quite difficult to imagine how the code might work and the execution paths
    it might take. In this case, you can get a better understanding of the specific
    algorithm to use by writing an initial sketch of the method code. In this initial
    stage, we need to focus just on the main execution path, completely ignoring extreme
    cases and input verifications. Once we get a clear picture of the main ideas behind
    an algorithm that should work, we can enter the standard three-stage TDD loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，设计初始单元测试非常困难，因为很难想象代码可能如何工作以及它可能采取的执行路径。在这种情况下，你可以通过编写方法代码的初始草图来更好地理解要使用的特定算法。在这个初始阶段，我们只需要关注主要的执行路径，完全忽略极端情况和输入验证。一旦我们清楚地了解了应该工作的算法背后的主要思想，我们就可以进入标准的三个阶段的TDD循环。
- en: The next section discusses functional tests in detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将详细讨论功能测试。
- en: Functional tests
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: These tests use the same techniques and tools as unit and integration tests
    but differ from them in that they are run only at the end of each sprint. They
    have the fundamental role of verifying that the current version of the entire
    software complies with its specifications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试使用与单元测试和集成测试相同的技巧和工具，但它们的不同之处在于它们只在每个冲刺的结束时运行。它们的基本作用是验证整个软件的当前版本是否符合其规范。
- en: Since functional tests also involve the UI, they need further tools to simulate,
    somehow, how the user acts in the UI. The need for extra tools is not the only
    challenge the UI brings with it because UIs also see frequent and major changes.
    Thus, we mustn’t design tests that depend on the UI’s graphical details, or we
    might be forced to rewrite all the tests completely at each UI change. We will
    discuss both the tools and the best practices for optimizing UI tests in the *Automating
    functional tests in C#* section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能测试也涉及到用户界面（UI），因此它们需要额外的工具来模拟用户在UI中的行为。需要额外工具的挑战不仅仅是UI带来的，因为UI也经常发生频繁和重大的变化。因此，我们不应该设计依赖于UI图形细节的测试，否则我们可能被迫在每次UI更改时完全重写所有测试。我们将在“在C#中自动化功能测试”部分讨论这两个工具以及优化UI测试的最佳实践。
- en: Anyway, it is worth pointing out that sometimes it is better to renounce automated
    testing for some UI-related features and fall back to manual tests because the
    time investment is not justified by the short life of the UI code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，值得注意的是，有时放弃某些与UI相关的功能的自动化测试，转而进行手动测试会更好，因为UI代码的短暂生命周期并不能证明时间投入是合理的。
- en: 'Whether automatic or manual, functional testing must be a formal process that
    is performed for the following purposes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是自动的还是手动的，功能测试都必须是一个正式的过程，用于以下目的：
- en: Functional tests represent the most important part of the contract between stakeholders
    and the development team, the other part being the verification of non-functional
    specifications. The way this contract is formalized depends on the nature of the
    relationship between the development team and stakeholders.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试代表了利益相关者和开发团队之间合同的最重要部分，另一部分是对非功能规范的验证。这个合同如何正式化取决于开发团队和利益相关者之间关系的性质。
- en: In the case of a supplier-customer relationship, the functional tests become
    part of the supplier-customer business contract for each sprint, and a team that
    works for the customer writes them. If the tests fail, then the sprint is rejected,
    and the supplier must run a supplementary sprint to fix all problems.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在供应商-客户关系的案例中，功能测试成为每个冲刺的供应商-客户业务合同的一部分，由为顾客工作的团队编写。如果测试失败，则该冲刺被拒绝，供应商必须运行一个补充冲刺来解决所有问题。
- en: If there is no supplier-customer business relationship because the development
    team and the stakeholder belong to the same company, there is no business contract.
    In this case, the stakeholder, together with the team, writes an internal document
    that formalizes the requirements of the sprint. If the tests fail, usually, the
    sprint is not rejected, but the results of the tests are used to drive the specifications
    for the next sprints. Of course, if the failure percentage is high, the sprint
    may be rejected and should be repeated.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果由于开发团队和利益相关者属于同一家公司而没有供应商-客户业务关系，那么就没有商业合同。在这种情况下，利益相关者与团队一起编写一个内部文档，以正式化冲刺的需求。如果测试失败，通常不会拒绝冲刺，但测试结果将用于驱动下一个冲刺的规范。当然，如果失败率很高，冲刺可能会被拒绝并需要重做。
- en: Formalized functional tests that run at the end of each sprint prevent any results
    achieved in previous sprints from being destroyed by new code.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个冲刺结束时运行的正式化功能测试可以防止之前冲刺中取得的结果被新代码破坏。
- en: When using an agile development methodology, maintaining an updated battery
    of functional tests is the best way to get a formal representation of the final
    system specifications since, during agile development, the specifications of the
    final system are not decided before development starts but are the result of the
    system’s evolution. Agile development and sprints are discussed in detail in *Chapter
    1*, *Understanding the Importance of Software Architecture*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用敏捷开发方法时，维护一个最新的功能测试库是获取最终系统规范正式表示的最佳方式，因为在敏捷开发过程中，最终系统的规范不是在开发开始之前就确定的，而是系统演化的结果。敏捷开发和冲刺将在*第一章*，“理解软件架构的重要性”中详细讨论。
- en: Since the output of the first sprints may differ a lot from the final system
    in these early stages, it is not worth spending too much time writing detailed
    manual tests and/or automatized tests. Therefore, you may limit the user stories
    to just a few examples that will be used both as inputs for software development
    and as manual tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在早期阶段，第一个冲刺的输出可能与最终系统有很大差异，因此不值得花太多时间编写详细的手动测试和/或自动化测试。因此，您可以将用户故事限制为仅几个示例，这些示例将同时用作软件开发输入和手动测试。
- en: 'As system functionalities become more stable, it is worth investing time in
    writing detailed and formal functional tests for them. For each functional specification,
    we must write tests that verify their operation in extreme cases. For instance,
    in a cash withdrawal use case, we must write tests that verify all possibilities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统功能的日益稳定，值得花时间编写详细和正式的功能测试。对于每个功能规范，我们必须编写测试来验证其在极端情况下的操作。例如，在现金取款用例中，我们必须编写测试来验证所有可能性：
- en: Not enough funds
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资金不足
- en: Card expired
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡片过期
- en: Wrong credentials
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误的凭证
- en: Repeated wrong credentials
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复错误的凭证
- en: 'The following diagram sketches the whole process with all possible outcomes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概述了整个流程及其所有可能的结果：
- en: '![Descrizione: Diagram  Description automatically generated](img/B19820_09_01.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![描述：自动生成的描述性图表](img/B19820_09_01.png)'
- en: 'Figure 9.1: Withdrawal example'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：取款示例
- en: The user inserts their card, and the card may be accepted or rejected because
    it has expired. Then, the user tries their PIN with possible errors, so they might
    repeat the PIN entry till either they succeed or they reach a maximum number of
    attempts. Finally, the user enters the amount to withdraw and may get their money
    or a “Not enough funds” error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户插入他们的卡，卡可能被接受或拒绝，因为已经过期。然后，用户尝试他们的PIN码，可能会出现错误，所以他们可能会重复输入PIN码，直到成功或达到最大尝试次数。最后，用户输入取款金额，可能会得到钱或“资金不足”错误。
- en: In the case of manual tests, for each of the preceding scenarios, we must give
    all the details of all the steps involved in each operation and, for each step,
    the expected result.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动测试的情况下，对于上述所有场景，我们必须给出每个操作中涉及的每个步骤的所有细节，并且对于每个步骤，预期的结果。
- en: An important decision is whether you want to automate all or a part of the functional
    tests since it is very expensive to write automated tests that simulate a human
    operator that interacts with a system’s UI. The final decision depends on the
    cost of the test implementation divided by the expected number of times it will
    be used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的决定是您是否想自动化所有或部分功能测试，因为编写模拟与系统UI交互的人类操作员的自动化测试非常昂贵。最终的决定取决于测试实现的成本除以预期的使用次数。
- en: In the case of CI/CD, the same functional test can be executed several times,
    but unluckily, functional tests are strictly tied to the way the UI is implemented,
    and, in modern systems, the UI is changed frequently. Therefore, in this case,
    a test is executed with exactly the same UI no more than a couple of times.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD的情况下，相同的功能测试可以执行多次，但不幸的是，功能测试严格绑定到UI的实现方式，而在现代系统中，UI经常更改。因此，在这种情况下，测试最多只能与完全相同的UI执行几次。
- en: In order to overcome most of the problems related to the UI, some functional
    tests can be implemented as **subcutaneous tests**. Subcutaneous tests are a specific
    type of functional test designed to bypass the UI layer of an application. Instead
    of interacting with the application through its UI, like a user would, these tests
    directly interact with the application’s underlying logic. For example, in an
    ASP.NET Core application, a subcutaneous test might directly invoke the methods
    of a controller – the part of the application that handles incoming requests –
    rather than going through the process of sending these requests via a browser.
    This approach helps us focus on testing the core functionality of the application
    without the complexities of the UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服与UI相关的多数问题，一些功能测试可以实施为**皮下测试**。皮下测试是一种特殊类型的功能测试，旨在绕过应用程序的UI层。这些测试不是像用户一样通过UI与应用程序交互，而是直接与应用程序的下层逻辑交互。例如，在一个ASP.NET
    Core应用程序中，皮下测试可能会直接调用控制器的方法——处理传入请求的应用程序部分——而不是通过浏览器发送这些请求的过程。这种方法有助于我们专注于测试应用程序的核心功能，而不必处理UI的复杂性。
- en: In the user case in *Chapter 21*, *Case Study*, we will see in practice how
    to design subcutaneous tests for an ASP.NET Core application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章的用例中，*案例研究*，我们将看到在实践中如何为ASP.NET Core应用程序设计皮下测试。
- en: Unfortunately, subcutaneous tests can’t verify all possible implementation errors
    since they can’t detect errors in the UI itself. Moreover, in the case of a web
    application, subcutaneous tests usually suffer from other limitations because
    they bypass the whole HTTP protocol.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，皮下测试无法验证所有可能的实现错误，因为它们无法检测UI本身的错误。此外，在Web应用程序的情况下，皮下测试通常还受到其他限制，因为它们绕过了整个HTTP协议。
- en: In particular, in the case of ASP.NET Core applications, which will be described
    in *Chapter 17*, *Presenting ASP.NET Core*, if we call controller action methods
    directly, we bypass the whole ASP.NET Core pipeline that processes each request
    before passing it to the right action method. Therefore, authentication, authorization,
    CORS, and the behavior of other middleware in the ASP.NET Core pipeline will not
    be analyzed by the tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，在描述第17章的*介绍ASP.NET Core*时，如果我们直接调用控制器操作方法，我们将绕过整个ASP.NET Core管道，该管道在将请求传递给正确的操作方法之前处理每个请求。因此，身份验证、授权、CORS以及其他中间件在ASP.NET
    Core管道中的行为将不会被测试分析。
- en: 'A complete automated functional test of a web application should do the following
    things:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的自动化功能测试应该做以下几件事情：
- en: Start an actual browser on the URL to be tested.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要测试的URL上启动一个实际的浏览器。
- en: Wait so that any JavaScript on the page completes its execution.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待，以便页面上的任何JavaScript完成其执行。
- en: Then, send commands to the browser that simulate the behavior of a human operator.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向浏览器发送模拟人类操作员行为的命令。
- en: Finally, after each interaction with the browser, automatic tests should wait
    so that any JavaScript that was triggered by the interaction completes.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在与浏览器交互之后，自动测试应该等待，以便由交互触发的任何JavaScript完成其执行。
- en: Such tests can be executed using browser automatization tools like **Selenium,**
    which will be discussed in the *Automating functional tests in C#* section of
    this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试可以使用像**Selenium**这样的浏览器自动化工具执行，这将在本章的*使用C#自动化功能测试*部分中讨论。
- en: It is worth pointing out that not all user interface tests can be automated
    since no automatic test can verify how the user interface appears and how usable
    it is.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，并非所有用户界面测试都可以自动化，因为没有任何自动测试可以验证用户界面的外观及其可用性。
- en: As we’ve explored the intricacies of functional and subcutaneous testing, it’s
    become clear that a comprehensive testing strategy must encompass not only how
    the tests are performed but also how they are conceptualized and communicated.
    This brings us to **Behavior-Driven Development** (**BDD**), a methodology that
    builds upon the principles of functional testing by emphasizing business value
    and client-side behavior. BDD offers a structured approach to creating tests that
    are more closely aligned with user requirements and business objectives.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索了功能测试和皮下测试的复杂性，我们已经清楚地认识到，全面的测试策略必须涵盖测试的执行方式，以及它们的构思和传达方式。这使我们来到了**行为驱动开发**（**BDD**），这是一种基于功能测试原则的方法，通过强调业务价值和客户端行为来构建。BDD提供了一种结构化的方法来创建与用户需求和业务目标更紧密对齐的测试。
- en: Behavior-Driven Development (BDD)
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）
- en: BDD conforms to the rules of TDD we already described but focuses mainly on
    business value and client-side behavior.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: BDD遵循我们已描述的TDD规则，但主要关注业务价值和客户端行为。
- en: 'We discussed that the strength of unit tests is as follows: “It is very unlikely
    that when describing a behavior in two completely different ways, that is, with
    code and with examples, we might make exactly the same errors, so errors are discovered
    with a probability that is close to 100%.”'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了单元测试的优势如下：“在用两种完全不同的方式描述一个行为时，即用代码和用示例，我们可能会犯完全相同的错误，因此错误被发现的概率接近100%。”
- en: BDD uses the same approach, but the examples used in TDD must not depend on
    the specific way the functionality might be implemented. That is, examples must
    be as close as possible to pure specifications. This way, we are sure tests can’t
    influence the way functionality is implemented and vice versa; we are not influenced
    by pure technical facilities or constraints when writing specifications but focus
    mainly on the user needs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 使用相同的方法，但 TDD 中使用的示例必须不依赖于功能可能实现的具体方式。也就是说，示例必须尽可能接近纯规范。这样，我们可以确保测试不会影响功能实现的方式，反之亦然；我们在编写规范时不受纯技术设施或约束的影响，主要关注用户需求。
- en: 'Moreover, tests should use a vocabulary that can be understood by stakeholders.
    For these reasons, tests are described by a Given-When-Then syntax. The following
    is an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试应使用利益相关者能够理解的语言。出于这些原因，测试使用 Given-When-Then 语法进行描述。以下是一个示例：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Given`, `And`, `When`, and `Then` are keywords, while the remaining text is
    just natural language containing the example data.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Given`、`And`、`When` 和 `Then` 是关键字，而其余文本只是包含示例数据的自然语言。'
- en: The Given-When-Then formal language is called Gherkin. It can be translated
    into code either manually or with tools that are part of toolsets like Cucumber
    ([https://cucumber.io/](https://cucumber.io/)) or SpecFlow in the case of .NET
    projects. SpecFlow is a Visual Studio extension that can be installed from the
    Visual Studio **Extensions** menu. Once installed, it adds a new kind of test
    project, a SpecFlow project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Given-When-Then 正式语言被称为 Gherkin。它可以手动或使用工具集（如 Cucumber [https://cucumber.io/](https://cucumber.io/)）或针对
    .NET 项目的 SpecFlow 等工具进行转换。SpecFlow 是一个可以从 Visual Studio **扩展**菜单安装的 Visual Studio
    扩展。一旦安装，它将添加一种新的测试项目类型，即 SpecFlow 项目。
- en: 'In SpecFlow, Given-When-Then tests are defined in `.feature` files, while natural
    language clauses contained in the description are transformed into code in the
    so-called step files. Step files are automatically created, but the code inside
    of them must be written by the developer. Below is the method that is in charge
    of translating into code the `"Given the first number is 50"` clause:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SpecFlow 中，Given-When-Then 测试是在 `.feature` 文件中定义的，而描述中包含的自然语言子句则被转换成所谓的步骤文件中的代码。步骤文件是自动创建的，但其中的代码必须由开发者编写。以下是将
    `"Given the first number is 50"` 子句转换成代码的方法：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The attribute on top of the method is automatically created by SpecFlow, but
    the (.*) regular expression that extracts the datum from the natural language
    clause must be written by the developer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 方法顶部的属性是由 SpecFlow 自动创建的，但用于从自然语言子句中提取数据的 (.*) 正则表达式必须由开发者编写。
- en: '`_calculator` is a variable that must be created by the developer and that
    contains a class to test:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`_calculator` 是一个必须由开发者创建的变量，它包含一个用于测试的类：'
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once completely defined, SpecFlow tests are run by exploiting an underlying
    test framework supported by .NET. The underlying test framework to use is specified
    when the SpecFlow project is created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完全定义，SpecFlow 测试将通过利用 .NET 支持的底层测试框架来运行。在创建 SpecFlow 项目时指定要使用的底层测试框架。
- en: While BDD and the Gherkin syntax can be used in unit, integration, and functional
    tests, the effort of writing tests in natural language and turning them into code
    is worth it only for functional tests because functional tests must be easily
    understood by stakeholders.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 BDD 和 Gherkin 语法可以在单元、集成和功能测试中使用，但将测试用自然语言编写并转换为代码的努力只对功能测试来说是值得的，因为功能测试必须易于被利益相关者理解。
- en: When writing unit tests, the BDD rule of the independence of tests from the
    implementation improves the tests’ quality and lifetime (fewer tests depend on
    implementation. Thus, they need to be updated less frequently). However, keep
    in mind that the classes that we are unit testing are themselves the result of
    implementation choices, so an excessive obsession with test independence might
    result in a waste of time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，BDD 规则中测试独立于实现的规则提高了测试的质量和生命周期（较少的测试依赖于实现。因此，它们需要更新的频率较低）。然而，请记住，我们正在单元测试的类本身是实施选择的结果，因此过度关注测试独立性可能会导致时间的浪费。
- en: After having described the theory behind testing, we are ready to move to practical
    implementations in C#. In the next section, we will list all test projects available
    in Visual Studio and describe xUnit in detail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了测试背后的理论之后，我们准备转向 C# 中的实际实现。在下一节中，我们将列出 Visual Studio 中所有可用的测试项目，并详细描述 xUnit。
- en: Defining C# test projects in Visual Studio
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中定义 C# 测试项目
- en: 'The .NET SDK contains project templates for three types of unit testing frameworks:
    MSTest, xUnit, and NUnit. When starting the new project wizard in Visual Studio,
    if you want to see the compatible versions of these testing frameworks for .NET
    C# applications, set the **Project type** to **Test**, the **Language** to **C#**,
    and the **Platform** as **Linux**. This configuration will allow you to identify
    and select the appropriate versions of MSTest, xUnit, and NUnit for your project.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK 包含三种类型的单元测试框架的项目模板：MSTest、xUnit 和 NUnit。当在 Visual Studio 中启动新项目向导时，如果您想查看适用于
    .NET C# 应用程序的这些测试框架的兼容版本，请将 **项目类型** 设置为 **测试**，将 **语言** 设置为 **C#**，将 **平台** 设置为
    **Linux**。此配置将允许您识别并选择适合您项目的 MSTest、xUnit 和 NUnit 的适当版本。
- en: 'The following screenshot shows the selection that should appear:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了应该出现的选项：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_09_02.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_09_02.png)'
- en: 'Figure 9.2: Adding a test project'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：添加测试项目
- en: All the preceding projects automatically include the NuGet package for running
    all the tests in the Visual Studio test user interface (Visual Studio test runner).
    However, they do not include any facility for mocking interfaces, so you need
    to add the `Moq` NuGet package, which contains a popular mocking framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的项目都自动包含用于在 Visual Studio 测试用户界面（Visual Studio 测试运行器）中运行所有测试的 NuGet 包。然而，它们不包含任何用于模拟接口的功能，因此您需要添加包含流行模拟框架的
    `Moq` NuGet 包。
- en: All these test projects must contain a reference to the project to be tested.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试项目都必须包含对要测试的项目的引用。
- en: In the next subsection, we will describe **xUnit**, but all three frameworks
    are quite similar and differ mainly in the names of the assert methods and the
    names of the attributes used to decorate various testing classes and methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将描述 **xUnit**，但所有三个框架都非常相似，主要区别在于断言方法的名称以及用于装饰各种测试类和方法的属性的名称。
- en: Using the xUnit test framework
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 xUnit 测试框架
- en: In xUnit, tests are methods decorated with either the `[Fact]` or `[Theory]`
    attributes. Tests are automatically discovered by the test runner, which lists
    all of them in the user interface so the user can run either all of them or just
    a selection of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 xUnit 中，测试是带有 `[Fact]` 或 `[Theory]` 属性的装饰方法。测试由测试运行器自动发现，并在用户界面中列出所有测试，以便用户可以运行所有测试或仅运行其中的一部分。
- en: A new instance of the test class is created before running each test, so the
    *test preparation* code contained in the class constructor is executed before
    each test of the class. If you also require *tear-down code*, the test class must
    implement the `IDisposable` interface so that the tear-down code can be included
    in the `IDisposable.Dispose` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个测试之前，都会创建测试类的新的实例，因此类构造函数中包含的 *测试准备* 代码会在类的每个测试之前执行。如果您还需要 *清理代码*，则测试类必须实现
    `IDisposable` 接口，以便清理代码可以包含在 `IDisposable.Dispose` 方法中。
- en: 'The test code invokes the methods to be tested and then tests the results with
    methods from the `Assert` static class, such as `Assert.NotNull(x)`, `Assert.Equal(x,
    y)`, and `Assert.NotEmpty(IEnumerable x)`. Some methods verify whether a call
    throws an exception of a specific type, for instance:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码调用要测试的方法，然后使用 `Assert` 静态类中的方法测试结果，例如 `Assert.NotNull(x)`、`Assert.Equal(x,
    y)` 和 `Assert.NotEmpty(IEnumerable x)`。一些方法验证是否抛出特定类型的异常，例如：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When an assertion fails, an exception is thrown. A test fails if a not-intercepted
    exception is thrown either by the test code or by an assertion.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当断言失败时，会抛出异常。如果测试代码或断言抛出未捕获的异常，则测试失败。
- en: 'The following is an example of a method that defines a single test:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个定义单个测试的方法的示例：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `[Fact]` attribute is used when a method defines just one test, while the
    `[Theory]` attribute is used when the same method defines several tests, each
    on a different tuple of data. Tuples of data can be specified in several ways
    and are injected into the test as method parameters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法仅定义一个测试时，使用 `[Fact]` 属性，而当同一个方法定义了多个测试，每个测试针对不同的数据元组时，使用 `[Theory]` 属性。数据元组可以通过几种方式指定，并作为方法参数注入到测试中。
- en: 'The previous code can be modified to test `MethodToTest` on several inputs
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改前面的代码以测试 `MethodToTest` 的多个输入，如下所示：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each `InlineData` attribute specifies a tuple to be injected into the method
    parameters. Since just simple constant data can be included as attribute arguments,
    xUnit also gives you the possibility to take all data tuples from a class that
    implements `IEnumerable`, as shown in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`InlineData`属性指定了一个要注入到方法参数中的元组。由于只需简单常量数据可以作为属性参数包含，xUnit还允许您从实现`IEnumerable`的类中获取所有数据元组，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The type of class that provides the test data is specified with the `ClassData`
    attribute.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提供测试数据的类类型是通过`ClassData`属性指定的。
- en: 'It is also possible to take data from a static method of a class that returns
    `IEnumerable` with the `MemberData` attribute, as shown in the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`MemberData`属性从类的静态方法中获取数据，该静态方法返回`IEnumerable`，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `MemberData` attribute is passed the method name as the first parameter,
    and the class type in the `MemberType` named parameter. If the static method is
    part of the same test class, the `MemberType` parameter can be omitted.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemberData`属性将方法名称作为第一个参数传递，将`MemberType`命名参数中的类类型。如果静态方法是同一测试类的一部分，则可以省略`MemberType`参数。'
- en: The next subsection shows how to deal with some advanced preparation and tear-down
    scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何处理一些高级的测试准备和清理场景。
- en: Advanced test preparation and tear-down scenarios
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级测试准备和清理场景
- en: Sometimes, the preparation code contains very time-consuming operations, such
    as opening a connection with a database that doesn’t need to be repeated before
    each test but that can be executed once before all the tests contained in the
    same class. In xUnit, this kind of test preparation code can’t be included in
    the test class constructor; since a different instance of the test class is created
    before every single test, it must be factored out in a separate class called a
    fixture class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，准备代码包含非常耗时的操作，例如，在不需要在每次测试之前重复的数据库上打开连接，但可以在同一类中包含的所有测试之前执行一次。在xUnit中，这种测试准备代码不能包含在测试类构造函数中；由于在每次单个测试之前都会创建测试类的不同实例，因此必须将其提取到单独的类中，称为固定类。
- en: If we also need corresponding tear-down code, the fixture class must implement
    `IDisposable`. In other test frameworks, such as NUnit, the test class instances
    are created just once instead, so they don’t need the fixture code to be factored
    out in other classes. However, test frameworks such as **NUnit**, which do not
    create a new instance before each test, may suffer from bugs because of unwanted
    interactions between test methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还需要相应的清理代码，则固定类必须实现`IDisposable`。在其他测试框架中，如NUnit，测试类实例仅创建一次，因此不需要将固定代码提取到其他类中。然而，像**NUnit**这样的测试框架，在每次测试之前不创建新实例，可能会因为测试方法之间的不期望交互而出现错误。
- en: 'The following is an example of an xUnit fixture class that opens and closes
    a database connection:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个xUnit固定类示例，该类打开和关闭数据库连接：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since a fixture class instance is created just once before all tests associated
    with the fixture are executed and the same instance is disposed of immediately
    after the tests, then the database connection is created just once when the fixture
    class is created and is disposed of immediately after the tests when the fixture
    object is disposed of.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于固定类实例仅在所有与固定类关联的测试执行之前创建一次，并且在测试之后立即销毁，因此数据库连接仅在创建固定类时创建一次，并在销毁固定对象后立即销毁。
- en: 'The fixture class is associated with each test class by letting the test class
    implement the empty `IClassFixture<T>` interface as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让测试类实现空的`IClassFixture<T>`接口，将固定类与每个测试类关联，如下所示：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A fixture class instance is automatically injected into the test class constructor
    in order to make all data computed in the fixture test preparation available for
    the tests. This way, for instance, in our previous example, we can get the database
    connection instance so that all test methods of the class can use it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 固定类实例会自动注入到测试类构造函数中，以便使固定测试准备中计算的所有数据对测试可用。这样，例如，在我们的上一个示例中，我们可以获取数据库连接实例，以便类中的所有测试方法都可以使用它。
- en: 'If we want to execute some test preparation code on all tests contained in
    a collection of test classes instead of a single test class, we must associate
    the fixture class with an empty class that represents the collection of test classes,
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在测试类集合中的所有测试上执行一些测试准备代码，而不是单个测试类，我们必须将固定类与代表测试类集合的空类关联起来，如下所示：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `CollectionDefinition` attribute declares the name of the collection, and
    the `IClassFixture<T>` interface has been replaced with `ICollectionFixture<T>`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionDefinition`属性声明了集合的名称，而`IClassFixture<T>`接口已被`ICollectionFixture<T>`所取代。'
- en: 'Then, we declare that a test class belongs to the previously defined collection
    by applying it to the `Collection` attribute with the name of the collection,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将集合名称应用于`Collection`属性来声明测试类属于之前定义的集合，如下所示：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Collection` attribute declares which collection to use, while the `DataBaseFixture`
    argument in the test class constructor provides an actual fixture class instance,
    so it can be used in all class tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`属性声明了要使用哪个集合，而测试类构造函数中的`DataBaseFixture`参数提供了一个实际的固定类实例，因此它可以在所有类测试中使用。'
- en: Now that we have seen how to leverage fixture classes to share setup and cleanup
    code across multiple tests, enhancing our test organization and efficiency, we
    turn our attention to another powerful technique in our testing arsenal. The following
    section introduces the use of the `Moq` framework, a tool that allows us to simulate
    the behavior of complex dependencies in our tests through mocking. This approach
    is crucial for isolating the component we are testing and verifying its behavior
    under controlled conditions without the need for the actual implementations of
    its dependencies.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何利用固定类来在多个测试之间共享设置和清理代码，从而提高我们的测试组织和效率，我们将注意力转向测试工具箱中的另一个强大技术。下一节介绍了`Moq`框架的使用，这是一个工具，它允许我们通过模拟来模拟测试中复杂依赖项的行为。这种方法对于隔离我们正在测试的组件并在受控条件下验证其行为至关重要，而无需实际实现其依赖项。
- en: Mocking interfaces with Moq
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Moq进行接口模拟
- en: Mocking is a technique used in both unit testing to isolate classes from dependencies
    they have on other classes, so we can impute each test failure to the class under
    test. Classes are isolated from their dependencies by creating a mock or a fake
    version of each dependency.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一种在单元测试中用来隔离类对其他类的依赖的技术，这样我们就可以将每个测试失败归因于正在测试的类。通过创建每个依赖项的模拟或假版本，类与其依赖项被隔离。
- en: Mocking capabilities are not included in any of the test frameworks we listed
    in this section, as they are not included in xUnit, so we must add another library
    that offers mocking capability. The `Moq` framework, a popular tool in .NET, makes
    the mocking process super-easy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中列出的任何测试框架都没有包含模拟功能，因为它们都没有包含在xUnit中，所以我们必须添加另一个提供模拟功能的库。`Moq`框架是.NET中流行的工具，使得模拟过程变得非常简单。
- en: Let’s explore how to use `Moq` to create mocks and set up our tests effectively.
    Here, we will discuss just how to use `Moq` to create mock classes. A practical
    and complete example that shows how to use `Moq` in your tests in practice is
    in the *Testing the WWTravelClub application* section of *Chapter 21*, *Case Study*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何使用`Moq`来创建模拟并有效地设置我们的测试。在这里，我们将讨论如何使用`Moq`来创建模拟类。一个实际且完整的示例，展示了如何在实践中使用`Moq`进行测试，可以在第21章的*案例研究*部分的*测试WWTravelClub应用程序*部分中找到。
- en: 'As a first step, we need to install the `Moq` NuGet package. Then, we need
    to add a `using Moq` statement to our test files. A mock implementation is easily
    defined as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要安装`Moq` NuGet包。然后，我们需要在我们的测试文件中添加一个`using Moq`语句。模拟实现可以轻松定义如下：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The behavior of the mock dependency on specific inputs of the specific method
    can be defined with the `Setup/Return` method pair as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Setup/Return`方法对来定义模拟依赖项对特定方法特定输入的行为，如下所示：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can add several `Setup/Return` instructions for the same method. This way,
    we can specify an indefinite number of input/output behaviors.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为同一方法添加多个`Setup/Return`指令。这样，我们可以指定无限数量的输入/输出行为。
- en: 'Instead of specific input values, we may also use wildcards that match a specific
    type as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定的输入值之外，我们还可以使用通配符来匹配特定类型，如下所示：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Where we replaced `5` with its type, `int`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`5`替换为其类型，`int`。
- en: 'Once we have configured the mock dependency, we may extract the mocked instance
    from its `Object` property and use it as if it were an actual implementation,
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了模拟依赖项，我们可以从其 `Object` 属性中提取模拟实例，并像使用实际实现一样使用它，如下所示：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, mocked methods are usually called by the code under test, so we just
    need to extract the mocked instance and use it as an input in our tests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模拟方法通常是由被测试的代码调用的，所以我们只需要提取模拟实例并将其用作测试的输入。
- en: 'We may also mock properties and **async** methods as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以模拟属性和**异步**方法，如下所示：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With `async` methods, `Returns` must be replaced by `ReturnsAsync`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `async` 方法，必须用 `ReturnsAsync` 替换 `Returns`。
- en: 'Each mocked instance records all calls to its methods and properties, so we
    may use this information in our tests. The following code shows an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模拟实例都会记录对其方法和属性的调用，因此我们可以在测试中使用这些信息。以下代码显示了一个示例：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding statement asserts that `MyMethod` has been invoked with the given
    arguments at least twice. There are also `Times.Never`, and `Times.Once` (which
    asserts that the method was called just once), and more.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句断言 `MyMethod` 至少被调用过两次带有给定的参数。还有 `Times.Never` 和 `Times.Once`（它断言方法只被调用了一次），以及其他选项。
- en: The `Moq` documentation summarized up to now should cover 99% of the needs that
    may arise in your tests, but `Moq` also offers more complex options. The *Further
    reading* section contains the link to the complete documentation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止总结的 `Moq` 文档应该覆盖你测试中可能出现的99%的需求，但 `Moq` 也提供了更复杂的选择。*进一步阅读*部分包含了完整文档的链接。
- en: The *Testing the WWTravelClub application* section of *Chapter 21*, *Case Study*,
    shows the practical usage of `Moq` in a complex example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*第21章*的*案例研究*中的*测试 WWTravelClub 应用程序*部分展示了在复杂示例中 `Moq` 的实际用法。'
- en: After exploring the capabilities of `Moq` and how it enhances our unit testing
    with effective mock implementations, we now turn our attention to a different
    facet of C# application testing – automating functional tests in ASP.NET Core
    applications. In this next section, we’ll dive into how various testing tools
    and techniques, including some we’ve just discussed, are applied to ensure our
    ASP.NET Core applications function as intended, both in isolation and when integrated
    with other systems and interfaces.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 `Moq` 的功能以及它是如何通过有效的模拟实现来增强我们的单元测试之后，我们现在将注意力转向 C# 应用程序测试的不同方面——在 ASP.NET
    Core 应用程序中自动化功能测试。在接下来的部分，我们将深入了解各种测试工具和技术，包括我们刚刚讨论的一些，它们是如何被应用于确保我们的 ASP.NET
    Core 应用程序按预期工作，无论是独立运行还是与其他系统和接口集成。
- en: Automating functional tests in C#
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 自动化功能测试
- en: Automated functional tests use the same test tools as unit and integration tests.
    That is, these tests can be embedded in the same xUnit, NUnit, or MSTest projects
    that we described in the previous section. However, in this case, we must add
    further tools that can interact with and inspect the UI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化功能测试使用与单元和集成测试相同的测试工具。也就是说，这些测试可以嵌入到我们在上一节中描述的相同的 xUnit、NUnit 或 MSTest 项目中。然而，在这种情况下，我们必须添加可以与
    UI 交互和检查的工具。
- en: In the remainder of this chapter, we will focus on web applications since they
    are the main focus of this book. Accordingly, if we are testing web APIs, we just
    need `HttpClient` instances since they can easily interact with web API endpoints
    in both XML and JSON.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将专注于网络应用程序，因为它们是本书的主要焦点。因此，如果我们正在测试网络 API，我们只需要 `HttpClient` 实例，因为它们可以轻松地与
    XML 和 JSON 格式的网络 API 端点交互。
- en: In the case of applications that return HTML pages, the interaction is more
    complex since we also need tools for parsing and interacting with the HTML page
    DOM tree.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回 HTML 页面的应用程序，交互更为复杂，因为我们还需要解析和与 HTML 页面 DOM 树交互的工具。
- en: The *Selenium* toolset is a great solution since it has drivers for simulating
    user interaction in all mainstream browsers and for programmatically accessing
    the browser DOM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*Selenium* 工具集是一个很好的解决方案，因为它为所有主流浏览器提供了模拟用户交互的驱动程序，并可以编程访问浏览器 DOM。'
- en: 'There are two basic options for testing a web application with the `HttpClient`
    class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HttpClient` 类测试网络应用程序有两个基本选项：
- en: '**Staging application**: An `HttpClient` instance connects with the actual
    *staging* web application through the internet/intranet, together with all other
    humans who are beta-testing the software. The advantage of this approach is that
    you are testing the *real stuff*, but tests are more difficult to conceive since
    you can’t control the initial state of the application before each test.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预发布应用**: 一个 `HttpClient` 实例通过互联网/内网与实际的 *预发布* 网络应用连接，同时与其他所有进行软件测试的人类一起。这种方法的优点是你可以测试
    *真实内容*，但由于在每次测试之前无法控制应用的初始状态，因此测试的构思更为困难。'
- en: '**Controlled application**: An `HttpClient` instance connects with a local
    application that is configured, initialized, and launched before every single
    test. This scenario is completely analogous to the unit test scenario. Test results
    are reproducible, the initial state before each test is fixed, tests are easier
    to design, and the actual database can be replaced by a faster and easier-to-initialize
    in-memory database. However, in this case, you are far from the actual system’s
    operation.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**受控应用**: 一个 `HttpClient` 实例连接到一个在每次单个测试之前配置、初始化和启动的本地应用。这种情况与单元测试场景完全类似。测试结果可重复，每次测试前的初始状态是固定的，测试设计更容易，实际数据库可以被一个更快且更容易初始化的内存数据库所替代。然而，在这种情况下，你离实际系统的操作还相当远。'
- en: A good strategy is to use a **controlled application**, where you have full
    control of the initial state, for testing the extreme cases, and then use a **staging
    application** for testing random average cases on the *real stuff*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的策略是使用 **受控应用**，其中你可以完全控制初始状态，用于测试极端情况，然后使用 **预发布应用** 来测试真实内容上的随机平均情况。
- en: The two subsections that follow describe both approaches. The two approaches
    differ only in the way that you define the fixtures of your tests.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个子节描述了这两种方法。这两种方法的不同之处仅在于你定义测试固定器的方式。
- en: Testing the staging application
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试预发布应用
- en: In the case of staging applications, your tests just need a class that can issue
    HTTP requests, which in the case of .NET is the `HttpClient` class. It is enough
    to define an efficient fixture that supplies the needed `HttpClient` instances,
    avoiding the risk of running out of operating system connections. Efficient management
    of the underlying operating system connections can be achieved through the `IHttpClientFactory`
    interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在预发布应用的情况下，你的测试只需要一个可以发出 HTTP 请求的类，在 .NET 中是 `HttpClient` 类。只需定义一个高效的固定器，提供所需的
    `HttpClient` 实例，避免耗尽操作系统连接的风险。可以通过 `IHttpClientFactory` 接口实现底层操作系统连接的高效管理。
- en: 'It is enough to add an `HttpClient` management factory to a dependency injection
    container that will be used by the tests with:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 只需向用于测试的依赖注入容器中添加一个 `HttpClient` 管理工厂即可：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'where the `AddHttpClient` extension belongs to the `Microsoft.Extensions.DependencyInjection`
    namespace and is defined in the `Microsoft.Extensions.Http` NuGet package. Therefore,
    our test fixture must create a dependency injection container, call the `AddHttpClient`
    extension method, and finally build the container. The following fixture class
    does this job:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `AddHttpClient` 扩展属于 `Microsoft.Extensions.DependencyInjection` 命名空间，并在 `Microsoft.Extensions.Http`
    NuGet 包中定义。因此，我们的测试固定器必须创建一个依赖注入容器，调用 `AddHttpClient` 扩展方法，并最终构建容器。以下固定器类执行这项工作：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the preceding definition, your tests should look as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义之后，你的测试应该看起来如下：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In `Test1`, once you get an HTTP client, you can test the application by issuing
    an HTTP request and then by analyzing the response returned by the application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Test1` 中，一旦你获取了一个 HTTP 客户端，你可以通过发出 HTTP 请求并分析应用返回的响应来测试应用。
- en: The approach described above is adequate when the HTTP endpoints return data,
    for instance, in JSON format that can be turned into .NET data by a data serializer/deserializer
    and then compared with the expected data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 端点返回数据时，例如，以 JSON 格式返回，可以通过数据序列化/反序列化器将其转换为 .NET 数据，然后与预期数据进行比较，上述方法就足够了。
- en: The next subsection describes how to test endpoints that return HTML.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了如何测试返回 HTML 的端点。
- en: Testing the staging application with Selenium
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Selenium 测试预发布应用
- en: Most endpoints that return HTML are tested either manually or with playback
    tools, like Selenium IDE, on various browsers. Playback tools record all user
    actions performed on an actual browser and generate code that repeats the same
    action sequences with the help of browser drivers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数返回 HTML 的端点要么手动测试，要么使用回放工具，如 Selenium IDE，在各个浏览器上进行测试。回放工具记录在真实浏览器上执行的所有用户操作，并生成代码，通过浏览器驱动程序帮助重复相同的操作序列。
- en: However, the code generated by playback tools is too sensitive to the DOM structure
    of each page, so most of the tests must be replaced after each relevant change
    in the user interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回放工具生成的代码对每个页面的 DOM 结构过于敏感，因此，大多数测试在用户界面相关更改后都必须进行替换。
- en: Therefore, the code of important and stable UI tests is better created manually
    in a way that is more robust to DOM changes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建重要且稳定的 UI 测试代码最好是手动进行，这样对 DOM 变化更加稳健。
- en: For this purpose, the Selenium toolset contains the `Selenium.WebDriver` NuGet
    package and a driver for each browser that you would like to adopt, such as, for
    instance, the `Selenium.WebDriver.ChromeDriver` NuGet package for the Chrome browser.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，Selenium 工具集包含了 `Selenium.WebDriver` NuGet 包以及每个你想要采用的浏览器的驱动程序，例如，例如，用于
    Chrome 浏览器的 `Selenium.WebDriver.ChromeDriver` NuGet 包。
- en: 'Manual tests based on Selenium WebDriver look like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Selenium WebDriver 的手动测试看起来像这样：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the page to test has been loaded, `driver` is used to explore the page
    content and to interact with page elements, like buttons, links, and input fields.
    As shown in the preceding code, the syntax for interacting with the browser is
    quite simple and intuitive. `driver.FindElement` can find elements by CSS class
    name, by ID, and also through generic CSS selectors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了要测试的页面，`driver` 就被用来探索页面内容并与页面元素交互，例如按钮、链接和输入字段。如前述代码所示，与浏览器交互的语法相当简单直观。`driver.FindElement`
    可以通过 CSS 类名、通过 ID 以及通过通用的 CSS 选择器来查找元素。
- en: Adding CSS classes that characterize their role with HTML elements is a good
    technique for building robust UI tests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML 元素添加描述其角色的 CSS 类是一个构建稳健 UI 测试的好技术。
- en: The next subsection explains how to test an application that runs in a controlled
    environment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将解释如何测试在受控环境中运行的应用程序。
- en: Testing a controlled application
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试受控的应用程序
- en: In this case, we create an ASP.NET Core server within the test application and
    test it with an `HttpClient` instance. The `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package contains all that we need to create both an HTTP client and the
    server running the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在测试应用程序中创建一个 ASP.NET Core 服务器，并用 `HttpClient` 实例对其进行测试。`Microsoft.AspNetCore.Mvc.Testing`
    NuGet 包包含了我们需要创建 HTTP 客户端和运行应用程序的服务的所有内容。
- en: '`Microsoft.AspNetCore.Mvc.Testing` contains a fixture class that does the job
    of launching a local web server and furnishing a client to interact with it. The
    predefined fixture class is `WebApplicationFactory<T>`. The generic `T` argument
    must be instantiated with the `Program` class of your web project, that is, with
    an entry point for the web application.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.Testing` 包含一个 fixture 类，它负责启动本地 web 服务器并提供一个客户端与之交互。预定义的
    fixture 类是 `WebApplicationFactory<T>`。泛型 `T` 参数必须用你的 web 项目的 `Program` 类实例化，即
    web 应用程序的入口点。'
- en: 'Tests look like the following class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 测试看起来像以下类：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Program` class must exist and must be defined as public. Otherwise, `WebApplicationFactory`
    has no entry point for starting the application. Therefore, if the code in `Program.cs`
    is not enclosed in a public class, as in the default project scaffolded by Visual
    Studio, you must turn the internal `Program` class automatically generated by
    the C# compile into a public class. This is easily achieved by adding the following
    code at the end of the `Program.cs` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 类必须存在并且必须定义为公共的。否则，`WebApplicationFactory` 将没有启动应用程序的入口点。因此，如果 `Program.cs`
    中的代码没有被包含在一个公共类中，就像 Visual Studio 默认生成的项目模板那样，你必须将 C# 编译自动生成的内部 `Program` 类转换为公共类。这可以通过在
    `Program.cs` 文件末尾添加以下代码轻松实现：'
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you want to analyze the HTML of the returned pages, you must also reference
    **Selenium** NuGet packages, as shown in the previous subsection. We will see
    how to use them in the example in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要分析返回页面的 HTML，你也必须引用 **Selenium** NuGet 包，如前一小节所示。我们将在下一节中看到如何使用它们。
- en: The simplest way to cope with databases in this type of test is to replace them
    with in-memory databases that are faster and automatically cleared whenever the
    local server is shut down and restarted.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类测试中处理数据库的最简单方法是将它们替换为内存数据库，这些数据库更快，并且每当本地服务器关闭和重启时都会自动清除。
- en: Unfortunately, in-memory databases are not 100% compatible with the actual database
    used, so some tests might fail. Therefore, at least some of the tests might require
    the actual database.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，内存数据库与实际使用的数据库并不完全兼容，因此某些测试可能会失败。因此，至少一些测试可能需要实际数据库。
- en: 'When performing tests with actual databases, we must also add all the required
    instructions to clear or recreate from scratch a standard database in the constructor
    of a custom fixture that inherits from `WebApplicationFactory<T>`. Note that deleting
    all database data is not as easy as it might appear, owing to integrity constraints.
    You have various options, but none is the best for all cases:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用实际数据库进行测试时，我们还必须在继承自`WebApplicationFactory<T>`的自定义固定构造函数中添加所有必要的指令来清除或从头创建一个标准数据库。请注意，删除所有数据库数据并不像看起来那么简单，因为存在完整性约束。您有多种选择，但没有一种是所有情况的最佳选择：
- en: Delete the whole database and recreate it using SQL scripts or Entity Framework
    Core migrations, which will be analyzed in *Chapter 13*, *Interacting with Data
    in C# – Entity Framework Core*. This always works, but it is slow and requires
    a database user with high privileges.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除整个数据库，并使用SQL脚本或Entity Framework Core迁移重新创建它，这些将在第13章“在C#中与数据交互 - Entity Framework
    Core”中进行分析。这总是可行的，但速度较慢，需要具有高权限的数据库用户。
- en: Enclose a test database in a Docker image and recreate a new container at each
    new test (Docker will be discussed in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*). This is faster than recreating a new database
    from scratch but still slow.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试数据库包含在Docker镜像中，并在每次新的测试中重新创建一个新的容器（Docker将在第11章“将微服务架构应用于您的企业应用”中讨论）。这比从头开始重新创建新数据库要快，但仍然较慢。
- en: Disable the database constraints and then clear all tables in any order. This
    technique sometimes doesn’t work and requires a database user with high privileges.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用数据库约束，然后按任何顺序清除所有表。这种技术有时不起作用，需要具有高权限的数据库用户。
- en: Delete all data in the right order, thus without violating all database constraints.
    This is not difficult if you keep an ordered delete list of all tables while the
    database grows and you add tables to the database. This delete list is a useful
    resource that you may also use to fix issues in database update operations and
    to remove old entries during production database maintenance. Unfortunately, this
    method also fails in the rare case of circular dependencies, such as a table that
    has a foreign key referring to itself.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照正确的顺序删除所有数据，从而不违反所有数据库约束。如果在数据库增长的同时保持所有表的有序删除列表，并且向数据库添加表，这并不困难。这个删除列表是一个有用的资源，您还可以使用它来解决数据库更新操作中的问题，以及在生产数据库维护期间删除旧条目。不幸的是，这种方法在罕见的情况下也会失败，例如，有一个外键引用自身的表这种循环依赖的情况。
- en: I prefer method 4 and revert to method 3 only in the rare case of difficulties
    due to circular dependencies.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢方法4，只有在由于循环依赖导致的困难罕见情况下才回退到方法3。
- en: Recording tests with Selenium IDE
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Selenium IDE记录测试
- en: The Selenium toolset contains browser extensions for recording and replaying
    browser tests. These are called Selenium IDE. You can download the extensions
    for Chrome and Firefox from [https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/),
    while the extension for Microsoft Edge is available from [https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp](https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium工具集包含用于记录和回放浏览器测试的浏览器扩展。这些被称为Selenium IDE。您可以从[https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/)下载Chrome和Firefox的扩展，而Microsoft
    Edge的扩展可以从[https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp](https://microsoftedge.microsoft.com/addons/detail/selenium-ide/ajdpfmkffanmkhejnopjppegokpogffp)获取。
- en: 'In Chrome, once installed, Selenium IDE can be run by clicking the extensions
    icon and then selecting the Selenium extension from the menu that appears, as
    shown in the screenshot below:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中，一旦安装，可以通过点击扩展图标并从出现的菜单中选择Selenium扩展来运行Selenium IDE，如下面的截图所示：
- en: '![](img/B19820_09_03.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_09_03.png)'
- en: 'Figure 9.3: Running Selenium IDE'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：运行Selenium IDE
- en: You are prompted for the action you would like to perform, whether to create
    a new project, access an existing project, etc.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到提示，要求您执行的操作，例如创建新项目、访问现有项目等。
- en: When you create a new project, you are prompted for the project name. At this
    point, Selenium IDE opens, and you can insert the application URL.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建新项目时，您将收到项目名称的提示。此时，Selenium IDE 将打开，您可以将应用程序 URL 插入其中。
- en: New tests can be created by clicking the plus button next to the tests list.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击测试列表旁边的加号按钮来创建新的测试。
- en: In order to record a test, select the test name and then click the record icon.
    A new browser window will open with the application URL. From this point, every
    action you perform on the application and its results will be recorded.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了录制测试，请选择测试名称，然后点击录制图标。将打开一个新的浏览器窗口，其中包含应用程序 URL。从这一点开始，您在应用程序上执行的所有操作及其结果都将被记录。
- en: You can make assertions on the page content by right-clicking on a page element
    and selecting the appropriate action from the **Selenium** **IDE > Assert** submenu.
    For instance, if you select the **Selenium IDE > Assert > Text** command on a
    text element, the text value will be stored. When the test is executed, the content
    of the same text element will be compared with the previously stored value, and
    the test will fail if the two values are different.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过右键单击页面元素并从 **Selenium** **IDE > 断言**子菜单中选择适当的操作来对页面内容进行断言。例如，如果您在文本元素上选择
    **Selenium IDE > 断言 > 文本** 命令，文本值将被存储。当测试执行时，同一文本元素的内容将与之前存储的值进行比较，如果两个值不同，则测试将失败。
- en: Once all desired actions and assertions have been performed, return to the Selenium
    IDE window, click the stop recording button, and save the project.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了所有期望的操作和断言，请返回 Selenium IDE 窗口，点击停止录制按钮，并保存项目。
- en: Selenium IDE offers the option to run either a selected test or all tests.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium IDE 提供了运行所选测试或所有测试的选项。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained why it is worth automating software tests, and
    then we focused on the importance of unit tests. We also listed the various types
    of tests and their main features, focusing mainly on unit tests and functional
    tests. We analyzed the advantages of **TDD** and how to use it in practice. With
    this knowledge, you should be able to produce software that is both reliable and
    easy to modify.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了为什么自动化软件测试是值得的，然后我们关注了单元测试的重要性。我们还列出了各种测试类型及其主要功能，主要关注单元测试和功能测试。我们分析了
    **TDD** 的优势以及如何在实践中使用它。有了这些知识，您应该能够生产出既可靠又易于修改的软件。
- en: Then, this chapter analyzed when it is worth automating some or all functional
    tests and described how to automate them in `ASP.NET` Core applications.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章分析了何时值得自动化某些或所有功能测试，并描述了如何在 `ASP.NET` Core 应用程序中自动化它们。
- en: Finally, we analyzed the main test tools available for .NET projects, focusing
    on xUnit, `Moq`, `Microsoft.AspNetCore.Mvc.Testing`, and *Selenium*, and showed
    how to use them in practice with the help of the book’s use case.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了适用于 .NET 项目的各种主要测试工具，重点关注 xUnit、`Moq`、`Microsoft.AspNetCore.Mvc.Testing`
    和 *Selenium*，并展示了如何借助本书的使用案例在实践中使用它们。
- en: '*Chapter 21*, *Case Study*, applies all the test concepts described in this
    chapter to the book’s case study.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 21 章*，*案例研究*，将本章中描述的所有测试概念应用于本书的案例研究。'
- en: Questions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it worth automating unit tests?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么自动化单元测试是值得的？
- en: What is the main reason why TDD is able to discover most bugs immediately?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD 能够立即发现大多数错误的主要原因是什么？
- en: What is the difference between the `[Theory]` and `[Fact]` attributes of xUnit?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[Theory]` 和 `[Fact]` 属性的 xUnit 之间有什么区别？'
- en: Which xUnit static class is used in test assertions?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 xUnit 静态类用于测试断言？
- en: Which methods allow the definition of the `Moq` mocked dependencies?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些方法允许定义 `Moq` 模拟的依赖项？
- en: Is it possible to mock `async` methods with `Moq`? If so, how?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用 `Moq` 模拟 `async` 方法？如果是，该如何操作？
- en: Is it always worth automating UI functional tests in the case of quick CI/CD
    cycles?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在快速 CI/CD 循环的情况下，是否总是值得自动化 UI 功能测试？
- en: What is the disadvantage of subcutaneous tests for ASP.NET Core applications?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 ASP.NET Core 应用程序，皮下测试的缺点是什么？
- en: What is the suggested technique for writing code-driven ASP.NET Core functional
    tests?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议使用什么技术来编写代码驱动的 ASP.NET Core 功能测试？
- en: What is the suggested way of inspecting the HTML returned by a server?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议如何检查服务器返回的 HTML？
- en: Further reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: While the documentation on xUnit included in this chapter is quite complete,
    it doesn’t include a few configuration options offered by xUnit. The full xUnit
    documentation is available at [https://xunit.net/](https://xunit.net/). Documentation
    for MSTest and NUnit can be found at [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)
    and [https://docs.nunit.org/](https://docs.nunit.org/), respectively.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管本章包含的 xUnit 文档相当完整，但它不包括 xUnit 提供的一些配置选项。完整的 xUnit 文档可在[https://xunit.net/](https://xunit.net/)找到。MSTest
    和 NUnit 的文档分别可在[https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)和[https://docs.nunit.org/](https://docs.nunit.org/)找到。
- en: For more information on BDD and SpecFlow, refer to the Cucumber official website
    at [https://cucumber.io/](https://cucumber.io/) and to the SpecFlow documentation
    at [https://docs.specflow.org/](https://docs.specflow.org/).
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 BDD 和 SpecFlow 的信息，请参考 Cucumber 官方网站[https://cucumber.io/](https://cucumber.io/)和
    SpecFlow 文档[https://docs.specflow.org/](https://docs.specflow.org/)。
- en: The full Moq documentation is available at [https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart).
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 Moq 文档可在[https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart)找到。
- en: 'Here are some links to performance test frameworks for web applications:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些关于网络应用程序性能测试框架的链接：
- en: '[https://jmeter.apache.org/ (free and open source)](https://jmeter.apache.org/)'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jmeter.apache.org/ (免费和开源)](https://jmeter.apache.org/)'
- en: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
- en: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
- en: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
- en: More details on the `Microsoft.AspNetCore.Mvc.Testing NuGet` package can be
    found in the official documentation at [https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests).
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 `Microsoft.AspNetCore.Mvc.Testing NuGet` 包的详细信息可在官方文档[https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests)中找到。
- en: 'More information on Selenium IDE can be found on the official website: [https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/).'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Selenium IDE 的信息可在官方网站[https://www.selenium.dev/selenium-ide/](https://www.selenium.dev/selenium-ide/)找到。
- en: 'More information on Selenium WebDriver can be found on the official website:
    [https://www.selenium.dev/documentation/webdriver/](https://www.selenium.dev/documentation/webdriver/).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Selenium WebDriver 的信息可在官方网站[https://www.selenium.dev/documentation/webdriver/](https://www.selenium.dev/documentation/webdriver/)找到。
- en: Learn more on Discord
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code175081751210902046.png)'
