- en: Approaching the Problem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近问题
- en: In [Chapter 5](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195), *Tabula
    Rasa – Approaching an Application with TDD in Mind*, the details of the Speaker
    Meet application were discussed. The requirements have been defined at a very
    high level. A picture has been painted with very, very broad strokes. This is
    often how the concept for many applications begins, with a high-level description
    and an important key functionality defined. It may have started with a bar napkin
    or a whiteboard sketch, but somewhere, somehow an idea was formed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195)，“Tabula Rasa –
    以TDD的心态接近应用程序”，讨论了演讲者遇到应用程序的细节。需求已经在非常高的层面上被定义。用非常、非常宽的笔触描绘了一幅画面。许多应用程序的概念通常就是这样开始的，有一个高级描述和一个重要的关键功能被定义。它可能始于一张吧台纸或白板草图，但无论如何，某个地方、某种方式形成了一个想法。
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Defining the Speaker Meet application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义演讲者遇到的应用程序
- en: Architectural choices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构选择
- en: Testing direction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试方向
- en: Defining the problem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义问题
- en: To define the problem, first the vision must be defined. Clear objectives should
    be described and outlined. The Speaker Meet problem came about as a result of
    technology speakers looking for a single, centralized place in which to find speaking
    opportunities and venues. It was determined that user group and conference organizers
    were equally in need of a solution to seek and find speakers for their meetings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义问题，首先必须定义愿景。应该描述并概述清晰的目标。演讲者遇到问题的出现是由于技术演讲者寻找一个单一、集中的地方来寻找演讲机会和场所。确定用户群体和会议组织者同样需要寻求和找到为他们的会议提供演讲者的解决方案。
- en: Thus, the idea for Speaker Meet was born. But, how would the application work?
    Should it be a mobile application or a website? How would the data be collected
    and managed? Would users be allowed to create their own profiles? Could users
    submit speaker, community, and conference information? Where would the application
    live and how would it be hosted? And where in the world do we begin?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，演讲者遇到的想法产生了。但是，应用程序将如何工作？它应该是一个移动应用程序还是网站？数据将如何收集和管理？用户是否允许创建自己的个人资料？用户能否提交演讲者、社区和会议信息？应用程序将驻留在何处以及如何托管？而且我们在世界的哪个角落开始？
- en: Digesting the problem
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消化问题
- en: The problem the application will be designed to solve has been defined. Speaker
    Meet will bring technology speakers, communities, and conferences together. Now
    that the purpose has been defined, it must be digested.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将被设计用来解决的问题已经被定义。演讲者遇到将把技术演讲者、社区和会议聚集在一起。现在目的已经定义，必须消化。
- en: As was suggested before in a previous chapter, attacking a new application from
    all directions is ill-advised. It can be quite a daunting task to attempt to approach
    a new software project by implementing each and every desired feature all at once.
    It can also be a large chore to define every want and need of the system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所建议的，从所有方向攻击新的应用程序是不明智的。试图通过一次性实现每个期望的功能来接近新的软件项目是一项相当艰巨的任务。定义系统的每个愿望和需求也可能是一项庞大的工作。
- en: It would be far better to define small, manageable chunks of the application
    that can be delivered quickly in order to evaluate their correctness and effectiveness.
    The trouble is, how does one define what can be separated into small pieces and
    determine that this small piece is of sufficient value?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最好定义小的、可管理的应用程序块，以便可以快速交付以评估其正确性和有效性。问题是，一个人如何定义可以分离成小块的内容，并确定这个小块具有足够的价值？
- en: Epics, features, and stories; oh my!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史故事、特性和故事；哦，我的天啊！
- en: Many software development projects will maintain what is referred to as a *product
    backlog*. This is where everything that the system might be asked to do is compiled.
    The product backlog might contain the largest of ideas down to the most minute
    detail. The important thing is that these ideas are recorded.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件开发项目将维护所谓的*产品待办事项列表*。这是系统可能被要求执行的所有事情被汇编的地方。产品待办事项列表可能包含从最大的想法到最微小的细节。重要的是这些想法被记录下来。
- en: The backlog should be regularly groomed and maintained. Items should be evaluated
    for their importance and ordered appropriately. If it is determined that an item
    is the next most important thing on which to be worked, it should be broken down
    into appropriately sized stories for the team to effectively deliver in a timely
    manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应定期整理和维护待办事项列表。应根据其重要性评估项目，并适当排序。如果确定某个项目是下一个需要工作的最重要的事情，则应将其拆分成适合团队及时有效交付的适当大小的故事。
- en: Epics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 史诗
- en: Larger, broader ideas are defined as *epics*. These could potentially be quite
    significant and wide-ranging in scope and size. Speakers would be defined as an
    epic. The speakers epic is a segment of the application devoted to anything and
    everything related to technology speakers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 较大、较广泛的想法被定义为**史诗**。这些可能具有相当重要的范围和规模。演讲者可能被定义为史诗。演讲者史诗是应用程序中用于与技术演讲者相关的一切和任何事物的部分。
- en: The term epic is used to signify that the features and stories contained within
    the epic all revolve around a single, central idea. These essentially start life
    as a single, large user story, and are broken down into smaller features and stories.
    Epics can often take several sprints to complete.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“史诗”用于表示史诗中包含的功能和故事都围绕一个单一、中心的思想。这些本质上最初是一个单一的大型用户故事，然后被拆分成更小的功能和故事。史诗可能需要几个迭代才能完成。
- en: Features
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能
- en: Features are generally smaller than epics and are contained within epics. A
    feature will usually contain many stories related to the subject matter it is
    responsible for. Think of features the same way you think of epics, they are just
    a smaller grouping.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能通常比史诗小，并且包含在史诗中。一个功能通常包含许多与它负责的主题相关的用户故事。将功能视为与史诗相同的方式，它们只是更小的分组。
- en: A feature might comprise a s*peaker catalog* or s*peaker detail*. The speaker
    catalog might contain everything associated with displaying, sorting, filtering,
    and searching for speakers within the system. The speaker detail feature might
    define details and functionality regarding single, individual speaker information
    and how it is displayed within the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能可能包括一个**演讲者目录**或**演讲者详情**。演讲者目录可能包含与在系统中显示、排序、过滤和搜索演讲者相关的一切。演讲者详情功能可能定义有关单个、个别演讲者信息及其在应用程序中显示的详细信息和功能。
- en: Stories
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户故事
- en: 'Depending on team preference, a story might be as small as seeing a speaker''s
    name when viewing their details. A word of caution: it is possible to have too
    small a story. It is better to break a story down so it''s just small enough and
    begin work than to waste time on minute details. If done correctly, the details
    will emerge during the development cycle.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据团队偏好，一个故事可能小到在查看其详情时看到演讲者的名字。提醒一下：故事可能太小。最好是将其拆分成足够小，以便开始工作，而不是在细节上浪费时间。如果做得正确，细节将在开发周期中自然出现。
- en: Determining what is small enough should be left to the team to decide. A good
    rule of thumb is that stories should take from half a day to three days to complete.
    Less than half a days' worth of work and the story will likely be broken down
    into pieces that are too small. More than three day's work and there is likely
    an opportunity to break the story into two or more stories.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确定足够小的事情应该留给团队决定。一个很好的经验法则是，故事应该需要半天到三天的时间来完成。少于半天的工作量，故事很可能会被拆分成过小的部分。多于三天的工作量，可能有机会将故事拆分成两个或更多个故事。
- en: It is possible to have too small a story.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 故事可能太小。
- en: Don't fall into the trap of breaking down stories into piece that are too small.
    Effort can be wasted by trying to compose smaller and smaller stories. If you're
    practicing Scrum, remember that small improvements can and should be proposed
    at the conclusion of each sprint. During the retrospective, story size and its
    effectiveness should be discussed. If it is decided that the size was not appropriate,
    whether that be too large or too small, adjustments should be made before the
    next sprint begins.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不要陷入将故事拆分成过小部分的陷阱。试图编写越来越小的故事可能会浪费精力。如果你在实践Scrum，记得在每个迭代的结束时可以并且应该提出小的改进建议。在回顾会议期间，应讨论故事大小及其有效性。如果决定大小不合适，无论是太大还是太小，应在下一个迭代开始之前进行调整。
- en: Maintain your backlog
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护您的待办事项列表
- en: So why is it so important to maintain the product backlog? A well-maintained
    backlog will define what the team should work on and help them plan for known,
    upcoming tasks. This will also help a team put together forecasting in order to
    plan for when a particular feature might be completed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么保持产品待办事项列表如此重要呢？一个维护良好的待办事项列表将定义团队应该做什么工作，并帮助他们规划已知和即将到来的任务。这也有助于团队制定预测，以便规划特定功能可能完成的时机。
- en: '![](img/00017.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: If appropriate metrics are captured, a well-disciplined team can deliver a reliable
    velocity in each sprint. With appropriately sized and estimated stories a reasonable
    timeline can be predicted for upcoming items in the backlog. For example, if a
    team has reliably delivered 20 points per sprint and the next five stories have
    been estimated at 8 points each it would not be unreasonable to expect these five
    stories to be completed in about two sprints. Of course, this is not a commitment;
    it is merely an estimate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果捕获了适当的指标，一个纪律严明的团队可以在每个冲刺中交付可靠的速率。通过合理大小和估计的故事，可以预测待办事项中即将到来的项目的合理时间表。例如，如果一个团队在每个冲刺中可靠地交付了20个点，而下一个五个故事被估计为每个8个点，那么预计这五个故事将在大约两个冲刺内完成是合理的。当然，这并不是承诺，而只是一个估计。
- en: The Speaker Meet problem
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者会议问题
- en: Remember that the application scope will initially be kept small and limited
    in functionality. Some features might be identified now as an item for the future,
    but the limited scope for the Minimum Viable Product still needs to be better
    defined. More features will continue to be added to the product backlog and prioritized
    quite low if it is determined that they are not needed for a first release. Consider,
    though, that a minimum viable product still needs to deliver some value. A software
    application that doesn't do anything isn't worth much to anyone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，应用程序的范围最初将保持小而有限。一些特性现在可能被识别为未来的项目，但最小可行产品的有限范围仍需要更好地定义。如果确定这些特性对首次发布不是必需的，将继续向产品待办事项中添加更多特性，并将它们的优先级设定得相当低。然而，考虑到最小可行产品仍需要提供一些价值。一个什么也不做的软件应用对任何人都没有多少价值。
- en: Taking the time to prioritize the potential value of features and stories will
    help decide what should be included in an initial release, and what can wait.
    By determining the effort involved to deliver specific functionality and combining
    that information with the proposed value, an educated decision can be made regarding
    which features will be delivered first.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间优先考虑特性和故事的潜在价值，将有助于决定应该包含在初始发布中的内容，以及可以等待的内容。通过确定提供特定功能所需的工作量，并将这些信息与提议的价值相结合，可以做出关于哪些特性将首先交付的明智决定。
- en: Meaningful separation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意义的分离
- en: Brainstorming the proposed features of the application will help to describe
    the system. Finding meaningful, logical separation will help define the scope
    of particular sections of the software solution. Logical boundaries could include
    epics and features as defined in the product backlog. They could also be determined
    by divisions in technology.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对应用程序提出的特性的头脑风暴有助于描述系统。找到有意义的、逻辑上的分离将有助于定义软件解决方案特定部分的范围。逻辑边界可能包括产品待办事项中定义的史诗和特性。它们也可能由技术划分决定。
- en: Speakers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者
- en: The speaker epic will be made up of all of the features and stories surrounding
    the speakers portion of the application. This will include the speaker catalog
    and speaker details. This section will also contain any future enhancements and
    features that might be added at a later date. Future functionality might include
    speaker ratings and reviews, slide decks, and presentations, YouTube or Vimeo
    videos, and so on. These have yet to be determined and can be evaluated at a later
    date when a proposed value can be weighed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲史诗将由围绕应用程序演讲部分的全部特性和故事组成。这包括演讲者目录和演讲者详细信息。本节还将包含未来可能添加的任何增强功能和特性。未来的功能可能包括演讲者评分和评论、幻灯片、演示文稿、YouTube
    或 Vimeo 视频，等等。这些尚未确定，可以在稍后评估，届时可以权衡提议的价值。
- en: Not all functionality needs to be decided up front. Remember, work towards a
    Minimum Viable Product and build functionality as it's needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有功能都需要一开始就决定。记住，朝着最小可行产品努力，并在需要时构建功能。
- en: 'Here are some basic features stories for the speaker epic:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演讲史诗的基本特性故事：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are using a story format to describe detail at all levels of the application.
    That is, epics are presented as a story, themes or features are presented as a
    story, and specific requirements are presented as a story. In the hierarchy, only
    the specific requirements are called user stories though. The reason for giving
    them all the story format is simple. We want to be able to write a requirement
    and be able to transition it from user story to feature or even to epic with minimal
    hassle. So, we use the same format for a requirement regardless of the abstraction
    level of that requirement.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用故事格式来描述应用的所有级别的细节。也就是说，史诗以故事的形式呈现，主题或特性以故事的形式呈现，具体需求也以故事的形式呈现。在层次结构中，只有具体需求被称为用户故事。给它们所有故事格式的原因很简单。我们希望能够编写一个需求，并能够以最小的麻烦将其从用户故事转换为特性或甚至史诗。因此，我们使用相同的格式来编写需求，无论该需求抽象级别如何。
- en: These feature stories are a good start. This will provide the business with
    an opportunity to grade and prioritize features before determining what should
    be worked on first. When presented to the team, these will likely need to be broken
    down into smaller, more detailed user stories with acceptance criteria.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性故事是一个良好的开端。这将给企业提供机会在确定首先应该做什么之前对特性进行评分和优先排序。当向团队展示时，这些特性故事很可能会被分解成更小、更详细的用户故事，并带有验收标准。
- en: Good acceptance criteria will help the team determine when a story can be marked
    complete. If all conditions have been met, then the story is done and can be delivered.
    If at some point, it is decided that more work is needed in order to deliver the
    requested functionality, additional criteria should be included or new stories
    added to the backlog.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的验收标准将帮助团队确定何时可以标记故事为完成。如果所有条件都已满足，则故事完成并可交付。如果在某个时候，决定需要更多的工作才能交付所需的功能，则应包括额外的标准或向待办事项列表中添加新的故事。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Communities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区
- en: User groups and meetups comprise the community section of the application. The
    main purpose of this portion of the application is to provide a place for speakers
    and potential members and attendees to find and discover technical communities
    in their area. Anyone traveling to a specific city might also be interested in
    learning which user groups or meetups are available to them, whether for speaking
    purposes or general attendance. The community segment of the application will
    include the community directory and user group details. If any future enhancements
    are proposed, they can be added as new features or user stories to the community
    epic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户组和聚会构成了应用中的社区部分。此应用部分的主要目的是为演讲者、潜在成员和参会者提供一个地方，以便他们可以找到和发现他们所在地区的技术社区。任何前往特定城市的旅行者也可能对了解哪些用户组或聚会可供他们参加感兴趣，无论是为了演讲还是一般参加。应用中的社区部分将包括社区目录和用户组详情。如果将来提出任何增强建议，它们可以作为新的特性或用户故事添加到社区史诗中。
- en: At some point in the near future, location search will be added to the community
    portion of the system. This would allow the user to search for communities based
    on distance, perhaps allowing speakers to determine communities within a 200-mile
    radius at which they may be interested in speaking. This feature was determined
    to be unnecessary for an initial release of the Speaker Meet application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，系统中的社区部分将增加位置搜索功能。这将使用户能够根据距离搜索社区，也许允许演讲者确定他们可能感兴趣的、半径为200英里的社区。这个功能被确定为Speaker
    Meet应用程序初始版本中不必要的功能。
- en: 'A small list of community feature stories can be found here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一份社区特性故事的简短列表可以在这里找到：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Much like the speaker feature stories, the community feature stories will help
    the product owner prioritize the functionality to be developed. These, too, will
    likely need to be broken down into smaller, more detailed user stories with acceptance
    criteria. Take a look at the stories here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与演讲者特性故事类似，社区特性故事将帮助产品所有者优先考虑要开发的功能。这些特性故事也可能会被分解成更小、更详细的用户故事，并带有验收标准。请查看这里的故事：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Conferences
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会议
- en: The details and functionality within the application regarding conferences are
    defined and described in the conferences epic. This will include the conference
    catalog and conference details. Future enhancements and features proposed at a
    later date may be added to the conferences epic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中关于会议的细节和功能在会议史诗中定义和描述。这包括会议目录和会议详情。未来在稍后日期提出的增强功能和特性可能被添加到会议史诗中。
- en: Conferences, too, may utilize location search. There are a variety of third-party
    services available and they can be evaluated for inclusion in a future release.
    Like all third-party code, these will be abstracted away from the main application,
    so that the system is insulated from potential changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 会议也可能利用位置搜索。有各种各样的第三方服务可用，并且它们可以被评估以包含在未来的版本中。像所有第三方代码一样，这些将被从主应用程序中抽象出来，以便系统免受潜在变化的影响。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Conferences differ from communities in that they happen only once per year
    and often have many speakers and sessions for the event. The conference feature
    stories will help the product owner prioritize the functionality to be developed.
    These, too, will likely need to be broken down into smaller, more detailed user
    stories with acceptance criteria. Take a look at the stories here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 会议与社区不同，因为它们每年只举行一次，通常有众多演讲者和会议。会议功能故事将帮助产品负责人优先考虑要开发的功能。这些也可能需要被分解成更小、更详细的用户故事，并带有验收标准。请查看这里的故事：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Separate by team function
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按团队功能分离
- en: Many self-organizing teams split themselves by expertise. This might mean that
    members divide themselves into front-end developers, back-end developers, QA,
    and so on. Likewise, stories and tasks can be separated by functionality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自我组织的团队会根据专业知识进行划分。这可能意味着成员将自己划分为前端开发者、后端开发者、QA等。同样，故事和任务可以根据功能进行分离。
- en: It is best left up to the team to decide how to effectively organize themselves
    and their body of work. For example, Sally may be the most knowledgeable developer
    when it comes to the .NET framework, while Steve may have more expertise with
    React. It might prove better to let Sally take a majority of the back-end stories
    and let Steve focus on front-end functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最好由团队自己决定如何有效地组织自己和他们的工作。例如，萨莉可能是.NET框架方面最知识渊博的开发者，而史蒂夫可能在React方面有更多的专业知识。可能更好的是让萨莉承担大部分后端故事，让史蒂夫专注于前端功能。
- en: Note that it is an easy pitfall to prioritize stories in such a manner that
    each team member has the most suitable work for them available. This will be efficient
    but not effective. Instead, priorities should focus on value delivered and optimized
    later on. There's no harm in letting someone (for example, Sally) work on UI features
    together with Steve when for example large UI design changes are needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以这种方式优先考虑故事，让每个团队成员都有最适合他们的工作，这是一个容易陷入的陷阱。这将是高效的，但不是有效的。相反，优先级应该集中在交付的价值上，并在之后进行优化。当需要例如大型UI设计变更时，让某人（例如，萨莉）与史蒂夫一起工作在UI功能上，例如，并没有什么不好。
- en: Technical separations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术分离
- en: There may be a time when you must perform some work that doesn't fit neatly
    into the epics defined previously. Non-functionality requirements may include
    items related to the technology chosen for parts of the system. Stories could
    comprise purely web or front-end functionality, such as bundling JavaScript files.
    Alternatively, back-end or server-side functionality may need to be defined outside
    the previous epics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，你必须执行一些之前定义史诗中无法整齐划入的工作。非功能性需求可能包括与系统部分选择的技术相关的项目。故事可能仅包括纯Web或前端功能，例如打包JavaScript文件。或者，后端或服务器端功能可能需要定义在之前的史诗之外。
- en: There will likely be a number of non-functional or system specifications that
    will also need to be evaluated. Examples of these requirements might include response
    times, throughput, or memory consumption. These are commonly added to the checklist
    for *Definition of Done* so that each story should confirm the non-functional
    requirements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能还会有一系列非功能性或系统规范需要评估。这些要求的例子可能包括响应时间、吞吐量或内存消耗。这些通常被添加到“完成定义”清单中，以便每个故事都应该确认非功能性要求。
- en: Many modern web-enabled applications are built as a **Single Page Application**
    (**SPA**) using JavaScript. These applications are hosted by a web server and
    delivered to a web browser on request. The entire application, or rather large
    pieces of the application, are delivered all at once. As requests are made by
    the client browser, the SPA will update the data on screen or mimic a page transition.
    Full-page postbacks and page reloading are not used with an SPA. This provides
    a perceptible increase in performance and increases in responsiveness for the
    end user. It also allows for distributing some of the processing of an application
    to client machines.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代的Web启用应用程序都是使用JavaScript构建的**单页应用程序**（SPA）。这些应用程序由Web服务器托管，并在请求时发送到Web浏览器。整个应用程序，或者更确切地说，应用程序的大块内容，一次全部发送。当客户端浏览器发起请求时，SPA将更新屏幕上的数据或模拟页面转换。在SPA中不使用全页回发和页面重新加载。这为最终用户提供了可感知的性能提升和响应速度增加。同时，这也允许将应用程序的一些处理工作分配到客户端机器上。
- en: With this division of the SPA, much of the functionality can be split into *web*
    and *non-web* designations. A team may choose to write their stories in this way.
    Similarly, a team may choose to designate web specialists to work primarily on
    web-related functionality. One issue with this split is that the single story
    with just a front-end or back-end is not potentially shippable software. They
    do not separately deliver value. Instead, the story could be split by stripping
    out special case handling, offering only one purpose, keeping the UI simpler,
    and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对SPA的这种划分，大部分功能可以被分为*Web*和*非Web*的标识。一个团队可能会选择以这种方式编写他们的故事。同样，一个团队可能会选择指定Web专家主要工作在Web相关功能上。这种划分的一个问题是，只有前端或后端的一个单一故事并不是可能发布的软件。它们没有单独提供价值。相反，故事可以通过去除特殊案例处理、只提供单一目的、保持UI更简单等方式进行拆分。
- en: Like the web designation, a team may decide to separate stories into server-side
    or back-end functionality. This might cover all functionality from the API to
    the database and everything in between. The back-end of the Speaker Meet application
    is written in .NET with C# and Entity Framework Core and a SQL Server database.
    These technologies provide an excellent opportunity to create technical separations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web标识类似，一个团队可能会决定将故事分为服务器端或后端功能。这可能涵盖从API到数据库以及所有中间的功能。Speaker Meet应用程序的后端是用.NET、C#和Entity
    Framework Core以及SQL Server数据库编写的。这些技术为创建技术分离提供了极好的机会。
- en: Defining a consistent API, for example, is an excellent place to start. How
    the back-end might be further subdivided is discussed later in this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一致的API，例如，是一个很好的起点。后端可能如何进一步细分将在本章后面讨论。
- en: Technical requirements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Speaker Meet application has an assortment of technical requirements. Language
    choices and platform decisions can have an immense effect on an application. These
    decisions will determine how an application is delivered to a client and how many
    parts of the application are expected to behave.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet应用程序有一系列的技术要求。语言选择和平台决策可以对应用程序产生巨大影响。这些决策将决定应用程序如何交付给客户端以及预期应用程序的哪些部分应该表现如何。
- en: Technology specifications can have a big impact on an application. Whether **LAMP**
    (**Linux, Apache, MySQL, PHP**/**Perl**/**Python**), **MEAN** (**MongoDB, Express,
    Angular, Node**), or in the case of Speaker Meet .NET and React, programming languages
    and frameworks can play a big role in a software system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 技术规范可以对应用程序产生重大影响。无论是**LAMP**（Linux, Apache, MySQL, PHP/Perl/Python），**MEAN**（MongoDB,
    Express, Angular, Node），还是Speaker Meet中的.NET和React，编程语言和框架在软件系统中可以发挥重要作用。
- en: React web user interface
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Web用户界面
- en: The first *user interface d*efined for the Speaker Meet application is an SPA using
    React, a JavaScript library. React was written by the Facebook team for the purpose
    of developing modern web applications. This equates to the View in the traditional
    *Model-View-Controller* template. By using a one-way data flow model along with
    the *Virtual DOM*, React is an extremely powerful library that performs well and
    scales nicely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet应用程序的第一个*用户界面*定义为使用React的SPA，React是一个JavaScript库。React是由Facebook团队编写的，用于开发现代Web应用程序。这相当于传统*模型-视图-控制器*模板中的视图。通过使用单向数据流模型以及*虚拟DOM*，React是一个功能强大、性能出色且可扩展性良好的库。
- en: Many additional libraries will be included using the JavaScript package manager
    NPM. Additional libraries include webpack, a bundler for JavaScript, CSS, and
    other such files. More will be introduced in the following chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用JavaScript包管理器NPM包含许多额外的库。额外的库包括webpack，一个用于JavaScript、CSS和其他类似文件的打包器。更多内容将在后续章节中介绍。
- en: .NET Core
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core
- en: The primary language for the server-side application will be C# in .NET Core.
    With the release of the latest overhaul to the .NET Framework, developers can
    choose which parts of the framework to include within their application and keep
    core level libraries to a minimum.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端应用程序的主要语言将是.NET Core中的C#。随着最新版本的.NET Framework的重构发布，开发者可以选择将框架的哪些部分包含在他们的应用程序中，并将核心级库保持到最小。
- en: .NET Web API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Web API
- en: The way to expose internal information and behavior to an external system, and
    the SPA is considered an external system, is to provide an **Application Programming
    Interface** (**API**). The API layer exposes data functionality to the outside
    world. The primary gateway into the application is an assemblage of APIs using
    .NET Web API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将内部信息和行为暴露给外部系统的方式，SPA被视为外部系统，是通过提供一个**应用程序编程接口**（**API**）。API层向外界暴露数据功能。应用程序的主要入口是一个由.NET
    Web API组成的API集合。
- en: Entity Framework
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体框架
- en: For the Speaker Meet application, an **Object-Relational Mapper** (**ORM**)
    is utilized to convert database objects into C# objects. There are many such ORMs
    available for a variety of different languages and platforms. In .NET alone there
    is NHibernate, LLBLGen, Dapper, and many more. For the Speaker Meet application,
    **Entity Framework** (**EF**) Core was selected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于演讲者见面应用，使用了**对象关系映射器**（**ORM**）将数据库对象转换为C#对象。有众多这样的ORM适用于各种不同的语言和平台。仅.NET就有NHibernate、LLBLGen、Dapper等许多ORM。对于演讲者见面应用，选择了**Entity
    Framework**（**EF**）Core。
- en: Choosing an ORM mapper such as EF Core in and of itself is a requirement that
    will affect architectural choices for an application. The team will likely need
    to determine the pros and cons of ORM options available to them, and whether to
    use an ORM at all.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个如EF Core这样的ORM映射器本身就是一个要求，它将影响应用程序的架构选择。团队可能需要确定他们可用的ORM选项的优缺点，以及是否需要使用ORM。
- en: Azure
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure
- en: The Speaker Meet application is hosted using Microsoft Azure. Choosing Azure
    allows the team to scale up or down parts of the application as demand arises.
    Of course, there are architectural decisions that must be made to effectively
    leverage the available functionality that Azure provides.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲者见面应用使用Microsoft Azure进行托管。选择Azure允许团队根据需求增加或减少应用程序的部分。当然，必须做出一些架构决策，以有效地利用Azure提供的可用功能。
- en: Knowing about upcoming or desired future functionality can allow a team to make
    wise decisions while developing parts of an application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 了解即将到来或期望的未来功能，可以使团队在开发应用程序的部分时做出明智的决定。
- en: Future enhancements are planned to employ the power of Azure Search. The core
    search functionality was written in such a way that switching to Azure Search
    would have minimal impact on the rest of the system. Implementing Azure Search,
    of course, would be developed using TDD.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 计划未来的增强功能以利用Azure Search的力量。核心搜索功能是以一种方式编写的，切换到Azure Search将对系统其他部分的影响最小。当然，实现Azure
    Search将使用TDD（测试驱动开发）。
- en: Database
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: Microsoft SQL Azure is utilized to persist speaker information, user group and
    community particulars, information about conferences, as well as user login details.
    SQL Azure is very similar to using SQL Server on-premise, with a few caveats.
    For example, SQL Azure requires clustered indexes on each table. Knowing the requirements
    and differences of available database options allows the team to make an informed
    decision about their data storage choices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Microsoft SQL Azure来持久化演讲者信息、用户群体和社区细节、会议信息以及用户登录详情。SQL Azure与在本地使用SQL Server非常相似，但有几点需要注意。例如，SQL
    Azure要求每个表都有聚集索引。了解可用数据库选项的要求和差异，使团队能够就他们的数据存储选择做出明智的决定。
- en: An N-Tiered hexagonal architecture
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N层六边形架构
- en: In a previous chapter, the N-Tiered architecture was discussed, where a software
    application is divided up into layers. N-Tiered applications are typically separated
    in successive layers, like the layers of a cake, from *A* to *B* to *C* and so
    on. There is a danger in defining an application in this way, as sometimes pieces
    of functionality don't cleanly fall into one layer. As long as the layers remain
    loosely coupled and functionality does not cross the boundaries, your application
    should remain well-structured and organized.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了N层架构，其中软件应用程序被划分为多个层次。N层应用程序通常像蛋糕的层次一样，从*A*层到*B*层再到*C*层，依此类推。以这种方式定义应用程序存在风险，因为有时功能组件并不能干净利落地归入某一层。只要层次之间保持松散耦合，功能不跨越边界，您的应用程序应该保持良好的结构和组织。
- en: Hexagonal architecture
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六边形架构
- en: The hexagonal architecture was first described by Alistair Cockburn in the 2000s.
    Hexagonal architecture has also been referred to as ports and adapters, in which
    ports are abstractions and adapters are the implementations. This approach to
    designing applications changes the concept of layers to one of internal and external
    pieces to the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '六边形架构最早由Alistair Cockburn在2000年代提出。六边形架构也被称为端口和适配器，其中端口是抽象，适配器是实现。这种设计应用程序的方法改变了层级的概念，将其转变为应用程序的内部和外部组件。 '
- en: 'Some may argue that the hexagonal architecture and N-Tiered architecture are
    one and the same. While it''s possible to achieve a hexagonal architecture using
    an N-Tiered linear layered approach, the main distinction lies in how the layers
    interact with one another—linear or through specific ports and adapters: two distinct
    zones, internal and external bits. In the simplest of terms, a hexagonal method
    will save you in the event that something doesn’t fit neatly into a series of
    sequential layers and helps to prevent tight coupling between layers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，六边形架构和N层架构是相同的。虽然可以使用N层线性分层方法实现六边形架构，但主要区别在于层与层之间的交互方式——线性或通过特定的端口和适配器：两个不同的区域，内部和外部部分。用最简单的话说，六边形方法可以在某些东西无法整齐地放入一系列连续层次时为您提供帮助，并有助于防止层之间的紧密耦合。
- en: The main thing to remember is that there are things that need to be separated—data
    source, user interface, third-party libraries, frameworks—essentially anything
    that isn't written by your team, possibly even the layers themselves. With the
    use of the *Dependency Inversion Principle*, as discussed in a previous chapter,
    and the *Repository Pattern,* coupling can be kept to a minimum. This allows for
    greater flexibility, maintainability, and testability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的主要是，有一些东西需要分离——数据源、用户界面、第三方库、框架——基本上是任何不是由您的团队编写的组件，甚至可能包括层次本身。通过使用在前一章中讨论的*依赖倒置原则*和*仓储模式*，可以将耦合度降至最低。这提供了更大的灵活性、可维护性和可测试性。
- en: Greater flexibility can be provided by minimizing coupling between parts. New
    features can be plugged into the existing application. Existing parts of an application
    can be swapped out in favor of something else entirely. This simply cannot be
    done if existing parts of your application are tightly coupled to other parts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最小化组件之间的耦合，可以提供更大的灵活性。新功能可以插入到现有应用程序中。现有应用程序的部分可以被替换为其他完全不同的东西。如果现有应用程序的部分与其他部分紧密耦合，这是无法做到的。
- en: If an application is segmented properly, it becomes much easier to maintain.
    By strictly adhering to the SOLID Principles as outlined in a previous chapters,
    this becomes almost effortless. With the strict adherence to hexagonal design
    and by keeping internal logic free from outside dependencies, it is simple to
    make modifications without impacts on other parts of the system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序被正确分割，维护起来会容易得多。通过严格遵循在前几章中概述的SOLID原则，这几乎变得轻而易举。通过严格遵循六边形设计和保持内部逻辑不受外部依赖的影响，可以轻松地进行修改，而不会影响系统的其他部分。
- en: Testing a loosely coupled system is much easier than the alternative. By limiting
    the dependencies, tests can be limited to the functionality of the method, function,
    or system under test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试松散耦合的系统比其他方法要容易得多。通过限制依赖关系，测试可以限制在测试的方法、函数或系统功能上。
- en: Basic yet effective N-Tiered divisions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本而有效的N层划分
- en: Typical layers in a three-tiered application include presentation, business
    logic, and data access. These can be and often are subdivided even further, but
    this is a basic starting point for many applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 三层应用程序中的典型层包括表示层、业务逻辑和数据访问。这些可以进一步细分，但这对于许多应用程序来说是一个基本的起点。
- en: By dividing an application in this way, the first separation of concerns is
    born. Business logic should not be found in the presentation layer. Data access
    code should not be found in the business logic layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式划分应用程序，产生了第一个关注点的分离。业务逻辑不应出现在表示层。数据访问代码不应出现在业务逻辑层。
- en: A place for everything and everything in its place.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都有其位，一切都在其位。
- en: -Mary Poppins
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: -玛丽·波平斯
- en: Service layer
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务层
- en: The business layer, or *service layer*, is where the business logic for the
    application resides. Whether you choose to use the idea of individual services,
    managers, or domain objects, the idea is effectively the same. The logic of the
    application should reside in a separate place from the presentation information
    and data access code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层，或称为*服务层*，是应用程序业务逻辑所在的地方。无论你选择使用单个服务、管理器还是领域对象的概念，其本质上是相同的。应用程序的逻辑应该位于与表示信息和数据访问代码分开的地方。
- en: Microservices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: You may have heard the term *microservices* at some point in your development
    career. These are typically very small, independent applications that serve one
    and only one purpose for the rest of the system. Whether they be standalone APIs
    or executables deployed to Azure Service Fabric, they can be developed and deployed
    independently from the rest of the application. Microservices tend to be small,
    reusable functions, often consumed by a number of different applications or deployed
    user interfaces.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发生涯中，你可能在某个时刻听说过*微服务*这个术语。这些通常是极小、独立的应用程序，为系统中的其他部分服务一个且仅有一个目的。无论是作为独立API还是部署到Azure
    Service Fabric的可执行文件，它们都可以独立于应用程序的其他部分进行开发和部署。微服务通常是小型、可重用的函数，通常被多个不同的应用程序或部署的用户界面所消费。
- en: Data access layer
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问层
- en: Instead of littering the rest of the application with data persistence code,
    many applications rely on a data access layer of some sort. This allows for a
    centralized location of all data retrieval and storage procedures.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在应用程序的其他部分散布数据持久化代码，许多应用程序依赖于某种类型的数据访问层。这允许所有数据检索和存储过程集中在一个地方。
- en: As the Speaker Meet application relies on EF Core, the data access layer is
    where much of this information will reside.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Speaker Meet应用程序依赖于EF Core，数据访问层将是这些信息存储的主要地方。
- en: Repository Pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库模式
- en: The Repository Pattern allows for abstraction between the domain layer and the
    data access layer. This allows for the rest of the application to be agnostic
    to the way data is persisted or retrieved. This allows for improved testability
    and for code reuse within the repositories themselves.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式允许在领域层和数据访问层之间进行抽象。这允许应用程序的其他部分对数据持久化或检索的方式保持无知。这提高了测试性，并在仓库本身中实现了代码重用。
- en: Generic repository
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用仓库
- en: As much of the data access functionality is the same across database models,
    a g*eneric repository* is used to minimize duplication of code. Many standard
    **CRUD** (**Create, Read, Update, Delete**) operations are used across all database
    objects. This provides the opportunity to create a generic repository to be used
    across all models and this will be covered in [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195),
    *Test Driving C# Applications*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分数据访问功能在数据库模型之间是相同的，因此使用通用仓库来最小化代码重复。许多标准的**CRUD**（**创建、读取、更新、删除**）操作被用于所有数据库对象。这为创建一个可用于所有模型的通用仓库提供了机会，这将在[第7章](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195)，“测试驱动C#应用程序”中介绍。
- en: As in life, often one size does not fit all. While the generic repository fits
    most cases, there may come a time when you need to create a specific repository
    or to extend the generic repository. These instances should be carefully evaluated
    and a proper solution should be put in place for them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活中一样，往往不是所有情况都适用单一模式。虽然通用仓库适用于大多数情况，但可能有时你需要创建一个特定的仓库或扩展通用仓库。这些情况应该仔细评估，并为他们制定适当的解决方案。
- en: User interface adapter layer
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面适配层
- en: The user interface adapter layer is where a user interface can "plug in" to
    the rest of the application. The Speaker Meet application provides a collection
    of web APIs to provide data and functionality to external systems. The first such
    external system is the React SPA. Utilizing a user interface adapter layer allows
    for the replacement or addition of a new UI application. This could be in the
    form of native mobile application, a Facebook application, or integration with
    another external site such as Meetup.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面适配层是用户界面可以“插入”到应用程序其余部分的地方。演讲者见面应用程序提供了一系列网络 API，以向外部系统提供数据和功能。第一个这样的外部系统是
    React SPA。利用用户界面适配层允许替换或添加新的 UI 应用程序。这可能是一种原生移动应用程序、Facebook 应用程序，或者与另一个外部网站（如
    Meetup）的集成。
- en: User interface layer
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面层
- en: Modern applications have a dual N-Tiered approach with architectures on both
    the back-end and front-end. This means that as much planning and separation as
    is done on the server side, the same amount of effort could also be spent architecting
    a UI application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序在前后端都有双 N 层架构。这意味着在服务器端所做的尽可能多的规划和分离，同样多的努力也可以用于架构 UI 应用程序。
- en: With much of the functionality of an entire system being delivered to the client,
    the SPA in the case of the Speaker Meet system can be treated as a wholly independent
    application. It, too, must have its own application architecture specification.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个系统的许多功能都交付给了客户端，在演讲者见面系统中，SPA 可以被视为一个完全独立的应用程序。它也必须有自己的应用程序架构规范。
- en: Front-end business layer
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端业务层
- en: Using Redux action creators allows for front-end business logic to be contained
    in a single layer or location. Within an action creator, behavior can be encapsulated
    and concerns separated. Reusable functions may be exposed, minimizing code duplication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Redux 动作创建者可以将前端业务逻辑包含在单个层或位置中。在动作创建者中，行为可以被封装，关注点可以被分离。可重用函数可以被公开，从而最小化代码重复。
- en: Front-end user interface layer
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端用户界面层
- en: React components and containers provide the presentation to the end user. Reusable
    components should be created and kept small, and without external dependencies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件和容器为最终用户提供展示。应该创建可重用组件并保持它们小巧，且没有外部依赖。
- en: Front-end data source layer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端数据源层
- en: Using React with Redux, data will be stored in state on the client's machine
    by way of a reducer. The shape of the data store should be carefully planned and
    evaluated. If something is not shared by more than one component, then it should
    likely not be placed in state. If you need the same data to take on many shapes,
    consider the use of something such as React Reselect, which provides a way to
    transform or compute derived data for use throughout your application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 和 Redux，数据将通过 reducer 存储在客户端机器的状态中。数据存储的形状应该仔细规划和评估。如果某个东西不是由多个组件共享的，那么它很可能不应该放在状态中。如果你需要相同的数据以多种形状出现，可以考虑使用像
    React Reselect 这样的工具，它提供了一种在整个应用程序中使用转换或计算派生数据的方法。
- en: Testing direction
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方向
- en: 'Now that you have a basic plan for your architecture you have to think about
    where you should begin your testing. There are a few options for where to start:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的架构制定了一个基本的计划，你必须考虑你应该从哪里开始测试。有几个选择来确定开始的地方：
- en: You could choose to start testing at the data access or data source layers and
    work your way up to the user interface layers. This method is a back-to-front
    approach to testing.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以选择从数据访问层或数据源层开始测试，然后逐步向上到用户界面层。这种方法是测试的从后向前的方法。
- en: You could start at the user interface layers and work your way to the data access
    layers. Approaching the tests in this manner is a front-to-back method of testing.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从用户界面层开始，然后逐步到数据访问层。以这种方式进行测试是一种从前往后的测试方法。
- en: Lastly, you could start testing in the business layers and work your way out
    to the hexagonal boundaries of the system. This method is an inside-out testing
    approach.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你可以从业务层开始测试，然后逐步扩展到系统的六边形边界。这种方法是内部到外部的测试方法。
- en: As a demonstration of the three testing directions to be examined, the same
    scenario of user login will be used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为要检查的三种测试方向的演示，将使用相同的用户登录场景。
- en: Back-to-front
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从后向前
- en: Most back-end developers have been taught to think in a database-first manner.
    This style of thinking will lead them to find that a back-to-front style of testing
    makes more sense. As mentioned previously, in back-to-front testing you start
    at the data access layers. Mentally you really start by imagining the data structure
    within the data source. Once a data source has been defined, you can move up a
    layer and begin thinking about the business layer's design. Finally, you can apply
    the models and functionality you have created to a user interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数后端开发者都接受过以数据库优先的方式进行思考的教育。这种思考方式会让他们发现，从后往前的方式进行测试更有意义。如前所述，在后往前测试中，你从数据访问层开始。在心理上，你实际上是通过想象数据源内的数据结构来开始的。一旦定义了数据源，你就可以向上移动一层，开始考虑业务层的设计。最后，你可以将创建的模型和功能应用到用户界面。
- en: Defining a data source
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据源
- en: By starting in the data layer, you are presented with defining your data model
    as early as possible. For this application and the requirements you have received,
    we suggest you go with a SQL database and use an entity framework for your data
    connections. Since you are working in a relational database, you will need some
    kind of primary key. These keys are for relational database concerns and are often
    not mentioned in the system requirements. In a situation like this you might end
    up with a table that looks something like this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从数据层开始，你可以尽早定义你的数据模型。对于这个应用程序和收到的需求，我们建议你使用SQL数据库，并使用实体框架进行数据连接。由于你在一个关系型数据库中工作，你需要某种类型的主键。这些键是针对关系型数据库的关注点，通常在系统需求中不会提及。在这种情况下，你可能会得到一个看起来像这样的表。
- en: '| UserProfile |  |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 用户资料 |  |  |'
- en: '| **ID** | **Integer** | **Primary Key, Identity** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **Integer** | **主键，自增** |'
- en: '| Username | `Varchar(255)` | Unique, Not Null |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | `Varchar(255)` | 唯一，非空 |'
- en: '| PasswordHash | `Binary(64)` | Not Null |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 密码散列 | `Binary(64)` | 非空 |'
- en: '| FirstName | `Varchar(255)` | Not Null |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 首名 | `Varchar(255)` | 非空 |'
- en: Now that you have a table defined, you can see that, instead of having a simple
    password field, you must use a password hash for security reasons. The next step
    is to create the data access layer code that will interact with this table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个表，你可以看到，由于安全原因，你不仅需要一个简单的密码字段，还必须使用密码散列。下一步是创建与该表交互的数据访问层代码。
- en: Start with tests to properly define the model. These tests will provide some
    of the validations defined in your requirements and put you in a good place to
    define the entity framework model builder relationships.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试开始，正确地定义模型。这些测试将提供一些在需求中定义的验证，并为你定义实体框架模型构建器关系提供一个良好的起点。
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are the tests that will get you started testing the model, the rest is
    up to you as an exercise. At the end of it, you should have a model that looks
    similar to this one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试将帮助你开始测试模型，其余的作为练习由你自己来完成。在完成之后，你应该有一个看起来与这个类似的模型。
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this model is not too complicated, but could get that way quickly
    if the number of database fields needed to expand. This is only a partial example
    of what a user profile would look like. Before moving on, think about what other
    fields would be needed and how they might need to be tested.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个模型并不复杂，但如果需要扩展的数据库字段数量增加，它可能会很快变得复杂。这只是一个用户资料可能看起来的部分示例。在继续之前，考虑一下还需要哪些其他字段，以及它们可能需要如何进行测试。
- en: Now that you have a data transfer object, you need to be able to read that model
    into the application from the database. As mentioned in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195),
    *Setting up a JavaScript Environment*, in the *What to Know Before Getting Started*
    section, we prefer to use a repository pattern for this. As a quick recap, the
    repository pattern is a simple pattern that helps us deal with create, read, update,
    and delete operations on a data source.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个数据传输对象，你需要能够从数据库中将该模型读入应用程序。如[第3章](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)中所述，“在开始之前需要了解的内容”部分，我们更倾向于使用仓库模式。作为一个快速回顾，仓库模式是一个简单的模式，帮助我们处理数据源上的创建、读取、更新和删除操作。
- en: We are only going to use as much of the `FakeRepository` as is needed. For now
    that means that we will only implement `Get` and `GetAll`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会使用`FakeRepository`中所需的部分。目前这意味着我们只会实现`Get`和`GetAll`。
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we are using a `FakeRepository`, we can move on to business layer integration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用`FakeRepository`，我们可以继续到业务层集成。
- en: Creating a business layer
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建业务层
- en: Using the `UserProfileDto` defined previously, you can now focus on the service
    needed to log on. As you will be dealing with the `UserProfileDto` and repository,
    call this the `UserProfileService`. It will house all the interactions in the
    app with user profile objects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前定义的 `UserProfileDto`，你现在可以专注于登录所需的服务。由于你将处理 `UserProfileDto` 和存储库，将其称为 `UserProfileService`。它将包含应用中与用户资料对象的所有交互。
- en: Right now, you only need to worry about the logon capabilities of the system.
    You will create a `GetUser` method which will consume a username and return a
    `UserProfile`. Then you will use the `UserProfile` and a password to authenticate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需要关注系统的登录功能。你将创建一个 `GetUser` 方法，它将接受一个用户名并返回一个 `UserProfile`。然后你将使用 `UserProfile`
    和密码进行认证。
- en: First, here is the starting test to create a `UserProfileService`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是创建 `UserProfileService` 的起始测试。
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we normally do at this point is create a new class and a folder structure
    to support tests related to the `UserProfileService`. Our next test class with
    be for testing the `GetUserProfile` method, so we will create the folder structure
    and add that test class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在这个阶段创建一个新的类和文件夹结构来支持与 `UserProfileService` 相关的测试。我们的下一个测试类将是用于测试 `GetUserProfile`
    方法的，因此我们将创建文件夹结构并添加该测试类。
- en: 'Folder structure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构：
- en: '![](img/00018.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00018.jpeg)'
- en: Now write tests for a `GetUserProfile` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写 `GetUserProfile` 方法的测试。
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, we will let you implement the class method that will pass these
    tests. Remember, we only want to the write a minimal amount of code to pass the
    tests. You will also want to create tests to verify case insensitivity, if that
    is something you believe the system needs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将让你实现一个类方法，该方法将通过这些测试。记住，我们只想编写足够少的代码来通过测试。你还将想要创建测试来验证不区分大小写，如果你认为系统需要的话。
- en: Now that you have a user profile, you need to verify that the password supplied
    by the user is the correct password. We won't be getting into security concerns
    too much as part of this book, but you should know that passwords should be a
    one-way hash. Now, write the test to check the password before you move on to
    creating a user interface for logging in.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个用户资料，你需要验证用户提供的密码是否正确。在这本书的部分内容中，我们不会过多涉及安全问题，但你应该知道密码应该是一个单向散列。现在，在你继续创建登录用户界面之前，先编写测试来检查密码。
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Building a user interface
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Now there is enough functionality for you to begin working on your user interface.
    In a C# web API, the user interface is an API controller. The basic tests needed
    for an API controller are that it exists and that it inherits correctly from the
    controller class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经有了足够的功能，你可以开始着手用户界面了。在 C# Web API 中，用户界面是一个 API 控制器。API 控制器所需的基本测试是它存在并且正确地从控制器类继承。
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, you need to make sure it has a logon method that accepts a username and
    password. That same method must also return either a 200 OK or 401 NOT AUTHORIZED,
    depending on the validity of the user information:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保它有一个接受用户名和密码的登录方法。该方法必须根据用户信息的有效性返回 200 OK 或 401 NOT AUTHORIZED：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One of the downsides to approaching the application in this manner is that now
    almost all of our layers are concerned with an object that is almost an exact
    representation of the database. Normally, this is not a real problem. But database
    tables do change so what if our user profile table needs some touching up in the
    future? Our entire application will need to be updated at this point. Did you
    pick up on some of the side-effects of thinking about the application in a back-to-front
    way? If not, that is okay, but keep an eye open as you explore the two other directional
    approaches.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理应用程序的一个缺点是，现在我们几乎所有的层都关注于几乎与数据库完全相同的对象。通常，这并不是真正的问题。但是数据库表确实会发生变化，那么如果我们的用户资料表在未来需要一些调整怎么办？此时，我们的整个应用程序都需要更新。你是否注意到了以反向方式思考应用程序的一些副作用？如果没有，那没关系，但在你探索其他两种方向方法时，请保持警觉。
- en: Front-to-back
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前后端
- en: Another way that some developers choose to approach application design and implementation
    is from a user experience perspective. First, think about how the user would want
    to interact with the system, then design the system around that concept.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者选择从用户体验的角度来处理应用程序设计和实现。首先，思考用户如何希望与系统交互，然后围绕这个概念设计系统。
- en: Defining a user interface
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: To attack the application in this way, first you must determine what you think
    the best user experience would be. It would probably be best if the user not only
    got notified whether the logon was accepted, but also received a message explaining
    to them the current status.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式攻击应用程序，首先你必须确定你认为最好的用户体验是什么。如果用户不仅得到登录是否被接受的通知，而且还收到解释当前状态的消息，那可能最好。
- en: What would you call our controller when testing from this direction? The user
    is wanting to log on so, you should call it a logon controller.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个方向测试时，你会称我们的控制器叫什么？用户想要登录，所以，你应该称它为登录控制器。
- en: As before, you need to test that your controller exists. Then test that it properly
    inherits from the controller.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你需要测试你的控制器是否存在。然后测试它是否正确地继承自控制器。
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, you can test for your API method. What should it be called? Think again
    about the user. They are trying to log on so, again, we should probably stick
    with something simple related to logon. The default post action on this controller
    should probably be the method used to activate a logon.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以测试你的API方法。它应该叫什么？再想想用户。他们正在尝试登录，所以，我们可能应该坚持与登录相关的简单名称。这个控制器的默认POST操作可能应该是激活登录的方法。
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the front-to-back directional approach, you don't yet have any of your
    dependencies defined so you have no choice but to hardcode decisions. You can
    push those decisions back slightly, though.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从前往后的方向性方法，你还没有定义任何依赖项，所以你别无选择，只能硬编码决策。尽管如此，你可以稍微将这些决策推后。
- en: Creating a business layer
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建业务层
- en: Create an interface and move your valid user login into a fake logon service
    for that interface.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接口，并将有效的用户登录移动到该接口的模拟登录服务中。
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you are following along, you will need to update all the controller references
    in the tests to use this new fake logon service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，你需要在测试中更新所有控制器引用以使用这个新的模拟登录服务。
- en: Now that you have an interface defined, you can write tests to create a service
    layer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经定义了接口，你可以编写测试来创建服务层。
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Building a data source
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据源
- en: Now that you have a service, you can focus on the data layer. Believe it or
    not, this part is not really any different from what we did at this stage for
    the back-to-front approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了服务，你可以专注于数据层。信不信由你，这部分实际上与我们之前在从后到前的方法中做的没有太大区别。
- en: We have managed to do one thing differently. We have created a contract for
    our data interaction. The rest of the table, if we are using a relational data
    store, could be anything and we don't care. We only care about the username and
    password hash. We only have ID because the `FakeRepository` requires it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地做了一件事不同。我们为我们的数据交互创建了一个合约。如果我们使用关系型数据存储，表的其余部分可以是任何东西，我们不在乎。我们只关心用户名和密码散列。我们只有ID，因为`FakeRepository`需要它。
- en: There are ways to program the repository that do not require this feature. We
    are not going to recreate the table from the previous example. It is the same
    table.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些编程存储库的方法不需要这个功能。我们不会从上一个示例中重新创建表。它是一样的表。
- en: Inside out
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内外结合
- en: The last directional approach that we are going to cover in this chapter is
    the inside-out approach. With the inside-out approach, you begin, not with the
    UI or the data source, but instead with the business rules defined in the requirements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要介绍的最后一个方向性方法是“内外结合”方法。使用内外结合方法，你开始时不是从UI或数据源开始，而是从需求中定义的业务规则开始。
- en: Defining a business layer
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义业务层
- en: 'Looking back at our requirements, we can build tests and logic that are a one-to-one
    match for our requirements such as:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的需求，我们可以构建与我们的需求一对一匹配的测试和逻辑，例如：
- en: Given a registered speaker
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个已注册的演讲者
- en: And given an invalid username
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个无效的用户名
- en: When attempting login
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试登录时
- en: Then an INVALID_USERNAME_OR_PASSWORD error occurs
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后发生INVALID_USERNAME_OR_PASSWORD错误
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Some significant changes are made by the next requirement in order to provide
    some latitude going forward.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需求为了提供一些前进的空间，做了一些重大改变。
- en: Given a registered speaker
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个已注册的演讲者
- en: And given a valid username
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个有效的用户名
- en: And given a valid password
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个有效的密码
- en: When attempting login
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试登录时
- en: Then the user is granted access to the application
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后用户被授予访问应用程序的权限
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now for the last requirement that we were provided:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一个我们提供的需求：
- en: Given a registered speaker
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个已注册的演讲者
- en: And given a valid username
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个有效的用户名
- en: And given an invalid password
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个无效的密码
- en: When attempting login
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试登录时
- en: Then an INVALID_USERNAME_OR_PASSWORD error occurs
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后发生了一个INVALID_USERNAME_OR_PASSWORD错误
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This last test was quite simple and closely resembles the first test we wrote
    for inside-out development. One thing to note, but which we are not showing here,
    is that we had to extend our `UserCredentials` class with the password hash property.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个测试相当简单，与我们在内部开发中编写的第一个测试非常相似。有一点需要注意，但在这里我们没有展示，那就是我们必须扩展我们的`UserCredentials`类以包含密码哈希属性。
- en: Creating the user interface and data layers from this point is almost exactly
    like what we have shown in the earlier examples, so we will not show them here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始创建用户界面和数据层几乎与我们在早期示例中展示的完全一样，所以这里我们不会展示它们。
- en: The tasks left for this example are abstracting the business layer behind an
    interface, using the business object in the UI, and creating the appropriate data
    configuration for the data layer.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，剩余的任务是将业务层抽象化到接口后面，在UI中使用业务对象，并为数据层创建适当的数据配置。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've defined the Speaker Meet application in more detail. Architectural
    choices were discussed and a path has been set. Epics, features, and user stories
    have been covered in enough detail that we're now ready to take the next steps
    with the Speaker Meet application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更详细地定义了演讲者见面应用。讨论了架构选择，并设定了路径。史诗、功能和用户故事已经足够详细，我们现在可以准备与演讲者见面应用迈出下一步。
- en: In [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195), *Test
    Driving C# Applications*, we'll focus on test driving the C# API. Topics such
    as *fakes, stubs, *and *mocks* will be introduced to help you navigate the testing
    world.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195)，“测试驱动C#应用程序”，我们将专注于测试驱动C#
    API。将介绍诸如**模拟**、**存根**和**模拟对象**等主题，以帮助您在测试世界中导航。
