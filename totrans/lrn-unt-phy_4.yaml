- en: Chapter 4. Rigidbody Types and Their Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Rigidbody类型及其属性
- en: In this chapter, we will learn about the types of Rigidbody components and their
    properties. To detect collision, add gravity, and several other Physics functionalities,
    a game object must have a Rigidbody component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Rigidbody组件的类型及其属性。为了检测碰撞、添加重力以及实现其他物理功能，游戏对象必须具有Rigidbody组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of Rigidbody components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody组件的类型
- en: Properties of Rigidbody components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody组件的属性
- en: Example using Rigidbody components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rigidbody组件的示例
- en: We can handle a Rigidbody component using a script as well as by manually applying
    linear and angular velocity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用脚本以及手动应用线性和角速度来处理Rigidbody组件。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For accurate Physics calculation, a Rigidbody component requires a collider
    component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行准确的物理计算，Rigidbody组件需要一个碰撞器组件。
- en: Types of Rigidbody components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rigidbody组件的类型
- en: 'We enable our game objects to act under the control of Physics using Rigidbodies.
    Here, we will learn how to use and handle a Rigidbody component. A Rigidbody can
    be handled in two ways:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Rigidbody使我们的游戏对象在物理控制下行动。在这里，我们将学习如何使用和处理Rigidbody组件。Rigidbody可以通过两种方式处理：
- en: Physics Rigidbody
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理Rigidbody
- en: Kinematic Rigidbody
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动力学Rigidbody
- en: Physics Rigidbody
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理Rigidbody
- en: To influence a game object by gravity or forces, the game object must have a
    Rigidbody. When a Rigidbody is completely controlled by the engine, it is called
    a Physics Rigidbody. We can manually apply forces and torque to handle linear
    and angular velocity of a game object. Manual implementation of forces and torque
    gives you the freedom to get the desired effect. Let's look at an example of a
    Rigidbody.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过重力或力影响游戏对象，游戏对象必须具有Rigidbody。当一个Rigidbody完全由引擎控制时，它被称为物理Rigidbody。我们可以手动应用力矩来处理游戏对象的线性和角速度。手动实现力和扭矩可以让你获得所需的效果。让我们看看一个Rigidbody的示例。
- en: An example of creating a Physics Rigidbody
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建物理Rigidbody的示例
- en: 'Use the following steps to apply a Physics Rigidbody:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤应用物理Rigidbody：
- en: We will start by creating a new scene and save it as `Physics Rigidbody`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的场景并将其保存为`Physics Rigidbody`。
- en: Create a **Cube** game object, as shown in the following screenshot:![An example
    of creating a Physics Rigidbody](img/00044.jpeg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**立方体**游戏对象，如图所示：![创建物理Rigidbody的示例](img/00044.jpeg)
- en: To enable our game objects to act under the control of Physics, we use Rigidbodies.
    Add the **Rigidbody** component to the cube game object, as shown in the following
    screenshot:![An example of creating a Physics Rigidbody](img/00045.jpeg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的游戏对象在物理控制下行动，我们使用Rigidbody。将**Rigidbody**组件添加到立方体游戏对象中，如图所示：![创建物理Rigidbody的示例](img/00045.jpeg)
- en: In the **Inspector** panel, make sure that the **Is Kinematic** property is
    unchecked. If we enable **Is Kinematic**, the object can only be manipulated by
    its Transform property. Generally, we use this for moving platforms or if we want
    to animate a Rigidbody that has a HingeJoint attached.![An example of creating
    a Physics Rigidbody](img/00046.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，确保**Is Kinematic**属性未被勾选。如果我们启用**Is Kinematic**，则对象只能通过其Transform属性进行操作。通常，我们使用此属性来移动平台或当我们想要动画化一个连接了HingeJoint的Rigidbody时。![创建物理Rigidbody的示例](img/00046.jpeg)
- en: As shown in the previous steps, we can get the desired effect using the different
    properties.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的步骤所示，我们可以使用不同的属性来获得所需的效果。
- en: Kinematic Rigidbody
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动力学Rigidbody
- en: When we check the **Is Kinematic** property of a Rigidbody, it is known as a
    Kinematic Rigidbody. We cannot apply forces or torque manually to a Kinematic
    Rigidbody. We can move a Kinematic Rigidbody by changing the values of a GameObject's
    Transform component. This is useful for moving platforms or animated HingeJoint
    GameObjects where the engine does not handle the object directly and where we
    can manipulate its Transform property as per our requirement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查Rigidbody的**Is Kinematic**属性时，它被称为动力学Rigidbody。我们不能手动对动力学Rigidbody应用力或扭矩。我们可以通过改变GameObject的Transform组件的值来移动动力学Rigidbody。这对于移动平台或动画化的HingeJoint
    GameObjects很有用，在这些情况下，引擎不会直接处理对象，并且我们可以根据需要操作其Transform属性。
- en: '![Kinematic Rigidbody](img/00047.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![动力学Rigidbody](img/00047.jpeg)'
- en: We can use this property by checking it in the **Inspector** panel, as shown
    in the previous screenshot. Now, we will learn about the properties of a Rigidbody
    and their implementation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在**检查器**面板中勾选它来使用此属性，如图中所示的前一个截图。现在，我们将学习Rigidbody的属性及其实现。
- en: Properties of Rigidbody components
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rigidbody组件的性质
- en: 'Let''s get familiar with the properties of a Rigidbody:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉一下Rigidbody的性质：
- en: '**Mass**: If we look at the **Inspector** panel of a Rigidbody component, we
    will see **Mass** as one of the listed properties. This property of a Rigidbody
    defines the mass that should be based on the relative size and density of the
    object that is attached to it. The mass of a Rigidbody defines how much force
    is required to move the Rigidbody fast or slow. We can calculate the force using
    Newton''s law of motion as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：如果我们查看Rigidbody组件的**检查器**面板，我们会看到**质量**作为列出的属性之一。Rigidbody的这个属性定义了基于附着到其上的对象的相对大小和密度的质量。Rigidbody的质量定义了移动Rigidbody所需的力量大小。我们可以使用牛顿运动定律如下计算力：'
- en: '*F=ma*, that is, Force = Mass x Acceleration'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*F=ma*，即力 = 质量 x 加速度'
- en: '**Drag**: This property defines the linear velocity due to air resistance.
    For example, if we need to add an outer-space behavior to a game object, we set
    this value as `0`. An object with mass `1` should have a **Drag** value of `998`
    to resist the force of gravity.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：这个属性定义了由于空气阻力产生的线性速度。例如，如果我们需要向游戏对象添加外太空行为，我们将此值设置为`0`。质量为`1`的对象应该有一个**阻力**值为`998`以抵抗重力。'
- en: '**Angular Drag**: This property defines the angular velocity due to air resistance.
    For example, if we need to add an infinitely-spinning-unless-used external force
    behavior on a game object, we set this value as `0`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻力**：这个属性定义了由于空气阻力产生的角速度。例如，如果我们需要在游戏对象上添加一个无限旋转除非使用外部力的行为，我们将此值设置为`0`。'
- en: '**Use Gravity**: If we want our game object to be affected by gravity, we use
    this behavior.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用重力**：如果我们想让我们的游戏对象受到重力的影响，我们使用此行为。'
- en: '**Is Kinematic**: To add kinematic behavior, we set this to true. By setting
    its behavior to true, we can directly change the position and orientation of the
    Rigidbody using its Transform properties.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是运动学**：为了添加运动学行为，我们将此设置为true。通过将其行为设置为true，我们可以直接使用其变换属性更改Rigidbody的位置和方向。'
- en: '**Interpolate**: Using this property, we make a Rigidbody move smoothly. We
    can adjust the **Interpolate** method using **None**, **Interpolate**, and **Extrapolate**,
    as seen in the following screenshot:![Properties of Rigidbody components](img/00048.jpeg)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值**：使用此属性，我们使Rigidbody平滑移动。我们可以通过**None**、**Interpolate**和**Extrapolate**调整**插值**方法，如以下截图所示：![Rigidbody组件的性质](img/00048.jpeg)'
- en: Using **None**, no interpolation is applied; using **Interpolate**, we smoothly
    transform based on its previous frame; and in **Extrapolate**, we smoothly transform
    based on its estimated next frame.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**None**，不应用插值；使用**Interpolate**，我们根据其前一帧平滑地转换；在**Extrapolate**中，我们根据其估计的下一帧平滑地转换。
- en: '**Collision Detection**: Using this property, we can determine how the Rigidbody
    will perform collision detection with other Rigidbodies. This property consists
    of the following subproperties:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞检测**：使用此属性，我们可以确定Rigidbody将如何与其他Rigidbody执行碰撞检测。此属性包括以下子属性：'
- en: '**Discreet**: By setting this property, we use the simplest form of collision
    detection. At each frame, an intersection test is done. The drawback of this property
    is that small, fast moving objects will pass directly through solid objects.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离散**：通过设置此属性，我们使用最简单的碰撞检测形式。在每一帧，进行一次交点测试。此属性的缺点是，小型快速移动的对象会直接穿过固体对象。'
- en: '**Continuous**: By setting this property, a Rigidbody performs continuous collision
    detection against all the other static colliders.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续**：通过设置此属性，Rigidbody对所有其他静态碰撞器执行连续碰撞检测。'
- en: '**Continuous Dynamic**: By setting this property, a Rigidbody detects the collision
    with fast moving objects.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续动态**：通过设置此属性，Rigidbody可以检测与快速移动对象的碰撞。'
- en: '**Constraints**: This property is used for Physics Rigidbodies. Using this
    property, we can make the position and orientation of a Rigidbody constraint.
    This property consists of the following subproperties:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束**：此属性用于物理Rigidbody。使用此属性，我们可以约束Rigidbody的位置和方向。此属性包括以下子属性：'
- en: '**FreezePosition**: By setting this property, a Rigidbody constrains the linear
    motion'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冻结位置**：通过设置此属性，Rigidbody约束线性运动'
- en: '**FreezeRotation**: By setting this property, the rotation of a Rigidbody is
    prevented'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冻结旋转**：通过设置此属性，防止Rigidbody旋转'
- en: Example using a Rigidbody
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rigidbody的示例
- en: 'Let''s assume that in our game, we require a cube to be our character. In this
    case, we won''t be using the character controller. Let''s follow these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的游戏中，我们需要一个立方体作为我们的角色。在这种情况下，我们不会使用角色控制器。让我们按照以下步骤进行：
- en: Create a new scene and save it as `Rigidbody example`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景并将其保存为`Rigidbody example`。
- en: As shown in the following screenshot, create a **Plane** game object and set
    its properties to position `0` (all axes), rotation `0` (all axes), and scale
    `20`, `1`, `20` for the *x*, *y*, and *z* axes respectively:![Example using a
    Rigidbody](img/00049.jpeg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，创建一个**平面**游戏对象，并将其属性设置为位置`0`（所有轴），旋转`0`（所有轴），以及*x*、*y*、*z*轴的缩放分别为`20`、`1`、`20`：![使用Rigidbody的示例](img/00049.jpeg)
- en: Add a **Cube** game object and a Rigidbody Collider. Place it above the plane.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**立方体**游戏对象和一个Rigidbody碰撞体。将其放置在平面上方。
- en: As shown in the following screenshot, add material to the red cube:![Example
    using a Rigidbody](img/00050.jpeg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，向红色立方体添加材质：![使用Rigidbody的示例](img/00050.jpeg)
- en: Create another **Cube** game object. I have used a white cube without a Rigidbody.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个**立方体**游戏对象。我使用了一个没有Rigidbody的白色立方体。
- en: Create another **Cube** object without a Rigidbody. I have used a blue cube,
    as shown in the following screenshot, and have set the **Is Trigger** property
    to true:![Example using a Rigidbody](img/00051.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个没有Rigidbody的**立方体**对象。我使用了一个蓝色立方体，如图所示，并将**触发器**属性设置为true：![使用Rigidbody的示例](img/00051.jpeg)
- en: In the preceding screenshot, we have set the **Is Trigger** property in the
    blue cube.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们在蓝色立方体中设置了**触发器**属性。
- en: 'Create a new script and save it as `TriggerController.js`; add it to the **Trigger
    Collider** game object and put the following code inside it:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并将其保存为`TriggerController.js`；将其添加到**触发器碰撞体**游戏对象中，并在其中放入以下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code will show the logon events in the console window: **OnTriggerEnter**
    and **OnTriggerExit**.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将在控制台窗口中显示登录事件：**OnTriggerEnter**和**OnTriggerExit**。
- en: Let's move to the next step. Create a new script and save it as `RigidbodyController.js`.
    Add it to the **Red Cube** game object, as shown in the following screenshot:![Example
    using a Rigidbody](img/00052.jpeg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进入下一步。创建一个新的脚本并将其保存为`RigidbodyController.js`。如以下截图所示，将其添加到**红色立方体**游戏对象中：![使用Rigidbody的示例](img/00052.jpeg)
- en: 'Add the following code to the `RigidbodyController.js` script file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`RigidbodyController.js`脚本文件中：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the project and you will see the Rigidbody actions on the red cube by clicking
    on the **Jump** button.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，通过点击**跳跃**按钮，你将看到红色立方体上的Rigidbody动作。
- en: In the preceding example, we have learned how to apply actions on a Rigidbody
    using scripts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何使用脚本在Rigidbody上应用动作。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the types of Rigidbodies and their properties.
    We have seen the properties and uses of the Physics Rigidbody and Is Kinematic
    Rigidbody. We have learned how to implement actions on them using scripts. In
    the next chapter, we will learn about the types of joints and their properties.
    We will also see how we can implement joints on the game objects using different
    examples.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Rigidbody的类型及其属性。我们看到了物理Rigidbody和是运动学Rigidbody的属性和用途。我们学习了如何使用脚本在它们上实现动作。在下一章中，我们将学习关节的类型及其属性。我们还将看到如何通过不同的示例在游戏对象上实现关节。
