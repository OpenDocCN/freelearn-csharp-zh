- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Controlling Flow, Converting Types, and Handling Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程、转换类型和处理异常
- en: This chapter is all about writing code that performs simple operations on variables,
    makes decisions, performs pattern matching, and repeats statements or blocks.
    You will also learn how to work with arrays to store multiple values, how to convert
    variable or expression values from one type to another, how to handle exceptions,
    and how to check for overflows in number variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲解编写对变量执行简单操作、做出决策、执行模式匹配以及重复语句或代码块的代码。你还将学习如何使用数组存储多个值，如何将变量或表达式值从一种类型转换为另一种类型，如何处理异常，以及如何在数字变量中检查溢出。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Operating on variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作变量
- en: Understanding selection statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Understanding iteration statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Storing multiple values in an array
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中存储多个值
- en: Casting and converting between types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换和类型间转换
- en: Handling exceptions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Checking for overflow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查溢出
- en: Operating on variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作变量
- en: '**Operators** apply simple operations such as addition and multiplication to
    **operands** such as variables and literal values. Operators return a new value
    that is the result of the operation and can be assigned to a variable, and they
    can also affect the operands.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符** 对 **操作数**（如变量和字面值）执行简单的操作，如加法和乘法。运算符返回一个新值，它是操作的结果，可以赋给变量，并且它们也可以影响操作数。'
- en: Understanding binary operators
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解二元运算符
- en: 'Most operators are **binary**, meaning that they work on two operands, as shown
    in the following pseudocode:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符是 **二元** 的，意味着它们作用于两个操作数，如下面的伪代码所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Examples of binary operators include adding and multiplying, as shown in the
    following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符的例子包括加法和乘法，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Understanding unary operators
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解一元运算符
- en: 'Some operators are **unary**, meaning they work on a single operand and can
    be applied before or after the operand, as shown in the following pseudocode:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符是 **一元** 的，意味着它们作用于单个操作数，可以在操作数之前或之后应用，如下面的伪代码所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Examples of unary operators include incrementors and retrieving a type or its
    size in bytes, as shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符的例子包括增量运算符和检索类型或其字节大小，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Understanding ternary operators
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解三元运算符
- en: 'A **ternary** operator works on three operands, as shown in the following pseudocode:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**三元** 运算符作用于三个操作数，如下面的伪代码所示：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An example of a ternary operator is the conditional operator `?:`, which acts
    like a simplified `if` statement. The first operand is a Boolean expression, the
    second operand is a value to return if it is `true`, and the third operand is
    a value to return if it is `false`, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符的一个例子是条件运算符 `?:`，它像一个简化的 `if` 语句。第一个操作数是一个布尔表达式，第二个操作数是在它为 `true` 时返回的值，第三个操作数是在它为
    `false` 时返回的值，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: More experienced C# developers adopt ternary operators as much as possible because
    they are concise and can result in cleaner code once you are used to reading them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更有经验的 C# 开发者尽可能多地使用三元运算符，因为它们简洁，一旦习惯了阅读，就可以使代码更清晰。
- en: Exploring unary operators
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索一元运算符
- en: 'Two common unary operators are used to increment, `++`, and decrement, `--`,
    a number. Let us write some example code to show how they work:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 两个常用的 **一元** 运算符用于增加，`++`，和减少，`--`，一个数字。让我们写一些示例代码来展示它们是如何工作的：
- en: If you’ve completed the previous chapters, then you will already have a `cs13net9`
    folder. If not, then you’ll need to create it.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经完成了前面的章节，那么你将已经有一个 `cs13net9` 文件夹。如果没有，那么你需要创建它。
- en: 'Use your preferred code editor to create a new solution and project, as defined
    in the following list:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新的解决方案和项目，如下所示列表：
- en: 'Project template: **Console App** / `console`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `Operators`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Operators`
- en: 'Solution file and folder: `Chapter03`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter03`
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶层语句**：已清除'
- en: '**Enable native AOT publish**: Cleared'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT 发布**：已清除'
- en: 'In `Operators.csproj`, add a new `<ItemGroup>` section to statically import
    `System.Console` for all C# files using the `implicit usings` .NET SDK feature,
    as shown in the following markup:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Operators.csproj` 文件中，添加一个新的 `<ItemGroup>` 部分，以静态导入 `System.Console`，以便所有使用
    `.NET SDK` 的 `implicit usings` 功能的 C# 文件，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Program.cs`, delete the existing statements and then declare two integer
    variables named `a` and `b`; set `a` to `3`, increment `a` while assigning the
    result to `b`, and then output their values, as shown in the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后声明两个名为`a`和`b`的整数变量；将`a`设置为`3`，在赋值时递增`a`并将结果赋给`b`，然后输出它们的值，如下所示代码：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Good Practice**: I recommend wrapping the statements for each section in
    `#region` and `#endregion` (as shown in the preceding code) so that you can easily
    collapse the sections. But I will not show this in future code tasks to save space.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我建议将每个部分的语句包裹在`#region`和`#endregion`（如前述代码所示）中，这样你可以轻松地折叠这些部分。但我在未来的代码任务中不会展示这一点以节省空间。'
- en: 'Before running the console app, ask yourself a question: what do you think
    the value of `b` will be when output? Once you’ve thought about that, run the
    code and compare your prediction against the actual result, as shown in the following
    output:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行控制台应用程序之前，问问自己一个问题：你认为`b`的值在输出时会是多少？一旦你思考过这个问题，运行代码并将你的预测与实际结果进行比较，如下所示输出：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The variable `b` has the value `3` because the `++` operator executes *after*
    the assignment; this is known as a **postfix operator**. If you need to increment
    *before* the assignment, then use the **prefix operator**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`b`的值是`3`，因为`++`运算符是在赋值**之后**执行的；这被称为**后缀运算符**。如果你需要在赋值**之前**递增，那么请使用**前缀运算符**。
- en: 'Copy and paste the statements, and then modify them to rename the variables
    and use the prefix operator, as shown in the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴语句，然后修改它们以重命名变量并使用前缀运算符，如下所示代码：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rerun the code and note the result, as shown in the following output:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并注意结果，如下所示输出：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Good Practice**: Due to the confusion between the prefix and postfix for
    the increment and decrement operators when combined with an assignment, the Swift
    programming language designers decided to drop support for this operator in version
    3\. My recommendation for usage in C# is to never combine the use of the `++`
    and `--` operators with an assignment operator, `=`. Perform the operations as
    separate statements.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：由于增量`++`和减量`--`运算符与赋值运算符`=`结合使用时前缀和后缀之间的混淆，Swift编程语言的设计者决定从版本3开始不支持此运算符。我对于C#的使用建议是永远不要将`++`和`--`运算符与赋值运算符`=`结合使用。将操作作为单独的语句执行。'
- en: Exploring binary arithmetic operators
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索二进制算术运算符
- en: 'Increment and decrement are unary arithmetic operators. Other arithmetic operators
    are usually binary and allow you to perform arithmetic operations on two numbers,
    as the following shows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量是单目算术运算符。其他算术运算符通常是双目运算符，允许你对两个数字执行算术运算，如下所示：
- en: 'Add statements to declare and assign values to two integer variables named
    `e` and `f`, and then apply the five common binary arithmetic operators to the
    two numbers, as shown in the following code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明并给两个名为`e`和`f`的整数变量赋值，然后应用五个常见的二进制算术运算符到这两个数字上，如下所示代码：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下所示输出：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To understand the divide `/` and modulo `%` operators when applied to integers,
    you need to think back to primary school. Imagine you have eleven sweets and three
    friends.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解整数除法`/`和取模`%`运算符，你需要回想起小学。想象你有十一个糖果和三个朋友。
- en: How can you divide the sweets between your friends? You can give three sweets
    to each of your friends, and there will be two left over. Those two sweets are
    the **modulus**, also known as the **remainder** after dividing. If you had twelve
    sweets, then each friend would get four of them, and there would be none left
    over, so the remainder would be zero.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将糖果分给你的朋友们？你可以给每个朋友三个糖果，然后会剩下两个。这两个糖果就是**余数**，也称为除法后的**余数**。如果你有十二个糖果，那么每个朋友会得到四个，就不会剩下，所以余数会是零。
- en: 'Add statements to declare and assign a value to a `double` variable named `g`
    to show the difference between whole-number and real-number divisions, as shown
    in the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明并给一个名为`g`的`double`变量赋值，以显示整数除法和实数除法之间的差异，如下所示代码：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并注意结果，如下所示输出：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the first operand is a floating-point number, such as `g` with the value
    `11.0`, then the divide operator returns a floating-point value, such as `3.6666666666665`,
    rather than a whole number.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数是一个浮点数，例如 `g` 的值为 `11.0`，那么除法运算符返回一个浮点值，例如 `3.6666666666665`，而不是一个整数。
- en: Assignment operators
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: You have already been using the most common assignment operator, `=`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过最常见的赋值运算符 `=`。
- en: 'To make your code more concise, you can combine the assignment operator with
    other operators like arithmetic operators, as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的代码更简洁，你可以将赋值运算符与其他运算符（如算术运算符）结合使用，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Null-coalescing operators
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: Related operators to the assignment operators are the null-coalescing operators.
    Sometimes, you want to either assign a variable to a result or, if the variable
    is `null`, assign an alternative value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与赋值运算符相关的运算符是空合并运算符。有时，你想要将变量赋给结果，或者如果变量为 `null`，则赋给一个替代值。
- en: 'You can do this using the null-coalescing operators, `??` or `??=`, as shown
    in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用空合并运算符 `??` 或 `??=` 来做到这一点，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exploring logical operators
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索逻辑运算符
- en: 'Logical operators operate on Boolean values, so they return either `true` or
    `false`. Let’s explore binary logical operators that operate on two Boolean values,
    traditionally named `p` and `q` in mathematics:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符作用于布尔值，因此它们返回 `true` 或 `false`。让我们探索作用于两个布尔值（在数学中传统上命名为 `p` 和 `q`）的二进制逻辑运算符：
- en: 'In `Program.cs`, add statements to declare two Boolean variables, `p` and `q`,
    with values of `true` and `false`, and then output truth tables showing the results
    of applying AND, OR, and XOR (exclusive OR) logical operators, as shown in the
    following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加语句来声明两个布尔变量 `p` 和 `q`，它们的值分别为 `true` 和 `false`，然后输出应用 AND、OR
    和 XOR（异或）逻辑运算符的结果的真值表，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that `,-5` means left-align within a five-width column.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`,-5` 表示在五个宽度列内左对齐。
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the AND `&` logical operator, both operands must be `true` for the result
    to be `true`. For the OR `|` logical operator, either operand can be `true` for
    the result to be `true`. For the XOR `^` logical operator, either operand can
    be `true` (but not both!) for the result to be `true`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `&` 逻辑运算符，两个操作数都必须为 `true`，结果才为 `true`。对于 `|` 逻辑运算符，任一操作数可以为 `true`，结果才为
    `true`。对于 `^` 逻辑运算符，任一操作数可以为 `true`（但不能同时为 `true`!），结果才为 `true`。
- en: Exploring conditional logical operators
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索条件逻辑运算符
- en: Conditional logical operators are like logical operators, but you use two symbols
    instead of one, for example, `&&` instead of `&`, or `||` instead of `|`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 条件逻辑运算符类似于逻辑运算符，但使用两个符号而不是一个，例如，使用 `&&` 而不是 `&`，或使用 `||` 而不是 `|`。
- en: In *Chapter 4*, *Writing, Debugging, and Testing Functions*, you will learn
    about functions in more detail, but I need to introduce functions now to explain
    conditional logical operators, also known as short-circuiting Boolean operators.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第4章*，*编写、调试和测试函数* 中，你将更详细地了解函数，但我现在需要介绍函数来解释条件逻辑运算符，也称为短路布尔运算符。
- en: 'A function executes statements and then returns a value. That value could be
    a Boolean value like `true` that is used in a Boolean operation. Let’s make use
    of conditional logical operators:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行语句然后返回一个值。这个值可以是用于布尔操作的布尔值，例如 `true`。让我们利用条件逻辑运算符：
- en: 'At the bottom of `Program.cs`, write statements to declare a function that
    writes a message to the console and returns `true`, as shown in the following
    code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部，编写语句来声明一个函数，该函数将消息写入控制台并返回 `true`，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Local functions can be anywhere within the statements in `Program.cs` that use
    the top-level program feature but it is good practice to put them at the bottom
    of the file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数可以在 `Program.cs` 中使用顶级程序功能的任何语句中，但良好的实践是将它们放在文件的底部。
- en: 'After the previous `WriteLine` statements, perform an AND `&` operation on
    the `p` and `q` variables, and the result of calling the function, as shown in
    the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的 `WriteLine` 语句之后，对 `p` 和 `q` 变量以及函数调用的结果执行 AND `&` 操作，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the code, view the result, and note that the function was called twice,
    once for `p` and once for `q`, as shown in the following output:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意函数被调用了两次，一次是 `p`，一次是 `q`，如下面的输出所示：
- en: '[PRE21]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy and paste the three statements and then change the `&` operators into
    `&&` operators, as shown in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴这三个语句，然后将`&`运算符更改为`&&`运算符，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code, view the result, and note that the function does run when combined
    with the `p` variable. It does not run when combined with the `q` variable because
    the `q` variable is `false` so the result will be `false` anyway, so it does not
    need to execute the function, as shown in the following output:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当与`p`变量结合时函数会运行。当与`q`变量结合时不会运行，因为`q`变量是`false`，所以结果无论如何都会是`false`，因此不需要执行函数，如下面的输出所示：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Good Practice**: Now you can see why the conditional logical operators are
    described as being short-circuiting. They can make your apps more efficient, but
    they can also introduce subtle bugs in cases where you assume that the function
    will always be called. It is safest to avoid them when used in combination with
    functions that cause side effects.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：现在你可以看到为什么条件逻辑运算符被描述为短路。它们可以使你的应用程序更高效，但它们也可能在假设函数总是会调用的情况下引入微妙的错误。当与引起副作用的功能一起使用时，最安全的方法是避免使用它们。'
- en: Exploring bitwise and binary shift operators
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索位运算和二进制移位运算符
- en: Bitwise operators compare the bits in the binary representation of a number.
    Each bit, either the `0` (zero) or `1` (one) value, is compared individually to
    the bit in the same column.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符比较一个数字的二进制表示中的位。每个位，无论是`0`（零）还是`1`（一）的值，都会与同一列中的位单独比较。
- en: Binary shift operators can perform some common arithmetic calculations much
    faster than traditional operators, for example, any multiplication by a factor
    of 2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制移位运算符可以比传统运算符更快地执行一些常见的算术计算，例如，任何乘以2的因子。
- en: 'Let’s explore bitwise and binary shift operators:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索位运算和二进制移位运算符：
- en: 'In `Program.cs`, add statements to declare two integer variables named `x`
    and `y` with values `10` and `6`, and then output the results of applying AND,
    OR, and XOR bitwise operators, as shown in the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加语句以声明两个名为`x`和`y`的整型变量，其值分别为`10`和`6`，然后输出应用AND、OR和XOR位运算符的结果，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that `,7` means right-align in a seven-width column and `:B8` means
    format in binary with eight digits.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`,`7`表示在七宽度列中右对齐，而`:B8`表示以八位二进制格式进行格式化。
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For `x & y`, only the 2-bit column is set. For `x | y`, the 8-, 4-, and 2-bit
    columns are set. For `x ^ y`, the 8- and 4-bit columns are set.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`x & y`，只有2位列被设置。对于`x | y`，8位、4位和2位列被设置。对于`x ^ y`，8位和4位列被设置。
- en: 'In `Program.cs`, add statements to output the results of applying the left-shift
    operator to move the bits of the variable `x` by three columns, multiplying `x`
    by 8, and right-shifting the bits of the variable `y` by one column, as shown
    in the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加语句以输出将变量`x`的位左移三列、将`x`乘以8以及将变量`y`的位右移一列的结果，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `80` result is because the bits in it were shifted three columns to the
    left, so the 1 bits moved into the 64- and 16-bit columns, and 64 + 16 = 80\.
    This is the equivalent of multiplying by 8, but CPUs can perform a bit-shift faster.
    The `3` result is because the 1 bits in `y` were shifted one column into the 2-
    and 1-bit columns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`80`的结果是因为其中的位向左移动了三列，所以1位移动到了64位和16位列，64 + 16 = 80。这相当于乘以8，但CPU可以更快地执行位移操作。`3`的结果是因为`y`中的1位向右移动了一列进入了2位和1位列。'
- en: '**Good Practice**: Remember that when operating on integer values, the `&`
    and `|` symbols are bitwise operators, and when operating on Boolean values like
    `true` and `false`, the `&` and `|` symbols are logical operators.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：记住，在操作整型值时，`&`和`|`符号是位运算符，而在操作类似`true`和`false`的布尔值时，`&`和`|`符号是逻辑运算符。'
- en: Miscellaneous operators
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项运算符
- en: '`nameof` and `sizeof` are convenient operators when working with types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`和`sizeof`是处理类型时方便的运算符：'
- en: '`nameof` returns the short name (without the namespace) of a variable, type,
    or member as a `string` value, which is useful when outputting exception messages.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameof`返回变量、类型或成员的短名称（不带命名空间）作为`string`值，这在输出异常消息时很有用。'
- en: '`sizeof` returns the size in bytes of simple types, which is useful for determining
    the efficiency of data storage. Technically, the `sizeof` operator requires an
    unsafe code block, but the sizes of value types with a C# alias, like `int` and
    `double`, are hardcoded as constants by the compiler so they do not need an unsafe
    block.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof` 返回简单类型的大小（以字节为单位），这对于确定数据存储的效率很有用。技术上，`sizeof` 运算符需要一个不安全代码块，但具有 C#
    别名的值类型的大小，如 `int` 和 `double`，由编译器硬编码为常量，因此不需要不安全块。'
- en: 'For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are many other operators; for example, the dot between a variable and
    its members is called the **member access operator** and the round brackets at
    the end of a function or method name are called the **invocation operator**, as
    shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他运算符；例如，变量和其成员之间的点称为 **成员访问运算符**，函数或方法名称末尾的圆括号称为 **调用运算符**，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Understanding selection statements
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Every application needs to be able to select from choices and branch along different
    code paths. The two selection statements in C# are `if` and `switch`. You can
    use `if` for all your code, but `switch` can simplify your code in some common
    scenarios, such as when there is a single variable that can have multiple values
    that each require different processing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要能够从选项中进行选择，并沿着不同的代码路径分支。C# 中的两个选择语句是 `if` 和 `switch`。您可以使用 `if` 为所有代码，但
    `switch` 可以在某些常见场景中简化您的代码，例如当有一个变量可以具有多个值，每个值都需要不同的处理时。
- en: Branching with the if statement
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `if` 语句进行分支
- en: The `if` statement determines which branch to follow by evaluating a Boolean
    expression. If the expression is `true`, then the block executes. The `else` block
    is optional, and it executes if the `if` expression is `false`. The `if` statement
    can be nested.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句通过评估布尔表达式来确定要遵循的分支。如果表达式为 `true`，则执行该块。`else` 块是可选的，如果 `if` 表达式为 `false`，则执行该块。`if`
    语句可以嵌套。'
- en: 'The `if` statement can be combined with other `if` statements as `else if`
    branches, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句可以与其他 `if` 语句结合使用，作为 `else if` 分支，如下面的代码所示：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each `if` statement’s Boolean expression is independent of the others and, unlike
    `switch` statements, does not need to reference a single value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `if` 语句的布尔表达式都是独立的，并且与 `switch` 语句不同，不需要引用单个值。
- en: 'Let’s write some code to explore selection statements like `if`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来探索 `if` 等选择语句：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `SelectionStatements` to the `Chapter03` solution.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，将名为 `SelectionStatements` 的新 **Console App** / `console` 项目添加到 `Chapter03`
    解决方案中。
- en: Remember to statically import `System.Console` in your project file. If you
    are using Visual Studio, then configure the startup project to be the current
    selection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在项目文件中静态导入 `System.Console`。如果您正在使用 Visual Studio，则将启动项目配置为当前选择。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    check if a password is at least eight characters long, as shown in the following
    code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后添加语句来检查密码是否至少有八个字符长，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Why you should always use braces with if statements
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么您始终应该与 `if` 语句一起使用大括号
- en: 'As there is only a single statement inside each block, the preceding code could
    be written without the curly braces, as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个块内只有一个语句，前面的代码可以不使用大括号编写，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This style of `if` statement should be avoided because it can introduce serious
    bugs. An infamous example is the #gotofail bug in Apple’s iPhone iOS operating
    system. For 18 months after Apple’s iOS 6 was released, in September 2012, it
    had a bug due to an `if` statement without braces in its **Secure Sockets Layer**
    (**SSL**) encryption code. This meant that any user running Safari, the device’s
    web browser, who tried to connect to secure websites, such as their bank, was
    not properly secure because an important check was being accidentally skipped.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '应该避免这种 `if` 语句的样式，因为它可能会引入严重的错误。一个臭名昭著的例子是苹果公司 iPhone iOS 操作系统中的 #gotofail
    错误。在苹果公司 iOS 6 发布后的 18 个月内，即 2012 年 9 月，由于在 **安全套接字层** (**SSL**) 加密代码中缺少大括号的 `if`
    语句，存在一个错误。这意味着任何尝试连接到受保护网站（如他们的银行）的用户，使用 Safari 浏览器（该设备的网络浏览器）时，都没有得到适当的保护，因为一个重要的检查被意外地跳过了。'
- en: Just because you can leave out the curly braces, doesn’t mean you should. Your
    code is not “more efficient” without them; instead, it is harder to read, less
    maintainable, and, potentially, more dangerous.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以省略花括号，但这并不意味着您应该这样做。没有它们，您的代码并不“更高效”；相反，它更难以阅读，维护性更差，并且可能更危险。
- en: Pattern matching with the if statement
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `if` 语句进行模式匹配
- en: 'A feature introduced with C# 7 and later is pattern matching. The `if` statement
    can use the `is` keyword in combination with declaring a local variable to make
    your code safer. It is important to note that a single expression, for example,
    `o is int i`, does two things:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 及以后版本引入的一个特性是模式匹配。`if` 语句可以使用 `is` 关键字结合声明局部变量来使您的代码更安全。重要的是要注意，单个表达式，例如
    `o is int i`，执行了两个操作：
- en: Checks the type of the data in a variable named `o`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为 `o` 的变量中的数据类型。
- en: If the type check is `true`, then it assigns the value to the variable named
    `i`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类型检查为 `true`，则将值赋给名为 `i` 的变量。
- en: '**More Information**: You can learn more about the `is` operator at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is).
    You will use this technique in later chapters, so keep this in mind.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于 `is` 操作符的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is)。您将在后面的章节中使用这项技术，所以请记住这一点。'
- en: 'Let’s see it in action:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: 'Add statements so that if the value stored in the variable named `o` is an
    `int`, then the value is assigned to the local variable named `i`, which can then
    be used inside the `if` statement. This is safer than using the variable named
    `o` because we know for sure that `i` is an `int` variable and not something else,
    as shown in the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句，以便如果名为 `o` 的变量中存储的值是 `int` 类型，则将该值赋给名为 `i` 的局部变量，这样就可以在 `if` 语句内部使用它。这样做比使用名为
    `o` 的变量更安全，因为我们确信 `i` 是一个 `int` 类型的变量，而不是其他类型，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Delete the double-quote characters around the `"3"` value so that the value
    stored in the variable named `o` is an `int` type instead of a `string` type.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除围绕 `"3"` 值的双引号字符，以便名为 `o` 的变量中存储的值是 `int` 类型，而不是 `string` 类型。
- en: 'Rerun the code to view the results, as shown in the following output:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码以查看结果，如下所示：
- en: '[PRE36]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Branching with the switch statement
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `switch` 语句进行分支
- en: 'The `switch` statement is different from the `if` statement because `switch`
    compares a single expression against a list of multiple possible `case` statements.
    Every `case` statement is related to the single expression. Every `case` section
    must end with one of the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句与 `if` 语句不同，因为 `switch` 将单个表达式与多个可能的 `case` 语句列表进行比较。每个 `case` 语句都与单个表达式相关。每个
    `case` 部分必须以以下之一结束：'
- en: The `break` keyword (like `case 1` in the following code).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break` 关键字（如下面代码中的 `case 1`）。'
- en: The `goto` `case` keywords (like `case 2` in the following code).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto` `case` 关键字（如下面代码中的 `case 2`）。'
- en: They should have no statements (like `case 3` in the following code).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该没有语句（如以下代码中的 `case 3`）。
- en: The `goto` keyword that references a named label (like `case 5` in the following
    code).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用命名标签的 `goto` 关键字（如下面代码中的 `case 5`）。
- en: The `return` keyword to leave the current function (not shown in the code).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `return` 关键字离开当前函数（代码中未显示）。
- en: 'Let’s write some code to explore the `switch` statements:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来探索 `switch` 语句：
- en: 'Type the following code for a `switch` statement. You should note that the
    penultimate statement is a label that can be jumped to, and the first statement
    generates a random number between 1 and 6 (the number 7 in the code is an exclusive
    upper bound). The `switch` statement branches are based on the value of this random
    number, as shown in the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `switch` 语句输入以下代码。您应该注意，倒数第二个语句是一个可以跳转到的标签，第一个语句生成一个介于 1 和 6 之间的随机数（代码中的数字
    7 是一个排他性上限）。`switch` 语句的分支基于这个随机数的值，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Good Practice**: You can use the `goto` keyword to jump to another case or
    a label. The `goto` keyword is frowned upon by most programmers but can be a good
    solution to code logic in some scenarios. However, you should use it sparingly,
    if at all. To see how often Microsoft uses `goto` in the .NET base class libraries,
    use the following link: [https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch](https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你可以使用 `goto` 关键字跳转到另一个 case 或标签。大多数程序员都不赞成使用 `goto` 关键字，但在某些场景下它可能是一个好的解决方案。然而，如果你确实需要使用它，应该尽量少用。要查看
    Microsoft 在 .NET 基类库中使用了多少次 `goto`，请使用以下链接：[https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch](https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch)。'
- en: 'Run the code multiple times to see what happens in various cases of random
    numbers, as shown in the following example output:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码多次，以查看在随机数的各种情况下会发生什么，如下面的示例输出所示：
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Good Practice**: The `Random` class that we used to generate a random number
    has a `Next` method that allows you to specify an inclusive lower bound and an
    exclusive upper bound and will generate a pseudo-random number. Instead of creating
    a new instance of `Random` that is not thread-safe, since .NET 6, you can use
    a `Shared` instance that is thread-safe so it can be used concurrently from any
    thread.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们用来生成随机数的 `Random` 类有一个 `Next` 方法，允许你指定一个包含的较低界限和一个排除的较高界限，并将生成一个伪随机数。由于
    .NET 6，你不再需要创建一个非线程安全的 `Random` 实例，你可以使用一个线程安全的 `Shared` 实例，这样它就可以在任何线程中并发使用。'
- en: Now let’s take a small diversion from the `switch` keyword to review how to
    add a new item to a project using Visual Studio because, in the next code task,
    you need to add a new class file to your project and I haven’t shown you how to
    do that yet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时从 `switch` 关键字转向，回顾一下如何在 Visual Studio 中添加新项，因为在下一个代码任务中，你需要将一个新类文件添加到你的项目中，而我还没有向你展示如何做。
- en: Adding a new item to a project using Visual Studio
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 向项目添加新项
- en: 'Visual Studio version 17.6 or later has an optional simplified dialog box for
    adding a new item to a project. After navigating to **Project** | **Add New Item…**,
    or right-clicking on a project in **Solution Explorer** and selecting **Add**
    | **New Item…**, you will see the traditional dialog box, as shown in *Figure
    3.1*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 版本 17.6 及更高版本提供了一个用于向项目添加新项的可选简化对话框。在导航到 **项目** | **添加新项…**，或在
    **解决方案资源管理器** 中右键单击项目并选择 **添加** | **新项…** 后，你会看到传统的对话框，如图 *图 3.1* 所示：
- en: '![](img/B22322_03_01.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_03_01.png)'
- en: 'Figure 3.1: Add New Item dialog box in normal view'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：正常视图中的“添加新项”对话框
- en: 'If you click the **Show Compact View** button, then it switches to a simplified
    dialog box, as shown in *Figure 3.2*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **显示紧凑视图** 按钮，那么它将切换到一个简化的对话框，如图 *图 3.2* 所示：
- en: '![](img/B22322_03_02.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_03_02.png)'
- en: 'Figure 3.2: Add New Item dialog box in compact view'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：紧凑视图中的“添加新项”对话框
- en: To revert to the normal dialog box, click the **Show All Templates** button.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到正常对话框，请点击 **显示所有模板** 按钮。
- en: Pattern matching with the switch statement
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 switch 语句进行模式匹配
- en: Like the `if` statement, the `switch` statement supports pattern matching in
    C# 7 and later. The `case` values no longer need to be literal values; they can
    be patterns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 语句一样，`switch` 语句在 C# 7 及更高版本中支持模式匹配。`case` 值不再需要是字面值；它们可以是模式。
- en: In C# 7 and later, your code can more concisely branch, based on the subtype
    of a class, and you can declare and assign a local variable to safely use it.
    Additionally, `case` statements can include a `when` keyword to perform more specific
    pattern matching.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 及更高版本中，你的代码可以根据类的子类型更简洁地进行分支，并且你可以声明和分配一个局部变量来安全地使用它。此外，`case` 语句可以包含一个
    `when` 关键字以执行更具体的模式匹配。
- en: 'Let’s see an example of pattern matching with the `switch` statement using
    a custom class hierarchy of animals with different properties:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个使用自定义动物类层次结构（具有不同属性）的 `switch` 语句模式匹配的例子来看一下：
- en: You will learn more details about defining classes in *Chapter 5*, *Building
    Your Own Types with Object-Oriented Programming*. For now, you should be able
    to get the idea from reading the code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 5 章* 中学习更多关于定义类的细节，*使用面向对象编程构建自己的类型*。现在，你应该能够通过阅读代码来理解这个概念。
- en: 'In the `SelectionStatements` project, add a new class file named `Animals.cs`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SelectionStatements` 项目中，添加一个名为 `Animals.cs` 的新类文件：
- en: In Visual Studio, navigate to **Project** | **Add New Item…** or press *Ctrl*
    + *Shift* + *A*, type the name, and then click **Add**.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，导航到 **项目** | **添加新项…** 或按 *Ctrl* + *Shift* + *A*，输入名称，然后单击
    **添加**。
- en: In VS Code, click the **New File…** button and type the name.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，单击 **新建文件…** 按钮，并输入名称。
- en: In Rider, right-click on the project and select **Add** | **Class/Interface…**.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rider 中，右键单击项目并选择 **添加** | **类/接口…**。
- en: 'In `Animals.cs`, delete any existing statements, and then define three classes,
    a base class, `Animal`, and two inherited classes, `Cat` and `Spider`, as shown
    in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Animals.cs` 文件中，删除任何现有的语句，然后定义三个类，一个基类 `Animal` 和两个继承类 `Cat` 和 `Spider`，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since this section is about pattern matching and not the most common way to
    define a class with fields, it is not important how the data types are declared.
    The `Name` property has been declared nullable and the other two properties are
    not. You could make the `Name` not-nullable and make the other two nullable and
    the pattern-matching example is unaffected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节是关于模式匹配，而不是定义具有字段的类的最常见方式，因此数据类型的声明方式并不重要。`Name` 属性已被声明为可空，而其他两个属性则不是。您可以将
    `Name` 声明为非可空，并将其他两个声明为可空，模式匹配示例不受影响。
- en: 'In `Program.cs`, add statements to declare an array of nullable animals, and
    then show a message based on what type and attributes each animal has, as shown
    in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句来声明一个可空动物数组，然后根据每个动物的类型和属性显示一条消息，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Good Practice:** Always put the `default` at the end of a `switch` statement.
    I wrote the preceding `switch` statement with the `default` in the middle of the
    set of branches deliberately to show that the compiler will accept this, and will
    always move it to the end of the set of branches for you.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践：** 总是在 `switch` 语句的末尾放置 `default`。我故意将前面的 `switch` 语句中的 `default` 放在分支集合的中间，以显示编译器将接受这一点，并且会始终将其移动到分支集合的末尾。'
- en: 'The `case` statement shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码中显示的 `case` 语句：
- en: '`case Cat fourLeggedCat when fourLeggedCat.Legs == 4:`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`case Cat fourLeggedCat when fourLeggedCat.Legs == 4:`'
- en: 'can also be written using the more concise property pattern-matching syntax,
    as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用更简洁的属性模式匹配语法来编写，如下面的代码所示：
- en: '`case Cat { Legs: 4 } fourLeggedCat:`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`case Cat { Legs: 4 } fourLeggedCat:`'
- en: 'Run the code and note that the array named `animals` is declared to contain
    the `Animal?` type, so it could be any subtype of `Animal`, such as `Cat` or `Spider`,
    or a `null` value. In this code, we create four instances of `Animal` of different
    types with different properties, and one `null` one, so the result will be five
    messages that describe each of the animals, as shown in the following output:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意，名为 `animals` 的数组被声明为包含 `Animal?` 类型，因此它可以包含 `Animal` 的任何子类型，例如 `Cat`
    或 `Spider`，或者一个 `null` 值。在此代码中，我们创建了四个不同类型的 `Animal` 实例，具有不同的属性，以及一个 `null` 实例，因此结果将是五条描述每个动物的消息，如下面的输出所示：
- en: '[PRE41]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Simplifying switch statements with switch expressions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `switch` 表达式简化 `switch` 语句
- en: In C# 8 or later, you can simplify `switch` statements using **switch expressions**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 或更高版本中，您可以使用 `switch` 表达式简化 `switch` 语句。
- en: Most `switch` statements are very simple, yet they require a lot of typing.
    `switch` expressions are designed to simplify the code you need to type while
    still expressing the same intent in scenarios where all cases return a value to
    set a single variable. `switch` expressions use a lambda, `=>`, to indicate a
    return value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `switch` 语句都非常简单，但它们需要大量的输入。`switch` 表达式旨在简化您需要输入的代码，同时在所有情况都返回一个值以设置单个变量的场景中，仍然表达相同的意图。`switch`
    表达式使用 lambda 表达式 `=>` 来指示返回值。
- en: 'Let’s implement the previous code that used a `switch` statement using a `switch`
    expression so that you can compare the two styles:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现之前使用 `switch` 语句的代码，使用 `switch` 表达式，以便您可以比较两种风格：
- en: 'In `Program.cs`, at the bottom and inside the `foreach` loop, add statements
    to set the message based on what type and attributes the animal has, using a `switch`
    expression, as shown in the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在 `foreach` 循环底部内部添加语句，根据动物的类型和属性设置消息，使用 `switch` 表达式，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The main differences are the removal of the `case` and `break` keywords. The
    underscore character `_` is used to represent the default return value. It is
    known as a **discard** and you can read more about it at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别是移除了`case`和`break`关键字。下划线字符`_`用于表示默认返回值。它被称为**丢弃**，你可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards)。
- en: 'Run the code, and note that the result is the same as before, as shown in the
    following output:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意结果与之前相同，如下所示：
- en: '[PRE43]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Understanding iteration statements
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Iteration statements repeat a block of statements either while a condition is
    `true` (`while` and `for` statements) or for each item in a collection (`foreach`
    statement). The choice of which statement to use is based on a combination of
    ease of understanding to solve the logic problem and personal preference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句会重复执行一个语句块，要么是在条件为`true`时（`while`和`for`语句），要么是在集合中的每个项目上（`foreach`语句）。选择使用哪个语句取决于解决逻辑问题的理解难度和个人偏好。
- en: Looping with the while statement
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`while`语句进行循环
- en: 'The `while` statement evaluates a Boolean expression and continues to loop
    while it is true. Let’s explore iteration statements:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句评估一个布尔表达式，并在表达式为真时继续循环。让我们来探索迭代语句：'
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `IterationStatements` to the `Chapter03` solution.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，向`Chapter03`解决方案中添加一个名为`IterationStatements`的新**控制台应用程序**/ `console`项目。
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    define a `while` statement that loops while an integer variable has a value less
    than 10, as shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加语句来定义一个`while`语句，该语句在整数变量的值小于10时循环，如下所示：
- en: '[PRE44]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the results, which should be the numbers 0 to 9, as shown
    in the following output:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，结果应该是从0到9的数字，如下所示：
- en: '[PRE45]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Looping with the do statement
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`do`语句进行循环
- en: 'The `do` statement is like `while`, except the Boolean expression is checked
    at the bottom of the block instead of the top, which means that the block always
    executes at least once, as the following shows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`语句类似于`while`，除了布尔表达式是在块的底部而不是顶部进行检查，这意味着块至少执行一次，如下所示：'
- en: 'Type statements to define a `do` loop, as shown in the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以定义`do`循环，如下所示：
- en: '[PRE46]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code, and note that you are prompted to enter your password repeatedly
    until you enter it correctly, as shown in the following output:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意你会被提示重复输入密码，直到输入正确，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As an optional challenge, add statements so that the user can only make three
    attempts before an error message is displayed.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一项可选挑战，添加语句，以便用户只能在显示错误消息之前尝试三次。
- en: At this point, you might want to comment out the code for this section so you
    do not have to keep entering a password every time you run the console app!
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想要注释掉这一部分的代码，这样你就不必每次运行控制台应用程序时都输入密码！
- en: Looping with the for statement
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`语句进行循环
- en: 'The `for` statement is like `while`, except that it is more succinct. It combines:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句类似于`while`，但它更简洁。它结合了：'
- en: An optional **initializer expression**, which executes once at the start of
    the loop.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的**初始化表达式**，它在循环开始时执行一次。
- en: An optional **conditional expression**, which executes on every iteration at
    the start of the loop to check whether the looping should continue. If the expression
    returns `true` or it is missing, the loop will execute again.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的**条件表达式**，它在循环的每次迭代开始时执行，以检查是否应该继续循环。如果表达式返回`true`或它缺失，则循环将再次执行。
- en: An optional **iterator expression**, which executes on every loop at the bottom
    of the statement. This is often used to increment a counter variable.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的**迭代表达式**，它在语句底部的每个循环中执行。这通常用于递增计数器变量。
- en: 'The `for` statement is commonly used with an integer counter. Let’s explore
    some code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句通常与整数计数器一起使用。让我们看看一些代码：'
- en: 'Type a `for` statement to output the numbers 1 to 10, as shown in the following
    code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个`for`语句以输出从1到10的数字，如下所示：
- en: '[PRE48]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the code to view the result, which should be the numbers 1 to 10.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，结果应该是从1到10的数字。
- en: 'Add another `for` statement to output the numbers 0 to 10, incrementing by
    3, as shown in the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个 `for` 语句以输出 0 到 10 的数字，每次增加 3，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Run the code to view the result, which should be the numbers 0, 3, 6, and 9.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，结果应该是数字 0、3、6 和 9。
- en: Optionally, experiment with changing the initializer expression, conditional
    expression, or iterator expression to see their effects. Only change one thing
    at a time so that you can clearly see the effect produced.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，尝试更改初始化器表达式、条件表达式或迭代器表达式以查看它们的效果。一次只更改一个，以便您可以清楚地看到产生的效果。
- en: Looping with the foreach statement
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `foreach` 语句进行循环
- en: The `foreach` statement is a bit different from the previous three iteration
    statements.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 语句与前面的三个迭代语句略有不同。'
- en: It is used to perform a block of statements on each item in a sequence, for
    example, an array or collection. Each item is usually read-only, and if the sequence
    structure is modified during iteration, for example, by adding or removing an
    item, then an exception will be thrown.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于对序列中的每个项目执行一组语句，例如数组或集合。每个项目通常是只读的，如果在迭代过程中修改了序列结构，例如添加或删除一个项目，那么将抛出异常。
- en: 'Try the following example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例：
- en: 'Type statements to create an array of string variables and then output the
    length of each one, as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以创建一个字符串变量的数组，然后输出每个变量的长度，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE51]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Understanding how foreach works internally
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 `foreach` 在内部是如何工作的
- en: A developer who defines a type that represents multiple items, like an array
    or collection, should make sure that a programmer can use the `foreach` statement
    to enumerate through the type’s items.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 定义表示多个项目（如数组或集合）的类型的设计师应确保程序员可以使用 `foreach` 语句遍历类型的项。
- en: 'Technically, the `foreach` statement will work on any type that follows these
    rules:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`foreach` 语句将在遵循以下规则的所有类型上工作：
- en: The type must have a method named `GetEnumerator` that returns an object.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须有一个名为 `GetEnumerator` 的方法，该方法返回一个对象。
- en: The returned object must have a property named `Current` and a method named
    `MoveNext`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的对象必须有一个名为 `Current` 的属性和一个名为 `MoveNext` 的方法。
- en: The `MoveNext` method must change the value of `Current` and return `true` if
    there are more items to enumerate through or return `false` if there are no more
    items.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveNext` 方法必须更改 `Current` 的值，并在还有更多要枚举的项目时返回 `true`，如果没有更多项目则返回 `false`。'
- en: There are interfaces named `IEnumerable` and `IEnumerable<T>` that formally
    define these rules, but technically, the compiler does not require the type to
    implement these interfaces.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有名为 `IEnumerable` 和 `IEnumerable<T>` 的接口正式定义了这些规则，但从技术上讲，编译器不要求类型实现这些接口。
- en: 'The compiler turns the `foreach` statement in the preceding example into something
    like the following pseudocode:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将前面示例中的 `foreach` 语句转换为以下伪代码：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Due to the use of an iterator and its read-only `Current` property, the variable
    declared in a `foreach` statement cannot be used to modify the value of the current
    item.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了迭代器和其只读的 `Current` 属性，因此 `foreach` 语句中声明的变量不能用来修改当前项的值。
- en: Storing multiple values in an array
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中存储多个值
- en: When you need to store multiple values of the same type, you can declare an
    **array**. For example, you may do this when you need to store four names in a
    `string` array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要存储相同类型的多个值时，你可以声明一个**数组**。例如，当你需要在一个 `string` 数组中存储四个名字时，你可能这样做。
- en: Working with single-dimensional arrays
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与一维数组一起工作
- en: The code that you will write next will allocate memory for an array for storing
    four `string` values. It will then store `string` values at index positions 0
    to 3 (arrays usually have a lower bound of zero, so the index of the last item
    is one less than the length of the array).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要编写的代码将为存储四个 `string` 值的数组分配内存。然后它将在索引位置 0 到 3 存储字符串值（数组通常具有零的下限，因此最后一个项目的索引比数组的长度少一）。
- en: 'We could visualize the array like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数组可视化如下：
- en: '| 0 | 1 | 2 | 3 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 2 | 3 |'
- en: '| Kate | Jack | Rebecca | Tom |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 凯特 | 杰克 | 丽贝卡 | 汤姆 |'
- en: 'Table 3.1: Visualization of an array of four string values'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：四个字符串值数组的可视化
- en: '**Good Practice**: Do not assume that all arrays count from zero. The most
    common type of array in .NET is **szArray**, a single-dimensional zero-indexed
    array, and these use the normal `[]` syntax. But .NET also has **mdArray**, a
    multi-dimensional array, and these do not have to have a lower bound of zero.
    These are rarely used, but you should know they exist.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：不要假设所有数组都是从零开始的。在 .NET 中最常见的数组类型是 **szArray**，这是一个单维零索引数组，并且它们使用正常的
    `[]` 语法。但是 .NET 还有一个 **mdArray**，这是一个多维数组，它们不必有零的下限。这些很少使用，但您应该知道它们存在。'
- en: Finally, it will loop through each item in the array using a `for` statement.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将使用 `for` 语句遍历数组中的每个项目。
- en: 'Let’s look at how to use an array:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用数组：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Arrays` to the `Chapter03` solution.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，向 `Chapter03` 解决方案中添加一个名为 `Arrays` 的新 **Console App** / `console`
    项目。
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare and use an array of `string` values, as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句，然后输入语句来声明和使用一个 `string` 类型的数组，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE54]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Arrays are always of a fixed size at the time of memory allocation, so you need
    to decide how many items you want to store before instantiating them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在内存分配时总是固定大小的，因此您需要在实例化之前决定要存储多少项。
- en: 'An alternative to defining the array in three steps as above is to use array
    initializer syntax:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述分三步定义数组的方法不同，可以使用数组初始化语法：
- en: 'Before the `for` loop, add a statement to declare, allocate memory, and instantiate
    the values of a similar array, as shown in the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环之前，添加一个语句来声明、分配内存并实例化一个类似数组的值，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Change the `for` loop to use `names2`, run the console app, and note that the
    results are the same.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `for` 循环改为使用 `names2`，运行控制台应用程序，并注意结果相同。
- en: Working with multi-dimensional arrays
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多维数组
- en: Instead of a single-dimension array for storing a row of string values (or any
    other data type), what if we want to store a grid of values? Or a cube? Or even
    higher dimensions?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要存储一个值的网格，或者一个立方体，甚至更高的维度，而不是存储一行的字符串值（或任何其他数据类型）的单一维度数组，那会怎么样呢？
- en: 'We could visualize a two-dimensional array, aka a grid, of `string` values
    like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将字符串值的二维数组，也就是网格，可视化如下：
- en: '|  | 0 | 1 | 2 | 3 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  | 0 | 1 | 2 | 3 |'
- en: '| 0 | Alpha | Beta | Gamma | Delta |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Alpha | Beta | Gamma | Delta |'
- en: '| 1 | Anne | Ben | Charlie | Doug |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Anne | Ben | Charlie | Doug |'
- en: '| 2 | Aardvark | Bear | Cat | Dog |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Aardvark | Bear | Cat | Dog |'
- en: 'Table 3.2: Visualization of a two-dimensional array'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：二维数组的可视化
- en: 'Let’s look at how to use multi-dimensional arrays:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用多维数组：
- en: 'At the bottom of `Program.cs`, add statements to declare and instantiate a
    two-dimensional array of `string` values, as shown in the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件的底部添加语句来声明和实例化一个 `string` 类型的二维数组，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can discover the lower and upper bounds of this array using helpful methods,
    as shown in the following code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用有用的方法来发现这个数组的上下限，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE58]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then use these values in nested `for` statements to loop through the
    `string` values, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这些值在嵌套的 `for` 语句中循环遍历 `string` 值，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE60]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You must supply a value for every row and every column when it is instantiated,
    or you will get compile errors. If you need to indicate a missing `string` value,
    then use `string.Empty`. Or if you declare the array to be nullable `string` values
    by using `string?[]`, then you can also use `null` for a missing value.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，您必须为每一行和每一列提供一个值，否则您将得到编译错误。如果您需要表示缺失的 `string` 值，则使用 `string.Empty`。或者，如果您通过使用
    `string?[]` 声明数组为可空 `string` 值，那么您也可以使用 `null` 表示缺失的值。
- en: 'If you cannot use the array initialization syntax, perhaps because you are
    loading values from a file or database, then you can separate the declaration
    of the array dimension and the allocation of memory from the assignment of values,
    as shown in the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不能使用数组初始化语法，可能是因为您正在从文件或数据库中加载数值，那么您可以将数组的声明和内存分配与值的赋值分开，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When declaring the size of the dimensions, you specify the length, not the upper
    bound. The expression `new string[3,4]` means the array can have 3 items in its
    first dimension (0) with an upper bound of 2, and the array can have 4 items in
    its second dimension (1) with an upper bound of 3.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明维度的尺寸时，你指定长度，而不是上界。表达式 `new string[3,4]` 表示数组在其第一个维度（0）中可以有 3 个项目，上界为 2，并且数组在其第二个维度（1）中可以有
    4 个项目，上界为 3。
- en: Working with jagged arrays
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用交错数组
- en: If you need a multi-dimensional array but the number of items stored in each
    dimension is different, then you can define an array of arrays, aka a jagged array.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个多维数组，但每个维度中存储的项目数量不同，那么你可以定义一个数组数组，也称为交错数组。
- en: 'We could visualize a jagged array as shown in *Figure 3.3*:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将交错数组可视化如图 *图 3.3* 所示：
- en: '![](img/B22322_03_03.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_03_03.png)'
- en: 'Figure 3.3: Visualization of a jagged array'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：交错数组的可视化
- en: 'Let’s look at how to use a jagged array:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用交错数组：
- en: 'At the bottom of `Program.cs`, add statements to declare and instantiate an
    array of arrays of `string` values, as shown in the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部，添加语句来声明和实例化一个 `string` 值的数组数组，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can discover the lower and upper bounds of the array of arrays, and then
    each array with it, as shown in the following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以找到数组数组的上下界，然后是每个与之相关的数组，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE64]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can then use these values in nested `for` statements to loop through the
    `string` values, as shown in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这些值在嵌套的 `for` 语句中使用，以遍历 `string` 值，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE66]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: List pattern matching with arrays
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组进行列表模式匹配
- en: Earlier in this chapter, you saw how an individual object supports pattern matching
    against its type and properties. Pattern matching also works with arrays and collections.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你看到了单个对象如何支持与其类型和属性的模式匹配。模式匹配也适用于数组和集合。
- en: Introduced with C# 11, list pattern matching works with any type that has a
    public `Length` or `Count` property and has an indexer using an `int` or `System.Index`
    parameter. You will learn about indexers in *Chapter 5*, *Building Your Own Types
    with Object-Oriented Programming*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始引入，列表模式匹配与任何具有公共 `Length` 或 `Count` 属性并且使用 `int` 或 `System.Index`
    参数的索引器的类型一起工作。你将在 *第 5 章*，*使用面向对象编程构建自己的类型* 中了解索引器。
- en: When you define multiple list patterns in the same `switch` expression, you
    must order them so that the more specific one comes first, or the compiler will
    complain because a more general pattern will match the more specific pattern too,
    and make the more specific one unreachable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在同一个 `switch` 表达式中定义多个列表模式时，你必须按顺序排列它们，以便更具体的模式先出现，否则编译器会抱怨，因为更通用的模式也会匹配更具体的模式，从而使更具体的模式不可达。
- en: '*Table 3.3* shows examples of list pattern matching, assuming a list of `int`
    values:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.3* 显示了列表模式匹配的示例，假设有一个 `int` 值的列表：'
- en: '| **Example** | **Description** |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | **描述** |'
- en: '| `[]` | Matches an empty array or collection. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 与空数组或集合匹配。|'
- en: '| `[..]` | Matches an array or collection with any number of items, including
    zero, so `[..]` must come after `[]` if you need to switch on both. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `[..]` | 与包含任何数量（包括零）的项的数组或集合匹配，因此如果需要同时切换，则 `[..]` 必须在 `[]` 之后。|'
- en: '| `[_]` | Matches a list with any single item. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `[_]` | 与包含任何单个项目的列表匹配。|'
- en: '| `[int item1]` or`[var item1]` | Matches a list with any single item and can
    use the value in the return expression by referring to `item1`. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `[int item1]` 或 `[var item1]` | 与包含任何单个项目的列表匹配，并且可以通过引用 `item1` 使用返回表达式中的值。|'
- en: '| `[7, 2]` | Matches exactly a list of two items with those values in that
    order. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `[7, 2]` | 与具有这些值的顺序的恰好两个项目的列表匹配。|'
- en: '| `[_, _]` | Matches a list with any two items. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `[_, _]` | 与包含任何两个项目的列表匹配。|'
- en: '| `[var item1, var item2]` | Matches a list with any two items and can use
    the values in the return expression by referring to `item1` and `item2`. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `[var item1, var item2]` | 与包含任何两个项目的列表匹配，并且可以通过引用 `item1` 和 `item2` 在返回表达式中使用这些值。|'
- en: '| `[_, _, _]` | Matches a list with any three items. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `[_, _, _]` | 与包含任何三个项目的列表匹配。|'
- en: '| `[var item1, ..]` | Matches a list with one or more items. Can refer to the
    value of the first item in its return expression by referring to `item1`. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `[var item1, ..]` | 与包含一个或多个项目的列表匹配。可以通过引用 `item1` 在返回表达式中引用第一个项目的值。|'
- en: '| `[var firstItem, .., var lastItem]` | Matches a list with two or more items.
    Can refer to the value of the first and last item in its return expression by
    referring to `firstItem` and `lastItem`. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `[var firstItem, .., var lastItem]` | 匹配包含两个或更多项目的列表。可以通过引用`firstItem`和`lastItem`来引用其返回表达式中第一个和最后一个项目的值。|'
- en: '| `[.., var lastItem]` | Matches a list with one or more items. Can refer to
    the value of the last item in its return expression by referring to `lastItem`.
    |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `[.., var lastItem]` | 匹配包含一个或多个项目的列表。可以通过引用`lastItem`来引用其返回表达式中最后一个项目的值。|'
- en: 'Table 3.3: Examples of list pattern matching'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3：列表模式匹配的示例
- en: 'Let’s see some examples in code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码示例：
- en: 'At the bottom of `Program.cs`, add statements to define some arrays of `int`
    values, and then pass them to a method that returns descriptive text depending
    on the pattern that matches best, as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，添加语句来定义一些`int`值的数组，然后将它们传递给一个方法，该方法根据最佳匹配模式返回描述性文本，如下所示代码：
- en: '[PRE67]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In C# 6, Microsoft added support for expression-bodied function members. The
    `CheckSwitch` function above uses this syntax. In C#, lambdas are the use of the
    `=>` character to indicate a return value from a function. I will properly introduce
    this in *Chapter 4, Writing, Debugging, and Testing Functions*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 6中，Microsoft添加了对表达式主体函数成员的支持。上面的`CheckSwitch`函数使用了这种语法。在C#中，lambda是使用`=>`字符来表示函数的返回值。我将在*第4章，编写、调试和测试函数*中适当介绍这一点。
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下所示输出：
- en: '[PRE68]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can learn more about list pattern matching at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于列表模式匹配的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns)。
- en: Trailing commas
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾随逗号
- en: The trailing comma after the last item in the `switch` expression is optional
    and the compiler will not complain about it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`表达式的最后一个项目后面的逗号是可选的，编译器不会对此提出异议。
- en: Most languages, including C#, allow the code style of trailing commas. When
    multiple items are separated by commas (for example, when declaring an anonymous
    object, an array, collection initializers, enums, and switch expressions), C#
    allows you to have the trailing comma after the last item. This makes it easy
    to rearrange the order of the items without having to keep adding and removing
    commas.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言，包括C#，都允许使用尾随逗号的代码风格。当多个项目通过逗号分隔（例如，在声明匿名对象、数组、集合初始化器、枚举和`switch`表达式时），C#
    允许你在最后一个项目后面使用尾随逗号。这使得在不添加和删除逗号的情况下重新排列项目顺序变得容易。
- en: 'You can read a discussion about allowing trailing commas for `switch` expressions
    back in 2018 at the following link: [https://github.com/dotnet/csharplang/issues/2098](https://github.com/dotnet/csharplang/issues/2098).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中回顾2018年关于允许`switch`表达式尾随逗号的讨论：[https://github.com/dotnet/csharplang/issues/2098](https://github.com/dotnet/csharplang/issues/2098)。
- en: 'Even JSON serializers have an option to allow this because it is so common
    to use, as discussed at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 即使JSON序列化器也有一个选项允许这样做，因为它如此常见，如以下链接中讨论的：[https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas)。
- en: Understanding inline arrays
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内联数组
- en: Inline arrays were introduced with C# 12; they are an advanced feature used
    by the .NET runtime team to improve performance. You are unlikely to use them
    yourself unless you are a public library author, but you will automatically benefit
    from others’ use of them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 内联数组是在C# 12中引入的；它们是.NET运行时团队用来提高性能的高级功能。除非你是公共库的作者，否则你不太可能自己使用它们，但你将自动从其他人使用它们中受益。
- en: '**More Information**: You can learn more about inline arrays at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于内联数组的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays)。'
- en: Summarizing arrays
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结数组
- en: 'We use slightly different syntax to declare different types of arrays, as shown
    in *Table 3.4*:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用略微不同的语法来声明不同类型的数组，如*表3.4*所示：
- en: '| **Type of array** | **Declaration syntax** |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **数组类型** | **声明语法** |'
- en: '| One dimension | `datatype[]`, for example, `string[]` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 一维 | `datatype[]`, 例如，`string[]` |'
- en: '| Two dimensions | `string[,]` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 二维 | `string[,]` |'
- en: '| Three dimensions | `string[,,]` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 三维 | `string[,,]` |'
- en: '| Ten dimensions | `string[,,,,,,,,,]` |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 十维 | `string[,,,,,,,,,]` |'
- en: '| Array of arrays, aka two-dimensional jagged array | `string[][]` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 数组数组，也称为二维交错数组 | `string[][]` |'
- en: '| Array of arrays of arrays, aka three-dimensional jagged array | `string[][][]`
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 数组数组的数组，也称为三维交错数组 | `string[][][]` |'
- en: 'Table 3.4: Summary of array declaration syntax'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4：数组声明语法总结
- en: Arrays are useful for temporarily storing multiple items, but collections are
    a more flexible option when adding and removing items dynamically. You don’t need
    to worry about collections right now, as we will cover them in *Chapter 8*, *Working
    with Common .NET Types*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 数组用于临时存储多个项目，但在动态添加和删除项目时，集合是一个更灵活的选项。您现在不需要担心集合，因为我们将在第8章“使用常见的.NET类型”中介绍它们。
- en: You can convert any sequence of items into an array using the `ToArray` extension
    method, which we will cover in *Chapter 11*, *Querying and Manipulating Data Using
    LINQ*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ToArray`扩展方法将任何项目序列转换为数组，我们将在第11章“使用LINQ查询和操作数据”中介绍。
- en: '**Good Practice**: If you do not need to dynamically add and remove items,
    then you should use an array instead of a collection like `List<T>` because arrays
    are more efficient in memory use and the items are stored contiguously, which
    can improve performance.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您不需要动态添加和删除项目，那么您应该使用数组而不是像`List<T>`这样的集合，因为数组在内存使用上更高效，并且项目是连续存储的，这可以提高性能。'
- en: Casting and converting between types
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型之间的转换和转换
- en: You will often need to convert values of variables between different types.
    For example, data input is often entered as text in the console, so it is initially
    stored in a variable of the `string` type, but it then needs to be converted into
    a date/time, number, or some other data type, depending on how it should be stored
    and processed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常需要在不同类型之间转换变量值。例如，数据输入通常在控制台以文本形式输入，因此最初存储在`string`类型的变量中，但它随后需要转换为日期/时间、数字或其他数据类型，具体取决于如何存储和处理。
- en: Sometimes you will need to convert between number types, like between an integer
    and a floating point, before performing calculations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要在执行计算之前在数字类型之间进行转换，例如在整数和浮点数之间。
- en: 'Converting is also known as **casting**, and it has two varieties: **implicit**
    and **explicit**. Implicit casting happens automatically, and it is safe, meaning
    that you will not lose any information.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 转换也称为**转换**，它有两种类型：**隐式**和**显式**。隐式转换是自动发生的，并且是安全的，这意味着您不会丢失任何信息。
- en: Explicit casting must be performed manually because it may lose information,
    for example, the precision of a number. By explicitly casting, you are telling
    the C# compiler that you understand and accept the risk.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 显式转换必须手动执行，因为它可能会丢失信息，例如数字的精度。通过显式转换，您正在告诉C#编译器您了解并接受风险。
- en: Casting numbers implicitly and explicitly
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式转换数字
- en: 'Implicitly casting an `int` variable into a `double` variable is safe because
    no information can be lost, as the following shows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将`int`变量隐式转换为`double`变量是安全的，因为不会丢失任何信息，如下所示：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `CastingConverting` to the `Chapter03` solution.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将名为`CastingConverting`的新**控制台应用程序**/ `console`项目添加到`Chapter03`解决方案中。
- en: 'In `Program.cs`, delete the existing statements, then type statements to declare
    and assign an `int` variable and a `double` variable, and then implicitly cast
    the integer’s value when assigning it to the `double` variable, as shown in the
    following code:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后输入语句来声明和分配一个`int`变量和一个`double`变量，然后在将整数值赋给`double`变量时隐式转换整数，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Type statements to declare and assign a `double` variable and an `int` variable,
    and then implicitly cast the `double` value when assigning it to the `int` variable,
    as shown in the following code:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句来声明和分配一个`double`变量和一个`int`变量，然后在将`double`值赋给`int`变量时隐式转换，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the code and note the error message, as shown in the following output:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意错误信息，如下面的输出所示：
- en: '[PRE71]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This error message will also appear in the Visual Studio **Error List**, VS
    Code **PROBLEMS** window, or Rider **Problems** window.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误消息也将出现在 Visual Studio **错误列表**、VS Code **问题**窗口或 Rider **问题**窗口中。
- en: You cannot implicitly cast a `double` variable into an `int` variable because
    it is potentially unsafe and could lose data, like the value after the decimal
    point. You must explicitly cast a `double` variable into an `int` variable using
    a pair of round brackets around the type you want to cast the `double` type into.
    The pair of round brackets is the **cast operator**. Even then, you must be aware
    that the part after the decimal point will be trimmed off without warning because
    you have chosen to perform an explicit cast and therefore understand the consequences.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能隐式地将`double`变量转换为`int`变量，因为这可能是不安全的，并且可能会丢失数据，就像小数点后的值一样。你必须使用一对圆括号明确地将`double`变量转换为你要转换的`int`类型。这对圆括号是**转换运算符**。即使如此，你也必须意识到小数点后的部分将被截断，而不会发出警告，因为你选择了执行显式转换，因此理解了后果。
- en: 'Modify the assignment statement for the `d` variable to explicitly cast the
    variable `c` into an `int`, and add a comment to explain what will happen, as
    shown highlighted in the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`d`变量的赋值语句修改为显式地将变量`c`转换为`int`，并添加注释来解释将会发生什么，如下所示高亮显示的代码：
- en: '[PRE72]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示输出：
- en: '[PRE73]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We must perform a similar operation when converting values between larger integers
    and smaller integers. Again, be aware that you might lose information because
    any value too big will have its bits copied and then be interpreted in ways that
    you might not expect!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在将大整数和小整数之间的值进行转换时，我们必须执行类似的操作。再次提醒，请注意，你可能会丢失信息，因为任何太大的值都会将其位复制过来，然后以你可能无法预料的方式解释！
- en: 'Enter statements to declare and assign a `long` (64-bit) integer variable to
    an `int` (32-bit) integer variable, both using a small value that will work and
    a too-large value that will not, as shown in the following code:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以声明和分配一个`long`（64位）整数变量到一个`int`（32位）整数变量，同时使用一个可以工作的小值和一个太大无法工作的大值，如下所示代码：
- en: '[PRE74]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示输出：
- en: '[PRE75]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Modify the value of `e` to 5 billion, as shown in the following code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`e`的值修改为50亿，如下所示代码：
- en: '[PRE76]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示输出：
- en: '[PRE77]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Five billion cannot fit into a 32-bit integer, so it overflows (wraps around)
    to about 705 million. It is all to do with the binary representation of integer
    numbers. You will see more examples of integer overflow and how to handle it later
    in this chapter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 五十亿无法放入32位整数中，因此它溢出（回绕）到大约705百万。这完全与整数的二进制表示有关。你将在本章后面看到更多关于整数溢出及其处理方法的示例。
- en: How negative numbers are represented in binary
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何表示二进制中的负数
- en: You might have wondered why `f` had the value `-1` in the previous code. Negative,
    aka signed, numbers use the first bit to represent negativity. If the bit is `0`
    (zero), then it is a positive number. If the bit is `1` (one), then it is a negative
    number.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在之前的代码中`f`的值是`-1`。负数，也称为有符号数，使用第一个位来表示负值。如果这个位是`0`（零），那么它是一个正数。如果这个位是`1`（一），那么它是一个负数。
- en: 'Let’s write some code to illustrate this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来演示这一点：
- en: 'Enter statements to output the maximum value for an `int` in decimal and binary
    number formats, then output the values `8` to `-8`, decrementing by one, and finally,
    output the minimum value for an `int`, as shown in the following code:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以输出`int`的最大值，以十进制和二进制数格式，然后输出值`8`到`-8`，每次递减一个，最后输出`int`的最小值，如下所示代码：
- en: '[PRE78]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that `,12` and `,34` mean right-align within those column widths. `:B32`
    means format as binary padded with leading zeros to a width of 32.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`,`12`和`,`34`表示在这些列宽内右对齐。`:B32`表示以二进制格式填充，前导零的宽度为32。
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示输出：
- en: '[PRE79]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that all the positive binary number representations start with `0` and
    all the negative binary number representations start with `1`. The decimal value
    `-1` is represented by all ones in binary. That is why when you have an integer
    too large to fit in a 32-bit integer, it becomes `-1`. But it’s not always the
    case that the result of this type of casting is `-1`. When casting from a wider
    integer data type to a narrower integer data type, the most significant extra
    bits get truncated. For example, if you’re casting from a 32-bit integer to a
    16-bit integer, the 16 **most significant bits (MSBs)** of the 32-bit integer
    will be truncated. The **least significant bits (LSBs)** represent the result
    of the casting. For instance, if you’re casting to a 16-bit integer, the 16 least
    significant bits of the original value will represent the result after casting.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，所有正二进制数表示都以 `0` 开头，所有负二进制数表示都以 `1` 开头。十进制值 `-1` 在二进制中表示为全 `1`。这就是为什么当整数太大而无法放入
    32 位整数时，它变成 `-1`。但这类转换的结果并不总是 `-1`。当从更宽的整数数据类型转换为更窄的整数数据类型时，最高有效位会被截断。例如，如果你从
    32 位整数转换为 16 位整数，32 位整数的 16 个最高有效位（MSBs）将被截断。最低有效位（LSBs）代表转换的结果。例如，如果你转换到 16 位整数，原始值的
    16 个最低有效位将代表转换后的结果。
- en: 'Enter statements to show an example of a `long` integer that, when cast to
    an `int`, gets truncated to a non-minus-one value, as shown in the following code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以展示一个 `long` 整数的例子，当将其转换为 `int` 时，会被截断为一个非负一值，如下面的代码所示：
- en: '[PRE80]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下面的输出所示：
- en: '[PRE81]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**More Information**: If you are interested in learning more about how signed
    numbers can be represented in computer systems, then you can read the following
    article: [https://en.wikipedia.org/wiki/Signed_number_representations](https://en.wikipedia.org/wiki/Signed_number_representations).'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：如果你对在计算机系统中如何表示有符号数字感兴趣，可以阅读以下文章：[https://en.wikipedia.org/wiki/Signed_number_representations](https://en.wikipedia.org/wiki/Signed_number_representations)。'
- en: Converting with the System.Convert type
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 System.Convert 类型进行转换
- en: You can only cast between similar types, for example, between whole numbers
    like `byte`, `int`, and `long`, or between a class and its subclasses. You cannot
    cast a `long` to a `string` or a `byte` to a `DateTime`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能进行类似类型的转换，例如，在整数类型如 `byte`、`int` 和 `long` 之间，或者在一个类及其子类之间。你不能将 `long` 转换为
    `string` 或将 `byte` 转换为 `DateTime`。
- en: An alternative to using the cast operator is to use the `System.Convert` type.
    The `System.Convert` type can convert to and from all the C# number types, as
    well as Booleans, strings, and date and time values.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换运算符的替代方法是使用 `System.Convert` 类型。`System.Convert` 类型可以将所有 C# 数字类型以及布尔值、字符串和日期时间值进行转换。
- en: 'Let’s write some code to see this in action:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来观察这一过程：
- en: 'At the top of `Program.cs`, statically import the `System.Convert` class, as
    shown in the following code:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的顶部，静态导入 `System.Convert` 类，如下面的代码所示：
- en: '[PRE82]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Alternatively, add an entry to `CastingConverting.csproj`, as shown in the
    following markup: `<Using Include="System.Convert" Static="true" />`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将条目添加到 `CastingConverting.csproj` 中，如下面的标记所示：`<Using Include="System.Convert"
    Static="true" />`。
- en: 'At the bottom of `Program.cs`, type statements to declare and assign a value
    to a `double` variable, convert it into an integer, and then write both values
    to the console, as shown in the following code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的底部，输入语句以声明并分配一个 `double` 变量的值，将其转换为整数，然后将这两个值写入控制台，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE84]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: An important difference between casting and converting is that converting rounds
    the `double` value `9.8` up to `10` instead of trimming the part after the decimal
    point. Another is that casting can allow overflows while converting will throw
    an exception.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 转换和转换之间的重要区别在于，转换会将 `double` 值 `9.8` 向上舍入到 `10`，而不是截断小数点后的部分。另一个区别是，转换可以允许溢出，而转换会抛出异常。
- en: Rounding numbers and the default rounding rules
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字四舍五入和默认的四舍五入规则
- en: You have now seen that the cast operator trims the decimal part of a real number
    and that the `System.Convert` method rounds up or down. However, what is the rule
    for rounding?
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到，转换运算符会截断实数的十进制部分，而 `System.Convert` 方法会向上或向下舍入。然而，四舍五入的规则是什么？
- en: In British primary schools for children aged 5 to 11, pupils are taught to round
    *up* if the decimal part is .5 or higher and round *down* if the decimal part
    is less. Of course, these terms only make sense because, at that age, the pupils
    are only dealing with positive numbers. With negative numbers, these terms become
    confusing and should be avoided. This is why the .NET API uses the `enum` values
    `AwayFromZero`, `ToZero`, `ToEven`, `ToPositiveInfinity`, and `ToNegativeInfinity`
    for improved clarity.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国小学（5至11岁儿童就读的学校）中，学生被教导如果小数部分是 .5 或更高，则**向上**四舍五入，如果小数部分小于，则向下四舍五入。当然，这些术语之所以有意义，是因为在那个年龄，学生只处理正数。对于负数，这些术语会变得令人困惑，应该避免使用。这就是为什么
    .NET API 使用 `enum` 值 `AwayFromZero`、`ToZero`、`ToEven`、`ToPositiveInfinity` 和 `ToNegativeInfinity`
    来提高清晰度。
- en: 'Let’s explore if C# follows the same primary school rule:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 C# 是否遵循相同的学校规则：
- en: 'Type statements to declare and assign an array of `double` values, convert
    each of them into an integer, and then write the result to the console, as shown
    in the following code:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句来声明并分配一个 `double` 值数组，将每个值转换为整数，然后将结果写入控制台，如下面的代码所示：
- en: '[PRE85]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE86]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have shown that the rule for rounding in C# is subtly different from the
    primary school rule:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经表明，C# 的四舍五入规则与小学规则微妙地不同：
- en: It always rounds *toward zero* if the decimal part is less than the midpoint
    .5.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分小于中点 .5，它总是会**向零**四舍五入。
- en: It always rounds *away from zero* if the decimal part is more than the midpoint
    .5.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分大于中点 .5，它总是会**远离零**进行四舍五入。
- en: It will round *away from zero* if the decimal part is the midpoint .5 and the
    non-decimal part is *odd*, but it will round *toward zero* if the non-decimal
    part is *even*.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分是中点 .5 且非小数部分是**奇数**，则它会**远离零**四舍五入，但如果非小数部分是**偶数**，则它会**向零**四舍五入。
- en: This rule is known as **Banker’s rounding**, and it is preferred because it
    reduces bias by alternating when it rounds toward or away from zero. Sadly, other
    languages such as JavaScript use the primary school rule.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则被称为**银行家四舍五入法**，因为它通过交替向零或远离零进行四舍五入来减少偏差，因此更受欢迎。遗憾的是，其他语言如 JavaScript 使用的是小学规则。
- en: Taking control of rounding rules
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制四舍五入规则
- en: 'You can take control of the rounding rules by using the `Round` method of the
    `Math` class:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `Math` 类的 `Round` 方法来控制四舍五入规则：
- en: 'Type statements to round each of the `double` values using the “away from zero”
    rounding rule, also known as rounding “up,” and then write the result to the console,
    as shown in the following code:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“远离零”四舍五入规则（也称为向上四舍五入）编写语句来四舍五入每个 `double` 类型的值，然后将结果写入控制台，如下面的代码所示：
- en: '[PRE87]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can use a `foreach` statement to enumerate all the items in a multi-dimensional
    array.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用 `foreach` 语句来枚举多维数组中的所有项。
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的部分输出所示：
- en: '[PRE88]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Good Practice**: For every programming language that you use, check its rounding
    rules. They may not work the way you expect! You can read more about `Math.Round`
    at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.math.round](https://learn.microsoft.com/en-us/dotnet/api/system.math.round).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：对于您使用的每种编程语言，检查其四舍五入规则。它们可能不会按您预期的那样工作！您可以在以下链接中了解更多关于 `Math.Round`
    的信息：[https://learn.microsoft.com/en-us/dotnet/api/system.math.round](https://learn.microsoft.com/en-us/dotnet/api/system.math.round)。'
- en: Converting from any type to a string
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从任何类型转换为字符串
- en: The most common conversion is from any type into a `string` variable for outputting
    as human-readable text, so all types have a method named `ToString` that they
    inherit from the `System.Object` class.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的转换是将任何类型转换为 `string` 变量，以便作为可读文本输出，因此所有类型都有一个名为 `ToString` 的方法，它们从 `System.Object`
    类继承。
- en: The `ToString` method converts the current value of any variable into a textual
    representation. Some types can’t be sensibly represented as text, so they return
    their namespace and type name instead.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString` 方法将任何变量的当前值转换为文本表示形式。某些类型无法合理地表示为文本，因此它们返回它们的命名空间和类型名称。'
- en: 'Let’s convert some types into a `string`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些类型转换为 `string`：
- en: 'Type statements to declare some variables, convert them to their `string` representation,
    and write them to the console, as shown in the following code:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句来声明一些变量，将它们转换为它们的 `string` 表示形式，并将它们写入控制台，如下面的代码所示：
- en: '[PRE89]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE90]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Passing any object to the `WriteLine` method implicitly converts it into a `string`,
    so it is not necessary to explicitly call `ToString`. We are doing so here just
    to emphasize what is happening. Explicitly calling `ToString` does avoid a boxing
    operation, so if you are developing games with Unity, then that can help you avoid
    memory garbage collection issues.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何对象传递给`WriteLine`方法会隐式地将其转换为`string`，因此不需要显式调用`ToString`。我们在这里这样做只是为了强调正在发生的事情。显式调用`ToString`可以避免装箱操作，所以如果你正在使用Unity开发游戏，那么这可以帮助你避免内存垃圾回收问题。
- en: Converting from a binary object to a string
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从二进制对象转换为字符串
- en: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the stored
    binary object.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个像图像或视频这样的二进制对象，你想要存储或传输时，有时你不想发送原始位，因为你不知道这些位可能会被误解，例如，由传输它们的网络协议或读取存储的二进制对象的另一个操作系统。
- en: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding. Base64 is an encoding scheme
    that converts arbitrary bytes into text using a specific set of 64 characters.
    It’s widely used for data transfer and has long been supported through various
    methods.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 做最安全的事情是将二进制对象转换为安全字符的`字符串`。程序员称这种编码为**Base64**编码。Base64是一种编码方案，它使用一组特定的64个字符将任意字节转换为文本。它在数据传输中得到了广泛的应用，并且长期以来通过各种方法得到了支持。
- en: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`,
    that perform this conversion for you. Let’s see them in action:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`类型有一对方法，`ToBase64String`和`FromBase64String`，为你执行这种转换。让我们看看它们在实际中的应用：'
- en: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted into Base64 to the console, as shown in the following code:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类型语句创建一个随机填充字节值的字节数组，将每个字节格式化地写入控制台，然后将相同的字节转换为Base64写入控制台，如下面的代码所示：
- en: '[PRE91]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: By default, an `int` value would output assuming decimal notation, that is,
    Base10\. You can use format codes such as `:X2` to format the value using hexadecimal
    notation.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`int`值会以十进制表示输出，即Base10。你可以使用如`:X2`这样的格式代码来使用十六进制表示格式化值。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE92]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Base64 for URLs
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL中的Base64
- en: Base64 is useful, but some of the characters it uses, like `+` and `/`, are
    problematic for certain uses, such as query strings in URLs, where these characters
    have special meanings.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Base64很有用，但它使用的某些字符，如`+`和`/`，对于某些用途来说是有问题的，例如URL中的查询字符串，在这些字符中具有特殊含义。
- en: To address this issue, the Base64Url scheme was created. It is similar to Base64
    but uses a slightly different set of characters, making it suitable for contexts
    like URLs.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，创建了Base64Url方案。它与Base64类似，但使用了一组略微不同的字符，使其适合像URL这样的上下文。
- en: '**More Information**: You can learn more about the Base64Url scheme at the
    following link: [https://base64.guru/standards/base64url](https://base64.guru/standards/base64url).'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于Base64Url方案的信息：[https://base64.guru/standards/base64url](https://base64.guru/standards/base64url)。'
- en: '.NET 9 introduces the new `Base64Url` class, which offers a range of optimized
    methods for encoding and decoding data using the `Base64Url` scheme. For example,
    you can convert some arbitrary bytes into Base64Url, as shown in the following
    code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9引入了新的`Base64Url`类，它提供了一系列针对使用`Base64Url`方案进行编码和解码数据的优化方法。例如，你可以将一些任意的字节转换为Base64Url，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Parsing from strings to numbers or dates and times
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字符串解析到数字或日期和时间
- en: The second most common conversion is from strings to numbers or date and time
    values.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种最常见的转换是从字符串到数字或日期和时间值。
- en: The opposite of `ToString` is `Parse`. Only a few types have a `Parse` method,
    including all the number types and `DateTime`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`的反向操作是`Parse`。只有少数类型有`Parse`方法，包括所有数字类型和`DateTime`。'
- en: 'Let’s see `Parse` in action:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Parse`的实际应用：
- en: 'At the top of `Program.cs`, import the namespace for working with cultures,
    as shown in the following code:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，导入用于处理文化的命名空间，如下面的代码所示：
- en: '[PRE94]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'At the bottom of `Program.cs`, add statements to parse an integer and a date
    and time value from strings, and then write the result to the console, as shown
    in the following code:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部添加语句，从字符串中解析整数和日期时间值，然后将结果写入控制台，如下面的代码所示：
- en: '[PRE95]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE96]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日期和时间值以短日期时间格式输出。你可以使用如`D`之类的格式代码，仅使用长日期格式输出日期部分。
- en: '**Good Practice**: Use the standard date and time format specifiers, as shown
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用标准的日期和时间格式说明符，如下面的链接所示：[https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)。'
- en: Avoiding Parse exceptions by using the TryParse method
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用`TryParse`方法避免解析异常
- en: 'One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse`方法的一个问题是，如果`string`无法转换，它会报错：'
- en: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个尝试将包含字母的字符串解析为整型变量的语句，如下面的代码所示：
- en: '[PRE97]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE98]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As well as the preceding exception message, you will see a stack trace. I have
    not included stack traces in this book because they take up too much space.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的异常信息，你还会看到一个堆栈跟踪。我没有在这本书中包含堆栈跟踪，因为它们会占用太多空间。
- en: To avoid errors, you can use the `TryParse` method instead. `TryParse` attempts
    to convert the input `string` and returns `true` if it can convert it and `false`
    if it cannot. Exceptions are a relatively expensive operation so they should be
    avoided when possible.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，你可以使用`TryParse`方法。`TryParse`尝试将输入的`string`转换为其他类型，如果可以转换则返回`true`，如果不能转换则返回`false`。异常操作相对昂贵，因此应尽可能避免。
- en: The `out` keyword is required to allow the `TryParse` method to set the `count`
    variable when the conversion works.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字是必需的，以便在转换成功时允许`TryParse`方法设置`count`变量。'
- en: 'Let’s see `TryParse` in action:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`TryParse`的实际应用：
- en: 'Replace the `int` `count` declaration with statements to use the `TryParse`
    method and ask the user to input a count for the number of eggs, as shown in the
    following code:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`int` `count`声明替换为使用`TryParse`方法的语句，并提示用户输入鸡蛋数量的计数，如下面的代码所示：
- en: '[PRE99]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Run the code, enter `12`, and view the result, as shown in the following output:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`12`，查看结果，如下面的输出所示：
- en: '[PRE100]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Run the code, enter `twelve`, and view the result, as shown in the following
    output:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`twelve`，查看结果，如下面的输出所示：
- en: '[PRE101]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You can also use methods of the `System.Convert` type to convert `string` values
    into other types; however, like the `Parse` method, it gives an error if it cannot
    convert.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`System.Convert`类型的方法将`string`值转换为其他类型；然而，与`Parse`方法一样，如果无法转换，它也会报错。
- en: Understanding the Try method naming convention
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`Try`方法命名约定
- en: '.NET uses a standard signature for all methods that follow the `Try` naming
    convention. For any method named `Something` that returns a value of a specific
    type, its matching `TrySomething` method must return a `bool` to indicate success
    or failure and use an `out` parameter in place of the return value. For example:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: .NET为遵循`Try`命名约定的所有方法使用标准签名。对于任何名为`Something`且返回特定类型值的方法，其对应的`TrySomething`方法必须返回`bool`以指示成功或失败，并使用`out`参数代替返回值。例如：
- en: '[PRE102]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Handling exceptions
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: You’ve seen several scenarios where errors have occurred when converting types.
    Some languages return error codes when something goes wrong. .NET uses exceptions
    that are richer and designed only for failure reporting. When this happens, we
    say *a runtime exception has been thrown*.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在类型转换过程中发生错误的一些场景。一些语言在出错时会返回错误代码。.NET使用更丰富且仅用于错误报告的异常。当这种情况发生时，我们说*抛出了一个运行时异常*。
- en: Other systems might use return values that could have multiple uses. For example,
    if the return value is a positive number, it might represent the count of rows
    in a table, or if the return value is a negative number, it might represent some
    error code.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 其他系统可能会使用具有多种用途的返回值。例如，如果返回值是正数，它可能代表表中的行数；如果返回值是负数，它可能代表某些错误代码。
- en: Some third-party libraries make it easier to define “result” types that can
    indicate errors as well as successes. Many .NET developers prefer to use them
    instead of throwing exceptions. You can learn more about this in an optional online
    section at the end of this chapter.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方库使得定义可以指示错误以及成功的“结果”类型变得更加容易。许多.NET开发者更喜欢使用它们而不是抛出异常。你可以在本章末尾的选读在线部分了解更多关于此内容。
- en: When an exception is thrown, the thread is suspended, and if the calling code
    has defined a `try-catch` statement, then it is given a chance to handle the exception.
    If the current method does not handle it, then its calling method is given a chance,
    and so on up the call stack.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，线程将被挂起，如果调用代码已定义`try-catch`语句，则它将有机会处理该异常。如果当前方法没有处理它，则其调用方法将有机会，依此类推，沿着调用堆栈向上。
- en: As you have seen, the default behavior of a console app is to output a message
    about the exception, including a stack trace, and then stop running the code.
    The application is terminated. This is better than allowing the code to continue
    executing in a potentially corrupt state. Your code should only catch and handle
    exceptions that it understands and can properly fix.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，控制台应用程序的默认行为是输出有关异常的消息，包括堆栈跟踪，然后停止运行代码。应用程序被终止。这比允许代码在可能损坏的状态下继续执行要好。你的代码应该只捕获并处理它理解并能正确修复的异常。
- en: '**Good Practice**: Avoid writing code that will throw an exception whenever
    possible, perhaps by performing `if` statement checks. Sometimes you can’t, and
    sometimes it is best to allow the exception to be caught by a higher-level component
    that is calling your code. You will learn how to do this in *Chapter 4*, *Writing,
    Debugging, and Testing Functions*.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：尽可能避免编写会抛出异常的代码，可能通过执行`if`语句检查来实现。有时你无法这样做，有时最好让调用你的代码的高级组件捕获异常。你将在*第4章*，*编写、调试和测试函数*中学习如何做到这一点。'
- en: In .NET 9, exception handling uses a new implementation based on the NativeAOT
    exception handling model. This improves exception handling performance by 2 to
    4 times in the .NET team’s benchmarks.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 9中，异常处理使用基于NativeAOT异常处理模型的新实现。这通过.NET团队的基准测试将异常处理性能提高了2到4倍。
- en: Wrapping error-prone code in a try block
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`try`块中包裹容易出错的代码
- en: When you know that a statement can cause an error, you should wrap that statement
    in a `try` block. For example, parsing from text to a number can cause an error.
    Any statements in the `catch` block will be executed only if an exception is thrown
    by a statement in the `try` block.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道一个语句可能会引发错误时，你应该将该语句包裹在`try`块中。例如，从文本解析到数字可能会引发错误。只有当`try`块中的语句抛出异常时，`catch`块中的任何语句才会执行。
- en: 'We don’t have to do anything inside the `catch` block. Let’s see this in action:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在`catch`块内部做任何事情。让我们看看它是如何实际工作的：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HandlingExceptions` to the `Chapter03` solution.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，将一个新的**控制台应用程序**/`console`项目命名为`HandlingExceptions`添加到`Chapter03`解决方案中。
- en: 'In `Program.cs`, delete any existing statements, and then type statements to
    prompt the user to enter their age and then write their age to the console, as
    shown in the following code:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除任何现有语句，然后输入提示用户输入他们的年龄并将他们的年龄写入控制台的语句，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You will see the following compiler message: `Warning CS8604 Possible null
    reference argument for parameter ''s'' in ''int int.Parse(string s)''`.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下编译器消息：`警告 CS8604 在 'int int.Parse(string s)' 中参数 's' 的可能为 null 的引用参数`。
- en: 'By default, in .NET 6 or later projects, Microsoft enables nullable reference
    types, so you will see many more compiler warnings like this. In production code,
    you should add code to check for `null` and handle that possibility appropriately,
    as shown in the following code:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在.NET 6或更高版本的项目中，Microsoft启用了可空引用类型，因此你会看到更多这样的编译器警告。在生产代码中，你应该添加代码来检查`null`并适当地处理这种情况，如下面的代码所示：
- en: '[PRE104]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In this book, I will not give instructions to add these `null` checks every
    time because the code samples are not designed to be production-quality, and having
    `null` checks everywhere will clutter the code and use up valuable pages.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我不会每次都给出添加这些`null`检查的指令，因为代码示例不是设计成生产质量的，到处都有`null`检查会使得代码杂乱无章，并占用宝贵的页面。
- en: You will probably see hundreds more examples of potentially `null` variables
    throughout the code samples in this book. Those warnings are safe to ignore for
    the book code examples. You only need to pay attention to similar warnings when
    you write your own production code. You will see more about null handling in *Chapter
    6*,*Implementing Interfaces and Inheriting Classes*.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这本书的代码示例中看到数百个可能为`null`的变量的例子。对于书中的代码示例，这些警告可以安全忽略。你只需要在你自己的生产代码中注意类似的警告。你将在*第6章*，*实现接口和继承类*中了解更多关于`null`处理的内容。
- en: 'In this case, it is impossible for `input` to be `null` because the user must
    press *Enter* for `ReadLine` to return, and if they have not typed any characters
    at that point, then the `ReadLine` method will return an empty `string`. Let’s
    tell the compiler that it does not need to show us this warning:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`input`不可能为`null`，因为用户必须按*Enter*键，`ReadLine`才会返回，如果他们当时没有输入任何字符，则`ReadLine`方法将返回一个空字符串。让我们告诉编译器它不需要显示这个警告：
- en: 'To disable the compiler warning, change `input` to `input!`, as shown highlighted
    in the following code:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用编译器警告，将`input`改为`input!`，如下所示高亮代码：
- en: '[PRE105]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: An exclamation mark, `!`, after an expression is called the **null-forgiving
    operator** and it disables the compiler warning. The **null-forgiving operator**
    has no effect at runtime. If the expression could evaluate to `null` at runtime,
    perhaps because we assigned it in another way, then an exception would be thrown.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式后的感叹号`!`称为**null- forgiving operator**，它禁用编译器警告。**null- forgiving operator**在运行时没有效果。如果表达式在运行时可能评估为`null`，可能是因为我们以另一种方式分配了它，那么将抛出异常。
- en: This code includes two messages to indicate *before* parsing and *after* parsing
    to make the flow through the code clearer. These will be especially useful as
    the example code grows more complex.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码包含两个消息，用于指示在解析之前和解析之后，以使代码的流程更清晰。当示例代码变得更加复杂时，这些将特别有用。
- en: 'Run the code, enter `49`, and view the result, as shown in the following output:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`49`，查看以下输出结果：
- en: '[PRE106]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Run the code, enter `Kermit`, and view the result, as shown in the following
    output:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`Kermit`，查看以下输出结果：
- en: '[PRE107]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: When the code was executed, the error exception was caught, the default message
    and stack trace were not output, and the console app continued running. This is
    better than the default behavior, but it might be useful to see the type of error
    that occurred.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，捕获了错误异常，没有输出默认消息和堆栈跟踪，控制台应用程序继续运行。这比默认行为要好，但可能需要查看发生的错误类型。
- en: '**Good Practice**: You should never use an empty `catch` statement like this
    in production code because it “swallows” exceptions and hides potential problems.
    You should at least log the exception if you cannot or do not want to handle it
    properly, or rethrow it so that higher-level code can decide instead. You will
    learn about logging in *Chapter 4*,*Writing, Debugging, and Testing Functions*.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你永远不应该在生产代码中使用这样的空`catch`语句，因为它“吞没”异常并隐藏潜在问题。如果你不能或不想正确处理它，至少记录异常，或者重新抛出它，以便高级代码可以决定。你将在*第4章*，*编写、调试和测试函数*中学习关于日志记录的内容。'
- en: Catching all exceptions
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获所有异常
- en: 'To get information about any type of exception that might occur, you can declare
    a variable of type `System.Exception` to the `catch` block:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关可能发生的任何类型异常的信息，你可以在`catch`块中声明一个类型为`System.Exception`的变量：
- en: 'Add an exception variable declaration to the `catch` block and use it to write
    information about the exception to the console, as shown in the following code:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`块中添加一个异常变量声明，并使用它将异常信息写入控制台，如下所示代码：
- en: '[PRE108]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，再次输入`Kermit`，查看以下输出结果：
- en: '[PRE109]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Catching specific exceptions
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获特定异常
- en: 'Now that we know which specific type of exception occurred, we can improve
    our code by catching just that type of exception and customizing the message that
    we display to the user. You can think of this as a form of testing:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了发生了哪种具体的异常类型，我们可以通过只捕获这种类型的异常并自定义显示给用户的消息来改进我们的代码。您可以将此视为一种测试形式：
- en: 'Leave the existing `catch` block and, above it, add a new `catch` block for
    the format exception type, as shown in the following highlighted code:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留下现有的`catch`块，在其上方添加一个新的`catch`块用于格式异常类型，如下所示的高亮代码：
- en: '[PRE110]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，再次输入`Kermit`，查看结果，如下所示输出：
- en: '[PRE111]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The reason we want to leave the more general `catch` below is that there might
    be other types of exceptions that can occur.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要留下更通用的`catch`块的原因是可能还有其他类型的异常会发生。
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`9876543210`，查看结果，如下所示输出：
- en: '[PRE112]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Let’s add another `catch` block for this type of exception.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这种类型的异常添加另一个`catch`块。
- en: 'Leave the existing `catch` blocks, and add a new `catch` block for the overflow
    exception type, as shown in the following highlighted code:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留下现有的`catch`块，并添加一个新的`catch`块用于溢出异常类型，如下所示的高亮代码：
- en: '[PRE113]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`9876543210`，查看结果，如下所示输出：
- en: '[PRE114]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The order in which you catch exceptions is important. The correct order is related
    to the inheritance hierarchy of the exception types. You will learn about inheritance
    in *Chapter 5*,*Building Your Own Types with Object-Oriented Programming*. However,
    don’t worry too much about this—the compiler will give you build errors if you
    get exceptions in the wrong order anyway.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常的顺序很重要。正确的顺序与异常类型的继承层次结构相关。您将在*第5章*，*使用面向对象编程创建自己的类型*中学习关于继承的内容。然而，不必过于担心这一点——如果您的异常顺序错误，编译器会给出构建错误。
- en: '**Good Practice**: Avoid over-catching exceptions. They should often be allowed
    to propagate up the call stack to be handled at a level where more information
    is known about the circumstances that could change the logic of how they should
    be handled. You will learn about this in *Chapter 4*,*Writing, Debugging, and
    Testing Functions*.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免过度捕获异常。它们通常应该允许向上传播调用堆栈，以便在更了解可能导致它们处理逻辑变化的情境的级别进行处理。您将在*第4章*，*编写、调试和测试函数*中学习这一点。'
- en: Catching with filters
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带过滤器的捕获
- en: 'You can also add filters to a `catch` statement using the `when` keyword, as
    shown in the following code:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`when`关键字向`catch`语句添加过滤器，如下所示代码：
- en: '[PRE115]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '**Good Practice**: The `Contains` method on the `string` type has overloads
    for both a `string` value that is passed using double-quotes and a `char` value
    that is passed using single-quotes. When you want to check for one character,
    like a dollar, it is more efficient to use the `char` overload as in the preceding
    code.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：`string`类型的`Contains`方法对使用双引号传递的`string`值和使用单引号传递的`char`值都有重载。当您想检查一个字符，如美元符号时，使用前面代码中的`char`重载会更有效。'
- en: Checking for overflow
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查溢出
- en: Earlier, we saw that when casting between number types, it was possible to lose
    information, for example, when casting from a `long` variable to an `int` variable.
    If the value stored in a type is too big, it will overflow.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们了解到，在数字类型之间进行转换时可能会丢失信息，例如，将`long`变量转换为`int`变量时。如果存储在类型中的值太大，就会发生溢出。
- en: Throwing overflow exceptions with the checked statement
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`checked`语句抛出溢出异常
- en: The `checked` statement tells .NET to throw an exception when an overflow happens
    instead of allowing it to happen silently, which is done by default for performance
    reasons.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`语句告诉.NET在发生溢出时抛出异常，而不是允许它静默发生，这是默认的做法，出于性能考虑。'
- en: We will set the initial value of an `int` variable to its maximum value minus
    one. Then, we will increment it several times, outputting its value each time.
    Once it gets above its maximum value, it overflows to its minimum value and continues
    incrementing from there.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`int`变量的初始值设置为最大值减一。然后，我们将它增加几次，每次输出其值。一旦它超过最大值，它就会溢出到最小值，并从那里继续增加。
- en: 'Let’s see this in action:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作：
- en: 'In `Program.cs`, type statements to declare and assign an integer to one less
    than its maximum possible value, and then increment it and write its value to
    the console three times, as shown in the following code:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句来声明并分配一个整数，其值小于其可能的最大值，然后递增它并将它的值写入控制台三次，如下面的代码所示：
- en: '[PRE116]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Run the code and view the result that shows the value overflowing silently
    and wrapping around to large negative values, as shown in the following output:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果，它显示了值静默溢出并环绕到大的负值，如图所示：
- en: '[PRE117]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, let’s get the compiler to warn us about the overflow by wrapping the statements
    using a `checked` statement block, as shown highlighted in the following code:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`checked`语句块包裹语句来让编译器警告我们关于溢出，如下面的代码所示：
- en: '[PRE118]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Run the code and view the result that shows the overflow being checked and
    causing an exception to be thrown, as shown in the following output:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果，它显示了溢出被检查并导致抛出异常，如图所示：
- en: '[PRE119]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Just like any other exception, we should wrap these statements in a `try` statement
    block and display a nicer error message for the user, as shown in the following
    code:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像任何其他异常一样，我们应该将这些语句包裹在`try`语句块中，并为用户提供更友好的错误消息，如下面的代码所示：
- en: '[PRE120]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE121]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Disabling compiler overflow checks with the unchecked statement
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`unchecked`语句禁用编译器溢出检查
- en: The previous section was about the default overflow behavior at *runtime* and
    how to use the `checked` statement to change that behavior. This section is about
    *compile-time* overflow behavior and how to use the `unchecked` statement to change
    that behavior.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节是关于运行时默认溢出行为以及如何使用`checked`语句来改变这种行为。本节是关于编译时溢出行为以及如何使用`unchecked`语句来改变这种行为。
- en: 'A related keyword is `unchecked`. This keyword switches off overflow checks
    performed by the compiler within a block of code. Let’s see how to do this:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的关键字是`unchecked`。这个关键字关闭了编译器在代码块内执行的溢出检查。让我们看看如何做到这一点：
- en: 'Type the following statement at the end of the previous statements. The compiler
    will not compile this statement because it knows it will overflow:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一条语句的末尾输入以下语句。编译器将不会编译此语句，因为它知道它将溢出：
- en: '[PRE122]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Hover your mouse pointer over the error, and note that a compile-time check
    is shown as an error message, as shown in *Figure 3.4*:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在错误上，注意编译时检查会显示为错误消息，如图*3.4*所示：
- en: '![](img/B22322_03_04.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_03_04.png)'
- en: 'Figure 3.4: A compile-time check for integer overflow'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：整数溢出的编译时检查
- en: 'To disable compile-time checks, wrap the statement in an `unchecked` block,
    write the value of `y` to the console, decrement it, and repeat, as shown in the
    following code:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用编译时检查，将语句包裹在`unchecked`块中，将`y`的值写入控制台，递减它，并重复，如下面的代码所示：
- en: '[PRE123]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下输出结果：
- en: '[PRE124]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Of course, it would be rare that you would want to explicitly switch off a check
    like this because it allows an overflow to occur. But perhaps you can think of
    a scenario where you might want that behavior.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你很少会想明确地关闭这种检查，因为这会导致溢出发生。但也许你可以想到一个你可能想要这种行为的情况。
- en: Practicing and exploring
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作，并深入探索本章的主题来测试你的知识和理解。
- en: Exercise 3.1 – Online material
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.1 – 网络材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 网络材料可以是我为这本书写的额外内容，也可以是引用微软或第三方创建的内容。
- en: Returning result types versus throwing exceptions
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回结果类型与抛出异常
- en: 'In .NET programming, handling errors often revolves around two primary mechanisms:
    exceptions and result types. Learn more about result types by reading the following
    online section:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET编程中，错误处理通常围绕两个主要机制：异常和结果类型。通过阅读以下在线部分了解更多关于结果类型的信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md)'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md)'
- en: C# 101 notebooks
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 101笔记本
- en: 'Use the links to notebooks and videos at the following link to see interactive
    examples of C# using Polyglot Notebooks:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下链接中的笔记本和视频查看使用 Polyglot Notebooks 的 C# 交互式示例：
- en: '[https://github.com/dotnet/csharp-notebooks#c-101](https://github.com/dotnet/csharp-notebooks#c-101)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/csharp-notebooks#c-101](https://github.com/dotnet/csharp-notebooks#c-101)'
- en: Exercise 3.2 – Practice exercises
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.2 – 实践练习
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 实践练习深入探讨了本章的主题。
- en: Loops and overflow
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环和溢出
- en: What will happen if this code executes?
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此代码执行，会发生什么？
- en: '[PRE125]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Create a console app in `Chapter03` named `Exercise_LoopsAndOverflow` and enter
    the preceding code. Run the console app and view the output. What happens?
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter03` 中创建一个名为 `Exercise_LoopsAndOverflow` 的控制台应用程序并输入前面的代码。运行控制台应用程序并查看输出。会发生什么？
- en: What code could you add (don’t change any of the preceding code) to warn us
    about the problem?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加什么代码（不要更改前面的任何代码）来警告我们问题？
- en: Practice loops and operators
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践循环和运算符
- en: FizzBuzz is a group game for children to teach them about division. Players
    take turns to count incrementally, replacing any number divisible by 3 with the
    word *fizz*, any number divisible by 5 with the word *buzz*, and any number divisible
    by both with *fizzbuzz*.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: FizzBuzz 是一个儿童分组游戏，用于教授他们除法。玩家轮流递增计数，将任何能被 3 整除的数字替换为单词 *fizz*，任何能被 5 整除的数字替换为单词
    *buzz*，同时能被两者整除的替换为 *fizzbuzz*。
- en: 'Create a console app in `Chapter03` named `Exercise_FizzBuzz` that outputs
    a simulated FizzBuzz game that counts up to 100\. The output should look something
    like *Figure 3.5*:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter03` 中创建一个名为 `Exercise_FizzBuzz` 的控制台应用程序，输出一个模拟的 FizzBuzz 游戏，该游戏计数到
    100。输出应类似于 *图 3.5*：
- en: '![A screenshot of a computer  Description automatically generated](img/B22322_03_05.png)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B22322_03_05.png)'
- en: 'Figure 3.5: A simulated FizzBuzz game output'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：模拟的 FizzBuzz 游戏输出
- en: Practice exception handling
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践异常处理
- en: 'Create a console app in `Chapter03` named `Exercise_Exceptions` that asks the
    user for two numbers in the range 0–255 and then divides the first number by the
    second:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter03` 中创建一个名为 `Exercise_Exceptions` 的控制台应用程序，要求用户输入 0-255 范围内的两个数字，然后除以第二个数字：
- en: '[PRE126]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Write exception handlers to catch any thrown errors, as shown in the following
    output:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异常处理程序来捕获任何抛出的错误，如下所示输出：
- en: '[PRE127]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Exercise 3.3 – Test your knowledge
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What happens when you divide an `int` variable by `0`?
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将一个 `int` 变量除以 `0` 时会发生什么？
- en: What happens when you divide a `double` variable by `0`?
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将一个 `double` 变量除以 `0` 时会发生什么？
- en: What happens when you overflow an `int` variable, that is, set it to a value
    beyond its range?
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你溢出一个 `int` 变量时（即将其设置为超出其范围的值）会发生什么？
- en: What is the difference between `x = y++;` and `x = ++y;`?
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x = y++;` 和 `x = ++y;` 之间的区别是什么？'
- en: What is the difference between `break`, `continue`, and `return` when used inside
    a loop statement?
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在循环语句中使用时，`break`、`continue` 和 `return` 之间的区别是什么？
- en: What are the three parts of a `for` statement and which of them are required?
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for` 语句的三个部分是什么，哪部分是必需的？'
- en: What is the difference between the `=` and `==` operators?
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`=` 和 `==` 运算符之间的区别是什么？'
- en: Does the following statement compile?
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句能否编译？
- en: '[PRE128]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: What does the underscore (`_`) represent in a `switch` expression?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下划线 (`_`) 在 `switch` 表达式中代表什么？
- en: What interface must an object “implement” to be enumerated over by using the
    `foreach` statement?
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用 `foreach` 语句枚举对象，该对象必须“实现”什么接口？
- en: Test your knowledge of operators
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你对运算符的知识
- en: 'What are the values of `x` and `y` after the following statements execute?
    Create a console app in `Chapter03` named `Ch03Ex03Operators` to test your assumptions:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下语句后，`x` 和 `y` 的值是什么？在 `Chapter03` 中创建一个名为 `Ch03Ex03Operators` 的控制台应用程序来测试你的假设：
- en: 'Increment and addition operators:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增量和加法运算符：
- en: '[PRE129]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Binary shift operators:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制移位运算符：
- en: '[PRE130]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Bitwise operators:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位运算符：
- en: '[PRE131]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Exercise 3.4 – Explore topics
  id: totrans-627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.4 – 探索主题
- en: 'Use the links on the following page to learn about the topics covered in this
    chapter in more detail:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接详细了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions)'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions)'
- en: Summary
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned how to:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: Use operators to perform simple tasks.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符执行简单任务。
- en: Use branch and loop statements to implement logic.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支和循环语句实现逻辑。
- en: Work with single- and multi-dimensional arrays.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理单维和多维数组。
- en: Convert between types.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同类型之间进行转换。
- en: Catch exceptions and handle integer overflow.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常并处理整数溢出。
- en: You are now ready to learn how to reuse blocks of code by defining functions,
    how to pass values into them and get values back, and how to track down bugs in
    your code and squash them using debugging and testing tools!
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好学习如何通过定义函数来重用代码块，如何将值传递给它们并从中获取值，以及如何使用调试和测试工具追踪代码中的错误并将它们消除！
