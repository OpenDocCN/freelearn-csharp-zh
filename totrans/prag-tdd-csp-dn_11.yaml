- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Continuous Integration with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You wrote unit tests and other types of tests and you are happy about your code
    coverage and quality. So far so good, but who is going to make sure these tests
    are going to run every time the code changes? Is it the developer that is pushing
    new code? What if they forget? What if there are merge problems in source control
    that might break your tests? Who is going to check?
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already figured out the answer. It is the **continuous integration**
    (**CI**) system that you should have in place. CI is the natural companion to
    unit testing, and you can rarely find a modern project today without a CI system
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a CI process with GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to implement an end-to-end CI process
    with GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind the term **CI** is that new code is continuously integrated
    with existing code, which results in a system that can be shipped to production
    at any time (or at least this is the intention).
  prefs: []
  type: TYPE_NORMAL
- en: The route from software development to production is referred to as the **release
    pipeline**, where the code passes through multiple processes to reach production,
    such as compiling the code, deploying the binaries on the dev environment, allowing
    a QA to pull the code to a certain environment, and others. CI is an integral
    part of the release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CI system requires a host so that it can do various operations on the code.
    The host is a combination of a server and an operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – CI server in an OS ](img/Figure_11.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – CI server in an OS
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of on-premise CI servers:'
  prefs: []
  type: TYPE_NORMAL
- en: Cruise Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team City
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team Foundation Server** (**TFS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Octopus Deploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will be able to find a SaaS solution for the previously mentioned system
    as well. However, today, the native cloud solutions are more popular, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Octopus Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concepts of these systems are the same and when you learn one, you can easily
    learn another. Now, let’s see how a CI system works.
  prefs: []
  type: TYPE_NORMAL
- en: CI workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A CI system applies a workflow to your code by executing a series of actions.
    The actions are configurable and may vary between one project and another based
    on the project’s needs. This is a generic workflow for a CI system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – CI workflow ](img/Figure_11.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – CI workflow
  prefs: []
  type: TYPE_NORMAL
- en: When a developer pushes new code into the source control, the CI system is usually
    listening for this event. It takes a copy of the code and tries to compile it
    similarly to what happens when you compile on your machine. Then, it tries to
    discover all the unit tests in your test projects and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: CI systems are highly customizable, so a developer might add execution for multiple
    types of tests and other housekeeping steps.
  prefs: []
  type: TYPE_NORMAL
- en: If any step fails, the CI system will abandon the build and mark it as failed,
    and notify the developer via a pre-configured way, such as an email.
  prefs: []
  type: TYPE_NORMAL
- en: If all the steps pass, then a **continuous deployment** (**CD**) system can
    be plugged into the end of this process. A CD system deploys your built code (binaries)
    into servers based on your specific preferences. Therefore, you always hear the
    terms *CI/CD* used simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to discuss the importance of CI in a software engineering
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of CI systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI systems are usually plugged in from sprint zero of an agile process. They
    exist from day one for good reasons. Obviously, building a CI system pipeline
    takes time and effort, so there should be a justification for the added effort.
    Here, we will see the importance and benefits of a CI system.
  prefs: []
  type: TYPE_NORMAL
- en: Having the code compiling at all times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How many times in a team project have you pulled the latest code from source
    control and discovered that it does not compile? The CI system ensures the code
    compiles at all times and the best practice is not to pull the new code if the
    CI flags a previous push as a failure, because you won’t be able to continue working
    unless you fix the code yourself or wait for your colleague to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you will have to pull the broken build if you are intending to fix
    it, but the CI gives you an earlier indication.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, broken code in source control happens when a developer doesn’t pull
    the latest from source control, and compiles and executes the tests before pushing
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: Having the unit tests passing at all times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers might forget to execute the unit tests on their machine before pushing
    their code, but the CI system won’t forget!
  prefs: []
  type: TYPE_NORMAL
- en: As per the previous discussion in this book, where unit tests should be high-performance,
    the CI should take no time in running all your unit tests to feed back to the
    team that the build is safe and ready for them to pull the new code.
  prefs: []
  type: TYPE_NORMAL
- en: I have specifically mentioned unit tests as they provide fast feedback. You
    might have other types of tests that might take time to execute, and you may decide
    whether you want to execute them with every push or at certain times of the day.
    Other tests are usually slow and take minutes to execute, and you might want to
    run them in parallel but not block the feedback until they finish, which might
    be 10 minutes or an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the code in a ready state for CD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the build has compiled successfully and passed testing, then this is ready
    for manual testing if you have this as part of your software engineering process
    or if you have binaries ready to be deployed to your environments by the CD process.
  prefs: []
  type: TYPE_NORMAL
- en: The CD process takes the output of your CI and deploys it to configured locations
    such as your dev environment, UAT, and production.
  prefs: []
  type: TYPE_NORMAL
- en: CI is not optional anymore in today’s software engineering process, as you can
    see from the benefits. There is no excuse not to implement one. It is cheap, and
    it is easy to implement, as we are going to see next when we utilize GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CI process with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, when I was designing the guidelines for the chapters in this book,
    I was planning to give a sample implementation using Azure DevOps, as it has a
    popular CI system. However, GitHub Actions climbed up fast and quickly became
    the developers’ choice in configuring a CI system, so I changed my mind and I
    am going to use GitHub Actions instead.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions can deal with multiple programming stacks; one of them is .NET
    Core, which is what we are concerned about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you will need to have a GitHub account for using GitHub Actions and
    you will be glad to know that the free tier gives you 2,000 minutes/month of running
    time, which should be enough for a small solo project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to use GitHub Actions as a CI system for the project in [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245), *Building an App with Repositories and
    Document DB* you don’t need to have read the chapter, we just want a solution
    that has a project and unit tests against it so we can demonstrate how Actions
    works and [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245) has that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project in a GitHub repo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along, you will need to have a GitHub account with a GitHub repository
    hosting a .NET project. If you don’t have one, then you can create a free GitHub
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the code of [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    in your repository, so the fastest way to do that is to go on this book’s GitHub
    page and hit **Fork** | **Create a new fork**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Create a new fork ](img/Figure_11.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Create a new fork
  prefs: []
  type: TYPE_NORMAL
- en: 'Or go to the repository URL and add `/fork` to the end, like this: [https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork).
    Then hit **Create fork**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Filling in the form and hitting Create fork ](img/Figure_11.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Filling in the form and hitting Create fork
  prefs: []
  type: TYPE_NORMAL
- en: The fork will copy the content of a repository into a newly created repository
    that you own so you can play with the code without affecting the original repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’ve copied all the code, we are only interested in this earlier chapter
    ([*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)) in the solution, located in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the same code, we can create the GitHub Actions CI for this
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, to write any configuration for GitHub Actions, you will have to be familiar
    with YAML. YAML is a file format alternative to JSON that is geared for readability
    by humans. You will see examples of YAML as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a workflow for the [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    project using the GitHub Actions wizard. From your GitHub repository, select **Actions**
    | **New workflow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Creating a new workflow ](img/Figure_11.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Creating a new workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions comes back with a list of suggestions based on your repository
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Suggestion list for a GitHub Actions workflow template ](img/Figure_11.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Suggestion list for a GitHub Actions workflow template
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code is .NET Core, so the first suggestion is suitable; let’s hit **Configure**.
    We will get this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Creating a workflow ](img/Figure_11.7_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Creating a workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that GitHub has already suggested a file location for your workflow configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'GitHub Actions lives in the `workflows` directory. It also suggested the following
    YAML code for a start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This workflow is called `.NET` and will be triggered when someone pushes code
    into the main branch or raises a `pull` request to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: The CI system uses the latest version of Ubuntu Linux available at GitHub Actions,
    which at the time of writing is Ubuntu 20.04\. The OS will be hosting the build
    while various actions are applied to it. Linux is usually chosen by default because
    it is more efficient to run and cheaper than Windows, and obviously supports .NET
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the execution of the steps starts with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actions/checkout@v3`: This action checks out your repository, so your workflow
    can access it. This is requesting version 3 of this action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`actions/setup-dotnet@v2`: Fetches .NET SDK using version 2 of this library
    and specifies .NET Core 6 as the .NET version. This allows us to use .NET CLI
    after.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dotnet restore`: This is a standard .NET **command-line interface** (**CLI**)
    command to restore the NuGet packages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dotnet build`: Compiles the solution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dotnet test`: Executes all the test projects in the solution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Steps 1* and *2* prepare your workspace on the host OS to be able to execute
    the `.NET CLI` command in the same way you would execute it on your local machine.
    As you’ve already figured out, the whole text uses YAML syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go ahead and push the **Start commit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Start commit ](img/Figure_11.8_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Start commit
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, click on the **Actions** tab to see how GitHub Actions is going
    to execute these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Failed build ](img/Figure_11.9_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Failed build
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve noticed with the red sign, the build has failed. You could click
    on the failed build to know more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Description of build failure ](img/Figure_11.10_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Description of build failure
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see why this failed: it was unable to find the solution file to restore
    the dependencies. This is an expected error as our solution file for [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245) lives in the `/ch10/UqsAppointmentBooking`
    directory and not on `/` (the root), so we need to modify the YAML file to reflect
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the latest from source control, and you will notice that you have a new
    directory called `workflows` (`/.github/workflows`) and inside this directory,
    you will find the file that we have just created: `dotnet.yml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can edit this YAML file using any plain text editor. I use **Visual Studio
    Code** for this. We need to edit this file to instruct Actions where to find the
    solution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I have modified the preceding YAML to include the location of the solution
    file. If you push this file to GitHub, this will trigger a build. You can see
    the results in the **Actions** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Build pass ](img/Figure_11.11_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Build pass
  prefs: []
  type: TYPE_NORMAL
- en: The passing build means that all the steps that we specified in our YAML file
    have passed. You can click the passed build to look at how every step is executed
    and to ensure that your steps passed accurately and not by coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: We have created our CI system on GitHub Actions for our project. Now, every
    time a team member modifies the code, the CI workflow will kick in.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus a bit more on the test part.
  prefs: []
  type: TYPE_NORMAL
- en: CI and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last line in the YAML steps is meant to trigger all available tests in
    the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This targets all the tests in your solution, which might be a combination of
    unit tests, Sintegration tests, integration tests, and system tests. Executing
    all the tests that you have might not be ideal based on what your project does.
    This will delay the feedback of the recent push and block other team members from
    validating that the build is safe to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you might want to restrict your workflow to unit tests only. You can modify
    the run command to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will target all tests with `Tests.Unit` in their namespace. So, you don’t
    execute all tests and you get fast feedback.
  prefs: []
  type: TYPE_NORMAL
- en: For other tests, you can write another YAML file that contains a new workflow
    and schedule it to run at a different event, such as multiple times per day.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens when a test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating failed tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that a colleague forgot to run the unit tests before pushing to source
    control, heaven forbid. We can simulate this by changing the line from [*Chapter
    10*](B18370_10.xhtml#_idTextAnchor245)*’s* `SlotService` from `||` to `&&` and
    pushing the code to source control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Breaking the logic in the code to trigger failed tests ](img/Figure_11.12_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Breaking the logic in the code to trigger failed tests
  prefs: []
  type: TYPE_NORMAL
- en: 'This change will fail the existing unit tests in the solution, and it is usually
    trapped before pushing to source control, but if pushed, the CI system will report
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Failed tests in source control ](img/Figure_11.13_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Failed tests in source control
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screen will show multiple failing points and if you scroll down,
    it will show you more of a description of the failed test, what was expected,
    and what was produced instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Failed tests description ](img/Figure_11.14_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Failed tests description
  prefs: []
  type: TYPE_NORMAL
- en: You can conclude what went wrong by reading the description. Obviously, we know
    what went wrong here because we broke the code on purpose. In other situations,
    we could understand what went wrong from the description of the error on GitHub
    Actions or we should be able to run the unit tests again on our local machine
    and try to figure out the situation.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen an implementation that uses a workflow. Let’s next understand the
    concept behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The module in GitHub Actions is a workflow and a workflow looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Workflows ](img/Figure_11.15_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Workflows
  prefs: []
  type: TYPE_NORMAL
- en: A workflow lives in a YAML file in the `/.github/workflows` directory in your
    repository. Each workflow will run when triggered by an event(s) in your repository,
    or they can be triggered manually or at a defined schedule. In the previous example,
    the events that would trigger the workflow are pushing into the main branch and
    raising pull requests to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this section did a good job of introducing you to GitHub Actions. Of
    course, there are more advanced options such as `matrix` and other features, but
    *Rome wasn’t built in a day*. You can start with the basics and progress into
    an expert quickly to gain fine control within your release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CI system is a must in today’s software engineering process and a continuation
    of the effort that was put into TDD.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced GitHub Actions as a good example of a CI system and
    used the code of [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245) as a realistic
    example. By completing this chapter, I trust you should be able to add CI configuration
    to your arsenal of tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to consider adding tests to a brownfield
    project, as we don’t always have the luxury of starting a greenfield project all
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*YAML files*: [https://yaml.org/](https://yaml.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GitHub Actions workflows*: [https://docs.github.com/en/actions/using-workflows/about-workflows](https://docs.github.com/en/actions/using-workflows/about-workflows%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous Integration* by Martin Fowler: [https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
