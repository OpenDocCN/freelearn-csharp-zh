- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Forms with Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about creating forms and validating them, which
    is an excellent opportunity to build our admin interface, where we can manage
    our blog posts and also take a look at the new enhanced form navigation. We will
    also build multiple reusable components and learn about some of the new functionalities
    in Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be super fun, and we will use a lot of the things we have
    learned up until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring form elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom validation class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an admin interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an abstraction layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have followed the previous chapters or use the `Chapter05` folder
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring form elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many form elements in HTML, and we can use them all in Blazor. In
    the end, what Blazor outputs is HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor does have components that will add to the functionality, so we can and
    should try to use those components instead of HTML elements. The built-in components
    give us great functionality for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor offers the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputBase<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputCheckbox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputDate<TValue>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputNumber<TValue>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputSelect<TValue>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputText`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputTextArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputRadio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputRadioGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationSummary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through them all in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: EditForm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`EditForm` renders as a `form` tag, but it has a lot more functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will not create an action or method like traditional `form` tags;
    Blazor will handle all of that.
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` will create an `EditContext` instance as a cascading value so that
    all the components you put inside of `EditForm` will access the same `EditContext`.
    `EditContext` tracks the metadata regarding the editing process, such as what
    fields have been edited, and keeps track of any validation messages.'
  prefs: []
  type: TYPE_NORMAL
- en: You need to assign either a model (a class you wish to edit) or an `EditContext`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases, assigning a model is the way to go, but for more advanced
    scenarios, you might want to be able to trigger `EditContext.Validate()`, for
    example, to validate all the controls connected to `EditContext`. This is very
    rarely done, but it might be good to know it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` has the following events that you can use to handle form submissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnValidSubmit` gets triggered when the data in the form validates correctly
    (we will come back to validation in just a bit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnInvalidSubmit` gets triggered if the form does not validate correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSubmit` gets triggered when the form is submitted, regardless of whether
    the form validates correctly or not. Use `OnSubmit` if you want to control the
    validation yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a class that holds a person; the class has a name and an age for that
    person and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`EditForm` for this class would look like this (without any other elements
    for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`EditForm` specifies a model (in this case, `personmodel`), and we are listening
    to the `OnValidSubmit` event.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Submit` button is a regular HTML button that is not a specific Blazor component.
  prefs: []
  type: TYPE_NORMAL
- en: InputBase<>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the Blazor input classes derive from the `InputBase` class. It has a bunch
    of things we can use for all of the `input` components; we will go through the
    most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputBase` handles `AdditionalAttributes`, which means that if we add any
    other attributes to the tag, they will automatically get transferred to the output.
    This means that the components derived from this class can leverage any HTML attributes
    since they will be part of the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '`InputBase` has properties for `Value`, which we can bind to, and an event
    callback for when the value changes called `ValueChanged`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also change `DisplayName` so that the automated validation messages will
    reflect the correct name and not the property’s name, which is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Not all controls support the `DisplayName` property. Some properties are only
    used inside the component, and we will return to those in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: InputCheckbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputCheckbox` component will render as `<input type="checkbox">`.
  prefs: []
  type: TYPE_NORMAL
- en: InputDate<TValue>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputDate` component will render as `<input type="date">`. We can use `DateTime,
    DateOnly, TimeOnly,` and `DateTimeOffset` as values for the `InputDate` component.
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to format the date; it will use the web browser’s current setting.
    This behavior is by design and is part of the HTML5 spec.
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber<TValue>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputNumber` component will render as `<input type="number">`. We can use
    `Int32`, `Int64`, `Single`, `Double`, and `Decimal` as values for the `InputNumber`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: InputSelect<TValue>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputSelect` component will render as `<select>`. We will create `InputSelect`
    later in this chapter, so I won’t go into further detail here.
  prefs: []
  type: TYPE_NORMAL
- en: InputText
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputText` component will render as `<input type="text">`.
  prefs: []
  type: TYPE_NORMAL
- en: InputTextArea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputSelect` component will render as `<textarea>`. In this chapter, we
    will build our own version of this control.
  prefs: []
  type: TYPE_NORMAL
- en: InputRadio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputRadio` component will render as `<input type="radio">`. Use this for
    individual options.
  prefs: []
  type: TYPE_NORMAL
- en: InputRadioGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputRadioGroup` component is not an element itself but rather groups other
    `InputRadioInputs`. Use this to group options. We can add multiple `InputRadio`
    components inside of the `InputRadioGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: InputFile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputFile` component will render as `<Input type="file">`. This component
    will make it easier to get the file data. It will supply us with a stream for
    each file’s content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can dive into `InputFile` further by checking out the documentation here:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0).'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there is a Blazor component for almost all the HTML form controls,
    with some added functionality such as validation, which we will see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already touched on validation; there are some built-in functionalities
    in the `input` components and `EditForm` to handle validation.
  prefs: []
  type: TYPE_NORMAL
- en: One way to add validation to our form is to use `DataAnnotations`. Using DataAnnotations,
    we don’t have to write any custom logic to ensure the data in the form is correct;
    instead, we can add attributes to the data model and let `DataAnnotationsValidator`
    take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of `DataAnnotations` instances in .NET already that we can
    use; we can also build our own annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the built-in data annotations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Required`: This makes the field required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`: This will check that the entered value is an email address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinLength`: This will check that the number of characters is not fewer than
    the value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLength`: This will check that the number of characters is not exceeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Range`: This will check that the value is within a specific range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more annotations that can help us validate our data. To test
    this out, let’s add data annotations to our data classes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Data.Models` project, open `Models/BlogPost.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the file, add a `using` statement for System.ComponentModel.DataAnnotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Required` and `MinLength` attributes to the `Title` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Required` attribute will ensure we can’t leave the title empty, and `MinLength`
    will make sure it has at least `5` characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Text` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Required` attribute will ensure the `Text` property cannot be empty, which
    makes sense – why would we create an empty blog post?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Category.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Required` attribute will make sure we can’t leave the name empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Tag.cs`, and at the top of the file, add a `using` statement for
    `System.ComponentModel.DataAnnotations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Required` attribute will make sure we can’t leave the name empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Comment.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` and `Text` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, now our data models have validation built into them. We need to give
    our users feedback on what went wrong with the validation.
  prefs: []
  type: TYPE_NORMAL
- en: We can do that by using the `ValidationMessage` or `ValidationSummary` components.
  prefs: []
  type: TYPE_NORMAL
- en: ValidationMessage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ValidationMessage` component can show us individual error messages for
    a specific property. We want to use this component to show validation errors under
    a form element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a `ValidationMessage` component, we have to specify the `For` property
    with the name of the property we want to show the validation errors for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ValidationSummary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ValidationSummary` component will show all the validation errors as a
    list for the entire `EditContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to supply any model or property to the `ValidationSummary` component
    since it gets access to the `EditContext` using the cascading value.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to show the error close to the problem so the user can see where the
    issue is. However, we also have the option to show the validation errors as a
    list using `ValidationSummary`.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure our input controls match the Bootstrap theme (or whatever theme we
    might use), we can create our **custom validation class**.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By simply using the edit form, input components, and `DataAnnotationValidator`,
    the framework will automatically add classes to the components when it is and
    isn’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these classes are `.valid` and `.invalid`. In .NET 5, we were given
    a way to customize these class names ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: When using Bootstrap, the default class names are `.is-valid` and `.is-invalid`
    , and the list of class names must also include `.form-control` to get the proper
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: The next component we build will help us get the proper Bootstrap styling on
    all our form components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create our own `FieldCssClassProvider` to customize what classes Blazor
    will use:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, inside the `ResuableComponents` folder, add
    a new class called `BootstrapFieldCssClassProvider.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new class and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BootstrapFieldCssClassProvider` needs an `EditContext` instance to work.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code will check whether the form (or `EditContext` to be specific) is valid
    and whether or not it has been modified. Based on that, it returns the correct
    CSS classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It returns the form control for all elements; that way, we don’t have to add
    it to every element in the form. We could validate an untouched form as valid
    or invalid, but we don’t want it to show that the form is OK just because it hasn’t
    been changed yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Without the code we are about to build, we need to get the `EditContext` instance
    from our `EditForm` and then set `FieldCssClassProvider` on `EditContext` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CurrentEditContext.SetFieldCssClassProvider(provider);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will do that more elegantly (in my humble opinion) with the `CustomCssClassProvider`
    we will create next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Earlier in this chapter, I mentioned that `EditForm` exposes its `EditContext`
    as `CascadingValue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That means we will build a component that we can just put inside of our `EditForm`
    and access `EditContext` that way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the root of the project, add a new class
    and name it `CustomCssClassProvider.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file and replace the content with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This generic component takes a `type` value, in this case, the type of `Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: We specified that `type` must inherit from `FieldCssClassProvider` and must
    have a constructor without parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The component inherits from `ComponentBase`, which makes it possible to place
    the component inside a Blazor component.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are writing our component with C# only, but it is not rendering
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `Cascading` parameter that will be populated from `EditForm`. We throw
    an exception if `EditContext` is missing for some reason (for example, if we place
    the component outside of `EditForm`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set `FieldCssClassProvider` on `EditContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the component, we have to add the following code inside of `EditForm`
    (don’t worry, we will create an `EditForm` soon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We provide our `CustomCssClassProvider` component with the right `ProviderType`:
    `BootstrapFieldCssClassProvider`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one way of implementing components to help us encapsulate functionality.
    We could have written the code this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But with the new `CustomCssClassProvider` component, we can write the same
    thing like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we are doing something with `EditContext`, we can always create a component
    like this since it is a `cascading` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a component that will make our form controls look like Bootstrap
    controls and instead of adding specific code to every component, we can now add
    the `CustomCssClassProvider` component. Next, it’s time to put that into practice
    and create a couple of forms by building our admin interface.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are using bindings to bind data to our form controls. We
    briefly discussed bindings in *Chapter 5*, *Creating Advanced Blazor Components*,
    but it’s time to dig deeper into bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to HTML elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With HTML elements, we can use `@bind` to bind variables to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we are binding to a textbox, we would do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`@bind` and `@bind-value` both work and do the same thing. Note the lower `v`
    in value. The input element is an HTML element that will render as a normal HTML
    element with no extra features (except binding). Compare this to `InputText`,
    which will work in a similar way but also give you additional features like validation
    and styles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value in the variable will change when we leave the textbox.
    But we can change that behavior by adding a `@bind:event` attribute like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even take full control over what is happening by using the `@bind:get`
    and `@bind:set` attributes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These are doing the same thing as `@bind`, so we can’t use them together with
    `@bind`. The `@bind:set` attribute has another nice feature. We can run asynchronous
    methods when we set a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a way for us to run a method after the value is set by using
    `@bind:after` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This gives us great flexibility when it comes to binding to HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we can also set the culture using `@bind:culture`. Both date
    and number fields use invariant culture and will use the appropriate browser formatting,
    but if we use a text field, we can change the behavior like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `GBCulture`, in this case, is a `CultureInfo` object. Lastly, we can
    set the format using `@bind:format`. This is only implemented for `DateTime` at
    this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now know how we can bind to HTML elements. Next, we will take a look at binding
    to components.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When binding to components, `Get`, `Set`, and `After` will also work. `Culture`,
    `Event`, and `Format` will work on some components.
  prefs: []
  type: TYPE_NORMAL
- en: 'When binding to a component, we use `@bind-{ParameterName}`, so for the parameter
    `Value`, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the background, `@bind-Value` will affect two other parameters, `ValueExpression`
    and `ValueChanged`. This means you will not be able to set them manually if you
    use `@bind-Value`. When we change the value, `ValueChanged` will get triggered,
    and we can listen to the event and make things happen when it changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `Get` and `Set` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We must always supply both `Get` and `Set` and they cannot be combined with
    `@bind-Value`. These samples use `InputText`, a built-in Blazor component, but
    this concept works with any parameter on any component. The same thing goes for
    `After`. It can be used with any component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have access to some nice binding features, and they work when binding to
    components as well as HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will build an admin interface using bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Building an admin interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it’s time to build a simple admin interface for our blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List blog posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit blog posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look at the preceding list, we might notice that some of the things seem
    similar – perhaps we can build shared components for those. Categories and tags
    are very similar; they have names, and the name is the only thing we should be
    able to edit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a component for that. The component is going to be responsible for
    listing, adding, deleting, and updating the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the object we are working with is either `Category` or `Tag`, we need
    to be able to call different APIs depending on the object, so our component needs
    to be generic:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the root of the project, add a new Razor
    component and call it `ItemList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the newly created file and at the top of the file, add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@typeparam` is to make the component generic, and the variable holding the
    generic type is called `ItemType`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `code` section (if you don’t have one already), and add the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need two parameters: a list where we can add all the items and an `ItemTemplate`
    instance that we can use to change how we want the items to be shown. The `EditorRequired`
    attribute makes sure that we need to set this value when using the component.
    Otherwise, Visual Studio will show hostile error messages until we fix it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we are using `RenderFragment<T>`, which will give us access to
    the item inside the template (things will become clearer as soon as we implement
    it).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need a couple of events; add the following code to the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added two events; the first is when we delete a tag or a category. We will
    send an event to the parent component where we can add the code needed to delete
    the item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second one is when we select an item so that we can edit the item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add the UI; replace the top of the file below the `@typeparam`
    to the code tag with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we look back to *Step 3*, we’ll notice that we used the variable for the
    lists and `RenderFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the new `Virtualize` component to list our items; to be fair, we
    might not have that many categories or tags, but why not use it when we can? We
    set the `Items` property to `"Items"` (which is the name of our list) and the
    `Context` parameter to `"item"`.
  prefs: []
  type: TYPE_NORMAL
- en: We can give it whatever name we want; we’re only going to use it inside of the
    `Virtualize` render template.
  prefs: []
  type: TYPE_NORMAL
- en: We added two buttons that simply invoke the `EventCallback` instance we added
    in *Step 4*. Between those buttons, we added `@ItemTemplate(item)`; we want Blazor
    to render the template, but we also send the current item in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: That means we have access to the item’s value inside our template.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our new component, it’s now time to create a component for listing and
    editing our categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SharedComponents` project, open `_Imports.razor`. Make sure the following
    namespaces are included: `@using SharedComponents` and `@using Microsoft.AspNetCore.Components.Forms`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Pages` folder, select **Add** | **New folder**, and name
    the folder `Admin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Pages/Admin` folder, add a new Razor component and name it `CategoryList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, replace `<h3>CategoryList</h3>` with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We started with the `@page` directive, telling Blazor that if we navigate to
    the `"``admin/categories"` URL, we will get to the `CategoryList.Razor` component.
    This component has some interactivity, so we need to set what interactivity mode
    we wish to use. In this case, we are using `InteractiveServer`. If we want to
    use `InteractiveAuto` or `InteractiveWebAssembly`, we need to put the component
    in the `BlazorWebApp.Client` project. We will add a `using` statement and then
    inject our API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to add a form to edit the categories. Add the following code
    under the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    OK. For validation, we added `DataAnnotationsValidator`, which will validate the
    supplied data against the annotations we added to the `Tag` and `Category` classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added `InputText` and connected it to a `Category` object called `Item` (which
    we will add in just a second).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Below that, we added `ValidationMessage`, which will show any errors for the
    `name` property, and then a **Submit** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add our `ItemList` component; under the code we added in
    the previous step, add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add our component and we bind the `Items` property to a list of items (we
    will create that list in the next step).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We bind the `Select` and `Delete` events to methods and we specify the type
    of the list in the `ItemType` property. Then, we have `ItemTemplate`. Since we
    are using `RenderFragment<T>`, we now have access to a variable called `context`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We convert that variable to a category and print out the name of the category.
    This is the template for each item that will be shown on the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we add the following code to replace the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a list to hold all our categories and a variable that holds one item
    (the item currently being edited). We use `OnInitializedAsync` to load all the
    categories from the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Delete` and `Save` methods call the API’s corresponding method, and the
    `Select` method takes the provided item and puts it into the item variable (ready
    to be edited).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We check whether we already have the item in the list before we add it to the
    list. Run the project and navigate to `/admin/categories`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to add, edit, or delete a category, as shown in *Figure 6.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The Edit category view'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need a component for listing and editing tags as well – it is pretty
    much the same thing, but we need to use `Tag` instead of `Category`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just created a component for listing and editing categories; now, we need
    to create a component to list and edit tags:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client` project, in the `Pages`folder, add a new folder
    called`Admin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Razor component called `TagList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, replace `<h3>TagList</h3>` with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We started with the `@page` directive telling Blazor that if we navigate to
    the `"admin/tags"` URL, we will get to the `TagList.Razor` component. We also
    specify the render mode as `InteractiveServer`. We add a `using` statement and
    then inject our API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to add a form to edit the tags. Add the following code under
    the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    without a problem. For validation, we added `DataAnnotationsValidator`, which
    will validate the supplied data against the annotations we added to the `Tag`
    and `Category` classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added `InputText` and connected it to a `Tag` object called `Item` (which
    we will add in a moment).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Below it, we add a `ValidationMessage` instance that will show any errors for
    the `name` property and then a **Submit** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add our `ItemList` component. Under the code we added in
    the previous step, add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added our component and bound the `Items` property to a list of items (we
    will create that list in the next step). We bind the `Select` and `Delete` events
    to methods and specify the `List` type in the `ItemType` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we have `ItemTemplate`; since we are using `RenderFragment<T>`, we now
    have access to a variable called `context`. We convert that variable to a tag
    and print out the tag’s name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the template for each item shown in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we replace the code section with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a list to hold all our tags and a variable that holds one item (the
    item currently being edited). We use `OnInitializedAsync` to load all the tags
    from the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Delete` and `Save` methods call the API’s corresponding method and the
    `Select` method takes the provided item and puts it into the `Item` variable (ready
    to be edited).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We check whether we already have the item in the list before we add it to the
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the project and navigate to `/admin/tags`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to add, edit, and delete a tag, as shown in *Figure 6.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The Edit tag view'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need ways to list and edit blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing blog posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with listing and editing blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `Pages/Admin` folder, add a new Razor
    component called `BlogPostList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `BlogPostList.razor` file, replace `<h3>BlogPostList</h3>`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a `page` directive, injected our API, and listed the blog posts using
    a `foreach` loop. We also enabled `StreamingRendering`, because this page doesn’t
    have any interactivity, so there is no need to add that. This also means we can’t
    use the `Virtualize` component since it is interactive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also linked the posts to a URL with the `Id` instance of the blog.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code in the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We added the functionality to load posts from the database and a small delay
    so that we can see **Loading…** for just a brief moment. Now, there is only one
    thing left in the section: adding a page where we can edit the blog post.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A very popular way of writing blog posts is using Markdown; our blog engine
    will support that. Since Blazor supports any .NET standard **dynamic link library**
    (**DLL**), we will add an existing library called `Markdig`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the same engine that Microsoft uses for their `docs` site.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can extend `Markdig` with different extensions (as Microsoft has done), but
    let’s keep this simple and only add support for Markdown without all the fancy
    extensions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the `SharedComponents` project, right-click on the **Dependencies** node
    in Solution Explorer and select **Manage NuGet Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Markdig` and click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class in the root of the project called `InputTextAreaOnInput.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file and replace its contents with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is taken from Microsoft’s GitHub repository; it is how they
    implement the `InputTextArea` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In their build system, they can’t handle `.razor` files, so that’s why they
    implement the code this way. I made one change in Microsoft’s code, and that is
    `oninput`, which used to say `OnChange`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For most cases, `OnChange` will be just fine, which means when I leave the textbox,
    the value will be updated (and trigger validations). But in our case, we want
    the preview of the HTML to be updated in real time, which is why we had to implement
    our own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One option could have been not to use the `InputTextArea` component and instead
    use the `TextArea` tag, but we would lose the validation highlighting. This is
    the way to go if we ever need to customize the behavior on an input control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I recommend using `.razor` files over `.cs` files if you make many changes to
    the implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Pages/Admin` folder, add a new Razor component called `BlogPostEdit.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `BlogPostEdit.razor` file, replace `<h3>BlogPostEdit</h3>`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add two different `page` directives because we want to be able to create
    a new blog post as well as supply an ID to edit an already existing one. If we
    do not supply an ID, the `Id` parameter will be null (or the default).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We inject our API and `NavigationManager` as well as adding `using` statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need some variables. Add the following code in the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a parameter for the blog post ID (if we want to edit one), a variable
    to hold the post we are editing, one to hold all the categories, and one to hold
    all the tags. We also added a variable to hold the currently selected category
    and one to hold the Markdown converted to HTML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add the form; add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add an `EditForm`, and when we submit the form (if it is valid), we execute
    the `SavePost` method. We add `DataAnnotationValidator`, which will validate our
    model against the data annotations in the class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We add `CustomCssClassProvider` so that we get the correct Bootstrap class names.
    Then, we add components for the title, publish date, category, tags, and, last
    but not least, the text (the blog post’s content).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we add the text using the component we created in *Step 4* (the component
    that updates for each keystroke).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also hook up the `@onkeyup` event to update the preview for each keystroke.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to add our `SavePost` method. Add the following code in the `code`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to show the preview. Add the following code just below the `EditForm`
    close tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `MarkupString` to make sure Blazor outputs the HTML code without escaping
    the characters. You might remember that from *Chapter 4*, *Understanding Basic
    Blazor Components*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it is time to set up `Markdig`. Add the following code somewhere in the
    `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To configure `Markdig`, we need to create a pipeline. As I mentioned earlier
    in the chapter, this is the engine Microsoft uses for their documentation site.
    It has many extensions available, including source code highlighting and emoticons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also added emoticons to the pipeline to make it a little more fun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must also add code to load the data (`blog` `posts`, `categories`, and `tags`).
    Add the following methods in the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the site, navigate to `/admin/blogposts`, click on a blog post to
    edit it, and test the new Markdown support. *Figure 6.3* shows the **Edit** page
    with Markdown support:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.3: The Edit page with Markdown support'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We still have one more thing to do: we need to ensure that the blog post page
    shows a converted HTML version of the Markdown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `/Pages/Post.razor` and add the following `using` statement at the top
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the following row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding row with this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great job! Now, we have an admin interface up and running so that we can start
    writing blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code we wrote, no textbox has a label; what we can do is add
    a label in all the places we are using a textbox. Some component vendors have
    a label built into their components. I prefer doing that myself. Add an abstraction
    layer on top of any built-in components or third-party components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an abstraction layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This has saved us more times than I can count. Adding an abstraction layer
    does take some time and effort, but I promise you, you will get that time back.
    So, why should we do this? Well, for several reasons: if we are using Bootstrap,
    for example, and we want to upgrade Bootstrap to the latest version, there might
    be classes that have changed. By using components, it’s easy to only change those
    components. It also makes it easier to change component vendors in the future
    if you have your own components encapsulating the third-party components. But
    the real reason is that if we add a layer, we can set the team’s programming style/language.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything we build will have the same default values, the same access to properties,
    and the same UX. We can add functionality, but in most cases, it is more important
    to limit the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A third-party component has a lot of functionality; it should cater to many
    different use cases. But they also mean that your team now has access to many
    different functionalities that can make the UX different for each developer that
    implements the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a couple of shared components to the project.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a textbox with a label and validation message built in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at our `CategoryList` component, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A label using Bootstrap looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see if we can combine these; some features are already built in. Since
    we only add a layer, we don’t have to handle as much functionality. We rather
    need to send the parent component values to the encapsulated component. Let’s
    look at some code to see what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponent` project, in the `ResusableComponents` folder, add a
    new Razor component and call it `BlogInputText.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s take a look at what is going on. First, we add a parameter so that we
    have an ID that we can use for the `label` tag in the next step. We add a string
    that can contain text for our label, id we do have some text, we render the label.
    If it is `null`, we don’t render the label. I prefer not to have a “`ShowLabel`"
    property. If there is a text, it should show the label. We also have the current
    edit context, which we will use to send to the next level of components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our form we have an `EditForm`; the `EditForm` will send the `EditContext`
    to all the child components and will keep track of the state of the form. We want
    to grab that edit context and send that to all the components inside of this component
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the trio of value parameters, `Value`, `ValueChanged`, and `ValueExpression`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the non-code part of the page, add the following (replacing the three tags):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we grab the `CurrentEditContext` and send that to a child component;
    this way, all the children will have the same edit context as the parent `EditForm`.
    If we have any text in the `Label` parameter, we should show the label. Then we
    add the `InputText`, the built-in component. If we would like to do this with
    a third-party library, we would do it in a similar way. Next is where things get
    a bit more complicated; we could have simply said `@bind-Value`, which would notify
    Blazor that a change has happened, but it would notify the `EditContext` that
    the `Value` parameter of our component has been changed, not the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, instead of doing that, we set the `Value` parameter and the `ValueChanged`
    parameter to the parameters that we send to the component. This way, the notification
    of the value changed will directly notify that the model has been changed. The
    `ValueExpression` will make sure that the `EditContext` gets notified of the change
    and will show the corresponding validation message. To be honest, in this example,
    it doesn’t really matter, but if we were using a third-party component with validation
    built in, it might not work (depending on how they build the component). So, using
    this method should always work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we have the `ValidationMessage`, which shows any error in the model, and
    we are using the same `ValueExpression` here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to use this component. Let’s change the `Taglist` first. In the
    `BlazorWebApp.Client` project, in the `Pages/Admin` folder, open `Taglist.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right now, we have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace this code with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, isn’t that kind of elegant?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s do the same with the `CategoryList`. In the `SharedComponent` project,
    in the `Pages/Admin` folder, open `CategoryList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding code with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This kind of change makes me genuinely happy – it simplifies usage, makes the
    UI easier to understand, and removes the need for duplicated code. Even though
    we know how to do this now, I want to add one more example that perhaps showcases
    the really nice benefits of working this way. Let’s create a button component
    as well. This component will be a bit more to take in:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new component and name it `BlogButton.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are adding a normal HTML button, nothing fancy. We add functionality to change
    the type (`button` or `submit`), whether it is disabled or not, what CSS class
    it should have, a method to run, and the title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are doing the same thing as with the `BlogTextbox`, and we bring in
    the `EditContext`, which we will use in just a bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also have a `RenderFragment` for the content of the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we add a couple of `private` fields that we will use in the component,
    then we add a property for whether the button is disabled or not. It will use
    `EditContext` to check whether there are any errors in the form, save those errors
    in a variable, and if the form is OK, enable the button, and if it is not, disable
    the button. There is a downside to this implementation; for the validation to
    trigger, we need to click somewhere else on the page to trigger the change in
    the field. So, now, the button will be disabled if the form is not OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will get a `Title` for the button and it will be shown when hovering
    your mouse over the button. We can also set a `HelpText` or a disabled help text.
    If the function is disabled for any reason, it might not have anything to do with
    the for we will show a text that explains why the button is disabled. It will
    also add any form errors to the button so it is easy to understand what form element
    is the problem without having to scroll to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to use the button, but without a form, simply executing
    a method. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we have a delegate for `OnClick`, we want the button to simply be a button.
    If we don’t have a delegate, we assume the button is used inside of an `EditForm`.
    When the button is clicked, the `OnButtonClick` method will run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we get to the really juicy part. Let’s add an `enum`; we can add it in
    the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are not using vocabulary like primary or danger – that’s Bootstrap
    lingo. What we want to know is what the button is used for. When we add a button,
    what is the most likely scenario in which the button will be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a parameter for `ButtonType` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add a parameter for `ButtonType` and an internal property that translates
    the “Save” use case, for example, to a Bootstrap CSS class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our team doesn’t have to bother remembering which Bootstrap class they should
    use; they know it’s a button, and they know what the button is used for. The component
    takes care of the rest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s test it out!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, in the `Pages/Admin` folder, open `TagList.razor.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding line with the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the project now, you will see that the button is disabled if we haven’t
    made any changes to the form, and will become enabled if we add something to the
    textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s do the same for the `CategoryList`. In the `SharedComponents` project,
    in the folder `Pages/Admin`, open `CategoryList.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding line with the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are more places we can modify and add this button to, but let’s not spend
    time on that for now. If you want, you can return to this and make sure we are
    using the new button and `InputText` everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: We have one more component to build.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 7, we got a new component called `NavigationLock`. Right now, if we
    write a blog post and click somewhere in the menu, our changes will be lost. The
    same thing happens if we change the URL and press *Enter*. With `NavigationLock`,
    we can prevent that from happening.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigationLock` can prevent us from leaving the page and navigating to another
    page in our site. In that case, we can show a custom message using JavaScript.
    If we navigate to another site, it can trigger a warning, but we don’t have control
    over the message shown. This functionality is built into the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement this in the same way we did with `FieldCssClassProvider`,
    as a reusable component. We want to check whether our `EditContext` has any changes
    made so we can trigger the navigation lock:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new Razor component and name it `BlogNavigationLock.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject an `IJSRuntime` to make JavaScript calls. We will return to JavaScript
    interop in *Chapter 10*, *JavaScript Interop*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also implement the `IDisposable` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have a `CascadingParameter`, which gets the current `EditContext`, just as
    we did with `FieldCssClassProvider`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also added a string that is the message shown when we try to navigate from
    the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a change happens in the `EditContext`, we need to update the component
    and make sure it locks the navigation. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start to listen for field changes, and if a field changes, we call the `StateHasChanged`
    method to update the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`InvokeAsync` is needed since the call comes from another thread.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also override the `Dispose` method and remove the event listener.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will make a JavaScript call if there are changes in the `EditContext`
    (or model), showing a confirm dialog and the message we added. If we do not confirm,
    the navigation will be prevented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can add the `NavigationLock` component. Just under the directives,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `NavigationLock` component will prevent external navigation (navigating
    to another site) and internal navigation (navigating to another page in our blog).
    It checks whether the `EditContext` (model) has any changes and prevents external
    navigation. On internal navigation, it will execute the `OnBeforeInternalNavigation`
    method, which checks whether the `EditContext` has been changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we only have one more thing to do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Pages/Admin/BlogPostEdit.razor`, add the new Razor component we created
    just below the `CustomCssClassProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will get the `EditContext` from the cascading value, and execute the code
    we just wrote.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `code` section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `SavePostAsync` method, just before navigating to `admin/blogposts`,
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When saving the object, the `EditContext` doesn’t know that, so we are telling
    the `EditContext` that the model is now unmodified, so the navigation should not
    be stopped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another site (it should work).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another page (it should work).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the blog post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another site (it should show a message box).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another page. You might notice that, in our case, it doesn’t
    show a message box when we navigate to another page. What is up with that? It
    seems to be a limitation in how this component works. If we were running `InteractiveServer`
    or `InteractiveWebAssembly`, it would work. Navigation using static server rendering
    (which is what happens when we navigate) won’t trigger the navigation change.
    If we want to test this, we can change our project to run as Blazor Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, in the `Components` folder, open the `App.razor`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding line with the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can try it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another site (it should work).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another page (it should work).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the blog post.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another site (it should show a message box).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another page (it should show a message box).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change it back to `<Routes />`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The point of this is to show that, in some cases, the built-in components will
    act differently depending on the render mode. I honestly think that this is a
    bug rather than a feature, but there are discussions about this.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We have implemented another reusable component. Next, let’s take a
    look at how we can use a form with a static server-side rendered component using
    enhanced form navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Form Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET 8, we got server-side rendering. Adding interactivity to a component
    is simple, as we have seen. But sometimes we just want a form and a submit button.
    Do we really have to enable WebAssembly or a SignalR connection for this? I’m
    glad you asked! The answer is, no, we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a component to showcase that our blog posts need comments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SharedComponents` project, in the `Pages` folder, add a new Razor component
    called `Comments.razor`. This component should do two things: list comments and
    create a new comment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `comments` file, replace the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a list of comments and some bootstrap classes to make it look better.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continue by adding the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are still using an `EditForm` just as before and an `OnValidSubmit` property.
    There are some things that are new here, though. We are specifying the method
    we are using to post the form – in this case, a post method. We are also naming
    the form with the `FormName` parameter. These two properties must be there. We
    are using the `DataAnnotationValidator` and the `CustomCssClassProvider` we created
    earlier. We are even using the `BlogInputText`. But since this component isn’t
    interactive, our button will not work as it is disabled by default, and if we
    remove the interactivity, it will stay disabled. So, in this case, we have to
    add a button the old-fashioned way. We can make sure that there is a non-interactive
    button for cases like this as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it is time for the code part of the form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using a parameter so that our component knows what blog post to
    show comments for. It has `EditorRequired`, so Visual Studio will warn you if
    it is missing. The `Model` parameter has the `SupplyParameterFromForm` attribute,
    which is required. This is so Blazor knows what property to fill with data when
    the form is posted. The rest of the code is the same as the code we have used
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Post.cs` and add the following code just beneath the line @((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text,
    pipeline)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, what is happening?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we submit our form, the component will be rerendered, creating a new instance
    of the component and filling the (in our case) `Model` parameter with the data
    from the post. With interactive components, `OnInitialized` and `OnInitializedAsync`
    will only run once (unless we are running prerendering). With these static components,
    it will reload the component. But we also get a “problem” because the scrolling
    positions get lost when the page reloads. We will now find ourselves at the top
    of the page, which is not a great user experience. Luckily, there is a solution;
    this is where the `Enhance` part comes in. By adding `Enhance` to our form, it
    will now keep its scroll position after posting the page. Pretty neat, right?
    We can also use a normal form instead of an `EditForm`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It would then look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of `Enhance`, we add `data-enhance`. Personally, I prefer to use an
    `EditForm` where I can, but it might be good to know that there are options.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use `data-permanent` to keep the information in the form fields
    for a search parameter, for example. This way, the enhanced navigation will not
    update that data when the response is returned. How many times have we used a
    search field, misspelled something, and then the search field is empty and we
    need to retype everything? This is where `data-permanent` saves us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Amazing!
  prefs: []
  type: TYPE_NORMAL
- en: This has been a heavy chapter, but wow, we have done so much – a whole bunch
    of new and reusable components and a complete admin interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us how to create forms and make API calls to get and save
    data.
  prefs: []
  type: TYPE_NORMAL
- en: We built custom input controls and got Bootstrap styling on our controls. Most
    business apps use forms; we can add logic close to the data by annotating data.
  prefs: []
  type: TYPE_NORMAL
- en: We also created multiple reusable components and used many of the things we
    discussed in previous chapters. We even touched on JavaScript interop, which we
    will go into more detail about in *Chapter 10*, *JavaScript Interop*.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality that Blazor offers when it comes to validation and input controls
    will help us build amazing applications and give our users a great experience.
    You may notice that, right now, the admin pages are wide open. We need to secure
    our blog with a login, but we will come to that in *Chapter 8*, *Authentication
    and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a web API to get data when we are running
    components such as `InteractiveAuto` or `InteractiveWebAssembly`.
  prefs: []
  type: TYPE_NORMAL
