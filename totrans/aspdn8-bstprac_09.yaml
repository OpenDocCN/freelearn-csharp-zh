- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Better Web APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web APIs are the essence of the internet. They give developers the openness
    of the web and the ability to access any data on the internet. However, there
    are some best practices specific to APIs. The ability to select the right HTTP
    verb, how to document APIs, and testing APIs are just some of the topics we’ll
    cover.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: With that said, the techniques covered in this chapter are vast and dense. We’ll
    try to pack as much information as possible to help build quality APIs. We’ll
    also provide relevant links for further research.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating APIs quickly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Web APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardized Web API techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn how to design, create, test, and document APIs
    and how to perform full end-to-end tests of our APIs through a CI/CD pipeline.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish this chapter by reviewing some of the more common techniques for
    writing APIs, such as using the correct HTTP verbs and status codes, how to avoid
    large dependent resources, how to implement pagination into APIs, versioning an
    API, using DTOs instead of entities, and the best way to call other APIs from
    .NET.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET 8, Web APIs take a front seat. Visual Studio has added new features
    to make Web APIs easier to build and test. For this chapter, we recommend using
    Visual Studio 2022, but the only requirement to view the GitHub repository is
    a simple text editor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The code for *Chapter 09* is located in Packt Publishing’s GitHub repository,
    found at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating APIs quickly
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With .NET 8, APIs are integrated into the framework, making it easier to create,
    test, and document. In this section, we’ll learn a quick and easy way to create
    a minimal API using Visual Studio 2022 and walk through the code it generates.
    We’ll also learn why minimal APIs are the best approach to building REST-based
    services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the features of .NET 8 is the ability to create minimal REST APIs extremely
    fast. One way is to use the dotnet command-line tool and the other way is to use
    Visual Studio. To do so, follow these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio 2022 and create an **ASP.NET Core Web** **API** project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the directory for the project, click **Next**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the project options, make the following changes:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Use Controllers** option to use minimal APIs
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check **Enable OpenAPI support** to include support for API documentation using
    Swagger:'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Options for a web minimal API project](img/B19493_09_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Options for a web minimal API project
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it – we have a simple API! It may not be much of one, but it’s still
    a complete API with Swagger documentation. Swagger is a tool for creating documentation
    for APIs and implementing the OpenAPI specification, whereas Swashbuckle is a
    NuGet package that uses Swagger for implementing Microsoft APIs. If we look at
    the project, there’s a single file called `Program.cs`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening `Program.cs` will show the entire application. This is one of the strong
    points of .NET – the ability to create a scaffolded REST API relatively quickly:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created our “application” through the `.CreateBuilder()`
    method. We also added the `EndpointsAPIExplorer` and `SwaggerGen` services. `EndpointsAPIExplorer`
    enables the developer to view all endpoints in Visual Studio, which we’ll cover
    later. The `SwaggerGen` service, on the other hand, creates the documentation
    for the API when accessed through the browser. The next line creates our application
    instance using the `.``Build()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our app instance and we are in development mode, we can add Swagger
    and the Swagger UI. `.UseHttpsRedirection()` is meant to redirect to HTTPS when
    the protocol of a web page is HTTP to make the API secure.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next line creates our GET `weatherforecast` route using `.MapGet()`. We
    added the `.WithName()` and `.WithOpenApi()` methods to identify the primary method
    to call and let .NET know it uses the OpenAPI standard, respectively. Finally,
    we called `app.Run()`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the application, we will see the documented API on how to use our
    API and what’s available. Running the application produces the following output:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Screenshot of our documented Web API](img/B19493_09_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Screenshot of our documented Web API
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: If we call the `/weatherforecast` API, we see that we receive JSON back with
    a 200 HTTP status.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Results of our /weatherforecast API](img/B19493_09_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Results of our /weatherforecast API
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Think of this small API as middleware with API controllers combined into one
    compact file (`Program.cs`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Why minimal APIs?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I consider minimal APIs to be a feature in .NET 8, even though it’s a language
    concept. If the application is extremely large, adding minimal APIs should be
    an appealing feature in four ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-contained**: Simple API functionality inside one file is easy to follow
    for other developers'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Since we aren’t using controllers, the MVC overhead isn’t
    necessary when using these APIs'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: With .NET, APIs can now be deployed on any platform'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-documenting**: While we can add Swashbuckle to other APIs, it also builds
    the documentation for minimal APIs'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving forward, we’ll take these minimal APIs and start looking at Visual Studio’s
    testing capabilities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created and reviewed a minimal API project in Visual Studio
    and why minimal APIs are important to our projects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at designing APIs to help eliminate long resource
    (URL) names and standardized API naming.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover the best approach for delivering intuitive and
    clear APIs to our users. The design of an API should be well thought-out and make
    sense when a user wishes to make a request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: To create a truly REST-based API, we must use a different mindset. We have to
    think of ourselves as a user and not a developer. When writing APIs, the users
    of the API *are* fellow developers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Disconnecting from existing schemas
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing APIs, we need a user’s perspective as opposed to basing an API
    on a class hierarchy or database schema. While developers may consider creating
    an API based on a class hierarchy or database schema as a shortcut, it could create
    more complexity as to which resource to use when retrieving data. One example
    is using an Order resource to find a contact. While an Order entity in Entity
    Framework Core could contain a `Company` property and we need the contact of the
    company, we wouldn’t write `https://www.myfakesite.com/Order/15/Company/Contact`.
    Basing a URL structure on an existing hierarchy or schema should be avoided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to disregard existing schemas when designing a sensible API. Look
    at the API with new eyes to get the best design. The most popular APIs are the
    cleanest and most intuitive as they use the `collection/item/collection` syntax.
    A good example of this would be `/orders/15/companys`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resources
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a system, look at how the user interacts with the website and extract the
    nouns from specific scenarios. These will become the resources for the APIs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a user can perform the following actions in a shopping cart system:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: View a list of products
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View a product
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a product to the cart
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a product from the cart
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From these scenarios, we can extract the following resources:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Products
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re starting to identify and logically partition our APIs based on resources
    used throughout the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can apply an HTTP verb to each resource based on each scenario.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Relating HTTP verbs to resources
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the primary resources, we can apply an HTTP verb to each resource
    based on the specific scenario we defined in the previous section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: When creating an API, it may be tempting to use the noun/verb syntax – for example,
    [https://www.myurl.com/products/get](https://www.myurl.com/products/get) or [https://www.myurl.com/getproducts](https://www.myurl.com/getproducts).
    This approach is counterproductive since web standards already exist for this
    exact purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: While this does work, it violates some of the REST principles (which we’ll get
    into when we looked at standardized web API techniques in the following sections).
    For now, let’s take it step by step and create a simple shopping cart API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Each HTTP verb has a default operation based on its context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Returns a resource'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Creates a new resource'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Replaces an entire resource based on an identifier'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Updates specific items in a resource based on an identifier'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a resource'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, our scenarios in the previous section can begin to take shape
    based on the resources and their verbs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/products`: View a list of products'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/product/{id}`: View a product'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}`: Add a product to the cart with `POST` data (that
    is, `new { ProductId = {productId}, Qty =` `1 }`)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /api/cart/{cartId}`: Remove a product from the cart with `POST` data
    (that is, `new { ProductId = {``productId} }`)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/cart/{cartId}`: Retrieve a cart with all the products in the cart'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}/checkout`: Check out'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have matched the resources to the scenarios that have been defined,
    we can move forward with returning status codes to the caller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Returning HTTP status codes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the resources defined, we need to know whether the request was successful
    or not. This is where we return HTTP status codes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'These status codes are broken into the following categories:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx**: Information codes'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2xx**: Success codes'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3xx**: Redirection codes'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4xx**: Client-side codes'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5xx**: Server errors'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to unit tests, we look at a “happy” path and a broken path. But with
    APIs, we need to add an unrecoverable path in case an unrecoverable error occurs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two of the URLs and what status codes they should return.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/products` will return the following status codes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**200 Success**: Products were successfully returned'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**: Optional if something caused a problem'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the API was successful, it will return a list of the products with a 200
    status code. If there are issues, it will return a 500 status code. The API could
    also return additional status codes. For example, if an API call is made for specific
    users, the API could return a 401, which is an Unauthorized status code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}` with a post body of (`new { ProductId = {productId},
    Qty = 1 }`) will return the following status codes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**201 Created**: The item was created and added to the cart'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**202 Accepted**: The item was added to the cart'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found**: The cart or product wasn’t found'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**: An unrecoverable error occurred'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this API, we can return either a 201 Created or a 202 Accepted status code.
    If we couldn’t find the cart or product to add to the cart, return a 404 status
    code. Otherwise, return a 500 status code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: While these two examples are not set in stone, they should provide a template
    for the team to discuss what business rules dictate the status codes that are
    returned to the user. Whatever status codes are returned, they should provide
    enough context as to the request made through the API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Some APIs seen in the wild use an all-or-nothing approach; they either return
    a 200 or a 500\. It depends on how much information we want to send back to the
    client. These types of APIs feel like they’re missing more functionality, such
    as Unauthorized (401) or Not Found (404) status codes. It’s a best practice to
    include as much information as we can to the caller of the API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes are standard in web development and are presented through
    the RFC `HttpStatusCodeEnum` class with every status code at [https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode](https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode),
    along with `IActionResults` such as `Ok(object)`. Specific status codes can be
    found at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to design APIs and broke down each step – that
    is, disconnecting from the technology, identifying the resources, knowing the
    right verbs to apply to resources, and providing the correct response codes to
    our API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will look at two ways to test our APIs: one in Visual
    Studio with the new Endpoints Explorer and the other by creating a complete integration
    test.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Testing Web APIs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our APIs designed and created, we need a way to test them in our
    IDE and our integration tests. Luckily, Visual Studio has added the new Endpoints
    Explorer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn two ways to test our APIs. One way is through our
    development environment using Visual Studio. The second way we’ll test our API
    is through integration tests. If we have a CI/CD pipeline (which we should from
    [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)), these will automatically run
    to confirm our APIs work as expected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Endpoints Explorer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Historically, developers using Visual Studio had to run a separate tool to
    test their APIs, but with the latest version of .NET 8, the Visual Studio team
    added a new panel called **Endpoints Explorer**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Endpoints Explorer](img/B19493_09_4.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Endpoints Explorer
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a collection of APIs defined in the `Program.cs` file, our collection
    will appear as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Collection of APIs in Endpoints Explorer](img/B19493_09_5.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Collection of APIs in Endpoints Explorer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-clicking on an API will generate a request in a new HTTP Editor. The
    HTTP Editor allows custom-defined variables for the APIs listed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Sample API collection in the HTTP Editor](img/B19493_09_6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Sample API collection in the HTTP Editor
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.6*, the HTTP Editor uses the following commands to issue HTTP
    requests:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`@`: Creates a variable for the file (for example, `@variable` = `value`)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//`: This specifies comments'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`###`: This specifies the end of an HTTP request'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<HTTP Verb>`: Creates a REST-based request, including `DELETE`, `GET`, `HEAD`,
    `OPTIONS`, `PATCH`, `POST`, `PUT`, and `TRACE` requests'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Headers>`: Adds headers directly after defining the URL so that they’re included
    in the request'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have defined the APIs, there are green arrows in the left gutter. Run
    the application to test the API locally. Pressing the arrow in the far left gutter
    *while the API is running* will produce results in the right-hand pane:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Results of the /attractions request](img/B19493_09_7.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Results of the /attractions request
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we tested the `/attractions` request, received the data, and
    displayed it on the right.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important?
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using this new Visual Studio feature, we gain the following advantages:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized APIs**: We have a catalog of all of our APIs in one place'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.http` file, execute sample requests, and understand what each API does in
    the system'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE-integrated**: Additional tools aren’t necessary for testing our APIs'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This new feature is extremely helpful to developers looking to test existing
    APIs locally and also complements new minimal APIs introduced into the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Additional Endpoints Explorer material
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: For additional material on Endpoints Explorer, Sayed Ibrahim Hashimi has provided
    a great write-up about everything it can do at [https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer](https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Endpoints Explorer, how we can use it to help
    test APIs locally, and why it’s important. In the next section, we’ll take our
    APIs and learn how to use integration tests to produce quick results.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing APIs
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about how to use Endpoints Explorer to test
    our APIs. However, we shouldn’t have to install Visual Studio on a server to test
    our APIs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at applying an integration server for our APIs
    to achieve a complete end-to-end test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When we created unit tests back in [*Chapter 8*](B19493_08.xhtml#_idTextAnchor189),
    we created an in-memory representation of a database. We can create a similar
    environment where we can spin up and tear down the entire environment for API
    tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In our CI/CD pipelines, we can build a disposable server for our integration
    tests to provide a full end-to-end test with APIs and services and a disposable
    database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Building the integration server
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since .NET provides us with a simple `Program.cs` file for our applications,
    we can wrap the entire application and replace the services we want to mimic with
    a web and database server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up the environment using the `WebApplicationFactory` class. We include
    the minimal API project as a dependency in our `Api.Tests` project. Once we have
    our dependency in the program, we can create our `WebApplicationFactory` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code example, we inherited from `WebApplicationFactory<Program>`.
    The generic `<Program>` comes from the included dependency we referenced. Then,
    we created a root for our in-memory database and proceeded to configure our services
    by removing all instances of `DbContextOptionsBuilder<ThemeParkDbContext>`. Once
    we’ve removed these, we can create a new scoped reference to the same type with
    our updated settings for the database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added our new `ThemeParkDbContext` with our updated connection using
    a SQLite database. Remember, Entity Framework Core will automatically create the
    structure of our entire database with the `.EnsureCreated()` method. Finally,
    we added a dependency injection registration for `IThemeParkDbContext` for the
    services in our application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for our integration server. Now, we can use `TestThemeParkApiApplication`
    in our integration test. For example, if we want to create a test for our `/attractions`
    API, our integration test will look as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we initialized `TestThemeParkApiApplication`
    on setup so that every instance is new through the `.EnsureCreated()` method.
    `_app.CreateClient` gives us `HttpClient` to make a call to a URL. We make a call
    to our `/attractions` API and compare it with a resource string we created instead
    of cluttering our test methods with large JSON strings. Finally, our test compares
    the JSON results with what’s returned from an API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create entire front-to-back integration tests proving the APIs,
    Entity Framework queries, and database code work as expected while running through
    a CI/CD pipeline with successful tests should instill confidence about the code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to take APIs and test them in Visual Studio’s
    Endpoints Explorer. We also learned how to take those APIs and make them testable
    in a CI/CD pipeline by wrapping our API project using `WebApplicationFactory`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some of the common practices used in the industry
    when building APIs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Standardized Web API techniques
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to use HTTP verbs and status codes properly,
    how to avoid large dependent resources, how to create paginations for APIs, how
    to version an API, using DTOs instead of entities, and the best way to make API
    calls from .NET.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Using the right HTTP verbs and status codes
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve looked at how to use HTTP verbs and how to return status codes.
    While this may seem like a trivial thing, some systems ignore these standards
    and use POSTs all the time, regardless of the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Swagger provides a great template for documenting APIs and with Visual Studio’s
    new Endpoints Explorer, Visual Studio brings this fundamental documentation down
    to the developer’s IDE, making the API easier to read and implement in other projects,
    showing developers what verbs to use and what status codes are expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In our example of a shopping cart API earlier in this chapter, users were going
    to add products to a cart and proceed to check out. They were going to use a cart
    to begin this process. The function of checking out led us to use the cart API
    with a method of checkout (`/cart/checkout`), which makes perfect sense. We should
    take the user’s actions and match them to actions in the APIs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Beware dependent resources
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But how far do I take my API based on resources? What if one resource belongs
    to another resource and that’s dependent on another resource, and so on?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example: `/users/{userId}/projects/{projectId}/tasks`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We want to get a user’s tasks for a project, but this URL seems a bit long,
    doesn’t it? How do we break this down into something a bit more manageable? Anything
    more than three levels deep is simply asking for trouble.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This URL requires a more granular approach – that is, breaking out each resource.
    Instead of the preceding URL, a better approach would be to use `/users/{userId}/projects`
    to retrieve a list of projects a user is working on at a time. The next URL would
    provide the tasks based on the selected project and look like `/projects/{projectId}/tasks`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we all know everything is a compromise. In this case, we are
    providing a simpler API but requiring two calls instead of one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: These are discussions to be had with team members, but essentially, the smaller
    the URL, the easier it is to implement. The longer the URL, the more resource
    lookups are necessary to fulfill the request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Pagination in API results
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most API calls, results are returned in a raw, **JavaScript Object Notation**
    (**JSON**) format, usually as a collection or a single item. What if the client
    side needs paginated results and they only want one page of data for now?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'To assist client-side developers, a JSON result could contain the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While returning results as a collection is usually required, some fields to
    return in the header are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`Total`: Total number of records'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PageSize`: How many records are returned in this response'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalPages`: Specifies the total number of pages based on `PageSize`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentPage`: Specifies what page we are currently on'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Next` and `Previous`: Are there enough records to move back and forward?'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sort`: Specifies how the results are sorted'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter`: Specifies what filter was applied to the results'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header is meant to help our fellow client-side developer make the most of
    the response. While this isn’t a comprehensive list of fields to include, it should
    be implemented with consistency across every single response when displaying a
    subset of records on the client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: A “status code” field or “success” field in the header should be avoided since
    HTTP status codes are considered the expected response.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Versioning APIs
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating APIs, by default, they’ll more than likely be in a raw state
    with no versioning in place. There are four types of versioning:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**No versioning**: When we create our first API'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/users`)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/?version=1`)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom-header` to place the version into the header:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most common versioning technique that’s used is URI versioning. While everyone’s
    mileage may vary, this technique is appealing because it’s immediately obvious
    which version we’re using.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Use DTOs, not entities!
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While testing our API, we weren’t returning entities (`Attraction` or `Location`).
    Instead, we were returning **data transfer objects** (**DTOs**), which are a subset
    of properties.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Our security chapter ([*Chapter 4*](B19493_04.xhtml#_idTextAnchor086)) mentioned
    not to expose too much when it comes to primary keys or sensitive information.
    DTOs give the developer a chance to pick and choose which properties should be
    exposed to the client.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `Attraction` DTO is meant to provide a minimal amount of information;
    we’ll discuss this after we look at the following code example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have a simplified `AttractionDto` class containing simple properties.
    We also have a `LocationName` property based on our dependent `Location` class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: While we have this as a `.ToDto()` method, we could create other DTO extension
    methods to return different data in a `.ToDifferentDto()` method or whatever we
    want to call it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use DTOs instead of Entity Framework entities is the potentially
    recursive nature of navigational properties. When an entity is returned from an
    API, it’s turned into a JSON object. If we have a nested entity, it’ll follow
    it down the chain. It’s better to isolate and distill an entity’s properties down
    to their native types for basic consumption on the client side when they’re returned
    from the API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Avoid new instances of HttpClient
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the majority of this chapter discussed creating and testing APIs, I feel
    we need to mention how to consume them in a .NET application as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to consume a web API, such as using `WebRequest` or `WebClient`,
    but for most purposes, the use of the `HttpClient` class is recommended because
    of its flexibility and modernization. The `WebRequest` and `WebClient` classes
    were included for the transition of legacy applications. With that said, it’s
    easy to create a new instance of `HttpClient`, but it’s not the best approach.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft states that `HttpClient` should only be used once per the lifetime
    of an application. If we create instances of `HttpClient` in multiple locations
    in our application, we are hindering the performance and scalability opportunities.
    It causes an issue called TCP port exhaustion if the rate of requests is too high,
    so it’s best to avoid code such as the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Some developers may take this a step further and decide the following code
    snippet is better by wrapping a `using` statement to dispose of an `HttpClient`
    class properly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The problem with this code is that we’re still creating another instance of
    `HttpClient`, still causing port exhaustion, and still disposing of it when we’ll
    more than likely need it later.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Core 2.1, Microsoft created an `IHttpClientFactory` class to deliver
    a single instance of `HttpClient`. We can simply ask it for an `HttpClient` instance
    and we’ll receive one. The best news is it can be dependency injected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 2.1 中，Microsoft 创建了一个 `IHttpClientFactory` 类来提供单个 `HttpClient` 实例。我们可以简单地请求一个
    `HttpClient` 实例，并且我们会收到一个。最好的消息是它可以进行依赖注入。
- en: 'The code becomes easier to work with once we’ve injected the class through
    constructors, as shown in the following code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过构造函数注入了类，代码就会变得更容易处理，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we ask `HttpClientFactory` for a client using `.CreateClient()`, it won’t
    create a new instance of `HttpClient` unless it has to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `.CreateClient()` 从 `HttpClientFactory` 获取客户端时，除非必须，否则它不会创建一个新的 `HttpClient`
    实例。
- en: 'Think of the `.CreateClient()` method as using a singleton design pattern behind
    the scenes, similar to the code shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.CreateClient()` 方法视为在幕后使用单例设计模式，类似于以下代码所示：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As a side note, the preceding code is *not* thread-safe; it has been provided
    to show the concept of a singleton design pattern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，前面的代码**不是**线程安全的；它被提供出来以展示单例设计模式的概念。
- en: We always get an instance of `HttpClient`, which is a better way to make server-side
    API calls.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是得到一个 `HttpClient` 实例，这是进行服务器端 API 调用的更好方式。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about several techniques, such as how to design
    an API by disconnecting from technology by becoming a user of the application,
    identifying the resources, and using the right HTTP verbs and correct status codes.
    We also learned how to create, test, and document APIs, along with why minimal
    APIs are important. After, we learned how to use the new Endpoints Explorer in
    Visual Studio 2022, as well as how to build an automated end-to-end test of our
    APIs in a CI/CD pipeline.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几个技术，例如如何通过成为应用程序的用户、识别资源、使用正确的 HTTP 动词和状态码来设计 API。我们还学习了如何创建、测试和记录
    API，以及为什么最小 API 很重要。之后，我们学习了如何在 Visual Studio 2022 中使用新的端点探索器，以及如何在 CI/CD 管道中构建我们
    API 的自动化端到端测试。
- en: Once we understood the process of writing APIs, we examined what standards were
    used in the industry to create common and useful APIs, such as using the correct
    HTTP verbs and status codes, avoiding large URLs, how to use pagination with APIs,
    versioning our API, using DTOs instead of entities, and the optimal way to use
    `HttpClient` when making API calls from .NET.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了编写 API 的过程，我们就检查了在行业中用于创建通用和有用 API 的标准，例如使用正确的 HTTP 动词和状态码、避免大型 URL、如何使用
    API 进行分页、API 版本化、使用 DTO 而不是实体，以及从 .NET 进行 API 调用时使用 `HttpClient` 的最佳方式。
- en: In the next chapter, we’ll look at how to improve performance across various
    topics we’ve covered in this book, and we’ll also provide some new performance
    tips.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何提高本书中涵盖的各个主题的性能，并提供一些新的性能提示。
