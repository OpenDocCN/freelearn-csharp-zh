- en: Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay
    Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 交易纸杯蛋糕和终极蛋糕争夺战 – 游戏玩法编程
- en: 'After going through different parts of the Unity engine, it''s time to come
    back to our game and finish it up. In doing this, we will explore another big
    topic: **gameplay programming**. In particular, we will see how data can be exchanged
    between different parts of a game. Since in our tower defense game there are still
    many parts to connect, and they can be implemented in thousands of different ways,
    I tried to choose different techniques in order to give you a different perspective
    on how things can be implemented within Unity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Unity引擎的不同部分之后，是时候回到我们的游戏并完成它了。在这个过程中，我们将探讨另一个重要主题：**游戏玩法编程**。特别是，我们将看到数据如何在游戏的不同部分之间交换。由于在我们的塔防游戏中还有许多部分需要连接，并且它们可以以数千种不同的方式实现，我尝试选择不同的技术，以便给你一个在Unity中实现事物的新视角。
- en: 'Specifically, in this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中我们将涵盖：
- en: How to implement a trading system to allow the player to buy, sell, and upgrade
    cupcake towers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个交易系统，允许玩家购买、出售和升级纸杯蛋糕塔
- en: Scripting how the player can place cupcake towers on the map once they are bought
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本，以便玩家在购买后可以在地图上放置纸杯蛋糕塔
- en: How game over conditions can be triggered to display a winning or losing screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何触发游戏结束条件以显示胜利或失败屏幕
- en: Keeping track of the progress made by the player during the level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪玩家在关卡中取得的进展
- en: Creating a spawn system for our Pandas, based on dividing the Pandas into waves
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据将熊猫分为波次来创建我们的熊猫的生成系统
- en: Designing and implementing a main menu
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现主菜单
- en: How to change a scene in Unity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Unity中更改场景
- en: As always, at the end of the chapter you can find the *Homework* section, which
    is full of exercises for you to bring your skills to a higher level. Some of these
    exercises will challenge you about the concepts learnt in the chapter, and they
    will guide you in improving our tower defense game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在章节的结尾你可以找到*作业*部分，其中充满了练习，帮助你将技能提升到更高的水平。其中一些练习将挑战你对章节中学到的概念的理解，并将指导你改进我们的塔防游戏。
- en: But before we go straight into gameplay programming for our game, let's spend
    some time learning about gameplay programming in general.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们直接进入游戏玩法编程之前，让我们花些时间了解一般性的游戏玩法编程。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To better understand this chapter, you should have followed all of the other
    chapters, since we are going to implement our scripts here on top of the ones
    we have previously created throughout the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解本章，你应该已经阅读了所有其他章节，因为我们将在这里实现我们的脚本，这些脚本是在本书中之前创建的。
- en: For simplicity, for those readers who only did the first implementation in the
    previous chapter, I have kept the code of the first implementation. However, for
    those who did the second implementation, you shouldn't have a problem doing the
    same modifications to the code. In any case, it's recommended that you have the
    second implementation of the code in the game, because the next chapter will give
    us some ways to exploit its potential in the context of a larger game.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，对于那些只在上一章中进行了第一次实现的读者，我保留了第一次实现的代码。然而，对于那些进行了第二次实现的读者，你应该没有问题对代码进行相同的修改。无论如何，建议你在游戏中保留代码的第二次实现，因为下一章将给我们一些方法来利用其在更大游戏环境中的潜力。
- en: What does gameplay programming mean?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法编程是什么意思？
- en: There is not a unique definition for gameplay programming. Of course, it deals
    with building and developing the game, but for instance, does it include programming
    artificial intelligence? Or UIs? Or database connections? Or animation machines?
    Therefore, the definition depends on the context. However, it is interesting to
    note how the definition changes again, when you seek a job position. As a rule
    of thumb, based only on experience, the bigger and larger the company is, the
    better the gameplay programmer job position will be. In fact, in small companies,
    teams can be resource limited and therefore having a gameplay programmer means
    that he/she will do everything, whereas in larger teams where there are AI, UI,
    and animation programmers, the gameplay programmer is likely to be more a coordinator
    of all such roles, and therefore it is a higher position.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩法编程并没有一个独特的定义。当然，它涉及到游戏的建设和发展，但例如，它是否包括人工智能编程？或者用户界面？或者数据库连接？或者动画机器？因此，定义取决于上下文。然而，值得注意的是，当你寻找工作职位时，定义又会发生变化。一般来说，根据经验，公司越大，游戏玩法程序员的工作职位越好。实际上，在小公司中，团队可能资源有限，因此拥有一个游戏玩法程序员意味着他/她将做所有事情，而在有AI、UI和动画程序员的较大团队中，游戏玩法程序员更可能成为所有这些角色的协调者，因此这是一个更高的职位。
- en: 'I would like to close this section with a quote from a blog of a game developer
    (Ask a Game Dev at [http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer](http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer)),
    who describes what it feels like to be a gameplay programmer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用一位游戏开发者的博客中的一句话来结束本节（[游戏开发者博客](http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer)），他描述了作为一名游戏玩法程序员的感觉：
- en: '*"As you can see, being a gameplay programmer is about solving problems even
    moreso than the designer - you have to really figure out all of the bits of the
    problem and solve them all. But you also have much more in-depth knowledge of
    how the entire system works. You get to create those systems. You get to be the
    first to see something awesome happen."*'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"正如你所见，成为一名游戏玩法程序员不仅仅是解决问题，甚至比设计师还要多——你必须真正弄清楚问题的所有方面并解决它们。但你也有更深入的了解整个系统是如何工作的。你可以创建这些系统。你可以成为第一个看到令人惊叹的事情发生的人。"*'
- en: Now, it's time to go into the specifics and get our tower defense game done!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候深入细节，完成我们的塔防游戏了！
- en: Planning what is left to implement for our game
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们游戏剩余要实现的内容
- en: The first thing to do before we complete our game is to reorganize the ideas
    after having written down what we have done so far.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成游戏之前，首先要做的是整理我们已经写下的想法。
- en: In [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in Unity"),
    *A Flat World in Unity*, we imported all the Sprites and set them up properly.
    Then, in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking
    Cupcake Towers*, we implemented the Projectile and Cupcake tower classes. In [Chapter
    3](part0043.xhtml#aid-190861 "Chapter 3. Communicating with the Player – the User
    Interface"), *Communicating with the Player – the User Interface*, we implemented
    the health and the sugar of the player, whereas in [Chapter 4](part0056.xhtml#aid-1LCVG1
    "Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone
    – Sweet-Toothed Pandas Strike*, we focused on animating our sweet-toothed Panda.
    Finally, in [Chapter 5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient
    Is a Dash of Physics"), *The Secret Ingredient Is a Dash of Physics*, we explored
    physics and how we can use it within our game, and in [Chapter 6](part0077.xhtml#aid-29DRA1
    "Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence"),
    *Through a Sea of Sprinkles – Navigation in Artificial Intelligence*, we gave
    the Pandas the possibility of moving along the path towards the sweet cake.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")，*Unity中的平面世界*中，我们导入了所有精灵并正确设置了它们。然后，在[第2章](part0028.xhtml#aid-QMFO1
    "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*中，我们实现了投射物和纸杯蛋糕塔类。在[第3章](part0043.xhtml#aid-190861 "第3章。与玩家沟通——用户界面")，*与玩家沟通——用户界面*中，我们实现了玩家的生命值和糖分，而在[第4章](part0056.xhtml#aid-1LCVG1
    "第4章。不再孤单——甜食熊猫出击")，*不再孤单——甜食熊猫出击*中，我们专注于为我们的甜食熊猫制作动画。最后，在[第5章](part0062.xhtml#aid-1R42S1
    "第5章。秘密成分是物理学的一点点")，*秘密成分是物理学的一点点*中，我们探讨了物理学以及我们如何在游戏中使用它，并在[第6章](part0077.xhtml#aid-29DRA1
    "第6章。穿过糖霜的海洋——人工智能中的导航")，*穿过糖霜的海洋——人工智能中的导航*中，我们给了熊猫沿着通往甜蛋糕的路径移动的可能性。
- en: 'So, what''s left to do is the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来要做的有以下几点：
- en: Integrate a trading system so the player can buy, sell, and upgrade cupcake
    towers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成一个交易系统，以便玩家可以购买、出售和升级纸杯蛋糕塔
- en: Create a mechanism to place the cupcake towers once they have been bought
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个机制，以便在购买后放置纸杯蛋糕塔
- en: Specify how the player can select a specific cupcake tower
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定玩家如何选择特定的纸杯蛋糕塔
- en: Set up game over conditions.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置游戏结束条件。
- en: Keeping track of the progress of the player during gameplay
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏过程中跟踪玩家的进度
- en: Implement a spawning system for our Pandas
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的熊猫实现一个生成系统
- en: Create a main menu for our game
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏创建一个主菜单
- en: After we have done all of this, we will basically have a functioning game. So,
    let's get started with the first on the list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，我们基本上将有一个功能齐全的游戏。所以，让我们从列表中的第一个开始。
- en: Trading cupcake towers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易纸杯蛋糕塔
- en: In this section, we will see how to allow the player to trade towers. In particular,
    the player can either buy, sell, or upgrade a cupcake tower. Since these three
    actions have something in common, we will implement them by using **inheritance**.
    If you remember, we talked a bit about it in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, but now we have
    the possibility of seeing it in action. As a result, along the way we will have
    a better understanding of abstract methods and static variables, since we will
    use them again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何允许玩家进行塔的交易。特别是，玩家可以购买、出售或升级一个纸杯蛋糕塔。由于这三个动作有一些共同点，我们将通过使用**继承**来实现它们。如果你还记得，我们在[第2章](part0028.xhtml#aid-QMFO1
    "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*中谈到了一点，但现在我们有机会看到它付诸实践。因此，在这个过程中，我们将更好地理解抽象方法和静态变量，因为我们将再次使用它们。
- en: 'In any case, each one of these trading actions that the player can perform
    are implemented separately. This is the structure we will implement:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，玩家可以执行的所有这些交易动作都是单独实现的。这是我们将会实现的架构：
- en: '![Trading cupcake towers](img/image00594.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![交易纸杯蛋糕塔](img/image00594.jpeg)'
- en: Each of the child scripts can be attached to a UI element, and that will be
    transformed into a button to perform that specific action. Let's start with the
    parent class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子脚本都可以附加到一个UI元素上，这将转换成一个按钮来执行该特定动作。让我们从父类开始。
- en: The trading parent class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易父类
- en: Let's start to create a general class named `TradeCupcakeTower`, and open it
    with your favorite code editor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个名为`TradeCupcakeTower`的通用类，并使用你最喜欢的代码编辑器打开它。
- en: 'Buying, selling, and upgrading require the user to click on their icon in the
    user interface (we will create the UI in the scene for the trading actions after
    we have scripted the whole trading system first), and so we need to provide a
    way to detect the click (or the tap in case of a mobile application) of the player.
    As we have talked about it in [Chapter 3](part0043.xhtml#aid-190861 "Chapter 3. Communicating
    with the Player – the User Interface"), *Communicating with the Player – the User
    Interface*, we can use a handler. Thus, we need to add the following library at
    the beginning of our script:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 购买、出售和升级需要用户在用户界面中点击他们的图标（我们将在脚本整个交易系统完成后创建场景中的UI以执行交易动作），因此我们需要提供一种检测玩家点击（或移动应用中的轻触）的方法。正如我们在[第3章](part0043.xhtml#aid-190861
    "第3章。与玩家沟通——用户界面")，*与玩家沟通——用户界面*中讨论的那样，我们可以使用一个处理器。因此，我们需要在脚本开头添加以下库：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in the definition of the class, we can add the click handler. Moreover,
    since this will be an abstract class, we need to specify it in the following way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在类的定义中，我们可以添加点击处理器。此外，由于这将是一个抽象类，我们需要以下方式指定它：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When trading, we want to check the player''s sugar level (which is the currency
    of our game). As a result, we need to have a reference to the Sugar Meter, which
    is also shared among all the trading classes. Thus, we can make the variable protected
    and static:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易时，我们想要检查玩家的糖分水平（这是我们游戏的货币）。因此，我们需要有一个对糖量计的参考，它也是所有交易类共享的。因此，我们可以使这个变量成为受保护的静态变量：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similar to what we did in the last chapter when we had to get the reference
    to the game manager for all the Pandas (since also, in that case the variable
    was static), we need to get the reference to the Sugar Meter only once. As such,
    in the `Start()` function we can write:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在上一章中必须获取所有Pandas的游戏管理器引用时所做的（因为在这种情况下变量也是静态的），我们只需要获取一次糖量计的引用。因此，在`Start()`函数中，我们可以编写：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the player sells or upgrades a tower, the trading system should know which
    tower the player is referring to (how the player selects a tower is left for later
    in *Selecting the towers* section). Therefore, again we can use a protected and
    static variable shared across all the trading operation classes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家出售或升级一座塔时，交易系统应该知道玩家指的是哪座塔（玩家如何选择塔留待*选择塔*部分稍后讨论）。因此，我们再次可以使用所有交易操作类共享的受保护和静态变量：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we need a function to set the selection (the current active tower), and
    it needs to be static, so it can be easily set by other scripts (as we will see
    later). The function just assigns the tower passed as a parameter to the static
    variable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个函数来设置选择（当前活动塔），并且它需要是静态的，这样其他脚本就可以轻松设置（正如我们稍后将会看到的）。该函数只是将作为参数传递的塔赋值给静态变量：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we need to implement the interface for handling the click. However,
    the sequence of actions that should be performed depends on if the player is either
    buying, selling, or upgrading. Therefore, we can leave the implementation to the
    child classes, and leave this as an abstract function (refer to [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, on how abstract
    and virtual methods work) as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现处理点击的接口。然而，应该执行的动作序列取决于玩家是在购买、出售还是升级。因此，我们可以将实现留给子类，并将这个作为抽象函数（参考[第2章](part0028.xhtml#aid-QMFO1
    "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*，了解抽象和虚函数的工作方式）如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can save the script, and as a result our parent class is ready. Now, before
    we implement its children for specific trading actions that the player can perform,
    we need to modify the `CupcakeTowerScript`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存脚本，因此我们的父类就准备好了。现在，在我们实现其子类以执行玩家可以执行的具体交易动作之前，我们需要修改`CupcakeTowerScript`。
- en: Modifying the CupcakeTowerScript
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改CupcakeTowerScript
- en: Back in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking
    Cupcake Towers*, we implemented many functionalities for our cupcake towers. However,
    there is more work to do on their script. In particular, we need to add some variables
    to store their prices and costs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第2章](part0028.xhtml#aid-QMFO1 "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*，我们为我们的纸杯蛋糕塔实现了许多功能。然而，在它们的脚本上还有更多的工作要做。特别是，我们需要添加一些变量来存储它们的价格和成本。
- en: 'Let''s start by adding the following self-explanatory variables, which we may
    want to set into the **Inspector** later:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加以下自解释的变量开始，我们可能希望在稍后将其设置到**检查器**中：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Every time we upgrade the cupcake tower, we want to raise both the `sellingValue,`
    because an upgraded tower is more valuable, and the `UpgradingCost`, because upgrading
    to higher levels requires more sugar. So, we can add the following lines of code
    in the `Upgrade()` function (the values may depend on your very specific balance
    of the game, but the next chapter will go into more detail on this and how to
    handle costs of towers in a dynamic way):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们升级杯子蛋糕塔时，我们希望同时提高`sellingValue`（因为升级后的塔更有价值），以及`UpgradingCost`（因为升级到更高等级需要更多的糖）。因此，我们可以在`Upgrade()`函数中添加以下代码行（这些值可能取决于你游戏中非常具体的平衡，但下一章将更详细地介绍这一点以及如何以动态方式处理塔的成本）：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the script, and go into your cupcake tower prefabs and change the values
    of these three, new variables in the **Inspector** (again, feel free to use the
    values you prefer). Here is an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，进入你的杯子蛋糕塔预制体，并在**检查器**中更改这三个新变量的值（当然，你可以使用你喜欢的值）。以下是一个示例：
- en: '![Modifying the CupcakeTowerScript](img/image00595.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![修改CupcakeTowerScript](img/image00595.jpeg)'
- en: Now, we are ready to implement the trading actions, starting with buying.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好实施交易动作，从购买开始。
- en: Buying cupcake towers
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购买杯子蛋糕塔
- en: In this section, we will implement the script that handles the buying action.
    Let's start by creating a new script and name it TradeCupcakeTowers_Buying and
    open it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现处理购买动作的脚本。让我们先创建一个新的脚本，命名为`TradeCupcakeTowers_Buying`，然后打开它。
- en: 'First of all, we still need to import the event systems library from the Unity
    engine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们仍然需要从Unity引擎中导入事件系统库：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the class declaration, we need to specify that we are going to extend the
    `TradeCupcakeTowers` class, instead of `MonoBehaviour`, in the following way:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中，我们需要指定我们将要扩展`TradeCupcakeTowers`类，而不是`MonoBehaviour`，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you look at the design of our user interface back in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*, we have three different kinds of towers
    that the player can buy. Each one of the buttons, once clicked, will instantiate
    a different tower. Therefore, we need to specify which cupcake tower prefab this
    instance of the script is referring to. Of course, its values should be set in
    the **Inspector** (we will see this later). So, let''s add the following variable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下[第3章](part0043.xhtml#aid-190861 "第3章。与玩家沟通——用户界面")中的用户界面设计，*与玩家沟通——用户界面*，我们有三种不同的塔供玩家购买。每个按钮一旦被点击，就会实例化一个不同的塔。因此，我们需要指定这个脚本的实例引用的是哪个杯子蛋糕塔预制体。当然，其值应该在**检查器**中设置（我们稍后会看到这一点）。所以，让我们添加以下变量：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we need to implement the abstract function inherited from its parent,
    to handle what happens when the player clicks on its icon. As such, we need to
    use the `override` property, and declare the method in the following way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现从其父类继承的抽象函数，以处理玩家点击其图标时发生的情况。为此，我们需要使用`override`属性，并以下述方式声明方法：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, the first thing to do when the player clicks is to retrieve the price
    of the cupcake tower that the player wants to buy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家点击时首先要做的是检索玩家想要购买的杯子蛋糕塔的价格：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to check if the player has enough sugar, by using the shared
    static variable, `sugarMeter`. If the player has enough sugar, then a new cupcake
    tower is instantiated (we will see how the player places the tower later in the
    chapter) and it is assigned as the active tower among the trading classes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过使用共享静态变量`sugarMeter`来检查玩家是否有足够的糖。如果玩家有足够的糖，则实例化一个新的杯子蛋糕塔（我们将在本章后面看到玩家如何放置塔），并将其分配为交易类中的活动塔：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save the script, and the buy functionality is implemented. Let's see how the
    player can sell the cupcake towers to get some sugar back.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，购买功能已实现。让我们看看玩家如何通过出售杯子蛋糕塔来获取一些糖分。
- en: Selling cupcake towers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出售杯子蛋糕塔
- en: In this section, we will implement the script that handles the selling action.
    Create a new script and name it `TradeCupcakeTowers_Selling`, then open it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现处理销售动作的脚本。创建一个新的脚本，命名为`TradeCupcakeTowers_Selling`，然后打开它。
- en: 'Once again, we still need to import the event systems library from the Unity
    engine:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们仍然需要从Unity引擎中导入事件系统库：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we did for the `TradeCupcakeTowers_Buying`, we need to inherit from the
    `TradeCupcakeTowers` class in the following way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与`TradeCupcakeTowers_Buying`一样，我们需要以下方式从`TradeCupcakeTowers`类中继承：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we need to implement the abstract function, to handle what happens when
    the player clicks on the selling icon. Again, we need to use the `override` property,
    like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现抽象函数，以处理玩家点击销售图标时发生的情况。再次，我们需要使用 `override` 属性，如下所示：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since selling is an action that the player is always able to perform, we don''t
    need to do any checks (except if there is an active tower), but rather retrieve
    the value of the cupcake tower and add that amount to the player''s savings. Then,
    remove the cupcake tower from the scene:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于销售是玩家始终能够执行的操作，我们不需要进行任何检查（除非有一个活动的塔），而是检索纸杯蛋糕塔的价值，并将其金额添加到玩家的储蓄中。然后，从场景中移除纸杯蛋糕塔：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we can save the script. As a result, the selling functionality is also
    implemented. Only the upgrading one is left.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以保存这个脚本。因此，销售功能也得到了实现。只剩下升级功能未完成。
- en: Upgrading cupcakes towers
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级纸杯蛋糕塔
- en: Here we get to create the upgrading button. Create a script and name it `TradeCupcakeTowers_Upgrading`,
    then open it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要创建升级按钮。创建一个脚本，命名为 `TradeCupcakeTowers_Upgrading`，然后打开它。
- en: 'Once again, we still need to import the event systems library from the Unity
    engine:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们仍然需要从Unity引擎中导入事件系统库：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we did for the other trading classes, we need to inherit from the `TradeCupcakeTowers`
    class in the following way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对其他交易类所做的那样，我们需要以下方式从 `TradeCupcakeTowers` 类中继承：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we need to implement the abstract function, to handle what happens when
    the player clicks on the upgrading button. Once more, we need to use the `override` property,
    like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现抽象函数，以处理玩家点击升级按钮时发生的情况。再次，我们需要使用 `override` 属性，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similar to what we did with the buying button, we need to check if the player
    can afford to upgrade the tower, and if the tower is actually upgradable (we had
    a Boolean flag for that, set back in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking
    Cupcake Towers"), *Baking Cupcake Towers*). If so, the cost of the upgrade is
    subtracted from the player''s sugar, and the tower is finally upgraded:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们处理购买按钮的方式类似，我们需要检查玩家是否有能力升级塔，以及塔是否真的可以升级（我们有一个布尔标志用于此，设置在[第2章](part0028.xhtml#aid-QMFO1
    "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*)。如果是这样，升级的费用将从玩家的糖分中扣除，塔最终升级：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save this script, and as a result we have completed all the trading functionalities.
    However, they are not present in the scene, so let's add them to our interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个脚本，结果我们就完成了所有的交易功能。然而，它们在场景中并不存在，所以让我们将它们添加到我们的界面中。
- en: Adding the trading options to the user interface
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将交易选项添加到用户界面
- en: Now that we have the scripts to implement all the different trading buttons,
    we need to actually place them within our scene/level.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了实现所有不同交易按钮的脚本，我们需要实际上将它们放置在我们的场景/级别中。
- en: 'Therefore, let''s start to create three UI images, and attach to each one of
    them, the `TradeCupcakeTowers_Buying` script. As their **Source Image**, you can
    select the icons we have in our graphical package for the three different kind
    of towers we have. In case you didn''t implement them all, that''s alright, just
    remove the buttons you don''t need. If on the contrary, you have implemented more
    with your own graphics, feel free to add more of these buttons. Then, after you
    have properly scaled the buttons, place them within our interface as shown in
    the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始创建三个UI图像，并将 `TradeCupcakeTowers_Buying` 脚本附加到每个图像上。作为它们的**源图像**，你可以选择我们图形包中为三种不同类型的塔提供的图标。如果你没有实现所有这些，没关系，只需删除你不需要的按钮。相反，如果你使用自己的图形实现了更多，请随意添加更多这些按钮。然后，在你正确缩放按钮后，将它们放置在以下截图所示的界面中：
- en: '![Adding the trading options to the user interface](img/image00596.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![将交易选项添加到用户界面](img/image00596.jpeg)'
- en: 'Then, in the **Inspector**, we need to assign their respective **Cupcake Tower
    Prefab**. Here is just one of the three buttons, shown as an example for you:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**检查器**中，我们需要分配它们各自的**纸杯蛋糕塔预制体**。这里只展示了三个按钮中的一个，作为示例供你参考：
- en: '![Adding the trading options to the user interface](img/image00597.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![将交易选项添加到用户界面](img/image00597.jpeg)'
- en: Very well, now the player can buy towers! What about selling and upgrading them?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在玩家可以购买塔了！那么关于销售和升级它们呢？
- en: 'Let''s create another two UI images, and attach respectively, the `TradeCupcakeTowers_Selling`
    and `TradeCupcakeTowers_Upgrading` scripts to them. Then, use the icons for selling
    and upgrading you can find in our graphical package as **Source Image**. Scale
    the buttons properly, and place them within our interface as shown in the following
    screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建另外两张UI图像，并将分别附上`TradeCupcakeTowers_Selling`和`TradeCupcakeTowers_Upgrading`脚本。然后，使用我们在图形包中可以找到的用于销售和升级的图标作为**源图像**。适当地调整按钮大小，并将它们放置在以下截图所示的用户界面中：
- en: '![Adding the trading options to the user interface](img/image00598.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![将交易选项添加到用户界面](img/image00598.jpeg)'
- en: We don't have any variables to assign in the **Inspector**, so we can consider
    our trading system ready! Although to make it work properly, we still need to
    have a way to place our towers and a way to select the towers. These will be explored
    in the next sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**中我们没有任何变量需要分配，因此我们可以认为我们的交易系统已经准备好了！尽管要使其正常工作，我们仍然需要一种放置塔楼的方法以及选择塔楼的方法。这些内容将在下一节中进行探讨。
- en: Placing the towers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放置塔楼
- en: Once the player has bought a cupcake tower, he or she should be able to decide
    where to place it. This section will explore how to implement this mechanism,
    which may be simple, but requires you pay attention to many things.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家购买了纸杯蛋糕塔，他或她应该能够决定将其放置在哪里。本节将探讨如何实现这一机制，这可能很简单，但需要你注意许多细节。
- en: Sketching the idea of how it works
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制工作原理的草图
- en: There are many ways in which we can implement this system, but we will use colliders
    and a second script on the cupcake tower. As a result, you will also be able to
    learn new ways to handle situations in which information should be exchanged among
    the different game elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式实现这个系统，但我们将使用碰撞器和纸杯蛋糕塔上的第二个脚本。因此，你还将学会处理不同游戏元素之间信息交换的新方法。
- en: In particular, we will define some areas where it is allowed to place a tower,
    and we will do this through the use of colliders. Then, the game manager registers
    if the pointer of the player is within allowed areas. A second script, attached
    to the cupcake towers, uses this information from the game manager to actually
    allow the player to place cupcake towers. Moreover, once the tower is placed,
    the script attaches a collider to the cupcake tower. This will prevent a tower
    from being placed on top of others, and it will also be useful for implementing
    the selection system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们将定义一些允许放置塔楼的区域，我们将通过使用碰撞器来实现这一点。然后，游戏管理器会注册玩家的指针是否在允许区域内。第二个脚本附加到纸杯蛋糕塔上，它使用游戏管理器提供的信息来实际上允许玩家放置纸杯蛋糕塔。此外，一旦塔楼放置好，脚本会为纸杯蛋糕塔附加一个碰撞器。这将防止塔楼被放置在其他塔楼之上，并且对于实现选择系统也将非常有用。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the *Homework* section, you will find some exercises to improve what we are
    going to implement in this section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在**作业**部分，你将找到一些练习来提高我们将在本节中实现的内容。
- en: Allowed areas
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许区域
- en: 'To begin, we should notice that the player is not free to place his towers
    wherever he wants to on the map. In fact, he cannot place them along the path
    where the Pandas are moving or in areas where there is water or other obstacles.
    Therefore, we need to specify this constraint within our game. Thus, we need to
    look at our map and find all the spots where the player can place the tower. In
    our case, the spots that we are looking for are the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该注意到玩家不能在地图上的任何地方随意放置他的塔楼。实际上，他不能在熊猫移动的路径上或在水或其他障碍物所在的区域放置塔楼。因此，我们需要在我们的游戏中指定这个限制。因此，我们需要查看我们的地图，并找到玩家可以放置塔楼的所有位置。在我们的案例中，我们正在寻找的位置如下：
- en: '![Allowed areas](img/image00599.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![允许区域](img/image00599.jpeg)'
- en: As we can see, they have a custom shape. Even if it is possible to implement
    custom shapes (which is left as an exercise to readers who want to challenge themselves),
    it can be much more convenient to think in terms of rectangles and thus to split
    our shapes into rectangles. Of course, this can be done in more than one way;
    however, the less rectangles that cover the entire area, the better from a computational
    point of view. On the other hand, by using more rectangles, you are able to better
    approximate your areas. So find your tradeoff.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它们具有自定义的形状。即使可以实现自定义形状（这留给想要挑战自己的读者作为练习），但以矩形的形式思考并因此将我们的形状分割成矩形可能会更加方便。当然，这可以以多种方式完成；然而，覆盖整个区域的矩形越少，从计算的角度来看就越好。另一方面，通过使用更多的矩形，你能够更好地近似你的区域。所以找到你的权衡点。
- en: 'A possible choice could be the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的选择如下：
- en: '![Allowed areas](img/image00600.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![允许区域](img/image00600.jpeg)'
- en: In the end, we have found 11 areas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到了11个区域。
- en: The idea here is that all these areas are **Box Colliders 2D** attached to the
    `Game Manager` object, which will check if the mouse is within one of these areas
    or not by toggling a flag. This flag will be read by the script we are going to
    implement in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，所有这些区域都连接到`Game Manager`对象上的**2D盒子碰撞器**，它将通过切换一个标志来检查鼠标是否位于这些区域之一。这个标志将被我们在下一节中要实现的脚本读取。
- en: Let's start by adding a **Box Collider 2D** on the **Game Manager** by clicking
    on** Component | Physics 2D | Box Collider 2D**. Then, we need to resize it to
    the same dimensions as one of the rectangles we have found, and by using the offset
    parameter, place it onto the map. At this stage in the book, you should be able
    to repeat this operation for all the areas of the map, without having their exact
    values written down here in the book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在**游戏管理器**上添加一个**2D盒子碰撞器**开始，方法是点击**组件 | 物理效果 2D | 2D盒子碰撞器**。然后，我们需要将其调整到与我们所找到的矩形相同的尺寸，并使用偏移参数将其放置到地图上。在这个阶段，你应该能够重复此操作以覆盖地图的所有区域，而无需在此书中写下它们的精确值。
- en: 'Now, the next stage is to modify the `GameManagerScript` to toggle the flag.
    Once we have opened the script, we can already add the flag as a Boolean variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是修改`GameManagerScript`以切换标志。一旦我们打开了脚本，我们就可以添加标志作为一个布尔变量：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since we don''t want other scripts to change this variable, it is private,
    and therefore we need to expose a function to retrieve its value:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望其他脚本更改此变量，它是私有的，因此我们需要提供一个函数来检索其值：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unity offers us a couple of very handy functions to detect when the pointer
    of the player enters within an area. Their names are self-explanatory: `OnMouseEnter()`
    and `OnMouseExit()`. In the first function, we will set the flag to `true`, whereas
    in the second we will set the flag to `false`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为我们提供了一些非常实用的函数来检测玩家的指针是否进入了一个区域。它们的名称是自解释的：`OnMouseEnter()`和`OnMouseExit()`。在第一个函数中，我们将标志设置为`true`，而在第二个函数中，我们将标志设置为`false`：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Save the script, and the setup for the allowed areas is ready.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，允许区域的设置就绪。
- en: Scripting the placement script
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写放置脚本
- en: For placing the cupcake towers after having been bought, we need to create another
    script for our cupcake towers. You can rename it `PlacingCupcakeTowerScript`,
    and add it to the **Cupcake Tower Prefabs**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在购买蛋糕塔之后放置蛋糕塔，我们需要为我们的蛋糕塔创建另一个脚本。你可以将其重命名为`PlacingCupcakeTowerScript`，并将其添加到**蛋糕塔预制体**中。
- en: Before modifying it, we need to uncheck the `CupcakeTowerScript` from the prefabs
    of our cupcake towers. In fact, a tower enters in the scene for the first time
    because the player has bought it. While in placing mode, the cupcake tower should
    not shoot. Once placed, the `CupcakeTowerScript` is enabled, and the tower is
    operative again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改它之前，我们需要从我们的蛋糕塔预制体中取消选中`CupcakeTowerScript`。实际上，一座塔第一次进入场景是因为玩家购买了它。在放置模式下，蛋糕塔不应该发射。一旦放置，`CupcakeTowerScript`被启用，塔再次开始运作。
- en: 'Now, we can open the newly-created script. We need to retrieve the `Game Manager`,
    since we will need it to check when the mouse is on an area where cupcake towers
    can be placed. As such, we can write the following code, which is the same we
    used in [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles
    – Navigation in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence*, to retrieve the `Game Manager` for the first time:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开新创建的脚本。我们需要检索`Game Manager`，因为我们需要它来检查鼠标是否位于可以放置蛋糕塔的区域。为此，我们可以编写以下代码，这是我们在[第6章](part0077.xhtml#aid-29DRA1
    "第6章。穿越糖浆之海 – 人工智能导航")中使用的相同代码，*穿越糖浆之海 – 人工智能导航*，以首次检索`Game Manager`：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `Update()` function we are moving the tower to the mouse location (so
    at each frame, the tower will move with the mouse of the player), and if the player
    presses a key, we check if the pointer is actually over an allowed area. If so,
    the tower is placed, which means that the script that moves the tower is destroyed.
    Moreover, the `CupcakeTowerScript` is enabled again, and a collider is placed
    on the cupcake tower. In fact, this additional collider prevents the placing of
    other towers on top of this (and to select the tower in the next section):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数中，我们将塔移动到鼠标位置（因此，在每一帧，塔都会随着玩家的鼠标移动），如果玩家按下键，我们检查指针是否实际上在允许的区域。如果是这样，塔就被放置了，这意味着移动塔的脚本被销毁。此外，`CupcakeTowerScript`再次启用，并在蛋糕塔上放置了一个碰撞器。实际上，这个额外的碰撞器防止了其他塔放在这个塔的上面（以及在下一节中选择塔）：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save the script, and as a result the player is able to place cupcake towers
    once they are bought.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本后，玩家一旦购买，就可以放置蛋糕塔。
- en: Selecting the towers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择塔
- en: If you remember, all the trading operations have a selected tower to deal with.
    In fact, when the player presses the sell button, the game should know which cupcake
    tower the player intends to sell. As such, the player should be able to select
    (and unselect) a tower, and this tower should notify the trading system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，所有的交易操作都有一个选定的塔来处理。实际上，当玩家按下卖出按钮时，游戏应该知道玩家打算卖出哪个蛋糕塔。因此，玩家应该能够选择（并取消选择）一个塔，并且这个塔应该通知交易系统。
- en: 'To achieve this, we need to slightly modify the `CupcakeTowerScript`. From
    the previous section, we know that when the tower is active, it has a collider
    to prevent placing other towers on top of it as well. But, we can also use this
    collider to detect if the player clicks on this very specific tower. In particular,
    we can use the self-explanatory function, `OnMouseDown()` in the following way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要稍微修改一下`CupcakeTowerScript`。从上一节中，我们知道当塔处于活动状态时，它有一个碰撞器来防止其他塔放在它的上面。但是，我们也可以使用这个碰撞器来检测玩家是否点击了这个非常具体的塔。特别是，我们可以用以下方式使用自解释的函数`OnMouseDown()`：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After saving the script, the player is able to select a specific tower among
    the ones he or she has in the game, and sell or upgrade it through the trading
    system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本后，玩家能够选择他在游戏中拥有的特定塔，并通过交易系统进行出售或升级。
- en: The Game Manager
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏管理器
- en: In the previous chapter, we introduced the `GameMangerScript`, but even after
    the second implementation of waypoints, we have left this script empty with no
    use. However, we do indeed need a game manager in our game to handle a couple
    of things. So, in case you have erased it from the last chapter, recreate it,
    along with a game object in the scene with such a script attached (the same way
    as if you erased the reference from the `PandaScript`, because we will need it
    later on).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了`GameMangerScript`，即使在第二次实现航标点之后，我们仍然让这个脚本保持空白，没有任何用途。然而，我们确实需要在我们的游戏中有一个游戏管理器来处理一些事情。所以，如果你在上一个章节中将其删除，请重新创建它，并在场景中创建一个带有此脚本的游戏对象（就像你从`PandaScript`中删除引用一样，因为我们稍后会用到它）。
- en: We will use the `Game Manager` as a hub for exchanging information between the
    player's health and the Pandas. In fact, the `Game Manager` will spawn Pandas
    in the scene divided into waves, and it's the only script to be aware of when
    the level starts and finishes and/or if the player has lost all the health. This
    makes the Game Manager the perfect candidate to handle and trigger the game over
    conditions. Let's start with them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`游戏管理器`作为玩家健康状态和熊猫之间交换信息的中心。实际上，`游戏管理器`会在场景中分波生成熊猫，并且它是唯一在关卡开始和结束以及/或者玩家失去所有健康时需要关注的脚本。这使得游戏管理器成为处理和触发游戏结束条件的理想人选。让我们从这些开始。
- en: Game over conditions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束条件
- en: 'When does our game reach an end? Well, there are two cases: when the player
    loses his/her health, which means the Pandas have eaten all the cake (losing condition),
    or when the player has shot down all the Pandas (winning condition). In either
    case, we need to show to the player the outcome and terminate the game.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏何时结束？嗯，有两种情况：当玩家失去健康，这意味着熊猫吃掉了所有的蛋糕（失败条件），或者当玩家击落所有熊猫（胜利条件）。在任何一种情况下，我们都需要向玩家展示结果并终止游戏。
- en: Game over feedback
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏结束反馈
- en: In our graphic package, there are two screens ready for when the game is over.
    Respectively, these are *Game Over*, used for the losing condition, and *You Win*,
    used for the winning condition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图形包中，有两个屏幕在游戏结束时准备就绪。分别是*游戏结束*，用于失败条件，和*你赢了*，用于胜利条件。
- en: 'Create two UI images, as we learnt in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*, and place the two sprites of our package,
    one for each UI image. You probably want to press the **Set Native Size** button,
    and then scale and move them, so that they are in the middle of the scene, as
    shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个UI图像，正如我们在[第3章](part0043.xhtml#aid-190861 "第3章。与玩家沟通——用户界面")“与玩家沟通——用户界面”中学到的，放置我们包中的两个精灵，每个UI图像一个。你可能想按**设置原生大小**按钮，然后调整大小和位置，使它们位于场景中间，如图所示：
- en: '![Game over feedback](img/image00601.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束反馈](img/image00601.jpeg)'
- en: Now, we can disable them, since they shouldn't be displayed until the game ends.
    However, we need to add a reference to them in the `Game Manager`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以禁用它们，因为它们不应该在游戏结束之前显示。然而，我们需要在`Game Manager`中添加对它们的引用。
- en: 'As such, open the `GameManagerScript` and let''s add these variables:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`GameManagerScript`并添加以下变量：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save the script, and from the **Inspector** assign the UI images we created
    previously, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后在**检查器**中分配我们之前创建的UI图像，如图所示：
- en: '![Game over feedback](img/image00602.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束反馈](img/image00602.jpeg)'
- en: As a result, the `Game Manager` is able to activate one of the two when certain
    conditions are met. Let's see how to implement a function for that in the next
    section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当满足某些条件时，`Game Manager`能够激活其中的一个。让我们在下一节中看看如何实现这个功能的函数。
- en: The GameOver function
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GameOver函数
- en: To keep things ordered within our `GameManagerScript`, let's create a function
    to trigger what happens when the game ends. It will have a Boolean as a parameter
    to determine if the player has won or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`GameManagerScript`中保持条理清晰，让我们创建一个函数来触发游戏结束时发生的事情。它将有一个布尔值作为参数，以确定玩家是否获胜。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, what exactly should happen when the game ends is up to you. You can
    save statistics and the score (if you have any), trigger nice and cool animations,
    display buttons to load next levels, and so on. In this book, we will just display
    the UI images created in the previous section, because the goal is to show you
    where and how to insert code for game over. Feel free to add your own implementation
    to it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，游戏结束时确切会发生什么取决于你。你可以保存统计数据和分数（如果你有的话），触发漂亮酷炫的动画，显示加载下一级的按钮等等。在这本书中，我们只会显示上一节创建的UI图像，因为目标是向你展示在哪里以及如何插入游戏结束的代码。请随意添加你自己的实现。
- en: 'Therefore, let''s write down this function that, based on the parameter, will
    display the right screen to the player. Then, it stops the time of the game to
    create a kind of pause situation in the game. As a result, the game won''t be
    running when the game over screen appears (if any UI is present, it will still
    be possible for the player to press on it):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们写下这个函数，根据参数，将显示正确的屏幕给玩家。然后，它停止游戏的时间，在游戏中创建一种暂停情况。结果，当游戏结束屏幕出现时（如果有UI存在，玩家仍然可以点击它）：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find out more about `timeScale` here in the official documentation
    for Unity: [https://docs.unity3d.com/ScriptReference/Time-timeScale.html](https://docs.unity3d.com/ScriptReference/Time-timeScale.html)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity官方文档中了解更多关于`timeScale`的信息：[https://docs.unity3d.com/ScriptReference/Time-timeScale.html](https://docs.unity3d.com/ScriptReference/Time-timeScale.html)
- en: Save the `GameManagerScript`, and let's explore when to trigger this function
    in the next sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`GameManagerScript`，然后让我们在下一节中探讨何时触发此函数。
- en: Keeping track of the game's progress
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪游戏的进度
- en: 'Keeping track of the game''s progress is one of the fundamental functions of
    a Game Manager. So, the first thing we want to ask is: what should we keep track
    of?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪游戏的进度是游戏管理器的基本功能之一。因此，我们首先想问的是：我们应该跟踪什么？
- en: Definitely not the sugar possessed by the player, since it is separately handled
    within the Sugar Meter and the trading scripts. What about the player's health?
    Well, we do indeed want to keep track of it. In fact, when the player loses his/her
    health, the game ends as well, and the `Game Manager` needs to handle this case.
    What else? The `Game Manager` needs to keep track of how many Pandas the player
    shoots down, because in this way, the game manager is able to determine when the
    player wins.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对不是玩家拥有的糖，因为糖在糖量计和交易脚本中单独处理。那么玩家的健康呢？嗯，我们确实想跟踪它。事实上，当玩家失去健康时，游戏也会结束，`Game Manager`需要处理这种情况。还有什么？`Game
    Manager`需要跟踪玩家击落了多少只大熊猫，因为这样，游戏管理者就能确定玩家何时获胜。
- en: 'Thus, the first thing we need to do is to get a reference to the health of
    the player. We can add the following variable:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要做的是获取玩家的健康引用。我们可以添加以下变量：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can initialize it in the `Start()` function, by adding this line at the
    beginning:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Start()`函数中初始化它，在开始处添加以下行：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we need a variable to keep track of how many Pandas there are still to
    defeat, hence we can add the following variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个变量来跟踪还有多少只大熊猫需要击败，因此我们可以添加以下变量：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It will be initialized by our spawning system, which we will implement soon.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它将由我们的生成系统初始化，我们将很快实现。
- en: Finally, we need to implement a couple of functions, which will be called, respectively,
    when a Panda is shot down, and when the player loses his/her health.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现几个函数，这些函数将在大熊猫被击落和玩家失去健康时分别被调用。
- en: 'For the first, we don''t need any parameters or return values, since the `Game
    Manager` just acknowledges that a Panda has been shot down by decreasing the number
    of Pandas that still need to be defeated:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个功能，我们不需要任何参数或返回值，因为`Game Manager`只需确认一只大熊猫已被击落，通过减少还需要击败的大熊猫数量：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Regarding the second function, we want to create a hub of communication between
    the Panda that is eating the cake and the player''s health. As such, we need to
    implement a function that takes the damage of the Panda as a parameter and subtract
    it from the player''s health. Then, it checks if the player is still alive, because
    if he/she is not, the `GameOver` function is triggered. In either case, at the
    end we need to decrease the number of Pandas still to defeat, because we remember
    that Pandas eat so much cake that they explode:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个功能，我们希望在吃蛋糕的大熊猫和玩家的健康之间建立一个沟通中心。因此，我们需要实现一个函数，该函数接受大熊猫造成的伤害作为参数，并从玩家的健康中扣除。然后，它检查玩家是否仍然存活，因为如果他不/她不存活，就会触发`GameOver`函数。在任何情况下，我们都需要减少还需要击败的大熊猫数量，因为我们记得大熊猫吃了很多蛋糕以至于它们会爆炸：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the script, and open the `PandaScript` since now we need to slightly modify
    it. In particular, we need to call the functions just created in the `Game Manager`.
    From [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles
    – Navigation in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence*, we already have a reference to the `Game Manager`,
    which we can use to trigger these functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并打开`PandaScript`，因为我们现在需要稍微修改它。特别是，我们需要在`Game Manager`中调用刚刚创建的函数。从[第6章](part0077.xhtml#aid-29DRA1
    "第6章。穿过糖雨——人工智能中的导航")，《穿过糖雨——人工智能中的导航》，我们已经有了对`Game Manager`的引用，我们可以用它来触发这些函数。
- en: 'The first modification is to add the following variable to determine how much
    cake this specific Panda can eat when it bites (its value needs to be set in the
    Inspector, don''t forget it!):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修改是添加以下变量以确定这只特定的大熊猫在咬蛋糕时可以吃掉多少蛋糕（其值需要在检查器中设置，别忘了！）：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second modification is in the `FixedUpdate()` function. In fact, we need
    to detract health from the player by using the `BiteTheCake()` function in the
    `Game Manager`. The highlighted part is what we have modified:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个修改是在`FixedUpdate()`函数中。实际上，我们需要使用`Game Manager`中的`BiteTheCake()`函数来减少玩家的健康。下面高亮的部分是我们所做的修改：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The third and last modification is in the `Hit()` function, in which we also
    need to trigger the `OneMorePandaInHeaven()` function of the Game Manager. We
    can do it in the following way (again the highlighted part is what is changed):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个修改是在`Hit()`函数中，我们还需要触发游戏管理器的`OneMorePandaInHeaven()`函数。我们可以这样做（再次，高亮的部分是我们所做的修改）：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save the script, because we are going to explore how the Pandas are created/spawned
    in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，因为我们将在下一节中探索熊猫是如何被创建/生成的。
- en: Panda invasion – spawning Pandas
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熊猫入侵 – 生成熊猫
- en: In this section, we will implement the spawning system of the game. This can
    be done in many ways. However, since we have only one kind of Panda (at least
    for the moment), we will implement it in a simple way. In any case, we will use
    coroutines to implement the system, and we will see a template structure which
    we might also use in more complex spawning systems (in the next chapter, some
    ideas of more complex spawning systems will be provided).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现游戏的生成系统。这可以通过多种方式完成。然而，由于我们只有一种熊猫（至少目前是这样），我们将以简单的方式实现它。无论如何，我们将使用协程来实现系统，并且我们将看到一个模板结构，我们可能在更复杂的生成系统中也会使用（在下一章，将提供一些更复杂生成系统的想法）。
- en: What is a coroutine?
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程是什么？
- en: 'It is a structure that Unity provides to allow functions to be interrupted
    and continued in other frames of the game. In the case of our spawning system,
    we don''t want to spawn all the Pandas at the same time, but a little bit over
    time. This over time can be controlled with coroutines. You can definitely learn
    more and see some examples in the official documentation here: [https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Unity提供的一种结构，允许函数在游戏的其它帧中被中断并继续执行。在我们的生成系统中，我们不想一次性生成所有的大熊猫，而是希望它们在一段时间内逐渐生成。这个“一段时间”可以通过协程来控制。你肯定可以在官方文档中学习更多并查看一些示例：[https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)
- en: 'However, the most important things to know about coroutines are listed here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于协程最重要的几点如下：
- en: They are special functions which have an `IEnumerator` as a return value.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是特殊的函数，返回值是一个`IEnumerator`。
- en: They can be started with the `StartCoroutine()` function and stopped with the
    `StopCourotine()` function.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过`StartCoroutine()`函数启动，并通过`StopCoroutine()`函数停止。
- en: They cannot run/start within any `Update()` function. The reason is because
    the `Update()` function's nature is to be called one time per frame (or more),
    whereas the coroutine's nature is to run at the time they specify.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能在任何`Update()`函数中运行/启动。原因是`Update()`函数的本质是每帧（或更多）被调用一次，而协程的本质是在它们指定的时刻运行。
- en: 'They can use a special instruction; yield: It allows them to wait for something,
    such as a fixed amount of time, the end of the frame, or even another coroutine.
    In any case, after the yield, they expect a return value. Common functions that
    are used with yield are:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用一个特殊的指令；`yield`：它允许它们等待某些事情，比如固定的时间、帧的结束，甚至是另一个协程。无论如何，在`yield`之后，它们期望得到一个返回值。与`yield`一起使用的常见函数有：
- en: '`WaitForEndOfFrame()`: Waits until the next frame (official documentation:
    [https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html](https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html))'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitForEndOfFrame()`: 等待直到下一帧（官方文档：[https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html](https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html))'
- en: '`WaitForSeconds()`: Waits a specific amount of time specified in seconds as
    a parameter (official documentation: [https://docs.unity3d.com/ScriptReference/WaitForSeconds.html](https://docs.unity3d.com/ScriptReference/WaitForSeconds.html))'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitForSeconds()`: 等待指定的时间（以秒为单位）作为参数（官方文档：[https://docs.unity3d.com/ScriptReference/WaitForSeconds.html](https://docs.unity3d.com/ScriptReference/WaitForSeconds.html))'
- en: '`WaitUntil()`: Waits until a certain condition is met (official documentation:
    [https://docs.unity3d.com/ScriptReference/WaitUntil.html](https://docs.unity3d.com/ScriptReference/WaitUntil.html))'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitUntil()`: 等待直到满足某个条件（官方文档：[https://docs.unity3d.com/ScriptReference/WaitUntil.html](https://docs.unity3d.com/ScriptReference/WaitUntil.html))'
- en: 'Moreover, you can even implement custom yield instructions, as shown in the
    official documentation here: [https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html](https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你甚至可以实现自定义的`yield`指令，如官方文档中所示：[https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html](https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html)
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the most curious of you, coroutines are not threads. In fact, coroutines
    run on the same thread as the rest of the game.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最好奇的你们来说，协程并不是线程。实际上，协程是在与游戏其余部分相同的线程上运行的。
- en: It takes time to get used to them, since they are hard to make work when you
    have complex environments, and as such they are often considered as an advanced
    topic. But they unlock many potentialities in what can be done, which is fundamental
    for good gameplay programming. Unfortunately, in this book we don't have enough
    space to dedicate them a proper space, but I hope that with the official documentation,
    this small explanation, and the example of the spawning system in the next section,
    you will be able to better understand coroutines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 适应它们需要时间，因为当你有复杂的环境时，它们很难工作，因此它们通常被认为是一个高级主题。但它们解锁了许多可以做的事情的潜力，这对于良好的游戏编程是基本的。不幸的是，在这本书中，我们没有足够的空间为它们分配适当的空间，但我希望随着官方文档、这个小解释以及下一节中生成系统的示例，你将能够更好地理解协程。
- en: Sketching the idea of how it works
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制其工作原理的想法
- en: We will divide our game into waves. Each wave has a determined number of Pandas,
    which will be spawned over time at an increasing intensity. Once all of the Pandas
    of that wave have been shot down, the game will increase the number of spawned
    Pandas for the next wave and start it. When all the waves are completed by the
    player, the level can be considered as a win.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把游戏分为波浪。每个波浪都有确定数量的Panda，这些Panda将在一段时间内以递增的强度生成。一旦该波浪的所有Panda都被击落，游戏将增加下一波生成的Panda数量并开始它。当玩家完成所有波浪后，该关卡可以被认为是胜利。
- en: In particular, we will have a cycle in a coroutine which will manage the different
    waves and wait till the end of a wave before starting another one. A second routine
    will take care of the single wave, to spawn Pandas for it, and check when all
    the Pandas have been shot down by the player.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将在协程中有一个循环来管理不同的波浪，并在开始另一个波浪之前等待波浪结束。第二个例程将负责单个波浪，为其生成Panda，并检查玩家是否击落了所有Panda。
- en: Setting up the spawning system
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置生成系统
- en: 'Designers should be provided with a way to place where the Pandas will be spawned.
    As such, we can create an empty game object, and call it `SpawningPoint`. Moreover,
    you can attach to it a gizmo, similar to what we have done with waypoints in the
    previous chapter. As a result, it will be visible in the **Scene** view. So, at
    the end you should have something like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师应该有一种方式来放置Panda将被生成的位置。因此，我们可以创建一个空的游戏对象，并称其为`SpawningPoint`。此外，你可以将其附加到一个与上一章中使用的航点类似的gizmo。结果，它将在**场景**视图中可见。所以，最后你应该有如下所示的内容：
- en: '![Setting up the spawning system](img/image00603.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![设置生成系统](img/image00603.jpeg)'
- en: 'Open the `GameManagerScript` and let''s add a variable to keep track of where
    this `SpawningPoint` is. Since we just need the position, we can just take the
    Transform, instead of the whole game object:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`GameManagerScript`并添加一个变量来跟踪这个`SpawningPoint`的位置。由于我们只需要位置，我们可以直接使用Transform，而不是整个游戏对象：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To set its value, let''s change the `Start()` function like the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置其值，让我们像以下这样更改`Start()`函数：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also, we need three more variables. One is for the prefab of the Panda to instantiate
    the right enemy, another is for the number of waves that the player has to face,
    and the last one for the number of Pandas per wave (which will increase between
    waves):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要三个额外的变量。一个是用于Panda预制体实例化正确的敌人，另一个是玩家需要面对的波浪数量，最后一个是为每波Panda的数量（将在波浪之间增加）：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After we have saved the script, we have to assign the variable in the **Inspector**,
    as shown in the following screenshot (feel free to change the values to suit the
    balance of your game):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本后，我们必须在**检查器**中分配变量，如下面的截图所示（请随意更改值以适应你游戏的平衡）：
- en: '![Setting up the spawning system](img/image00604.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![设置生成系统](img/image00604.jpeg)'
- en: Managing waves
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理波浪
- en: In this section, we are going to implement the first of the two coroutines aforementioned.
    In fact, this coroutine will cycle over all the waves, and call the second one
    to handle the single wave. Between waves, the number of spawned enemies is increased.
    If the player has won all the waves, then the `GameOver()` function is called
    in the winning mode.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现上述两个协程中的第一个。实际上，这个协程将遍历所有波浪，并调用第二个来处理单个波浪。在波浪之间，生成的敌人数量会增加。如果玩家赢得了所有波浪，那么在胜利模式下将调用`GameOver()`函数。
- en: 'Thus, open the `GameManagerScript` and we can start to write the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`GameManagerScript`，我们可以开始编写以下代码：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see from the code, we call call the `PandaSpawner()` coroutine, which
    we implement in the next section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中看到的，我们调用了`PandaSpawner()`协程，我们将在下一节中实现它。
- en: The single wave
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个波次
- en: 'Now for the tough part. Here we need to write a coroutine that is able to handle
    a whole wave of Pandas. Therefore, let''s look at it step-by-step, starting with
    creating the coroutine:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是困难的部分。我们需要编写一个能够处理整个Pandas波的协程。因此，让我们一步一步来看，从创建协程开始：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first thing to do is to initialize the `numberOfPandasToDefeat` variable,
    to keep track of how many Pandas the player has defeated so far. Of course, we
    will initialize this number to be the same as the number of Pandas that will be
    spawned in the wave:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是初始化`numberOfPandasToDefeat`变量，以跟踪玩家迄今为止击败了多少Pandas。当然，我们将这个数字初始化为波次中将生成的Pandas数量：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next step is to cycle through all the Pandas to spawn, to progressively
    spawn them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是循环遍历所有待生成的 Pandas，以逐步生成它们：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the cycle, we need to first spawn the Pandas at their spawned position
    (with no rotation, which means having the identity as a **quaternion**). Then,
    we need to wait for a time that depends both on how many Pandas are left and by
    a random number. In particular, we will calculate the ratio of how many Pandas
    are left, and use it to interpolate between two times. As a result, the greater
    the number of Pandas spawned so far, the less time to wait. Then, this is added
    to a random number, to add a bit of chance in our game. Here is the code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们首先需要在生成位置生成Pandas（没有旋转，这意味着具有作为**四元数**的恒等性）。然后，我们需要等待一个时间，这个时间取决于剩余的Pandas数量和一个随机数。具体来说，我们将计算剩余Pandas的数量比率，并使用它来在两个时间之间进行插值。因此，生成的Pandas数量越多，等待的时间就越少。然后，我们将这个时间添加到一个随机数上，以在我们的游戏中增加一些随机性。以下是代码：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, this is not the only way to implement this and the numbers in the
    code are arbitrary. In a real game, everything should be decided in order to balance
    the game, by the hard work of designing and play testing. You can find a bit more
    about this in the next chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是实现它的唯一方法，代码中的数字是任意的。在真正的游戏中，所有东西都应该通过设计和游戏测试的辛勤工作来决定，以平衡游戏。你可以在下一章中找到更多关于这方面的信息。
- en: 'Outside the cycle, instead, we need to wait until all the Pandas have been
    shot down by the player (or some game over conditions have been met) before ending
    the coroutine, and so give back control to the `WavesSpawner()` coroutine for
    the next wave:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之外，相反，我们需要等待所有Pandas都被玩家击落（或者满足某些游戏结束条件）之后，才能结束协程，并将控制权交还给`WavesSpawner()`协程以生成下一波：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save the script, and as a result, the player has to face many, terrible waves
    of sweet-toothed Pandas!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，结果，玩家不得不面对许多可怕、甜食成瘾的Pandas波次！
- en: The main menu
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主菜单
- en: As in many games, there is a main menu when the game starts, and so, also, in
    our game we cannot forget a main menu. This will give us the possibility to explore
    a bit more of what we have touched upon in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*, about changing scenes
    in Unity.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏中，游戏开始时都有一个主菜单，因此，在我们的游戏中，我们也不能忘记主菜单。这将给我们探索更多我们在[第1章](part0016.xhtml#aid-F8901
    "第1章。Unity中的平面世界")中提到的内容的机会，*Unity中的平面世界*，关于在Unity中更改场景。
- en: Designing the main menu
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计主菜单
- en: As we learnt back in [Chapter 3](part0043.xhtml#aid-190861 "Chapter 3. Communicating
    with the Player – the User Interface"), *Communicating with the Player – the User
    Interface*, it's good practice to have a design of the user interface, and the
    main menu is an extension of the user interface. As such, it should be designed
    with the same principles of UI design in mind.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第3章](part0043.xhtml#aid-190861 "第3章。与玩家通信 – 用户界面")中学习的那样，*与玩家通信 – 用户界面*，有一个用户界面设计是很好的实践，而主菜单是用户界面的一部分。因此，它应该按照相同的UI设计原则来设计。
- en: 'The menu for our game is very simple: we have a cool background, and three
    buttons placed just below the center of the screen. They are respectively:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的主菜单非常简单：我们有一个酷炫的背景，屏幕中心下方放置了三个按钮。它们分别是：
- en: '**NEW GAME**: Creates a new game for the player, by loading the level we have
    been creating so far'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新游戏**：为玩家创建一个新游戏，通过加载我们迄今为止创建的水平'
- en: '**SETTINGS**: Triggers a setting screen, where the player can manipulate some
    options (this is left as an exercise, in the *Homework* section)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：触发设置屏幕，玩家可以操作一些选项（这部分留作练习，在*作业*部分）'
- en: '**QUIT**: As the name suggests, it closes the game'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出**：正如其名所示，它将关闭游戏'
- en: 'So, our design will look something like the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的设计看起来可能如下所示：
- en: '![Designing the main menu](img/image00605.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![设计主菜单](img/image00605.jpeg)'
- en: Creating the main menu in another scene
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在另一个场景中创建主菜单
- en: To create another scene in Unity, you can select **File** | **New Scene** from
    the top bar, but it's preferable to navigate in the **Project** panel within the
    `Scene` folder so that by right-clicking you can select **Create |** ** Scene**.
    In this second way, the scene will be directly created within the right folder;
    as a result, your project is ordered and tidy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中创建另一个场景，你可以从顶部菜单栏中选择**文件** | **新建场景**，但最好在`场景`文件夹内的**项目**面板中进行导航，这样通过右键单击，你可以选择**创建
    |** **场景**。通过第二种方式，场景将直接在正确的文件夹中创建；因此，你的项目是有序和整洁的。
- en: You can name the scene `Main Menu`, and then double-click to open it. And here
    from scratch again, there is an empty void to fill up with your creativity and
    fantasies!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将场景命名为`主菜单`，然后双击打开它。然后，从头开始，这里有一个空的空间，你可以用你的创造力和想象力来填充！
- en: 'Now, you should have the skills to do the following without a step-by-step
    explanation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该具备以下技能，而无需逐步解释：
- en: Create a UI image (which will automatically generate a **Canvas** as well as
    the **Event System**), and name it `Background`. Then, extend it to the whole
    screen, and place the cool background you have in mind.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个UI图像（这将自动生成一个**画布**以及**事件系统**），并将其命名为`背景`。然后，将其扩展到整个屏幕，并放置你心中的酷炫背景。
- en: Tweak the canvas settings if you need to achieve what you have in mind.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要达到你心中的效果，请调整画布设置。
- en: Create three buttons, change their graphics if you want, and their texts so
    to match **NEW GAME**, **SETTINGS**, and **QUIT** respectively. Place them, as
    in the design of the previous section.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个按钮，如果你想，可以更改它们的图形和文本，以匹配**新游戏**、**设置**和**退出**。按照上一节的设计放置它们。
- en: Create an empty GameObject where we will attach a script to handle all the different
    interactions.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空的游戏对象中创建脚本，用于处理所有不同的交互。
- en: On the three buttons, add an `OnClick()` event and drag the new empty object
    into the `object` variable
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三个按钮上添加一个`OnClick()`事件，并将新创建的空对象拖动到`object`变量中
- en: Once the menu is created, we can save the scene.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦菜单创建完成，我们就可以保存场景。
- en: Since we have two scenes, if we want to include them in the final version of
    the game, we need to include them in the **Scenes In Build**. To do so, we need
    to open the building settings from the top bar menu by clicking on **File** |** Building
    Settings… **. You can drag and drop the scene in the **Scenes In Build** area
    from your **Project** panel, and they will appear there in a determined order.
    The numbers you see next to the scenes are the identifiers of the scene. For instance,
    we can use this identifier to specify which scene to load.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个场景，如果我们想在游戏的最终版本中包含它们，我们需要将它们包含在**构建中的场景**中。为此，我们需要通过点击顶部菜单栏中的**文件** |**构建设置…**来打开构建设置。你可以从**项目**面板中将场景拖放到**构建中的场景**区域，它们将按照确定的顺序出现在那里。你看到的场景旁边的数字是场景的标识符。例如，我们可以使用这个标识符来指定要加载哪个场景。
- en: 'In our case, be sure that the `Main Menu` scene is before our `Level_01`, as
    shown in the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，确保`主菜单`场景在`Level_01`之前，如图所示：
- en: '![Creating the main menu in another scene](img/image00606.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![在另一个场景中创建主菜单](img/image00606.jpeg)'
- en: Now, it's time to create the script with all the functionalities.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建具有所有功能的脚本了。
- en: Loading scenes through scripts
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过脚本加载场景
- en: Create a new script and call it `MainMenuFunctionalities`. Since its functions
    will be triggered by the `OnClick()` event, we need to make them public.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`MainMenuFunctionalities`。由于它的函数将由`OnClick()`事件触发，我们需要将它们设置为公共的。
- en: 'In particular, we have a function for loading the level of our game. If you
    remember, its ID is `1`. To load a scene in Unity, you use a special class called
    `SceneManager`. As such, we need to import its library by adding the following
    line of code at the beginning of our script:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们有一个用于加载游戏级别的函数。如果你记得，它的ID是`1`。在Unity中加载场景，你使用一个特殊的类，称为`SceneManager`。因此，我们需要通过在脚本开头添加以下代码行来导入其库：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `SceneManager` class along with the `UnityEngine.SceneManagement` library are
    relatively new in Unity. In fact, these allow you to perform many actions on scenes,
    such as loading them together, loading them dynamically, and unloading them, all
    at runtime. This gives you a new universe of possibilities, which I hope you will
    have chance to explore, since in this book we don''t have time to go through everything
    in detail. In any case, a good starting point is, as usual, the official documentation
    that you can find here: [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneManager`类以及`UnityEngine.SceneManagement`库在Unity中相对较新。实际上，这些库允许你在运行时对场景执行许多操作，例如一起加载它们、动态加载它们以及卸载它们。这为你提供了一个全新的可能性世界，我希望你有机会去探索，因为在这本书中我们没有时间详细讲解所有内容。无论如何，通常一个好的起点是官方文档，你可以在以下位置找到它：[https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html)。'
- en: For the more curious of you, before the `SceneManager` class, scenes were handled
    by the `Application` class. So, in case you have some outdated code, which still
    uses the `Application` class to load scenes, you know that it was written for
    previous versions of Unity. If that code belongs to your project, consider (if
    possible, due to legal issues) to update it using the `SceneManager` class.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些好奇心旺盛的人来说，在`SceneManager`类之前，场景是由`Application`类处理的。所以，如果你有一些过时的代码，仍然使用`Application`类来加载场景，你知道它是为Unity的早期版本编写的。如果这些代码属于你的项目，考虑（如果可能，由于法律问题）使用`SceneManager`类来更新它。
- en: The most common function of the `SceneManager` class is `LoadScene()`, which
    can load another scene. One way to specify the scene is with its identifier (as
    we will do in our script), but there are also other ways, such as with a string
    containing the name of the scene.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneManager`类最常用的功能是`LoadScene()`，它可以加载另一个场景。指定场景的一种方式是使用其标识符（正如我们将在脚本中做的那样），但还有其他方式，例如使用包含场景名称的字符串。'
- en: 'We can implement the function that will be called by the **NEW GAME** button
    in the following way, which is really simple and straight forward:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以下这种方式实现将被**新游戏**按钮调用的函数，这非常简单直接：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The function related to the **SETTINGS** button, instead, is left as an exercise
    (see *Homework* section):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相关的**设置**按钮的功能留作练习（见*作业*部分）：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, the function to quit the game uses the `Application` class (more on
    this class in the official documentation here: [https://docs.unity3d.com/ScriptReference/Application.html](https://docs.unity3d.com/ScriptReference/Application.html)),
    where there is a specific function to quit your game:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出游戏的功能使用的是`Application`类（关于这个类的更多信息可以在官方文档中找到：[https://docs.unity3d.com/ScriptReference/Application.html](https://docs.unity3d.com/ScriptReference/Application.html))，其中有一个特定的函数可以退出你的游戏：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that this function doesn't work in some circumstances, such as
    when the game is running in the editor (in Unity itself), or for instance, for
    web-based games. As such, closing a game that should be shipped on different platforms
    might require more work. More about multi-platform games in the next chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个功能在某些情况下可能不起作用，例如当游戏在编辑器中运行（在Unity本身中）时，或者例如对于基于网页的游戏。因此，关闭应该在不同平台上发布的游戏可能需要更多的工作。关于多平台游戏的内容将在下一章中详细介绍。
- en: Save the script, and come back to the `OnClick()` events on the three buttons.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后回到三个按钮的`OnClick()`事件上。
- en: 'Assign the correct function to each of them. Here is the example of how the
    **NEW GAME** button event should look:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个按钮分配正确的功能。以下是如何使**新游戏**按钮事件看起来像的示例：
- en: '![Loading scenes through scripts](img/image00607.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![通过脚本加载场景](img/image00607.jpeg)'
- en: And also, the main menu has been implemented. With this, our game is basically
    completed and functioning. Let's recap what we have done and learnt so far in
    the next section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，主菜单已经实现。有了这个，我们的游戏基本上已经完成并可以运行。让我们在下节回顾一下到目前为止我们所做和学到的内容。
- en: Techniques we learnt in this chapter
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章学到的技术
- en: 'If you have reached this point of the chapter and book, it means that your
    game is completed. Let''s recap what we have learnt in terms of techniques, instead
    of topics:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达了本章和本书的这一部分，这意味着你的游戏已经完成。让我们回顾一下在技术方面的学习内容，而不是主题：
- en: '**Inheritance**: We have implemented our trading system by using inheritance,
    and this gave us the possibility to explore it. In particular, we learnt a bit
    more about:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：我们通过使用继承来实现我们的交易系统，这给了我们探索它的可能性。特别是，我们了解了一些关于以下内容的知识：'
- en: '**Abstract classes and methods**: So that their full implementation is left
    to child classes'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类和方法**：以便它们的完整实现留给子类'
- en: '**Protected variables**: Which can be seen by some scripts but not all of them'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的变量**：某些脚本可以看到，但并非所有脚本都可以看到'
- en: '**UI handlers**: Can be automatically linked to have an interaction with the
    UI without settings events in the **Inspector**'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI处理器**：可以自动链接以与UI进行交互，而无需在**检查器**中设置事件'
- en: '**Interaction between mouse and camera**: To implement the placing script,
    we needed to transform the mouse coordinates into game coordinates.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼠标和相机之间的交互**：为了实现放置脚本，我们需要将鼠标坐标转换为游戏坐标。'
- en: '**Enabling/disabling scripts**: To implement functionalities, always in the
    placing script, we learnt how it is possible to disable and enable scripts to
    trigger functionalities when they are needed.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用/禁用脚本**：为了实现功能，始终在放置脚本中，我们学习了如何禁用和启用脚本以在需要时触发功能。'
- en: '**Storing information**: Within the `Game Manager`, we learnt how other scripts
    can have access to them. Throughout all the chapters we have done this, and in
    different ways. In particular, we used public functions on the `Game Manager`
    that have been called by the other scripts. As a result, the **Game Manager**
    became a hub to exchange data between the different parts of the game.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储信息**：在`游戏管理器`中，我们学习了其他脚本如何访问它们。在整个章节中，我们都这样做，并且以不同的方式。特别是，我们使用了`游戏管理器`上的公共函数，这些函数被其他脚本调用。因此，**游戏管理器**成为交换游戏不同部分数据的中枢。'
- en: '**Using static functions**: To assign generic variables again, in the trading
    system, we have implemented a static function to set the active tower. As a result,
    any script can have access to that function without the need to get a reference
    to the specific trading class instance (moreover the parent class is abstract
    so it doesn''t have instances). This could have been done without many problems,
    because the variable assigned was already static and shared among all the instances
    of the trading classes.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用静态函数**：为了在交易系统中再次分配通用变量，我们实现了一个静态函数来设置活动塔。因此，任何脚本都可以访问该函数，而无需获取特定交易类实例的引用（而且父类是抽象的，所以没有实例）。这本来可以没有太多问题完成，因为分配的变量已经是静态的，并且在所有交易类实例之间共享。'
- en: '**Implementing coroutines**: To handle events that last over timein implementing
    the spawning system, we have used coroutines. These are special functions which
    have the possibility to be interrupted and continue in other frames of the game.
    This is the most powerful tool we have seen in this chapter, although it requires
    a bit more practice than other tools to master it, but it is definitely worth
    it.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现协程**：在实现生成系统时，我们使用了协程。这些是特殊的函数，它们有可能被中断并在游戏的其它帧中继续执行。这是我们在这个章节中看到的最强大的工具，尽管它需要比其他工具更多的实践来掌握，但它绝对值得。'
- en: '**Using UI events**: To implement the functions, in our main menu, we have
    implemented functions within a script to be triggered by the `OnClick()` event
    of the buttons. In this way, you avoid using UI handlers. The advantages of this
    method is that you can place all the functions within a single script and have
    a specific instance of that script to trigger (in case the script can be instantiated).
    On the other hand the disadvantage is that a lot of manual work for linking the
    events in the **Inspector** is required. UI handlers, on the contrary, have advantages
    and disadvantages flipped. As such, UI handlers are suitable for big scripts with
    many functions implemented in that which require a bit of interaction with the
    UI. For small functions, instead, it is better to have them all in a single script
    that creates a different script for each one of them. In any case, the best solution
    depends on the situation and which one is your goal.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用UI事件**：为了实现函数，在我们的主菜单中，我们通过按钮的`OnClick()`事件触发一个脚本中的函数。这样，你可以避免使用UI处理器。这种方法的优势在于你可以将所有函数放在一个单独的脚本中，并有一个特定的脚本实例来触发（如果脚本可以被实例化）。另一方面，缺点是需要在**检查器**中手动链接事件，工作量很大。相反，UI处理器具有相反的优势和劣势。因此，UI处理器适合大型脚本，其中包含许多在脚本中实现的功能，并且需要与UI进行一些交互。对于小型函数，最好将它们全部放在一个单独的脚本中，并为每个函数创建一个不同的脚本。在任何情况下，最好的解决方案取决于具体情况和你的目标。'
- en: '**Using colliders to identify zones**: We used the physics engine to detect
    if the mouse is hovering over certain zones when placing cupcake towers is allowed.
    Moreover, we used a collider on the cupcake towers to detect a click on it (so
    as to be selected) and to avoid placing other cupcake towers on top of others.
    These are just one of the many ways to use the Physics engine for non-physics
    related calculations.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用碰撞器来识别区域**：我们在放置纸杯蛋糕塔时，使用物理引擎检测鼠标是否悬停在允许放置的特定区域上。此外，我们在纸杯蛋糕塔上使用了一个碰撞器来检测点击（以便被选中）并避免在其他纸杯蛋糕塔上放置其他纸杯蛋糕塔。这些都是使用物理引擎进行非物理相关计算的方式之一。'
- en: I hope you have learnt a lot in this chapter, and that you have grasped the
    basic concepts of each of the different techniques we have used. To improve both
    the game and your skills, I invite you do the exercises in the following section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在本章中学到了很多，并且已经掌握了我们使用过的不同技术的每个基本概念。为了提高游戏和你的技能，我邀请你完成以下章节中的练习。
- en: Homework
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'In this chapter, we have covered many techniques on how to exchange information
    between different parts of our game, and learnt a bit about gameplay programming.
    Here there are some exercises to improve your skills and become a better game
    developer:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多如何在游戏的不同部分之间交换信息的技术，并学习了一些关于游戏编程的知识。这里有几个练习来提高你的技能，并成为一名更好的游戏开发者：
- en: '**Sweet capital**: When the the game begins, Pandas start coming and the player
    should buy some cupcake tower to defend his/her cake. But, at the very beginning,
    the player doesn''t have any sugar to buy towers, nor he/she can kill some Pandas
    to get some sugar. Thus, add an initial sugar amount variable in the `Game Manager`
    (so that it can be set from the Inspector), and set this quantity in the `Sugar
    Meter` within the `Start()` function. As a result, the player will be immediately
    ready to fight Pandas.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**甜蜜的资本**：当游戏开始时，熊猫们开始出现，玩家应该购买一些纸杯蛋糕塔来保卫他的/她的蛋糕。但是，在最开始的时候，玩家没有任何糖来购买塔，也不能杀死一些熊猫来获得一些糖。因此，在`游戏管理器`中添加一个初始糖量变量（以便可以从检查器中设置），并在`Start()`函数中将这个数量设置在`糖表`中。结果，玩家将立即准备好与熊猫战斗。'
- en: '**The calm before the storm**: At this stage, when the game starts, the Pandas
    immediately come to eat the player''s delicious cake. However, the player should
    have the time to buy and place some cupcake towers at the beginning, with the
    capital set from the previous exercise. In the `wavesSpawner()` coroutine, set
    a timer before each wave to give the player the time to assess. Then, expose the
    right variables in the **Inspector**, so as to tweak the timer depending on the
    level. Consider, as a variant, that you can increase or decrease such a timer
    between waves.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**暴风雨前的宁静**：在这个阶段，当游戏开始时，熊猫们会立即来吃玩家美味的蛋糕。然而，玩家应该有足够的时间在游戏开始时购买并放置一些纸杯蛋糕塔，资金是从之前的练习中设置的。在`wavesSpawner()`协程中，在每一波之前设置一个计时器，以便玩家有时间进行评估。然后，在**检查器**中暴露正确的变量，以便根据级别调整计时器。作为一个变体，你可以在波之间增加或减少这样的计时器。'
- en: '**Wave bonus (Part I)**: If you are planning to increase the number of Pandas
    spawned significantly between waves, then you should consider rewarding the player
    with some sugar once the wave is completed. Modify the `wavesSpawner()` coroutine
    to include a sweet bonus for the player. Then, expose the right variables in the
    Inspector to tweak the bonus for each level.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波浪奖励（第一部分）**：如果你计划在波浪之间显著增加生成的熊猫数量，那么在波浪完成后，你应该考虑用一些糖果奖励玩家。修改`wavesSpawner()`协程，为玩家添加一个甜蜜的奖励。然后，在检查器中公开正确的变量以调整每个等级的奖励。'
- en: '**Wave bonus (Part II)**: After have done the previous exercise, make an array
    of bonuses, where its dimension changes according to the number of waves. Then,
    at the end of each wave, assign the right bonus to the player, so as to have the
    possibility to tweak the bonus not only for each level, but also for each wave.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波浪奖励（第二部分）**：在完成前面的练习后，制作一个根据波浪数量变化的奖励数组。然后，在每个波浪结束时，为玩家分配正确的奖励，以便能够调整奖励，不仅针对每个等级，而且针对每个波浪。'
- en: '**Singleton pattern (Part I)**: In our game, there are some scripts that should
    have a single instance at the time, such as the `Game manager`, the `Health Bar`,
    or the `Sugar Meter`. As such, it''s best practice to make them unique, since
    some of our scripts rely on the implicit (but not granted) fact that there is
    only one instance of such classes. Therefore, you should implement a pattern called
    **singleton**. You can definitely search on the Internet how to implement it,
    but try to come up with your own personal solution. Many online implementations
    rely on a static variable to retrieve the single instance of the class. Since
    our script will find these classes with the `FindObjectOfType()` function, you
    can try to explore other ways. So, try to give your solution to the problem and
    implement it for the `GameMangerScript`, the `HealthBarScript`, and the `SugarMeterScript`.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单例模式（第一部分）**：在我们的游戏中，有一些脚本应该只有一个实例，例如`游戏管理器`、`生命条`或`糖量计`。因此，最好使它们唯一，因为我们的某些脚本依赖于这样的类只有一个实例的隐含（但未保证）事实。因此，你应该实现一个名为**单例**的模式。你当然可以在互联网上搜索如何实现它，但尽量提出你自己的解决方案。许多在线实现依赖于静态变量来检索类的单个实例。由于我们的脚本将使用`FindObjectOfType()`函数找到这些类，你可以尝试探索其他方法。所以，尝试为这个问题提供你的解决方案，并为`GameMangerScript`、`HealthBarScript`和`SugarMeterScript`实现它。'
- en: '**Singleton pattern (Part II)**: After Part I, you should have implemented
    the singleton pattern in your way. Now, look at the following two links: [http://wiki.unity3d.com/index.php/Singleton](http://wiki.unity3d.com/index.php/Singleton)
    and [https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager](https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager),
    since both implement the singleton pattern. Compare those to the ones you came
    up with, and highlight for each approach, the advantages and the disadvantages.
    Which approach do you think would work better in our game? Does the approach differ
    for the `Game Manager`, the `Health Bar`, or the `Sugar Meter`? Implement the
    singleton pattern you consider worthwhile for our tower defense game.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单例模式（第二部分）**：在第一部分之后，你应该已经以你的方式实现了单例模式。现在，查看以下两个链接：[http://wiki.unity3d.com/index.php/Singleton](http://wiki.unity3d.com/index.php/Singleton)
    和 [https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager](https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager)，因为它们都实现了单例模式。将它们与你提出的进行比较，并为每种方法突出显示其优点和缺点。你认为哪种方法在我们的游戏中会更好？这种方法对于`游戏管理器`、`生命条`或`糖量计`是否有所不同？为我们的塔防游戏实现你认为值得的单例模式。'
- en: '**Improving the allowed areas (Part I)**: We have seen how it is possible to
    use colliders to check if the mouse is hovering over allowed areas, so that the
    placing script knows if it is a suitable place or not when it needs to release
    the cupcake towers. But what happens in the `Game Manager`? Even if there is no
    tower to place, it stills checks for allowed areas and updates its internal state.
    Think about a solution in which the `Game Manager` checks if the mouse is hovering
    over allowed areas only when the placing scripts asks for it. As a result, your
    new solution should improve the performance of the `Game Manager`.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改进允许区域（第一部分）**：我们已经看到如何使用碰撞器来检查鼠标是否悬停在允许的区域上，这样放置脚本就知道在需要释放蛋糕塔时，它是否是一个合适的位置。但在`游戏管理器`中会发生什么呢？即使没有塔需要放置，它仍然会检查允许的区域并更新其内部状态。考虑一个解决方案，其中`游戏管理器`仅在放置脚本请求时检查鼠标是否悬停在允许的区域上。因此，你的新解决方案应该提高`游戏管理器`的性能。'
- en: '**Improving the allowed areas (Part II)**: This exercise is independent from
    part I. In the allowed areas system, we have considered only the mouse. What about
    if you want to export the game on a mobile platform, such as on an Android device?
    In this situation, should the allowed area system be completely redesign or changed?
    As such, design and implement a system which is suitable for as many platforms
    as possible.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改进允许区域（第二部分）**：这项练习与第一部分是独立的。在允许区域系统中，我们只考虑了鼠标。如果你想在移动平台上导出游戏，比如在Android设备上，会怎样呢？在这种情况下，是否应该完全重新设计或更改允许区域系统？因此，设计并实现一个适用于尽可能多平台的系统。'
- en: '**Improving the allowed areas (Part III)**: This exercise is independent from
    Parts I and II. The system of allowed areas we came up with is not really easy
    to use for a multi-level game (something that, most likely, you have), since you
    cannot place colliders in the `Game Manager Prefab` as they depend on the particular
    level. Can you think of an easier solution for level designers to tell the `Game
    Manager` which areas are allowed, level by level? Once you have designed such
    a system, implement it in our tower defense game.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改进允许区域（第三部分）**：这项练习与第一部分和第二部分是独立的。我们提出的允许区域系统对于多级游戏（很可能你就有这样的游戏）来说并不容易使用，因为你不能在`游戏管理器预制件`中放置碰撞器，因为它们依赖于特定的级别。你能想到一个更简单的解决方案，让关卡设计师能够逐级告诉`游戏管理器`哪些区域是允许的吗？一旦你设计了这样的系统，就在我们的塔防游戏中实现它。'
- en: '**Improving the allowed areas (Part IV)**: Consider all the solutions you have
    found for the different problems faced in Parts I, II, and III. Try to merge them
    together into an ultimate solution for the allowed areas. The goal is to create
    a system which is efficient (from a computational point of view), easy-to-use
    (for game and level designers), and multi-platform (so as to deploy the game on
    more than one platform) at the same time.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改进允许区域（第四部分）**：考虑你在第一部分、第二部分和第三部分中找到的所有针对不同问题的解决方案。尝试将它们合并成一个针对允许区域的终极解决方案。目标是创建一个系统，它从计算角度来看是高效的，对于游戏和关卡设计师来说易于使用，并且是多平台的（以便能够在多个平台上部署游戏）。'
- en: '**Feedback to the player (Part I)**: This is a series of exercises all independent
    of each other, and they aim to improve the feedback that the game provides to
    the player, which is of vital importance for a game to be appealing. When the
    player trades, he/she sells, buys, or upgrades towers, but there is no feedback
    that the operation was a success. Therefore, you need to implement some visual
    feedback. Consider the following as smaller exercises:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**玩家反馈（第一部分）**：这是一系列相互独立的练习，目的是提高游戏提供给玩家的反馈，这对于游戏具有吸引力至关重要。当玩家进行交易时，他/她出售、购买或升级塔，但没有反馈表明操作成功。因此，你需要实现一些视觉反馈。以下是一些更小的练习：'
- en: When sugar is detracted or added to the `Sugar Meter`, add an animation so that
    a big number appears on the `Sugar Meter` showing the quantity that changed. Moreover,
    consider changing the color of this number based on the amount, and whether it
    is added or subtracted.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`糖度计`中减去或添加糖分时，添加一个动画，以便在`糖度计`上显示一个大的数字，显示变化的数量。此外，考虑根据数量以及是添加还是减去来改变这个数字的颜色。
- en: When the sugar is detracted or added to the `Sugar Meter`, add an animation
    to show the numbers of the `Sugar Meter` changing, instead of suddenly changing
    the number displayed.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当糖分从`糖度计`中减去或添加时，添加一个动画来显示`糖度计`上的数字变化，而不是突然改变显示的数字。
- en: When a tower is upgraded, consider placing an animation that plays on the tower.
    Same for when the tower is sold or placed (after have bought it).
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当塔升级时，考虑在塔上播放一个动画。同样，当塔被出售或放置（在购买后）时也是如此。
- en: '**Feedback to the player (Part II)**: This is a series of exercises all independent
    of each other, and they aim to improve the feedback that the game provides to
    the player, which is of vital importance for a game to be appealing.When the player
    trades, he/she sells, buys, or upgrades towers, but there is no feedback about
    what the operations are going to do/change, such as: which one is the price of
    buying a tower? Therefore, you need to implement some visual feedback. Consider
    the following as smaller exercises:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**玩家反馈（第二部分）**：这是一系列相互独立的练习，目的是提高游戏提供给玩家的反馈，这对于游戏吸引玩家至关重要。当玩家进行交易时，他/她出售、购买或升级塔，但没有关于这些操作将做什么/改变什么的信息，例如：购买一个塔的价格是多少？因此，你需要实现一些视觉反馈。以下是一些较小的练习：'
- en: When the player hovers over one of the trading buttons, make the price (or the
    value in case of the selling button) appear somewhere (which needs to be decided
    carefully, since it impacts the design we did in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*), so the player can read it before, to perform
    the action.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家悬停在交易按钮之一上时，将价格（或出售按钮的情况下的价值）显示在某个地方（需要仔细决定，因为它会影响我们在[第3章](part0043.xhtml#aid-190861
    "第3章。与玩家沟通——用户界面")中做的设计），这样玩家在执行操作之前可以阅读它。
- en: When no tower is selected, both the selling and the upgrading buttons shouldn't
    be displayed as active. Change this, to display a disable button when the `currentActiveTower`
    variable is null.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有选择任何塔时，销售和升级按钮都不应该显示为激活状态。将其更改为，当`currentActiveTower`变量为null时，显示一个禁用按钮。
- en: '**Implementing a setting menu (Part I)**: In this chapter, we left this as
    an exercise, so let''s see what we need to do. The first thing to decide is what
    settings the player can change and how (a toggle? A slider? A drop-down menu?).
    In particular, you should have at least an audio toggle, and a quality settings
    drop-down menu, plus any options you would like to include. Then, make a complete
    design of the UI. Finally, in Unity create a new scene (or screen, whichever you
    prefer) and implement the settings screen by using UI elements.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现设置菜单（第一部分）**：在这一章中，我们将这留作练习，所以让我们看看我们需要做什么。首先，要决定玩家可以更改哪些设置以及如何更改（切换？滑块？下拉菜单？）。特别是，你应该至少有一个音频切换和一个质量设置下拉菜单，以及你想要包含的任何选项。然后，完成UI的完整设计。最后，在Unity中创建一个新的场景（或屏幕，根据你的喜好），通过使用UI元素实现设置屏幕。'
- en: '**Implementing a setting menu (Part II)**: In Part I, we did the design and
    implemented it within Unity. Now, we need to implement the functionalities (except
    the audio for now, which is left for the next chapter). So, create a script, and
    similar to what we did with the main menu, implement all the functionalities there,
    and link them to the UI elements through the use of events in the **Inspector**.
    To modify the quality settings and the audio settings, search the official documentation
    on how to do it (this is part of the exercise). Moreover, keep in mind that the
    next chapter might give you some other ideas of the kind of settings to implement.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现设置菜单（第二部分）**：在第一部分中，我们进行了设计和在Unity中实现了它。现在，我们需要实现功能（目前不包括音频，留到下一章），所以创建一个脚本，类似于我们在主菜单中做的，在那里实现所有功能，并通过使用**检查器**中的事件将它们链接到UI元素。要修改质量设置和音频设置，搜索官方文档了解如何操作（这是练习的一部分）。此外，请记住，下一章可能会给你一些其他实现设置类型的思想。'
- en: '**Magic numbers (Part I)**: We already have encountered magic numbers in the
    previous chapters. They are numbers that appear within a script and without an
    explanation, and good practice says that it is better to avoid them as much as
    possible. Also in this chapter, we have left many of them; let''s try to remove
    them. The first magic number is the number *7* from the placing script when we
    create a new vector for the position of our tower. This number depends on the
    position of the camera and where the tower should be placed along the *z*-axis.
    As such, add some lines of code to calculate this number in a dynamic way (so
    if we decide to change the camera position or the *z*-depth of the towers, we
    can do it without changing the script, as a bonus, you will have the possibility
    of also having different kinds of towers on different z-depth layers, which can
    be useful to you in the same way). In particular, you need to subtract the *z*-axis
    of the tower from the *z*-axis of the camera.'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**魔法数字（第一部分）**：我们在前面的章节中已经遇到了魔法数字。它们是在脚本中出现的没有解释的数字，良好的实践是尽可能避免它们。在本章中，我们也留下了许多这样的数字；让我们尝试去除它们。第一个魔法数字是在创建我们塔的位置的新向量时放置脚本中的数字*7*。这个数字取决于摄像机的位置以及塔应该在*z*轴上的位置。因此，添加一些代码来以动态方式计算这个数字（这样如果我们决定改变摄像机的位置或塔的*z*深度，我们可以在不改变脚本的情况下做到这一点，作为额外的奖励，你还将有机会在不同的*z*深度层上有不同类型的塔，这对你来说可能同样有用）。特别是，你需要从塔的*z*轴减去摄像机的*z*轴。'
- en: '**Magic numbers (Part II)** : We have also left some magic numbers in the `Upgrade()`
    function of the `CupcakeTowerScript`. Create variables that can be set in the
    **Inspector**, to remove any magic numbers that are left (such as increasing the
    selling value or the upgrade cost).'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**魔法数字（第二部分）**：在`CupcakeTowerScript`的`Upgrade()`函数中，我们也留下了一些魔法数字。创建可以在**检查器**中设置的变量，以去除任何剩余的魔法数字（例如增加销售价值或升级成本）。'
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored many techniques to exchange information and
    data between different scripts. In doing so, we have finished the implementation
    of our tower defense game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在脚本之间交换信息和数据的技术。通过这样做，我们完成了我们的塔防游戏的实现。
- en: The Pandas walk towards the player's cake to eat it, the cupcake towers shoot
    at them, and so Pandas die and they are periodically spawned as well. The player
    can buy, sell, and upgrade cupcake towers. A main menu is present and the player
    can either win or lose. So, our game is complete. Or is it not? Can we go even
    further? Let's find it out in the next chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 熊猫走向玩家的蛋糕去吃它，纸杯塔向它们射击，因此熊猫死亡，它们也会定期生成。玩家可以购买、出售和升级纸杯塔。有一个主菜单，玩家可以赢或输。所以，我们的游戏完成了。是吗？我们能更进一步吗？让我们在下一章中找出答案。
