<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Xamarin.Forms</h1></div></div></div><p>Xamarin.Forms is <a class="indexterm" id="id474"/>an extension module to Xamarin compiler technologies; an abstraction layer on top of the native UI components on target platforms. This chapter will focus on the various features and extensibility options of Xamarin.Forms that help developers create cross-platform application user interfaces that can then be compiled into Xamarin projects, increasing the code-sharing quality markers, and making cross-platform application development projects more manageable and unified. This chapter is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Under the hood</li><li class="listitem" style="list-style-type: disc">Components</li><li class="listitem" style="list-style-type: disc">Extending forms</li><li class="listitem" style="list-style-type: disc">Patterns and best practices</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Under the hood</h1></div></div></div><p>As <a class="indexterm" id="id475"/>previously mentioned, Xamarin, being a cross-platform development framework, provides developers the toolset to create applications that depend on and use the same code base. The shared amount of code is directly proportional to the manageability in these types of implementation.</p><p>Xamarin.Forms adds an abstraction layer on top of the mono runtime on Android and the pre-compiler .NET stack on iOS platforms. This abstraction layer's sole responsibility is to<a class="indexterm" id="id476"/> provide the Xamarin compilers with the necessary instructions to normalize the code or markup for GUI elements to render native controls in Xamarin apps. Since the platform language for Xamarin is C#, <strong>Extensible Application Markup Language</strong> (<strong>XAML</strong>) is the design markup language of choice. Xamarin.Forms provides the same abstraction as a runtime library for Windows Store applications.</p><p>The abstraction layer provided by Xamarin.Forms makes use of the similar UI elements and layout patterns which were illustrated in the previous chapter (see <a class="link" href="ch07.html" title="Chapter 7. View Elements">Chapter 7</a>, <em>View Elements</em>). In this context, Xamarin.Forms only provides controls and views that are common to all three platforms and omits platform-specific UI elements. It is important to understand that Xamarin.Forms is not a replacement for a native user interface implementation, but<a class="indexterm" id="id477"/> more of a foundation to build upon while creating cross-platform applications.</p><div><img alt="Under the hood" src="img/B04693_08_01.jpg"/><div><p>Figure 1: Xamarin.Forms abstraction layer</p></div></div><p>Xamarin.Forms not only provides a uniform native UI development framework, but also additional features that are generally associated with loosely-coupled UI development, such as data binding, dependency injection, and messenger infrastructure. To a certain extent, these features render third-party MVVM libraries used in various mobile application projects obsolete.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Anatomy of Xamarin.Forms</h2></div></div></div><p>Xamarin.Forms libraries<a class="indexterm" id="id478"/> are distributed through NuGet packages and can be freely included in cross-platform development projects.</p><p>Whilst the NuGet package for iOS does not present any dependencies, the Android and Windows Phone versions depend on several support libraries (that is, WPToolKit for Windows Phone; and several design and compatibility packages for Android).</p><p>The Xamarin.Forms.Core library contains the UI elements and the necessary XAML declarations together with additional features related to data binding and similar operations. This assembly can be included in portable class library projects that provide the view implementation to platform-specific projects. Native client projects, in return, should reference Xamarin.Forms.Core and the platform-specific assemblies of Xamarin.Forms (for example, Xamarin.Forms.Platform.iOS). Xamarin.Forms platform libraries contain the so-called<a class="indexterm" id="id479"/> renderer implementations that are responsible for rendering Xamarin.Form elements using native controls. In other words, these platform assemblies provide the mapping between native elements and their Xamarin. Forms counterparts.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Project structure</h2></div></div></div><p>In order<a class="indexterm" id="id480"/> to create a Xamarin.Forms application project targeting iOS, Android, and/or Windows Phone 8, it is sufficient to use one of the project templates located in the <strong>Cross-Platform</strong> section. While the portable library project template makes use of a PCL to create the Xamarin.Forms application boilerplate, the shared project template creates a shared project with file references linked to the native client app projects.</p><div><img alt="Project structure" src="img/B04693_08_02.jpg"/><div><p>Figure 2: Xamarin.Forms project templates</p></div></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Project templates can be found in the <strong>Mobile Apps</strong> section in older versions of Xamarin.</p></div></div><p>Once <a class="indexterm" id="id481"/>the project is initialized, by selecting the <strong>Blank App (Xamarin.Forms Portable)</strong> project template, the created solution will include four projects, one project carrying the same name as the entered project name and three platform-specific projects with the platform suffixes.</p><div><img alt="Project structure" src="img/B04693_08_03.jpg"/><div><p>Figure 3: Xamarin.Forms solution main view and project scopes</p></div></div><p>One caveat of using this project template for Xamarin.Forms is the fact that other platforms that are actually supported by this framework (for example, Windows Phone 8.1 and Windows 10) are not included in this multi-project template. These projects can be created manually, and the NuGet package for Xamarin.Forms can be added using the NuGet package manager. It is also important to mention that the NuGet package referenced in the project template might not be the latest version of Xamarin.Forms and therefore can be updated using the NuGet package manager.</p><div><img alt="Project structure" src="img/B04693_08_04.jpg"/><div><p>Figure 4: The latest NuGet package for Xamarin.Forms</p></div></div><p>If you <a class="indexterm" id="id482"/>take a look at the generated code in the portable library, <code class="literal">App.cs</code>, and the platform-specific projects, the implementation pattern immediately becomes apparent.</p><p>The Xamarin.Forms implementation contains the application class implementation as the root node. This application is initialized and invoked by the generated code in the app delegates in platform-specific projects (similar to the following code excerpt from the Xamarin.Forms iOS application sample):</p><div><pre class="programlisting">[Register("AppDelegate")]
public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate
{
    public override bool FinishedLaunching(UIApplication app, NSDictionary options)
    {
        global::Xamarin.Forms.Forms.Init();
        LoadApplication(new App());

        return base.FinishedLaunching(app, options);
    }
}</pre></div><p>The initialization code for the app in the template boilerplate creates a content page with a single <a class="indexterm" id="id483"/>label in a <code class="literal">StackLayout</code> element and designates this view as the main page:</p><div><pre class="programlisting">public App()
{
    // The root page of your application
    MainPage = new ContentPage
    {
        Content = new StackLayout
        {
            VerticalOptions = LayoutOptions.Center,
            Children = {
                new Label {
                    XAlign = TextAlignment.Center,
                    Text = "Welcome to Xamarin Forms!"
                }
            }
        }
    };
}</pre></div><p>As you can see, the Xamarin.Forms application structure is made up of controls wrapped in different layout configurations that are presented through various page types.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Components</h1></div></div></div><p>Xamarin.Forms components can be categorized into three main groups according to their position<a class="indexterm" id="id484"/> in the view hierarchy and their usage.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Pages</h2></div></div></div><p>Conceptually, pages are<a class="indexterm" id="id485"/> navigational elements. They provide a general hierarchical organization of the view elements whilst also acting as a container for the layouts. There are various page types that can be inherited and implemented or designed using XAML markups.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec31"/>Tabbed page</h3></div></div></div><p>When<a class="indexterm" id="id486"/> discussing the top-level navigation pages in the previous chapter, we mentioned several controls that can provide horizontal navigation throughout top-level pages. Using Xamarin.Forms, <code class="literal">TabbedPage</code> allows developers to create these horizontal navigational view elements. <code class="literal">TabbedPage</code> generates a tabbed action bar and associated activities on Android. On Windows Phone, the generated view contains a pivot control. Finally on iOS, generated view contains a tab bar and associated views.</p><p><code class="literal">TabbedPage</code> contains <a class="indexterm" id="id487"/>the navigation pages as its children (that is, the <code class="literal">Children</code> property accepts different page implementations), and the page titles of the child elements are used as navigation links.</p><p>Implementing the tabbed view example from the previous chapter for our TravelTrace application would look similar to the following snippet:</p><div><pre class="programlisting">var tabbedPage = new TabbedPage();

tabbedPage.Children.Add(new ContentPage
{
    Title = "Recent",
    Content = new StackLayout
    {
        VerticalOptions = LayoutOptions.Center,
        Children = {
            new Label {
                HorizontalTextAlignment = TextAlignment.Center,
                Text = "Recent uploads page"
            }
        }
    }
});

// ...
// TODO: Add the other tab nav items

MainPage = tabbedPage;</pre></div><p>The same implementation can be done using XAML and creating a <code class="literal">TabbedPage</code> implementation:</p><div><pre class="programlisting">&lt;TabbedPage 
  
  x:Class="Xamarin.Master.TravelTrace.Views.MainTabView"&gt;
  &lt;ContentPage Title="Recent" Icon="social.png"&gt;
    &lt;StackLayout VerticalOptions="Center"&gt;
      &lt;Label Text="Recent uploads page" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
  &lt;ContentPage Title="Local" Icon="map.png"&gt;
    &lt;StackLayout VerticalOptions="Center"&gt;
      &lt;Label Text="Local landmarks page" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
  &lt;ContentPage Title="Friends" Icon="people.png"&gt;
    &lt;StackLayout VerticalOptions="Center"&gt;
      &lt;Label Text="Friends related page" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
&lt;/TabbedPage&gt;</pre></div><p>Assigning the <a class="indexterm" id="id488"/>newly created <code class="literal">MainTabView</code> class instance to <code class="literal">MainPage</code> in <code class="literal">App.cs</code> would result in the same view as the code implementation:</p><div><img alt="Tabbed page" src="img/B04693_08_05.jpg"/><div><p>Figure 5: TabbedPage view</p></div></div><p>It is important here to mention that the <code class="literal">Icon</code> property provided for individual peers in a <code class="literal">TabbedPage</code> implementation only applies to the iOS platform. Icons in tab and pivot views are not supported by Xamarin and it is not an accepted design approach for Android and Windows <a class="indexterm" id="id489"/>Phone.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec32"/>The MasterDetail page</h3></div></div></div><p>The <a class="indexterm" id="id490"/>example with the tabbed view satisfies the horizontal navigation requirements of our design, but we also need a navigation drawer and associated main menu navigation items for our Android applications.</p><p><code class="literal">MasterDetailPage</code> provides a structure in which the master page selection menu can initiate a navigation request on the detail page. Moreover, if the content of the <code class="literal">Detail</code> page is encapsulated in a <code class="literal">NavigationPage</code>, the generated view is added to the navigation stack so that the previously displayed pages can easily be pulled into the master view using the event methods. In order to include an additional layer of navigation and a global menu, we can now use the <code class="literal">MasterDetailPage</code> class to create the desired navigation structure.</p><p>The first step of the implementation is to create our master view. The master view in this case will include a simple list view with menu and a profile display as the list header. When the list view content items are selected, we can either bubble up the event to the <code class="literal">MasterDetailPage</code> or pass the parent page as a parameter to the menu page we are implementing.</p><div><pre class="programlisting">public NavigationMenuView(Page root)
{
    Icon = "toggle.png";

    InitializeComponent();

    ListViewMenu.ItemsSource = m_MenuItems = new List&lt;Tuple&lt;string, string, string&gt;
    {
        new Tuple&lt;string, string, string&gt;("Profile", "profile", "profileicon.png"),
        new Tuple&lt;string, string, string&gt;("Map", "map", "mapicon.png"),
        new Tuple&lt;string, string, string&gt;("Settings", "settings", "settingsicon.png")
    };

    ListViewMenu.SelectedItem = m_MenuItems[0];

    ListViewMenu.ItemSelected += async (sender, e) =&gt; 
    {
        if(ListViewMenu.SelectedItem == null)
            return;

        // TODO: Implement the navigation strategy 
        Debug.WriteLine("Item selected {0}", 
          ((Tuple&lt;string, string, string&gt;)e.SelectedItem).Item2);
    };
}</pre></div><p>In this <a class="indexterm" id="id491"/>implementation, we are using a <code class="literal">Tuple</code> with three parameters for the label, tag, and icon of the menu item. It would, of course, be better to implement a class to contain these data values.</p><p>Now we can construct our <code class="literal">MasterDetailPage</code> by setting the <code class="literal">Master</code> and <code class="literal">Detail</code> properties:</p><div><pre class="programlisting">var masterDetailPage = new MasterDetailPage();

// Can select any of the behaviors: 
// Default, Popover, Split, SplitOnLandscape, SplitOnPortrait
masterDetailPage.MasterBehavior = MasterBehavior.Popover;
masterDetailPage.Master = new NavigationMenuView(masterDetailPage);
masterDetailPage.Detail = new NavigationPage(new ContentPage
{
    Title = "Detail Page",
    Content = new StackLayout
    {
        VerticalOptions = LayoutOptions.Center,
        Children = {
            new Label {
                HorizontalTextAlignment = TextAlignment.Center,
                Text = "Here is the Detail"
            }
        }
    }
});

MainPage = masterDetailPage;</pre></div><p><code class="literal">MasterBehavior</code> can be adjusted according to the platform. In this example, we will be using the popover behavior, which displays a flyout and a toggle button in the main app bar on Android and creates a navigation command icon to open the flyout on other platforms.</p><div><img alt="The MasterDetail page" src="img/B04693_08_06.jpg"/><div><p>Figure 6: Navigation flyout on Android and Windows Phone</p></div></div><p>When<a class="indexterm" id="id492"/> using <code class="literal">MasterDetailPage</code>, it is important to anticipate the outcome of the design decisions made in Xamarin.Forms markups so that final applications for the target platforms still follow the design guidelines.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec33"/>NavigationPage</h3></div></div></div><p><code class="literal">NavigationPage</code> is the most abstract implementation of the <code class="literal">Page</code> class. The main purpose <a class="indexterm" id="id493"/>of using NavigationPage is to create a navigational stack in the application context. This navigational context is supported natively on Windows Phone. However, other platforms do not create a stack for previously viewed pages. Using <code class="literal">NavigationPage</code>, one can utilize the items in the navigational history and manipulate the stack using push and pop methods.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec34"/>CarouselPage</h3></div></div></div><p><code class="literal">CarouselPage</code> is<a class="indexterm" id="id494"/> another horizontal navigation implementation that the user can use to navigate through the peer pages using swipe or flick gestures. <code class="literal">CarouselPage</code> is very similar to the panorama view and pivot controls from the Windows Phone 7 platform, except for the fact that <code class="literal">CarouselPage</code> has strict snap points (that is, when the free scrolling view snaps to the borders of a control or a page) and it does not have an endless loop of items, in contrast with pivot control, but instead has more linear navigation. Behaviorally, it resembles and uses a similar navigation <a class="indexterm" id="id495"/>strategy as the <code class="literal">FlipView</code> control from Windows Runtime.</p><p>In order to initiate a carousel-type navigation structure, either XAML or code-behind can be used. A simple carousel view with three content page implementations would look as follows:</p><div><pre class="programlisting">&lt;CarouselPage 
  
  x:Class="Xamarin.Master.TravelTrace.Views.GuidesView"&gt;
  &lt;ContentPage Title="First Peer"&gt;
    &lt;StackLayout  HeightRequest="50" VerticalOptions="Center" BackgroundColor="Silver"&gt;
      &lt;Label Text="Content for the First Peer" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
  &lt;ContentPage Title="Second Per"&gt;
    &lt;StackLayout HeightRequest="50" VerticalOptions="Center" BackgroundColor="Gray"&gt;
      &lt;Label Text="Content for the Second Peer" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
  &lt;ContentPage Title="Third Peer"&gt;
    &lt;StackLayout HeightRequest="50" VerticalOptions="Center" BackgroundColor="Silver"&gt;
      &lt;Label Text="Content for the Third Peer" HorizontalTextAlignment="Center"&gt;&lt;/Label&gt;
    &lt;/StackLayout&gt;
  &lt;/ContentPage&gt;
&lt;/CarouselPage&gt;</pre></div><p>The resulting view would be a container for touch-initiated horizontal navigation between peers.</p><div><img alt="CarouselPage" src="img/B04693_08_07.jpg"/><div><p>Figure 7: Carousel view</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec35"/>ContentPage</h3></div></div></div><p><code class="literal">ContentPage</code> is<a class="indexterm" id="id496"/> a simple page implementation used generally in cooperation with previously described page structures. It can be described as the actual content presenter. Child views in other navigation implementations are generally made up of <code class="literal">ContentPage</code> implementations.</p><p>In order to set the content to be visualized on the user interface, you can use the <code class="literal">Content</code> property, which accepts a list of view objects. Layout elements are generally used as the direct children of <code class="literal">ContentPage</code> and other user controls are appended to this visual tree.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Layouts</h2></div></div></div><p>Layouts<a class="indexterm" id="id497"/> are structural design elements that allow developers to organize the UI controls using various strategies. We can classify layouts into two groups according to their class inheritance hierarchy: single view and multiple view.</p><div><img alt="Layouts" src="img/B04693_08_08.jpg"/><div><p>Figure 8: Layout classes</p></div></div><p>Single view<a class="indexterm" id="id498"/> layouts are direct descendants of the base layout implementation and they are capable of displaying only a single view item (they can also be a branch of a visual tree). Examples of this category are <code class="literal">ContentView</code>, <code class="literal">Frame</code>, and <code class="literal">ScrollView</code>. <code class="literal">ContentView</code> and <code class="literal">Frame</code> elements are rarely used and can be helpful while dealing with fewer content elements and/or an application with an active screen pattern (for example, a drawing application would use a single canvas implementation with absolute positioning; drawn geometry items would be the children of the canvas).</p><p><code class="literal">ScrollView</code>, on the other hand, is one of the most popular controls and can be used together with another layout element, such as <code class="literal">StackLayout</code>. When used with <code class="literal">StackLayout</code>, if the calculated height of <code class="literal">StackLayout</code> is greater than the client area, the parent control, <code class="literal">ScrollView</code>, makes it possible to change the viewport of the child control. Even though it is not very common, <code class="literal">ScrollView</code> can still be used with simple controls such as <code class="literal">Label</code> or <code class="literal">Image</code>.</p><p>For instance, if we were to implement the primary content of the <code class="literal">TabbedPage</code> created in the previous section, we can use a <code class="literal">ScrollView</code> to display the <code class="literal">StackLayout</code> that is displaying the recently uploaded items from the TravelTrace server. The markup for this implementation would look similar to the following snippet:</p><div><pre class="programlisting">  &lt;ScrollView&gt;
    &lt;StackLayout x:Name="StackLayout"&gt;
      &lt;Grid Padding="10" ColumnSpacing="4"&gt;…&lt;/Grid&gt;
      &lt;Grid Padding="10" ColumnSpacing="4"&gt;…&lt;/Grid&gt;
      &lt;!-- Omitted for clarity --&gt;
    &lt;/StackLayout&gt;
  &lt;/ScrollView&gt;</pre></div><p>It would be displayed almost like a scrolling <code class="literal">ListView</code>:.</p><div><img alt="Layouts" src="img/B04693_08_09.jpg"/><div><p>Figure 9: ScrollView visualizations</p></div></div><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Under normal circumstances, when dealing with a long list of data items, <code class="literal">ListView</code> should be the main control to be used. This implementation is only for demonstration purposes.</p></div></div><p>The <a class="indexterm" id="id499"/>multi-page layouts category consists of <code class="literal">AbsoluteLayout</code>, <code class="literal">Grid</code>, <code class="literal">RelativeLayout</code>, and, as seen in the previous example, <code class="literal">StackLayout</code>. Each layout is used for a specific scenario for various design-related requirements.</p><p><code class="literal">Grid</code>, similar to the <code class="literal">Grid</code> in Windows Presentation Foundation, is used to organize child elements in a grid structure. The initial step of creating a grid is to define <code class="literal">ColumnDefinitions</code> and <code class="literal">RowDefinitions</code>, which describe the cells that are going to be used to render the elements. After this step, view elements can be added to the grid using the attached properties of <code class="literal">Grid</code>, such as <code class="literal">Grid.Row</code>, <code class="literal">Grid.Column</code>, <code class="literal">Grid.RowSpan</code>, and <code class="literal">Grid.ColumnSpan</code>.</p><p>Using the<a class="indexterm" id="id500"/> example cells from the previous implementation, we could have a classic cell view with two lines of text and an image on the right-most section of the cell:</p><div><pre class="programlisting">&lt;Grid Padding="10" ColumnSpacing="4"&gt;
  &lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto" /&gt;
    &lt;RowDefinition Height="40" /&gt;
  &lt;/Grid.RowDefinitions&gt;
  &lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition Width="*" /&gt;
    &lt;ColumnDefinition Width="60" /&gt;
  &lt;/Grid.ColumnDefinitions&gt;
  &lt;Image Grid.RowSpan="2" Grid.Column="1" Source="mapicon.png" HeightRequest="40" WidthRequest="40"/&gt;
  &lt;Label Grid.Row="0" Grid.Column="0" Text="Item Title" FontSize="16"/&gt;
  &lt;Label Grid.Row="1" Grid.Column="0" Text="{Binding LongTextPlaceholder}" FontSize="14" /&gt;
&lt;/Grid&gt;</pre></div><p><code class="literal">AbsoluteLayout</code> provides a rendering mechanism in which the child elements are organized in floating rectangles. Placement geometry (that is, the <code class="literal">LayoutBounds</code> property) defines the X and Y coordinates of the element and the size of the bounding rectangle. The <code class="literal">LayoutBounds</code> property can accept device units or proportional units. The notion used for proportional units is similar to the "%" system used in HTML layouts. These values have to be in the range of 0-1 to designate an element on the screen area. The <code class="literal">AbsoluteLayoutFlags</code> enumeration can be used to define the bounding rectangle values that follow the proportional unit system or otherwise (for example, <code class="literal">PositionProportional</code>, <code class="literal">HeightProportional</code>, <code class="literal">SizeProportional</code>, or <code class="literal">All</code>).</p><p><code class="literal">RelativeLayout</code> is conceptually similar to relative layouts on the Android and Windows 10 platforms. It also uses a similar constraint mechanism as iOS auto-layout implementation. In a relative layout, elements can be positioned in a bounding rectangle similar to an absolute layout. However, values for this bounding rectangle are defined in reference to the parent element (<code class="literal">RelativeToParent</code>) or another control in the visual tree (<code class="literal">RelativeToView</code>). Developers are also allowed to use constant values without referencing another control.</p><p>In relative layouts, if the arrangement is being created in code-behind, constraints are defined using a lambda expression or anonymous functions. For instance, in order to add an image element to the center of the page of size (100,100), we would use the <code class="literal">RelativeToParent</code> constraint:</p><div><pre class="programlisting">relativeLayout.Children.Add(image,
    Constraint.RelativeToParent(parent =&gt; parent.Width/2 - 50),
    Constraint.RelativeToParent(parent =&gt; parent.Height/2 - 50),
    Constraint.Constant(100), Constraint.Constant(100));</pre></div><p>If we <a class="indexterm" id="id501"/>were to insert a label 10 units underneath the image in the center, it would look as follows:</p><div><pre class="programlisting">relativeLayout.Children.Add(label,
    Constraint.RelativeToParent(parent =&gt; parent.Width/2 - 100),
    Constraint.RelativeToView(image, (parent, view) =&gt;
    {
        // Here view is referring to the other relative control
        return view.Y + view.Height + 10;
    }),
    Constraint.Constant(200),
    Constraint.Constant(100));</pre></div><p>The outcome would be as follows:</p><div><img alt="Layouts" src="img/B04693_08_10.jpg"/><div><p>Figure 10: Relative layouts</p></div></div><p>A similar implementation using the markup extensions in XAML can be employed. Even though the constraint expression options are limited by factor and constant values (that is, using relative <a class="indexterm" id="id502"/>layout, factor multiplies the value of the selected property and constant is used for offset values), it can prove useful in data-bound scenarios.</p><div><pre class="programlisting">&lt;RelativeLayout x:Name="relativeLayout"&gt;
  &lt;Image x:Name="Image" Source="icon.png" HeightRequest="100" WidthRequest="100"
          RelativeLayout.XConstraint=
          "{ConstraintExpression Type=RelativeToParent, 
                                  Property=Width, 
                                  Factor=0.5, 
                                  Constant=-50}"
          RelativeLayout.YConstraint=
          "{ConstraintExpression Type=RelativeToParent, 
                                  Property=Height, 
                                  Factor=0.5, 
                                  Constant=-50}" /&gt;
  &lt;Label Text="Hello Relative Layout!" HeightRequest="100" WidthRequest="200" HorizontalTextAlignment="Center"
          RelativeLayout.XConstraint=
          "{ConstraintExpression Type=RelativeToParent, 
                                  Property=Width, 
                                  Factor=0.5, 
                                  Constant=-100}"
          RelativeLayout.YConstraint=
          "{ConstraintExpression Type=RelativeToView,
                                  ElementName=Image,
                                  Property=Y, 
                                  Constant=110}"/&gt;
&lt;/RelativeLayout&gt;</pre></div><p>Finally, <code class="literal">StackLayout</code>, similar to <code class="literal">StackPanel</code> on the Windows platform and <code class="literal">LinearLayout</code> on the Android platform, provides a flow layout where child views (that is, controls) are arranged automatically according to the orientation set and the calculated or requested dimensions of elements.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Views</h2></div></div></div><p>User<a class="indexterm" id="id503"/> interface controls in Xamarin.Forms are referred to as views. Views are abstractions of controls or widgets in Xamarin target platforms, and each of them is rendered with a native control on the respective platform.</p><p>For text-related scenarios, there are three controls: <code class="literal">Editor</code>, <code class="literal">Entry</code>, and <code class="literal">Label</code>. The <code class="literal">Editor</code> and <code class="literal">Entry</code> views provide multi-line and single-line editing capabilities to the user interface respectively. On the other hand, the label view can be used in either scenario as a read-only control.</p><p>For <a class="indexterm" id="id504"/>dropdown-related scenarios, the <code class="literal">Picker</code> view can be used. More specialized implementations of pickers are <code class="literal">TimePicker</code> and <code class="literal">DatePicker</code>. <code class="literal">Stepper</code> and <code class="literal">Slider</code> are other views that can provide a constraint value, such as an integer within a certain range. For option scenarios, the only available control is the <code class="literal">Switch</code> view. The <code class="literal">Switch</code> view renders a <code class="literal">Switch</code> control on Android and iOS and a <code class="literal">ToggleButton</code> on Windows.</p><p>For process feedback implementation, there are two views available, namely <code class="literal">ProgressBar</code> and <code class="literal">ActivityIndicator</code>. <code class="literal">ProgressBar</code> provides a determinate progress indicator, and <code class="literal">ActivityIndicator</code> is rendered as an indeterminate progress ring on target platforms.</p><p>For web resource-related scenarios, <code class="literal">WebView</code> can be utilized. In a similar fashion to embedded web view native controls on target platforms, <code class="literal">WebView</code> can be used to display either a local (that is, a web element constructed from application resources or a text value) or a remote web page. It provides access to the navigation stack and navigation events of the displayed web document.</p><p>For collection views, there are two main controls in Xamarin.Forms: <code class="literal">ListView</code> and <code class="literal">TableView</code>. <code class="literal">ListView</code>, undoubtedly, is the most specialized control to display a collection of content items. It supports data binding scenarios together with more specialized actions such as pull-to-refresh, context-related commands, and selections. <code class="literal">TableView</code>, on the other hand, is used for scenarios where the content items are more heterogeneous and instead of a data-bound source, fixed UI element declarations are required. It can be used for a menu display of selections, configuration values, or as an input form.</p><p>Both <code class="literal">ListView</code> and <code class="literal">TableView</code> consist of cells. Cells are visual templates used to render content elements in these collection views. While <code class="literal">TableView</code> is generally associated with default templates such as <code class="literal">SwitchCell</code> and <code class="literal">EntryCell</code>, which are used to create form elements in a table, <code class="literal">ListView</code> generally uses a templated implementation of <code class="literal">ViewCell</code>. For simpler implementation scenarios, built-in cell implementations, such as <code class="literal">TextCell</code> and <code class="literal">ImageCell</code>, can also be used with the <code class="literal">ListView</code> control.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>For <code class="literal">TableView</code> collection control, the iOS platform currently does not support the <code class="literal">HasUnevenRows</code> property and automatic layout of the cells. This is a known platform limitation that was recently fixed for the <code class="literal">ListView</code> control. Developers are expected to either define a fixed <code class="literal">RowHeight</code> for <code class="literal">TableView</code> or define a <code class="literal">Height</code> value for each cell.</p></div></div><p>In order to demonstrate the <code class="literal">ListView</code> utilization, we can make use of the previous implementation in which we used <code class="literal">StackLayout</code> together with <code class="literal">ScrollView</code>. In the previous scenario, we created hard-coded UI elements that were defined as <code class="literal">Grid</code> items. In this<a class="indexterm" id="id505"/> implementation, let us assume that we have a data source that can be set as the data provider for the <code class="literal">ListView</code>:</p><div><pre class="programlisting">RecentUploadsList.ItemsSource = new List&lt;Tuple&lt;string, string, string&gt;&gt;
{
    new Tuple&lt;string, string, string&gt;("Sarajevo trip on 04.10", longText, "profileicon.png"),
    new Tuple&lt;string, string, string&gt;("Istanbul trip on 23.09", longText, "mapicon.png"),
    new Tuple&lt;string, string, string&gt;("Rome trip on 12.09", longText, "settingsicon.png"),
    new Tuple&lt;string, string, string&gt;("Sarajevo trip on 04.10", longText, "profileicon.png"),
    new Tuple&lt;string, string, string&gt;("Istanbul trip on 23.09", longText, "mapicon.png"),
    new Tuple&lt;string, string, string&gt;("Rome trip on 12.09", longText, "settingsicon.png"),
    new Tuple&lt;string, string, string&gt;("Sarajevo trip on 04.10", longText, "profileicon.png"),
    new Tuple&lt;string, string, string&gt;("Istanbul trip on 23.09", longText, "mapicon.png"),
    new Tuple&lt;string, string, string&gt;("Rome trip on 12.09", longText, "settingsicon.png")
};</pre></div><p>In this provider, we are using a three value <code class="literal">Tuple</code> that provides the display name, description, and image values for the content entries.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p><code class="literal">Tuple</code> values are accessed using Item1, Item2… properties.</p></div></div><p><code class="literal">ListView</code> can contain three visual templates defining the respective sections of the collection view: <code class="literal">HeaderTemplate</code>, <code class="literal">FooterTemplate</code>, and <code class="literal">ItemTemplate</code>. A header and footer can also be set directly using a view element:</p><div><pre class="programlisting">&lt;ListView BackgroundColor="Gray" SeparatorColor="Black" HasUnevenRows="true" x:Name="RecentUploadsList" &gt;
  &lt;ListView.Header&gt;
    &lt;Label TranslationX="10" Text="Recent Uploads"&gt;&lt;/Label&gt;
  &lt;/ListView.Header&gt;
  &lt;!--&lt;ListView.ItemTemplate&gt; TODO: Insert DataTemplate &lt;/ListView.ItemTemplate&gt;--&gt;
&lt;/ListView&gt;</pre></div><p><code class="literal">ItemTemplate</code> defines how the content elements are to be rendered in the collection view. If <code class="literal">ItemTemplate</code> is not defined, the list renderer will try to convert the content elements to <a class="indexterm" id="id506"/>a string and display them as <code class="literal">TextCells</code>. Re-using the grid implementation from the previous example(s), we can define <code class="literal">DataTemplate</code> for the <code class="literal">ItemTemplate</code> property of <code class="literal">ListView</code>:</p><div><pre class="programlisting">&lt;ListView.ItemTemplate&gt;
  &lt;DataTemplate&gt;
    &lt;ViewCell&gt;
        &lt;Grid Padding="10" ColumnSpacing="4"&gt;
          &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto" /&gt;
            &lt;RowDefinition Height="40" /&gt;
          &lt;/Grid.RowDefinitions&gt;
          &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="*" /&gt;
            &lt;ColumnDefinition Width="60" /&gt;
          &lt;/Grid.ColumnDefinitions&gt;
          &lt;Image Grid.RowSpan="2" Grid.Column="1" Source="{Binding Item3}" 
                  HeightRequest="40" WidthRequest="60"/&gt;
          &lt;Label Grid.Row="0" Grid.Column="0" 
                  Text="{Binding Item1}" FontSize="16" /&gt;
          &lt;Label Grid.Row="1" Grid.Column="0" 
                  Text="{Binding Item2}" FontSize="14" /&gt;
        &lt;/Grid&gt;
    &lt;/ViewCell&gt;
  &lt;/DataTemplate&gt;
&lt;/ListView.ItemTemplate&gt;</pre></div><p>This implementation will be displayed in a scroll-enabled list container similar to the following screenshots:</p><div><img alt="Views" src="img/B04693_08_11.jpg"/><div><p>Figure 11: ListView with item source</p></div></div><p>In order<a class="indexterm" id="id507"/> to implement context-related functions, the item data template, view cell, can be edited to include context menu elements. It is also possible to modify view cell in the code-behind file.</p><p>The following XAML snippet can be used to create two context menu actions: <code class="literal">Favourite</code> and <code class="literal">Remove</code>:</p><div><pre class="programlisting">&lt;ViewCell.ContextActions&gt;
  &lt;MenuItem Text="Favourite" Clicked="OnFavouriteClicked" CommandParameter="{Binding .}"&gt;
  &lt;/MenuItem&gt;
  &lt;MenuItem Text="Remove" IsDestructive="True" Clicked="OnRemoveClicked" CommandParameter="{Binding .}"&gt;
  &lt;/MenuItem&gt;
&lt;/ViewCell.ContextActions&gt;</pre></div><p>Notice that the <code class="literal">Remove</code> command is marked as destructive. The <code class="literal">IsDestructive</code> flag is used to create the slide-to-delete behavior on iOS. On other platforms, destructive actions are rendered similar to other commands.</p><div><img alt="Views" src="img/B04693_08_12.jpg"/><div><p>Figure 12: Context menu actions</p></div></div><p><code class="literal">ListView</code> also<a class="indexterm" id="id508"/> has a flag called <code class="literal">IsPullToRefreshEnabled</code>. This property can be used to support the pull-to-refresh behavior. <code class="literal">RefreshCommand</code> can be used to bind the action required to refresh the list.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Extending forms</h1></div></div></div><p>Even<a class="indexterm" id="id509"/> though the Xamarin.Forms framework provides an extensive set of customizable UI elements, in certain scenarios you might want to change how a certain control looks or behaves. Moreover, at times, providing an application-wide customization scheme can provide consistency and decrease redundancy. XAML markup infrastructure used in Xamarin.Forms provides various custom implementation scenarios.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Styles</h2></div></div></div><p>When<a class="indexterm" id="id510"/> implementing certain UI patterns, view elements have to be declared independent of each other, and yet they have to carry the same design attributes, such as typography, layout properties, colors, and so on. Styles can be used in this situation to organize and re-use the element attributes.</p><p>Using <code class="literal">ListView</code>, the only view container defined would be the item data template, and the content items loaded from the data source will be rendered using the same template. However, if the view requirement is to use <code class="literal">Grid</code>, <code class="literal">StackLayout</code>, or <code class="literal">TableView</code>, each view item would have to be defined separately.</p><p>For <a class="indexterm" id="id511"/>instance, it might become quite cumbersome to create a settings view for Xamarin.Forms applications using the <code class="literal">TableView</code> control. In this implementation, if we cannot use the standard cell views, such as <code class="literal">EntryCell</code> or <code class="literal">SwitchCell</code>, because of requirements, the markup becomes even more redundant with each control having to declare similar fonts and colors that make up the theme of the application.</p><div><img alt="Styles" src="img/B04693_08_13.jpg"/><div><p>Figure 13: TableView used for a settings view</p></div></div><p>Custom cell views in this implementation were used to create a description element for each setting. If we look at the markup file, you can see the repeating styles for each text element:</p><div><pre class="programlisting">&lt;TableView Intent="Settings" HasUnevenRows="True"&gt;
  &lt;TableRoot&gt;
    &lt;TableSection Title="Location"&gt;
      &lt;ViewCell&gt;
        &lt;StackLayout Orientation="Vertical" Padding="10"&gt;
          &lt;StackLayout Orientation="Horizontal"&gt;
            &lt;Label TextColor="White" FontSize="24"
                   VerticalTextAlignment="Center" 
                   HorizontalOptions="StartAndExpand" 
                   Text="Use Location" /&gt;
            &lt;Switch IsToggled="True"&gt;&lt;/Switch&gt;
          &lt;/StackLayout&gt;
          &lt;Label TextColor="Silver" FontSize="20"
                 VerticalTextAlignment="Center" 
                 HorizontalOptions="StartAndExpand"  
                 Text="Use location to tag photos and notes. Location can be used for notifications as well"&gt;
          &lt;/Label&gt;
        &lt;/StackLayout&gt;
      &lt;/ViewCell&gt;
      &lt;ViewCell&gt;
        &lt;StackLayout Orientation="Vertical" Padding="10"&gt;
          &lt;StackLayout Orientation="Horizontal"&gt;
            &lt;Label TextColor="White" FontSize="24"
                   VerticalTextAlignment="Center" 
                   HorizontalOptions="StartAndExpand" 
                   Text="Create Geofences" /&gt;
            &lt;Switch IsToggled="True"&gt;&lt;/Switch&gt;
          &lt;/StackLayout&gt;
          &lt;Label TextColor="Silver" FontSize="20"
                  VerticalTextAlignment="Center" 
                  HorizontalOptions="StartAndExpand" 
                  Text="Create geofences to give notifications about landmarks."&gt;
          &lt;/Label&gt;
        &lt;/StackLayout&gt;
      &lt;/ViewCell&gt;
    &lt;/TableSection&gt;
    &lt;!-- Additional sections were removed for simplicity --&gt;
  &lt;/TableRoot&gt;
&lt;/TableView&gt;</pre></div><p>In this <a class="indexterm" id="id512"/>example, each label is defining at least <code class="literal">TextColor</code>, <code class="literal">FontSize</code>, <code class="literal">VerticalTextAlignment</code>, and <code class="literal">HorizontalOptions</code>. There is one pattern for setting labels and another one for description elements. Vertical and horizontal alignment options, however, apply to all text elements.</p><p>Initially, we can simplify the markup by creating an implicit style that will apply to all <code class="literal">Label</code> elements. Implicit <a class="indexterm" id="id513"/>styles do not define a resource key, hence they apply to all targeted controls, such as <code class="literal">TargetType</code>:</p><div><pre class="programlisting">&lt;ContentPage.Resources&gt;
  &lt;ResourceDictionary&gt;
    &lt;Style TargetType="Label"&gt;
      &lt;Setter Property="HorizontalOptions" Value="StartAndExpand" /&gt;
      &lt;Setter Property="VerticalTextAlignment" Value="Center" /&gt;
    &lt;/Style&gt;
  &lt;/ResourceDictionary&gt;
&lt;/ContentPage.Resources&gt;</pre></div><p>We can now create additional styles to set item labels and descriptions:</p><div><pre class="programlisting">&lt;Style x:Key="SettingLabel" TargetType="Label"&gt;
  &lt;Setter Property="FontSize" Value="24"&gt;&lt;/Setter&gt;
  &lt;Setter Property="TextColor" Value="White"&gt;&lt;/Setter&gt;
&lt;/Style&gt;
&lt;Style x:Key="SettingDescription" TargetType="Label"&gt;
  &lt;Setter Property="FontSize" Value="20"&gt;&lt;/Setter&gt;
  &lt;Setter Property="TextColor" Value="Silver"&gt;&lt;/Setter&gt;
&lt;/Style&gt;</pre></div><p>However, this does not work as we expected it to. The outcome demonstrates that the implicit styles were overridden by more specific style descriptions. It is important to realize that there is no implicit cascading between the styles defined for the same target controls. XAML is not HTML/CSS.</p><div><img alt="Styles" src="img/B04693_08_14.jpg"/><div><p>Figure 14: Implicit style is overridden with assigned styles</p></div></div><p>In order to create a cascading scheme, we need to base the <code class="literal">SettingLabel</code> and <code class="literal">SettingDescription</code> styles on the initial implicit style. For this purpose, we need to define a key for <a class="indexterm" id="id514"/>our base style and reference this base in the derived style declarations:</p><div><pre class="programlisting">&lt;ContentPage.Resources&gt;
  &lt;ResourceDictionary&gt;
    &lt;Style x:Key="BaseLabelStyle" TargetType="Label"&gt;
      &lt;Setter Property="HorizontalOptions" Value="StartAndExpand" /&gt;
      &lt;Setter Property="VerticalTextAlignment" Value="Center" /&gt;
    &lt;/Style&gt;
<strong>    &lt;Style x:Key="SettingLabel" BaseResourceKey="BaseLabelStyle" TargetType="Label"&gt;</strong>
      &lt;Setter Property="FontSize" Value="24"&gt;&lt;/Setter&gt;
      &lt;Setter Property="TextColor" Value="White"&gt;&lt;/Setter&gt;
    &lt;/Style&gt;
<strong>    &lt;Style x:Key="SettingDescription" BasedOn="{StaticResource BaseLabelStyle}" TargetType="Label"&gt;</strong>
      &lt;Setter Property="FontSize" Value="20"&gt;&lt;/Setter&gt;
      &lt;Setter Property="TextColor" Value="Silver"&gt;&lt;/Setter&gt;
    &lt;/Style&gt;
  &lt;/ResourceDictionary&gt;
&lt;/ContentPage.Resources&gt;</pre></div><p>Notice that the <code class="literal">SettingDescription</code> style uses the <code class="literal">BasedOn</code> declaration (similar to the WPF implementation), while <code class="literal">SettingLabel</code> uses the <code class="literal">BaseResourceKey</code> property. Both of these references can be used in Xamarin.Forms implementations.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Triggers and behaviors</h2></div></div></div><p>At times, implementation requires style-related or behavioral changes of controls in accordance<a class="indexterm" id="id515"/> with changes of the same or any other control's properties or data, as well as certain events (for example, disabling a certain control according to the data input value changes). Under normal circumstances, implementations utilize data bindings where the data change event is routed to the presenter and the presenter changes the view, providing a trivial solution. However, if the UI event should trigger another UI change, the cost of data binding would be an overhead. Instead, the Xamarin.Forms markup offers triggers and behaviors that add complexity to intrinsic controls.</p><p>For instance, the settings view that we previously created for our application requires certain business rules. The first setting value, UserLocation, is a dependency of the UseGeofences setting. In other words, technically it is not possible to create geofences without using location services. For this specific scenario, we could create a data binding from the <code class="literal">IsToggled</code> value:</p><div><pre class="programlisting">&lt;Switch x:Name="SwitchUseGeofences" IsToggled="True"
              IsEnabled="{Binding Source={x:Reference SwitchUserLocation}, Path=IsToggled}"&gt;</pre></div><p>The preceding implementation works as expected since the <code class="literal">IsToggled</code> and <code class="literal">IsEnabled</code> values are both using <code class="literal">Boolean</code> as the value type. If we were to change any other property of the target UI element, we would have to implement a value converter. Moreover, multiple property changes would require multiple bindings.</p><p>Triggers <a class="indexterm" id="id516"/>provide an easy solution for this type of scenario. There are four types of trigger that can be used to initiate either a setter action or a custom implementation of a trigger action. Property triggers are used to create a visual state on a user control according to the value of a property of the same control. Data triggers are used in a similar fashion but in this case, the cause for the trigger is defined by data binding. Event triggers are bound to user control events and multi triggers can encompass and invoke an action that is dependent on multiple conditions.</p><p>The same scenario from the previous example can, in this case, be implemented with a <code class="literal">DataTrigger</code>. Iterating on the scenario, the implementation can set the enabled and text color properties on the associated description label:</p><div><pre class="programlisting">&lt;ViewCell&gt;
  &lt;StackLayout Orientation="Vertical" Padding="10"&gt;
    &lt;StackLayout Orientation="Horizontal"&gt;
      &lt;Label Text="Create Geofences" Style="{StaticResource SettingLabel}" /&gt;
      &lt;Switch x:Name="SwitchUseGeofences" IsToggled="True"
              IsEnabled="{Binding Source={x:Reference SwitchUserLocation}, Path=IsToggled}"&gt;
        &lt;Switch.Triggers&gt;
<strong>          &lt;DataTrigger TargetType="Switch" Binding="{Binding Source={x:Reference SwitchUserLocation}, Path=IsToggled}" Value="True"&gt;</strong>
<strong>            &lt;Setter Property="IsEnabled" Value="False"&gt;&lt;/Setter&gt;</strong>
<strong>          &lt;/DataTrigger&gt;</strong>
        &lt;/Switch.Triggers&gt;
      &lt;/Switch&gt;
    &lt;/StackLayout&gt;
    &lt;Label Text="Create geofences to give notifications about landmarks."
            Style="{StaticResource SettingDescription}"&gt;
      &lt;Label.Triggers&gt;
<strong>        &lt;DataTrigger TargetType="Label" Binding="{Binding Source={x:Reference SwitchUserLocation}, Path=IsToggled}" Value="False"&gt;</strong>
<strong>          &lt;Setter Property="IsEnabled" Value="False"&gt;&lt;/Setter&gt;</strong>
<strong>          &lt;Setter Property="TextColor" Value="Transparent"&gt;&lt;/Setter&gt;</strong>
<strong>        &lt;/DataTrigger&gt;</strong>
<strong>      &lt;/Label.Triggers&gt;</strong>
    &lt;/Label&gt;
  &lt;/StackLayout&gt;
&lt;/ViewCell&gt;</pre></div><p>Let us also <a class="indexterm" id="id517"/>implement a notification when the main control is disabled, warning the user about other settings being disabled. For this implementation, we will need an event trigger and a trigger action implementation. A trigger action implementation consists of implementing the <code class="literal">TriggerAction&lt;T&gt;</code> class and the virtual <code class="literal">Invoke</code> method: (see the <em>Dependency injection</em> section for the implementation of <code class="literal">INotificationService</code>)</p><div><pre class="programlisting">public class WarningTriggerAction : TriggerAction&lt;Switch&gt;
{
    public string Message { get; set; }
    protected override void Invoke(Switch sender)
    {
        if(!sender.IsToggled) 
            DependencyService.Get&lt;INotificationService&gt;()
                .Notify(Message);
    }
}</pre></div><p>Then, we will need to declare the namespace containing the implementation in the root node of the page's markup:</p><div><pre class="programlisting"/></div><p>And finally, we can add the event trigger to the main setting control:</p><div><pre class="programlisting">&lt;Switch x:Name="SwitchUserLocation" IsToggled="True"&gt;
  &lt;Switch.Triggers&gt;
    &lt;EventTrigger Event="Toggled"&gt;
      &lt;components:WarningTriggerAction Message="Disabling this setting will disable other values" /&gt;
    &lt;/EventTrigger&gt;
  &lt;/Switch.Triggers&gt;
&lt;/Switch&gt;</pre></div><div><img alt="Triggers and behaviors" src="img/B04693_08_15.jpg"/><div><p>Figure 15: Notification triggered using EventTrigger</p></div></div><p>If we<a class="indexterm" id="id518"/> want this trigger to be applied to multiple controls (for example, the notification settings section in the example), we can create a new style for the main setting values and add the trigger to the style declaration:</p><div><pre class="programlisting">&lt;Style x:Key="SectionToggleSwitch" TargetType="Switch"&gt;
  &lt;Style.Triggers&gt;
    &lt;EventTrigger Event="Toggled"&gt;
      &lt;components:WarningTriggerAction Message="Disabling this setting will disable other values" /&gt;
    &lt;/EventTrigger&gt;
  &lt;/Style.Triggers&gt;
&lt;/Style&gt;</pre></div><p>The same type of result could have been achieved with a behavior implementation for the <code class="literal">Switch</code> control. Behaviors are a more generic type of extension mechanism that allow developers to extend existing user controls without having to create derivatives of these controls.</p><p>For instance, if we were to use the same scenario (that is, when the switch control is toggled off, a notification window should be shown to the user), we would need to implement the base class, <code class="literal">Behavior</code>, with a type argument for <code class="literal">Switch</code> view:</p><div><pre class="programlisting">public class SectionSwitchAlertBehavior : Behavior&lt;Switch&gt;
{
    public string Message { get; set; }

    protected override void OnAttachedTo(Switch control)
    {
        control.Toggled += ControlOnToggled;

        base.OnAttachedTo(control);
    }

    protected override void OnDetachingFrom(Switch control)
    {
        control.Toggled -= ControlOnToggled;

        base.OnDetachingFrom(control);
    }
    private void ControlOnToggled(object sender, ToggledEventArgs toggledEventArgs)
    {
        if (!toggledEventArgs.Value &amp;&amp; !string.IsNullOrWhiteSpace(Message))
        {
            DependencyService.Get&lt;INotificationService&gt;().Notify(Message);
        }
    }
}</pre></div><p>In a<a class="indexterm" id="id519"/> custom behavior implementation class, an <code class="literal">OnAttachedTo</code> method is used as the initialization function where the control can be customized. Similarly, <code class="literal">OnDetachingFrom</code> is used to clean up the customizations and any existing event handlers that might have been attached to the control. Even though it's technically possible, it is not advisable to modify the binding context using behaviors.</p><p>The custom behavior can be included either in styles targeting the same type of control or with in-place markup elements added to the specific control:</p><div><pre class="programlisting">&lt;Style x:Key="SectionToggleSwitch" TargetType="Switch"&gt;
  &lt;Style.Behaviors&gt;
<strong>    &lt;components:SectionSwitchAlertBehavior Message="Disabling this setting will disable other values" /&gt;</strong>
  &lt;/Style.Behaviors&gt;
&lt;/Style&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Custom renderers</h2></div></div></div><p>Xamarin.Forms <a class="indexterm" id="id520"/>provides the developers with a uniform markup and implementation framework to create native UI views for all Xamarin target platforms. The abstractions of provided UI elements are then used by the framework to render native controls. Similar to the Xamarin.Forms solution anatomy, each view/control in the Xamarin.Forms platform is a composite implementation. While the behaviors for the abstracted control logic are implemented and can be derived in portable class libraries, the renderers associated with each control for various platforms are implemented by platform-specific libraries.</p><div><img alt="Custom renderers" src="img/B04693_08_16.jpg"/><div><p>Figure 16: Custom renderer implementation</p></div></div><p>In order to customize a control, one must first create a derived class for the abstracted control. After this implementation, the custom control can be referenced with a <code class="literal">clr-namespace</code> declaration (similar to <code class="literal">TriggerAction</code> and <code class="literal">Behaviors</code>) and can be used in the view markup.</p><p>At this stage, the custom implementation of the control would use the default renderer for the base class. In order to change the way that native controls are rendered on a specific platform, we would need to provide a custom renderer implementation and register it using the <code class="literal">ExportRenderer</code> attribute on the same platform.</p><p>Custom renderers provide a powerful way to customize how the common view implementations with Xamarin.Forms should look on platform-specific views.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Patterns and best practices</h1></div></div></div><p>In<a class="indexterm" id="id521"/> this section, we will discuss several implementation patterns and tools that developers generally resort to while developing Xamarin.Forms applications. Messaging and dependency injection features will be discussed further in <a class="link" href="ch09.html" title="Chapter 9. Reusable UI Patterns">Chapter 9</a>, <em>Reusable UI Patterns</em>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Messaging infrastructure</h2></div></div></div><p>In <a class="indexterm" id="id522"/>an ideal implementation of the <strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>) or <strong>Model-View-Presenter</strong> (<strong>MVP</strong>) pattern, each screen<a class="indexterm" id="id523"/> is self-contained; the screen modules for<a class="indexterm" id="id524"/> the view, model, and the mitigation components communicate with each other using various communication channels.</p><p>However, in complex applications, there is sometimes the need for a communication channel between these self-contained elements, since the result of an action on one of the screens should be propagated to other unrelated section(s) of the application with a shared interest in the result of this very action. As a solution to this problem, in MVVM frameworks such as MVVMCross, Prism, or MVVM Light, it is common to see an implementation of the Event Aggregator pattern providing a loosely coupled, multicast-enabled publisher/subscriber messaging infrastructure. Event Aggregator can be described as the eventing hub, which receives multiple types of strongly typed messages and delivers these messages to multiple subscribers.</p><p>In Xamarin.Forms, the Event Aggregator is called the <code class="literal">MessagingCenter</code>. It exposes three groups of methods: <code class="literal">Subscribe</code>, <code class="literal">Unsubscribe</code>, and <code class="literal">Send</code>. The <code class="literal">Subscribe</code> and <code class="literal">Unsubscribe</code> methods are used by the event observers, and the <code class="literal">Send</code> method is used by the publisher.</p><p>In this paradigm, the subscriber is responsible for providing the instance and/or the type of the sender together with the expected type of the message (that is, a simple text parameter defining the message). The message type or name is an identifier for the message and together with the message signature (the sender type and the arguments type), it makes up the decision criteria for the subscribers. Finally, the last provided parameter is the callback delegate, which can have the sender, and possibly the event arguments, as parameters:</p><div><pre class="programlisting">MessagingCenter.Subscribe&lt;MyViewModel, MyMessageContract&gt;(this, "MyMessageName",
    (sender, data) =&gt;
    {
        // TODO: Use the provided data and the sender
    });

// or
//MessagingCenter.Subscribe(this, "MyMessageName", (sender) =&gt; { }, myViewModelInstance);</pre></div><p>The <a class="indexterm" id="id525"/>publisher is responsible for providing the message with the same message name and signature. On the publisher's side, the message signature is made up of the message name and the message argument parameter:</p><div><pre class="programlisting">MessagingCenter.Send(this, "MyMessageName", new MyMessageContract
{
    // TODO: Pass on the required data.
});</pre></div><p>MessagingCenter can prove to be very utile, providing simple solutions/workarounds for architectural problems (especially scenarios where a Separation of Concerns is in question) in Xamarin.Forms applications, and creating a decoupled communication channel between components.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Dependency injection</h2></div></div></div><p>As<a class="indexterm" id="id526"/> previously mentioned, one of the biggest drawbacks of using <strong>Portable Class Libraries</strong> (<strong>PCLs</strong>) to implement common cross-platform libraries is the fact that the platform-specific features cannot be accessed directly <a class="indexterm" id="id527"/>since the platform-dependent modules cannot be referenced by these libraries.</p><p>One of the most effective and elegant solutions to this problem is using dependency injection (aka IoC - Inversion of Control). Using dependency injection, platform-specific functionality should be abstracted into segregated interfaces, and these interfaces can later be used to access the implementation modules injected with the provided dependency containers.</p><p><code class="literal">DependencyService</code> in Xamarin.Forms allows applications to use platform-specific implementation through the abstraction interfaces.</p><p>In a common scenario, the first step would be to define the abstraction (in the common portable forms library) that is going to be used by the common application layer.</p><p>For a demonstration, let us implement a module that uses the native messaging methods to display a notification for the user:</p><div><pre class="programlisting">public interface INotificationService
{
    void Notify(string message);
}</pre></div><p>Now we can implement this interface in platform-specific projects. In the Xamarin.Android project, we can implement this using a toast notification:</p><div><pre class="programlisting">[assembly:Xamarin.Forms.Dependency(typeof(NotificationService))]
namespace Xamarin.Master.TravelTrace.Droid.Modules
{
    public class NotificationService : INotificationService
    {
        public void Notify(string message)
        {
            var toast = Toast.MakeText(Application.Context, message, ToastLength.Long);
            toast.Show();
        }
    }
}</pre></div><p>For <a class="indexterm" id="id528"/>the iOS platform, we can create a local notification message and present it using the shared application infrastructure. However, local notifications for foreground applications are automatically dismissed (only at the UI level can one still implement an event delegate for a notification received event and display an alert instead). Hence, we will use the <code class="literal">UIAlertController</code> class and present it using the current window:</p><div><pre class="programlisting">[assembly: Xamarin.Forms.Dependency(typeof(NotificationService))]
namespace Xamarin.Master.TravelTrace.iOS.Modules
{
    public class NotificationService : INotificationService
    {
        public void Notify(string message)
        {
            //
            // This will not fire for the foreground application
            //UILocalNotification localNotification = new 
            // UILocalNotification();
            // localNotification.FireDate = 
            // NSDate.Now.AddSeconds(2);
            //localNotification.AlertBody = message;
            //localNotification.TimeZone = 
            // NSTimeZone.SystemTimeZone;
            // UIApplication.SharedApplication
            // .PresentLocalNotificationNow(localNotification);
            // UIApplication.SharedApplication
            // .ScheduleLocalNotification(localNotification);

            //Create Alert
            var okAlertController = UIAlertController.Create ("Notification", message, UIAlertControllerStyle.Alert);

            //Add Action
            okAlertController.AddAction(UIAlertAction.Create("OK", UIAlertActionStyle.Default, null));

            if (UIApplication.SharedApplication.KeyWindow != null)
                UIApplication.SharedApplication.KeyWindow.RootViewController.PresentViewController(okAlertController, true, null);
        }
    }
}</pre></div><p>And finally, for<a class="indexterm" id="id529"/> the Windows Phone platform, we can only use the local toast notifications with the currently running applications on Windows Phone 8.1 and Windows 10 mobile. For other versions, similar to the iOS scenario, local toast notifications are not allowed for foreground applications. For this reason, we can implement a simpler notification dialog using the <code class="literal">MessageBox</code> class:</p><div><pre class="programlisting">[assembly: Xamarin.Forms.Dependency(typeof(NotificationService))]
namespace Xamarin.Master.TravelTrace.WinPhone.Modules
{
    public class NotificationService : INotificationService
    {
        public void Notify(string message)
        {
            MessageBox.Show(message);
        }
    }
}</pre></div><p>In order to use the <code class="literal">INotificationService</code> interface in the portable class library that implements the Xamarin.Forms application, we need to resolve the interface to create an instance of one of the platform-appropriate implementations:</p><div><pre class="programlisting">DependencyService.Get&lt;INotificationService&gt;().Notify("Hello Xamarin.Forms!");</pre></div><p>It is important to note that in this sample implementation, the <code class="literal">Dependency</code> assembly attribute was used to register the platform-dependent implementation classes. It is also possible to use the <code class="literal">Register</code> method of <code class="literal">DependencyService</code> to create dependency containers:</p><div><pre class="programlisting">Xamarin.Forms.DependencyService.Register&lt;INotificationService, NotificationService&gt;();</pre></div><p>The <code class="literal">Register</code> method has to be invoked after the initialization of Xamarin.Forms (that is, the <code class="literal">Forms.Init</code> method) and before any dependent module is loaded.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Shared project versus portable project</h2></div></div></div><p>Xamarin.Forms extensions introduce two types of multi-project solution templates. Each template contains platform-specific projects as well as a common project to implement platform-agnostic components for these native applications.</p><p>In the <a class="indexterm" id="id530"/>previous examples we were using the PCL project template, which creates three platform-specific projects, each referencing a cross-platform portable class library. Platform-specific projects delegate the application initialization to the portable class library that initializes Xamarin.Forms and renders the pages implemented using Xamarin.Forms.</p><p>The second project template creates a shared project that is included and compiled into the platform-specific projects. In this scenario, since we are technically not dealing with a platform-agnostic implementation (that is, implementations in the shared project are directly compiled into the referencing projects), developers are free to use platform-specific features, given that the compilation conditions are used for appropriate platforms.</p><p>The easiest way to demonstrate the difference between the two approaches would be to re-implement the notification service from the previous section without dependency injection. In the previous example, we needed to create an abstraction of the notification feature to be used in common views and inject the implementation from platform-specific projects in the runtime. In the case of a shared project, we can implement the same feature using conditional compilation:</p><div><pre class="programlisting">public class NotificationService
{
    public void Notify(string message)
    {
        if (!string.IsNullOrWhiteSpace(message))
#if __IOS__
    var okAlertController = UIAlertController.Create("Notification", message, UIAlertControllerStyle.Alert);

    okAlertController.AddAction(UIAlertAction.Create("OK", UIAlertActionStyle.Default, null));

    if (UIApplication.SharedApplication.KeyWindow != null)
        UIApplication.SharedApplication.KeyWindow.RootViewController
            .PresentViewController(okAlertController, true, null);
#elif __ANDROID__
    var toast = Toast.MakeText(Application.Context, message, ToastLength.Long);
    toast.Show();
#elif WINDOWS_PHONE
            MessageBox.Show(message);
#endif
    }
}</pre></div><p>In this case, each platform compilation uses a specific section of the function. We can also use <a class="indexterm" id="id531"/>other types of abstraction and partial classes or methods to create elegant implementations according to the requirements of the scenario.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Platform-specific fine-tuning</h2></div></div></div><p>In spite of, or even<a class="indexterm" id="id532"/> because of, the fact that Xamarin.Forms tries to provide a uniform implementation layer and then translates this layer into native controls, at times developers are faced with the challenge of implementing retouches for specific platforms. These modifications vary from small changes, such as font size (because of device- and platform-dependent pixel measures) or background color, to more systematic problems, such as not having the auto-layout implementation for <code class="literal">TableViews</code> on the iOS platform. There are various ways to deal with this type of situation, and the <code class="literal">Device</code> class is generally the access point to these solutions.</p><p>When dealing with common typographic controls, such as a <code class="literal">Label</code> or an <code class="literal">Entry</code> field, the simplest way to comply with the design or accessibility requirements of a specific device is to use the built-in styles available in the <code class="literal">Device.Styles</code> class. There are several style elements, such as <code class="literal">BodyStyle</code>, <code class="literal">SubtitleStyle</code>, and <code class="literal">CaptionStyle</code>, that can be used to solve common implementation problems. The style elements in this class are calculated for the current platform/device in the runtime, hence they have to be referenced by a <code class="literal">DynamicResource</code> XAML markup extension when dealing with markup rather than code.</p><p>A simple label using the <code class="literal">TitleStyle</code> can be implemented as follows:</p><div><pre class="programlisting">var mylabel = new Label
{
    Text = "Text for my Title",
    Style = Device.Styles.TitleStyle
};</pre></div><p>It can also be declared in the markup file as follows:</p><div><pre class="programlisting">&lt;Label x:Name="MyLabel" Text="Text for my Title" Style="{DynamicResource TitleStyle}" /&gt;</pre></div><p>Another useful platform-specific typography-related utility is the <code class="literal">NamedSize</code> enumeration. The <code class="literal">NamedSize</code> enumeration can be used with the <code class="literal">Device.GetNamedSize</code> method to choose the most suitable font size in the target platform for a text field. The enumeration provides four built-in options for different scenarios:</p><div><pre class="programlisting">var mylabel = new Label {Text = "Text for my Title"};

// A Large font size, for titles or other important text elements
mylabel.FontSize = Device.GetNamedSize(NamedSize.Large, typeof (Label));</pre></div><p>A built-in converter can also be used to include the font size in XAML markup:</p><div><pre class="programlisting">&lt;Label x:Name="MyLabel" Text="Text for my Title" FontSize="Large" /&gt;</pre></div><p>For more<a class="indexterm" id="id533"/> general implementation requirements, <code class="literal">Device.Idiom</code> and <code class="literal">Device.OS</code> provide valuable target platform information related to the type of device (desktop, phone, tablet, and so on) and the operating system of the device (Android, iOS, Windows, or Windows Phone) respectively.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Currently, Windows Phone 8.1 and Windows Phone Silverlight versions cannot be differentiated using the <code class="literal">Device.OS</code> property. Conditional compilation can be used as a replacement for this distinction.</p></div></div><p>Additionally, the <code class="literal">Device.OnPlatform</code> function and its XAML extension counterpart can help developers implement platform-specific styles. The <code class="literal">OnPlatform</code> function uses three values for each platform and returns the appropriate value according to the <code class="literal">Device.OS</code> property.</p><p>Visualizing a label using the <code class="literal">OnPlatform</code> function would look similar to the following snippet:</p><div><pre class="programlisting">var mylabel = new Label {Text = "Text for my Title"};
mylabel.FontSize = Device.OnPlatform&lt;double&gt;(
     Android: 24, WinPhone: 24, iOS: 18);</pre></div><p>Or, using the XAML markup extension, it would look like this:</p><div><pre class="programlisting">&lt;Label x:Name="MyLabel" Text="Text for my Title"&gt;
  &lt;Label.FontSize&gt;
    &lt;OnPlatform x:TypeArguments="x:Double" Android="24" WinPhone="24" iOS="16"/&gt;
  &lt;/Label.FontSize&gt;
&lt;/Label&gt;</pre></div><p>The <code class="literal">Device.OnPlatform</code> function has another overload that can be used to execute certain actions according to current operating system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Summary</h1></div></div></div><p>Briefly, Xamarin.Forms provides the toolset to increase code-sharing between platform-specific projects and provide developers with a uniform experience when developing UI components for these projects. The Xamarin.Forms framework, in general, proves to be indispensable, especially for cross-platform implementation where platform-dependent feature requirements are minimal.</p><p>This uniform abstraction layer is responsible for rendering the platform-specific UI controls and creating native experience for the users. This layer can also be extended using various features and patterns, some of which were discussed in this chapter.</p><p>We will be focusing on more re-usable view elements and implementation patterns in the next chapter. Xamarin.Forms will again be referenced in this context.</p></div></body></html>