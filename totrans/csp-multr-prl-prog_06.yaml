- en: Chapter 6. Task-based Parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will cover the **Task Parallel Library** (**TPL**) and the
    details of using the `Task` class to write concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Lightweight Concurrency – Task Parallel
    Library (TPL)"), *Lightweight Concurrency – Task Parallel Library (TPL)*, we started
    our exploration of lightweight concurrency and .NET's new most preferred way to
    accomplish multithreaded programming—the TPL. In this chapter, we will explore
    task-based parallelism further and show how to wait on tasks or multiple tasks,
    custom scheduling of a task, error handling, and canceling a task.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL gives us an easy way to schedule, run, and coordinate tasks at a higher
    level of abstraction than working directly with threads. As mentioned earlier,
    a task is a set of instructions to carry out an objective, a unit of work if you
    wish. We can define a task in a method called by a delegate or in a lambda expression
    defined directly in the task-creation command.
  prefs: []
  type: TYPE_NORMAL
- en: When running more than one task concurrently, there will be times when we need
    to wait on one or more tasks to complete before performing a function, or be able
    to cancel one or more tasks if a certain condition arises, or coordinate exception
    handling if one or more tasks throws an error when running in parallel. We will
    discuss all of these scenarios in this chapter and work through examples. By the
    end of this chapter, you will be very comfortable with all the aspects of using
    tasks in parallel in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait on a particular task when multiple tasks are running concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait on all or many tasks that are running concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel one or more tasks when certain conditions occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle exceptions thrown by one or more tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully coordinate the execution and completion of concurrently running tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for a task to complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do when we execute a task is to know when it has
    completed, and if it returns results, what the results are. Let's see a simple
    example by creating a task, waiting for it to complete, and then checking the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: We will do this using a task that doesn't return a result and one that does,
    and see the difference between `Task` and `Task<TResult>`. When a task returns
    a result value, the wait is implicit, and when it doesn't, we need to explicitly
    wait for it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s open up Visual Studio and create a new console application called
    `WaitonTask`. Once we have the new project created, we will add the following
    code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are creating a task to run for 10 seconds
    and we will wait on the task to finish. This task calls a method named `Worker`
    and is instantiated using a `Task.Factory` and a lambda expression. The task does
    not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compile and run our new application. The following is an example
    of the output you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we first start a task with the `Worker` method and wait on it
    to complete and then we start a task with the `Worker` method and perform a wait
    with a time-out value. Did you notice a difference between the two executions?
  prefs: []
  type: TYPE_NORMAL
- en: The first time we run the task, we will wait the full 10 seconds for the task
    to complete. The second time we run the task, we set a timeout and continue on
    before the task completes. Since the task runs for longer than 2 seconds, the
    wait command times out and the program moves on, while the task is still running.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of these examples, we have a task that does not return a value. Now,
    let''s change our worker task to return a value and see what happens. Let''s add
    a new method to our program called `Worker1`. Add the following code to the `Worker1`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `Main` method of the `Program.cs` file, add the following two lines
    of code towards the end right before the `Console.ReadLine` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile and run our program again. The following is the output
    that you should see when you run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Did you notice that the program ran and waited for `TaskC` to complete? Shortly,
    we will get to the `SpinWait` method of the `Thread` class, but for now, why did
    the program wait on `TaskC` to finish running when we did not put a wait command
    in the code for it?
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we saw three ways to wait for a task to complete.
    The first two examples used the `Task.Wait` method to tell our program to wait
    on the task. Since the task is running on a different thread, we have to wait
    for it to complete before we continue the execution of the program in our main
    thread. In these two examples, our task does not return a value. In this case,
    we need to explicitly wait on the task to complete if we do not want our main
    thread to continue after starting the task (or at least scheduling it in the threadpool).
    We do this using the `Task.Wait` method in the `Task` class.
  prefs: []
  type: TYPE_NORMAL
- en: The first time, we told our program to wait on the task to complete and then
    move on. The second time, we set a timeout value in the `Wait` method. This tells
    our main thread to wait for the amount of time in the timeout parameter and then
    move on. Then we checked the `Task.IsComplete` property to see whether our task
    has completed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the task was set to run for longer than the timeout value, the task was
    still running when our main thread continued execution. That is why the `IsComplete`
    property is `false` and the `else` portion of our `if` statement gets executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can play around with this code and make the task run for less time than
    the timeout value and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we ran a task using the `Worker1` method that returns a `double` value.
    What did we see here? We did not place a `Task.Wait` command but our main program
    still waited on the task to complete before continuing on with its execution.
    Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: We know it waited until the task was completed because when we wrote the `Task.Result`
    value to the console, it had a value and was not `null`. In this case, we do not
    need to use the `Task.Wait` method explicitly because the main thread will wait
    on the task to complete; it needs to wait until the `Task.Result` property is
    set. By defining a task with a return value, we are telling our main thread implicitly
    to wait on the task to complete.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we have seen, if we do not return a value in our task, then we need to
    explicitly tell our program to wait. However, if we return a value, we are implicitly
    telling our program to wait on the task to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to control the execution of our main thread when we start
    many concurrent tasks at once. In this case, if our tasks return values, we might
    not implicitly want to wait on every task to complete. Maybe we just want to wait
    on one task to complete.
  prefs: []
  type: TYPE_NORMAL
- en: In our current program, we used the `Thread.SpinWait` method. This method is
    different from the `Thread.Sleep` method. The `Thread.Sleep` method waits for
    a specified time whereas the `SpinWait` method starts a loop for the specified
    iterations passed to the method. So, in this case, the speed of the processor
    will dictate the duration because the clock speed will determine how fast it can
    complete the number of iterations. By using this instead of a `Sleep` method,
    it also allows the scheduler to perform context switching if thread priorities
    dictate.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for multiple tasks to complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we examined how to explicitly and implicitly wait on
    a task to complete. Now, let's see how we can control execution and waiting when
    we start many tasks instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we may want to wait on one task out of a group to finish. Sometimes,
    we might want to wait on all of the tasks to finish, and other times we might
    want to wait on a certain condition of tasks to finish before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all of the `Wait` and `When` methods provided
    with the `Task` class. The `Wait` methods are as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `When` methods are as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both images are references from [http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate how to perform different `Wait` and `When` techniques in
    this chapter, but this is to give you further ideas on what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a simple program to demonstrate how the `WaitAll` method
    works by populating three circles with random numbers once three tasks complete.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we need to create a WPF application using Visual Studio. Open
    Visual Studio and create a new WPF project called `RandomCircles`. Once we have
    created this project, proceed by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the design mode in Visual Studio and add the following controls to
    the `MainWindow.xaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three Ellipse controls and name them `Circle1`, `Circle2`, and `Circle3`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set their height and width properties to `120` for all three circles. This is
    done in the `MainWindow.xaml` file using the **Design** mode in Visual Studio.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add three textboxes and place them inside the circles. Name them `text1`,
    `text2`, and `text3`. Set the `Text` property on all three to an empty string
    and make their `Background` property the same color as the `Fill` property on
    the Ellipse controls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add a button control and name it `btnRandomAll`. Set the `Content` property
    on this control to `Random All`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, your `MainWindow.xaml` file should look like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, let's go to the `MainWindow.xaml.cs` code behind this file. We need to
    add a `using` statement for the `Threading` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks` namespace should already be included when you created
    the WPF project, but check to make sure whether it is there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s add a worker method to provide work for the tasks to perform, which
    we are about to create. Create a `Worker1` method that is `private` and returns
    a string value. Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SpinWait` is used here to demonstrate how processor speed can affect the speed
    of a function. `SpinWait` is very inefficient and does consume CPU resources more
    than `Sleep()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s create an event handler for `btnRandomAll`—a click event called
    `btnRandomAll_Click`. Inside this method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That should be all you need to have a program that runs three tasks in separate
    threads. Each of these tasks will spin for a random time. The main thread will
    wait on all of these tasks to complete and then return a string that has the random
    number used by the task and the current time in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s compile and run our new program. The following is what random
    circles should look like when it is first started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random All** button once and see what the output looks
    like. The following is what we got when we ran it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random All** button a second time and see what the program
    looks like. The following screenshot is what we got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make some changes to our program and try running it again. Make
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Ellipse control and name it `Circle4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new textbox control and name it `text4` and set the `Text` property to
    an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another button control and name it `btnRandomFirst` and set the `Content`
    property to `RandomFirst`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an event handler to the button, `btnRandomFirst`, and name it `btnRandomFirst_Click`.
    Add the following code to the event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s compile and run our program. The following is the output before
    an action is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random First** button once and the output should look like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s click on the **Random First** button a second time and look
    at the results. They should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a minute to go through what we just did with this program.
  prefs: []
  type: TYPE_NORMAL
- en: First, our `Worker1` method that performs our *tasks* is a simple worker bee.
    It generates a random number and then does a `Thread.SpinWait` for that number
    of iterations. Then it returns the current time in milliseconds. So, every time
    this method is run as a task in a separate thread, it will run for a random amount
    of time. If multiple copies of this method are running in different threads, then
    they will each finish at a different time because `SpinWait` will run for a different
    randomly generated number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Random All** button, the event handler is fired. The
    event handler starts three separate tasks each running the `Worker1` method using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We created a `Task` array with a string value `TResult` using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we wait on all of the tasks in the tasks array using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we display the results of each task and see that they each have a different
    random number and finish at a different time even though each task is executing
    the same method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we created a second button that does much of the same work except for
    this time instead of the `Task.WaitAll` command, we use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, in this case, we only wait for any of the three tasks to complete before
    continuing execution in our main thread. You can verify this by clicking on the
    **Random First** button many times. Each time it can be either task 0, 1, or 2
    that finishes first.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to play with these two commands and make sure you have a full
    understanding of how each works.
  prefs: []
  type: TYPE_NORMAL
- en: We will not spend time on this book playing with the `Continue`, `ContinueAll`,
    `When`, and `WhenAll` methods of the `Task` class, but take some time to experiment
    with these functionalities. These methods allow you to execute a task when other
    tasks have completed. So, you can chain task executions together. The alternative
    to these is to wait on tasks to complete and then start new tasks. The `Continue`
    and `When` methods allow you to combine this into one statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore canceling tasks. Depending on your requirements,
    you might want to cancel a task that you have started, before it ends.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore canceling a task. Now that we know how to start one or more tasks
    and how to coordinate waiting on one or more of these tasks, what if something
    happens after we have started a group of tasks and we need to stop them?
  prefs: []
  type: TYPE_NORMAL
- en: Task cancellation is accomplished in the .NET framework by using **cancellation
    tokens**. The delegate used when running a task needs to have code to support
    cancelation and then any other code that needs to cancel a task can request cancelation
    of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CancellationToken` structure in .NET manages notification that an operation
    should be canceled. It has a property, `IsCancellationRequested`, that you can
    use to see if a cancellation request has been issued. This structure is a member
    of the `System.Threading` namespace and is used by threads and tasks to manage
    cancellation requests in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: Merely requesting to cancel a task will not cancel the task. The task delegate
    must support cancellation tokens. There are two ways that a delegate can choose
    to cancel. The delegate can simply return from execution, or it can throw an `OperationCanceledException`
    using the `ThrowIfCancellationRequested` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main differences to these two methods of cancelation. If the
    delegate just returns from execution, then the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The task is put in a state of `TaskStatus.RanToCompletion` instead of `TaskStatus.Canceled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code requesting to cancel the task does not know if the task simply finished
    or was canceled before finishing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the task delegate implements the latter method for canceling (throwing an
    `OperationCanceledException`), then the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The task is put in a state of `TaskStatus.Canceled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The requesting code can check this status and determine if the task was canceled
    or just finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, now we will create a WPF application to allow the user to cancel tasks.
    We will demonstrate how to create cancellation tokens, monitor the task state
    to see if it is canceled, and then do some processing when it is canceled. This
    will also use the `Task.ContinueWith` method. This method allows us to execute
    a task when another task has completed.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we will start 10 tasks. Each task will take an integer parameter
    as input and will multiply it by the numbers from 1 to 10 million and take a sum
    of the results. It will then return a `double` value that is the result. While
    this may not be the world's most exciting computation, it will take a little time
    depending on your processor speed.
  prefs: []
  type: TYPE_NORMAL
- en: We will start each task with a task cancelation token pass to it and create
    `ContinueWith` tasks for it. One will *continue with* if the task runs to completion,
    and the other will *continue with* if the task is canceled. We will also have
    a **Cancel** button that allows you to cancel at any time and stop the tasks in
    progress.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up Visual Studio and create a new WPF application called `TaskCancel`.
    In the designer window in the `MainWindow.xaml` file, let's add the following
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two button controls: one named `btnStart` and other named `btnCancel`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add a click event handler for each button: `btnStart_Click` and `btnCancel_Click`
    respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a text block control named `textBlock1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `MainWindow.xaml` file should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, move to the `MainWindow.xaml.cs` code behind the file. Let''s add the
    following items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `using` statement for the `System.Threading` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside the class definition at the top, let''s add our cancelation token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s add a method that will execute inside our 10 tasks. We will call
    this method `AddMultiple`. It takes an integer parameter and returns a value that
    is the datatype `double`. Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s add the code to the click event handler of `btnStart` that will
    start the 10 tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s add the code to the click event handler of `btnCancel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all we have to do. Now, let's compile and run our application. But this
    time, let's not run it through Visual Studio. We will run the application directly.
    Go to the `bin\Release` folder in our project directory and double-click on the
    `TaskCancel.exe` application. We will explain shortly why we are doing this and
    what happens when we run it in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, it should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Start** button. Then click on the **Cancel** button. You
    can decide how fast to click on the **Cancel** button but you should see an output
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you try running it in Visual Studio directly, you will notice that when you
    click on the **Cancel** button, an unhandled exception occurs. You can press *F5*
    a couple of times and it will continue on. But why does this happen?
  prefs: []
  type: TYPE_NORMAL
- en: The `ThrowIfCancellationRequested` method has *cooperative cancellation*. This
    throws an exception to indicate that it has accepted the cancellation requested
    and will stop. This exception is handled by .NET in the TPL and shouldn't be handled
    by your code. Since Visual Studio looks for all unhandled exceptions and shows
    them in debug mode, you will see it when running the application in debug mode
    through Visual Studio. There is a way to turn this off through the **Options-Debugging**
    settings under **Tools**, but we do not recommend it because it can mask other
    exceptions that you want to see. Nevertheless, the exception we encounter here
    is a nuisance when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've successfully canceled running tasks, let's see how we did it.
    First, we defined a cancellation token using `CancellationTokenSourcets`. Then
    we instantiated it using `ts = new CancellationTokenSource()`. This gives us a
    cancellation token that we can work with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's skip, briefly, to the end. To cancel tasks, we just call the token's `Cancel`
    method, `ts.Cancel()`, in the **Cancel** button's click event handler. This will
    indicate to any task, which is using this cancelation token, that they need to
    cancel. Now it is up to the tasks to monitor the token and perform the cancelation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at the **Start** button''s click method. Here, we create
    and start 10 tasks using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the `Task.Factory.StartNew` command and pass it the delegate for
    the task to execute and the cancellation token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we also call the `ContinueWith` command to tell the task what to do after
    it finishes. We set up two of these depending on how the task finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the first one, we pass the parameter, `TaskContinuationOptions.OnlyOnCanceled`,
    and for the second one, we pass the parameter, `TaskContinuationOptions.OnlyOnRanToCompletion`.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the task is canceled, the second `ContinueWith` command is executed and,
    if the task runs to completion, the first `ContinueWith` command is executed.
    In each of these `ContinueWith` commands, we pass a lambda expression to execute,
    which prints the results of the task. This is how we update the UI with the status
    of each task, once it has completed.
  prefs: []
  type: TYPE_NORMAL
- en: From the output you can see which tasks run to completion and which tasks are
    canceled. Also, note that the output is not in sequential order. Since the 10
    tasks are scheduled with the threadpool and the different cores on the machine
    we run have different workloads, the tasks finish in different orders.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at error handling with tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Task exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have learned how to start, coordinate, and cancel tasks. Now, let's
    talk about error handling with tasks. In C#, when we discuss error handling, we
    are really talking about the `try..catch..finally` structure. In this book, we
    assume you are familiar with the operation of a `try..catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: A task has a lifecycle of states that it can be in. A task can be idle (scheduled),
    running, pending, cancelled, faulted, or completed. Each task has a `status` property
    that defines the current state of the task. We saw this in the last section and
    used `OnlyOnCanceled` and `OnlyOnRanToCompletion` as the options for `TaskContinuationOptions`
    for our `ContinueWith` methods.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we talk about exception handling with TPL, we are referring to faulted
    tasks. There are several ways a task can reach a faulted status, for example,
    when the task delegate fails and throws an exception. A **faulted task** is basically
    a task that resulted in an error and carries the exception with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code will incur an exception if you perform one of the following on a
    faulted task:'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting on a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the task's result value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an `Await` on the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when you use the `Wait`, `WaitAll`, `Await`, or `Result` methods of a task,
    you should surround these statements with a `try..catch` block. The first two
    will always throw an exception of the `AggregateException` type, which is a container
    for multiple exceptions. The `Await` will throw the actual exception occurred
    by the task's delegate.
  prefs: []
  type: TYPE_NORMAL
- en: These are the basics of task exception handling. We want to do a `try..catch`
    around the `Result`, `Wait`, or `Await` of a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we start a task and do not care about waiting on it or its results,
    but we want to know if it incurs an exception? How do we know if a start-and-forget
    task has a problem? In this case, we can use a simple technique with the help
    of the `ContinueWith` command. Look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we create a task to execute on a `ContinueWith` command if the
    task is in an `OnlyOnFaulted` state.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can perform exception handling with a `try..catch` on the result while
    waiting on a task or, if you are not waiting on the task or result, you can create
    a `ContinueWith` task to handle the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at ways to wait on a task, cancel, chain, and
    perform exception handling with tasks. We have now covered all of the aspects
    that need to work with tasks in the TPL and the techniques needed to handle all
    of the scenarios your design might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to further explore the techniques presented in this chapter
    and explore the world of task-based parallelism. The days of working directly
    with threads and the `BackgroundWorker` component will soon become a distant memory.
  prefs: []
  type: TYPE_NORMAL
- en: These last two chapters have been an overview of TPL and task-based parallelism.
    In the next chapter, we will cover data-based parallelism and working with data
    collections in a concurrent manner.
  prefs: []
  type: TYPE_NORMAL
