# 七、面向移动应用的 Azure 服务

无论您是处理一个小型的启动应用，还是处理一个企业应用的大量数据，Microsoft Azure 总是一个方便的选择，因为它提供的低成本订阅模型和可伸缩性。 有许多可用的服务在不同的管理服务模式,如**软件即服务(SaaS**),**平台即服务**(****PaaS)和【显示】基础设施作为服务**(**IaaS)。 这些功能包括通知中心、认知服务和 Azure 功能，它们可以改变用户对您的应用的印象，而不需要额外的开发时间。 本章将为您提供关于如何在开发。net Core 应用时使用这些服务的快速概述。****

 **在本章中，我们将使用 Azure 平台上提供的服务来设计我们的服务后端。 我们将首先浏览 Azure 平台上可用的服务，然后继续深入研究数据存储、Azure 无服务器 PaaS 产品，最后是开发服务。 以下主题将指导你完成本章:

*   Azure 服务的概述
*   数据存储
*   Azure Serverless
*   开发服务

在本章结束时，您将熟悉各种利用 Azure 服务的架构模型，并更好地理解如何将这些模型整合到您的移动应用项目中。 我们将仔细研究持久性服务以及 Azure 无服务器服务。 最后，我们将讨论 Azure DevOps 和 Visual Studio App Center。

# Azure 服务概述

我们正生活在云计算的时代。 我们 10 年前学习并应用到应用中的许多软件范例现在已经完全过时了。 为了可维护性和性能，分布式模块已经取代了传统的 n 层应用和开发团队的简单性。

废话少说，让我们开始通过设置架构和探索 Azure 平台的概念来准备应用的范围。

## 分布式系统简介

在本节中，我们将讨论分布式后端系统的不同托管模型，以及这些设置的优缺点。

在本书前几章中，我们开始了客户端应用的开发; 这将需要一些额外的视图和修改。 为了继续开发，我们首先需要设置我们的后端。 对于我们的应用，我们需要一个服务后端，它将做以下工作:

*   提供关于产品的静态元数据
*   管理用户配置文件并维护用户特定的信息
*   允许用户上传和公开共享数据
*   索引和搜索用户上传和共享
*   使用实时更新通知一组用户

现在，把这些需求和我们创建云基础设施的目标放在一边，让我们试着想象一下，我们如何通过一个本地 n 层应用设置来实现一个分布式系统:

![Figure 7.1 – N-tier on-premises backend ](image/Figure_7.01_B16381.jpg)

【t】【t】

图 7.1 - n 层本地后端

在上图所示的设置中，我们有一个 web 层，它向客户端公开封闭的逻辑 n 层结构。 请注意，系统被划分为逻辑层，并且不涉及无线通信。 我们将使用一个本地服务器来维护这个结构。 如果需要扩展，具有负载平衡实现的多个服务器仍然可以工作。 在大多数情况下，同步和规范化将在数据层进行。 从部署和管理的角度来看，每个部署都将导致一个完整的更新(在多个服务器上)。 此外，每个逻辑模块的需求必须单独维护，即使它是一个整体实现，而且不应该因为这些需求而轻视对本地服务器的应用更新。 部署到不同的服务器也必须小心处理。

重要提示

Knight Capital Group 是一家美国全球金融服务公司，专门从事销售和交易的电子执行。 2012 年 8 月，该公司的资产从 4 亿美元一夜之间破产，原因是该公司运营的 8 台服务器中只有 7 台发布了一项新部署。 在这个 45 分钟的噩梦中，正确的部署与旧代码在单个服务器上竞争，导致了 4.6 亿美元的损失。

我们可以轻松地将整个 web 应用移动到云 IaaS**虚拟机**(**虚拟机**)。 然而，这种迁移只会有助于维护，并且扩展仍然必须是在系统级别而不是组件级别。 在这种情况下，瓶颈很可能是数据层，因为伸缩的应用组件只会对数据存储库施加更大的压力。

为了理解这个 n 层设置，让我们仔细看看可能涉及到的组件。 我们将使用一个 SQL 数据库来存储数据，一个消息队列(如 Rabbit MQ 或 MSMQ)和一个 ASP.NET web API 实现。 身份管理可能是一个集成的解决方案，例如 ASP。 净的身份。 通知可以是来自客户端的轮询实现，或者可以考虑在 ASP 中使用 SignalR 实现。 净的 web 应用。 搜索功能可能必须在 SQL Server 级别上才能提高性能。 所有这些都是基于这样一个假设:我们使用的是 Microsoft . net 栈，目标托管平台是 Windows 主机上的 Microsoft IIS 服务器。

接下来，让我们将逻辑模块分解为更小的服务，这些服务可以在**面向服务的体系结构**(**SOA**)生态系统中相互通信

![Figure 7.2 – Microservice Setup ](image/Figure_7.02_B16381.jpg)

图 7.2 -微服务设置

与图 7.1 中的*相比，前面截图中的设置要轻一些，图 7.1*中的每个组件都可以独立开发和部署(也就是说，与系统中的其他元素解耦)。 从维护的角度来看，每个服务可以部署到单独的服务器或虚拟机上。 反过来，它们可以相互独立地进行缩放。 而且，这些服务中的每一个现在都可以被容器化，这样我们就可以完全将服务从操作系统中分离出来。 毕竟，我们只需要有一个 web 服务器，我们的服务集可以在其中托管和服务给客户端。 在这一点上，. net Core 将把我们的应用变成一个跨平台的 web 模块，允许我们同时使用 Windows 和 Unix 容器。 这整个过程可以被标记为从 IaaS 策略迁移到 PaaS 方法。 此外，应用现在可以实现一个**基础结构作为代码**(**IaC**)结构，在这个结构中，我们不需要担心应用正在运行的服务器的当前状态。

嗯，这听起来很棒，但是它与云架构和 Azure 有什么关系呢? 创建云就绪应用的主要目的是创建具有功能独立的模块的应用，这些模块可以由适当的、可维护的和可伸缩的云资源托管。 在这一点上，我们不再谈论单个应用，而是一组为各种应用需求携手工作的资源 ts:

![Figure 7.3 – Azure PaaS Setup ](image/Figure_7.03_B16381.jpg)

图 7.3 - Azure PaaS 设置

在前面的分布式模型图中，每个组件都由简单的 PaaS 服务组成，它们之间没有直接依赖关系。 这些组件是完全可扩展的，只要满足系统要求，就可以更换。 例如，如果我们从一个小的 web API 应用服务开始，它可能驻留在一个应用服务计划中。 然而，如果满足了这些需求，那么我们就可以用 Azure 的功能实现来替换这个微服务，它将改变部署模型和执行运行时，但仍然保持系统的完整性。 总的来说，在云模型中，单个组件的可替换性(只要整个系统处于检查状态)将风险和维护工作降到最低。

回到我们的需求，我们可以在关系数据库(如 SQL Server PaaS)或使用 Cosmos DB 的 NoSQL 设置之间自由选择。 此外，我们可以通过在数据存储和 web 网关之间使用 Redis 缓存来提高性能。 搜索功能可以使用 Azure 搜索索引执行，应用服务和 Azure 函数可以用于 API 层。 此外，一个简单的 ESB 实现或 Azure 持久函数可以帮助实现长时间运行的异步操作。 最后，通知可以通过使用 Azure SignalR 或通知中心来执行。

当然，资源的选择很大程度上取决于所选择的体系结构方法。

## 云架构

在本节中，我们将分析云托管分布式应用和相关 Azure 服务产品的几种架构模式。

在云平台中，系统的设计由单个组件组成。 虽然应该分别设计和开发每个组件，但这些组件的组合方式应该遵循特定的体系结构模式，这些模式将允许系统提供弹性、可维护性、可伸缩性和安全性。

特别是对于移动应用，下面的一些组合模型有助于应用的成功。

为了关联这些模式，我们将讨论我们的 ShopAcross 应用，所以让我们定义一个新的用户故事，我们将在接下来的部分工作:

*作为产品所有者，我想引入一个拍卖功能，用户可以为他们的商品创建帖子，比如要拍卖的车辆，这样我就可以增加我的应用的目标群体。*

该特性增加了对应用持久性存储的数据输入/输出，并增加了后端服务的复杂性。 现在让我们看看几个可以帮助我们实现这一目标的模型。

### 门户聚合

在微服务设置中，应用由多个域组成，每个域实现自己的微服务对等体。 由于域是隔离的，因此可以通过执行对后端服务的多个调用来构造客户机应用视图所需的数据。 在一个不断发展的应用生态系统中，这将及时将业务层的所有复杂性推到客户端应用中。 虽然这对于 web 应用来说仍然是可以接受的，但移动应用的性能将随着系统复杂性的增长而降低。 为了避免这个问题，可以在客户端应用和微服务之间放置一个网关服务 façade:

![Figure 7.4 – Gateway Aggregation Setup ](image/Figure_7.04_B16381.png)

图 7.4 -网关聚合设置

让我们考虑在应用中应用相同的逻辑。 让我们假设拍卖车辆的数据由一个 API(业务项)处理，车辆的元数据由另一个 API(静态数据)处理，用户信息通过另一个 API 提供，最后，我们有一个投标 API。 虽然这种设置为微服务设置提供了必要的隔离，但它要求客户端应用执行多个服务调用来查看和/或创建单个发布。 在这样的场景中，可以使用网关来编排微服务，以便客户机应用可以免除此责任。

事实上，如果我们计划将 web 应用作为客户端来支持，那么数据模型和服务编排可能与移动应用不同。 在这种情况下，我们需要考虑为每个客户端应用创建单独的网关，从而降低单个超级网关的可维护性成本。

### 后端,前端

在多客户端系统中，每个客户端可能需要以某种方式聚合数据。 这将取决于目标平台资源、技术可行性和用例。 在这种场景中，需要网关 API 为不同的微服务和数据组合公开多个服务端点。 相反，每个客户端应用可以通过单独的网关提供数据，从而减少通过单个 façade 支持多个客户端应用的复杂性:

![Figure 7.5 – Backends for frontends ](image/Figure_7.05_B16381.jpg)

图 7.5 -前端的后端

在前面的示例中，我们设置了三个单独的网关(换句话说，是 Gate-A、Gate-B 和 Gate-C)，以支持三个不同的客户机应用。 每个网关实现自己的聚合模型，而不是创建一个复杂的 façade，其中充满了特定于客户端的调整。

例如，让我们假设我们的应用开发团队在一个针对 iOS 和 Android 平台的原始移动应用之上实现了一个 UWP 应用。 在这种情况下，UWP 视图将在更大的设计范围内查看，并且数据需求将不同于移动应用。 对于一个简单的解决方案，网关 API 端点现在可以使用参数来扩展，以限制或扩展响应中返回的对象树(即，info、normal 或 extended)，或者可以引入额外的`Get{Entity}Extended`端点。 然而，通过这种方式，在最小化客户端应用复杂性的同时，我们正在导致网关的增长，并降低了这一层的可维护性。 如果我们引入单独的网关，我们将为已经拥有单独应用生命周期的客户端分离这些 api 的生命周期。 这可以帮助创建一个更易于维护的系统。

但是，如果在整个客户机应用的执行过程中有某些重复的组合或聚合，该怎么办? 这些重复模式可以解释为数据设计问题，其中数据隔离导致性能下降。 事实上，如果微服务设置需要这些领域分离，那么我们将需要在数据存储级别上提出一个数据组合。

### 物化视图

某些数据维度的聚合可以在数据存储级别上完成。 事实上，作为具有 SQL 背景的开发人员，我们熟悉可以由多个关系表组成的 SQL 视图，并且可以在数据存储级别上进行索引。 虽然这提供了对可用数据的不同视角，但它甚至可以创建多个特定于领域的数据模型的聚合。 尽管如此，这些视图仍然只是一个运行时抽象。 此外，如果持久性存储分散在多个服务器上，我们将需要一个独立的进程来同步域存储和另一个聚合存储之间的数据，并持久化非规范化的数据。 换句话说，具体化视图。 类似的策略可以应用于 Cosmos 等 NoSQL 数据库。

例如，可以使用 Azure Cosmos DB 更改提要在 Cosmos DB 上执行这个数据反规范化过程。 一个文档集合上的更改可以跨多个集合进行同步，这些集合为执行各种搜索或聚合数据定量进行了优化:

![Figure 7.6 – Denormalized data with Azure Functions ](image/Figure_7.06_B16381.jpg)

图 7.6 - Azure 函数的反规范化数据

例如，回到我们的拍卖功能，当我们处理搜索功能时，我们将对多个文档集合执行搜索; 也就是说，用户将需要根据车辆、拍卖数据、出价和个人资料数据进行搜索。 换句话说，不同维度上的数据点都应该通过内部连接用于搜索执行。 这可以通过使用车辆岗位的汇总表来实现，允许可搜索字段在集合之间同步。

### cache-aside 模式

缓存是另一个可以帮助提高应用性能的因素，也就是说，我们缓存的数据类型和我们缓存这些信息的应用层。 cache-aside 模式是一个多路复用器的实现，它将处理缓存存储和数据存储之间的数据一致性，这取决于传入的请求和数据寿命:

![Figure 7.7 – Cache-aside Implementation ](image/Figure_7.07_B16381.jpg)

图 7.7 - Cache-aside 实现

在这种设置中，首先在缓存存储中搜索带有特定惟一标识符(例如`{EntityName}_{EntityId}`)的传入请求，如果没有，则从数据存储中检索并插入到缓存中。 通过这种方式，下一个请求将能够从缓存中检索数据。

在缓存还是不缓存的困境中，数据熵可能是一个基本的决定因素。 例如，缓存静态引用项的数据可能是有益的; 然而，缓存拍卖信息，其中的数据是不纯的，并且对相同数据点的重复请求比静态引用更不可能，不会为系统提供额外的价值。

缓存边策略也可以在客户端使用本地存储(如 SQLite)来实现。 有时，在服务器端缓存某个没有意义的文档集合可以在客户端缓存。 例如，当前用户的特定车型和模型的车辆元数据可能是重复请求模式; 然而，考虑到该数据的熵以及其他用户对同一项的访问频率，它不会是一个服务器缓存维度。

### 基于队列的负载均衡

消息队列不是一个新概念，也不是云架构所独有的。 然而，在具有微服务的分布式系统中，它们可以帮助解耦服务，并允许您控制资源的利用。 为可伸缩性和性能而设计的无服务器组件，如 Azure Functions，可以为云基础设施中的工作队列提供优秀的消费者。

例如，让我们考虑一个应用用例，其中注册用户正在创建一个拍卖项目。 他们已经选择了车型和型号，添加了额外的信息，甚至还添加了几张照片。 此时，如果我们允许将拍卖项目的发布作为一个同步请求，我们将把管道中的某些模块锁定为单个请求。 首先，请求需要在数据存储中创建一个文档; 但是，系统中还会触发其他功能来处理映像、通知订阅的用户，甚至启动内容管理员的审批流程。 现在，假设这个请求由应用的多个用户执行(例如，多个注册用户创建多个帖子)。 这将导致资源利用率达到峰值，进而将应用的恢复力和可用性置于风险之中。

作为这个问题的解决方案，我们可以创建一个消息队列，由 Azure 函数使用，它将协调拍卖数据的创建。 消息队列可以是企业服务总线，也可以是 Azure sto 狂暴队列:

![Figure 7.8 – Queue-based request processing ](image/Figure_7.08_B16381.jpg)

图 7.8 -基于队列的请求处理

这听起来很棒，但是这个实现如何影响客户端实现? 客户机应用需要实现一种轮询策略来检索异步作业的状态，或者可以使用推拉机制来通知它，在推拉机制中，服务器将在进程排队之前首先发送拍卖 ID。 然后，当它完成时，服务器可以用相同的 ID 通知客户机，允许它提取完成的服务器数据。 此时，可以存储本地版本的数据并将其提供给用户，直到实际的服务器数据可用为止。 对于这种类型的通知，可以使用 Azure SignalR 或 Notifications Hub 等通知机制。

### 竞争消费者

在前面的示例中，我们使用 Azure 函数作为消息队列的消费者。 这种方法已经可以作为竞争消费者的实现来接受，其中提供的消息队列由多个工作模块处理。

虽然这将提供可伸缩需求并允许性能执行，但作为产品所有者，我们将无法控制创建来使用消息队列中的事件的函数实例。 为了能够控制和管理队列，可以引入消息代理机制，该机制将控制进入队列的消息流。 消息被推入队列后，多个使用者可以检索、处理和完成消息。

### 发布者/订阅者的模式

让我们假设我们已经完成了代理队列的实现，并分派了一个使用者来完成一个长时间运行的操作。 此时，正如前面提到的，我们的应用正在期待一个完成信号，以便摆脱任何瞬时数据。

在一个开放的系统,就像我们在实施的过程中,每个服务可以相互通信(而不是一个封闭的系统,执行顺序处理下游),我们面对的不再是一个确定性的同步模型,然而系统的消费者仍然期望结果。 为了允许源系统(即发布者)将操作的输出传播给相关方(即订阅者)，可以建立输出通道。 这个实现模式可以归因于发布者/订阅方模式(也称为发布/订阅模式)。

回到我们的异步 web 请求，输出通道然后将结果传递给通知模块，并将结果传递给客户端应用。

同样的模式实现可以通过使用服务总线的另一个消息队列或者使用 Azure 基础设施 EventGrid 上的 pub/sub 模式的实际实现来建立。 这些服务中的任何一个都可以允许长时间运行的流程的输出向相关方散开，比如一个 Azure 函数，它将在 Azure SignalR 上推送通知消息或触发消息。

### 断路器和重试模式

在一个云系统中，涉及多个移动的块，很难避免失败。 在这种情况下，系统的弹性取决于它从故障中恢复的速度和频率。 断路器和重试模式是微服务生态系统中通常引入的互补模式。 如果即将发生故障，可以使用断路模式来减少系统的时间和资源。 在这些类型的情况下，最好允许系统尽早失败，而不是推迟失败，以便由辅助进程处理故障或启动故障转移机制。

例如，如果我们有一个容易超时的服务(例如，负载过重或由于外部服务故障)，可以实现一个断路器，以在闭路状态下连续监视传入的请求。 对于客户端应用，可以无缝地重试失败。 当后续的故障发生时，电路可以暂时处于半开或开的状态，这样下面的请求在不尝试执行的情况下立即被丢弃(知道它可能会失败，直到问题得到解决)。 在这种状态下，客户端应用可以禁用该特性，或者，如果实现了故障转移/解决方案，则可以使用该实现。 一旦电路开放状态过期，系统可以重新引入这个端点，首先是半开放状态，最后是关闭状态，系统就被说成痊愈了。

内置的 Azure 监控功能以及应用遥测功能可以提供警报和通知，这有助于维护 Azure 应用。

## Azure 服务提供商和资源类型

在前面的小节中，我们分析了各种模型并提到了几种 Azure 产品。 在本部分中，您将了解 Azure 生态系统中这些服务产品是如何组织的。

Azure 生态系统及其提供的不断增长的服务集允许开发人员轻松地创建各种分布式云应用。 正如我们在*云架构*一节中看到的，许多 PaaS 和 SaaS 产品通过设计可伸缩和有弹性的应用，为日常问题创建了一个解决方案目录。

通过快速查看服务目录(不完整)，您会注意到每个服务都是作为提供者类别的一部分提供的:

![Figure 7.9 – Azure service offerings ](image/Figure_7.09_B16381.jpg)

图 7.9 - Azure 服务提供

每个类别中的服务由一个或多个服务提供商提供。 这些目录中的每个服务都进行了版本管理，以便 Azure Resource Manager 能够处理这些服务的供应。

为了可视化同一屋檐下可用的提供商数量，你可以使用 Azure PowerShell 模块:

```
Get-AzResourceProvider -ListAvailable | Select-Object ProviderNamespace, RegistrationState 
```

这将返回一组可供您订阅的提供商。 这些提供商可以是微软提供的模块或第三方提供的:

![Figure 7.10 – Microsoft Azure providers ](image/Figure_7.10_B16381.jpg)

图 7.10 - Microsoft Azure 提供商

重要提示

Microsoft Azure 文档提供了有用的 Azure PowerShell 命令，这些命令可以直接在 Cloud Shell 中执行，而无需使用 PowerShell(在 Windows 上)或 Bash(在 Linux 或 macOS 上)。 此外，跨平台版本 PowerShell (Core)在非 windows 操作系统上也可用，它利用了。net Core。

如果你潜水到一个特定的名称空间,例如,`Microsoft.Compute`提供者名称空间,你可以得到一个更好的提供的服务的概述,和这些资源的地理区域中可以看到 f 问题从截图:

![Figure 7.11 – Microsoft.Compute provider services ](image/Figure_7.11_B16381.jpg)

图 7.11 -微软。 计算提供者服务

在 Azure 资源组中，`Resource`类型定义了我们真正需要的资源以及该资源的版本。 这些资源定义，如果作为资源组**Azure 资源管理器**(**ARM**)模板的一部分准备，就构成了我们的声明式 IaC。

ARM 是一个平台服务，它允许在订阅中提供资源。 它公开了一个 web API，可以使用 PowerShell、Azure CLI 和 CloudShell，以及 Azure 门户本身。 资源管理器模板中使用的声明式语法提供了一致的、幂等的部署体验，这允许开发人员和自动化工程师自信地管理基础设施生命周期。

在本节中，讨论了几种分布式应用模型以及体系结构模式。 我们还简要地看了一下 Azure 提供目录中的资源组和提供者。 在下一节中，我们将重点讨论 Azure 上可用的持久性存储服务。

# 数据存储

定义域并创建我们的分布式系统将要构建的体系结构，从决定持久性存储开始。 反过来，可以定义数据域，并指定访问模型。 在大多数情况下，这个决策不需要局限于单个数据存储，但是系统可以使用多种数据类型和不同的数据存储。 Azure 平台提供了具有不同数据管理概念和特性集的各种资源。 选择最适合应用需求并考虑成本和管理的数据存储模型是很重要的。 现在让我们看看这些不同的模型以及何时使用它们。

## 关系数据库资源

关系数据库可能是数据存储中最重要的应用。 事务一致性实现原子**,**的**,**,**持久【显示】(****酸)原则为开发人员提供了一个强大的保证一致性。 然而，从可伸缩性和性能的角度来看，在大多数情况下，常见的 SQL 实现(如 MSSQL 或 MySQL)比 NoSQL 数据库(如 Mongo 和 Cosmos DB)的性能要好。 Azure SQL Database、Azure Database for MySQL 和 PostgreSQL 在 Azure 平台上都可以作为 IaaS 和 PaaS 产品。******

 **在 PaaS 资源模型中，数据库的操作成本和可伸缩性是通过一个称为**数据库事务单元**(**DTU**)的单元来处理的。 这个单元是一个抽象的基准测试，它使用 CPU、内存和数据 I/O 度量来计算。 换句话说，DTU 不是一个精确的度量，而是根据上述度量的标准化值。 微软提供了一个 DTU 计算器，它可以根据在实时数据库上收集的性能计数器来估计 DTU 的使用情况。

从安全性的角度来看，Azure SQL 数据库有几个高级特性。 这些安全特性可用于不同级别的数据可访问性:

*   网络安全由防火墙维护，访问权限由 IP 和虚拟网络防火墙规则显式授予。
*   访问管理实现包括 SQL 认证和 Azure Active Directory 认证。 安全权限可以像数据表和行一样进行粒度化。
*   威胁保护可以通过日志分析和数据审计以及威胁检测服务提供。
*   通过不同级别的数据屏蔽和加密进行信息保护，保护了数据本身。

正如您所看到的，作为最保守的数据模型之一，它在 Azure 平台上仍然非常流行，可以作为 IaaS 和 PaaS 产品使用。 现在我们已经讨论了关系数据库，让我们转向更“自由”的 NoSQL 数据存储模型。

## Azure 存储

Azure 存储模型是云生态系统中最古老的服务之一。 它是一个 NoSQL 存储，为开发人员提供了一个持久的、可伸缩的持久层。 Azure 存储由四个不同的数据服务组成，每个服务都通过 HTTP/HTTPS 和一个完善的 REST API 进行访问。

让我们仔细看看 Azure 存储中可用的这些数据服务。

### Azure 斑点

Azure Blob 存储是为非结构化数据提供的云存储。 blob 可用于存储任何类型的数据块，如文本或二进制数据。 Azure Blob 存储可以通过为创建的存储帐户提供的 URL 访问:

`http://{storageaccountname}.blob.core.windows.net`

每个存储帐户至少包含一个容器，用于组织创建的 blob。 三种类型的 blob 用于不同类型的数据块上传:

1.  **块斑点**:这些是为大二进制数据设计的。 一个块块的大小可以达到 4.7 TB。 每个块块由更小的数据块组成，这些数据块可以单独管理。 每个块可以容纳高达 100 MB 的数据。 每个块应该定义一个块 ID，它应该符合 blob 中特定的长度。 块块可以看作是离散的存储对象，比如本地操作系统中的文件。 它们通常用于存储单个文件，如媒体内容。
2.  **页团**:当需要随机读写操作时，使用。 这些斑点由 512 字节的页面组成。 一个页面 blob 可以存储高达 8tb 的数据。 为了创建一个页面 blob，应该指定一个最大的大小。 然后，通过指定与 512 字节页面边界对齐的偏移量和范围，可以在页面中添加内容。 存储在云中的 vhd 非常适合页面团的使用场景。 事实上，为 Azure VM 提供的持久磁盘是基于页面 blob 的(也就是说，它们是 Azure IaaS 磁盘)。
3.  **追加斑点**:正如名称所示，这些是仅追加斑点。 它们不能被更新或删除，并且不支持对单个块的管理。 它们经常用于记录信息。 一个附加 blob 可以增长到 195 GB。

如您所见，blob 存储，特别是块 blob，是存储应用图像内容的理想选择。 Azure Storage Client 库方法为 blob 提供了对 CRUD 操作的访问，可以直接在客户端应用中使用。 然而，通常使用后端服务来执行实际的上传到 blob 存储是一种安全感知的方法，这样 Azure 安全密钥就可以保存在服务器中而不是客户机中。

### Azure 文件

Azure 文件可以视为一个云托管的文件共享系统。 可以通过**服务器消息块**(**SMB**)访问它，也称为 Samba，并允许在混合(即本地和云)场景中使用存储资源。 使用网络共享文件夹(甚至本地文件)的遗留应用可以很容易地指向 Azure 文件网络存储。 Azure 文件，就像任何其他 Azure 存储数据服务一样，可以通过 REST API 和 Azure 存储客户端库访问。

### Azure 队列

为了实现异步处理模式，如果您不追求高级功能和队列一致性，那么 Azure 队列可以成为服务总线之外的划算的替代方案。 Azure 队列可以更大，更容易实现和管理，以实现更简单的用例。 与服务总线类似，Azure 队列消息也可以与 Azure 函数一起使用，其中每个消息触发一个 Azure 函数来处理处理。 如果不使用触发器，那么只有轮询机制可以处理消息队列。 这是因为，与服务总线不同，它们不提供阻塞访问或事件触发机制，如服务总线上的`OnMessage`。

### Azure 表

Azure 表是一个 nosql 结构的云数据存储解决方案。 Azure 表存储的实现遵循一种**键值对**(**KVP**)方法，其中没有公共模式的结构化数据可以存储在表存储中。 Azure Table 存储数据可以很容易地在 Azure 门户上可视化，并且通过其他 Azure 存储服务等 Azure storage 客户端库支持数据操作。 然而，Azure 表存储现在是 Azure Cosmos DB 的一部分，可以使用 Cosmos DB 表 API 和 SDK 访问。

## Cosmos DB

Cosmos DB 是微软在 Azure 云上提供的 multi-façade，全球分布式数据库服务。 Azure Cosmos DB 的主要优点是可伸缩性和可用性，因此它是任何基于云计算的项目的强有力的候选人。 作为一个写优化的数据库引擎，它保证在全球范围内 99%的读/写查询上的延迟小于 10 毫秒。

Cosmos DB 为开发人员提供了五种不同的一致性模型，以根据需求在性能和可用性之间实现最佳折衷。 所谓的一致性频谱定义了强一致性和最终一致性之间的不同级别，或者换句话说，更高的可用性和更高的吞吐量。

尽管它被设计为 NoSQL 存储，但它确实支持各种存储模型协议，包括 SQL。 这些存储协议支持使用现有的客户端驱动程序和 sdk，并且可以无缝地替换现有的 NoSQL 数据存储。 每个 API 模型也可以通过 gh 使用可用的 REST API:

![Figure 7.12 – CosmosDB Access Models ](image/Figure_7.12_B16381.jpg)

图 7.12 - CosmosDB 访问模型

由于它提供了各种访问模型，CosmosDB 正在成为 Azure 平台上数据持久性的首选服务。 但是，如果我们要处理的数据比我们在长期持久性存储中存储的数据类型更不稳定，该怎么办呢? Azure 缓存的 Redis 可以是一个伟大的解决方案，临时数据是使用在这些类型的场景。

## Azure Cache for Redis

Azure Cache for Redis 是一个提供类似 Redis 的内存数据结构存储的提供商。 通过减少实际持久性存储的负载，它有助于提高分布式系统的性能和可伸缩性。 使用 Redis，数据存储为 kvp，由于其复制特性，它也可以用作分布式队列。 Redis 支持以原子方式执行事务。

在 Azure Cache 的帮助下，我们将在应用后端使用缓存模式来实现 Redis。

在本节中，我们浏览了 Azure 上用于数据存储的 PaaS 产品。 在下一节中，我们将了解另一个对分布式系统的可维护性和成本有很大帮助的 PaaS 服务:Azure 无服务器。

# Azure 无服务器

您可能已经注意到，在现代云应用中，PaaS 组件比 IaaS 资源更丰富。 在这里，应用虚拟机被更小的应用容器取代，数据库作为平台取代了集群数据库服务器。 Azure 无服务器将基础设施和平台管理向前推进了一步。 在无服务器资源模型(如 Azure Functions)中，事件驱动的应用逻辑在由平台本身提供、扩展和管理的平台上按需执行。 在 Azure 无服务器平台中，事件触发器可以从消息队列到网络钩子等多种多样，可以内在地集成到生态系统中的各种资源中。

## Azure 功能

Azure 功能是管理的、事件驱动的逻辑实现，可以为云架构提供轻量级的特别解决方案。 在 Azure 函数中，工程团队不仅忽略了执行基础设施，也忽略了平台，因为 Azure 函数是用。net Core、Java 和 Python 跨平台实现的。

Azure 函数的执行从触发器开始。 Azure 功能支持多种执行模型，包括:

1.  **数据触发器**:`CosmosDBTrigger`、`BlobTrigger`
2.  **周期触发器**:`TimerTrigger`
3.  **队列触发**:`QueueTrigger`，`ServicesBusQueueTrigger`，`ServiceBusTopicTrigger`
4.  **事件触发**:`EventGridTrigger`和`EventHubTrigger`

Azure 函数的触发器在函数清单/配置中定义:`function.json`。

触发器一旦实现，函数运行时就执行 Azure 函数的 run 块。 传递给运行块的请求参数(即输入绑定)由所使用的触发器决定。

例如，下面的函数实现是由 Azure 存储队列中的一个消息条目触发的:

```
public static class MyQueueSample 
{ 
    [FunctionName("LogQueueMessage")] 
    public static void Run(
        [QueueTrigger("%queueappsetting%")] string 
         queueItem, ILogger log) 
    { 
        log.LogInformation($"Function was called with: 
        {queueItem}");
    } 
}
```

输出参数(即输出绑定)也可以定义为函数声明中的`out`参数:

```
public static class MyQueueSample 
{ 
    [FunctionName("LogQueueMessage")] 
    public static void Run(
        [QueueTrigger("%queueappsetting%")] string 
         queueItem,
        [Queue("%queueappsetting%-out")] string outputItem 
        ILogger log) 
    { 
        log.LogInformation($"Function was called with: 
        {queueItem}");
    } 
}
```

注意，`[Queue]`属性在 Azure 函数的队列存储绑定中用作输出绑定，它将在另一个队列中创建一个新的消息条目。 对于 Azure 函数，还有更多类似的开箱即用绑定类型。

重要提示

在这些例子中，我们使用了 c#和。net Standard 来创建已编译的 Azure 函数。 基于脚本的 c#、Node.js 和 Python 也是使用类似方法创建函数的选项。

从概念上讲，Azure 函数可以被视为逐调用的 web 服务。 然而，作为 Azure 函数的扩展，持久性函数允许开发人员创建持久性(即有状态的)函数。 这些函数允许您使用检查点编写有状态函数，其中编排器函数可以分派无状态函数并执行工作流。

Azure 函数既可以作为在特定触发器上执行业务逻辑的单个模块使用，也可以作为一组强制工作流(使用持久函数)使用; 或者，它们可以作为**Azure Logic Apps**的处理单元。

## Azure Logic 应用

Azure Logic 应用是声明式工作流定义，用于编排任务、流程和工作流。 与函数类似，它们可以与许多其他 Azure 资源以及外部资源集成。 逻辑应用是使用 JSON 应用定义模式创建、版本控制和配给的。 Azure 门户的和 Visual Studio 都提供了设计器:

![Figure 7.13 – Logic app designer ](image/Figure_7.13_B16381.jpg)

图 7.13 -逻辑应用设计器

逻辑应用的任务不仅限于 Azure 功能，还包括所谓的商业和/或第三方连接器(例如，使用 Twilio 发送短信，使用 SendGrid 发送电子邮件，或发布 Tweet)。 此外，**企业集成包**(**EIP**)提供行业标准消息传递协议。

与 Azure 函数一样，逻辑应用的执行从触发器开始，每个输出步骤都存储在执行上下文中。 处理块，如条件、开关和`foreach`循环在应用流中是可用的。 此外，逻辑应用工作流可以通过**Azure 事件网格**事件进行调度。

## Azure 事件网格

Azure Event Grid 是一个基于云的事件聚合实现，它支持发布/订阅事件路由策略。 事件网格由事件源(即发布者)和事件订阅(即使用者)组成:

![Figure 7.14 – Event Grid actors ](image/Figure_7.14_B16381.jpg)

图 7.14 -事件网格参与者

与 Azure 函数触发器类似，开发人员可以使用各种事件源，Azure 事件网格可用于将某些事件从一个 Azure 资源路由到另一个 Azure 资源，或将某些事件多播。 事件不需要由系统资源触发，但也可以使用 HTTP 请求创建事件，从而允许自定义模块向消费者发送事件。

使用事件网格，我们完成了本节。 在本节中，我们讨论了 Azure 函数和逻辑应用，最后讨论了事件网格，它可以用作应用中使用的其他 Azure 组件之间的中介。 现在我们已经浏览了可以在应用中使用的服务，接下来让我们看看可以帮助我们管理项目生命周期的服务。

# 开发服务

Azure 资源不仅仅局限于应用生命周期中提供和维护的应用需求。 它们还包括某些用于实现应用生命周期和开发管道的平台服务，例如 Azure DevOps 和 Visual Studio App Center。 在本节中，我们将了解这些免费增值服务，在本书的其余部分中，我们将使用它们来管理应用的开发和部署。

## Azure DevOps

AzureDevOps(以前称为 TFS 在线或 Visual Studio 团队服务),开始在微软**应用生命周期管理**(**ALM)本地产品套件 TFS,现在是利用最广泛的免费商业模式管理门户。 Azure DevOps 实例可以从 Azure Portal 创建，也可以通过 Azure DevOps 门户创建。 这个采购过程从创建 DevOps 组织开始。**

一旦创建了组织，就可以创建一个包含源控制存储库和待办事项列表的新项目。 在项目设置的**Advanced**部分中，可以使用中的 ALM 过程和版本控制选项:

![Figure 7.15 – Azure DevOps project setup ](image/Figure_7.15_B16381.jpg)

图 7.15 - Azure DevOps 项目设置

需要指出的是，TFVC 和 Git 存储库是同时可用的。 一个单独的 Azure DevOps 项目可能包含多个存储库。 由于跨平台支持和与 ide(如 Visual Studio Code 和 Visual Studio for Mac)的集成，以及本地 ide(如 Android Studio)的集成，Git 通常是 Xamarin 和本地移动开发者的首选存储库类型。

Azure DevOps 上的 DevOps 实现提供了广泛的特性集。 Azure 门户(除了概述)分为五个主要部分，如下:

*   董事会(项目管理)
*   回购(版本控制)
*   管道(CI / CD)
*   测试计划(测试管理)
*   工件(包管理)

根据免费订阅模式，一个项目最多可以免费包含 5 个贡献者。 额外的团队成员将需要具有有效的 Visual Studio 或**Microsoft Developer Network**(**MSDN**)许可证，否则他们将被分配给只读的涉事者角色。

## Visual Studio App Center

Visual Studio App Center 是一套工具，它将移动开发人员使用的各种开发服务(如 Xamarin、Native 和 Hybrid)捆绑到一个管理门户中。 App Center 与 Azure DevOps 紧密集成，它们可以相互配合使用。 App Center 支持多种应用平台，这些平台具有多种特性:

![Figure 7.16 – App Center platforms ](image/Figure_7.16_B16381.jpg)

图 7.16 - App Center 平台

从 CI/CD 的角度来看，App Center 允许使用来自各种存储库系统(如 Azure DevOps 和 GitHub)的源工件来构建移动应用。 应用可以使用开箱即用的构建模板进行编译，应用包可以分发给指定的组，而不需要使用任何其他存储。

准备好的应用包还可以通过 UI 测试进行自动验收测试。 自动化 UI 测试支持多个测试运行时，例如 Xamarin。 外的和 Appium。

最后，可以从移动应用的 beta 版和生产版收集应用遥测和诊断数据，并将有价值的应用反馈重新引入 backlog 中。 推送通知是另一个有价值的功能，可以用来吸引应用用户。

App Center 也采用免费订阅模式，其中的构建和测试时间受到订阅的限制; 然而，CI/CD 特性的有限使用和无限的分发特性是免费的。

# 总结

总的来说，使用紧密集成的 Azure 模块，现在开发分布式应用要容易得多。 云应用和混合应用都可以使用可用的资源和通过。net Core 堆栈实现的模块来创建。 同样重要的是要记住，资源不应该定义应用需求; 相反，应该设计一个最佳的解决方案，同时考虑到可用的模块、需求和成本。

在本章中，我们讨论了云环境中的各种应用模型和架构模型。 我们还浏览了可用的 Azure 资源，这些资源将在接下来的章节中用于创建我们的应用后端。 在下一章中，我们将使用 Cosmos DB 创建我们的数据存储。****