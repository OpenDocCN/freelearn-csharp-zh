- en: Dependency Injection System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is the basic building block of ASP.NET Core. This chapter
    shows how you can use dependency injection in order to resolve the dependencies
    of the classes inside an ASP.NET Core application. It also describes how you can
    deal with the dependency injection life cycle, and it provides some examples of
    how to keep the classes loosely coupled. The first part of this chapter will give
    you some basic theoretical ideas about dependency injection, while the second
    part will show you how to use it in any ASP.NET Core project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why implement the dependency injection pattern in real-world applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the dependency injection life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement dependency injections in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *dependency inversion principle* is part of the SOLID principles that were
    established by Robert C. Martin. The purpose of the SOLID principles is to provide
    some guidelines to developers on how to design code in a way that is more understandable,
    flexible, and maintainable. The dependency inversion principle, in particular,
    affirms that a high-level component should not depend directly on an individual
    component that is concentrated on a precise procedure (low-level component); instead,
    they should depend on an abstraction. Therefore, abstractions should not depend
    on any implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: A low-level component usually performs simple operations and provides simple
    functionalities. A high-level component, on the other hand, manages a set of individual
    components by orchestrating them. Real-world systems typically have more than
    two levels of abstractions. The concept of a high-level component is relative
    to the subject module; therefore, a high-level component for one component might
    be a low-level component for another. The concept of *abstraction* is particularly
    prevalent when we talk about SOLID principles. An abstract component is usually
    an interface or an abstract class. Therefore, it is an element that does not have
    any concrete implementation. In summary, the *dependency inversion principle*
    states that every element inside our application should only refer to *abstractions.*
    Let's look at a concrete example of the *dependency inversion principle* that
    has been applied to a system. The schema describes an add-to shopping bag e-commerce
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is composed of three different classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AddToShoppingBagHandler` handles the requests from the client and sends
    information to `PaymentService`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PaymentService` manages information about payment methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CurrencyConverter` component provides conversions between different currencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram describes the standard sequence of processing the preceding
    mentioned classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7b87f01-066f-4e46-aa2c-e27cc7e89647.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we apply the dependency inversion principle, the direction of our dependencies
    will change. To be compliant with the dependency inversion principle, we should
    introduce some abstractions between our components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f52ceb7-1d44-485c-87e9-127e2f8f7682.png)'
  prefs: []
  type: TYPE_IMG
- en: By comparing the two schemas, we deduce that the direction of the dependencies
    are inverted. The `AddToShoppingBagHandler` class now uses the `IPaymentService`
    interface, and the `PaymentService` type is the concrete implementation of the
    `IPaymentService` interface*.*
  prefs: []
  type: TYPE_NORMAL
- en: However, this schema is not yet complete. Moreover, it is not yet compliant
    with the second statement of the dependency inversion principle. We should make
    sure that our abstractions don't depend on the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, if we think in terms of architectural boundaries, our schema
    changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fc9cc77-5198-4a08-a0db-1ed23a81f705.png)'
  prefs: []
  type: TYPE_IMG
- en: Each rounded rectangle represents a boundary. The classes and the abstractions
    within the same rectangle are part of the same boundary. In the .NET ecosystem,
    each border is a project, and our interfaces are the bridge between high-level
    and low-level classes.
  prefs: []
  type: TYPE_NORMAL
- en: A common inaccuracy is to place the interfaces and the implementation classes
    within the same boundary. In .NET, this would mean putting the `IPaymentService`
    interface and `PaymentService` in the same project*.* This approach is not necessarily
    wrong, but it does not respect the *dependency inversion principle*.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the dependency inversion principle is used to build very flexible
    systems, and it helps us to design a more readable, flexible, and maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle is often confused with the idea of dependency
    injection because the two concepts are strongly related. If dependency inversion
    defines a principle to improve our systems, dependency injection is a concrete
    implementation of that principle.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle becomes very useful when we want to test
    our code, especially for the unit testing technique. Unit tests usually cover
    a particular function in our application, so it is necessary to isolate our classes
    and methods. Dependency inversion comes in handy because we can mock our abstraction
    and isolate our subject under testing.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dependency injection is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A set of software design patterns that enable us to develop a loosely coupled
    code."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of dependency injection is to implement a loosely coupled code
    and, as a consequence, write maintainable code. In the book, *Dependency Injection
    in .NET*, Mark Seemann describes a bright, real-life example of a loosely coupled
    code. He compares tightly coupled code with cheap hotel hairdryers: some hostels,
    hotels, and locker rooms bind their hairdryers directly on the wall without a
    plug to stop guests from stealing them. If the hairdryer stops working, the owner
    has to cut the power and call a technician, who has to disconnect the hairdryer
    and replace it with a new one. This approach is a very tedious procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the hairdryer is plugged into the wall, the owner has
    to replace it with a new one. This is a metaphor for *dependency injection.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is a *tightly coupled code*: our high-level component (the wall)
    uses a low-level part (the hairdryer) directly. In the second case, we have a
    third actor, which is the plug: the high-level element (the wall) directly uses
    the plug (the abstraction). The hairdryer, which is our low-level component, also
    uses the plug.'
  prefs: []
  type: TYPE_NORMAL
- en: The second case is *more flexible and maintainable* because we can plug anything
    into the plug, and if the hairdryer breaks, we can replace it easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what *dependency injection* is all about. It comes with a lot of benefits
    for our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Late binding**: Third-party services can be plugged in and swapped with other
    services. This may be useful when you change one third-party dependency for another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel development**: Different teams can develop code at the same time
    by defining interaction contracts (interfaces) between components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: The code is easy to maintain and manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: As mentioned earlier, dependency injection helps us to deal
    with the isolation of the dependencies of unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more our codebase grows, the more these benefits are useful. For small codebases,
    dependency injection can be seen as a useless overhead, but it becomes crucial
    when we deal with distributed and large codebases. In the next section, we will
    see how to apply the concept of dependency injection to the
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependency injection concept is a fundamental part of ASP.NET Core. A dependency
    injection system comes out of box with the ASP.NET Core framework, and it is the
    preferred way to instantiate components in our application.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core usually describes types that are managed by the dependency injection
    container as *services.* Therefore*,* all the servicesare stored in the built-in
    container that is represented by the `IServiceProvider` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next part of the chapter, we will see some examples of dependency injection.
    As a first step, let''s create a new class in the `SampleAPI` project inside the
    `Controllers` folder, called `ValuesController.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet of code declares a `ValuesController` class, with a simple
    `Get` method. It is possible to call the route by executing the following CLI
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also possible by calling the following endpoint: `https://localhost:5001/values`.
    As a second step, we need to create a new `PaymentService.cs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `PaymentService.cs` file defines the `IPaymentService` interface, which
    describes a `GetMessage` signature. In addition, the `IPaymentService` interface
    is implemented by the `PaymentService` class that returns a string. In the same
    way, we are defining an `ExternalPaymentService` class, which implements the `IPaymentService`
    interface with different behavior. The next section describes how to register
    the `IPaymentService` interface in order to use the `PaymentService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services using the dependency injection container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can register the `IPaymentService` interface in `ConfigureServices` in the
    `Startup` class by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows a simple instantiation of a service using the ASP.NET
    Core container. I've omitted some parts of the `Startup` class in order to make
    the code more readable. The runtime executes the `services.AddTransient<IPaymentService,
    PaymentService>()` method in order to map the `IPaymentService` interface with
    the concrete implementation that was described in the `PaymentService` class.
    The `AddTransient` method also defines the scope of our service. We will go into
    detail about scopes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We should also note that the dependency injection container requires the concrete
    class (`PaymentService`) in order to implement the abstraction (`IPaymentService`)
    and add the instance to the container.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a real-world application, it is common practice to conditionally register
    some services depending on their environment variables. This practice is useful
    when we want to initialize third-party dependencies differently, such as a data
    source. The following code shows how to register services conditionally, based
    on the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The example uses the `IWebHostEnvironment` interface to detect the `IsDevelopment()`
    environment. In this case, it initializes `PaymentService`. Otherwise, it initializes
    the `ExternalPaymentService` implementation. This practice is widespread in testing
    environments, especially when initializing testing services or a data source.
    It is common in broad business applications to register services conditionally
    for testing and development purposes. In [Chapter 10](266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml),
    *Implementing the RESTful HTTP Layer*, we will see some concrete examples that
    have been applied to integration testing. It is essential to keep testing environments
    isolated in order to avoid false-positive results. Furthermore, registering services
    conditionally also helps us to improve the flexibility of our code. In the next
    subsections, we will see how to use constructor injection and action injection
    in order to resolve the dependencies of the controller classes.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just seen how we can initialize services in our `Startup` class, but
    how can we consume these services? By default, the built-in dependency injection
    container of ASP.NET Core uses the constructor injectionpattern to retrieve services*.*
    We can modify `ValueController` to use `IPaymentServices` by adding the interface
    as a parameter of the controller constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can inject the `IPaymentService` interface into the constructor
    of our class. It should be noted that to be compliant with constructor injection*,*
    the constructor has to abide by the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The constructor should be public**: If our constructor is not public, the
    reflection process cannot access the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There should be only one applicable constructor**: For example, if we declare
    multiple constructors in our `ValuesController` class, such as `public ValuesController(IPaymentService
    paymentService)` or `public ValuesController(IPaymentService paymentService, string[]
    paymentTypes = new string[] { 1, 2, 3 })`, the runtime would throw `InvalidOperationException`.
    There should be only one constructor that is suitable for dependency injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can only pass arguments that *are not provided* by dependency injection
    if they have a *default value***.** For example, the following constructor is
    suitable for constructor injection: `public ValuesController(IPaymentService paymentService,
    string[] paymentTypes = new string[] { 1, 2, 3 })`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resolution of the dependencies happens during the runtime execution; therefore,
    we need to adhere to these rules in order to avoid pitfalls when we alter the
    dependencies of a controller class.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, dependency injection provides a smart way to resolve the dependencies
    of classes. You should also try to be compliant with the **Single Responsibility
    Principle** (**SRP**). The SRP states that a class should have responsibility
    for a single part of the functionality. Classes with a lot of injected dependencies
    are probably not compliant with the SRP. Avoiding these kinds of bad design practices
    improves the maintainability of our code, and avoids our classes being tightly
    coupled with static functionalities, which prevent them from being testable. Let's
    proceed with the next section that covers the action method injection technique.
  prefs: []
  type: TYPE_NORMAL
- en: Action method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A valid alternative to constructor injection is the action method injection.
    Sometimes, controllers use some dependencies in only one action method. In those
    cases, it may be useful to inject our dependency just in this action method, in
    order to improve the performance of our code. To perform anaction method injection,
    we should use the `[FromServices]` attribute. For example, look at the following
    snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The example, as aforementioned, uses the action method injection. We are injecting
    our service into the `Get` action method which is the only consumer of the dependency.
    Although constructor injection is widely adopted, the action method injection
    technique becomes useful when you don't use the dependency on the whole controller.
    This only guarantees a lazy resolution of the dependencies when the action method
    is invoked. We should also note that this approach is strictly dependent on the
    MVC stack, because the resolution of the service is performed in the model-binding
    phase of the execution; therefore, it is only supported in the action method and
    in the filter classes. The next section will be focused on the services life cycle
    types that are provided by ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Services life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key point to master when we deal with dependency injection is the services
    life cycle. The services life cycle is an essential concept about performance,
    because a wrong service life cycle may cause complicated performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object lifetime in .NET is simple: the object is *instantiated*, *used*,
    and finally *disposed of* by the garbage collector. The *dispose* phase is the
    most relevant in terms of performance. In a dependency injection process, the
    consumer of a specific dependency does not control its lifetime. Indeed, dependencies
    are usually initialized by the dependency injection container, and they continue
    to exist until all their consumers hold them.'
  prefs: []
  type: TYPE_NORMAL
- en: A typical performance issue that engineers face in large applications is the
    *memory leak*. The garbage collector fails to clean objects because they are still
    referred to as consumers. Consequently, the memory of the server increases until
    it reaches saturation. It is not easy to find and solve these kinds of performance
    issues. In a .NET ecosystem, tools such as dotMemory can help you to analyze the
    instances of the objects that are created by your application, and eventually
    detect performance issues of this type.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of dependency injection, the default life cycle types in ASP.NET Core
    are *transient*, *scoped*, and *singleton*. Let's discuss them more in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Transient life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The services define the transient life cycle using the `.AddTransient()` method.
    Every time the consumer requires the initialization of a transient service, the
    dependency injection container returns a new instance. The transient life cycle
    is the safest life cycle, because it returns a new instance each time, and instances
    are not shared between consumers. It is also, however, the least efficient, because
    it can create a huge number of instances, especially in the web environment.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The services define the scoped life cycle `.AddScoped()` method. Scoped instances
    are created once per request. The scoped life cycle is preferable compared to
    the transient life cycle regarding performance, but it is less efficient than
    the singleton life cycle. A scoped approach is usually applied to repository classes
    and services, and each request to the server will cause the creation of a new
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the singleton life cycle, each time a consumer asks for a new instance, the
    same instance is provided. This is the most efficient life cycle because there
    is only a single instance, so the amount of consumed memory is minimal. However,
    it is recommended that you only use the singleton life cycle for thread-safe components.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle madness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term *life cycle madness* is a quote from Jeffrey Richter''s *CLR via C#*,
    and its chapter about threading. Understanding the life cycle of dependencies
    is important in order to avoid performance issues in our application. Above all,
    we should avoid the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consuming scoped dependencies in a singleton consumer**:As previously mentioned,
    a scoped life cycle means that a new instance is created for each request. When
    we try to consume a scoped instance in a singleton life cycle, the runtime will
    throw an exception as follows: `InvalidOperationException: Cannot consume scoped
    service ''Services.MyScopedService'' from singleton ''Services.MySingletonService''`.
    This is because the runtime cannot create a scoped service for each request when
    it is referred to by a singleton instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consuming transient dependencies in a singleton consumer**:Similarly, if
    we use a transient dependency inside a singleton instance, the runtime will not
    create a new instance of the transient service each time. Furthermore, the transient
    service will be initialized only once because it is declared in a singleton. Also,
    the runtime *will not throw an exception*, because a new instance of the transient
    service is not requested, as the singleton always uses the same one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to prevent possible bugs and runtime errors, it is important to avoid
    the situation in which a singleton refers to a scoped or transient service. In
    the first case, the runtime will throw an exception, while in the second case,
    the singleton consumer will always use the same instance. These behaviors must
    be avoided in order to prevent any memory issues and performance degradation inside
    our APIs. The following subsection explains how to use dependency injection in
    the middleware classes.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting services into middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, middleware can instantiate dependencies through a dependency
    injection container. We should take the life cycle of the middleware into consideration:
    they are initialized once per application lifetime. As a consequence, if we try
    to consume a *scoped* or *transient* *instance* into our middleware we shouldn''t
    inject them through the constructor of the middleware, because this will cause
    some dependency resolution issues. A good way to avoid this is to use the parameter
    injection in the `Invoke` or `InvokeAsync` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The other middleware implementation injects `IPaymentService` in the `InvokeAsync`
    method. Unlike the middleware constructor, the `InvokeAsync` method is called
    for each request. Consequently, it is suitable for both a *scoped life cycle*
    and a *transient life cycle*.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to inject a transientservice or a scoped service into middleware,
    you should inject them in the `Invoke` or `InvokeAsync` methods in order to avoid
    life cycle problems. Furthermore, middleware is a cross-cutting component, which
    means that the application runs them at every request. Therefore, you must pay
    extra attention when you implement middleware, in order to avoid spreading performance
    issues across all of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown us how to deal with the ASP.NET Core default dependency
    injection engine. The chapter provides various examples that are related to dependency
    injection, how to use dependency injection in controllers and middleware, and
    describes the life cycle concepts of the registered services. The next chapter
    will discuss the controllers and the action methods in detail. It will show you
    how to use these in order to serialize data and expose it as a web service.
  prefs: []
  type: TYPE_NORMAL
