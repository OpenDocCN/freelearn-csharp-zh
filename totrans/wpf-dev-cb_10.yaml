- en: Debugging and Threading
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the UI debugging tool for XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through XAML elements using Live Visual Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting XAML properties using Live Property Explorer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the UI from a non-UI thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cancelation support to long running threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the background worker component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a timer to periodically update the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to application development, debugging plays a vital role. It is
    a process that helps you to quickly look at the current state of your program
    by walking through the code line by line. While writing the code, developers start
    debugging their applications. Sometimes, developers start debugging even before
    writing the first line of code to know the existing logic.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides us with details about running programs as much as possible
    and helps you to change some values while the application is running. As a developer,
    you must already know this. As the focus of this book is on **Windows Presentation
    Foundation** (**WPF**), we will be discussing XAML UI debugging using **Live Visual
    Tree** and **Live Property Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will discuss **threading** and learn how to update
    a UI thread from a non-UI thread, a background worker process, and a timer that
    is used to periodically update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the UI debugging tool for XAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin debugging your XAML application UI, you will first need to enable a
    few settings in Visual Studio. If the settings are disabled, you won't be able
    to view the **Live Visual Tree** and the **Live Properties** window, which we
    will be discussing in the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: These settings are by default enabled in Visual Studio 2017, but in case are
    disabled; this recipe will help you to get started with that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have Visual Studio 2017\. Open it to get started with the
    settings changes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps mentioned here to verify and enable the UI Debugging Tools
    for XAML in Visual Studio 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Visual Studio IDE, navigate to the Tools | Options... menu, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48a669c8-31c8-490c-8c7f-05b27b019075.png)'
  prefs: []
  type: TYPE_IMG
- en: This will open the Visual Studio Options window. From this page, navigate to
    the Debugging | General section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the checkbox labeled Enable UI Debugging Tools for XAML, and switch
    it ON if it is not already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31212628-0a71-4961-a105-1c99e420412a.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you switch ON the functionality to debug the XAML application UI, you will
    enable a few more settings to use the **Live Visual Tree** and modifications of
    XAML properties when the debugger is already attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the same page, select the other checkboxes labeled Preview selected elements
    in Live Visual Tree and Show runtime tools in application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to change the XAML elements and their properties when the application
    is already running in debug mode, check Enable XAML Edit and Continue, as shown
    in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to save the changes and restart the debugging process for the changes
    to take effect. You will now be able to debug your XAML UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigating through XAML elements using Live Visual Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Live Visual Tree** is a debugger tool that helps you to perform XAML debugging
    more easily. Using this, you can inspect the XAML at runtime and visualize the
    layout to show alignments and space for UI elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, Live Visual Tree provides you a tree view of the UI elements of your
    running XAML application, and provides information about the number of XAML elements
    inside each container. If the interface changes from one state to another, Live
    Visual Tree also changes in runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn more about Live Visual Tree and how to use it
    to visualize the actual control rendering on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open Visual Studio 2017 IDE and create a new WPF project named
    `CH10.XamlDebuggingDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps mentioned here to create our sample demo application and then
    learn how to use **Live Visual Tree** to navigate through the XAML elements while
    debugging the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first design our application UI. Open the `MainWindow.xaml` file from
    Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the default `Grid` panel to have five rows in the following manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Grid`, add the following XAML code block to create a login screen
    with a few textblocks, textboxes, and button controls. Place them in appropriate
    rows as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `<Window>` tag, add `<Window.Resources>` and add the following
    styles for the `TextBox` and `Button` controls to give them a proper look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the UI is ready, let''s run the application. You will see the following
    output on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/506b3fa6-288b-46a3-a28c-b9ac7cb2c22f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, close the application and run it in debug mode. To do this, either click
    on the Start button (![](img/56df5ce0-a8b4-4745-8b84-26d258ecfc9c.png)) on the
    **Visual Studio Toolbar** or navigate to the Visual Studio Debug menu and click
    Start Debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can press the keyboard shortcut *F5* to run the application
    in debug mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the application launches, you will see the following output with a toolbar
    on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7dff8c22-8b81-4214-af63-436438d3ff62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case the toolbar is not present in the UI, navigate to Visual Studio''s
    Debugging options and enable Show runtime tools in application, as shown in the
    following screenshot. Also make sure that the other checkboxes (marked here) are
    already checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a277773-7867-425b-a4e2-5480e54599eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the application is running in debug mode, click on the second button on
    the runtime toolbar to enable the control selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86f44a73-7714-42fd-9148-0c83e2e33c03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, hover over on any control on the application UI, and you will see a red
    dotted border on the hovered control (just like the **IE Developer Tools**), as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d163a9cd-69ad-41bb-b44e-265f61620ebb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on any control to open Live Visual Tree inside the Visual Studio editor.
    In case it is not visible, navigate back to the application UI, and as shown in
    the following screenshot, click the first button on the runtime toolbar to launch
    the Live Visual Tree dialog panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abcdcdcf-6f33-4ccb-9a19-0877d78ff662.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you can navigate to the Visual Studio 2017 menu Debug | Windows
    | Live Visual Tree to launch this dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the input box, labeled Password. Live Visual Tree will show you the
    currently selected visual element within the visual tree. Check out the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b7450a6-0aac-4d90-b645-c941565aeba6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s click on the button control (labeled Login) and, as shown in the following
    screenshot, the appropriate Button control will be automatically selected in the
    Visual Tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d01fa2b3-4c5f-441a-affd-5fb208e69ea8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the Login label inside the button. You will see that the `Button`
    control contains a `TextBlock` element, which is present inside a `ContentPresenter`,
    wrapped inside a `Border` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/696637c5-9aa8-4e54-a362-ea1b14cb02bf.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you launch a WPF application in debug mode, the floating toolbar also gets
    loaded on the screen, which allows you to easily select the element in the running
    instance of the application and inspect its **Visual Element** in **Live Visual
    Tree**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The floating toolbar contains four buttons—Go to Live Visual Tree, Enable Selection,
    Display layout adorners, and Track focused element, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/757ffdbe-5586-46ef-b8f5-9979650a9cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `MainWindow.xaml`, we have added just the `Button` control inside `StackPanel`,
    but when you see it on **Live Visual Tree**, you will notice that the `Button`
    control consists of other UI elements to represent the control. It contains a
    `Border`, a `ContentPresenter`, and a `TextBlock` to visualize the `Button` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c19150fb-9b41-470b-ba1f-b7dc94dd5e83.png)'
  prefs: []
  type: TYPE_IMG
- en: Like this, each UI control consists of one or more UI elements that are only
    visible in a Visual Tree and can be inspected via Live Visual Tree when the debugger
    is attached to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is how the XAML controls actually render in the UI. The
    more levels of elements you have in a **Visual Tree**, the more performance issues
    it may hit. Detecting and eliminating unnecessary elements in the Visual Tree
    is one of the major advantages of a **Live Visual Tree** debugger window.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 also supports modification of the selected element in the
    Live Visual Tree window, which we will be demonstrating in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also ask the XAML debugger to display the layout adorners. While the
    runtime debugger tool is visible on the application window, click on the third
    button (as shown in the following screenshot), titled Display layout adorners.
    It will cause the application window to show horizontal and vertical lines along
    the bounds of the selected object, so you can see what it aligns to. It also displays
    rectangles showing the margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/561a81b9-1d04-4ea4-b88c-8bc4b5a946aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When enabled, hover over or click any UI element on the application window.
    You will see the layout adorner for that control, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f4dc5f3-ce5b-4a75-9cca-b28b3a6b7271.png)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting XAML properties using Live Property Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learnt about **Live Visual Tree**, which is used
    to get a real-time view of your running XAML code by inspecting the visual elements.
    Visual Studio 2015 and above also provide a **Live Property Explorer** window,
    which allows you to temporarily modify the XAML properties at runtime to see the
    visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn about Live Property Explorer. We will use Visual
    Studio 2017 to demonstrate it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with a demo project creation. Open your Visual Studio 2017 instance
    and create a new project named `CH10.LivePropertyExplorerDemo`. Make sure to select
    the WPF application template during project creation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to design our application UI with a simple button and then
    utilize **Live Property Explorer** to view and modify the XAML properties at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of the XAML with the following code to have a basic `Button`
    with default style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application. You will see that the button automatically arranges
    itself to cover the entire application. This is because we have placed the button
    inside a `Grid` and haven''t specified its dimensions and margins, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fa1a4a0-fd85-4ba4-8143-6c19f5c3ace5.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, close the application and run it in debug mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application launches in debug mode, navigate to the Visual Studio menu—Debug
    | Windows | Live Property Explorer to open said explorer window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Live Property Explorer window will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9961fcd4-f963-4cd8-b227-cbb48a327975.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, Live Property Explorer is showing
    the properties of the selected `Button` control, named `myButton`. You will find
    that most of the properties are disabled. This is because they are either inherited
    from implicit/explicit styles or have default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To experiment with the UI element properties, you should modify the properties
    inside the Local panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To override an existing property value of the selected element (in our case,
    it is `myButton`) from Live Visual Tree, click on the New button, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa9bb085-0f10-482f-8c7b-bea94c9638d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will add a drop-down list in the panel, where you will be able to select
    the property that you would like to modify. Let''s select Width from the property
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b20e3581-8413-4bb1-b086-dd6401cb91a1.png)'
  prefs: []
  type: TYPE_IMG
- en: When you select the property, the panel will get populated with the appropriate
    property boxes to fill it. Enter `120` as the value against the Width property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the running application window. The `Button` control in the window will
    be automatically resized to a width of 120 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the actual element in the XAML designer window. The change was not
    performed in the XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a71d29e-bcd4-4a27-8f85-0627aabd7a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's modify a few more properties of the `Button` control. Click on the New
    button and select `Height` from the property list. Set its value to `30`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the New button once again and select `Background` from the property
    list. Now enter `Red` as its value. You can alternatively enter `#FFFF0000` to
    apply a red color as the button background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you perform these changes, look at the running application window. The
    new height and the background color have already been applied to the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31e040d8-a933-4e68-a14e-c70ccdbca665.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's change a few more properties. Add the `FontSize` and `Foreground` properties
    in your local property list. Set their values to `16` and `White`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the application window for the changes. It will now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65878958-94b4-47d9-a8a0-bd8ba688afa3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Live Property Explorer** only gives you a preview of what you want to modify
    in runtime. Based on that, you can change the original UI in the XAML view or
    designer view for permanent changes.'
  prefs: []
  type: TYPE_NORMAL
- en: If you end the debugging session, the changes that you performed in the Live
    Property Explorer window won't be saved and you will lose those changes. When
    you restart the application, you will see fresh values as per the default.
  prefs: []
  type: TYPE_NORMAL
- en: This is often useful when you want to see the changes live at runtime for any
    element inside the Visual Tree.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To permanently set the properties of any UI element while the application is
    running in debug mode, use either the XAML code view or the XAML designer view.
    The running application will automatically get the update of the style changes.
  prefs: []
  type: TYPE_NORMAL
- en: To modify the XAML code while the application is running in debug mode, make
    sure that the Enable UI Debugging Tools for XAML and the Enable XAML Edit and
    Continue settings are enabled (checked) in the Visual Studio Options window, under
    the Debugging | General section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the application once again in debug mode and start modifying the
    control properties directly in the XAML view. Once you have made some changes,
    check the running application and you will see that it already has been updated
    with the modified data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47153405-e910-4b93-921c-3a2e2e324dd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the modified XAML code of the button, which we used in the preceding
    screenshot. When applied, it will result in the addition of a nice linear gradient
    color to the button background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Updating the UI from a non-UI thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, the UI is managed by a single thread, called a **UI thread**, which
    that creates an instance of a window and processes the UI messages for that window.
    This is known as **message pumping**.
  prefs: []
  type: TYPE_NORMAL
- en: When the UI thread is performing a lot of operations, it enters in to a wait
    state and stops processing further UI messages. This causes the application to
    enter *Not Responding* mode, which is commonly known as **UI freezing**.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, you need to offload that long running operation into
    another thread. This keeps the UI thread free and allows it to perform the UI
    updates and stay responsive.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to offload a long running process into a separate
    thread in a thread pool and perform the UI updates once it completes the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by creating a WPF project. Name it `CH10.ThreadingDemo1`. Make sure
    to select the right WPF App template during project creation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a simple application that will count odd and even numbers in
    a numeric range. This will be done on a non-UI thread and once the result is available
    we will update the UI. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` with the following simple user interface to provide
    the numeric range, and a button to calculate and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `MainWindow.xaml.cs` file and add the following two member-variables
    to store the total count of odd and even numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create a method to calculate the odd and even numbers. Inside the
    `MainWindow` class, create a method named `CalculateOddEven`, and implement the
    code block as shown in this following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to invoke the call. Let''s implement the button click event `OnCalculateClicked`
    to call the `CalculateOddEven` method and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and click on the Calculate button. The UI will freeze for
    some time while the long running operation is in-progress, as it finds out the
    odd and even numbers between the `100 - 1000000000` range. Once the calculation
    completes, it will unfreeze the UI and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0636500-0d8d-47e8-acb0-b7bb41ad2afd.png)'
  prefs: []
  type: TYPE_IMG
- en: To resolve this issue, we should move the long running process to a different
    thread so that the UI thread keeps responding. We will be using a thread pool
    to move the process to a different thread. You can also perform this by creating
    a new `Thread` instance or by using `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we will be using thread pool. This can be done by calling
    `ThreadPool.QueueUserWorkItem`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to update the UI once the operation gets completed. This can''t
    be done outside the `ThreadPool.QueueUserWorkItem` block, as the operation will
    run in a different thread. The same can''t be done directly inside the `ThreadPool.QueueUserWorkItem`
    block too, as the update should be performed in the UI thread. For this to work,
    the `Dispatcher.BeginInvoke` block can be used within the `ThreadPool.QueueUserWorkItem`
    block, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application once again. Click on the Calculate button. You will
    observe that the UI is responsive while the long running operation is in progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each and every element in WPF inherits from `DispatcherObject`, and thus, the
    UI thread is always associated with `System.Windows.Threading.Dispatcher`. This
    is the reason why the `Dispatcher` object can be accessed any time by using the
    `DispatcherObject.Dispatcher` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`ThreadPool.QueueUserWorkItem` causes a delegate to execute on the CLRs thread
    pool. Thus, the operation performed within that delegate never executes on the
    UI thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the operation completes, and you need to update the UI, you must update
    this from the UI thread. The call to `Dispatcher.BeginInvoke` causes the delegate
    to run on the UI thread and make the necessary changes to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: A point to note is that the dispatcher is also accessible from the UI thread,
    using the static property `Dispatcher.CurrentDispatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two kinds of invocations by `Dispatcher`—`BeginInvoke` and `Invoke`.
    We have already seen the uses of `BeginInvoke`, which basically invokes `delegate`
    and returns to perform other operations while `delegate` is still running on the
    UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, the `Invoke` operation does not return until `delegate` completes
    its execution on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`BeginInvoke` is always preferable unless there is a specific reason to wait
    for the UI operation to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatcher` maintains a queue of requests that need to be processed on the
    UI thread. This is basically handled by setting `DispatcherPriority`. The default
    priority is `DispatcherPriority.Normal`, but you can set a lower or a higher priority
    based on the importance of the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding cancelation support to long running threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you execute a long running process on a different thread, to keep the UI
    responsive during the operation, you may want to provide a functionality to cancel
    the operation. This can be done on an on-demand basis.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add cancellation support to the existing
    long running operation that we have built in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same example that we used in the previous recipe. You can
    copy the entire `CH10.ThreadingDemo1` project folder and give it a new name, `CH10.ThreadingDemo2`.
    Launch Visual Studio and open the new (`CH10.ThreadingDemo2`) project inside it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to update the existing project and to have cancellation
    support during the long running process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `MainWindow.xaml` file and modify the UI to have a `Cancel`
    button in it. Add the following button control inside `StackPanel`, and label
    it as `Cancel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to set its `IsEnabled` property to `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, navigate to the `MainWindow.xaml.cs` file and add the following member
    variable inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `Cancel` button click, we need to cancel the running operation. Let''s
    modify the `OnCancelClicked` event to perform the same as the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s navigate to the `CalculateOddEven` method and modify it to accept a
    third parameter of type `CancellationToken`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `for` loop of the `CalculateOddEven` method, check whether the `CancellationToken.IsCancellationRequested`
    is `true`, and if so, return immediately after setting the `totalOdd` and `totalEven`
    values to `-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For reference, here''s the modified code of the `CalculateOddEven` method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On `OnCalculateClicked` event implementation, we need to perform some changes.
    First create the instance of `CancellationTokenSource` and assign it to the `tokenSource`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, pass the instance to the `CalculateOddEven` method as the third parameter
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, inside the `Dispatcher.BeginInvoke` call, modify the code to display
    Operation canceled! based on the value of `totalOdd` and `totalEven` variables.
    Display the message only if either of them is `-1`. Here''s the complete implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, let''s run the application. Click the Calculate button to start
    the process in a separate thread in the thread pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c47ebde2-9a39-4ce8-85bb-0d27be0ae523.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While the operation is in progress, click the Cancel button. You will see that
    the process immediately stops and the Operation canceled! message gets displayed
    in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05979e0a-608b-4706-a2dc-ddf3ff9ce364.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's click on the `Calculate` button once again and wait until the process
    ends. What can you see now? It displays the total count of odd and even numbers
    on the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CancellationTokenSource` represents a logical operation that can be canceled.
    The `Token` property of `CancellationTokenSource` provides the token object that
    provides the part of the logical operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `Cancel()` method gets called on the `CancellationTokenSource`
    object, all distributed tokens from that source get their `IsCancellationRequested`
    property set as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `for` loop inside our `CalculateOddEven` method polls the
    `IsCancellationRequested` property and fills the `totalOdd` and `totalEven` member
    variables with `-1`, which can be used to understand that a cancellation call
    was performed. Based on that value, the Operation canceled! message gets displayed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Using the background worker component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we used thread pool to perform long running operations
    in a different thread. From there, we had to update the UI by marshalling the
    code to the UI thread, which required additional work.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this explicit thread pooling and the marshalling of the UI updation
    on the UI thread, we can use the `System.ComponentModel.BackgroundWorker` class.
    It provides automatic management of long running operations on a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use that `BackgroundWorker` to do the asynchronous operations
    without blocking the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the same example that we have used in previous recipes. You
    can copy the entire `CH10.ThreadingDemo1` project folder and create a new one
    with the name `CH10.ThreadingDemo3`. Launch Visual Studio and open the new project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to use a background worker, to perform the long running
    process, and to count the odd and even numbers within a range:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, navigate to the `MainWindow.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `using` namespace—`System.ComponentModel`, so that we can
    use the `BackgroundWorker` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `OnCalculateClicked` event, instead of calling `ThreadPool` to execute
    the operation, create an instance of the `BackgroundWorker` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the worker events `DoWork` and `RunWorkerCompleted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `RunWorkerAsync` method of the background worker by passing the numeric
    range as an argument. The argument accepts objects, hence, we will use `Tuple<int,
    int>` as the data type for simplicity. The complete code looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the `OnWorker_DoWork` event implementation to extract the argument
    first. Then, call the long running method (`CalculateOddEven`) by passing the
    values extracted from the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnWorker_WorkCompleted` event implementation, release the `BackgroundWorker`
    instance and then update the UI based on the values. Here''s the code for your
    reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, let''s run the application. You will see the same application
    UI as we saw in the first example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6141192f-8e70-4c3a-8849-212faeb6e121.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the `Calculate` button. You will observe that the application is responding
    while the execution is happening in the background worker process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the execution completes, it displays the result in the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BackgroundWorker` exposes events to coordinate the work. When you call the
    `RunWorkerAsync` method, the `DoWork` event is raised on the thread pool thread.
    You can pass an optional `Argument` to the `RunWorkerAsync` method, which can
    be retrieved from the `DoWorkEventArgs.Argument` property inside the `DoWork`
    event handler.'
  prefs: []
  type: TYPE_NORMAL
- en: As the `DoWork` event handler executes on a thread pool thread, accessing UI
    controls inside the `DoWork` handler will throw `Exception`. For this reason,
    pass the value from the UI as an argument to the `RunWorkerAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: When the `DoWork` event handler completes its execution, `BackgroundWorker`
    raises the `RunWorkerCompleted` event. This runs on the UI thread, and thus, you
    can perform UI operations from this event handler. If you have passed any value
    from the `DoWork` handler, you can retrieve it here from the `RunWorkerCompletedEventArgs.Result`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show the current progress indication of the long running background operation,
    you can raise the `ProgressChanged` event on the worker process and update the
    UI directly from here. The `ProgressChanged` handler runs in the UI thread and
    occurs when `BackgroundWorker.ReportProgress(System.Int32)` is called from the
    `DoWork` handler. For this to work, make sure that you have set the `WorkerReportsProgress`
    property of the worker to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also check whether `BackgroundWorker` is running an asynchronous operation.
    The `IsBusy` property will return `true` if it is running the background operation.
  prefs: []
  type: TYPE_NORMAL
- en: In case you want to cancel a running background worker, you can call the `CancelAsync()`
    method of the worker to request cancellation of a pending background operation.
    If `BackgroundWorker.WorkerSupportsCancellation` is set as `false`, it will throw
    `InvalidOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer to periodically update the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often require to update a portion of the user interface periodically.
    In that case, a timer object is beneficial to keep the UI refreshed. For example,
    in your application, you may want to show the current time at some part of the
    UI. For this, you can use a timer to periodically update the UI without the need
    to create a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Windows.Threading.DispatcherTimer` class can be used to integrate
    into the `Dispatcher` queue, and can process at a specified interval of time and
    at a specified priority.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `DispatcherTimer` class to implement a timer,
    which will execute its subscribed `Tick` event each time the specified `Interval`
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new WPF application project. Name it `CH10.DispatcherTimerDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a digital clock experience with a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, navigate to the `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the default `Grid` into three rows, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `TextBlock` control at the `Grid.Row="0"` position and align it to the
    center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `StackPanel` at `Grid.Row="2"` and insert two buttons inside it. Name
    the buttons `startButton` and `stopButton`. Also, register the `Click` events
    for both the buttons as `OnStartTimer` and `OnStopTimer`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, navigate to `MainWindow.xaml.cs` to add the code behind the logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add the following namespaces in the class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the class, declare a private member variable (`dispatcherTimer`) of
    type `DispatcherTimer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the constructor of the class, let''s create the instance of `DispatcherTimer`
    and raise its `Tick` event to trigger after every `1` second of interval. Here''s
    the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `Tick` event implementation, set the `Text` property of the
    `TextBlock` control (`clock`) to the current time in `hh:mm:ss` format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user clicks on the Start button, the `OnStartTimer` event handler will
    fire. Inside it, let''s start the timer by calling the `Start()` method on the
    `dispatcherTimer` instance. Alternatively, you can also set the `dispatcherTimer.IsEnabled`
    property to `true` to start the timer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When the handler `OnStopTimer` raises, on a click of the Stop button we will
    call the `Stop()` method of the `dispatcherTimer` instance. Here, also, you can
    set the `dispatcherTimer.IsEnabled` property as an alternate method to stop the
    timer, but in this case, you will have to set it as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application. You will see the following output on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7bd357d-0de7-4267-9242-6315d91c6609.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observe the text in the UI, where it is being displayed as `00:00:00`. Now
    click on the Start button. This will now change the text to the current time of
    your system, and it will refresh after every second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1363bc2-a4ec-4d61-a0d7-5af1c06c449b.png)'
  prefs: []
  type: TYPE_IMG
- en: As the time is ticking on the UI, after every second of interval, click on the
    Stop button. This will cause the running timer on the screen to stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the Start button again will start the timer and show the current
    time on the screen. The time displayed on the UI will refresh after every second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use a `DispatcherTimer` object, it represents a timer that is bound
    to the UI thread. The `Interval` property of the `DispatcherTimer` class indicates
    the period of the timer for the `Tick` event to raise, and continues ticking until
    explicitly stopped.
  prefs: []
  type: TYPE_NORMAL
- en: To start the timer, you can call its `Start()` method, or set the `IsEnabled`
    property to `true`. Similarly, to stop a timer, you can call the `Stop()` method,
    or set the `IsEnabled` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Never perform any lengthy operations in the `Tick` event, as it runs on the
    UI thread. Long running operations may block the UI from responding.
  prefs: []
  type: TYPE_NORMAL
