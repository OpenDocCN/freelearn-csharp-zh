<html><head></head><body>
        

                            
                    Implementing a Game Manager with the Singleton
                
            
            
                
<p class="mce-root">In this first hands-on chapter, we will review one of the most infamous software design patterns in the field of programming, the <strong>Singleton</strong>. It could be argued by many that the Singleton is the most widely used pattern among Unity developers, maybe because it's the most straightforward pattern to learn. But it can also quickly become the "duct tape" in our programming toolbox that we reach for every time we need a quick fix for a complex architectural problem.</p>
<p class="mce-root">For instance, when using this pattern, we can quickly establish a simple code architecture revolving around wrapping and managing all the core systems of our game in individual manager classes. Then we could have these managers expose clean and straightforward interfaces that will conceal the inner complexity of the systems. Also, to make sure that these managers are easily accessible and only a single instance runs at a time, we would implement them as Singletons. This approach might sound solid and beneficial, but it's full of pitfalls as it will create strong coupling between core components and make unit testing very difficult.</p>
<p>In this book, we will attempt to move away from this type of architecture and use design patterns to establish a more robust, modular, and scalable code base. But this doesn't mean that we will ignore the Singleton and judge it as inherently faulty. Instead, in this chapter, we will explore a use case in which this pattern is well suited.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basics of the Singleton pattern</li>
<li>Writing a reusable Singleton class in Unity</li>
<li>Implementing a globally accessible GameManager </li>
</ul>
<h1 id="uuid-57d10560-c310-45ba-ad0d-14d193b30eb5">Technical requirements</h1>
<p class="mce-root">This is a hands-on chapter; you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concept: <strong>Generics</strong>.</p>
<p>If unfamiliar with this concept, please review <a href="c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml">Chapter 3</a>, <em>A Short Primer to Programming in Unity</em>.</p>
<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04</a>.<a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2020"/></p>
<p class="mce-root">Check out the following video to see the Code in Action: <br/>
<a href="https://bit.ly/3wDbM6W">https://bit.ly/3wDbM6W</a></p>
<p>Generics is a compelling C# feature that permits us to defer the type for a class at runtime. When we say a class is generic, it means that it doesn't have a defined object type. This approach is advantageous because we can assign it a specific type when we initialize it. </p>
<h1 id="uuid-d53d5d61-0b64-48dc-9842-687769750d56">Understanding the Singleton pattern</h1>
<p class="mce-root">As its name implies, the Singleton pattern's primary goal is to guarantee singularity. This approach means if a class implements this pattern correctly, once initialized, it will have only one instance of itself in memory during runtime. This mechanism can be helpful when you have a class that manages a system that needs to be globally accessible from a singular and consistent entry point.</p>
<p class="mce-root">The design of the Singleton is quite simple. When you implement a Singleton class, it becomes responsible for making sure there's only a single occurrence of itself in memory. Once a Singleton detects an instance of an object of the same type as itself, it will destroy it immediately. Therefore, it's pretty ruthless and doesn't tolerate any competition. The following diagram illustrates the process to a certain degree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c6462456-8fd3-4b52-8ace-904528704212.png" style="width:31.83em;height:43.50em;"/></p>
<p>Figure 4.1 – UML diagram of the Singleton pattern</p>
<p class="mce-root">The most important takeaway from this description of the Singleton pattern is that if well implemented, it makes sure that there can only be one of itself; if not, it fails at its purpose.</p>
<h2 id="uuid-41cf54f2-391d-4eaf-bc4d-d02d70b6864d">Benefits and drawbacks</h2>
<p>These are some of the benefits of the Singleton pattern:</p>
<ul>
<li><strong>Globally accessible</strong>: We can use the Singleton pattern to create a global access point to resources or services.</li>
<li><strong>Control concurrency</strong>: The pattern can be used to limit concurrent access to shared resources.</li>
</ul>
<p>These are some of the drawbacks of the Singleton pattern:</p>
<ul>
<li><strong>Unit testing</strong>: If overly used, the Singleton can make unit testing very difficult. We might end up with Singleton objects being dependent on other Singletons. If one is missing at any moment, the chain of dependency gets broken. This issue often happens when combining Facade and Singleton to set up front-facing interfaces to core systems. We end up with an array of manager classes, each managing a specific core component of the game, all dependent on each other to function. Therefore, it becomes impossible to test and debug in isolation.</li>
<li><strong>Laziness</strong>: Because of its ease of use, the Singleton is a pattern that can quickly instill faulty programming habits. As mentioned in the <em>Unit testing</em> drawback, we can easily make everything accessible from anywhere with the Singleton. The simplicity it offers can also make us unwilling to test out more sophisticated approaches when writing code.</li>
</ul>
<p>When making design choices, it's essential to always keep in mind whether your architecture is maintainable, scalable, and testable. When it comes to testable, I often ask myself whether I can easily test my core systems, components, and mechanics individually and in isolation. If not, then I know I made some potentially unwise decisions. </p>
<h1 id="uuid-847a93c8-79dd-41ab-88ae-634af3699bb5">Designing a Game Manager</h1>
<p class="mce-root">A standard class we often see in Unity projects is the Game Manager. It's usually implemented as a Singleton by developers, but its responsibility varies from one code base to another. Some programmers use it to manage top-level game states or as a globally accessible front-facing interface to core game systems.</p>
<p class="mce-root">In the context of this chapter, we will give it the singular responsibility of managing a game session. Similar to the concept of a game master in board gaming, it will be responsible for setting up the game for the player. It can also take on additional responsibilities, such as communicating with backend services, initializing global settings, logging, and saving the player's progress.</p>
<p class="mce-root">The critical thing to keep in mind is that Game Manager will be alive for the entire lifespan of the game. Therefore, there will be a singular but persistent instance of it in memory at all times.</p>
<p class="mce-root">The following diagram illustrates the overall concept:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d61677e1-5c53-4159-9d2b-54e8d2743a9f.png" style="width:55.58em;height:20.50em;"/></p>
<p>Figure 4.2 – Diagram that illustrates the lifespan of the Game Manager</p>
<p>In the next section, we are going to take the design we just reviewed and translate it into code.</p>
<h1 id="uuid-a0cb250d-8709-40f6-b50c-6c14c0a4e4f6">Implementing the Game Manager</h1>
<p>In this section, we will implement a Singleton and Game Manager class. We will attempt to utilize some core Unity API features to adapt the pattern for use in the engine:</p>
<ol>
<li>For the first step of the process, we will implement the <kbd>Singleton</kbd> class. To make it easier to understand its intricacies, we will split it up into two distinct segments:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Singleton<br/>{<br/>    public class  Singleton&lt;T&gt; : <br/>        MonoBehaviour where T : Component {<br/><br/>        private static T _instance;<br/><br/>        public static T Instance<br/>        {<br/>            get<br/>            {<br/>                if (_instance == null)<br/>                {<br/>                    _instance = FindObjectOfType&lt;T&gt;();<br/><br/>                    if (_instance == null)<br/>                    {<br/>                        GameObject obj = new GameObject();<br/>                        obj.name = typeof(T).Name;<br/>                        _instance = obj.AddComponent&lt;T&gt;();<br/>                    }<br/>                }<br/><br/>                return _instance;<br/>            }<br/>        }</pre>
<p style="padding-left: 60px">In the first segment of the <kbd>Singleton&lt;T&gt;</kbd> class, we can see that we implemented a <kbd>public static</kbd> property with a <kbd>get</kbd> accessor. In this accessor, we are making sure that there's no existing instance of this object before initializing a new one. <kbd>FindObjectOfType&lt;T&gt;()</kbd> searches for the first loaded object of a specified type. If we can't find one, then we create a new <kbd>GameObject</kbd>, rename it, and add a component to it of a non-specified type.</p>
<p style="padding-left: 60px" class="mce-root">This process will be more evident when we implement the <kbd>GameManager</kbd> class.</p>
<ol start="2">
<li>Let's implement the final segment of the <kbd>Singleton</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">        public virtual void Awake()<br/>        {<br/>            if (_instance == null)<br/>            {<br/>                _instance = this as T;<br/>                DontDestroyOnLoad(gameObject);<br/>            }<br/>            else<br/>            {<br/>                Destroy(gameObject);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">For the last segment of the class, we have an <kbd>Awake()</kbd> method that we marked as <kbd>virtual</kbd>, which means it can be overridden by a derived class. What is essential to understand is that when the <kbd>Awake()</kbd> method gets called by the engine, the Singleton component will check whether there's already an instance of itself initialized in memory. If not, then it will become the current instance. But if one already exists, it will destroy itself to prevent duplication.</p>
<p style="padding-left: 60px" class="mce-root">Therefore, there can only be one instance of a specific type of Singleton in a Scene at once. If you try to add two, one will get automatically destroyed.</p>
<p style="padding-left: 60px">Another important detail to review is the following line:</p>
<pre style="padding-left: 60px">DontDestroyOnLoad(gameObject);</pre>
<p style="padding-left: 60px"><kbd>DontDestroyOnLoad</kbd> is a public static method that is included in the Unity API; it prevents a target object from being destroyed when a new scene is loaded. In other words, it makes sure that the current instance of an object persists even when switching between scenes. This API feature is handy for our Singleton because it guarantees the object will be available throughout the application's lifespan, in this context, the game.</p>
<ol start="3">
<li>For the final steps of our implementation, we will write a skeleton version of the <kbd>GameManager</kbd> class. We will focus only on code that will validate our <kbd>Singleton</kbd> implementation for reasons of brevity:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using UnityEngine;<br/>using UnityEngine.SceneManagement;<br/><br/>namespace Chapter.Singleton <br/>{<br/>    public class GameManager : MonoBehaviour<br/>    {<br/>        private DateTime _sessionStartTime;<br/>        private DateTime _sessionEndTime;<br/><br/>        void Start() {<br/>            // TODO:<br/>            // - Load player save<br/>            // - If no save, redirect player to registration scene<br/>            // - Call backend and get daily challenge and rewards <br/><br/>            _sessionStartTime = DateTime.Now;<br/>            Debug.Log(<br/>                "Game session start @: " + DateTime.Now);<br/>        }<br/>        <br/>        void OnApplicationQuit() {<br/>            _sessionEndTime = DateTime.Now;<br/><br/>            TimeSpan timeDifference = <br/>                _sessionEndTime.Subtract(_sessionStartTime);<br/><br/>            Debug.Log(<br/>                "Game session ended @: " + DateTime.Now);<br/>            Debug.Log(<br/>                "Game session lasted: " + timeDifference);<br/>        }<br/><br/>        void OnGUI() {<br/>            if (GUILayout.Button("Next Scene")) {<br/>                SceneManager.LoadScene(<br/>                    SceneManager.GetActiveScene().buildIndex + 1);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">To give more context to <kbd>GameManager</kbd>, we left a <kbd>TODO</kbd> list of potential tasks for the class to accomplish. But we also added a timer and a GUI button. Both will help us validate whether our <kbd>Singleton</kbd> is working when we start the testing phase.<br/>
<br/>
But at the moment, our <kbd>GameManager</kbd> is not a <kbd>Singleton</kbd>; to make it one, we just need to make one change to a single line of code, as we can see here:</p>
<pre style="padding-left: 60px">public class GameManager : Singleton&lt;GameManager&gt; </pre>
<p style="padding-left: 60px">It's as simple as that; we took a regular <kbd>MonoBehaviour</kbd> class and converted it into a <kbd>Singleton</kbd> with one line of code. This is made possible because we are using Generics. Hence, our <kbd>Singleton</kbd> class can be anything until we assign it a specific type.</p>
<ol start="4">
<li>So, for our last step, we took our <kbd>GameManager</kbd> class and converted it into <kbd>Singleton</kbd>, as seen here:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using UnityEngine;<br/>using UnityEngine.SceneManagement;<br/><br/>namespace Chapter.Singleton <br/>{<br/>    public class GameManager : Singleton&lt;GameManager&gt; <br/>    {<br/>        private DateTime _sessionStartTime;<br/>        private DateTime _sessionEndTime;<br/><br/>        void Start() {<br/>            // TODO:<br/>            // - Load player save<br/>            // - If no save, redirect player to registration scene<br/>            // - Call backend and get daily challenge and rewards <br/><br/>            _sessionStartTime = DateTime.Now;<br/>            Debug.Log(<br/>                "Game session start @: " + DateTime.Now);<br/>        }<br/><br/>        void OnApplicationQuit() {<br/>            _sessionEndTime = DateTime.Now;<br/><br/>            TimeSpan timeDifference = <br/>                _sessionEndTime.Subtract(_sessionStartTime);<br/><br/>            Debug.Log(<br/>                "Game session ended @: " + DateTime.Now);<br/>            Debug.Log(<br/>                "Game session lasted: " + timeDifference);<br/>        }<br/><br/>        void OnGUI() {<br/>            if (GUILayout.Button("Next Scene")) {<br/>                SceneManager.LoadScene(<br/>                    SceneManager.GetActiveScene().buildIndex + 1);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">Now that we have prepared all our ingredients, it's time to start the testing phase, which we will do next.</p>
<h2 id="uuid-62970097-974b-4bd7-9ea1-7c23659448a1">Testing the Game Manager</h2>
<p>If you wish to test the classes you just wrote in your instance of Unity, then you should go through the following steps:</p>
<ol>
<li>Create a new empty Unity scene called <kbd>Init</kbd>.</li>
<li>In the <kbd>Init</kbd> scene, add an empty <kbd>GameObject</kbd> and attach the <kbd>GameManager</kbd> class to it.</li>
<li>Create several empty Unity scenes, as many as you wish.</li>
<li class="mce-root">In <strong>Build Settings</strong> under the <strong>File</strong> menu, add the <strong>Init</strong> scene at index 0:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a040acf-a6ed-45b1-8185-575116bbc459.jpg" style="width:39.08em;height:32.42em;"/></p>
<p>Figure 4.3 – Build Settings</p>
<ol start="5">
<li>Then add your new empty Unity scenes to the <strong>Build Settings</strong> list, as many as you wish.</li>
</ol>
<p>If you now start the <kbd>Init</kbd> scene, you should see a GUI button named Next Scene as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2e01498-e545-48b7-9875-a23bf0bf34e3.png" style="width:61.67em;height:38.08em;"/></p>
<p>Figure 4.4 – Screenshot of the code example in action</p>
<p>If you click on the Next Scene button, you will cycle through each of the scenes you added in Build Settings, and the GUI will persist onscreen. If you stop running the game, you should see in the console log the duration of your session. If you try to add additional GameManagers to GameObjects in any scene, you will notice that they get destroyed, as only one can exist during the entire lifespan of the game.</p>
<p class="mce-root">This concludes our tests; we now have the first draft of a GameManager class and a reusable Singleton implementation.</p>
<h1 id="uuid-a5b25f93-eb9b-4cdf-b36e-13c9e08be15d">Summary</h1>
<p>In this chapter, we tackled one of the most controversial design patterns out there. But we found a way to implement it with a consistent and reusable approach. The Singleton is a pattern that's perfectly suited to Unity's coding model but overusing it can lead you to become too dependent on it. </p>
<p>In the next chapter, we will review the State pattern, which we will use to implement a controller class for the main ingredient of our game, the racing bike.</p>


            

            
        
    </body></html>