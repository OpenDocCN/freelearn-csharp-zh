- en: '*Chapter 6*: Working with the Data Access Infrastructure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all business applications use a kind of database system. We typically
    implement data access logic to read data from and write data to a database. We
    also need to deal with database transactions to ensure consistency in the data
    source.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with the data access infrastructure
    of ABP Framework, which provides abstractions for data access by implementing
    **Repository** and **Unit of Work** (**UoW**) patterns. Repositories provide a
    standard way to perform common database operations for your **entities**. The
    UoW system automates database connections and transaction management to ensure
    a use case (typically, a **HyperText Transfer Protocol** (**HTTP**) request) is
    atomic; this means all operations done in the request are successful together
    or rolled back together in any error.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how to define your entities based on ABP Framework's pre-built
    base entity classes. Then, you will learn how to insert, update, delete, and query
    entities in the database using the repositories. You will also understand the
    UoW system to control transaction scopes in your application.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework can work with any database system, while it provides built-in
    integration packages with `DbContext` class, mapping your entities to database
    tables, implementing your repositories, and deploying different ways of loading
    related entities when you have an entity. You will also see how to use **MongoDB**
    as a second database provider option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers ABP''s fundamental data access infrastructure with the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the UoW system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow and try the examples, you need to have an **integrated
    development environment** (**IDE**)/editor installed (for example, Visual Studio)
    to build ASP.NET Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities are the main classes to define your domain model. If you are using
    a relational database, an entity is generally mapped to a database table. An **object-relational
    mapper** **(ORM)**, such as EF Core, provides abstractions to make you feel as
    though you are working with objects in your application code rather than database
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework standardizes defining entities by providing some interfaces and
    base classes. In the next sections, you will learn about ABP Framework's `AggregateRoot`
    and `Entity` base classes (and their variants), using single **primary keys**
    (**PKs**) and **composite PKs** (**CPKs**) with these classes and working with
    **globally unique identifier** (**GUID**) PKs.
  prefs: []
  type: TYPE_NORMAL
- en: AggregateRoot classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **aggregate** is a cluster of objects (entities and value objects) bound
    together by an aggregate root object.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases do not have a physical aggregate concept. Every entity
    is related to a separate database table, and an aggregate is spread into more
    than one table. You define relations with **foreign keys** (**FKs**). However,
    in document/object databases such as MongoDB, an aggregate is saved into a single
    collection by serializing it as a single document (a **JavaScript Object Notation**
    (**JSON**)-like object). The aggregate root is mapped to the collection, and sub-entities
    are serialized within the aggregate root object. That means sub-entities don't
    have their collections and are always accessed over the aggregate root.
  prefs: []
  type: TYPE_NORMAL
- en: The Aggregate Concept
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the aggregate concept in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*, with all the details of this. For now, you can think
    of aggregate roots as the main (root) entities in your domain.
  prefs: []
  type: TYPE_NORMAL
- en: In ABP Framework, you can define main entities and aggregate roots, by deriving
    from one of the `AggregateRoot` classes. `BasicAggregateRoot` is the most simple
    class for defining your aggregate roots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example entity class is derived from the `BasicAggregateRoot`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`BasicAggregateRoot` just defines an `Id` property as the PK and takes the
    PK type as the generic parameter. In this example, the PK type of `Form` is `Guid`.
    You can use any type as the PK (for example, `int`, `string`, and so on), as long
    as the underlying database provider supports it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other base classes to derive your aggregate roots from, as detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AggregateRoot` class has additional properties to support optimistic concurrency
    and object extension features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreationAuditedAggregateRoot` inherits from the `AggregateRoot` class and
    adds `CreationTime` (`DateTime`) and `CreatorId` (`Guid`) properties to store
    creation audit information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuditedAggregateRoot` inherits from the `CreationAuditedAggregateRoot` class
    and adds `LastModificationTime` (`DateTime`) and `LastModifierId` (`Guid`) properties
    to store modification audit information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FullAuditedAggregateRoot` inherits from the `AuditedAggregateRoot` class and
    adds `DeletionTime` (`DateTime`) and `DeleterId` (`Guid`) properties to store
    deletion audit information. It also adds `IsDeleted` (`bool`) by implementing
    the `ISoftDelete` interface, which makes the entity soft-delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimistic Concurrency and Object Extension Features
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These topics are not covered in this book. Please check the ABP Framework documentation
    if you need to use them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABP automatically sets auditing properties. We will return to the audit logging
    and soft-delete topics in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  prefs: []
  type: TYPE_NORMAL
- en: Entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Entity` base classes are similar to `AggregateRoot` classes, but they are
    used for sub-collection entities rather than main (root) entities. For example,
    the `Form` aggregate root example in the previous section has a collection of
    questions. The `Question` class is derived from the `Entity` class and is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As with the `AggregateRoot` class, the `Entity` class also defines an `Id` property
    of a given type. In this example, the `Question` entity also has a collection
    of options, where `Option` is another entity type.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other pre-defined base entity classes, such as `CreationAuditedEntity`,
    `AuditedEntity`, and `FullAuditedEntity`. They are similar to the audited aggregate
    root classes explained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Entities with CPKs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases support CPKs, whereby your PK consists of a combination
    of multiple values. Composite keys are especially useful for relation tables with
    **many-to-many** relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you want to set multiple managers for a form object and add a collection
    property to the `Form` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define a `FormManager` class deriving from the non-generic `Entity`
    class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you inherit from the non-generic `Entity` class, you have to implement
    the `GetKeys` method to return an array of the keys. In this way, ABP can use
    the CPK's value where it is needed. For this example, `FormId` and `UserId` are
    FKs to other tables, and they build the CPK of the `FormManager` entity.
  prefs: []
  type: TYPE_NORMAL
- en: CPKs for Aggregate Roots
  prefs: []
  type: TYPE_NORMAL
- en: '`AggregateRoot` classes also have non-generic versions for CPKs, while it is
    not so usual to set CPKs for aggregate root entities.'
  prefs: []
  type: TYPE_NORMAL
- en: The GUID PK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP mostly uses GUIDs as the PK type for pre-built entities. GUIDs are generally
    compared to auto-increment IDs (such as `int` or `long`, supported by relational
    databases). Here are some commonly known benefits of using GUIDs as the PK compared
    to auto-increment keys:'
  prefs: []
  type: TYPE_NORMAL
- en: GUIDs are naturally unique. This works well if you are building distributed
    systems, using a non-relational database, and need to split or merge tables or
    integrate external systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs can be generated on the client side without needing a database round trip.
    In this way, the client code can know the PK value before saving the entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs are impossible to guess, so they can be more secure in some cases (for
    example, if end users see the ID of an entity, they can't find the ID of another
    entity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GUIDs also have some disadvantages compared to auto-increment integer values,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A GUID is 16 bytes in the storage, higher than `int` (4 bytes) and `long` (8
    bytes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUIDs are not sequential by nature, which causes performance problems on clustered
    indexes. However, ABP offers a solution to that problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABP provides the `IGuidGenerator` service, which generates sequential `Guid`
    values by default. While it generates sequential values, the values generated
    by the algorithm are still safe to be universal and random. Generating a sequential
    value solves the clustered index performance problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you manually set the `Id` value of an entity, always use the `IGuidGenerator`
    service; never use `Guid.NewGuid()`. If you don't set the `Id` value for a new
    entity and insert it into the database using a repository, the repository automatically
    sets it using the `IGuidGenerator` service.
  prefs: []
  type: TYPE_NORMAL
- en: GUID versus Auto-Increment
  prefs: []
  type: TYPE_NORMAL
- en: GUID versus auto-increment PKs is a hot discussion in software development,
    and there is no clear winner. ABP works with any PK type, so you can make your
    own choice based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned the basics of entity definitions and will explore best practices
    for entities in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD
    – The Domain Layer*. But now, let's continue with the repositories to understand
    how to work with a database to persist our entities.
  prefs: []
  type: TYPE_NORMAL
- en: Working with repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Repository pattern** is a common approach to abstract the data access
    code from the other services of your application. In the next sections, you will
    learn how to use ABP Framework's generic repositories for your entities to query
    or manipulate data in the database using pre-defined repository methods. You will
    also see how to create custom repositories when you need to extend the generic
    repositories and add your own repository methods to encapsulate your data access
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Database Providers
  prefs: []
  type: TYPE_NORMAL
- en: Database provider integration should be done to use repositories. We will do
    this in the *EF Core integration* and *MongoDB integration* sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have an entity, you can directly inject and use the generic repository
    for that entity. Here is an example class that uses a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''ve injected `IRepository<Form, Guid>`, the default generic
    repository for the `Form` entity. Then, we''ve used the `GetListAsync` method
    to get a filtered list of forms from the database. The generic `IRepository` interface
    has two generic parameters: entity type (`Form`, in this example) and PK type
    (`Guid`, in this example).'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories for Non-Aggregate Root Entities
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories are only available for *aggregate root* entities by default
    because it is a best practice to access aggregates via aggregate root objects.
    However, it is possible to enable generic repositories for other entity types
    if you're using a relational database. We will see the configuration point in
    the *EF Core integration* section.
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories provide many built-in methods to query, insert, update,
    and delete entities.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, updating, and deleting entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods can be used to manipulate data in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InsertAsync` is used to insert a new entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertManyAsync` is used to insert multiple entities in a single call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateAsync` is used to update an existing entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateManyAsync` is used to update multiple entities in a single call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteAsync` is used to delete an existing entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteManyAsync` is used to insert multiple entities in a single call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Asynchronous Programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All repository methods are asynchronous. As a general principle in .NET, it
    is strongly suggested to write your application code with the `async`/`await`
    pattern wherever possible, because in .NET, mixing asynchronous code with synchronous
    code leads to potential deadlock, timeout, and scalability problems in your application
    that are not easy to detect and resolve.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using EF Core, these methods may not immediately perform an actual
    database operation because EF Core uses a change-tracking system. It saves changes
    only when you call the `DbContext.SaveChanges` method. ABP Framework's UoW system
    automatically calls the `SaveChanges` method when the current HTTP request successfully
    finishes. If you want to save changes into the database immediately, you can pass
    the `autoSave` parameter as `true` to the repository methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a new `Form` entity and immediately saves it
    to the database in the `InsertAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even if you save changes into the database, the changes may not be visible yet,
    depending on the transaction isolation level, and will be rolled back if the current
    transaction fails. We will cover the UoW system in the *Understanding the UoW
    system* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DeleteAsync` method has an extra overload to delete all the entities satisfying
    the given condition. The following example deletes all the draft forms in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also have a complex condition using logical operators such as `&&` and
    `||`.
  prefs: []
  type: TYPE_NORMAL
- en: About Cancellation Tokens
  prefs: []
  type: TYPE_NORMAL
- en: All repository methods get an optional `CancellationToken` parameter. Cancellation
    tokens are used to cancel a database operation when needed. For example, if the
    user closes the browser window, there is no need to continue a long-running database
    query operation. Most of the time, you don't need to manually pass a cancellation
    token, since ABP Framework automatically captures and uses the cancellation token
    from the HTTP request when you don't explicitly pass it.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a single entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods can be used to fetch a single entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Throws `EntityNotFoundException` if the requested entity was not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Returns `null` if the requested entity was not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use the `FindAsync` method only if you have custom logic or fallback
    code, in case the given entity does not exist in the database. Otherwise, use
    `GetAsync`, which throws a well-known exception that causes the `404` status code
    to return to the client in an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `GetAsync` method to query a `Form` entity with
    its `Id` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods have overloads to pass a predicate expression to query an entity
    with a given condition. The following example uses the `GetAsync` method to get
    a `Form` entity with its unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Use these overloads only if you are expecting a single entity. If your query
    returns multiple entities, then they throw `InvalidOperationException`. For example,
    if form names are always *unique* in your system, you can find a form by name,
    as in this example. However, if your query may return multiple entities, use querying
    methods that return a list of entities.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a list of entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generic repositories provide a lot of options to query entities from the database.
    The following methods can be used to get a list of entities directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetListAsync`: Returns all the entities or a list of entities satisfying the
    given condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetPagedListAsync`: Used to query entities by paging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block shows how to get a list of forms filtered by the given
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I've passed a lambda expression to the `GetListAsync` method to get all the
    `Form` entities with the given `name` parameter's value contained in their names.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are simple but limited. If you want to write advanced queries,
    you can use **Language-Integrated Query** (**LINQ**) over the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ over the repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repositories provide the `GetQueryableAsync()` method, which returns an `IQueryable<TEntity>`
    object. You can then use this object to perform LINQ on the entities in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a LINQ operation on the `Form` entities to get a
    list of forms filtered and ordered by their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've first obtained an `IQueryable<Form>` object, then written a LINQ query,
    and finally executed the query using the `IAsyncQueryableExecuter` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to write the previous query could be using LINQ extension
    methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Having an `IQueryable` object provides you with all the power of LINQ. You can
    even make joins between multiple `IQueryable` objects obtained from different
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `IAsyncQueryableExecuter` service may seem strange to you. You may
    expect to call the `ToListAsync` method directly on the query object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `ToListAsync` is an extension method defined by EF Core (or MongoDB,
    if you are using it) and located inside the `Microsoft.EntityFrameworkCore` NuGet
    package. If referencing that package from your application layer is not a problem
    for you, then you can directly use these asynchronous extension methods in your
    code. However, if you want to keep your application layer ORM-independent, ABP's
    `IAsyncQueryableExecuter` service provides the necessary abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: IRepository async extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ABP Framework provides all the standard async LINQ extension methods for the
    `IRepository` interface: `AllAsync`, `AnyAsync`, `AverageAsync`, `ContainsAsync`,
    `CountAsync`, `FirstAsync`, `FirstOrDefaultAsync`, `LastAsync`, `LastOrDefaultAsync`,
    `LongCountAsync`, `MaxAsync`, `MinAsync`, `SingleAsync`, `SingleOrDefaultAsync`,
    `SumAsync`, `ToArrayAsync`, and `ToListAsync`. You can directly use any of these
    methods on a repository object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `CountAsync` method to get a count of forms
    where the name starts with `"A"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that these extension methods are only available on the `IRepository`
    interface. If you want to use queryable extensions, you should still follow the
    approach explained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Generic repositories for entities with CPKs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your entity has a CPK, you can't use the `IRepository<TEntity, TKey>` interface,
    since it gets a single PK (`Id`) type. In this case, you can use the `IRepository<TEntity>`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use `IRepository<FormManager>` to get managers of a given
    form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I've used the `IRepository<FormManager>` interface to perform
    a query for the `FormManager` entities.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories for Non-Aggregate Root Entities
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the *Generic repositories* section of this chapter, you can't use
    `IRepository<FormManager>` by default, since `FormManager` is not an aggregate
    root entity. You normally want to get the `Form` aggregate root and access its
    `Managers` collection to get the form managers. However, if you are using EF Core,
    you can create default generic repositories for entities that are not aggregate
    roots. See the *EF Core integration* section to learn how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of generic repositories without the `TKey` generic argument is
    that they don't have methods that get `Id` parameters because they can't know
    the `Id` type. However, you can still use LINQ to write any type of query you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Other generic repository types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You typically want to use the repository interfaces explained in the previous
    sections since they are the most feature-full repository types. However, there
    are some more limited repository types that can be useful in some scenarios, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IBasicRepository<TEntity, TPrimaryKey>` and `IBasicRepository<TEntity>` provide
    fundamental repository methods, but they don''t support LINQ and `IQueryable`
    functionalities. You can use these repositories if your underlying database provider
    doesn''t support LINQ or you don''t want to leak LINQ queries into your application
    layer. In this case, you probably need to write custom repositories by inheriting
    from these interfaces and implement your queries with custom methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyRepository<TEntity, TKey>`, `IReadOnlyRepository<TEntity>`, `IReadOnlyBasicRepository<Tentity,
    TKey>`, and `IReadOnlyBasicRepository<TEntity, TKey>` provide methods to fetch
    data but do not include any methods to manipulate the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic repository methods are enough for most cases. However, you may still
    need to add custom methods to your repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Custom repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create custom repository interfaces and classes to access the underlying
    database provider **application programming interface** (**API**), encapsulate
    your LINQ expressions, call stored procedures, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom repository, first, define a new repository interface. Repository
    interfaces are defined in the `Domain` project that comes with the startup template.
    You can inherit from one of the generic repository interfaces to include the standard
    methods in your repository interface. The code is illustrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`IFormRepository` inherits from `IRepository<Form, Guid>` and adds a new method
    to get a list of forms with some filters. You can then inject `IFormRepository`
    into your services instead of the generic repository and use your custom methods.
    If you don''t want to include the standard repository methods, just derive your
    interface from the `IRepository` (without any generic argument) interface. This
    is an empty interface that is used to identify your interface as a repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Surely, we must implement the `IFormRepository` interface somewhere in our application.
    ABP startup templates provide integration projects for the underlying database
    provider, so we can implement custom repository interfaces in the database integration
    project. We will implement that interface for EF Core and MongoDB in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft's EF Core is the de facto ORM for .NET, with which you can work with
    major database providers, such as SQL Server, Oracle, MySQL, PostgreSQL, and Cosmos
    DB. It is the default database provider when you create a new ABP solution using
    the ABP **command-line interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The startup template uses *SQL Server* by default. If you prefer another `-dbms`
    parameter while creating a new solution, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`SqlServer`, `MySQL`, `SQLite`, `Oracle`, and `PostgreSQL` are directly supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Databases
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to ABP''s documentation to learn about up-to-date supported database
    options and how to switch to another database provider that the ABP CLI does not
    support out of the box: [https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS](https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you will learn how to configure the DBMS (although it
    is already done in the startup template), define a `DbContext` class, and register
    to the **dependency injection** (**DI**) system. Then, you will see how to map
    your entities to database tables, using Code First Migrations and creating custom
    repositories for your entities. Finally, we will explore different ways of loading
    related data for an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the DBMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `AbpDbContextOptions` to configure the DBMS in the `ConfigureServices`
    method of our module. The following example configures using SQL Server as the
    DBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Surely, the `UseSqlServer()` method call will be different if you've preferred
    a different DBMS. We don't need to set the connection string since it is automatically
    obtained from the `ConnectionStrings:Default` configuration. You can check the
    `appsettings.json` file in your project to see and change the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: We've configured the DBMS but haven't defined a `DbContext` object, which is
    necessary to work with the database in EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: Defining DbContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DbContext` is the main object in EF Core that you interact with the database.
    You normally create a class inheriting from `DbContext` to create your own `DbContext`.
    With ABP Framework, we are inheriting from `AbpDbContext` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `DbContext` class definition with ABP Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`FormsAppDbContext` inherits from `AbpDbContext<FormsAppDbContext>`. `AbpDbContext`
    is a generic class and takes the `DbContext` type as a generic parameter. It also
    forces us to create a constructor, as shown here. We can then add `DbSet` properties
    for our entities. It is essential to add `DbSet` properties since ABP can create
    default generic repositories only for the entities with `DbSet` properties defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we've defined `DbContext`, we should register it with the DI system to
    use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Registering DbContext with DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AddAbpDbContext` extension method is used to register `DbContext` classes
    with the DI system. You can use this method inside the `ConfigureServices` method
    of your module (it is inside the `EntityFrameworkCore` project in the startup
    solution), as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. It enables generic repositories only
    for aggregate root entities by default because, in `includeAllEntities` parameter
    to `true` if you want to use repositories for other entity types too, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this option, you can inject the `IRepository` service for any entity in
    your application code.
  prefs: []
  type: TYPE_NORMAL
- en: The includeAllEntities Option in the Startup Template
  prefs: []
  type: TYPE_NORMAL
- en: The ABP startup template sets the `includeAllEntities` option to `true` because
    developers working on relational databases are used to querying from all database
    tables. If you want to apply DDD principles strictly, you should always use the
    aggregate roots to access sub-entities. In this case, you can remove this option
    from the `AddDefaultRepositories` method call.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to register the `DbContext` class. We can inject and use `IRepository`
    interfaces for all your entities in your `DbContext` class. However, we should
    first configure the EF Core mappings for the entities.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring entity mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core is an object-to-relational mapper that maps your entities to database
    tables. We can configure the details of those mappings in two ways, as outlined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Using data annotation attributes on your entity class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Fluent API inside by overriding the `OnModelCreating` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data annotation attributes makes your domain layer EF Core-dependent.
    If that's not a problem for you, you can simply use these attributes by following
    EF Core's documentation. In this book, I will use the Fluent API approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Fluent API approach, you can override the `OnModelCreating` method
    in your `DbContext` class, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you override the `OnModelCreating` method, always call `base.OnModelCreating()`
    since ABP also performs default configurations inside that method, necessary to
    properly use ABP features such as audit logs and data filters. Then, you can use
    the `builder` object to perform your configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can configure the mapping for the `Form` class defined in this
    chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `b.ConfigureByConvention()` method is important here. It configures
    the base properties of your entity if it is derived from ABP's pre-defined `Entity`
    or `AggregateRoot` classes. The remaining configuration code is pretty clean and
    standard, and you can learn all the details from EF Core's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that configures a relation between entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are defining the relation between the `Form` and `Question`
    entities: a form can have many questions, while a question always belongs to a
    single form.'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration we've made ensures that EF Core knows how to read and write
    entities to the database tables. However, related tables in the database should
    also be available. You can definitely create a database and the tables inside
    it manually. Then, in every change to your entities, you manually reflect the
    related changes in the database schema. However, it is hard to keep your entities
    and database tables in sync in this way. It is also tedious and error-prone to
    make them all manual, especially when you have multiple environments (such as
    development and production).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a better way: Code First Migrations. EF''s Code First
    Migrations system provides an efficient way to incrementally update the database
    schema to keep it in sync with your entity model. We''ve already used the Code
    First Migration system in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*. You can refer to that chapter to learn
    how to add a new database migration and apply it in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. Now, it's time to
    implement this repository interface using EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the repository inside the EF Core integration project of
    your solution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is derived from ABP''s `EfCoreRepository` class. In this way, we
    are inheriting all the standard repository methods. The `EfCoreRepository` class
    gets three generic parameters: the `DbContext` type, the entity type, and the
    PK type of the entity class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormRepository` also implements `IFormRepository`, which defines a custom
    `GetListAsync` method. We get the `DbContext` instance to use all the power of
    the EF Core API in this method.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip about WhereIf
  prefs: []
  type: TYPE_NORMAL
- en: Conditional filtering is a widely used pattern, and ABP provides a nice `WhereIf`
    extension method that can simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the `GetListAsync` method, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the `DbContext` instance, we can use it to execute **Structured
    Query Language** (**SQL**) commands or stored procedures. The following method
    executes a raw SQL command to delete all draft forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Executing Stored Procedures and Functions
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to EF Core's documentation ([https://docs.microsoft.com/en-us/ef/core](https://docs.microsoft.com/en-us/ef/core))
    to learn how to execute stored procedures and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you implement `IFormRepository`, you can inject and use it instead of
    `IRepository<Form, Guid>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This class uses the custom `GetListAsync` method of `IFormRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (for example, `IRepository<Form,
    Guid>`) for that entity. This is a good feature, especially if you start with
    generic repositories, then decide to create a custom repository later. You don't
    have to change your existing code that uses the generic repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential problem may occur if you override a base method from the `EfCoreRepository`
    class and customize it in your repository. In this case, the services that use
    the generic repository reference will continue to use the non-overridden method.
    To prevent this fragmentation, use the `AddRepository` method while registering
    your `DbContext` with DI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, the `AddRepository` method redirects generic repositories
    to your custom repository class.
  prefs: []
  type: TYPE_NORMAL
- en: Loading related data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your entity has navigation properties to other entities or has collections
    of other entities, then you'll frequently need to access those related entities
    while working with the main entity. For example, the `Form` entity introduced
    before has a collection of `Question` entities, and you may need to access the
    questions while working with a `Form` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to access related entities: **explicit loading**, **lazy
    loading**, and **eager loading**.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repositories provide `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    extension methods to load a navigation property or sub-collection explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can explicitly load the questions of a form, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we don't use `EnsureCollectionLoadedAsync` here, then the `form.Questions`
    collection might be empty. If we are not sure it is filled, we can use `EnsureCollectionLoadedAsync`
    to ensure it is loaded. The `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    methods do nothing if the related property or collection is already loaded, so
    calling them multiple times is not a problem for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lazy loading is a feature of EF Core that loads related properties and collections
    when you first access them. Lazy loading is not enabled by default. If you want
    to enable it for your `DbContext`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `Microsoft.EntityFrameworkCore.Proxies` NuGet package in your EF
    Core layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `UseLazyLoadingProxies` method while configuring `AbpDbContextOptions`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be sure that the navigation properties and collection properties are virtual
    in your entities, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you enable lazy loading, you don't need to use explicit loading anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy loading is a discussed concept of ORMs. Some developers find it useful
    and practical, while others suggest not using it in any way. I am drawn to not
    using it because it has some potential problems, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading can't use asynchronous programming because there is no way to access
    a property with the `async`/`await` pattern. So, it blocks the caller thread,
    which is a bad practice for throughput and scalability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have a `1+N` loading problem if you forget to eager-load the related
    data before using a `foreach` loop. `1+N` loading means you query a list of entities
    from the database with a single database operation (`1`), then perform a loop
    that accesses a navigation property (or a collection) of these entities. In this
    case, it lazy-loads the related property for each loop (`N` = count of the queried
    entities in the first database operation). So, you make a `1+N` database call,
    which dramatically drops your application performance. You should eager-load the
    related entities in such cases so that you make a single database in total.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it hard to predicate and optimize your code since you may not easily
    see when the related data is loaded from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I suggest going for a more controlled approach and using eager loading wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eager loading is a way of loading related data while first querying the main
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you''ve created a custom repository method to load the related
    questions while getting a `Form` object from the database, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you create such custom repository methods, you can use the full EF Core API.
    However, if you are working with ABP's repositories and don't want to depend on
    EF Core in your application layer, you can't use EF Core's `Include` extension
    method (which is used to eager-load the related data). In this case, you have
    two options, which are discussed in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: IRepository.WithDetailsAsync
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `WithDetailsAsync` method of the `IRepository` returns an `IQueryable`
    instance by including the given properties or collections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`WithDetailsAsync(f => f.Questions)` returns `IQueryable<Form>` with questions
    included, so we can safely loop through the `form.Questions` collection. `IAsyncQueryableExecuter`
    was explained before, in the *Generic repositories* section of this chapter. The
    `WithDetailsAsync` method can get more than one expression to include more than
    one property if you need it. `WithDetailsAsync` can''t be used if you need nested
    includes (the `ThenInclude` extension method in EF Core). In this case, create
    a custom repository method.'
  prefs: []
  type: TYPE_NORMAL
- en: The Aggregate pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*. However, to give a brief bit of information, an aggregate
    is considered a single unit; it is read and saved as a single unit with all sub-collections.
    That means you always load related questions while loading a form.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP supports the aggregate pattern well and allows you to configure eager loading
    for an entity at a global point. We can write the following configuration inside
    the `ConfigureServices` method of our module class (in the `EntityFrameworkCore`
    project in your solution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is suggested to include all sub-collections. Once you configure the `DefaultWithDetailsFunc`
    method as shown, then the following will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository methods that return a single entity (such as `GetAsync`) will eager-load
    related entities by default unless you explicitly disable that behaviour by specifying
    the `includeDetails` parameter to `false` on the method call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository methods that return multiple entities (such as `GetListAsync`) will
    allow the eager loading of related entities, while they will not eager-load by
    default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a single form with sub-collections included like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a single form without sub-collections like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a list of forms without sub-collections like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a list of forms with sub-collections included like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The Aggregate pattern simplifies your application code in most cases, while
    you can still fine-tune cases where you need performance optimization. Note that
    navigation properties (to other aggregates) are not used if you truly implement
    the Aggregate pattern. We will return to this topic again in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the essentials of using EF Core with ABP Framework. The next section
    will explain MongoDB integration, the other built-in database provider of ABP
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a popular non-relational **document database**, which stores data
    in JSON-like documents rather than traditional row-/column-based tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ABP CLI provides an option to create new applications using MongoDB, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you want to check and change the database connection string, you can look
    at the `appsettings.json` file of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB Client Package
  prefs: []
  type: TYPE_NORMAL
- en: ABP uses the official `MongoDB.Driver` NuGet package for MongoDB integration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, you will learn how to work with ABP's `AbpMongoDbContext`
    class to define `DbContext` objects, perform object-mapping configurations, register
    `DbContext` objects with the DI system, and implement custom repositories when
    you want to extend the generic repositories for your entities.
  prefs: []
  type: TYPE_NORMAL
- en: We begin the MongoDB integration by defining a `DbContext` class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining DbContexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MongoDB driver package doesn''t have a `DbContext` concept like EF Core
    does. However, ABP introduces the `AbpMongoDbContext` class to provide a standard
    way to define and configure MongoDB integration. We need to define a class deriving
    from the `AbpMongoDbContext` base class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `MongoCollection` attribute sets the collection name on the database side.
    It is optional and uses the driver's default value if you don't specify it. Defining
    a collection property on the `FormsAppDbContext` class is required to use the
    default generic repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring object mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the MongoDB C# driver is not an ORM, it still maps your entities to collections
    in the database, and you may want to customize the mapping configuration. In this
    case, override the `CreateModel` method in your `DbContext` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I've configured MongoDB so that it ignores the `Description`
    property of the `Form` entity while saving and retrieving data. Please refer to
    the documentation of the `MongoDB.Driver` NuGet package to learn about all configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Registering DbContext with DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you create and configure your `DbContext` class, it is registered with
    the DI system in the `ConfigureServices` method of your module class (typically
    in the MongoDB integration project of your solution). The following code snippet
    illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. You can then inject `IRepository<Form>`
    into your classes and start using your MongoDB database.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AddDefaultRepositories` method enables default repositories only for aggregate
    root entities (the entity classes derived from the `AggregateRoot` class). Set
    `includeAllEntities` to `true` to enable default repositories for all entity types.
    However, it is strongly suggested to apply the Aggregate pattern while working
    with MongoDB. The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: Default generic repositories are enough in most cases, but you may need to access
    the MongoDB API or abstract your queries into custom repository methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. We can implement this
    repository interface using MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the repository inside the MongoDB integration project of
    your solution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FormRepository` class is derived from ABP''s `MongoDbRepository` class.
    In this way, we are inheriting all the standard repository methods. The `MongoDbRepository`
    class gets three generic parameters: the `DbContext` type, the entity type, and
    the PK type of the entity class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormRepository` class should implement the `GetListAsync` method defined
    by the `IFormRepository` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve used the LINQ API of the MongoDB driver in this example, but you can
    use alternative APIs by obtaining the `IMongoCollection` object, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can inject `IFormRepository` instead of the generic `IRepository<Form,
    Guid>` repository into your services and use all the standard and custom repository
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (such as `IRepository<Form,
    Guid>`) for that entity. If you implement a custom repository, it is suggested
    to use the `AddRepository` method on the `DbContext` registration code, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this way, generic default repositories will be redirected to your custom
    repository class. If you override a base method in your custom repository, they
    will also use your overload instead of the base method.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to use EF Core and MongoDB as the database provider. In the
    next section, we will understand the UoW system, making it possible to connect
    these databases and apply transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the UoW system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UoW is the main system that ABP uses to initiate, manage, and dispose of database
    connections and transactions. The UoW system is designed with the **Ambient Context
    pattern**. That means when we create a new UoW, it creates a scoped context that
    is participated by all the database operations performed in the current scope
    by sharing the same context and is considered a single transaction boundary. All
    the operations done in a UoW are committed (on success) or rolled back (on exception)
    together.
  prefs: []
  type: TYPE_NORMAL
- en: While you can manually create UoW scopes and control the transaction properties,
    most of the time, it works seamlessly just as you desire. However, it provides
    some options if you change the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: UoW and Database Operations
  prefs: []
  type: TYPE_NORMAL
- en: All database operations must be performed in a UoW scope since UoW is the way
    to manage database connections and transactions in ABP Framework. Otherwise, you
    get an exception indicating that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you will gain an understanding of how the UoW system works
    and customize it by configuring the options. I will also explain how to manually
    control the UoW system when the conventional system doesn't work for your use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring UoW options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the default setup, in an ASP.NET Core application, an HTTP request is considered
    as the UoW scope. ABP starts a UoW at the beginning of the request and saves changes
    to the database if the request successfully finishes. It rolls back the UoW if
    the request fails because of an exception.
  prefs: []
  type: TYPE_NORMAL
- en: ABP determines database transaction usage based on the HTTP request type. HTTP
    `GET` requests don't create a database transaction. UoW works anyway but doesn't
    use a database transaction in this case. All other HTTP request types (`POST`,
    `PUT`, `DELETE`, and others) use a database transaction if you haven't configured
    them otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP GET Requests and Transactions
  prefs: []
  type: TYPE_NORMAL
- en: It is a best practice not to make database changes in `GET` requests. If you
    make multiple write operations in a `GET` request and somehow your request fails,
    your database state could be left in an inconsistent state because ABP doesn't
    create a database transaction for `GET` requests. In this case, either enable
    transactions for `GET` requests using `AbpUnitOfWorkDefaultOptions` or manually
    control the UoW, as described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `AbpUnitOfWorkDefaultOptions` in the `ConfigureServices` method of your
    module (in the database integration project) if you want to change the UoW options,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`TransactionBehavior` can take the following three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Auto` (default): Automatically determines using database transactions (transactions
    are enabled for non-`GET` `HTTP` requests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enabled`: Always uses a database transaction, even for `HTTP` `GET` requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`: Never uses a database transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Auto` behavior is the default value and is suggested for most applications.
    `IsolationLevel` is only valid for relational databases. ABP uses the default
    value of the underlying provider if you don't specify it. Finally, the `Timeout`
    option allows you to set a default timeout value for transactions as milliseconds.
    If a UoW operation doesn't complete in the given timeout value, a timeout exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to configure the default options across all
    UoWs. It is also possible to configure these values for an individual UoW if you
    manually control it.
  prefs: []
  type: TYPE_NORMAL
- en: Manually controlling the UoW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For web applications, you rarely need to control the UoW system manually. However,
    for background workers or non-web applications, you may need to create UoW scopes
    yourself. You may also need to control the UoW system to create inner transaction
    scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to create a UoW scope is to use the `[UnitOfWork]` attribute on your
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The UoW system uses the Ambient Context pattern. If a surrounding UoW is already
    in place, your `UnitOfWork` attribute is ignored and your method participates
    in the surrounding UoW. Otherwise, ABP starts a new transactional UoW just before
    entering the `DoItAsync` method and commits the transaction if it doesn't throw
    an exception. The transaction is rolled back if that method throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to fine-control the UoW system, you can inject and use the `IUnitOfWorkManager`
    service, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are starting a new transactional UoW scope with 15 seconds
    as the `timeout` parameter''s value. With this usage (`requiresNew: true`), ABP
    always starts a new UoW even if there is a surrounding UoW. Always call the `uow.CompleteAsync()`
    method if everything goes right. You can use the `uow.RollbackAsync()` method
    if you want to roll back the current transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, UoW uses an ambient scope. You can access the current UoW
    anywhere in this scope, using the `IUnitOfWorkManager.Current` property. It can
    be `null` if there is no ongoing UoW.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet uses the `SaveChangesAsync` method with the `IUnitOfWorkManager.Current`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've saved all pending changes to the database. However, if that's a transactional
    UoW, these changes are also rolled back if you roll back the UoW or throw any
    exception in the UoW scope.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to work with databases using ABP Framework.
    ABP standardizes to define entities by providing base classes. It also helps to
    automatically track change times and the users changing entities, when you derive
    from audited entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: The repository system provides the fundamental functionalities to read and write
    entities. You can use LINQ over the repositories for advanced querying possibilities.
    Also, you can create custom repository classes to work with the underlying data
    provider directly, hide complex queries behind simple repository interfaces, call
    stored procedures, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: ABP is database-agnostic, but it provides integration packages with EF Core
    and MongoDB out of the box. ABP application startup templates come with one of
    these providers, whichever you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core is the de facto ORM for the .NET platform, and ABP supports EF Core
    as a first-class citizen. The application startup template is fine-tuned to configure
    your mappings and manage your database schema migrations while supporting a modular
    application structure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the UoW system provides a seamless way to manage database connections
    and transactions for us. It keeps the application code clean by automating these
    repeating tasks for us.
  prefs: []
  type: TYPE_NORMAL
- en: Data access is a core requirement for any business application, and it is essential
    to understand the details of it. The next chapter will continue with the cross-cutting
    concerns required for every application, such as authorization, validation, and
    exception handling.
  prefs: []
  type: TYPE_NORMAL
