- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Non-Functional Requirements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能性需求
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, availability, resiliency,
    performance, multithreading, interoperability, security, and other aspects need
    to be analyzed so that we can meet user needs. We refer to these aspects as non-functional
    requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了系统需求，就需要考虑它们对架构设计的影响。可扩展性、可用性、弹性、性能、多线程、互操作性、安全性和其他方面都需要进行分析，以便我们能够满足用户需求。我们将这些方面称为非功能性需求。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Enabling scalability, availability, and resiliency with Azure and .NET 8
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure 和 .NET 8 实现可扩展性、可用性和弹性
- en: Performance issues that need to be considered when programming in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 编程时需要考虑的性能问题
- en: 'Software usability: how to design effective user interfaces'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件可用性：如何设计有效的用户界面
- en: Interoperability with .NET 8
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 .NET 8 的互操作性
- en: Achieving security by design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设计实现安全性
- en: 'The main purpose of discussing non-functional requirements here is that they
    are highly relevant to software architects: even though they are not so important
    to getting the software working in terms of functionality, they can make all the
    difference when comparing good software and bad software.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论非功能性要求的主要目的是，它们与软件架构师高度相关：尽管它们在功能方面对软件工作的实现并不那么重要，但它们在比较优秀软件和劣质软件时可以产生很大的差异。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The samples provided in this chapter require Visual Studio 2022 Community Edition
    with the .NET 8 SDK installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例需要安装了 .NET 8 SDK 的 Visual Studio 2022 Community Edition。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)
    找到本章的示例代码。
- en: Enabling scalability, availability, and resiliency with Azure and .NET 8
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 和 .NET 8 实现可扩展性、可用性和弹性
- en: A quick search online for a definition of “scalability” returns something along
    the lines of “the ability of a system to keep working well when there is an increase
    in demand.” When developers go by this definition, many of them incorrectly conclude
    that scalability only means adding more hardware to keep things working without
    stopping their apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在线搜索“可扩展性”的定义，返回的结果类似于“系统在需求增加时保持良好工作状态的能力。”当开发者根据这个定义行事时，许多人错误地得出结论，认为可扩展性仅仅意味着添加更多硬件以保持事物运行而不停止他们的应用程序。
- en: Scalability relies on hardware solutions to some extent. However, as a software
    architect, you need to be aware that good software will keep scalability in a
    sustainable model, which means that well-architected software can save a lot of
    money. Hence, scalability is not just a matter of hardware but also a matter of
    overall software design. The point here is that the running costs of a system
    should also be a factor in architectural decisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性在一定程度上依赖于硬件解决方案。然而，作为一名软件架构师，你需要意识到，优秀的软件将保持可扩展性在一个可持续的模式中，这意味着良好的架构软件可以节省大量资金。因此，可扩展性不仅仅是硬件问题，也是整体软件设计的问题。这里的要点是，系统的运行成本也应该在架构决策中作为一个因素考虑。
- en: In *Chapter 1*, *Understanding the Importance of Software Architecture*, while
    discussing software performance, we presented some good tips to overcome performance
    issues. The same tips will help you with scalability, too. The fewer resources
    we spend on each process, the more users an application can handle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章* *理解软件架构的重要性* 中，当我们讨论软件性能时，我们提出了一些克服性能问题的好建议。同样的建议也会帮助你实现可扩展性。我们投入每个过程中的资源越少，应用程序就能处理更多的用户。
- en: Although scalability is important, cloud computing applications must be designed
    to work with system failures. Every time you guarantee that your application can
    recover from a failure without exposing the failure to the end user, you are creating
    a resilient application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可扩展性很重要，但云计算应用程序必须设计成能够在系统故障的情况下工作。每次你确保你的应用程序能够在不向最终用户暴露故障的情况下从故障中恢复，你就是在创建一个具有弹性的应用程序。
- en: You may find cloud architecture resiliency patterns at [https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency](https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency](https://docs.microsoft.com/en-us/azure/architecture/framework/resiliency/reliability-patterns#resiliency)找到云架构弹性模式。
- en: The reason why resiliency is especially important in cloud scenarios is that
    the infrastructure provided to you may need a small amount of time to manage updates,
    resets, and even hardware upgrades. You are also more likely to have to work with
    multiple systems, and transient errors are likely to occur in communicating with
    them. That is why the non-functional requirement of resiliency has gained a higher
    profile in recent years.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在云场景中，弹性之所以特别重要，是因为提供给您的基础设施可能需要一点时间来管理更新、重置甚至硬件升级。您也更可能需要与多个系统协作，并且在与它们通信时可能会出现暂时性错误。这就是为什么弹性这一非功能性需求在近年来得到了更高的关注。
- en: The possibility of having scalable and resilient solutions gets more exciting
    when you can enable high availability in the system. All the approaches presented
    in this book will help you to design solutions with good availability, but in
    some cases, you will need to design specific alternatives to achieve your specific
    goal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您能够在系统中启用高可用性时，拥有可扩展和弹性解决方案的可能性变得更加令人兴奋。本书中提出的所有方法都将帮助您设计具有良好可用性的解决方案，但在某些情况下，您将需要设计特定的替代方案以实现您的特定目标。
- en: It is worth knowing that Azure and .NET 8 web apps can be configured to achieve
    these non-functional requirements. Let us check this out in the following subsections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Azure和.NET 8 Web应用可以配置以实现这些非功能性需求。让我们在接下来的小节中查看这些内容。
- en: Creating a scalable web app in Azure
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure中创建可扩展的Web应用
- en: It is simple to create a web app in Azure that is ready for scaling. The reason
    why you must do so is to be able to maintain different numbers of users during
    different seasons. The more users you have, the more hardware you will need. Let
    us show you how to create a scalable web application in Azure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中创建一个可扩展的Web应用很简单。您必须这样做的原因是能够在不同季节维护不同数量的用户。用户越多，您需要的硬件就越多。让我们向您展示如何在Azure中创建一个可扩展的Web应用。
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到您的Azure账户，您将能够创建新的资源（Web应用、数据库、虚拟机等），如下面的截图所示：
- en: '![](img/B19820_02_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_02_01.png)'
- en: 'Figure 2.1: Microsoft Azure – Create a resource'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Microsoft Azure – 创建资源
- en: 'After that, you can select **App Services in Popular Options** or even type
    it into the **Search the Marketplace** textbox. Then, you can choose to create
    a **web app**. This action will take you to the following screen:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以选择**常用选项中的App服务**，或者甚至将其输入到**在市场搜索**文本框中。然后，您可以选择创建**Web应用**。此操作将带您进入以下屏幕：
- en: '![](img/B19820_02_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_02_02.png)'
- en: 'Figure 2.2: Microsoft Azure – Creating a web app'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Microsoft Azure – 创建Web应用
- en: 'The required **Project Details** are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的**项目详情**如下：
- en: '**Subscription**: This is the account that will be charged for all application
    costs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：这是将收取所有应用程序费用的账户。'
- en: '**Resource Group**: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源组**：这是您可以定义以组织策略和权限的资源集合。您可以选择指定新的资源组名称或将Web应用添加到在定义其他资源时指定的组中。'
- en: 'Besides these, the **Instance Details** are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，**实例详情**如下：
- en: '**Name**: As you can see, the web app name is the URL that your solution will
    assume after its creation. The name must be globally unique and is checked to
    ensure it is available.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：正如您所看到的，Web应用的名称是在创建后您的解决方案将采用的URL。名称必须是全局唯一的，并且会进行检查以确保其可用性。'
- en: '**Publish**: This parameter indicates whether the web app will be delivered
    directly, a static web app, or whether it is going to use Docker technology to
    publish content. Docker will be discussed in more detail in *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. If you opt for the
    Docker container publication, you will be able to configure the **Image Source**,
    **Access Type**, and **Image** and tag information to have it deployed to the
    web app.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：此参数指示Web应用是否直接交付、静态Web应用，还是将使用Docker技术发布内容。Docker将在第11章“将微服务架构应用于您的企业应用”中更详细地讨论。如果您选择Docker容器发布，您将能够配置**镜像源**、**访问类型**和**镜像**以及标签信息，以便将其部署到Web应用中。'
- en: '**Runtime stack**: This option is obviously only available when you decide
    to deliver code directly. You could define stacks for .NET, Go, Java, Node.js,
    PHP, Python, and Ruby.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时堆栈**：此选项仅在您决定直接交付代码时才可用。您可以定义.NET、Go、Java、Node.js、PHP、Python和Ruby的堆栈。'
- en: '**Operating System**: This is the option for defining the OS that will host
    the web app. Both Windows and Linux may be used for .NET projects in the newest
    versions.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：这是定义将托管Web应用的OS的选项。在最新版本中，Windows和Linux都可以用于.NET项目。'
- en: '**Region**: You may consider where you want to deploy your application; Azure
    has many different data centers all over the world.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：您可以考虑将应用程序部署到何处；Azure在全球有多个不同的数据中心。'
- en: '**Pricing Plans**: This is where you define the hardware plan that is used
    to handle the web app and the region of the servers. This choice defines application
    scalability, performance, and costs.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价计划**：这是您定义用于处理Web应用的服务器硬件和区域的地方。此选择定义了应用程序的可扩展性、性能和成本。'
- en: '**Zone redundancy:** Starting with premium pricing plans, you will be able
    to activate zone redundancy, which will increase the availability of the solution.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域冗余**：从高级定价计划开始，您将能够激活区域冗余，这将提高解决方案的可用性。'
- en: '**Deployment:** It is possible to define the GitHub repository that is responsible
    for continuously deploying the application.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：您可以定义负责持续部署应用的GitHub仓库。'
- en: '**Networking:** You may select the network behavior of the application according
    to its requirements and proposal.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：您可以根据应用程序的要求和提案选择应用程序的网络行为。'
- en: '**Monitoring**: This is a useful Azure toolset for monitoring and troubleshooting
    web apps. In this section, you can enable **Application Insights**. It is always
    recommended that you keep the same regions for the different components of your
    solution since this will save costs in terms of traffic exchange from one data
    center to another.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：这是一个用于监控和故障排除Web应用的Azure工具集。在本节中，您可以启用**应用程序洞察**。始终建议您为解决方案的不同组件保持相同的区域，因为这将在数据中心之间流量交换方面节省成本。'
- en: 'Once you have created your web app, this application may be scaled in two conceptually
    different ways: vertically (**scale up**) and horizontally (**scale out**). Both
    are available in the web app settings, as you can see in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了您的Web应用，此应用可以通过两种概念上不同的方式进行扩展：垂直扩展（**向上扩展**）和水平扩展（**向外扩展**）。这两种扩展方式都在Web应用设置中提供，如下面的截图所示：
- en: '![](img/B19820_02_03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_02_03.png)'
- en: 'Figure 2.3: Scaling options for web apps'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Web应用的扩展选项
- en: Let us check out the two types of scaling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看两种扩展类型。
- en: Vertical scaling (scaling up)
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直扩展（向上扩展）
- en: 'Scaling up means changing the specification of the hardware that will host
    your application. In Azure, you have the opportunity to start with free, shared
    hardware and move to an isolated machine in a few clicks. The following screenshot
    shows the user interface for scaling up a web app:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 向上扩展意味着更改将托管您的应用程序的硬件规格。在Azure中，您有机会从免费、共享的硬件开始，只需几点击即可迁移到隔离的机器。以下截图显示了向上扩展Web应用的用户界面：
- en: '![](img/B19820_02_04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_02_04.png)'
- en: 'Figure 2.4: Vertical scaling options'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：垂直扩展选项
- en: By choosing one of the options provided, you can select more powerful hardware
    (machines with more CPUs, storage, and RAM). Monitoring your application and its
    App Service plan will guide you on how to decide the best infrastructure for running
    your solution. It will also offer key insights, such as possible CPU, memory,
    and I/O bottlenecks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择提供的选项之一，您可以选择更强大的硬件（具有更多CPU、存储和RAM的机器）。监控您的应用程序及其App Service计划将指导您如何决定运行解决方案的最佳基础设施。它还将提供关键见解，例如可能的CPU、内存和I/O瓶颈。
- en: Horizontal scaling (scaling out)
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展（扩展）
- en: 'Scaling out means splitting requests between more servers and using the same
    capacity instead of using more powerful machines. The load on all the servers
    is automatically balanced by the Azure infrastructure. This solution is advised
    when the overall load may change considerably in the future since horizontal scaling
    can automatically adapt to a given load. The following screenshot shows an automatic
    **Scale out** strategy defined by two simple rules, triggered by CPU usage:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着在更多服务器之间分配请求，并使用相同的容量，而不是使用更强大的机器。所有服务器的负载将由 Azure 基础设施自动平衡。当整体负载可能在将来发生显著变化时，建议采用这种解决方案，因为水平扩展可以自动适应给定的负载。以下截图显示了由两个简单的规则定义的自动
    **扩展** 策略，这些规则由 CPU 使用情况触发：
- en: '![](img/B19820_02_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_02_05.png)'
- en: 'Figure 2.5: Horizontal scaling sample'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：水平扩展示例
- en: It is worth highlighting that you can choose to have a hardcoded instance count
    or implement rules for automatic scale in/out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，你可以选择使用硬编码的实例计数或实现自动扩展/缩小的规则。
- en: A complete description of all the available autoscale rules is beyond the scope
    of this book. However, they are quite self-explanatory, and the *Further reading*
    section contains links to the full documentation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的自动扩展规则的完整描述超出了本书的范围。然而，它们相当直观，*进一步阅读*部分包含指向完整文档的链接。
- en: The **Scale out** feature is only available in paid service plans.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展**功能仅在付费服务计划中可用。'
- en: In general, horizontal scaling is a way to guarantee availability in an application
    even with several simultaneous accesses. For sure, its use is not the only way
    to keep a system available, but it does help.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，水平扩展是一种即使在多个同时访问的情况下也能保证应用程序可用性的方法。当然，它的使用并不是保持系统可用的唯一方法，但它确实有帮助。
- en: Creating a scalable web app with .NET 8
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET 8 创建可扩展的 Web 应用
- en: Among all the available frameworks for implementing web apps, running web apps
    with ASP.NET Core in .NET 8 ensures good performance, together with low production
    and maintenance costs. The union of C#, a strongly typed and advanced general-purpose
    language, and continuous performance improvements achieved in ASP.NET Core distinguish
    this option as one of the best for enterprise development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用于实现 Web 应用的框架中，使用 .NET 8 中的 ASP.NET Core 运行时运行 Web 应用确保了良好的性能，同时生产和维护成本较低。C#（一种强类型和高级通用语言）与在
    ASP.NET Core 中实现的持续性能改进的结合，使这一选项成为企业开发中最佳选择之一。
- en: The steps in this section will guide you through the creation of an ASP.NET
    Core Runtime 8-based web app. All the steps are quite simple, but some details
    require particular attention.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的步骤将指导你创建一个基于 ASP.NET Core Runtime 8 的 Web 应用。所有步骤都非常简单，但一些细节需要特别注意。
- en: It is worth mentioning that .NET 8 gives you the opportunity to develop for
    any platform – desktops (WPF, Windows Forms, and UWP), web (ASP.NET), cloud (Azure),
    mobile (Xamarin), gaming (Unity), IoT (ARM32 and ARM64), or AI (ML.NET and .NET
    for Apache Spark). So, the recommendation from now on is to only use .NET 8\.
    In this scenario, you can run your web app on either Windows servers or cheaper
    Linux servers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，.NET 8 给你提供了为任何平台开发的机会——桌面（WPF、Windows Forms 和 UWP）、Web（ASP.NET）、云（Azure）、移动（Xamarin）、游戏（Unity）、物联网（ARM32
    和 ARM64）或人工智能（ML.NET 和 .NET for Apache Spark）。因此，从现在起，建议只使用 .NET 8。在这种情况下，你可以将你的
    Web 应用运行在 Windows 服务器或更便宜的 Linux 服务器上。
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core/5+ or you are deploying your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core/5+ because it allows you to do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Microsoft 推荐使用经典 .NET，以防所需的特性在 .NET Core/5+ 中不可用，或者你正在将你的 Web 应用部署到一个不支持
    .NET Core 的环境中。在任何其他情况下，你应该优先选择 .NET Core/5+，因为它允许你做以下事情：
- en: Run your web app in Windows, Linux, macOS, or Docker containers
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows、Linux、macOS 或 Docker 容器中运行你的 Web 应用
- en: Design your solution with microservices
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微服务设计你的解决方案
- en: Have high-performance and scalable systems
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有高性能和可扩展的系统
- en: Containers and microservices will be covered in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*. There, you will get a better understanding
    of the advantages of these technologies. For now, it is enough to say that .NET
    8 and microservices were designed for performance and scalability, which is why
    you should prefer .NET 8 in all your new projects. Besides, .NET 8 is guaranteed
    by Microsoft as a Long Term Support version, which means three years of patches
    and free support.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务将在**第 11 章**，**将微服务架构应用于您的企业应用程序**中介绍。在那里，您将更好地了解这些技术的优势。目前，只需说 .NET 8
    和微服务是为了性能和可扩展性而设计的就足够了，这就是为什么您应该在所有新项目中首选 .NET 8。此外，.NET 8 由微软保证为长期支持版本，这意味着三年内提供补丁和免费支持。
- en: '![](img/B19820_02_06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_06.png)'
- en: 'Figure 2.6: .NET 8 support policy'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：.NET 8 支持策略
- en: 'The following procedure will show you how to create an ASP.NET Core web app
    in Visual Studio 2022 with .NET 8:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程将向您展示如何在 Visual Studio 2022 中使用 .NET 8 创建 ASP.NET Core Web 应用程序：
- en: As soon as you start VS 2022, you will be able to click on **Create a new project**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您启动 VS 2022 时，您将能够点击**创建新项目**。
- en: 'Once you select **ASP.NET Core Web App**, you will be directed to a screen
    where you will be asked to set up **Project name**, **Location**, and **Solution
    name**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您选择了**ASP.NET Core Web 应用程序**，您将被引导到一个屏幕，您将需要设置**项目名称**、**位置**和**解决方案名称**：
- en: '![](img/B19820_02_07.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_07.png)'
- en: 'Figure 2.7: Creating an ASP.NET Core web application'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：创建 ASP.NET Core Web 应用程序
- en: After that, you will be able to select the .NET version to use. Select **.NET
    8.0** to get the most advanced and up-to-date platform.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您将能够选择要使用的 .NET 版本。选择**.NET 8.0**以获得最先进和最新的平台。
- en: Click **Create** to create your ASP.NET Core 8 web app.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**以创建您的 ASP.NET Core 8 Web 应用程序。
- en: Now that you are done with adding the basic details, you can connect your web
    app project to your Azure account and publish it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经添加了基本详情，您可以将您的 Web 应用程序项目连接到您的 Azure 账户并发布它。
- en: If you right-click the project you created in Solution Explorer, you have the
    option to **Publish**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在解决方案资源管理器中右键单击创建的项目，您有**发布**的选项。
- en: 'You will find different targets in terms of where to publish your web app.
    Select **Azure** as the target:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将找到不同的目标，用于确定发布您的 Web 应用程序的位置。选择**Azure**作为目标：
- en: '![](img/B19820_02_08.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_08.png)'
- en: 'Figure 2.8: Targeting Azure to publish the app'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：将应用程序发布到 Azure 的目标
- en: Then, you will be able to decide the specific target to publish. Select **Azure
    App Service (Windows)** for this demo.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将能够决定具体的发布目标。选择此演示的**Azure App Service (Windows)**。
- en: You may be required to define your Microsoft Account credentials at this time.
    This is because there is full integration between Visual Studio and Azure. This
    gives you the opportunity to view all the resources you created in the Azure portal
    in your development environment.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要在此处定义您的 Microsoft 账户凭据。这是因为 Visual Studio 和 Azure 之间有完全集成。这为您提供了一个机会，在您的开发环境中查看
    Azure 门户中创建的所有资源。
- en: '![](img/B19820_02_09.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_09.png)'
- en: 'Figure 2.9: Integration between Visual Studio and Azure'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：Visual Studio 和 Azure 之间的集成
- en: 'If you want to create a new web app using Visual Studio, make sure to select
    the **Free Size** tier of pricing during the App Service creation process so that
    this does not incur any costs:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用 Visual Studio 创建新的 Web 应用程序，请确保在 App Service 创建过程中选择定价的**免费大小**层，这样就不会产生任何费用：
- en: '![](img/B19820_02_10.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_10.png)'
- en: 'Figure 2.10: Creating a New Hosting Plan'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：创建新的托管计划
- en: The usual way to deploy using Visual Studio is by selecting **Publish Profile**,
    which generates a `.pubxml` file, which is a Visual Studio publish profile. In
    this case, you currently have two modes for deployment.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 部署的常用方法是选择**发布配置文件**，这将生成一个 `.pubxml` 文件，这是一个 Visual Studio
    发布配置文件。在这种情况下，您目前有两种部署模式。
- en: 'The first, **Framework-dependent**, will require a web app configured with
    the target framework. The second, **Self-contained**, will not need this feature
    since the binaries of the framework will be published together with the application.
    Once the file is created and the options are selected, you just click on the **Publish**
    button, and the process will start:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个，**框架依赖型**，将需要一个配置了目标框架的 Web 应用程序。第二个，**自包含型**，由于框架的二进制文件将与应用程序一起发布，因此不需要此功能。一旦文件创建并选择了选项，您只需点击**发布**按钮，过程就会开始：
- en: '![](img/B19820_02_11.png)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_11.png)'
- en: 'Figure 2.11: Publish profile web deploy'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.11：发布配置文件 Web 部署
- en: 'It is worth mentioning that to publish ASP.NET Preview versions in **Framework-dependent**
    mode, you must add an extension in the web app setup panel in the Azure portal,
    as shown in the following screenshot. However, consider using **Self-contained**
    mode, especially when you are under preview versions and using Windows apps:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，为了以**框架依赖**模式发布ASP.NET预览版本，你必须在Azure门户中的Web应用设置面板中添加一个扩展，如图下所示。然而，考虑到你正在使用预览版本和Windows应用，建议使用**自包含**模式：
- en: '![](img/B19820_02_12.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_12.png)'
- en: 'Figure 2.12: Adding extensions in Azure App Service'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：在Azure App Service中添加扩展
- en: 'For more information on deploying ASP.NET Core 8.0 to Azure App Service, please
    refer to the following link: [https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将ASP.NET Core 8.0部署到Azure App Service的更多信息，请参阅以下链接：[https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-8.0&tabs=visual-studio)。
- en: Although publishing using Visual Studio 2022 may be considered a good option
    for demonstration, in the real world, it is almost impossible to keep your publishing
    strategy using it. For this reason, you might consider using a CI/CD flow based
    on GitHub Actions, which automatically enables deployment on the code being pushed
    to a GitHub repo. It is worth mentioning that you must be connected to a GitHub
    repo to access this new function. Let us use this new feature for this demonstration.
    We will discuss it in more depth in *Chapter 8**, Understanding DevOps Principles
    and CI/CD*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Visual Studio 2022发布可能被认为是演示的好选择，但在现实世界中，几乎不可能保持使用它的发布策略。因此，你可能考虑使用基于GitHub
    Actions的CI/CD流程，该流程会自动在推送到GitHub仓库的代码上启用部署。值得注意的是，你必须连接到GitHub仓库才能访问这个新功能。让我们使用这个新功能进行演示。我们将在*第8章*，理解DevOps原则和CI/CD中更深入地讨论它。
- en: '![](img/B19820_02_13.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_13.png)'
- en: 'Figure 2.13: Deploying a web app using GitHub actions'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：使用GitHub actions部署Web应用
- en: Once you have pushed your code, you can go to the GitHub Actions pane and select
    the way you want to deploy the web app.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你推送了你的代码，你可以转到GitHub Actions面板并选择你想要部署Web应用的方式。
- en: For this second demo, you can select **Deploy a .NET Core app to an Azure Web
    App**. With this option, you will have a YAML file created with all the instructions
    needed to connect your code to the web app.![](img/B19820_02_14.png)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个第二个演示，你可以选择**将.NET Core应用部署到Azure Web应用**。使用此选项，将创建一个包含连接你的代码到Web应用所需所有指令的YAML文件！![图片](img/B19820_02_14.png)
- en: 'Figure 2.14: YAML file used to deploy the application'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.14：用于部署应用程序的YAML文件
- en: Depending on the web app you want to deploy, you will need a different script.
    These scripts are documented at [https://github.com/Azure/webapps-deploy](https://github.com/Azure/webapps-deploy).
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你想要部署的Web应用，你可能需要不同的脚本。这些脚本在[https://github.com/Azure/webapps-deploy](https://github.com/Azure/webapps-deploy)上有文档说明。
- en: 'Once you have set the correct script, you will be able to check the execution
    of the GitHub Action:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你设置了正确的脚本，你将能够检查GitHub Action的执行情况：
- en: '![](img/B19820_02_15.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_15.png)'
- en: 'Figure 2.15: GitHub Actions tab'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：GitHub Actions标签页
- en: Here, we described two ways to deploy a web app. In *Chapter 8**, Understanding
    DevOps Principles and CI/CD*, we will go further into **Continuous Integration/Continuous
    Delivery** (**CI/CD**) strategies to guarantee all the steps required to get an
    application to production, that is, building, testing, deployment to staging,
    and deployment to production.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了两种部署Web应用的方法。在*第8章*，理解DevOps原则和CI/CD*中，我们将进一步探讨**持续集成/持续交付**（**CI/CD**）策略，以确保将应用程序部署到生产所需的全部步骤，即构建、测试、部署到预发布环境和部署到生产环境。
- en: Now that you have learned a great way to make your web apps run on Azure, using
    Visual Studio as a helpful tool, it is essential to understand some performance
    issues that may cause struggles while creating a solution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学会了一种让Web应用在Azure上运行的好方法，使用Visual Studio作为有用的工具，了解一些可能导致创建解决方案时遇到困难的功能问题就变得至关重要。
- en: Performance issues that need to be considered when programming in C#
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#编程时需要考虑的性能问题
- en: Nowadays, C# is one of the most used programming languages in the world, so
    awareness of C# programming best practices is fundamental for the design of good
    architectures that satisfy the most common non-functional requirements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，C# 是世界上使用最广泛的编程语言之一，因此了解 C# 编程的最佳实践对于设计满足最常见非功能性要求的好架构是基本的。
- en: The following sections mention a few simple but effective tips – the associated
    code samples are available in this book’s GitHub repository. It is worth mentioning
    that .NET Foundation has developed a library dedicated to benchmarking called
    BenchmarkDotNet. You may find it useful for your scenarios. Check it out at [https://benchmarkdotnet.org/](https://benchmarkdotnet.org/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将提到一些简单但有效的技巧——相关的代码示例可在本书的 GitHub 仓库中找到。值得一提的是，.NET 基金会已经开发了一个用于基准测试的库，称为
    BenchmarkDotNet。你可能发现它在你的场景中很有用。请查看 [https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)。
- en: String concatenation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since every time two strings are
    concatenated; their contents are copied into a new string.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典案例！使用 `+` 字符串运算符进行字符串的简单连接可能会导致严重的性能问题，因为每次两个字符串连接时，它们的内 容都会被复制到一个新的字符串中。
- en: So, if we concatenate, for instance, 10 strings that have an average length
    of 100, the first operation has a cost of 200, the second one has a cost of `200+100=300`,
    the third one has a cost of `300+100=400`, and so on. It is not difficult to convince
    yourself that the overall cost grows as `m*n`², where `n` is the number of strings
    and `m` is their average length. `n`² is not too big for small `n` (say, `n <
    10`), but it becomes quite big when `n` reaches the magnitude of 100-1,000 and
    is unacceptable for magnitudes of 10,000-100,000.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们连接，例如，平均长度为 100 的 10 个字符串，第一次操作的成本为 200，第二次操作的成本为 `200+100=300`，第三次操作的成本为
    `300+100=400`，依此类推。不难相信，总成本随着 `m*n`² 增长，其中 `n` 是字符串的数量，`m` 是它们的平均长度。对于小的 `n`（例如，`n
    < 10`），`n`² 不会太大，但当 `n` 达到 100-1,000 的量级时，它就变得相当大了，对于 10,000-100,000 的量级则不可接受。
- en: 'Let us look at this with some test code that compares naive concatenation with
    the same operation but performed with the help of the `StringBuilder` class (the
    code is available in this book’s GitHub repository):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些测试代码来看看这一点，这些代码比较了简单的连接操作与使用 `StringBuilder` 类（代码可在本书的 GitHub 仓库中找到）执行相同操作的情况：
- en: '![Text  Description automatically generated](img/B19820_02_16.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19820_02_16.png)'
- en: 'Figure 2.16: Concatenation test code result'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：连接测试代码结果
- en: If you create a `StringBuilder` class with something like `var sb = new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder`-based concatenation grows simply as `m*n`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个 `StringBuilder` 类，例如 `var sb = new System.Text.StringBuilder()`，然后使用
    `sb.Append(currString)` 将每个字符串添加到其中，字符串不会被复制；相反，它们的指针会被排队到一个列表中。当调用 `sb.ToString()`
    获取最终结果时，它们只会在最终字符串中复制一次。因此，基于 `StringBuilder` 的连接成本简单地随着 `m*n` 增长。
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code like these where the concatenation of some 20-100 strings,
    say, in a web server that handles several requests simultaneously might cause
    bottlenecks that damage your non-functional requirements for performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能永远不会找到一个像前面那样的函数，它会连接 100,000 个字符串。然而，你需要认识到这些代码片段，比如在处理多个并发请求的 Web 服务器中，连接
    20-100 个字符串可能会造成瓶颈，损害你的性能非功能性要求。
- en: Exceptions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Always remember that exceptions are much slower than normal code flow! So, the
    usage of `try-catch` needs to be concise and essential; otherwise, you will have
    big performance issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，异常比正常代码流程慢得多！因此，`try-catch` 的使用需要简洁且必要；否则，你将遇到大的性能问题。
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例比较了使用 `try-catch` 和 `Int32.TryParse` 来检查字符串是否可以转换为整数的方法，如下所示：
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second function does not look dangerous, but it is thousands of times slower
    than the first one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数看起来并不危险，但它比第一个慢数千倍：
- en: '![Text  Description automatically generated](img/B19820_02_17.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19820_02_17.png)'
- en: 'Figure 2.17: Exception test code result'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17：异常测试代码结果
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，必须使用异常来处理破坏正常控制流程的异常情况，例如，当操作因某些意外原因必须中止时，并且必须将控制权返回到调用堆栈的几个级别。
- en: Multithreading environments for better results – dos and don’ts
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程环境以获得更好的结果——应该做和不应该做的事情
- en: If you want to take advantage of all the hardware that the system you are building
    provides, you must use multithreading. This way, when a thread is waiting for
    an operation to complete, the application can leave the CPU to other threads instead
    of wasting CPU time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要充分利用你正在构建的系统提供的所有硬件，你必须使用多线程。这样，当一个线程正在等待某个操作完成时，应用程序可以将 CPU 交给其他线程，而不是浪费
    CPU 时间。
- en: 'On the other hand, no matter how hard Microsoft works to help with this, parallel
    code is not as simple as eating a piece of cake: it is error-prone and difficult
    to test and debug. The most important thing to remember as a software architect
    when you start considering using threads is *does your system require them?* Non-functional
    and some functional requirements will answer this question for you.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无论微软如何努力帮助解决这个问题，并行代码并不像吃一块蛋糕那么简单：它容易出错，难以测试和调试。作为一个软件架构师，当你开始考虑使用线程时，最重要的事情要记住的是*你的系统是否需要它们？*
    非功能性和一些功能性需求会为你回答这个问题。
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定你需要一个多线程系统，你应该决定哪种技术更适合。这里有几个选项，如下：
- en: '**Creating an instance of** `System.Threading.Thread`: This is a classic way
    of creating threads in C#. The entire thread life cycle will be in your hands.
    This is good when you are sure about what you are going to do, but you need to
    worry about every single detail of the implementation. The resulting code is hard
    to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental, performance-critical modules.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** `System.Threading.Thread` 的实例：这是在 C# 中创建线程的经典方式。整个线程生命周期将完全由你掌控。当你确信你要做什么时，这很好，但你需要关注实现中的每一个细节。生成的代码难以构思、调试/测试/维护。因此，为了保持开发成本在可接受范围内，这种方法应该仅限于少数基本、性能关键模块。'
- en: '**Managing threads using** `System.Threading.ThreadPool`: You can reduce the
    complexity of this implementation by using the `ThreadPool` class. Especially
    if you intend to develop a solution in which you will have many threads being
    executed, this could be a good option. It is worth mentioning that the .NET thread
    pool has been re-implemented in .NET 6 as a C# class, which will bring new possibilities
    for experimentation or customization.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `System.Threading.ThreadPool` 管理线程：你可以通过使用 `ThreadPool` 类来简化这种实现。特别是如果你打算开发一个将会有许多线程被执行的解决方案，这可能是一个不错的选择。值得一提的是，.NET
    线程池在 .NET 6 中已被重新实现为一个 C# 类，这将带来新的实验或定制可能性。'
- en: '**Programming using** `System.Threading.Tasks.Parallel` classes: Since .NET
    Framework 4.0, you can use parallel classes to enable threads in a simpler way.
    This is good because you do not need to worry about the life cycle of the threads
    you create, but it will give you less control over what is happening in each thread.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `System.Threading.Tasks.Parallel` 类进行编程：自 .NET Framework 4.0 以来，你可以使用并行类以更简单的方式启用线程。这很好，因为你不需要担心你创建的线程的生命周期，但它会给你更少的控制权来了解每个线程中发生的事情。'
- en: '**Developing using asynchronous programming**: This is, for sure, the easiest
    way to develop multithreaded applications since the compiler takes on most of
    the work. Depending on the way you call an asynchronous method, you may have the
    `Task` created running in parallel with the `Thread` that was used to call it
    or even keep that `Thread` waiting without suspending for the `Task` that was
    created to conclude. This way, asynchronous code mimics the behavior of classical
    synchronous code while keeping most of the performance advantages of general parallel
    programming:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用异步编程进行开发**：这无疑是开发多线程应用程序最容易的方式，因为编译器承担了大部分工作。根据你调用异步方法的方式，创建的`Task`可能会与调用它的`Thread`并行运行，或者甚至保持该`Thread`等待，而不为创建的`Task`挂起。这样，异步代码模拟了经典同步代码的行为，同时保持了通用并行编程的大部分性能优势：'
- en: The overall behavior is deterministic and does not depend on the time taken
    by each task to complete, so non-reproducible bugs are less likely to happen,
    and the resulting code is easy to test/debug/maintain. Defining a method as an
    asynchronous task or not is the only choice left to the programmer; everything
    else is automatically handled by the runtime. The only thing you should be concerned
    about is which methods should have asynchronous behavior. It is worth mentioning
    that defining a method as `async` does not mean it will execute on a separate
    thread. You may find useful information in a great sample at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体行为是确定的，并且不依赖于每个任务完成所需的时间，因此非可复现的bug出现的可能性较小，生成的代码易于测试/调试/维护。将方法定义为异步任务或不是，是程序员唯一的选择；其他一切由运行时自动处理。你应该关注的是哪些方法应该具有异步行为。值得一提的是，将方法定义为`async`并不意味着它将在单独的线程上执行。你可以在一个优秀的示例中找到有用的信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)。
- en: Later in this book, we will provide some simple examples of asynchronous programming.
    For more information about asynchronous programming and its related patterns,
    please check out *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)).
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将提供一些异步编程的简单示例。有关异步编程及其相关模式的信息，请参阅微软文档中的*基于任务的异步模式* ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap))。
- en: '**TAP** is the evolution of **EAP** (**Event-Based Asynchronous Pattern**),
    which, in turn, is the successor to **APM** (**Asynchronous Programming Model
    Pattern**).'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**TAP**是**EAP**（基于事件的异步模式）的演变，而**EAP**又是**APM**（异步编程模型模式）的后继者。'
- en: 'No matter the option you choose, there are some dos and don’ts that, as a software
    architect, you must pay attention to. These are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种选项，作为软件架构师，你必须注意一些“应该做”和“不应该做”的事情。以下是一些注意事项：
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the most
    convenient option for developing thread-safe programs.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请务必使用并发集合** (`System.Collections.Concurrent`): 一旦你开始一个多线程应用程序，你就必须使用这些集合。原因是你的程序可能会从不同的线程管理相同的列表、字典等。使用并发集合是开发线程安全程序最方便的选项。'
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    cannot be used for extra-thread communications since values written by a thread
    cannot be read by other threads. In asynchronous programming, `AsyncLocal<T>`
    is the option for doing something like that.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忽视静态变量**：不能说在多线程开发中禁止使用静态变量，但你应该注意它们。再次强调，多个线程处理相同的变量可能会引起很多麻烦。如果你用`[ThreadStatic]`属性装饰静态变量，每个线程都会看到该变量的不同副本，从而解决了多个线程竞争同一值的问题。然而，`ThreadStatic`变量不能用于跨线程通信，因为一个线程写入的值不能被其他线程读取。在异步编程中，`AsyncLocal<T>`是执行类似操作的选项。'
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)`
    call in the main loop of some threads to prevent them from wasting too much CPU
    time, but you need to test this. A use case for this implementation is a Windows
    service with many threads running in the background.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在多线程实现后测试系统性能**：线程让你能够充分利用你的硬件，但在某些情况下，编写不良的线程可能会浪费CPU时间而无所作为！类似的情况可能会导致几乎100%的CPU使用率和不可接受的系统减速。在某些情况下，通过在某个线程的主循环中添加一个简单的`Thread.Sleep(1)`调用，可以减轻或解决这些问题，以防止它们浪费过多的CPU时间，但你需要测试这一点。这种实现的用例是一个在后台运行许多线程的Windows服务。'
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to bad implementation of multithreading.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要认为多线程很简单**：多线程并不像某些语法实现中看起来那么简单。在编写多线程应用程序时，你应该考虑诸如用户界面的同步、线程终止和协调等问题。在许多情况下，程序只是因为多线程实现不当而停止正常工作。'
- en: '**Do not forget to plan the number of threads your system should have**: This
    is especially important for 32-bit programs. There is a limitation regarding how
    many threads you can have in any environment. You should consider this when you
    are designing your system.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记规划你的系统应该拥有的线程数量**：这对于32位程序尤为重要。在任何环境中，你可以拥有的线程数量都有限制。在设计系统时，你应该考虑这一点。'
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handling
    leaks.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记结束你的线程**：如果你没有为每个线程提供正确的终止程序，你可能会在内存和处理泄漏方面遇到麻烦。'
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the entire processing pipeline, which
    includes both humans and machines. For this reason, in the next section, we will
    discuss how to design effective user interfaces.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性、性能提示和多线程是我们用来调整机器性能的主要工具。然而，你设计的系统的有效性取决于整个处理管道的整体性能，这包括人类和机器。因此，在下一节中，我们将讨论如何设计有效的用户界面。
- en: 'Software usability: how to design effective user interfaces'
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件可用性：如何设计有效的用户界面
- en: 'As a software architect, you cannot improve the performance of humans, but
    you can improve the performance of human-machine interaction by designing an effective
    **user interface** (**UI**), that is, a UI that ensures fast interaction with
    humans, which, in turn, means the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你无法提高人类的能力，但你可以通过设计一个有效的**用户界面**（**UI**），即确保与人类快速交互的界面来提高人机交互的性能，这反过来意味着以下内容：
- en: The UI must be easy to learn to reduce the time that is needed for the target
    users to learn how to operate it. This constraint is fundamental if UI changes
    are frequent and for public websites that need to attract the greatest possible
    number of users.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面必须易于学习，以减少目标用户学习如何操作所需的时间。如果用户界面经常更改，或者对于需要吸引尽可能多用户的公共网站来说，这个限制是基本的。
- en: The UI must not cause any kind of slowdown in data insertion; data entry speed
    must be limited only by the user’s ability to type, not by system delays or additional
    gestures that could be avoided.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面不得在数据插入时造成任何类型的减速；数据输入速度必须仅限于用户的打字能力，而不是由系统延迟或可以避免的额外手势。
- en: Today, we must also consider the accessibility aspects of our solutions since
    doing so allows us to include more users.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们必须考虑我们解决方案的可访问性方面，因为这样做可以让我们包括更多的用户。
- en: 'It is worth mentioning that we have UX experts in the market. As a software
    architect, you must decide when they are essential to the success of the project.
    The following are a few simple tips when it comes to designing *easy-to-learn*
    user interfaces:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，市场上我们有用户体验专家。作为一名软件架构师，你必须决定他们在项目的成功中何时是必不可少的。以下是在设计*易于学习*的用户界面时的一些简单提示：
- en: Each input screen must state its purpose clearly.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个输入屏幕必须清楚地说明其目的。
- en: Use the language of the user, not the language of developers.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户的语言，而不是开发者的语言。
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂化。以平均情况为设计UI的出发点；更复杂的情况可以通过仅在需要时出现的额外输入来处理。将复杂的屏幕拆分为更多的输入步骤。
- en: Use past inputs to understand user intentions and to put users on the right
    path with messages and automatic UI changes, for instance, cascading drop-down
    menus.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过去的输入来理解用户的意图，并通过消息和自动用户界面更改将用户引向正确的路径，例如，级联下拉菜单。
- en: Error messages are not bad notes that the system gives to the users who do something
    that’s wrong, but they must explain how to insert the correct input.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息不是系统给那些做错事的用户的坏评注，但它们必须解释如何插入正确的输入。
- en: 'Fast UIs result from efficacious solutions to the following three requirements:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的用户界面源于对以下三个要求的有效解决方案：
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the *Tab* or *Enter* key. Moreover,
    fields that often remain empty should be placed at the bottom of the form. Simply
    put, the usage of the mouse while filling in a form should be minimized. This
    way, the number of user gestures is kept to a minimum. In a web application, once
    the optimal placement of input fields has been decided, it is enough to use the
    `tabindex` attribute to define the right way for users to move from one input
    field to the next with the *Tab* key.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段必须按照它们通常填充的顺序排列，并且应该可以使用*Tab*或*Enter*键跳转到下一个输入。此外，经常保持空白的字段应放置在表单的底部。简单来说，填写表格时使用鼠标的操作应该最小化。这样，用户的手势数量保持在最低。在Web应用程序中，一旦决定了输入字段的最佳位置，就足够使用`tabindex`属性来定义用户使用*Tab*键从一个输入字段移动到下一个输入字段的正确方式。
- en: System reactions to user input must be as fast as possible. Error messages (or
    information ones) must appear as soon as the user leaves the input field. The
    simplest way to achieve this is to move most of the help and input validation
    logic to the client side so that system reactions do not need to pass through
    both communication lines and servers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统对用户输入的反应必须尽可能快。错误消息（或信息性消息）必须在用户离开输入字段时立即出现。实现这一点的最简单方法是将大部分帮助和输入验证逻辑移动到客户端，这样系统反应就不需要通过通信线路和服务器。
- en: 'Efficacious selection logic: Selecting an existing item should be as easy as
    possible; for example, selecting one out of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to decrease
    complexity to achieve fast selection.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的选择逻辑：选择现有项目应该尽可能简单；例如，在一份包含数千种产品的优惠中选择一个，应该可以通过几个手势完成，而且不需要记住确切的商品名称或其条形码。下一小节将分析我们可以使用的技巧来降低复杂性，以实现快速选择。
- en: 'In *Chapter 19**, Client Frameworks: Blazor*, we will discuss how this Microsoft
    technology can help us with the challenges of building web-based applications
    with C# code in the frontend.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第19章**，客户端框架：Blazor中，我们将讨论这项微软技术如何帮助我们解决使用C#代码在前端构建基于Web应用程序的挑战。
- en: Designing fast selection logic
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计快速选择逻辑
- en: 'When all possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, take this currency selection drop-down
    menu:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有可能的选项的数量级在1-50之间时，通常的下拉菜单就足够了。例如，看看这个货币选择下拉菜单：
- en: '![A picture containing calendar  Description automatically generated](img/B19820_02_18.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![包含日历的图片 描述自动生成](img/B19820_02_18.png)'
- en: 'Figure 2.18: Simple drop-down menu'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：简单下拉菜单
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当数量级较高但不到几千时，显示以用户输入的字符开头的所有项目名称的自动完成通常是一个不错的选择：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B19820_02_19.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息 描述自动生成](img/B19820_02_19.png)'
- en: 'Figure 2.19: Complex drop-down menu'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：复杂下拉菜单
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有主要数据库都可以有效地选择以给定子串开头的字符串，因此可以通过低计算成本实现类似的解决方案。
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    cannot be performed efficiently with the usual databases and requires ad hoc data
    structures, nor can we forget the debouncing aspect that can happen while typing
    as a performance issue.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称相当复杂时，在搜索用户输入的字符时，它们应该在每个项目字符串内部进行扩展。这种操作不能使用常规数据库有效地执行，需要专门的数据结构，同时我们也不能忘记在输入时可能出现的防抖动方面的问题，这可能会影响性能。
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, with
    product descriptions. If the chosen database supports full-text search, the system
    can efficiently search for the occurrence of several words that have been typed
    by the user inside all the descriptions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们搜索由多个单词组成的描述时，需要更复杂的搜索模式。例如，产品描述就是这样。如果所选数据库支持全文搜索，系统可以有效地在所有描述中搜索用户输入的多个单词的出现。
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms cannot be implemented efficiently with databases based on indexes but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当描述由名称而不是常用词组成时，用户可能很难记住目标描述中包含的几个确切名称。例如，多国公司名称就是这样。在这些情况下，我们需要找到用户输入的字符最佳匹配的算法。必须在每个描述的不同位置搜索用户输入的字符串的子串。一般来说，基于索引的数据库无法有效地实现类似的算法，而需要将所有描述加载到内存中，并以某种方式对用户输入的字符串进行排序。
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spellcheckers to find a word that best fits the one that
    was mistyped by the user. This algorithm minimizes the Levenshtein distance between
    the description and the string typed by the user, that is, the minimum number
    of character removals and additions needed to transform one string into another.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这类算法中最著名的算法可能是**Levenshtein**算法，该算法被大多数拼写检查器用来找到与用户输入的错误单词最匹配的单词。该算法最小化描述与用户输入的字符串之间的Levenshtein距离，即转换一个字符串为另一个字符串所需的最小字符删除和添加次数。
- en: The Levenshtein algorithm works great but has a very high computational cost.
    Here, we use a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user do not need to occur consecutively
    in the description but must occur in the same order. Some characters may be missing.
    Each description is given a penalty that depends on the missing characters and
    on how far the occurrences of the characters typed by the user are from the others.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein算法效果很好，但计算成本非常高。在这里，我们使用了一种更快的算法，它适用于在描述中搜索字符出现。用户输入的字符不需要在描述中连续出现，但必须按相同的顺序出现。某些字符可能缺失。每个描述都会根据缺失的字符和用户输入的字符与其他字符出现距离的远近给予一个惩罚。
- en: 'More specifically, the algorithm ranks each description with two numbers:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，算法使用两个数字对每个描述进行排名：
- en: 'The number of characters typed by the user that occurs in the description:
    the more characters contained in the description, the higher its rank.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的字符在描述中出现的次数：描述中包含的字符越多，其排名越高。
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个描述都会根据用户在描述中输入的字符出现的总距离给予一个惩罚。
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了单词**爱尔兰**与用户输入的字符串**ilad**的排名对比：
- en: '![A picture containing diagram  Description automatically generated](img/B19820_02_20.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![包含图描述自动生成的图片](img/B19820_02_20.png)'
- en: 'Figure 2.20: Sample of Levenshtein usage'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：Levenshtein使用示例
- en: The number of occurrences is four, while the total distance between character
    occurrences is three.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 出现次数为四次，而字符出现之间的总距离为三次。
- en: 'Once all the descriptions have been rated, they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有描述都被评分，它们将根据出现次数进行排序。出现次数相同的描述将根据最低的惩罚进行排序。以下是一个实现上述算法的自动完成示例：
- en: '![Diagram  Description automatically generated with medium confidence](img/B19820_02_21.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成，置信度中等](img/B19820_02_21.png)'
- en: 'Figure 2.21: Levenshtein algorithm UI experience'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：Levenshtein算法UI体验
- en: The full class code, along with a test console project, is available in this
    book’s GitHub repository.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类代码，以及测试控制台项目，可在本书的GitHub仓库中找到。
- en: Selecting from a huge number of items
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从大量项目中选择
- en: Here, *huge* does not refer to the amount of space needed to store the data
    but to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope of finding it by searching for character occurrences inside a description.
    Here, the user must be driven toward the right item through a hierarchy of categories.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*巨大*并不是指存储数据所需的空间量，而是指用户记住每个项目特征的难度。当必须从超过10,000-100,000个项目中选择一个项目时，通过在描述中搜索字符出现来找到它的希望就渺茫了。在这里，用户必须通过一系列的分类层次结构被引导到正确的项目。
- en: In this case, several user gestures are needed to perform a single selection.
    In other words, each selection requires interaction with several input fields.
    Once it is decided that the selection can’t be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要几个用户手势才能完成单个选择。换句话说，每个选择都需要与多个输入字段进行交互。一旦确定选择不能通过单个输入字段完成，最简单的选项就是级联下拉菜单，即依赖于前一个下拉菜单中选择的值的下拉菜单链。
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户需要在世界任何地方选择一个城镇，我们可能使用第一个下拉菜单来选择国家，一旦国家被选中，我们可能使用这个选择来填充第二个下拉菜单，其中包含所选国家的所有城镇。一个简单的例子如下：
- en: '![](img/B19820_02_22.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_22.png)'
- en: 'Figure 2.22: Cascading drop-down menu example'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：级联下拉菜单示例
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当有大量选项时，每个下拉菜单在需要时都可以被自动完成功能所替代。
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过交叉多个不同的层次结构来做出正确的选择变得效率低下，那么级联下拉菜单也会变得不高效，我们需要一个筛选表单，如下所示：
- en: '![](img/B19820_02_23.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_02_23.png)'
- en: 'Figure 2.23: Filter form sample'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：筛选表单示例
- en: Now, let us understand interoperability with .NET 6.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解与.NET 6的互操作性。
- en: Interoperability with .NET 8
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与.NET 8的互操作性
- en: Since .NET Core, Microsoft has brought to C# developers the ability to deliver
    their software to various platforms. And you, as a software architect, need to
    pay attention to this, considering developing for Linux and macOS as a great opportunity
    to deliver new features to your customers. Therefore, we need to ensure performance
    and multi-platform support, two common non-functional requirements for many systems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自从.NET Core以来，微软为C#开发者带来了将他们的软件部署到各种平台的能力。作为软件架构师，您需要关注这一点，考虑到为Linux和macOS开发是一个向客户交付新特性的绝佳机会。因此，我们需要确保性能和多平台支持，这是许多系统常见的非功能性需求。
- en: Both console applications and web apps designed with .NET 8 in Windows are almost
    completely compatible with Linux and macOS, too. This means you do not have to
    build the app again to run it on these platforms.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上使用.NET 8设计的控制台应用程序和Web应用程序几乎与Linux和macOS完全兼容。这意味着您不需要为这些平台重新构建应用程序。
- en: Microsoft offers scripts to help you install .NET on Linux and macOS. You can
    find them at [https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call `dotnet` the same way you
    do in Windows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了帮助您在Linux和macOS上安装.NET的脚本。您可以在[https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script)找到它们。一旦安装了SDK，您只需像在Windows上一样调用`dotnet`即可。
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes, and you must develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您必须意识到一些与Linux和macOS系统不完全兼容的功能。例如，这些操作系统中没有Windows注册表的等价物，您必须自己开发替代方案。如果需要，加密的JSON配置文件是一个不错的选择。
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` field and all the other `Path` class members to ensure
    your code is multi-platform. `Environment.NewLine` can also be useful in some
    situations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要点是，Linux是区分大小写的，而Windows不是。当您处理文件时，请记住这一点。另一件重要的事情是，Linux的路径分隔符与Windows的不同。您可以使用`Path.PathSeparator`字段和所有其他`Path`类成员来确保您的代码是跨平台的。在某些情况下，`Environment.NewLine`也可能很有用。
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET 8, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过使用.NET 8提供的运行时检查来适应底层操作系统，如下所示：
- en: '[PRE1]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip – creating a service in Linux
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示 - 在Linux中创建服务
- en: 'There are some good ways to create a service when you are developing on Windows,
    but how can we get the same result if we are developing for the Linux platform?
    The following script can be used to encapsulate a command-line .NET 8 app in Linux.
    The idea is that this service works like a Windows service. This can be useful,
    considering that most Linux installations are command-line-only and run without
    a user logged in:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Windows上开发时，有一些创建服务的好方法，但如果我们为Linux平台开发，我们如何获得相同的结果？以下脚本可以用来封装Linux中的命令行.NET
    8应用程序。这个想法是，这个服务就像Windows服务一样工作。考虑到大多数Linux安装都是仅命令行且无需用户登录即可运行，这可能会很有用：
- en: 'The first step is to create a file that will run the command-line app. The
    name of the app is `app.dll`, and it is installed in `appfolder`. The application
    will be checked every 5,000 milliseconds. This service was created on a CentOS
    7 system. Using a Linux terminal, you can type this:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个运行命令行应用程序的文件。应用程序的名称是`app.dll`，它安装在`appfolder`中。该应用程序将每5,000毫秒检查一次。这个服务是在CentOS
    7系统上创建的。使用Linux终端，您可以输入以下内容：
- en: '[PRE2]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the file has been created, you must copy the service file to a system
    location. After that, you must reload the system and enable the service so that
    it will restart on reboots:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件创建完成，你必须将服务文件复制到系统位置。之后，你必须重新加载系统并启用服务，以便在重启时重新启动：
- en: '[PRE3]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成！现在，你可以使用以下命令开始、停止和检查服务。你需要在命令行应用程序中提供的整个输入如下：
- en: '[PRE4]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have learned about a few concepts, let us learn how to implement
    them in our use case.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些概念，让我们学习如何在我们的用例中实现它们。
- en: Achieving security by design
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设计实现安全
- en: As we have seen up to this point in the book, the opportunities and techniques
    we have for developing software are incredible. If you add all the information
    you will read about in relation to cloud computing in the next chapters, you will
    see that the opportunities just increase, as does the complexity involved in maintaining
    this computing environment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本书的这一部分所看到的那样，我们用于开发软件的机会和技术是令人难以置信的。如果你加上下一章中关于云计算的所有信息，你会发现机会只会增加，同时维护这个计算环境的复杂性也会增加。
- en: As a software architect, you must understand that these opportunities come with
    many responsibilities. The world has changed a lot in recent years. The second
    decade of the 21st century has required lots of technology. Apps, social media,
    Industry 4.0, big data, and artificial intelligence are no longer future objectives
    but current projects that you will lead and deal with within your daily routine.
    However, the third decade of our century will require much more attention when
    it comes to cybersecurity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你必须明白，这些机会伴随着许多责任。近年来，世界发生了很大的变化。21世纪的第二个十年需要大量的技术。应用、社交媒体、工业4.0、大数据和人工智能不再是未来的目标，而是你将在日常工作中领导和处理的当前项目。然而，当我们进入本世纪的第三个十年时，在网络安全方面需要更多的关注。
- en: The world now regulates companies that manage personal data. For instance, the
    GDPR – the General Data Protection Regulation – is mandatory not only for European
    territory but also for the whole world; it has changed the way software is developed.
    There are many initiatives comparable to the GDPR that must be added to your glossary
    of techniques and regulations, considering that the software you design will be
    impacted by them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在世界正在规范管理个人数据的公司。例如，通用数据保护条例（GDPR）不仅对欧洲领土是强制性的，而且对全世界都是强制性的；它改变了软件开发的方式。有许多与GDPR类似的倡议必须添加到你的技术和法规术语表中，考虑到你设计的软件将受到它们的影响。
- en: Security by design must be one of your areas of focus for designing new applications.
    This subject is huge, and it is not going to be completely covered in this book,
    but as a software architect, you must understand the necessity of having a specialist
    in the information security area in your team to guarantee the policies and practices
    needed to avoid cyber-attacks and maintain the confidentiality, privacy, integrity,
    authenticity, and availability of the services you architect.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新应用程序时，设计安全必须成为你关注的领域之一。这个主题非常庞大，本书不会完全涵盖，但作为一名软件架构师，你必须理解在团队中拥有信息安全管理专家的必要性，以确保避免网络攻击并维护你设计的服务的机密性、隐私性、完整性、真实性和可用性。
- en: When it comes to protecting your ASP.NET Core application, it is worth mentioning
    that the framework has many features to help you out with that. For instance,
    it includes authentication and authorization patterns. In the OWASP Cheat Sheet
    Series, you can read about many other .NET practices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到保护你的ASP.NET Core应用程序时，值得提到的是，该框架有许多功能可以帮助你完成这项任务。例如，它包括身份验证和授权模式。在OWASP作弊表系列中，你可以了解许多其他的.NET实践。
- en: The **Open Web Application Security Project**® (**OWASP**) is a nonprofit foundation
    that works to improve the security of software. Check it out at [https://owasp.org/](https://owasp.org/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放网络应用安全项目**®（OWASP）是一个非营利性基金会，致力于提高软件的安全性。请访问[https://owasp.org/](https://owasp.org/)了解更多信息。'
- en: ASP.NET Core also provides features to help us out with the GDPR. Basically,
    there are APIs and templates to guide you in the implementation of policy declaration
    and cookie usage consent.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core还提供了帮助我们的GDPR功能。基本上，有一些API和模板可以指导你实施策略声明和cookie使用同意。
- en: List of practices for achieving a safe architecture
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现安全架构的实践列表
- en: The following list of practices related to security certainly does not cover
    the entirety of the subject. However, these practices will help you, as a software
    architect, to explore some solutions related to this topic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下与安全相关的实践列表当然不能涵盖这个主题的全部内容。然而，这些实践将帮助您作为软件架构师，探索一些与此主题相关的解决方案。
- en: Authentication
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: Define an authentication method for your web app. There are many authentication
    options available nowadays, from ASP.NET Core Identity to external provider authentication
    methods, such as Facebook or Google. As a software architect, you must consider
    who the target audience of the application is. It would also be worth considering
    using Azure **Active Directory** (**AD**) as a starting point if you choose to
    go down this route.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的Web应用程序定义认证方法。如今有许多认证选项可供选择，从ASP.NET Core Identity到外部提供者认证方法，如Facebook或Google。作为软件架构师，您必须考虑应用程序的目标受众。如果您选择走这条路，使用Azure
    **Active Directory**（**AD**）作为起点也是一个不错的选择。
- en: You may find it useful to design authentication associated with Azure AD, a
    component for managing the Active Directory of the company you are working for.
    This alternative is pretty good in some scenarios, especially for internal usage.
    Azure currently offers Active Directory for usage as **B2B** (**Business to Business**)
    or **B2C** (**Business to Consumer**).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现设计与Azure AD相关的认证很有用，这是一个用于管理您所在公司Active Directory的组件。在某些场景下，这种替代方案相当不错，尤其是对于内部使用。Azure目前提供Active
    Directory用于**B2B**（**企业对企业**）或**B2C**（**企业对消费者**）的使用。
- en: Depending on the scenario of the solution you are building, you might need to
    implement **MFA** – **Multi-Factor Authentication**. The idea of this pattern
    is to ask for at least two forms of proof of identity before allowing the solution
    to be used. It is worth mentioning that Azure AD facilitates this for you.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您构建的解决方案的场景，您可能需要实现**多因素认证（MFA）**。这种模式的想法是在允许解决方案使用之前，至少要求用户提供两种身份证明形式。值得一提的是，Azure
    AD为您简化了这一过程。
- en: You may also find it useful to implement authentication to your platform using
    as basis **Microsoft Identity Platform**. In this case, the usage of the **Microsoft
    Authentication Library** (**MSAL**) will facilitate your work hugely. Check how
    to implement it by reading its documentation at [https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现使用**Microsoft身份平台**作为基础来实现认证到您的平台很有用。在这种情况下，使用**Microsoft认证库（MSAL）**将极大地简化您的工作。通过阅读其文档了解如何实现，请参阅[https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview)。
- en: Do not forget that you must determine an authentication method for the APIs
    you provide. JSON Web Token is a pretty good pattern, and its usage is totally
    cross-platform.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记您必须为提供的API确定认证方法。JSON Web Token是一个相当好的模式，并且其使用是完全跨平台的。
- en: 'You must determine the authorization model you will use in your web app. There
    are four model options:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确定在您的Web应用程序中将使用的授权模型。有四种模型选项：
- en: '**Simple**, where you just use the `[Authorize]` attribute in the class or
    method.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的**，其中您只需在类或方法中使用`[Authorize]`属性。'
- en: '**Role-based**, in which you may declare `Roles` for accessing the `Controller`
    you are developing.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的**，其中您可以声明访问您正在开发的`Controller`的`Roles`。'
- en: '**Claims-based**, where you can define values that must be received during
    the authentication to indicate that the user is authorized.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于声明的**，其中您可以在认证过程中定义必须接收的值，以指示用户已授权。'
- en: '**Policy-based**, in which there is a policy established to define the access
    in that `Controller`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于策略的**，其中在该`Controller`中已建立策略来定义访问权限。'
- en: You may also define a controller or method in a class as being fully accessible
    to any user by defining the `[AllowAnonymous]` attribute. Be sure this kind of
    implementation will not cause any vulnerabilities in the system you are designing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过定义`[AllowAnonymous]`属性，将类中的控制器或方法定义为对任何用户完全可访问。请确保这种实现不会导致您正在设计的系统中出现任何漏洞。
- en: The model you decide to use will define exactly what each user will be able
    to do in the application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您决定使用的模型将精确定义每个用户在应用程序中能做什么。
- en: Sensitive data
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏感数据
- en: While designing, you, as a software architect, will have to decide which part
    of the data you store is sensitive, and it will need to be protected. By connecting
    to Azure, your web app will be able to store protected data in components such
    as Azure Storage and Azure Key Vault. Storage in Azure will be discussed in *Chapter
    12*, *Choosing Your Data Storage in the Cloud*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计过程中，作为软件架构师，你将不得不决定存储的数据中哪些部分是敏感的，并且需要对其进行保护。通过连接到Azure，你的Web应用将能够在Azure存储和Azure密钥保管库等组件中存储受保护的数据。Azure中的存储将在*第12章*，*选择您的云数据存储*中进行讨论。
- en: It is highly recommended to check the **Data Protection Framework** that your
    solution will need to deal with, considering where it will be placed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议检查你的解决方案将需要处理的**数据保护框架**，考虑到它将被放置的位置。
- en: It is worth mentioning that Azure Key Vault is used to protect secrets your
    app may have. Consider using this solution when you have this kind of requirement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Azure密钥保管库用于保护你的应用程序可能拥有的机密。当你有这种需求时，请考虑使用此解决方案。
- en: Web security
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络安全
- en: It is totally unacceptable to have a production solution deployed without the
    HTTPS protocol enabled. Azure Web Apps and ASP.NET Core solutions have various
    options to not only use but enforce the usage of this security protocol.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有启用HTTPS协议的情况下部署生产解决方案是完全不可接受的。Azure Web应用和ASP.NET Core解决方案提供了各种选项，不仅可以使用，还可以强制执行此安全协议的使用。
- en: There are many known attacks and malicious patterns, such as cross-site request
    forgery, open redirect, and cross-site scripting. ASP.NET Core provides APIs to
    solve them. You need to find the ones that are useful for your solution.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多已知的攻击和恶意模式，例如跨站请求伪造、开放重定向和跨站脚本。ASP.NET Core提供了API来解决这些问题。你需要找到对你解决方案有用的那些。
- en: Good programming practices, such as avoiding SQL injection by using parameters
    in your queries, is another important goal to achieve.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程实践，例如通过在查询中使用参数来避免SQL注入，是实现另一个重要目标的方法。
- en: You may find cloud architecture security patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security)找到云架构安全模式。
- en: To finish, it is worth mentioning that security needs to be treated using the
    onion approach, which means that there are many layers of security to be implemented.
    You must have determined a policy to guarantee a process to access the data, including
    physical access for people who use the system you are developing. In addition,
    you also must develop a disaster recovery solution in case the system is attacked.
    The disaster recovery solution will depend on your cloud solution. We will discuss
    this later, in *Chapter 10*, *Deciding on the Best Cloud-Based Solution*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，安全性需要使用洋葱方法来处理，这意味着需要实施许多安全层。你必须已经确定了一项政策，以确保有一个访问数据的流程，包括对使用你正在开发的系统的个人进行物理访问。此外，你还必须开发灾难恢复解决方案，以防系统遭到攻击。灾难恢复解决方案将取决于你的云解决方案。我们将在*第10章*，*决定最佳云解决方案*中对此进行讨论。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional requirements that describe system behavior must be complemented with
    non-functional requirements that constrain system performance, scalability, availability,
    resilience, interoperability, usability, and security.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 描述系统行为的职能需求必须与非职能需求相辅相成，这些非职能需求限制了系统的性能、可伸缩性、可用性、弹性、互操作性、可用性和安全性。
- en: Performance requirements come from response time and system load requirements.
    As a software architect, you should ensure you have the required performance at
    the minimum cost, building efficient algorithms and taking full advantage of the
    available hardware resources with multithreading.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 性能需求来源于响应时间和系统负载需求。作为一名软件架构师，你应该确保以最低的成本获得所需性能，构建高效的算法，并充分利用可用的硬件资源，通过多线程实现。
- en: Scalability is the ability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware or horizontally
    by replicating and load balancing the same hardware, which increases the availability.
    The cloud, in general, and Azure can help us implement strategies dynamically,
    with no need to stop your application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性是指系统适应增加负载的能力。系统可以通过提供更强大的硬件进行垂直扩展，或者通过复制和负载均衡相同的硬件进行水平扩展，从而提高可用性。通常来说，云和Azure可以帮助我们动态地实施策略，无需停止你的应用程序。
- en: Tools such as .NET 8 that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个平台上运行的工具，如 .NET 8，可以确保互操作性，即你的软件能够在不同的目标机器和不同的操作系统（Windows、Linux、macOS、Android
    等）上运行。
- en: Usability is ensured by taking care of input field order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注意输入字段顺序、项目选择逻辑的有效性以及系统学习的难易程度，可以确保可用性。
- en: Besides, the more complex your solution is, the better resilience it should
    have. The idea of resilience is not to guarantee that the solution does not fail.
    Instead, the idea is to guarantee that the solution has an action defined when
    each part of the software fails.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的解决方案越复杂，它应该具有更好的弹性。弹性的概念不是保证解决方案不会失败，而是保证当软件的每个部分失败时，解决方案都有定义好的行动。
- en: As a software architect, you must consider security from the very beginning
    of the design. Following the guidelines to determine the correct patterns and
    having a security specialist on your team is the best way to comply with all the
    current regulations we have.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你必须从设计的开始就考虑安全性。遵循指南来确定正确的模式，并在团队中拥有安全专家是遵守所有当前法规的最佳方式。
- en: In the next chapter, you will learn how Azure DevOps and GitHub can help us
    when it comes to collecting, defining, and documenting our requirements.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习 Azure DevOps 和 GitHub 如何帮助我们收集、定义和记录我们的需求。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the two conceptual ways to scale a system?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规模化系统的两种概念方式是什么？
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否从 Visual Studio 自动部署你的 Web 应用到 Azure？
- en: What is multithreading useful for?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程有什么用途？
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步模式相较于其他多线程技术的主要优势是什么？
- en: Why is the order of input fields so important?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么输入字段的顺序如此重要？
- en: Why is the `Path` class so important for interoperability?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 `Path` 类对于互操作性如此重要？
- en: What is the advantage of a .NET standard class library?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 标准类库的优势是什么？
- en: List the *most-used* types of .NET Visual Studio projects.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出最常用的 .NET Visual Studio 项目类型。
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and links you may consider reading to gather more
    information in relation to this chapter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能想要阅读的书籍和链接，以获取更多与本章相关的内容：
- en: Cloud computing models
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算模型
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自动扩展最佳实践](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ASP.NET Core 在 Azure 中的应用程序托管和部署](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
- en: Parallel programming
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行编程
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并行处理和并发](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并行编程](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
- en: Performance improvements in .NET
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 性能改进
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[.NET 8 性能改进](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)'
- en: '[https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[BenchmarkDotNet](https://benchmarkdotnet.org/)'
- en: Security aspects
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全方面
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ASP.NET Core 安全](https://docs.microsoft.com/en-us/aspnet/core/security/)'
- en: '[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DotNet 安全速查表](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
- en: '[https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview)'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview)'
- en: Service consistency aspects
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务一致性方面
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
- en: Dotnet support
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dotnet 支持
- en: '[https://dotnet.microsoft.com/platform/support/policy](https://dotnet.microsoft.com/platform/support/policy)'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dotnet.microsoft.com/platform/support/policy](https://dotnet.microsoft.com/platform/support/policy)'
- en: Learn more on Discord
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本发布——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
