<html><head></head><body>
        

                            
                    Implementing a Drone with the Strategy Pattern
                
            
            
                
<p class="mce-root">In this chapter, we are going to implement enemy drones that fly around the race track and attack the player by shooting laser beams. They are little annoying robotic pests that will test the player's reflexes. Our drones will have a single attack that consists of firing a continuous laser beam at a 45-degree angle. To create the illusion of autonomous intelligence, the drones can be assigned three distinct attack maneuvers at runtime. Each maneuver is a repetitive series of predictable movements. Individually, the drone's behavior may look robotic, but when they are placed in a formation at specific positions on the race track, it could look like they are forming a strategy to outmaneuver the player.</p>
<p>And so, I'm proposing that we use the Strategy pattern to implement the various drone behaviors. The main reason for this choice is that this pattern allows us to assign specific behavior to an object at runtime. But first, let's break down the specifications of the pattern and the design intentions of our enemy drone. </p>
<p>This chapter includes simplified skeleton code examples for the sake of brevity and clarity. If you wish to review a complete implementation of the pattern in the context of an actual game project, open the <kbd>FPP</kbd> folder in the GitHub project. You can find the link in the <em>Technical requirements</em> section.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>An overview of the Strategy pattern</li>
<li>Implementing enemy drone attack behaviors</li>
</ul>
<h1 id="uuid-2618380b-80b8-4689-a7d0-99c7148f75e4">Technical requirements</h1>
<p>This chapter is hands-on, so you will need to have a basic understanding of Unity and C#.<br/>
<br/>
The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11</a>.</p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/2TdeoL4">https://bit.ly/2TdeoL4</a><a href="https://bit.ly/2TdeoL4">.</a></p>
<h1 id="uuid-546e4bb9-798f-4a90-bdef-dafae053bbe1">Understanding the Strategy pattern</h1>
<p>The primary goal of the Strategy pattern is to defer the decision of which behavior to use at runtime. This is made possible because the Strategy pattern lets us define a family of behaviors that are encapsulated in individual classes that we call strategies. Each strategy is interchangeable and can be assigned to a target context object to change its behavior.</p>
<p>Let's visualize the key elements of the pattern with this UML diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/75e1b61e-a602-4cc7-bdf4-166eeb5a4d7d.png" style="width:35.42em;height:26.42em;"/></p>
<p>Figure 11.1 – UML diagram of the Strategy pattern</p>
<p class="mce-root">Here's a breakdown of the key players of the pattern:</p>
<ul>
<li><strong>Context</strong> is the class that uses the various concrete strategy classes and interacts with them through the Strategy interface.</li>
<li>The <strong>Strategy</strong> interface is common to all concrete strategy classes. It exposes a method that the <kbd>Context</kbd> class can use to execute a strategy.</li>
<li><strong>Concrete Strategy </strong>classes, also known as <strong>strategies</strong>, are concrete implementations of variants of algorithms/behaviors that can be applied to a <kbd>Context</kbd> object at runtime.</li>
</ul>
<p>At the moment, these concepts might sound very abstract, but in practice, they are quite easy to understand, as we are going to see later in this book.</p>
<p>The Strategy pattern is a behavioral software design pattern; its closest cousin is the State pattern. We can use both to encapsulate a set of behaviors in individual classes. You should use the Strategy pattern when you want to select a behavior at runtime and apply it to an object. You can also use the State pattern when you want an object to change its behavior when its internal state changes.</p>
<h2 id="uuid-db1f79ff-f2e5-4ef1-adb6-548b6d885602">Benefits and drawbacks of the Strategy pattern</h2>
<p>These are some of the benefits of the Strategy pattern:</p>
<ul>
<li class="mce-root"><strong>Encapsulation</strong>: A clear benefit of this pattern is that it enforces variations of algorithms to be encapsulated in individual classes. Hence, this helps us avoid using long conditional statements while keeping our code structured.</li>
<li class="mce-root"><strong>Runtime</strong>: The main benefit of this pattern is that it implements a mechanism that permits us to swap algorithms that an object is using at runtime. This approach makes our objects more dynamic and open for extension.</li>
</ul>
<p>The following are some potential drawbacks of the Strategy pattern:</p>
<ul>
<li><strong>Client</strong>: The client class must be aware of the individual strategies and the variations in the algorithm they implement so as to know which one to select. Therefore, the client becomes responsible for making sure that an object is behaving as expected during its lifespan.</li>
<li><strong>Confusion</strong>: Because the Strategy and State patterns are so similar in structure but have different intents, confusion could arise when you're choosing which one to use and in what context. In most cases, it's not an issue, but if you are working with a team of programmers, depending on the various levels of knowledge of the subject matter, some colleagues might not understand your choice of pattern.</li>
</ul>
<p>I believe it's essential to have regular open discussions about architecture, patterns, and best practices with your colleagues. If you can agree as a team on common approaches when using a specific set of design patterns, you will end up with a more consistent overall architecture and cleaner code.</p>
<h2 id="uuid-9bf92ea4-c4cc-425e-9dde-9d37b3b7affb">When to use the Strategy pattern</h2>
<p>When I get tasked with implementing behaviors for an enemy character, the first options I consider are the State pattern or a <strong>finite state machine</strong> (<strong>FSM</strong>) since most of the time, characters are stateful.</p>
<p>But sometimes, I might use the Strategy pattern if the following conditions are met:</p>
<ul>
<li>I have an entity with several variants of the same behavior, and I want to encapsulate them in individual classes.</li>
<li>I want to assign specific behavior variants to an entity at runtime, without the need to take its current internal state into consideration.</li>
<li>I need to apply a behavior to an entity so that it can accomplish a specific task based on selection criteria that are defined at runtime.</li>
</ul>
<p>The third point is probably the main reason I chose to use the Strategy pattern over the State pattern to implement the enemy drone presented in this chapter. The behavior of the drone is robotic; it has a singular task: attack the player. It doesn't make any alterations to its actions based on internal state changes. It only needs to be assigned an attack behavior at runtime to accomplish its task of attacking the player, which makes it the right candidate for the Strategy pattern in its current design.</p>
<p>It's important to note that potential use cases of the Strategy pattern are not limited to implementing enemy characters. For example, we could use it to encapsulate various encryption algorithms to apply to a saved file, depending on the target platform. Or, if we are working on a fantasy game, we could use it to encapsulate the individual behaviors of a family of spells that players can apply to a target entity. Therefore, the potential use cases for this pattern are broad and can be applied to various contexts, ranging from core systems to gameplay mechanics.</p>
<p>In the next section, we are going to review the design intentions of our enemy drone.</p>
<h1 id="uuid-a22a7309-9f04-4525-b6fb-3ab8dbcac33a">Designing an enemy drone</h1>
<p>The enemy drones in our game are not very smart; there is no artificial intelligence running behind the scene. These are robots with robotic behaviors, and it's common in video games to have enemies with predictable automated behaviors running in a loop. For instance, the Goombas in the original Super Mario Bros just walk in one direction; they are not aware of the presence of Mario or react to him. They are simply running an algorithm to make them wander in a path until they collide with an obstacle. Alone, they are not a threat, but if they are put in a formation or positioned at a point in the map in which navigation is difficult, they can become challenging to avoid.</p>
<p>We will be using the same approach for our enemy drones. Individually, they are easy to defeat because they can't change their behaviors based on the player's movements, but in a squad, they can be challenging to avoid. </p>
<p>Our drone has three distinct attack maneuvers; each revolves around a specific set of movements that are predictable but still challenging to counter when the drones are in a squad formation.</p>
<p>Let's look at each maneuver:</p>
<ul>
<li><strong>Bobbing Maneuver</strong>: In a bobbing maneuver, the drone moves up and down at high speed while shooting a laser beam.<br/></li>
<li><strong>Weaving Maneuver</strong>: For the weaving maneuver, the drone moves horizontally at high speed, while shooting. The weaving maneuver is limited to the distance between the two rails of a track.<br/></li>
<li><strong>Fallback Maneuver</strong>: For the fallback maneuver, the drone moves backward while shooting. The top speed of the drone can match that of the player's bike, but can only move back for a limited amount of time.</li>
</ul>
<p class="mce-root">The following diagram illustrates the preceding maneuvers:</p>
<div><img src="img/a2c7f88d-444e-47d8-880b-a01102961ed3.png" style="width:54.25em;height:25.00em;"/></div>
<p>Figure 11.2 – Illustration of the drone's attack maneuvers</p>
<p class="mce-root">The enemy drone has a single weapon: a front-facing laser beam that's fired at a 45-degree angle toward the ground. The following diagram illustrates the laser weapon of the drone:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d26c7ff3-661e-4fa1-8faf-a428685bd87e.png" style="width:61.58em;height:24.83em;"/></p>
<p>Figure 11.3 – Illustration of the drone's weapon attack</p>
<p class="mce-root">As we can see, the player must avoid the attack by navigating around the drone at high speed. If hit by the beam, the bike's front-facing shield will lose a certain amount of power. If the shield becomes depleted, the vehicle will explode on the next hit, and it will be game over.</p>
<p>In the next section, we are going to translate this design into code.</p>
<h1 id="uuid-a8a867af-aac8-48f0-be2e-0dc8f40855aa">Implementing an enemy drone</h1>
<p class="mce-root">In this section, we will write a skeleton implementation of the Strategy pattern and the individual attack behaviors of the drone enemy. The code in this section may seem oversimplified in certain aspects. Still, the end goal is not to have a complete implementation of the enemy drone but to understand the basics of the Strategy pattern.</p>
<h2 id="uuid-ff880418-cb27-4d24-8e6f-b75ee91eb2a6">Steps to implementing an enemy drone</h2>
<p class="mce-root">Let's start by implementing the main ingredients of the Strategy pattern:</p>
<ol>
<li>Our first element is the Strategy interface; all our concrete strategies will use it:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.Strategy<br/>{<br/>    public interface IManeuverBehaviour<br/>    {<br/>        void Maneuver(Drone drone);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Note that we are passing a parameter of the <kbd>Drone</kbd> type to the <kbd>Maneuver()</kbd> method. This is an important detail we will review later.</p>
<ol start="2">
<li>Next up is our <kbd>Drone</kbd> class; it's going to use our concrete strategies, so in the overall structure of the Strategy pattern, we will consider it to be our <kbd>Context</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Strategy {<br/>    public class Drone : MonoBehaviour {<br/><br/>        // Ray parameters<br/>        private RaycastHit _hit;<br/>        private Vector3 _rayDirection;<br/>        private float _rayAngle = -45.0f;<br/>        private float _rayDistance = 15.0f;<br/><br/>        // Movement parameters<br/>        public float speed = 1.0f;<br/>        public float maxHeight = 5.0f;<br/>        public float weavingDistance = 1.5f;<br/>        public float fallbackDistance = 20.0f;<br/><br/>        void Start() {<br/>            _rayDirection = <br/>                transform.TransformDirection(Vector3.back) <br/>                * _rayDistance;<br/><br/>            _rayDirection = <br/>                Quaternion.Euler(_rayAngle, 0.0f, 0f) <br/>                * _rayDirection;<br/>        }<br/><br/>        public void ApplyStrategy(IManeuverBehaviour strategy) {<br/>            strategy.Maneuver(this);<br/>        }<br/><br/>        void Update() {<br/>            Debug.DrawRay(transform.position, <br/>                _rayDirection, Color.blue);<br/><br/>            if (Physics.Raycast(<br/>                transform.position,<br/>                _rayDirection, out _hit, _rayDistance)) {<br/><br/>                if (_hit.collider) {<br/>                    Debug.DrawRay(<br/>                        transform.position, <br/>                        _rayDirection, Color.green);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Most of the lines of code in this class are for raycasting debugging information; we can safely ignore them. However, the following section is essential to understand:</p>
<pre style="padding-left: 60px">public void ApplyStrategy(IManeuverBehaviour strategy)<br/>{<br/>    strategy.Maneuver(this);<br/>}</pre>
<p style="padding-left: 60px">The <kbd>ApplyStrategy()</kbd> method contains the core mechanism of the Strategy pattern. If we look closely, we can see that the method in question accepts a concrete strategy of the <kbd>IManeuverBehaviour</kbd> type as a parameter. And this is where things get very interesting. A <kbd>Drone</kbd> object can communicate with the concrete strategies it received through the <kbd>IManeuverBehaviour</kbd> interface. Thus, it only needs to call <kbd>Maneuver()</kbd> to execute a strategy at runtime. Hence, a <kbd>Drone</kbd> object doesn't need to know how a strategy's behavior/algorithm is executed – it just needs to be aware of its interface.</p>
<p>Now, let's implement the concrete strategy classes:</p>
<ol>
<li>The following class implements the bopping maneuver:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Strategy {<br/>    public class BoppingManeuver : <br/>        MonoBehaviour, IManeuverBehaviour { <br/><br/>        public void Maneuver(Drone drone) {<br/>            StartCoroutine(Bopple(drone));<br/>        }<br/><br/>        IEnumerator Bopple(Drone drone)<br/>        {<br/>            float time;<br/>            bool isReverse = false;<br/>            float speed = drone.speed;<br/>            Vector3 startPosition = drone.transform.position;<br/>            Vector3 endPosition = startPosition;<br/>            endPosition.y = drone.maxHeight;<br/><br/>            while (true) {<br/>                time = 0;<br/>                Vector3 start = drone.transform.position;<br/>                Vector3 end = <br/>                    (isReverse) ? startPosition : endPosition;<br/><br/>                while (time &lt; speed) {<br/>                    drone.transform.position = <br/>                        Vector3.Lerp(start, end, time / speed);<br/>                    time += Time.deltaTime;<br/>                    yield return null;<br/>                }<br/><br/>                yield return new WaitForSeconds(1);<br/>                isReverse = !isReverse;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>The following class implements the weaving maneuver:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Strategy {<br/>    public class WeavingManeuver : <br/>        MonoBehaviour, IManeuverBehaviour {<br/><br/>        public void Maneuver(Drone drone) {<br/>            StartCoroutine(Weave(drone));<br/>        }<br/><br/>        IEnumerator Weave(Drone drone) {<br/>            float time;<br/>            bool isReverse = false;<br/>            float speed = drone.speed;<br/>            Vector3 startPosition = drone.transform.position;<br/>            Vector3 endPosition = startPosition;<br/>            endPosition.x = drone.weavingDistance;<br/><br/>            while (true) {<br/>                time = 0;<br/>                Vector3 start = drone.transform.position;<br/>                Vector3 end = <br/>                    (isReverse) ? startPosition : endPosition;<br/><br/>                while (time &lt; speed) {<br/>                    drone.transform.position = <br/>                        Vector3.Lerp(start, end, time / speed);<br/>                    <br/>                    time += Time.deltaTime;<br/>                    <br/>                    yield return null;<br/>                }<br/><br/>                yield return new WaitForSeconds(1);<br/>                isReverse = !isReverse;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Finally, let's implement the fallback maneuver:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Strategy<br/>{<br/>    public class FallbackManeuver : <br/>        MonoBehaviour, IManeuverBehaviour {<br/><br/>        public void Maneuver(Drone drone) {<br/>            StartCoroutine(Fallback(drone));<br/>        }<br/><br/>        IEnumerator Fallback(Drone drone)<br/>        {<br/>            float time = 0;<br/>            float speed = drone.speed;<br/>            Vector3 startPosition = drone.transform.position;<br/>            Vector3 endPosition = startPosition;<br/>            endPosition.z = drone.fallbackDistance;<br/><br/>            while (time &lt; speed)<br/>            {<br/>                drone.transform.position = <br/>                    Vector3.Lerp(<br/>                        startPosition, endPosition, time / speed);<br/><br/>                time += Time.deltaTime;<br/><br/>                yield return null;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>You may have noticed that the code of each class is quite similar, even repetitive in certain parts. This accounts for one of the reasons we are using the Strategy pattern – we want to encapsulate variations of similar behaviors so that they are easier to maintain individually. But also, imagine how messy our <kbd>Drone</kbd> class would be if we tried to implement the bopping, weaving, and fallback behaviors in a single class. We would find ourselves in a bloated <kbd>Drone</kbd> class that's potentially filled to the brim with conditional statements.</p>
<p>I would not recommend using coroutines to animate non-humanoid entities. Instead, I suggest using a Tween engine such as DOTween since you can animate objects with less code while getting better results. We are using coroutines in this chapter to avoid external dependencies and make our code easy to port. To learn more about DOTween, go to <a href="http://dotween.demigiant.com/" target="_blank">http://dotween.demigiant.com</a>.<a href="http://dotween.demigiant.com/" target="_blank"/></p>
<h2 id="uuid-6b22726b-e66b-400d-91eb-8d007fa8cce5">Testing the enemy drone implementation</h2>
<p>And now for the fun part – testing our implementation. It's going to be an easy one since all we need to do is attach the following client class to an empty <kbd>GameObject</kbd> in a Unity scene:</p>
<pre>using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>namespace Chapter.Strategy {<br/>    public class ClientStrategy : MonoBehaviour {<br/><br/>        private GameObject _drone;<br/><br/>        private List&lt;IManeuverBehaviour&gt; <br/>            _components = new List&lt;IManeuverBehaviour&gt;();<br/><br/>        private void SpawnDrone() {<br/>            _drone = <br/>                GameObject.CreatePrimitive(PrimitiveType.Cube);<br/><br/>            _drone.AddComponent&lt;Drone&gt;();<br/><br/>            _drone.transform.position = <br/>                Random.insideUnitSphere * 10;<br/><br/>            ApplyRandomStrategies();<br/>        }<br/><br/>        private void ApplyRandomStrategies() {<br/>            _components.Add(<br/>                _drone.AddComponent&lt;WeavingManeuver&gt;());<br/>            _components.Add(<br/>                _drone.AddComponent&lt;BoppingManeuver&gt;());<br/>            _components.Add(<br/>                _drone.AddComponent&lt;FallbackManeuver&gt;());<br/><br/>            int index = Random.Range(0, _components.Count);<br/><br/>            _drone.GetComponent&lt;Drone&gt;().<br/>                ApplyStrategy(_components[index]);<br/>        }<br/><br/>        void OnGUI() {<br/>            if (GUILayout.Button("Spawn Drone")) {<br/>                SpawnDrone();<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">In your instance of Unity, if you included all the scripts we wrote in the preceding sections in your project, you should see a single button on the screen when you start it called Spawn Drone, as shown in the following screenshot:<br/></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/75f67a2a-f8c9-4b8b-a0c3-0f07bd89a6b2.png" style="width:46.08em;height:26.25em;"/></p>
<p>Figure 11.4 – The code example in action inside Unity</p>
<p class="mce-root">If you click on the scene's primary button, a new cube representing a Drone entity should appear at a random position while executing a randomly selected attack maneuver.</p>
<h2 id="uuid-1f3ee26f-d29c-4b79-94a3-6450709750b0">Reviewing the enemy drone implementation</h2>
<p class="mce-root">In the preceding code example, the client class acts like a spawner that randomly assigns a strategy to a new drone instance. This could be an interesting approach for a real-world use case. But there are many other approaches we could have used to choose which strategy to assign to a drone. It could be based on specific rules and factors that are only known at runtime. Therefore, it's not limited to randomness but can also be deterministic and rule-based.</p>
<h1 id="uuid-800dbbcc-d3f6-4ee6-9f8c-b22cec3d7eb0">Reviewing alternative solutions</h1>
<p class="mce-root">There's one glaring issue with the code examples presented in this chapter. We encapsulated attack maneuver behaviors into distinct strategy classes, but each maneuver is nothing more than a single animation running on a loop. So, in an actual game project that's been built by a production team that includes animators, I would not have animated the enemy drones in code by using coroutines or even a Tween animation engine. Instead, I would ask an animator to author some detailed attack maneuver animations in an external authoring tool and then import them into Unity as animation clips. I would then have used Unity's native animation system and its state machine feature to assign attack maneuver animations to a drone dynamically.</p>
<p class="mce-root">Using this approach, I would have gained quality in the animations and the flexibility of transitioning smoothly from one attack behavior to another, if I decide that the drones can switch attacks when an internal state changes. Therefore, I would have moved away from the idea of encapsulating each attack behavior into a strategy class and instead defined them as finite states. This switch would not be a dramatic change in design as the concepts that drive the FSM, State, and Strategy patterns are closely related.</p>
<p class="mce-root">Even though the Strategy pattern's implementation in the example presented in this chapter is valid, it's wise to consider what can be achieved natively with Unity's animation system first when you're managing an entity's animation set. But imagine another use case in which we need to implement variations of a motion detection algorithm and assign them to a drone at runtime. In that context, the Strategy pattern would be an excellent choice to build that system.</p>
<p>You can read the official documentation on Unity's native animation system at <a href="https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html">https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html</a>.</p>
<h1 id="uuid-1c112357-29da-43f5-9463-1003bbe405cf">Summary</h1>
<p>In this chapter, we used the Strategy pattern to implement our game's first enemy ingredient, a flying, laser-shooting drone. By using this pattern, we encapsulated each variant of the drone's attack maneuvers in individual classes. This approach made our code easier to maintain by avoiding having bloated classes filled with lengthy conditional statements. Now, we can quickly write new attack maneuver variations or adjust existing ones. Hence, we have given ourselves the flexibility to be creative and test out new ideas quickly, which is a vital part of game development.</p>
<p class="mce-root">In the next chapter, we will start working on a weapon system and explore the Decorator pattern.</p>


            

            
        
    </body></html>