- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions and Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the first hands-on chapter of our journey! In this chapter, we are
    going to discuss expressions and statements, lambda expressions, and expression
    trees. These are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between expressions and statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clear and declarative code using expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing expression-bodied members, lambda expressions, anonymous methods,
    and local functions effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating expressions at runtime using expression trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive in, I want to tell you that I value your time, so most of the
    chapters will start with assessment tasks. These tasks are not meant to be solved
    all the time and are aimed to help you measure your existing understanding of
    the topic. If these tasks are no-brainers for you, you might want to skip the
    chapter for now. And vice versa, if the tasks are quite challenging for you, you
    might want to dedicate more time and effort to the chapter. At the end of each
    chapter with tasks, you will find the solutions section to check your answers.
    Now that you know the deal, let’s check the three tasks designed for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Name and count all expressions and all statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Name and count all expressions and all statements in the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Use expressions instead of statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refactor the code below to use expressions instead of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Create an expression tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an expression tree that is the lambda expression `(baseDamage, level)
    => baseDamage * level`. Then, compile and invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re 100% sure that you know the answers to all three tasks, then you can
    confidently skip this chapter. However, there’s always a chance you might miss
    something useful, so instead of skipping the chapter entirely, you might want
    to save it for later. In any case, you can always come back and read it if you
    have any questions, or if anything becomes unclear.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between expressions and statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, an **expression** in C# is just a piece of code that evaluates
    to a value. Simple expressions include constants, variables, and method calls.
    On the other hand, a **statement** is a standalone unit of code that performs
    an action. In essence, it is an executable instruction. The best way to understand
    something is through practice. So, let’s not delay anymore and look at expressions
    and statements through examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example of expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, 20, `pagesPerChapter`, `10`, and `pagesPerChapter * 10` are
    all expressions. Each of these pieces of code evaluates to a value.
  prefs: []
  type: TYPE_NORMAL
- en: Example of statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s identify statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, var pagesPerChapter = 20; and var totalBookPages = pagesPerChapter * 10;
    are statements. The first line instructs the program to declare a pagesPerChapter
    variable and initialize it with a value of 20\. The second line instructs the
    program to multiply the value of pagesPerChapter by 10 and save it in the `totalBookPages`
    variable. Both are standalone code units that perform actions, fitting our definition
    of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: Key differences between expressions and statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although statements and expressions can sometimes look similar, remember that
    an expression produces a value and can be used in larger expressions. In contrast,
    a statement performs an action and serves as a part of a method or program structure.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, every expression can be turned into a statement, but not every statement
    can be an expression. For example, `x = y + 2` is a statement where `y + 2` is
    an expression. However, a `for` loop or an `if` statement cannot be expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Guided exercise – finding expressions and statements in sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s exercise your knowledge. Can you find and count all the expressions and
    statements in a slightly more complex code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have 8 expressions and 4 statements. Specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`5`, `1`, `chapter`, `bookCount`, `chapter <= bookCount`, `chapter++`, `1000`,
    `chapter * 1000`, `chapter`, `wordCount`, and `$"Chapter {chapter} contains {``wordCount}
    words."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int bookCount = 5;`, `for(int chapter = 1; chapter <= bookCount; chapter++)`,
    `var wordCount = chapter * 1000;`, and `Console.WriteLine($"Chapter {chapter}
    contains {``wordCount} words.");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between expressions and statements helps you write
    better, clearer code. As you keep learning C#, you’ll get used to these basics
    and be able to make better software. Keep going with this knowledge, and let’s
    keep exploring functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: How to use expressions for clear and simple code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using short and clear code makes it easy to understand what it’s doing. It’s
    also easier for you and others to read later on. Using expressions in C# can help
    us do this. Let’s learn how to shape our code with expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The power of expressions – improving readability and maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expressions support the idea of immutability, a cornerstone of functional programming.
    Since expressions evaluate to a value and don’t modify the state of our program,
    they allow us to write code that’s less prone to bugs, easier to reason about,
    and simple to test.
  prefs: []
  type: TYPE_NORMAL
- en: One day, Steve received a phone call from his old friend Irene, a renowned author
    of children’s books. She had begun to notice that books with longer titles seemed
    to be more popular. To test her theory, she gathered the titles of all the top-selling
    books and asked Steve to develop a program to calculate the average title length
    associated with popularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, Steve created the program in the manner he was accustomed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the code looked wordy, and he decided to practice a functional approach
    and rewrite the code. He replaced the `foreach` loop with a simple `Average` expression
    that computes the average character count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With what almost seemed like magic, all these computations became just a single
    line of code. One line of more functional and concise code using expressions instead
    of statements.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to convert statements to expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great step toward embracing functional programming in C# is turning your statements
    into expressions where possible. As we just saw, **LINQ** (which stands for **Language
    INtegrated Query**) can be a powerful tool in this transformation.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used the `Average` method from LINQ. These are extension
    methods available for any `IEnumerable<T>`, allowing us to perform complex operations
    on collections with simple, expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: We can further leverage other LINQ methods, such as `Where` for filtering, `OrderBy`
    for sorting, and `Aggregate` for reducing a collection to a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the code can be transformed to comply with the functional approach even
    without LINQ methods. For example, we can convert `if` statements into a conditional
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, all `for`, `while`, `foreach`, and so on loops can be replaced with
    recursive methods, which will be expressions when run. In addition, we can use
    the `Result` type instead of exceptions and higher-order functions, which will
    be discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Guided exercise – refactoring code using expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emily approached Steve with a request to help her create a program that would
    display the view count of her YouTube videos. However, Emily’s channel comprises
    both private and public videos, and she was interested in counting views only
    for her public ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve wrote a program in which the primary method of counting views looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, Steve thought he should use this chance to get better at using the functional
    approach and expressions instead of statements. So, he made changes to his code
    using expressions and LINQ methods to make the code clearer and shorter. Now the
    new version looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what we changed:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement has been replaced with the `Where` method. This method filters
    out the elements that do not satisfy a certain condition – in this case, where
    `v.IsPublic` is `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop that manually adds each video’s views to `totalPublicViews` has been
    replaced with the `Select` method. This method transforms each element – in this
    case, it takes each video (`v`) and transforms it into its view count (`v.Views`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `Sum` method adds up the views from each of the public videos to
    get the total.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using LINQ methods and expressions, the resulting code is clearer, more declarative,
    and more concise. We can now see at a glance what the code does – calculate the
    total number of views for all public videos – rather than how it does it. This
    is the power of expressions in C# – they allow for cleaner, more human-readable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions, expression-bodied members, and anonymous methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern C# syntax offers a set of powerful tools for expressing complex functionality
    with elegance and brevity. Let’s take a closer look at these language features
    and how we can use them to make our code more functional, readable, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: What are lambda expressions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda expressions, denoted by the `=>` symbol, are a succinct way to create
    anonymous functions. Most likely, you use them daily when working with LINQ and
    similar functional programming constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s look at the following example where we define a lambda to square
    a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a lambda expression that takes an integer, `x`, and returns its
    square. We can then use this function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Lambda expressions offer great flexibility in parameter types and return values.
    They can take multiple parameters, return complex objects, or even have no parameters
    or return value at all.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple parameters in lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, methods in C# can contain more than one parameter, and lambda expressions
    can do so as well. In LINQ, one of the easiest methods to demonstrate it is `SelectMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, in addition to the collection of books and the one-parameter lambda expression,
    `publisher => books.Where(book => book.PublisherId == publisher.Id)`, this method
    also takes a two-parameter lambda expression, `(publisher, book) => new { PublisherName
    = publisher.Name, BookTitle = book.Title }`. As you can see, we just need to add
    parenthesis to use any number of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Being a teacher in online C# courses, I like to illustrate the “evolution”
    of lambda expressions to my students. The first thing you need to know here is
    that this type of expression is just syntactic sugar over methods. Let’s look
    at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method calculates whether a book is popular or not and is written in an
    imperative way (tells how to do things, not what to do). To make it smaller, we
    can replace `if` with `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it even shorter, let’s use expression-bodied member syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use the same conditions in the LINQ `Where` function, it will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see the similarities? This is basically one and the same, so we can
    use our function in the `Where` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This happens because `Where` takes a `Func<T, bool>` type as its parameter,
    which is basically what our lambda expression is.
  prefs: []
  type: TYPE_NORMAL
- en: And now let me tell you that the example that we used to understand “lambda
    expressions evolution” is actually not a lambda expression. Lambda expressions
    are a syntactic sugar for anonymous methods, and we used an expression-bodied
    member here. So, let’s dig deeper and understand the difference between those
    two.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous methods, as the name suggests, are methods without a name. This ability
    to write unnamed methods right at the place where they are used, especially as
    arguments to other methods, is a significant feature of functional programming
    languages. Here is an interesting fact: anonymous methods are one of the oldest
    features of C#; they were introduced with version 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `delegate(Video video){...}` is an anonymous method, and as
    you can see, it is used directly as an argument to the `ForEach` method.
  prefs: []
  type: TYPE_NORMAL
- en: How do anonymous methods work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anonymous methods work by generating a hidden method at compile time. The compiler
    generates a unique name for the method that isn’t valid in the context of C# naming
    rules, ensuring no possible conflict with your method names.
  prefs: []
  type: TYPE_NORMAL
- en: When to use anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of anonymous methods is particularly suitable when the logic of the
    method doesn’t justify a full method declaration. If the code is short, easily
    understandable, and used only in one place, an anonymous method is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common scenarios for using anonymous methods include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with LINQ**: LINQ heavily relies on delegates and anonymous methods,
    especially when filtering, ordering, or projecting data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handling**: Anonymous methods can be used when attaching events, especially
    when the event handling code is simple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous programming**: Tasks and threads often use anonymous methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical examples – applying these features in real code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another day on the street, Steve met his old friend Konstatos, founder of a
    small game studio that develops mobile games. Konstatos said that he wanted to
    analyze the behavior of a group of players he called “new whales.” Usually, people
    who spend much more money than others on something are called “whales.” So, he
    needed to get this subset of players using two conditions: firstly, they must
    have been registered in a game not earlier than a year ago, and secondly, they
    must have spent at least $10,000 since then.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve happily agreed, and now, having practiced a lot on previous tasks, he
    came up with this functional solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention that the condition is broken down into two `Where` methods. You
    could do it with just one `Where` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, the cognitive load for `Where` with two conditions inside is greater,
    which is why the first approach is preferred. Plus, the first method reduces the
    number of affected lines when making further code changes, it’s easier to expand
    (you simply add new `Where` methods on new lines), and it causes fewer merge conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so now that we have seen anonymous methods, let’s look at expression-bodied
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-bodied members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expression-bodied members are a syntax shortcut that allows methods, properties,
    and other members to be defined using a lambda-like syntax, where the body of
    the member is defined by a single expression following the `=>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following traditional method for calculating royalty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s turn this into an expression-bodied member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We’ve condensed our method to a one-liner (a piece of functionality written
    in a single line), concise line. The improved brevity enhances readability, especially
    for simple methods and properties. It is important to remember that it is not
    obligatory for the code to use expression-bodied members to be considered functional
    style. In my work, I stick to the rule that only single-line expression-bodied
    members can exist. If the method body starts to contain two or more lines, it
    is better to have fewer merge conflicts and readability to use a regular syntax
    for methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will tackle the powerful concept of expression trees
    and uncover their utility in C#. But first, take some time to absorb these concepts
    and see how you can use them to write more expressive and concise code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – implementing lambda expressions and anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for you to have more practice with a functional approach, here is
    a challenge to refactor the following code using expression-bodied members, lambda
    expressions, and anonymous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While it is quite an easy task, it can help us to clarify the difference between
    standard methods and lambda expressions, making our code in a more functional
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Expression trees and how to use them to manipulate expressions at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expression trees offer a unique capability in C#: the ability to treat code
    as data and manipulate it at runtime. They are central to the functionality of
    LINQ, allowing us to use the same query syntax for in-memory objects and external
    data sources. Let’s explore this fascinating feature. At a high level, an expression
    tree is a data structure that represents some code in a tree-like format, where
    each node is an expression. Expression trees are constructed from lambda expressions
    and allow you to inspect the code within the lambda as data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, consider a simple lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s rewrite it as a binary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference might be not significant in code, but let’s look at the inner
    representation of our variables. Here is our `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it has only two fields: `Target`, the class in which this method
    is, and the `Method` field, with the method’s information. Not that much to look
    at. Now, let’s look at `addExpression`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the expression has `NodeType` as `Add` and two parts: `Left`
    and `Right`. Visually, it can be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not scary at all, right? If so, let’s move on to expression trees.
  prefs: []
  type: TYPE_NORMAL
- en: Building and manipulating expression trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building an expression tree manually provides a deeper understanding of its
    structure. Let’s recreate our addition expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates the same expression tree as before but shows the structure
    more clearly. The lambda is formed from a body, `(a + b)`, and a list of parameters,
    `(``a, b)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our expression tree has two main branches, `Body` and `Parameters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That looks more like a tree to me. However, it has only one operation in it
    and real expression trees usually contain multiple operations. Let’s add a multiplication
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is much more interesting, and its inner representation is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is what our modified visual tree looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I hope that now you have a better understanding of what an expression tree looks
    like. This will help us to move forward to a more complex example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and manipulating complex expression trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other day, Irene asked Steve to meet her publisher. It appeared that the
    publisher wanted a program to easily filter popular books. Steve gladly agreed
    and created the advanced filter as an expression tree for their system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter checks whether a book’s title contains a specific keyword, whether
    its number of pages is more than a particular limit, and whether its rating is
    above a certain threshold. Therefore, the expression tree has three different
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing they need to do in their publishing system is to use `filterExpression`
    to create a delegate for filtering books and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The real power of expression trees comes from their ability to be manipulated
    at runtime. You can dynamically build, modify, or even compile and run expression
    trees. This is a powerful tool for runtime code generation and provides the basis
    for technologies such as LINQ and Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data with expression trees – LINQ and beyond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ uses expression trees under the hood to enable the same query syntax for
    different types of data. When you write a LINQ query against an `IQueryable<T>`,
    you’re actually building an expression tree. This tree is then passed to the query
    provider, which translates it into the appropriate format (such as SQL for a database).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a LINQ query that gets translated into SQL by Entity Framework
    (a popular tool to work with databases in C#):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When this query is run, Entity Framework generates an expression tree, converts
    it into SQL, sends it to the database, and materializes the results back into
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Guided exercise – constructing and manipulating expression trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you understand expression trees better, let’s look at this exercise.
    Our goal is to create an expression tree representing the lambda expression `(x,
    y) => x * y`. This represents a multiplication operation. Afterward, we’ll compile
    and invoke this expression, effectively performing the multiplication of two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the parameters for the lambda expression. These are `x` and `y`, which
    are both of the `int` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct the body of the lambda expression. This is the `x *` `y` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we combine the parameters and the body into a lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our expression tree, we can compile it into a delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the delegate with two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Awesome! We have successfully created an expression tree that represents a lambda
    expression, compiled it, and invoked it. This is a fundamental step in understanding
    how expression trees in C# allow us to use code as data, opening up powerful,
    dynamic programming possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Keep practicing these steps with different lambda expressions. Mastery of expression
    trees lets you harness the full potential of C#, giving you capabilities such
    as dynamic code generation and manipulation, advanced querying abilities, and
    much more. Keep at it, you’re doing great!
  prefs: []
  type: TYPE_NORMAL
- en: Problem sets and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading about expressions and statements, lambda expressions, and expression
    trees, Steve wrote an email to Julia, asking for the best way to get more hands-on
    experience. Julia congratulated Steve and sent him the list with five points that
    from her understanding every person trying to learn this topic should do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IEnumerable<T>` and a predicate in the form of an expression tree and returns
    the filtered results. Use it to filter a list of strings based on their length.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactor a class** with traditional methods into a version using expression-bodied
    members where appropriate. Compare the two versions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write an application** that takes a mathematical expression as a string at
    runtime, converts it into an expression tree, and evaluates it. The application
    should support operations such as addition, subtraction, multiplication, and division.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Design a mini query language** for querying in-memory objects. This language
    should support basic operations such as filtering and sorting. Use expression
    trees to implement it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code review a project**. Find an open source project on GitHub that uses
    C#, and examine the code to identify where these features (expression-bodied members,
    lambda expressions, and anonymous methods) are used. Analyze how they contribute
    to the code’s readability and maintainability.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will help Steve to develop and refactor his tower defense
    game in a functional programming way.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Name and count all expressions and all statements in the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactor the code below to use expressions instead of statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an expression tree that is the lambda expression, `(x, y) => x * y`.
    Then, compile and invoke it to multiply two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new` `Vector2(5, 5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5 (x-coordinate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5 (y-coordinate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new(position: new` `Vector2(5, 5))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainTower.MaxLevel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level <=` `mainTower.MaxLevel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level++`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level - 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.Pow(1.5, level -` `1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100 * Math.Pow(1.5, level -` `1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level (in` `string interpolation)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upgradeCost (in` `string interpolation)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$"Upgrading to level {level} costs {``upgradeCost} gold"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerGold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upgradeCost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerGold >=` `upgradeCost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upgradeCost (``in subtraction)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tower mainTower = new(position: new` `Vector2(5, 5));`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for (int level = 1; level <=` `mainTower.MaxLevel; level++)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double upgradeCost = 100 * Math.Pow(1.5, level -` `1);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Console.WriteLine($"Upgrading to level {level} costs {``upgradeCost} gold");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (playerGold >=` `upgradeCost)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainTower.Upgrade();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerGold -=` `upgradeCost;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Total: 22 expressions and 7 statements'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This refactored version uses LINQ expressions to filter active towers and sum
    their damage in a single line, eliminating the need for explicit loops and conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This solution creates an expression tree representing `(baseDamage, level) =>
    baseDamage * level`, compiles it into a function, and then invokes that function
    to calculate a tower’s damage based on its base damage (10) and level (5).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we dove into functional programming in C#, focusing on expressions
    and statements, and the powerful tools that C# provides to elevate your code.
    Let’s summarize the key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned the difference between expressions and statements. Functional programming
    often prefers expressions for their simple and direct style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at expression-bodied members, which give a shorter and cleaner way
    to write methods and properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We studied lambda expressions and anonymous methods. Both help in writing clear,
    brief, and contained code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We touched on expression trees, a special feature in C# that lets us handle
    code-like data. This is useful for things such as data queries in LINQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout, our goal was to understand not just how to use these tools but also
    why and when they’re helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn about pure functions, what makes a method “pure,” and what
    side effects mean.
  prefs: []
  type: TYPE_NORMAL
