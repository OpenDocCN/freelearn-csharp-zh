["```cs\nwhile(GetMessage( &msg, hWnd, 0, 0) != 0) \n{  \n    if (bRet == -1) \n    { \n        // handle the error and possibly exit \n    } \n    else \n    { \n        TranslateMessage(&msg);  \n        DispatchMessage(&msg);  \n    } \n} \n\n```", "```cs\nopen System \nopen System.Text \n\ntype Person() = \n    member val Name: String = \"\" with get, set \n    member val Address: String = \"\" with get, set \n    member val IsMarried = false with get, set \n    override this.ToString() =  \n        let mutable sb = new StringBuilder() \n        sb <- sb.Append(\"Person{\").Append(this.Name).Append(\"|\").Append(this.Address).Append(\"|\") \n        sb <- sb.Append(this.IsMarried).Append(\"}\") \n        sb.ToString() \n\n```", "```cs\n[<EntryPoint>] \nlet main argv =  \n    let anyPerson1 = new Person(Name = \"John Doe\", Address=\"Baker Street\", IsMarried = false) \n    let anyPerson2 = new Person(Name=\"Jane Doe\", Address =\"Arlington Street\", IsMarried = true) \n    Console.WriteLine(anyPerson1.ToString())  \n    Console.WriteLine(anyPerson2.ToString()) \n\n```", "```cs\n    static member Deserialize (serializedString:String) = \n        let mutable deserializedPerson = new Person() \n        let mutable strippedString = serializedString.Substring(7) \n        strippedString <- strippedString.Substring(0,strippedString.Length-1) \n        let splitString = strippedString.Split([| \"|\" |], StringSplitOptions.None) \n        deserializedPerson.Name <- splitString.[0] \n        deserializedPerson.Address <- splitString.[1] \n        deserializedPerson.IsMarried <- Boolean.Parse(splitString.[2]) \n        deserializedPerson \n\n```", "```cs\n[<EntryPoint>] \nlet main argv =  \n    let anyPerson1 = new Person(Name = \"John Doe\", Address=\"Baker Street\", IsMarried = false) \n    let anyPerson2 = new Person(Name=\"Jane Doe\", Address =\"Arlington Street\", IsMarried = true) \n    Console.WriteLine(anyPerson1.ToString())  \n    Console.WriteLine(anyPerson2.ToString()) \n    let anyperson3 = Person.Deserialize(anyPerson1.ToString()) \n    Console.WriteLine(anyperson3.ToString()) \n    0 // return an integer exit code \n\n```", "```cs\nopen System \nopen Microsoft.FSharp.Control \n\ntype EmailMessage() = \n    member val From : String = \"\" with get, set \n    member val To : String = \"\" with get, set \n    member val Cc : String = \"\" with get, set \n    member val DateSent : DateTime = (DateTime.Now) with get \n    member val Subject : String = \"\" with get, set \n    member val Content : String = \"\" with get, set \n\nlet mailbox = new MailboxProcessor<EmailMessage>(fun mailprocess -> \n    let rec loop = \n        async { printfn \"Incoming message!\"  \n                let! msg = mailprocess.Receive() \n                printfn \"Message received. \\r\\nFrom: %s, \\r\\nDate received: %s\" msg.From (msg.DateSent.ToString()) \n                printfn \"Subject: %s\" msg.Subject \n                printfn \"Content: \\r\\n %s\" msg.Content \n                return! loop } \n    loop)  \n\n```", "```cs\n    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>  \n            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit _arg2) cil managed \n    // SIG: 20 01 15 12 29 01 12 0D 12 0D \n    { \n      // Method begins at RVA 0x3450 \n      // Code size       16 (0x10) \n      .maxstack  8 \n      IL_0000:  /* 00   |                  */ nop \n      IL_0001:  /* 03   |                  */ ldarg.1 \n      IL_0002:  /* 26   |                  */ pop \n      IL_0003:  /* 02   |                  */ ldarg.0 \n      IL_0004:  /* 7B   | (04)00002E       */ ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder MailboxSample/'Loop@81-16'::builder@ \n      IL_0009:  /* 14   |                  */ ldnull \n      IL_000a:  /* 6F   | (2B)00000A       */ callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Return<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(!!0) \n      IL_000f:  /* 2A   |                  */ ret \n    } // end of method 'Loop@81-16'::Invoke \n  } // end of class 'Loop@81-16' \n\n```", "```cs\nlet email1 = new EmailMessage ( From = \"john@somemail.com\", To = \"clark@somemail.com\", Subject = \"Introduction\", Content = \"Hello there!\") \nlet email2 = new EmailMessage ( From = \"janet@somemail.com\", To = \"abby@somemail.com\", Subject = \"Friendly reminder\", Content = \"Please send me the report today. Thanks!\\r\\nRegards,\\r\\nJanet\") \nmailbox.Start() \nmailbox.Post(email1) \nmailbox.Post(email2)  \n\n```", "```cs\n// Signature: \nnew MailboxProcessor : (MailboxProcessor<'Msg> -> Async<unit>) * ?CancellationToken -> MailboxProcessor<'Msg> \n\n// Usage: \nnew MailboxProcessor (body) \nnew MailboxProcessor (body, cancellationToken = cancellationToken) \n\n```", "```cs\ntype ComplexMessage = \n    | OrdinaryMessage of EmailMessage \n    | ForceReplyDelay of AsyncReplyChannel<DateTime> \n\n```", "```cs\nlet msgManager = new MailboxProcessor<ComplexMessage>(fun inbox -> \n    let rec loop msgReceived = \n        async { let! msg = inbox.Receive() \n                match msg with \n                | OrdinaryMessage omsg ->  \n                    printfn \"Message received. \\r\\nFrom: %s, \\r\\nDate received: %s\" omsg.From (msg.DateSent.ToString()) \n                    printfn \"Subject: %s\" omsg.Subject \n                    printfn \"Content: \\r\\n %s\" omsg.Content \n                    return () \n                | ForceReplyDelay replyChannel -> \n                    replyChannel.Reply(msgReceived) \n                return! loop DateTime.Now \n             } \n    loop DateTime.Now \n    )  \n\n```", "```cs\n            let! message = inbox.Receive() \n                match msg with \n                | OrdinaryMessage omsg ->  \n                    printfn \"Message received. \\r\\nFrom: %s, \\r\\nDate received: %s\" omsg.From (msg.DateSent.ToString()) \n                    printfn \"Subject: %s\" omsg.Subject \n                    printfn \"Content: \\r\\n %s\" omsg.Content \n                    return () \n                | ForceReplyDelay replyChannel -> \n                    replyChannel.Reply(msgReceived) \n\n```", "```cs\nlet email1 = new EmailMessage ( From = \"john@somemail.com\", To = \"clark@somemail.com\", Subject = \"Introduction\", Content = \"Hello there!\") \nmsgManager.Start() \nmsgManager.Post(OrdinaryMessage email1) \nmsgManager.PostAndReply((fun reply -> ForceReplyDelay(reply)), 100) |> ignore \n\n```", "```cs\nstatic member Invoke :  \n        [<ParamArrayAttribute>] actions:Action[] -> unit \n\n```", "```cs\nstatic member Invoke :  \n        parallelOptions:ParallelOptions * \n        [<ParamArrayAttribute>] actions:Action[] -> unit \n\n```", "```cs\nopen System \nopen System.Diagnostics \nopen System.Threading.Tasks \n\nlet rec fact x =  \n    match x with \n    | n when n < 2 -> 1 \n    | _ -> fact(x-1) * x \n\nlet factwrap x = \n    let factresult = fact x \n    ignore \n\nlet runningProcesses = fun () ->  \n    let processes = Process.GetProcesses() \n    let processNames =  \n        processes \n        |> Seq.map (fun p -> p.ProcessName) \n    for name in processNames do \n        Console.WriteLine(name) \n\n```", "```cs\n[<EntryPoint>] \nlet main argv =  \n    let anyPerson1 = new Person(Name = \"John Doe\", Address=\"Baker Street\", IsMarried = false) \n    let anyPerson2 = new Person(Name=\"Jane Doe\", Address =\"Arlington Street\", IsMarried = true) \n    Console.WriteLine(anyPerson1.ToString())  \n    Console.WriteLine(anyPerson2.ToString()) \n    let anyperson3 = Person.Deserialize(anyPerson1.ToString()) \n    Console.WriteLine(anyperson3.ToString) \n    Parallel.Invoke(new Action(ParallelInvokeSample01.factwrap 5), new Action(ParallelInvokeSample01.runningProcesses)) \n    //printfn \"%A\" argv \n    0 // return an integer exit code \n\n```", "```cs\ntype Action =  \n    delegate of unit -> unit \n\n```", "```cs\n.class auto ansi serializable nested assembly beforefieldinit factwrap@14<a> \n       extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!a,class [FSharp.Core]Microsoft.FSharp.Core.Unit> \n{ \n} // end of class factwrap@14 \n\n```", "```cs\nParallel.Invoke(new ParallelOptions(MaxDegreeOfParallelism = 5),new Action(ParallelInvokeSample01.factwrap 5), new Action(ParallelInvokeSample01.runningProcesses)) \n\n```", "```cs\nopen System \nopen System.Threading.Tasks \n\nlet function1() = \n  for i = 1 to 10 do \n    Console.WriteLine(\"current datetime is\" + DateTime.Now.ToString()) \n  printfn \"\" \n\nParallel.For(1,10, fun(iteration) -> \n    Console.WriteLine(\"Iteration: \" + iteration.ToString() + \" current datetime: \" + DateTime.Now.ToString()) \n    printfn \"\" \n    ) \n\n```", "```cs\nlet seq1 = seq { for i in 1 .. 10 -> (i, i*i) } \nfor (a, asqr) in seq1 do \n  printfn \"%d squared is %d\" a asqr \n\nParallel.ForEach(seq1, fun((a,asqr)) -> \n  printfn \"%d squared is %d\" a asqr \n    ) \n\n```", "```cs\nopen System.Threading \n\nlet lock (lockobj:obj) anyfunction = \n  Monitor.Enter lockobj \n  try \n    anyfunction() \n  finally \n    // the code in the finally block will be executed after anyfunction is completely finishing execution.  \n    // Therefore we can exit the monitor gracefully. \n    Monitor.Exit lockobj \n\n```", "```cs\n       static member Parallel (l: seq<Async<'T>>) = \n            unprotectedPrimitive (fun args -> \n                let tasks,result =  \n                    try  \n                        Seq.toArray l, None   // manually protect eval of seq \n                    with exn ->  \n                        let edi = ExceptionDispatchInfo.RestoreOrCapture(exn) \n                        null, Some(errorT args edi) \n\n                match result with \n                | Some r -> r \n                | None -> \n                if tasks.Length = 0 then args.cont [| |] else  // must not be in a 'protect' if we call cont explicitly; if cont throws, it should unwind the stack, preserving Dev10 behavior \n                protectedPrimitiveCore args (fun args -> \n                    let ({ aux = aux } as args) = delimitSyncContext args  // manually resync \n                    let count = ref tasks.Length \n                    let firstExn = ref None \n                    let results = Array.zeroCreate tasks.Length \n                    // Attept to cancel the individual operations if an exception happens on any of the other threads \n                    let innerCTS = new LinkedSubSource(aux.token) \n                    let trampolineHolder = aux.trampolineHolder \n\n                    let finishTask(remaining) =  \n                        if (remaining = 0) then  \n                            innerCTS.Dispose() \n                            match (!firstExn) with  \n                            | None -> trampolineHolder.Protect(fun () -> args.cont results) \n                            | Some (Choice1Of2 exn) -> trampolineHolder.Protect(fun () -> aux.econt exn) \n                            | Some (Choice2Of2 cexn) -> trampolineHolder.Protect(fun () -> aux.ccont cexn) \n                        else \n                            FakeUnit \n\n                    // recordSuccess and recordFailure between them decrement count to 0 and  \n                    // as soon as 0 is reached dispose innerCancellationSource \n\n                    let recordSuccess i res =  \n                        results.[i] <- res; \n                        finishTask(Interlocked.Decrement count)  \n\n                    let recordFailure exn =  \n                        // capture first exception and then decrement the counter to avoid race when \n                        // - thread 1 decremented counter and preempted by the scheduler \n                        // - thread 2 decremented counter and called finishTask \n                        // since exception is not yet captured - finishtask will fall into success branch \n                        match Interlocked.CompareExchange(firstExn, Some exn, None) with \n                        | None ->  \n                            // signal cancellation before decrementing the counter - this guarantees that no other thread can sneak to finishTask and dispose innerCTS \n                            // NOTE: Cancel may introduce reentrancy - i.e. when handler registered for the cancellation token invokes cancel continuation that will call 'recordFailure' \n                            // to correctly handle this we need to return decremented value, not the current value of 'count' otherwise we may invoke finishTask with value '0' several times \n                            innerCTS.Cancel() \n                        | _ -> () \n                        finishTask(Interlocked.Decrement count) \n\n```"]