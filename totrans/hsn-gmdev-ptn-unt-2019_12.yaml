- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have to admit that the Command pattern might be hard to understand at first.
    I know that it took me time to master it. Even if its name indicates its core
    purpose, its actual application is not apparent at first. But once you start playing
    around with it and comprehend its intricacies, it can become a sturdy pattern
    to apply when designing specific types of systems, such as user interfaces. Its
    primary purpose is to offer a way to encapsulate data that is needed to execute
    an operation or trigger an event at a particular moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic principles behind the Command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Universal Controller that we can control multiple devices with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Our6OF](http://bit.ly/2Our6OF)'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Command pattern is a solution that makes it possible to centralize the process
    of invoking specific commands on objects. A real-world correlation I keep in mind
    when thinking about the Command pattern is a *Universal Controller*. Back in the
    day, before the internet and smartphones, most living rooms had multiple devices,
    each with a specific functionality. You had a stereo to play music, a TV to watch
    shows, a VHS to play tapes, and so on, but each system had a particular remote
    control associated with it, so this often caused confusion because of the variety
    of controllers you needed to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, the programmable *Universal Controller* was invented, which resolved
    this issue and allowed you to control multiple devices from a single remote. This
    approach worked because a *Universal Controller* had a standard set of buttons
    that you could associate with commands and devices.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, the Command pattern is very similar to the concept of a *Universal
    Controller* because it permits you to link and invoke specific commands on objects
    that can handle requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following diagram, which is of a typical implementation of
    the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cad29e3-cc4d-44ca-a948-c53825d38454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Trying to learn about the Command pattern by looking at a diagram is not the
    right approach, but it does help us isolate the fundamental classes that are participating
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Invoker` is an object that knows how to execute a command and can also do
    the bookkeeping of executed commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Receiver` is a type of object that can receive commands and execute them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CommandBase` is usually an interface or abstract class for concrete command
    classes. It's the primary layer of abstraction of this pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These core classes encapsulate all the information that's needed to execute
    a command at a specific moment. This will be made more evident when we implement
    our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to patterns such as the Strategy and State, the main reason that programmers
    seem to avoid using the Command pattern is because of its *wordiness*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main benefits of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequencing and timing**: The Command pattern gives you the flexibility of
    executing commands in a sequence or within a specific time frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo/Redo**: The Command pattern is often used to implement bookkeeping features
    that permit to rollback commands in specific orders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: A typical advantage of Behavioral patterns is that they
    give you the ability to add behaviors with minimal changes having to be made to
    the main classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the drawbacks of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbosity**: A common disadvantage of this type of pattern is that it makes
    your code very verbose and adds a lot more classes to your code base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a use case, we will actually implement a Universal Controller that will permit
    us to control multiple devices, including a TV and radio. The main reason we are
    going to use the Universal Controller concept as an example is because it's going
    to be easier for us to learn the intricacies of the Command pattern, which we
    will do by implementing a system that is directly related to managing the invocation
    of commands on specific objects.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the Command pattern with a specific use case is the best way to
    master it. The example we are going to write is a perfect fit for the Command
    pattern because it''s all about sending commands to specific receivers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first class, we will need to declare the `RemoteControlDevice` type
    in the form of an abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the `Command` class, which is our core type for this pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, its primary responsibility is to assign a `Receiver` object and
    `Execute()` a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement concrete Command classes, each with their unique responsibility.
    First off, let''s implement `TurnOnCommand`, which is used to turn on our devices
    (receivers):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is our `TurnOffCommand`, which will, of course, turn off our devices
    (receivers):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also our `KillSwitchCommand`, which is unique:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `KillSwitchCommand` doesn't merely call the `Execute()` function
    on a `Receiver` object, but goes through a list of devices and calls the `TurnOff()`
    function on each of them. This means that we are batching the execution of a specific
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to implement our devices that receive the orders to execute specific
    commands. Our first receiver is `Television`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next receiver is `Radio`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, both receivers have implemented the `TurnOn()` and `TurnOff()`
    functions. They are thus encapsulating the details of their unique behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, let''s implement a vital player of the `Command pattern`, `Invoker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example of `Invoker` is straightforward but can easily be extended to bookkeep
    the commands that are executed through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have our `Client` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that there''s a specific sequence of calls to be made when
    invoking a command:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a new Command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass it to `Invoker`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Invoker` executes the specified Command'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this approach, we are maintaining a consistent channel of communication
    between those that invoke commands and those that receive them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Command pattern, a unique pattern that tends
    to confuse a lot of programmers at first because its core usefulness is not always
    apparent. But once you apply it correctly, it does offer a lot of extensibility
    when implementing systems that are dependent on executing commands in specific
    orders on multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the Observer pattern, a pattern that's more easily understandable
    than Command and is the core of C#'s event system.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Command pattern is often used to implement the classic undo/redo functionality
    that you find in most text editors. In our code example, we implemented the groundwork
    to support this feature. So, as a practice exercise, I recommend that you integrate
    your own undo/redo feature. You can find cues on the best approach to this in
    the `Invoker` and `KillSwitchCommand` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Applying UML and Patterns,* by Craig Larman: [http://www.craiglarman.com](http://www.craiglarman.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
