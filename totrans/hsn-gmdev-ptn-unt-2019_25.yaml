- en: Object Pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Object Pool pattern is straightforward to understand; as its name suggests,
    it organizes a pool of objects. The simplest way to visualize the design intent
    behind this pattern is to imagine a swimming pool filled to the brim with balloons
    of various colors. If you wish, you can take all the green ones out, play with
    them and, once done, put them back. In other words, you always have a collection
    of specific types of objects ready to be used, and a place to store them afterward.
  prefs: []
  type: TYPE_NORMAL
- en: If we translate this concept into code, what we have is specific types of objects
    already contained in memory, which we can pull from when we need and then pool
    them back into memory when we are finished. This approach means we are using a
    constant size of reserved memory for specific types of ready-made objects. As
    you may already presume, this is a very optimized way of managing objects for
    a video game project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the basics of the Object Pool pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement the Object Pool pattern to manage reusable game objects for
    a zombie game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on; you will need to have a basic understanding of Unity
    and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2WutcB2](http://bit.ly/2WutcB2)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Object Pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Object Pool pattern is usually defined as a creational design pattern in
    academic documentation, but in this book, we have categorized it as an optimization
    pattern, because its core purpose is more aligned with optimization than the creation
    process – at least in the way we are going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept of this pattern is simple; a pool in the form of a container
    holds a collection of initialized objects. Clients can request the Object Pool
    for a specific type and number of objects. The Client must return the objects
    to the Object Pool once it's done using them. So, this means the pool always get
    filled back up, and is never drained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the back and forth between the `Client` and
    the `ObjectPool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cefb52-61e0-4305-8ec2-5a7e41f4307c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `Reusable Object` is always in memory; it is just its owner
    that switches between the Client and `ObjectPool`, depending on whether it's in
    an acquired or released state.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Object Pool pattern is quite popular with Unity developers, but it has
    its critics in the broader software development community:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefits**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictable memory usage**: Because the Object Pool pattern is configurable,
    you can set limits for the number of instances of specific objects available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance boost**: By having objects already initialized in memory, you
    avoid the loading cost of initializing new ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drawbacks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layering on already-managed memory**: Some criticize the Object Pool pattern
    as being unnecessary in most cases, because modern managed programming languages
    such as C# already optimally control memory allocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unpredictable object states**: The main pitfall of the Object Pool pattern
    is that, if incorrectly managed, objects will be returned to the pool in their
    current state instead of their default one. This issue can cause unpredictable
    behaviors the next time they are pulled out of the pool, because objects might
    be in an unexpected state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object pools have a lot of added value for mobile games, because phones have
    limited memory and resources compared to the average PC or console.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the other creational patterns, the Object Pool can be a great pattern
    to use when designing a spawn system. But, this time, we will focus on having
    a Client pulling and pooling directly from an Object Pool without any layers of
    abstraction between them, so we can see the system at work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to give some context to the following code example, let''s imagine we
    are doing a *Plants versus Zombies* clone. Like most zombie games, we have hordes
    of zombies moving toward a target. Each horde can contain various types of zombies,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Walkers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, what's important to consider is that every time our player kills one of
    them, instead of destroying the instance of the defeated zombie in memory, we
    can instead send it back to an Object Pool so that it can be used again afterward.
    With this approach, we are recycling our zombie-type entities instead of initializing
    new ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement this use case and adapt it, so that it
    works with Unity's GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter might be difficult to follow just by reading the code, because
    we are managing prefabs inside a scene. So, we recommend that you download the
    Unity project associated with this book on our Git depot at [https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018).
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity project, there should be a folder named Object Pool, with a scene
    included that will have the entire set of dependencies to run this example properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, in case the GitHub address is unavailable, here''s a quick list of steps
    that need to be done in order to execute the following code example inside a Unity
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new scene, add an empty `GameObject`, and name it `Object Pool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a set of prefabs and related scripts for each type of zombie. Here are
    some examples of zombie behavior scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Runner`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Walker`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Screamer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Attach the `ObjectPool` script to the `GameObject` Object Pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the inspector of the `GameObject` Object Pool, configure the list of zombie
    prefabs that the `ObjectPool` instance will manage. You can refer to the following
    screenshot for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43532542-f677-4cd0-9daf-34be205bf351.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s time for us to write the `ObjectPool` class. As you will see, it''s
    quite long, so it''s essential we read through it, and review its core features
    afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here''s a quick breakdown of what''s happening in the `ObjectPool` class
    in each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start()`: In this function, we are initializing a `list()` that will contain
    instances of our pooled objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PullObject()`: By calling this function, Clients can request an instance of
    an object from the pool just by specifying the name of its type. If we have it
    in store, we return its instance; if not, we initialize a new instance of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PoolObject()`: A client can use this function to return instances of objects
    to the pool. `ObjectPool` will deactivate the returning object and attach it back
    to itself as a child, so it can keep it contained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also see that our `ObjectPool` class is a singleton; this is a common
    approach, because we usually need to have Object Pools globally accessible and
    always available. To learn how to implement a singleton, please review [Chapter
    6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml), *Singleton*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to test out our `ObjectPool` with a `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Client` class is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: If the player presses *G*, we request an instance of a Walker zombie from the
    `ObjectPool`. Then, we place it randomly in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player presses *P*, we send all the Walker objects that are currently
    in our scene back into the pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that's it; with one class, we can implement a simple, configurable, and
    extensible Object Pool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just added the Object Pool pattern to our toolkit; it's one of the most
    useful patterns for Unity developers because, as we saw in our code example, we
    can easily recycle GameObjects that are already in our scene without having to
    initialize new ones. When dealing with huge prefabs that contain a lot of data
    and components to initialize, this pattern can help you avoid inconsistent frame
    rates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore the Spatial Partition pattern—a
    subject matter that's quite important to understand when building open-world games.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned all the core creational patterns, such as Factory,
    Prototype, and Object Pool, it would be a valuable practical exercise to combine
    all those patterns and build the ultimate Spawn System. The goal is to have a
    system that reuses instances of objects of specific types and only creates new
    ones when it's necessary, and, if it does, uses a Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by Robert Nystrom[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
