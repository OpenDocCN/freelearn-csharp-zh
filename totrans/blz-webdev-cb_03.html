<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-95">
    <a id="_idTextAnchor095">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor096">
    </a>
    
     Taking Control of Event Handling
    
   </h1>
   <p>
    
     In this chapter, we’ll dive into the world of event handling within Blazor applications.
    
    
     An
    
    <strong class="bold">
     
      event
     
    </strong>
    
     is a fundamental building block that signifies an action within the browser, such as clicks, inputs, or page loads.
    
    
     Events allow developers to execute specific code upon user interactions – creating an interactive and dynamic
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     We’ll start by exploring how to hook into event delegates, laying the foundation for event management.
    
    
     Next, we’ll discuss delegating responsibilities using
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     and lambda expressions that increase flexibility in
    
    
     
      event handling.
     
    
   </p>
   <p>
    
     We’ll also cover essential strategies for controlling event propagation and preventing the triggering of default events.
    
    
     These skills are vital for creating intuitive user interfaces where you have complete control over user interactions.
    
    
     Furthermore, we introduce the concept of custom events, expanding the possibilities for an
    
    <strong class="bold">
     
      event-driven
     
    </strong>
    
     
      application design.
     
    
   </p>
   <p>
    
     A key focus will be on understanding how events trigger rendering in Blazor.
    
    
     This understanding is crucial for optimizing application performance and ensuring a seamless user experience.
    
    
     By the end of this chapter, you’ll have a thorough understanding of event handling in Blazor and have gained the practical skills to apply these concepts effectively in your web
    
    
     
      development projects.
     
    
   </p>
   <p>
    
     Here’s the list of recipes we’ll cover in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Hooking into
     
     
      
       event delegates
      
     
    </li>
    <li>
     
      Delegating with
     
     
      
       lambda expressions
      
     
    </li>
    <li>
     
      Delegating
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        EventCallback
       
      </strong>
     
    </li>
    <li>
     
      Preventing default
     
     
      
       event actions
      
     
    </li>
    <li>
     
      Controlling
     
     
      
       event propagation
      
     
    </li>
    <li>
     
      Introducing
     
     
      
       custom events
      
     
    </li>
    <li>
     
      Handling
     
     
      
       long-running events
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-97">
    <a id="_idTextAnchor097">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The aim of this chapter is to keep the examples straightforward and focus on the principles of event handling in Blazor.
    
    
     With that said, you won’t need any additional tools, just
    
    
     
      these basics:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      .NET 9 installed on your
     
     
      
       development machine
      
     
    </li>
    <li>
     
      A modern web browser (that
     
     
      
       supports WebAssembly)
      
     
    </li>
    <li>
     
      A Blazor project (where you’ll write code as you
     
     
      
       go along)
      
     
    </li>
   </ul>
   <p>
    
     All the code examples (and data samples) that you’ll see can be found in a dedicated GitHub repository at:
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03">
     
      https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03
     
    </a>
    
     .
    
    
     In each recipe that needs any samples, I will also point you to the directory where you can
    
    
     
      find them.
     
    
   </p>
   <h1 id="_idParaDest-98">
    <a id="_idTextAnchor098">
    </a>
    
     Hooking into event delegates
    
   </h1>
   <p>
    
     UI events are the cornerstone of user interaction on the web – signaling every click, scroll, or keyboard press and enabling you to craft an interactive application.
    
    
     An event delegate acts as a bridge between the browser and your code.
    
    
     Each user interaction triggers a designated handler that executes a predefined action.
    
    
     In this recipe, we will dive into the mechanics
    
    <a id="_idIndexMarker127">
    </a>
    
     of event delegates, illustrating how they are detected and managed within a
    
    
     
      Blazor application.
     
    
   </p>
   <p>
    
     Let’s create a page, where users can display and hide a list of tickets by clicking
    
    
     
      a button.
     
    
   </p>
   <h2 id="_idParaDest-99">
    <a id="_idTextAnchor099">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you implement a clickable button, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      sample files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor100">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement a basic event
    
    
     
      delegate hook:
     
    
   </p>
   <ol>
    <li>
     
      Create a new routable
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component that renders in
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch03r01"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      Add the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section
     
     <a id="_idIndexMarker128">
     </a>
     
      to your
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component.
     
     
      Declare a
     
     <strong class="source-inline">
      
       ShowTickets
      
     </strong>
     
      property of type
     
     <strong class="source-inline">
      
       bool
      
     </strong>
     
      that will determine the visibility of the
     
     
      
       ticket list:
      
     
     <pre class="source-code">
@code {
    protected bool ShowTickets { get; set; }
}</pre>
    </li>
    <li>
     
      Additionally, still inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a method to toggle the
     
     <strong class="source-inline">
      
       ShowTickets
      
     </strong>
     
      property to change the ticket
     
     
      
       list’s visibility:
      
     
     <pre class="source-code">
private void ToggleTickets()
    =&gt; ShowTickets = !ShowTickets;</pre>
    </li>
    <li>
     
      In the markup area of the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component, introduce a button that leverages the
     
     <strong class="source-inline">
      
       ToggleTickets()
      
     </strong>
     
      method and allows the user to update the
     
     
      
       UI accordingly:
      
     
     <pre class="source-code">
&lt;button class="btn btn-sm btn-success"
    @onclick="@ToggleTickets"&gt;
    Toggle Tickets
&lt;/button&gt;</pre>
    </li>
    <li>
     
      Below the button, based on the current value of the
     
     <strong class="source-inline">
      
       ShowTickets
      
     </strong>
     
      property, conditionally skip displaying the list of tickets or render the horizontal separator, indicating where the tickets
     
     
      
       area starts:
      
     
     <pre class="source-code">
@if (!ShowTickets) return;
&lt;hr /&gt;</pre>
    </li>
    <li>
     
      Under the horizontal
     
     <a id="_idIndexMarker129">
     </a>
     
      separator, render the list of tickets, utilizing the
     
     <strong class="source-inline">
      
       Tickets.All
      
     </strong>
     
      collection, from the copied sample data, as your
     
     
      
       data source:
      
     
     <pre class="source-code">
@foreach (var ticket in Tickets.All)
{
    &lt;div class="d-flex justify-content-between mb-1"
         id="ticket-@ticket.Id"&gt;
        &lt;div&gt;@ticket.Title&lt;/div&gt;
    &lt;/div&gt;
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor101">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We begin the implementation by creating a routable
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component, as outlined in
    
    <em class="italic">
     
      step 1
     
    </em>
    
     .
    
    
     We declare the navigable path with the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     directive.
    
    
     We also declare an interactive render mode as we will need our button to be actionable.
    
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we introduce a backing
    
    <strong class="source-inline">
     
      ShowTickets
     
    </strong>
    
     property.
    
    
     This property serves as a flag indicating the current visibility state of the ticket list – either displayed or hidden.
    
    
     Then, in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we introduce a
    
    <strong class="source-inline">
     
      ToggleTickets()
     
    </strong>
    
     method designed to toggle the
    
    
     <strong class="source-inline">
      
       ShowTickets
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <p>
    
     We implement the core of interactivity in
    
    <em class="italic">
     
      step 4
     
    </em>
    
     by hooking into the event callback mechanism of Blazor.
    
    
     We add a button in the component’s markup to give users the power to control the display state of the ticket list.
    
    
     With
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     , we can trigger our
    
    <strong class="source-inline">
     
      ToggleTickets()
     
    </strong>
    
     method when an
    
    <strong class="source-inline">
     
      onclick
     
    </strong>
    
     
      event occurs.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we check the value of the
    
    <strong class="source-inline">
     
      ShowTickets
     
    </strong>
    
     property and decide whether to skip rendering the ticket list entirely.
    
    
     For cases when we render the list, we add a
    
    <strong class="source-inline">
     
      &lt;hr /&gt;
     
    </strong>
    
     tag to clearly indicate where the tickets area starts.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we iterate over the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     sample collection and render all available ticket titles in a flexible
    
    <strong class="source-inline">
     
      div
     
    </strong>
    
     container.
    
    
     With this setup,
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     reacts to user interactions and either renders or hides the ticket list, as dictated by the current value of the
    
    
     <strong class="source-inline">
      
       ShowTickets
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor102">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Blazor offers seamless integration with
    
    <strong class="source-inline">
     
      onclick
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      ondrag
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      oncopy
     
    </strong>
    
     , and other HTML events you’re already familiar with, allowing for dynamic and interactive web application development.
    
    
     By prefixing the event name with the
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     symbol, you signal to Blazor that you’re employing a Blazor-specific
    
    <a id="_idIndexMarker130">
    </a>
    
     event rather than a standard HTML event.
    
    
     This distinction is crucial for harnessing the full power of Blazor’s
    
    
     
      event system.
     
    
   </p>
   <p>
    
     One of the key advantages of using Blazor events is their ability to update the DOM in real time.
    
    
     Blazor employs a native
    
    <strong class="bold">
     
      diffing algorithm
     
    </strong>
    
     , which calculates precisely which parts of the DOM have changed and
    
    <a id="_idIndexMarker131">
    </a>
    
     updates only those parts.
    
    
     This results in a significantly smaller payload when communicating with the server and faster rendering times regardless of the selected
    
    
     
      render mode.
     
    
   </p>
   <p>
    
     It’s important to note that Blazor rendering is typically triggered only upon the initial render of a component or when you explicitly invoke the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     lifecycle method.
    
    
     If we explore deeper, HTML event counterparts in Blazor are actually instances of
    
    <strong class="source-inline">
     
      EventCallback&lt;T&gt;
     
    </strong>
    
     (complete with event arguments).
    
    
     A closer look at the
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     implementation reveals that it invokes the
    
    <strong class="source-inline">
     
      HandleEventAsync()
     
    </strong>
    
     method of the
    
    
     <strong class="source-inline">
      
       Receiver
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
public Task InvokeAsync(object? arg)
{
    if (Receiver == null)
    {
        return EventCallbackWorkItem
            .InvokeAsync&lt;object?&gt;(Delegate, arg);
    }
    return Receiver
        .HandleEventAsync(
            EventCallbackWorkItem(Delegate),arg);
}</pre>
   <p>
    
     In most cases, our receiver inherits from
    
    <strong class="source-inline">
     
      ComponentBase
     
    </strong>
    
     .
    
    
     Intriguingly, the
    
    <strong class="source-inline">
     
      ComponentBase.HandleEventAsync()
     
    </strong>
    
     method automatically invokes
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     .
    
    
     As a
    
    <a id="_idIndexMarker132">
    </a>
    
     result, the component’s state updates without requiring
    
    
     
      manual intervention:
     
    
   </p>
   <pre class="source-code">
Task IHandleEvent.HandleEventAsync(
    EventCallbackWorkItem callback, object? arg)
{
    // ...
    StateHasChanged();
    // ...
}</pre>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor103">
    </a>
    
     Delegating with lambda expressions
    
   </h1>
   <p>
    
     In this recipe, we will explore the power of
    
    <strong class="bold">
     
      lambda expressions
     
    </strong>
    
     in .NET and their pivotal role in Blazor event handling.
    
    
     In the simplest terms, a lambda expression is an anonymous method that
    
    <a id="_idIndexMarker133">
    </a>
    
     follows a specific syntax.
    
    
     These expressions are a cornerstone of functional programming in .NET and offer a streamlined approach to writing inline delegate implementations.
    
    
     When it comes to Blazor, delegating with lambda expressions becomes particularly advantageous.
    
    
     They come in handy for defining event handlers and callbacks directly within the markup.
    
    
     They also enable you to intercept incoming parameters and a current
    
    
     
      operational context.
     
    
   </p>
   <p>
    
     Let’s leverage lambda expressions and add a few more actions to the tickets list, allowing us to modify the state of a
    
    
     
      given ticket.
     
    
   </p>
   <h2 id="_idParaDest-104">
    <a id="_idTextAnchor104">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into delegating with lambda expressions, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Hooking into event delegates
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      sample files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-105">
    <a id="_idTextAnchor105">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to
    
    <a id="_idIndexMarker134">
    </a>
    
     see the power of delegating with
    
    
     
      lambda expressions:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      and, below the existing code, initialize an object of type
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      to store the details of the currently
     
     
      
       selected ticket:
      
     
     <pre class="source-code">
protected Ticket SelectedTicket;</pre>
    </li>
    <li>
     
      Below, still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       Show()
      
     </strong>
     
      method that enables setting the value of the currently
     
     
      
       selected ticket:
      
     
     <pre class="source-code">
private void Show(Ticket ticket)
    =&gt; SelectedTicket = ticket;</pre>
    </li>
    <li>
     
      Jump to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup and extend the rendering of ticket details by adding two action buttons below the
     
     <strong class="source-inline">
      
       Title
      
     </strong>
     
      section and attaching their actions with
     
     
      
       lambda expressions:
      
     
     <pre class="source-code">
&lt;div&gt;@ticket.Title&lt;/div&gt;
&lt;div&gt;
    &lt;button class="btn btn-sm btn-success"
            @onclick=@(() =&gt; Show(ticket))&gt;
        Show details
    &lt;/button&gt;
    &lt;button class="btn btn-sm btn-success"
            @onclick=@(() =&gt; ticket.Stock += 5)&gt;
        Top up
    &lt;/button&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Below the loop rendering ticket
     
     <a id="_idIndexMarker135">
     </a>
     
      details, check whether the user has already set the
     
     <strong class="source-inline">
      
       SelectedTicket
      
     </strong>
     
      value and conditionally skip the specific ticket
     
     
      
       details rendering:
      
     
     <pre class="source-code">
@if (SelectedTicket is null) return;
&lt;hr /&gt;</pre>
    </li>
    <li>
     
      For the case where the
     
     <strong class="source-inline">
      
       SelectedTicket
      
     </strong>
     
      variable has a value, render the ticket title, price, and availability.
     
     
      Ensure that this section only becomes visible when the value of
     
     <strong class="source-inline">
      
       SelectedTicket
      
     </strong>
     
      
       is available:
      
     
     <pre class="source-code">
&lt;div&gt;Title: @SelectedTicket.Title&lt;/div&gt;
&lt;div&gt;Price: @SelectedTicket.Price&lt;/div&gt;
&lt;div&gt;Stock: @SelectedTicket.Stock&lt;/div&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-106">
    <a id="_idTextAnchor106">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     and initialize a
    
    <strong class="source-inline">
     
      SelectedTicket
     
    </strong>
    
     variable that will hold a reference to the currently selected ticket.
    
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      Show()
     
    </strong>
    
     method, which accepts
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     as a parameter.
    
    
     The singular responsibility of the
    
    <strong class="source-inline">
     
      Show()
     
    </strong>
    
     method is to update the
    
    
     <strong class="source-inline">
      
       SelectedTicket
      
     </strong>
    
    
     
      reference.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we shift to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup where we iterate over the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection from the sample and render each ticket title.
    
    
     Below the section with
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     , we add two buttons enabling administrative actions, leveraging the delegation with lambda expressions.
    
    
     With the first button, we allow a user to display a given ticket’s details by attaching the
    
    <strong class="source-inline">
     
      Show()
     
    </strong>
    
     method to the button’s
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event and passing over a reference to the currently iterated
    
    <strong class="source-inline">
     
      ticket
     
    </strong>
    
     object.
    
    
     Here, the use of lambda expressions allows implementing precise and context-aware actions.
    
    
     The second button enables the user to top up the ticket stock.
    
    
     This time, we
    
    <a id="_idIndexMarker136">
    </a>
    
     use an
    
    <strong class="bold">
     
      anonymous lambda expression
     
    </strong>
    
     – a lambda expression that encapsulates the operation itself rather than delegating to an existing method.
    
    
     We access the
    
    <strong class="source-inline">
     
      Stock
     
    </strong>
    
     property of each ticket as we iterate over the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     sample collection and increment the
    
    <strong class="source-inline">
     
      Stock
     
    </strong>
    
     value by 5 directly within
    
    
     
      the markup.
     
    
   </p>
   <p>
    
     However, with the flexibility and power of lambda expressions comes great responsibility.
    
    
     Minimizing the
    
    <a id="_idIndexMarker137">
    </a>
    
     amount of C# code within the markup is good practice.
    
    
     Use a strongly typed method to encapsulate complex and lengthy lambda expressions and maintain the clarity of
    
    
     
      your code.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we extend the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup further.
    
    
     Similar to checking the
    
    <strong class="source-inline">
     
      ShowTickets
     
    </strong>
    
     value and conditionally displaying the list of tickets (that we implemented in the
    
    <em class="italic">
     
      Hooking into event delegates
     
    </em>
    
     recipe), we check whether the user set the value of
    
    <strong class="source-inline">
     
      SelectedTicket
     
    </strong>
    
     and conditionally skip the rendering of the specific ticket details.
    
    
     We conclude the implementation in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     by adding a simple markup to render the
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Price
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      Stock
     
    </strong>
    
     properties of the ticket that the user selects.
    
    
     As Blazor converts the lambda expression to an
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     object, users will see updates of the
    
    <strong class="source-inline">
     
      Stock
     
    </strong>
    
     property value immediately after each
    
    <strong class="bold">
     
      Top Up
     
    </strong>
    
     
      button click.
     
    
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor107">
    </a>
    
     See also
    
   </h2>
   <p>
    
     If you’re interested in learning more about the roles and capabilities of lambda expressions, visit the Microsoft
    
    
     
      Learn section:
     
    
   </p>
   <p>
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">
     
      
       https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions
      
     
    </a>
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor108">
    </a>
    
     Delegating with EventCallback
    
   </h1>
   <p>
    
     In this recipe, we explore event delegation with the help of
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     .
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     in Blazor is a mechanism that enables components to listen for and react to user-generated events or interactions, tying closely with the framework’s architectural design.
    
    
     This Blazor-native feature empowers developers to write cleaner, more efficient code by seamlessly integrating with the component lifecycle and the overall application state.
    
    
     The primary
    
    <a id="_idIndexMarker138">
    </a>
    
     benefit of event callbacks is their ability to automatically manage UI updates through the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     method, ensuring that the user interface remains in sync with the application’s state.
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     is also a null-safe object – when it’s not assigned but invoked, it safely skips rather than throwing
    
    <strong class="source-inline">
     
      NullReferenceException
     
    </strong>
    
     .
    
    
     You will see
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     in all the recipes in this chapter, as it’s a building block of most interactivity
    
    
     
      in Blazor.
     
    
   </p>
   <p>
    
     Let’s implement a component where we encapsulate administrative ticket actions with the help of
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     parameters.
    
    
     With that component, we will also simplify the markup of the
    
    
     
      ticket list.
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor109">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we implement delegation with
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     , do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Delegating with lambda expressions
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      sample files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor110">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement an article management system using
    
    
     <strong class="source-inline">
      
       EventCallback
      
     </strong>
    
    
     
      delegates:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     
      <strong class="source-inline">
       
        TicketOptions
       
      </strong>
     
     
      
       component.
      
     
    </li>
    <li>
     
      Initialize the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block in
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      and declare three required parameters, each of type
     
     <strong class="source-inline">
      
       EventCallback
      
     </strong>
     
      , corresponding to the different
     
     
      
       administrative actions:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public EventCallback OnShow { get; set; }
    [Parameter, EditorRequired]
    public EventCallback OnTopUp { get; set; }
    [Parameter, EditorRequired]
    public EventCallback OnRemove { get; set; }
}</pre>
    </li>
    <li>
     
      Jump to the
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      markup
     
     <a id="_idIndexMarker139">
     </a>
     
      and construct buttons allowing a user to invoke
     
     <strong class="source-inline">
      
       OnShow
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       OnTopUp
      
     </strong>
     
      , and
     
     
      <strong class="source-inline">
       
        OnRemove
       
      </strong>
     
     
      
       actions:
      
     
     <pre class="source-code">
&lt;button class="btn btn-sm btn-success"
        @onclick="@OnShow"&gt;
    Show
&lt;/button&gt;
&lt;button class="btn btn-sm btn-info"
        @onclick="@OnTopUp "&gt;
    Top up
&lt;/button&gt;
&lt;button class="btn btn-sm btn-danger"
        @onclick="@OnRemove"&gt;
    Remove
&lt;/button&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     
      <strong class="source-inline">
       
        TicketManager
       
      </strong>
     
     
      
       component.
      
     
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      , implement two new methods allowing you to remove
     
     <a id="_idIndexMarker140">
     </a>
     
      and top up the stock of a
     
     
      <strong class="source-inline">
       
        Ticket
       
      </strong>
     
     
      
       object:
      
     
     <pre class="source-code">
private void TopUp(Ticket ticket)
    =&gt; ticket.Stock += 5;
private void Remove(Ticket ticket)
    =&gt; Tickets.All.Remove(ticket);</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, replace the existing action buttons in the ticket details with the
     
     
      <strong class="source-inline">
       
        TicketOptions
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
&lt;div&gt;@ticket.Title&lt;/div&gt;
&lt;div&gt;
    &lt;TicketOptions
        OnShow="@(() =&gt; Show(ticket))"
        OnTopUp="@(() =&gt; TopUp(ticket))"
        OnRemove="@(() =&gt; Remove(ticket))" /&gt;
&lt;/div&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor111">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a new
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block in
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     and declare three required
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     parameters that will carry the action delegates necessary for triggering administrative ticket actions.
    
    
     Next, in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we construct the
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     markup with three buttons, each invoking
    
    <strong class="source-inline">
     
      OnShow
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      OnTopUp
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      OnRemove
     
    </strong>
    
     parameters when users click them.
    
    
     Notice that we attach the
    
    <strong class="source-inline">
     
      EventCallback
     
    </strong>
    
     parameters directly to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event of each button.
    
    
     We don’t need to add additional methods that will act as proxies.
    
    
     Blazor will seamlessly link UI interactions with our
    
    
     
      predefined actions.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we extend the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     with two additional methods.
    
    
     First, we implement a
    
    <strong class="source-inline">
     
      TopUp()
     
    </strong>
    
     method, that increments the current
    
    <a id="_idIndexMarker141">
    </a>
    
     ticket
    
    <strong class="source-inline">
     
      Stock
     
    </strong>
    
     property value by 5.
    
    
     Next, we implement a
    
    <strong class="source-inline">
     
      Remove()
     
    </strong>
    
     method that simply removes a given ticket from the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we locate the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup area where we render primitive action buttons for each ticket.
    
    
     We replace those buttons with the
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     markup and attach respective actions to each of the required
    
    
     <strong class="source-inline">
      
       EventCallback
      
     </strong>
    
    
     
      parameters.
     
    
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor112">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     component in place, we’ve significantly simplified the
    
    <strong class="source-inline">
     
      TicketsManager
     
    </strong>
    
     markup code.
    
    
     We’ve refactored ticket-related actions in a more organized and readable manner, making the overall code base cleaner and easier
    
    
     
      to maintain.
     
    
   </p>
   <p>
    
     But, since
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     acts only as an action proxy and is not based on a
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     reference, we effectively create new delegate instances, wrapping the actionable method inside, every time we render the
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     component.
    
    
     This operation might come with a performance penalty even with all the C# optimization magic.
    
    
     In simple applications, the performance impact will likely be negligible.
    
    
     However, you must keep this in mind when working with data-heavy or highly
    
    
     
      reactive systems.
     
    
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor113">
    </a>
    
     Preventing default event actions
    
   </h1>
   <p>
    
     In this recipe, we explore the mechanics of browsers automatically executing specific actions in response to user events.
    
    
     Default
    
    <a id="_idIndexMarker142">
    </a>
    
     event actions can include form submission when the return key is pressed or navigating to a link’s URL when it’s clicked.
    
    
     However, there are scenarios in Blazor applications where you might need to intercept these automatic behaviors to control the user experience.
    
    
     Whether to manage form validation, confirm user intentions, or manage dynamic content updates without refreshing the page, preventing default actions becomes essential.
    
    
     I will guide you through stopping these default behaviors programmatically within
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Let’s implement a fast ticket creation feature, where we will intercept and apply custom logic with each key store a
    
    
     
      user makes.
     
    
   </p>
   <h2 id="_idParaDest-114">
    <a id="_idTextAnchor114">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before exploring how to
    
    <a id="_idIndexMarker143">
    </a>
    
     intercept and prevent default event actions, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Delegating with event callbacks
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       Extensions
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-115">
    <a id="_idTextAnchor115">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Go through the process of preventing default event actions by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      and initialize a new
     
     <strong class="source-inline">
      
       Creator
      
     </strong>
     
      variable below the
     
     
      
       existing code:
      
     
     <pre class="source-code">
internal string Creator = string.Empty;</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       Creator
      
     </strong>
     
      variable, still in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       MonitorCreation()
      
     </strong>
     
      method that intercepts a
     
     <strong class="source-inline">
      
       KeyboardEventArgs
      
     </strong>
     
      parameter, resolves its payload, and creates a new ticket instance when the user hits the
     
     <em class="italic">
      
       +
      
     </em>
     
      symbol on
     
     
      
       the keyboard:
      
     
     <pre class="source-code">
private void MonitorCreation(KeyboardEventArgs args)
{
    if (args.Key == "+")
    {
        Tickets.All.Add(new() { Title = Creator });
        Creator = string.Empty;
        return;
    }
    if (args.IsBackspace() &amp;&amp; Creator.Length &gt; 0)
    {
        Creator = Creator[..^1];
        return;
    }
    if (args.IsLetter())
    {
        Creator += args.Key;
        return;
    }
}</pre>
    </li>
    <li>
     
      Jump over to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup.
     
     
      Below the render mode declaration at the top, construct a ticket creation area by adding a section header and an input with
     
     <a id="_idIndexMarker144">
     </a>
     
      the
     
     <strong class="source-inline">
      
       MonitorCreation()
      
     </strong>
     
      method attached to its
     
     <strong class="source-inline">
      
       @onkeydown
      
     </strong>
     
      event, preventing the default
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        onkeydown
       
      </strong>
     
     
      
       behavior:
      
     
     <pre class="source-code">
&lt;h5&gt;Quick creation&lt;/h5&gt;
&lt;p&gt;
    &lt;input value="@Creator"
           @onkeydown="MonitorCreation"
           @onkeydown:preventDefault /&gt;
&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor116">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     and initialize a
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     variable that will hold the current text that the user inputs in the fast ticket creation field.
    
    
     We will construct the creation field itself in
    
    
     
      a moment.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , next to the
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     variable, we implement a
    
    <strong class="source-inline">
     
      MonitorCreation()
     
    </strong>
    
     method, where we will put the custom
    
    <strong class="source-inline">
     
      @onkeydown
     
    </strong>
    
     logic for Blazor to execute instead of the default one.
    
    
     The
    
    <strong class="source-inline">
     
      MonitorCreation()
     
    </strong>
    
     method receives a
    
    <strong class="source-inline">
     
      KeyboardEventArgs
     
    </strong>
    
     object, having a
    
    <strong class="source-inline">
     
      Key
     
    </strong>
    
     property that we need for our custom creation logic.
    
    
     First, we check whether the clicked symbol matches the
    
    <strong class="source-inline">
     
      +
     
    </strong>
    
     key and add a new
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     object to the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection.
    
    
     Next, we leverage the
    
    <strong class="source-inline">
     
      IsBackspace()
     
    </strong>
    
     extension method from the
    
    <strong class="source-inline">
     
      Extensions
     
    </strong>
    
     file provided with data samples.
    
    
     If the user clicks the backspace button and the
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     length indicates there are characters to remove, we
    
    <a id="_idIndexMarker145">
    </a>
    
     remove the last character from the
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     value using the
    
    <strong class="bold">
     
      range operator
     
    </strong>
    
     .
    
    
     Lastly, we leverage another custom extension method from the
    
    <strong class="source-inline">
     
      Extensions
     
    </strong>
    
     file –
    
    <strong class="source-inline">
     
      IsLetter()
     
    </strong>
    
     – to check whether what the user pressed on their
    
    <a id="_idIndexMarker146">
    </a>
    
     keyboard is in fact a letter and append it at the end of the current
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     value.
    
    
     With that implementation, we ignore all other keyboard actions.
    
    
     I strongly encourage you to experiment and add numbers support on
    
    
     
      your own!
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup and build a section where users can fast-create new tickets.
    
    
     We add a
    
    <strong class="bold">
     
      Quick creation
     
    </strong>
    
     header, so it’s obvious what the intention of the input below is.
    
    
     And finally, we construct the
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     field where all the event-preventing happens.
    
    
     We set the
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     value to reflect the value of
    
    <strong class="source-inline">
     
      Creator
     
    </strong>
    
     .
    
    
     Notice, that we don’t leverage any binding here (more about binding in
    
    <a href="B22020_02.xhtml#_idTextAnchor065">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     ).
    
    
     Next, we attach the
    
    <strong class="source-inline">
     
      MonitorCreation()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      @onkeydown
     
    </strong>
    
     event of the input so Blazor seamlessly triggers our custom logic.
    
    
     But
    
    <strong class="source-inline">
     
      @onkeydown
     
    </strong>
    
     has browser-default logic, conflicting with what we just attached.
    
    
     Here, we employ
    
    <strong class="source-inline">
     
      @onkeydown:preventDefault
     
    </strong>
    
     , instructing Blazor to bypass any default
    
    
     
      key-down behavior.
     
    
   </p>
   <h2 id="_idParaDest-117">
    <a id="_idTextAnchor117">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     All the events in Blazor behave virtually the same, regardless of the render mode you use.
    
    
     However, some events, like
    
    <strong class="source-inline">
     
      @onkeydown
     
    </strong>
    
     , are inherently client-side in their expected result – responding immediately to user input.
    
    
     When using
    
    <strong class="source-inline">
     
      @onkeydown
     
    </strong>
    
     in
    
    <strong class="source-inline">
     
      InteractiveServer
     
    </strong>
    
     mode, you must consider that each event trigger will travel to the server and back before it’s reflected on the UI.
    
    
     In higher-latency scenarios, this round-trip can result in flaky and unstable behavior of the UI.
    
    
     Always consider the nature of the events you’re choosing
    
    <a id="_idIndexMarker147">
    </a>
    
     and the appropriate render mode to ensure that your application
    
    
     
      remains user-friendly.
     
    
   </p>
   <p>
    
     When building an internationally available application, you may need to support special local characters that require specific key combinations, such as using
    
    <em class="italic">
     
      Alt
     
    </em>
    
     +
    
    <em class="italic">
     
      a
     
    </em>
    
     to produce the letter
    
    <strong class="bold">
     
      ą
     
    </strong>
    
     in Polish.
    
    
     To handle these cases effectively, Blazor provides the ability to manage keyboard
    
    
     
      composition events.
     
    
   </p>
   <pre class="source-code">
private void MonitorCreation(KeyboardEventArgs args)
{
    if (args.IsComposing) return;
    //rest of the processing logic obscured for simplicity
}</pre>
   <p>
    
     You can track the composition state of the input using the
    
    <strong class="source-inline">
     
      IsComposing
     
    </strong>
    
     property in
    
    <strong class="source-inline">
     
      KeyboardEventArgs
     
    </strong>
    
     .
    
    
     When
    
    <strong class="source-inline">
     
      IsComposing
     
    </strong>
    
     is set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , it indicates that the user is entering a composite character.
    
    
     You should delay processing the input until
    
    <strong class="source-inline">
     
      IsComposing
     
    </strong>
    
     returns
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       false
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-118">
    <a id="_idTextAnchor118">
    </a>
    
     Controlling event propagation
    
   </h1>
   <p>
    
     In this recipe, we explore the process of
    
    <a id="_idIndexMarker148">
    </a>
    
     controlling how events travel through the
    
    <strong class="bold">
     
      Document Object Model
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DOM
     
    </strong>
    
     ) within Blazor applications.
    
    
     Stopping
    
    <a id="_idIndexMarker149">
    </a>
    
     default event propagation becomes crucial when we work with nested components or elements.
    
    
     You can ensure events such as clicks, hovers, or keyboard inputs have localized effects – thereby avoiding unintended ripple effects or behaviors in the UI.
    
    
     By mastering the control of event propagation, you can fine-tune interaction patterns within your application, leading to a smoother and more intuitive
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     Let’s allow users to click anywhere on the ticket record to display its details while ensuring that clicking on
    
    <a id="_idIndexMarker150">
    </a>
    
     any of the nested administrative actions won’t
    
    
     
      propagate uncontrollably.
     
    
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor119">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into controlling events propagation, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Preventing default event actions
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       Extensions
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-120">
    <a id="_idTextAnchor120">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To control event propagation and see the
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     attribute in action, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup and locate the container markup that we render for each ticket.
     
     
      Next to the assignment of the
     
     <strong class="source-inline">
      
       id
      
     </strong>
     
      attribute, attach the
     
     <strong class="source-inline">
      
       Show()
      
     </strong>
     
      method to the container’s
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        onclick
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
&lt;div class="d-flex justify-content-between mb-1"
     id="ticket-@ticket.Id"
     @onclick="() =&gt; Show(ticket)"&gt;
    @* here's still the ticket container body *@
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      markup and attach the
     
     <strong class="source-inline">
      
       stopPropagation
      
     </strong>
     
      attribute to the
     
     <strong class="source-inline">
      
       @onclick
      
     </strong>
     
      event of each of the administrative
     
     
      
       action buttons:
      
     
     <pre class="source-code">
&lt;button class="btn btn-sm btn-success"
        @onclick="@OnShow"
        @onclick:stopPropagation&gt;
    Show
&lt;/button&gt;
&lt;button class="btn btn-sm btn-info"
        @onclick="@OnTopUp"
        @onclick:stopPropagation&gt;
    Top up
&lt;/button&gt;
&lt;button class="btn btn-sm btn-danger"
        @onclick="@OnRemove"
        @onclick:stopPropagation&gt;
    Remove
&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-121">
    <a id="_idTextAnchor121">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup, where we render each ticket’s details in a dedicated container.
    
    
     You’ll find the container markup inside the
    
    <strong class="source-inline">
     
      foreach
     
    </strong>
    
     loop, with the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     attribute set to
    
    <a id="_idIndexMarker151">
    </a>
    
     correspond to the current ticket ID.
    
    
     In order to allow users to display ticket details by clicking anywhere on the container, next to the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     attribute, we attached our
    
    <strong class="source-inline">
     
      Show()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event of the container.
    
    
     Now, whether users click on the
    
    <strong class="bold">
     
      Show
     
    </strong>
    
     button or anywhere inside the ticket container, Blazor will trigger the same action and render details of a
    
    
     
      given ticket.
     
    
   </p>
   <p>
    
     Now, here is the catch.
    
    
     Inside the ticket container, we have also nested the
    
    <strong class="bold">
     
      Top Up
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Remove
     
    </strong>
    
     buttons – all reacting differently to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event.
    
    
     However, nested
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     events within the same area would trigger simultaneously by default.
    
    
     In our example, when the user clicks on the
    
    <strong class="bold">
     
      Top Up
     
    </strong>
    
     button, they will both increase that ticket stock and render its details.
    
    
     With the
    
    <strong class="bold">
     
      Remove
     
    </strong>
    
     button, it gets even more confusing, as users can remove a ticket and display its details at the same time.
    
    
     That’s where we need the
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     attribute.
    
    
     Attaching
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     to a desired event, we instruct Blazor to prevent event propagation to the parent
    
    
     
      DOM element.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      TicketOptions
     
    </strong>
    
     markup, where we have all the administrative action buttons.
    
    
     Next to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     attribute of each of the three buttons, we append the
    
    <strong class="source-inline">
     
      @onclick:stopPropagation
     
    </strong>
    
     attribute.
    
    
     That’s all it takes to ensure that users can
    
    <a id="_idIndexMarker152">
    </a>
    
     safely increase the stock of the ticket or remove it entirely without experiencing unwanted rendering of the ticket
    
    
     
      details display.
     
    
   </p>
   <h2 id="_idParaDest-122">
    <a id="_idTextAnchor122">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     While the
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     attribute is a powerful tool within Blazor applications for managing event flow, it’s essential to
    
    <a id="_idIndexMarker153">
    </a>
    
     understand its scope and limitations.
    
    
     This attribute is specifically designed to work with Blazor events and does not directly influence the behavior of standard HTML events.
    
    
     HTML events must first be allowed to execute normally; only then can Blazor intercept these events and make decisions regarding event propagation from child components to
    
    
     
      their parents.
     
    
   </p>
   <p>
    
     In our implementation, we focused on controlling the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event, but when dealing with complex interfaces where you need to control multiple events,
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     must be explicit for
    
    
     
      each event.
     
    
   </p>
   <p>
    
     Additionally, when incorporating components from external libraries into your Blazor applications, you might encounter situations where direct control over event propagation is not straightforward.
    
    
     In such cases, a practical workaround is to wrap the external component within a neutral HTML element, for example, a
    
    <strong class="source-inline">
     
      span
     
    </strong>
    
     element.
    
    
     By applying
    
    <strong class="source-inline">
     
      stopPropagation
     
    </strong>
    
     to events on
    
    <strong class="source-inline">
     
      span
     
    </strong>
    
     , you effectively create a barrier for event propagation, with
    
    <strong class="source-inline">
     
      span
     
    </strong>
    
     acting as the nearest parent.
    
    
     This method allows you to manage event flow even in complex component hierarchies, ensuring intended behavior without unintended side
    
    <a id="_idIndexMarker154">
    </a>
    
     effects from
    
    
     
      external components.
     
    
   </p>
   <h1 id="_idParaDest-123">
    <a id="_idTextAnchor123">
    </a>
    
     Introducing custom events
    
   </h1>
   <p>
    
     In this recipe, we explore the possibility of enriching our Blazor application with custom events, diving into slightly more advanced territory where
    
    <strong class="bold">
     
      JavaScript
     
    </strong>
    
     interplays with Blazor.
    
    
     Alongside custom events, the
    
    <a id="_idIndexMarker155">
    </a>
    
     concept of custom event arguments arises, allowing for the passage of tailored data that goes beyond the standard event payloads.
    
    
     Custom events and their corresponding arguments become invaluable when predefined events fall short, offering the flexibility to capture and respond to specific user actions or external system triggers
    
    
     
      with precision.
     
    
   </p>
   <p>
    
     Let’s implement a component that overwrites the data that a user tries to copy from the area that this
    
    
     
      component protects.
     
    
   </p>
   <h2 id="_idParaDest-124">
    <a id="_idTextAnchor124">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore the
    
    <a id="_idIndexMarker156">
    </a>
    
     implementation of custom events, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Controlling event propagation
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       Extensions
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-125">
    <a id="_idTextAnchor125">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to implement custom logic for a
    
    
     
      copy event:
     
    
   </p>
   <ol>
    <li>
     
      Add a new JavaScript (
     
     <strong class="source-inline">
      
       .js
      
     </strong>
     
      ) file to the application’s wwwroot directory.
     
     
      Adhere to the naming convention,
     
     <strong class="source-inline">
      
       {ASSEMBLY NAME}.lib.module.js
      
     </strong>
     
      .
     
     
      This file will contain the functions necessary for our
     
     
      
       custom events.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript functions" src="img/Figure_3.1_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript functions
    
   </p>
   <ol>
    <li value="2">
     
      Inside your newly created
     
     <strong class="source-inline">
      
       .js
      
     </strong>
     
      file, declare an
     
     <strong class="source-inline">
      
       afterWebStarted()
      
     </strong>
     
      function.
     
     
      Use the
     
     <strong class="source-inline">
      
       registerCustomEventType
      
     </strong>
     
      API to declare a new
     
     <strong class="source-inline">
      
       preventcopy
      
     </strong>
     
      event.
     
     
      Implement
     
     <a id="_idIndexMarker157">
     </a>
     
      custom logic within this event to overwrite the current
     
     
      
       clipboard data:
      
     
     <pre class="source-code">
export function afterWebStarted(blazor) {
    blazor.registerCustomEventType('preventcopy', {
        browserEventName: 'copy',
        createEventArgs: event =&gt; {
            event.clipboardData.setData('text/plain',
                '-------');
            event.preventDefault();
            return {
                stamp: new Date()
            };
        }
    });
}</pre>
    </li>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       CustomEvents.cs
      
     </strong>
     
      file that will serve as a central repository for all details related to
     
     
      
       custom events.
      
     
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       CustomEvents.cs
      
     </strong>
     
      , add a
     
     <a id="_idIndexMarker158">
     </a>
     
      class named
     
     <strong class="source-inline">
      
       PreventedCopyEventArgs
      
     </strong>
     
      that extends
     
     <strong class="source-inline">
      
       EventArgs
      
     </strong>
     
      .
     
     
      Include a
     
     <strong class="source-inline">
      
       Stamp
      
     </strong>
     
      property to persist when Blazor prevents the
     
     
      
       copy action:
      
     
     <pre class="source-code">
public class PreventedCopyEventArgs : EventArgs
{
    public DateTime Stamp { get; init; }
}</pre>
    </li>
    <li>
     
      Still within
     
     <strong class="source-inline">
      
       CustomEvents.cs
      
     </strong>
     
      , declare a
     
     <strong class="source-inline">
      
       public
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       static
      
     </strong>
     
      class named
     
     <strong class="source-inline">
      
       EventHandlers
      
     </strong>
     
      .
     
     
      Add a custom
     
     <strong class="source-inline">
      
       EventHandler
      
     </strong>
     
      attribute to this class and define an
     
     <strong class="source-inline">
      
       onpreventcopy
      
     </strong>
     
      event that
     
     
      
       returns
      
     
     
      <strong class="source-inline">
       
        PreventedCopyEventArgs
       
      </strong>
     
     
      
       .
      
     
     <pre class="source-code">
[EventHandler("onpreventcopy",
    typeof(PreventedCopyEventArgs))]
public static class EventHandlers { }</pre>
    </li>
    <li>
     
      Add a new
     
     <strong class="source-inline">
      
       PreventCopy
      
     </strong>
     
      component responsible for invoking the custom event logic
     
     
      
       you’ve defined.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section of the
     
     <strong class="source-inline">
      
       PreventCopy
      
     </strong>
     
      component, declare a required
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      parameter of type
     
     <strong class="source-inline">
      
       RenderFragment
      
     </strong>
     
      .
     
     
      Also, implement a
     
     <strong class="source-inline">
      
       Log()
      
     </strong>
     
      method to intercept and log the timestamp that
     
     
      <strong class="source-inline">
       
        PreventedCopyEventArgs
       
      </strong>
     
     
      
       carries:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; }
    private void Log(PreventedCopyEventArgs args)
        =&gt; Console.WriteLine(
            $"Prevented data leak at {args.Stamp}
                UTC.");
}</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       PreventCopy
      
     </strong>
     
      markup, construct a wrapping container, where you intercept the custom
     
     <strong class="source-inline">
      
       @onpreventcopy
      
     </strong>
     
      event and delegate it to the
     
     <strong class="source-inline">
      
       Log()
      
     </strong>
     
      method, while
     
     <a id="_idIndexMarker159">
     </a>
     
      rendering
     
     
      <strong class="source-inline">
       
        ChildContent
       
      </strong>
     
     
      
       inside:
      
     
     <pre class="source-code">
&lt;div @onpreventcopy="@Log"&gt;
     @ChildContent
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, locate the area where we render the
     
     <strong class="source-inline">
      
       SelectedTicket
      
     </strong>
     
      details, and wrap it with the
     
     
      <strong class="source-inline">
       
        PreventCopy
       
      </strong>
     
     
      
       tags:
      
     
     <pre class="source-code">
&lt;PreventCopy&gt;
    &lt;div&gt;Title: @SelectedTicket.Title&lt;/div&gt;
    &lt;div&gt;Price: @SelectedTicket.Price&lt;/div&gt;
    &lt;div&gt;Stock: @SelectedTicket.Stock&lt;/div&gt;
&lt;/PreventCopy&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-126">
    <a id="_idTextAnchor126">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We kick off the integration of a custom event by establishing a bridge between Blazor and JavaScript.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we add a
    
    <strong class="source-inline">
     
      .js
     
    </strong>
    
     file within the
    
    <strong class="source-inline">
     
      wwwroot
     
    </strong>
    
     directory, adhering to a specific naming convention (
    
    <strong class="source-inline">
     
      {ASSEMBLY NAME}.lib.module.js
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      {PACKAGE ID}.lib.module.js
     
    </strong>
    
     ).
    
    
     This convention is crucial as Blazor automatically searches for these files to support custom events defined within the application.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we define an
    
    <strong class="source-inline">
     
      afterWebStarted()
     
    </strong>
    
     function, which takes a
    
    <strong class="source-inline">
     
      blazor
     
    </strong>
    
     argument (intentionally lowercase to differentiate from the globally available
    
    <strong class="source-inline">
     
      Blazor
     
    </strong>
    
     object) and which Blazor compilers expect.
    
    
     Using the
    
    <strong class="source-inline">
     
      registerCustomEventType
     
    </strong>
    
     API, we declare our
    
    <strong class="source-inline">
     
      preventcopy
     
    </strong>
    
     event, designed to intercept the browser’s
    
    <strong class="source-inline">
     
      copy
     
    </strong>
    
     event and overwrite clipboard data.
    
    
     While at it, we must also cancel the browser’s default copy behavior using the
    
    <strong class="source-inline">
     
      preventDefault()
     
    </strong>
    
     method.
    
    
     We return a timestamp marking the event trigger that we will
    
    
     
      utilize later.
     
    
   </p>
   <p>
    
     Transitioning to Blazor in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we introduce the
    
    <strong class="source-inline">
     
      CustomEvents.cs
     
    </strong>
    
     file to define our Blazor-side custom event handling.
    
    
     We implement the
    
    <strong class="source-inline">
     
      PreventedCopyEventArgs
     
    </strong>
    
     class in
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , inheriting from
    
    <strong class="source-inline">
     
      EventArgs
     
    </strong>
    
     and reflecting our JavaScript function’s structure, including a
    
    <strong class="source-inline">
     
      Stamp
     
    </strong>
    
     property.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we register a Blazor custom event using the Razor compiler’s capabilities.
    
    
     Following the code generators convention, we declare
    
    <strong class="source-inline">
     
      public static class EventHandlers
     
    </strong>
    
     and leverage the
    
    <strong class="source-inline">
     
      [EventHandler]
     
    </strong>
    
     attribute to inform the Razor compiler of our custom
    
    <strong class="source-inline">
     
      onpreventcopy
     
    </strong>
    
     event.
    
    
     The Razor compiler will automatically align
    
    <strong class="source-inline">
     
      onpreventcopy
     
    </strong>
    
     with its JavaScript counterpart –
    
    
     <strong class="source-inline">
      
       preventcopy
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Next, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we add
    
    <a id="_idIndexMarker160">
    </a>
    
     a
    
    <strong class="source-inline">
     
      PreventCopy
     
    </strong>
    
     component as a wrapper preventing copy operations within specified content.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      PreventCopy
     
    </strong>
    
     , we declare a
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     parameter, where we can provide content to be protected and a primitive
    
    <strong class="source-inline">
     
      Log()
     
    </strong>
    
     method to log the timestamp of a prevented copy attempt.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we construct the
    
    <strong class="source-inline">
     
      PreventCopy
     
    </strong>
    
     markup.
    
    
     We add a container and intercept the
    
    <strong class="source-inline">
     
      @onpreventcopy
     
    </strong>
    
     event while also invoking the
    
    <strong class="source-inline">
     
      Log()
     
    </strong>
    
     method every time it’s triggered.
    
    
     Inside the container, we render the provided
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     markup.
    
    
     Now, Blazor will effectively prevent data leakage while maintaining an audit trail of any data
    
    
     
      copy attempts.
     
    
   </p>
   <h2 id="_idParaDest-127">
    <a id="_idTextAnchor127">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     While the
    
    <strong class="source-inline">
     
      afterWebStarted()
     
    </strong>
    
     function is crucial in integrating custom events within a
    
    <strong class="bold">
     
      Blazor Web App
     
    </strong>
    
     , it’s important to note that it’s designed specifically for this environment.
    
    
     When working outside
    
    <a id="_idIndexMarker161">
    </a>
    
     the Blazor Web App context, an analogous approach is required but with a slight adjustment in the function naming.
    
    
     For plain server or WebAssembly projects, you must implement the
    
    <strong class="source-inline">
     
      afterStarted()
     
    </strong>
    
     function.
    
    
     This naming distinction allows us to clearly define when Blazor registers custom events and ensures clarity in the
    
    
     
      application’s lifecycle.
     
    
   </p>
   <h1 id="_idParaDest-128">
    <a id="_idTextAnchor128">
    </a>
    
     Handling long-running events
    
   </h1>
   <p>
    
     In this recipe, we tackle a critical aspect of
    
    <strong class="bold">
     
      single-page application
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SPA
     
    </strong>
    
     ) development – ensuring users are aware
    
    <a id="_idIndexMarker162">
    </a>
    
     of operations occurring in the background.
    
    
     Unlike traditional web applications, SPAs do not naturally indicate when a process is executing behind the scenes.
    
    
     This lack of feedback can leave users staring at what appears to be a stale or unresponsive page, leading to frustration and confusion.
    
    
     It’s essential that you incorporate visual action indicators such as preloaders, loading spinners, or progress bars.
    
    
     These
    
    <a id="_idIndexMarker163">
    </a>
    
     elements serve as visual cues that inform the user something is happening, enhancing the user experience by providing a sense of activity and progress.
    
    
     I will guide you through implementing these indicators in your SPA, ensuring that during long-running requests or operations, your users are kept in the loop, maintaining engagement and satisfaction with
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Let’s implement two kinds of action indicators – a simple loading indicator and a primitive
    
    
     
      progress indicator.
     
    
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor129">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before starting the implementation of user-friendly status indicators, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       TicketOptions
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       PreventCopy
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       CustomEvents
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Introducing custom events
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Tickets
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       Extensions
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor130">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To build loading and progress indicators that improve the user experience of your app, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       LoadingIndicator
      
     </strong>
     
      component that will visually communicate to users when an operation
     
     
      
       is loading.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       LoadingIndicator
      
     </strong>
     
      , declare a
     
     <strong class="source-inline">
      
       Job
      
     </strong>
     
      parameter – representing the task to display the loading state for, and a
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      parameter to allow passing the content to render when loading
     
     
      
       is complete:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public Func&lt;Task&gt; Job { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; }
}</pre>
    </li>
    <li>
     
      Below the parameter declaration, still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, initialize an
     
     <strong class="source-inline">
      
       IsLoading
      
     </strong>
     
      state variable
     
     <a id="_idIndexMarker164">
     </a>
     
      and implement a
     
     <strong class="source-inline">
      
       RunAsync()
      
     </strong>
     
      method, which encapsulates the logic for managing the loading state while executing the
     
     
      <strong class="source-inline">
       
        Job
       
      </strong>
     
     
      
       delegate:
      
     
     <pre class="source-code">
internal bool IsLoading;
private async Task RunAsync()
{
    IsLoading = true;
    StateHasChanged();
    await Job.Invoke();
    IsLoading = false;
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       LoadingIndicator
      
     </strong>
     
      markup, add a button for users to initiate the loading process by attaching the
     
     <strong class="source-inline">
      
       RunAsync()
      
     </strong>
     
      method to the button’s
     
     <strong class="source-inline">
      
       @onclick
      
     </strong>
     
      event and conditionally disabling it while loading is
     
     
      
       in progress:
      
     
     <pre class="source-code">
&lt;button class="btn btn-sm btn-success"
        @onclick="@RunAsync"
        disabled="@IsLoading"&gt;
    Load
&lt;/button&gt;</pre>
    </li>
    <li>
     
      Below the loading button, construct
     
     <a id="_idIndexMarker165">
     </a>
     
      two areas – for when the loading is in progress and when it completes, based on the value of the
     
     <strong class="source-inline">
      
       IsLoading
      
     </strong>
     
      
       state variable:
      
     
     <pre class="source-code">
@if (IsLoading)
{
    &lt;hr /&gt;
    &lt;p&gt;Loading...&lt;/p&gt;
}
else
{
    @ChildContent
}</pre>
    </li>
    <li>
     
      Create another component –
     
     <strong class="source-inline">
      
       ProgressIndicator
      
     </strong>
     
      – that will visually communicate to users the progress of the operation
     
     
      
       they request.
      
     
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       ProgressIndicator
      
     </strong>
     
      , declare two required parameters: a
     
     <strong class="source-inline">
      
       Job
      
     </strong>
     
      parameter – representing an abstract operation the progress indicator should monitor, and a
     
     <strong class="source-inline">
      
       Total
      
     </strong>
     
      parameter – to provide the number of elements the operation should
     
     
      
       run for:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public Func&lt;int, Task&gt; Job { get; set; }
    [Parameter, EditorRequired]
    public int Total { get; set; }
}</pre>
    </li>
    <li>
     
      Below the parameter declaration, initialize a
     
     <strong class="source-inline">
      
       Progress
      
     </strong>
     
      state variable to reflect the
     
     
      
       operation’s progress:
      
     
     <pre class="source-code">
internal double Progress = 0;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement an expression-bodied
     
     <strong class="source-inline">
      
       Label
      
     </strong>
     
      property, where based on the
     
     <strong class="source-inline">
      
       Progress
      
     </strong>
     
      value, you construct a label for the action button (which we
     
     <a id="_idIndexMarker166">
     </a>
     
      will
     
     
      
       add shortly):
      
     
     <pre class="source-code">
private string Label
    =&gt; Progress &gt; 0 ? $"Processing {Progress:0%}"
                    : "Process";</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block by implementing a
     
     <strong class="source-inline">
      
       RunAsync()
      
     </strong>
     
      method to loop through the total amount of elements and execute the job for
     
     
      
       each index:
      
     
     <pre class="source-code">
private async Task RunAsync()
{
    for (int i = 0; i &lt; Total; i++)
    {
        Progress = 1.0 * (1 + i) / Total;
        StateHasChanged();
        await Job.Invoke(i);
    }
    Progress = 0;
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       ProgressIndicator
      
     </strong>
     
      markup, construct a button for users to invoke the processing through the
     
     <strong class="source-inline">
      
       RunAsync()
      
     </strong>
     
      method.
     
     
      Check the current value of the
     
     <strong class="source-inline">
      
       Progress
      
     </strong>
     
      variable to conditionally disable the action button and leverage the
     
     <strong class="source-inline">
      
       Label
      
     </strong>
     
      property to generate the button
     
     
      
       label dynamically:
      
     
     <pre class="source-code">
&lt;button class="btn btn-sm btn-success"
        @onclick="@RunAsync"
        disabled="@(Progress &gt; 0)"&gt;
    @Label
&lt;/button&gt;</pre>
    </li>
    <li>
     
      Navigate to
     
     <a id="_idIndexMarker167">
     </a>
     
      the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component, to its
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, and implement a simple
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method, leveraging
     
     <strong class="source-inline">
      
       Tickets.SaveAsync()
      
     </strong>
     
      provided with
     
     
      
       data samples:
      
     
     <pre class="source-code">
public Task SaveAsync(int index)
    =&gt; Tickets.SaveAsync(Tickets.All[index]);</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, below the render mode declaration, embed
     
     <strong class="source-inline">
      
       ProgressIndicator
      
     </strong>
     
      with
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Tickets.All.Count
      
     </strong>
     
      attached to the
     
     <strong class="source-inline">
      
       Job
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Total
      
     </strong>
     
      
       parameters respectively:
      
     
     <pre class="source-code">
&lt;ProgressIndicator Job="SaveAsync" Total="@Tickets.All.Count" /&gt;</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, remove the button allowing to toggle tickets and the
     
     
      <strong class="source-inline">
       
        ShowTickets
       
      </strong>
     
     
      
       check.
      
     
    </li>
    <li>
     
      Now, in the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, find the
     
     <strong class="source-inline">
      
       foreach
      
     </strong>
     
      loop, where you render each ticket container, and wrap it inside the
     
     <strong class="source-inline">
      
       LoadingIndicator
      
     </strong>
     
      component.
     
     
      Attach the
     
     <strong class="source-inline">
      
       Tickets.GetAsync()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       Job
      
     </strong>
     
      parameter that
     
     
      <strong class="source-inline">
       
        LoadingIndicator
       
      </strong>
     
     
      
       requires:
      
     
     <pre class="source-code">
&lt;LoadingIndicator Job="@(() =&gt; Tickets.GetAsync())"&gt;
    &lt;hr /&gt;
    @foreach (var ticket in Tickets.All)
    {
        @* here's still the ticket container markup *@
    }
&lt;/LoadingIndicator&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor131">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a new
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     component and declare two key parameters:
    
    <strong class="source-inline">
     
      Func&lt;Task&gt; Job
     
    </strong>
    
     to reference the asynchronous operation we intend to monitor, and
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     to allow passing the content to display when loading completes.
    
    
     Both parameters are designed to be operation-agnostic, making the component versatile and adaptable to various use cases.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initialize an
    
    <strong class="source-inline">
     
      IsLoading
     
    </strong>
    
     state variable and implement the core functionality in the
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     method.
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     updates the
    
    <strong class="source-inline">
     
      IsLoading
     
    </strong>
    
     value to reflect the operation’s start, executes the declared
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     delegate, and then resets
    
    <strong class="source-inline">
     
      IsLoading
     
    </strong>
    
     upon completion, seamlessly transitioning to display
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     .
    
    
     Notice that we’ve invoked the
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     lifecycle
    
    <a id="_idIndexMarker168">
    </a>
    
     method, before starting the
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     operation.
    
    
     With that implementation, the moment Blazor reaches an asynchronous operation, and frees up the UI thread, it will re-render the component markup, reflecting the state changes based on the
    
    <strong class="source-inline">
     
      IsLoading
     
    </strong>
    
     value.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we build the
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     markup.
    
    
     First, we construct an action button for initiating the load process with the help of
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     .
    
    
     We also attach the
    
    <strong class="source-inline">
     
      disabled
     
    </strong>
    
     button’s attribute to the value of the
    
    <strong class="source-inline">
     
      IsLoading
     
    </strong>
    
     state variable.
    
    
     Now, whenever loading is in progress, Blazor will disable the action button, effectively preventing users from requeuing the already running operation.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we add the visual loading indicator.
    
    
     During operation execution, we render a simple
    
    <strong class="bold">
     
      Loading...
     
    </strong>
    
     message, which you can enhance with CSS for a modern look, such as incorporating a spinner.
    
    
     When loading completes, we render the markup provided with the
    
    
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we create a component with a different type of indicator –
    
    <strong class="source-inline">
     
      ProgressIndicator
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block and define a
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     parameter – allowing us to define an operation to run – and a
    
    <strong class="source-inline">
     
      Total
     
    </strong>
    
     parameter – representing the number of iterations the operation must go through.
    
    
     The
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     signature effectively abstracts any asynchronous operation but also ensures that the operation accepts an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     parameter, representing the index of the current execution iteration.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we initialize a
    
    <strong class="source-inline">
     
      Progress
     
    </strong>
    
     variable that we’ll use to monitor the actual execution progress from 0% to 100%.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     property.
    
    
     With simple logic, based on the current
    
    <strong class="source-inline">
     
      Progress
     
    </strong>
    
     value, we generate either a
    
    <strong class="bold">
     
      Process
     
    </strong>
    
     call to action or actual processing progress.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block by implementing the core
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     method.
    
    
     In
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     , we loop from
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      Total
     
    </strong>
    
     and invoke the
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     delegate for each index while continuously updating the
    
    <strong class="source-inline">
     
      Progress
     
    </strong>
    
     value.
    
    
     When the processing is done, we reset the
    
    <strong class="source-inline">
     
      Progress
     
    </strong>
    
     value to a neutral
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we build the
    
    <strong class="source-inline">
     
      ProgressIndicator
     
    </strong>
    
     markup.
    
    
     We construct a button allowing us to start the processing by triggering
    
    <strong class="source-inline">
     
      RunAsync()
     
    </strong>
    
     on the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event.
    
    
     We also prevent the requeuing of the running operation by disabling the action button based on the
    
    <strong class="source-inline">
     
      Progress
     
    </strong>
    
     value, similar to the action button in the
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     component.
    
    
     Lastly, to provide real-time progress feedback, we leverage the
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     property to
    
    <a id="_idIndexMarker169">
    </a>
    
     render the text on the button.
    
    
     Now, when the operation is running, Blazor will not only disable the button but also render the current progress
    
    
     
      on it.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component and implement a
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method.
    
    
     The
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method is just a proxy method that allows intercepting the current iteration index, finding the related ticket object in the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection, and passing it over for saving.
    
    
     In
    
    <em class="italic">
     
      step 13
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup and, at the very top, we embed
    
    <strong class="source-inline">
     
      ProgressIndicator
     
    </strong>
    
     .
    
    
     Having the
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method in place, we can attach it to the
    
    <strong class="source-inline">
     
      ProgressIndicator
     
    </strong>
    
     component required
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     parameter.
    
    
     For the other required parameter –
    
    <strong class="source-inline">
     
      Total
     
    </strong>
    
     – we count the number of objects in the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection.
    
    
     With that setup,
    
    <strong class="source-inline">
     
      ProgressIndicator
     
    </strong>
    
     allows users to trigger the saving of each ticket and see the operation progress as it’s running.
    
    
     In
    
    <em class="italic">
     
      step 14
     
    </em>
    
     , we remove the button allowing to toggle tickets and the related
    
    <strong class="source-inline">
     
      ShowTickets
     
    </strong>
    
     check.
    
    
     We will no longer need them, as we will delegate the control over displaying the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     collection to
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 15
     
    </em>
    
     , we locate the loop in which we render ticket containers.
    
    
     We wrap that entire area inside the
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     component.
    
    
     As
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     requires a
    
    <strong class="source-inline">
     
      Job
     
    </strong>
    
     delegate, we leverage a lambda expression and attach the
    
    <strong class="source-inline">
     
      Tickets.GetAsync()
     
    </strong>
    
     method.
    
    
     Now, when users request to load data,
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     renders the
    
    <strong class="bold">
     
      Loading…
     
    </strong>
    
     message and triggers
    
    <strong class="source-inline">
     
      Tickets.GetAsync()
     
    </strong>
    
     seamlessly.
    
    
     When loading completes, the
    
    <strong class="source-inline">
     
      LoadingIndicator
     
    </strong>
    
     component updates the UI with a fresh set of
    
    
     
      ticket containers.
     
    
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor132">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     You might have already realized
    
    <a id="_idIndexMarker170">
    </a>
    
     which scenarios the loading and progress indicators fit but let me give you a simple rule
    
    
     
      of thumb.
     
    
   </p>
   <p>
    
     Any loading indicators are ideally suited for operations with unpredictable completion times, such as fetching data from an API, where the number of results and their arrival time
    
    
     
      are unknown.
     
    
   </p>
   <p>
    
     Progress indicators, such as a progress bar, are ideal for operations with known results, such as submitting data changes or
    
    
     
      sending notifications.
     
    
   </p>
  </div>
 </body></html>