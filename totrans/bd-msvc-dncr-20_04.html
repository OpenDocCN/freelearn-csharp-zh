<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing Microservices</h1>
                </header>
            
            <article>
                
<p>Quality assurance, or testing, is a great way to assess a system, program, or an application with different aspects. Sometimes, a system requires testing to identify erroneous code, on other occasions we may need it to assess our system's business compliance. Testing can vary from system to system and can be considerably different depending on the architectural style of the application. Everything depends on how we are strategizing our testing approach or plan. For example, testing a monolith .NET application is different to testing SOA or microservices. In this chapter, we will cover these topics:</p>
<ul>
<li>How to test microservices</li>
<li>Handling challenges</li>
<li>Testing strategies</li>
<li>The testing pyramid</li>
<li>Types of microservice tests</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to test microservices</h1>
                </header>
            
            <article>
                
<p>Testing microservices can be a challenging job, as it is different from how we test applications built using the traditional architectural style. Testing a .NET monolithic application is a bit easier than testing a microservice, which provides implementation independence and short delivery cycles.</p>
<p>Let's understand it in the context of our .NET monolithic application, where we did not utilize continuous integration and deployment. It becomes more complex when testing is combined with continuous integration and deployment. For microservices, we are required to understand the tests for every service and how these tests differ from each other. Also, note that automated testing does not mean that we will not perform any manual testing at all.</p>
<p>Here are a few things that make microservice testing a complex and challenging task:</p>
<ul>
<li>Microservices might have multiple services that work together or individually for an enterprise system, so they can be complex.</li>
<li>Microservices are meant to target multiple clients; hence, they involve more complex use cases.</li>
<li>Each component/service of the microservice architectural style is isolated and independent, so it is a bit complex to test them as they need to be tested individually and as a complete system.</li>
<li>There might be independent teams working on separate components/services that might be required to interact with each other. Therefore, tests should cover not only internal services but also external services. This makes the job of testing microservices more challenging and complex.</li>
<li>Each component/service in a microservice is designed to work independently, but they might have to access common/shared data where each service is responsible for modifying its own database. So, testing microservices is going to be more complex as services need to access data using API calls to other services, which further adds dependencies to other services. This type of testing will have to be handled using mock tests.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling challenges</h1>
                </header>
            
            <article>
                
<p>In the previous section, we discussed how testing a microservice is a complex and challenging job. In this section, we will discuss some points that will indicate how conducting various tests could help us overcome these challenges:</p>
<ul>
<li>A unit test framework, such as Microsoft Unit Testing Framework, provides a facility to test individual operations of independent components. To ensure that all the tests pass and that a new functionality or change does not break anything (if any functionality breaks down, then the related unit test would fail), these tests can be run on every compilation of code.</li>
<li>To make sure that responses are consistent with the expectations of the clients or consumers, consumer-driven contract testing can be used.</li>
<li>Services use data from an external party or from other services, and they can be tested by setting up the endpoint of the services that are responsible for handling the data. Then we can use a mocking framework or library such as <kbd>moq</kbd> to mock these endpoints during the integration process.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing strategies (testing approach)</h1>
                </header>
            
            <article>
                
<p>As mentioned in the <em>Prerequisites</em> section of <em>Chapter 1, An Introduction to Microservices</em>, deployment and QA requirements can become more demanding. The only way to effectively handle this scenario would be through preemptive planning. I have always favored the inclusion of the QA team during the early requirement gathering and design phase. In the case of microservices, it becomes a necessity to have a close collaboration between the architecture group and the QA group. Not only will the QA team's input be helpful, but they will be able to draw up a strategy to test the microservices effectively.</p>
<p>Test strategies are merely a map or outlined plan that describes the complete approach of testing.</p>
<p>Different systems require different testing approaches. It is not possible to implement a pure testing approach to a system that is developed using a newer approach rather than the earlier developed system. Testing strategies should be clear to everyone so that the created tests can help non-technical members of the team (such as stakeholders) understand how the system is working. Such tests can be automated, simply testing the business flow, or they could be manual tests, which can be simply performed by a user working on the User Acceptance Testing system.</p>
<p>Testing strategies or approaches have the following techniques:</p>
<ul>
<li>Proactive: This is a kind of early approach and tries to fix defects before the build is created from the initial test designs</li>
<li>Reactive: In this approach, testing is started once coding is completed</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing pyramid</h1>
                </header>
            
            <article>
                
<p>The testing pyramid is a strategy or a way to define what you should test in microservices. In other words, we can say it helps us define the testing scope of microservices. The concept of the testing pyramid was originated by Mike Cohn (<a href="http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid</a>) in 2009. There are various flavors of the testing pyramid; different authors have described this by indicating how they had placed or prioritized their testing scope. The following image depicts the same concept that was defined by Mike Cohn:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="268" src="assets/d7179b98-8b5e-4876-b699-9b7481169763.png" width="254"/></div>
<p>The<strong> Testing pyramid</strong> showcases how a well-designed test strategy is structured. When we look closely at it, we can easily see how we should follow the testing approach for microservices (note that the testing pyramid is not specific to microservices). Let's start from the bottom of this pyramid. We can see that the testing scope is limited to the use of <strong>Unit tests</strong>. As soon as we move to the top, our testing scope is expanded into a broader scope where we can perform complete system testing.</p>
<p>Let's talk about these layers in detail (bottom-to-top approach):</p>
<ul>
<li><strong>Unit tests</strong>: These are tests that test small functionalities of an application based on the microservice architectural style</li>
<li><strong>Service tests</strong>: These are tests that test an independent service or a service that communicates with another/external service</li>
<li><strong>System tests</strong>: These are tests that help in testing an entire system with an aspect of the user interface. These are end-to-end tests</li>
</ul>
<p>One interesting point in this concept is that the top-layered tests, that is, system tests, are slow and expensive to write and maintain. On the other hand, the bottom-layered tests, that is, unit tests, are comparatively fast and less expensive.</p>
<p>In the upcoming sections, we will discuss these tests in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of microservice tests</h1>
                </header>
            
            <article>
                
<p>In the previous section, we discussed test approaches or testing strategies. These strategies decide how we will proceed with the testing of the system. In this section, we will discuss various types of microservice testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>Unit tests are tests that typically test a single function call to ensure that the smallest piece of the program is tested. So these tests are meant to verify specific functionality without considering other components:</p>
<ul>
<li>Testing will be more complex when components are broken down into small, independent pieces that are supposed to be tested independently. Here, testing strategies come in handy and ensure that the best quality assurance of a system will be performed. It adds more power when it comes with the <strong>Test-Driven Development</strong> (<strong>TDD</strong>) approach. We will discuss this with the help of an example in <em>Unit tests</em> which is a sub-section of <em>Tests in Action</em>.</li>
</ul>
<div class="packt_infobox">You can learn and practice TDD with the help of Katas at <a href="https://github.com/garora/TDD-Katas">https://github.com/garora/TDD-Katas</a></div>
<ul>
<li>Unit tests can be of any size; there is no definite size for a unit test. Generally, these tests are written at the class level.</li>
<li>Smaller unit tests are good for testing every possible functionality of a complex system.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component (service) testing</h1>
                </header>
            
            <article>
                
<p>Component or service testing is a method where we bypass the UI and directly test the API (in our case, the ASP.NET Core Web API). Using this test, we confirm that an individual service does not have any code bugs and that it is working fine functionality-wise.</p>
<p>Testing a service does not mean it is an independent service. This service might be interacting with an external service. In such a scenario, we should not call the actual service but use the mock and stub approach. The reason for this is our motto: to test code and make sure it is bug-free. In our case, we will use the <kbd>moq</kbd> framework for mocking our services.</p>
<p>There are a few things worth noting for component or service testing:</p>
<ul>
<li>As we need to verify the functionality of the services, these kinds of tests should be small and fast</li>
<li>With the help of mocking, we don't need to deal with the actual database; therefore, test execution time is less or nominally higher</li>
<li>The scope of these tests is broader than unit tests</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integration testing</h1>
                </header>
            
            <article>
                
<p>In unit testing, we test a single unit of code. In component or service testing, we test mock services depending on an external or third-party component. But integration testing in microservices can be a bit challenging, as in this type of testing we test components that work together. Service calls here should be made that integrate with external services. In this test strategy, we make sure that the system is working together correctly and the behavior of services is as expected. In our case, we have various microservices and some of them depend upon external services.</p>
<p>For example, StockService depends upon OrderService in a way that a particular number of items is reduced from the stock as soon as the customer successfully orders that specific item. In this scenario, when we test StockService, we should mock OrderService. Our motto should be to test StockService and not communicate with OrderService. We do not test the database of any service directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contract testing</h1>
                </header>
            
            <article>
                
<p>Contract testing is an approach where each service call independently verifies the response. If any service is dependent then dependencies are stubbed. This way, the service functions without interacting with any other service. This is an integration test that allows us to check the contract of external services. Here we come to a concept called the consumer-driven contract (we will discuss this in detail in the following section).</p>
<p>For example, CustomerService allows new customers to register with the FlixOne Store. We do not store new customers' data in our database. We verify customer data before this to check for blacklisting or fraud user listing and so on. This process calls an external service that is maintained by another team or entirely by a third-party. Out tests will still pass if someone changes the contract of this external service because this change would not affect our test, as we stubbed the contract of this external service.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consumer-driven contracts</h1>
                </header>
            
            <article>
                
<p>In microservices, we have several services that are independent or services that require communication with each other. Apart from this, from a user's (here, the user is a developer, who is consuming the API being referred to) point of view, they know about the service and whether it has, or doesn't have, several clients/consumers/users. These clients can have the same or different needs.</p>
<p>Consumer-driven contracts refer to a pattern that specifies and verifies all the interactions between clients/consumers and the API owner (application). So here, consumer-driven means that the client/consumer specifies what kind of interactions it is asking for with the defined format. On the other hand, the API owner (application services) must then agree to these contracts and ensure that they are not breaking them:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="100" src="assets/dfe6dbe5-454f-4ff7-ac5c-f5157537d6b9.png" width="364"/></div>
<p>These are the contracts:</p>
<ul>
<li>Provider contract: This is merely a complete description of the service provided by the API owner (application). Swagger's documentation can be used for our REST API (web API).</li>
<li>Consumer contract: This is a description of how consumers/clients are going to utilize the provider contract.</li>
<li>Consumer-driven contract: This is a description of how the API owner satisfies consumer/client contracts.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to implement a consumer-driven test</h1>
                </header>
            
            <article>
                
<p>In the case of microservices, it's a bit more challenging to implement a consumer-driven test than for a .NET monolithic application. This is because, in monolithic applications, we can directly use any unit test framework, such as MS tests or NUnit, but we can't do this directly in the microservice architecture. In microservices, we would need to mock not only method calls but also the services themselves, which get called via either HTTP or HTTPs.</p>
<p>To implement a consumer-driven test, there are tools available that will help. One famous open source tool for a .NET framework is <em>PactNe</em>t (<a href="https://github.com/SEEK-Jobs/pact-net">https://github.com/SEEK-Jobs/pact-net</a>) and another for .NET Core is <em>Pact.Net Core</em> <span>(</span><a href="https://github.com/garora/pact-net-core">https://github.com/garora/pact-net-core</a><span>). These are </span>based on <em>Pact</em> (<a href="https://docs.pact.io/">https://docs.pact.io/</a>) standards. We will see consumer-driven contract testing in action at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Pact-net-core helps us achieve our goal</h1>
                </header>
            
            <article>
                
<p>In a consumer-driven test, our goal is to make sure that we are able to test all the services, internal components, and services that depend on or communicate with other/external services.</p>
<p>Pact-net-core is written in a way that guarantees the contracts would be met. Here are a few points on how it helps us to achieve our goal:</p>
<ul>
<li>The execution is very fast</li>
<li>It helps identify failure causes</li>
<li>The main thing is that Pact does not require a separate environment to manage automation test integration</li>
</ul>
<p>There are two steps for working with Pact:</p>
<ul>
<li>Defining expectations: In the very first step, the consumer team has to define the contract. In the preceding image, Pact helps record the consumer contract, which will be verified when replayed:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="229" src="assets/d0486369-1395-43de-9f84-335f3c705236.png" width="361"/></div>
<ul>
<li>Verifying expectations: As part of the next step, the contract is provided to the provider team and then the provider service is implemented to fulfill the same. In the following image, we are showing the replaying of a contract on the provider side to fulfill the defined contract:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="238" src="assets/59651ba9-f277-4e4d-8e13-efbbe81d90aa.png" width="375"/></div>
<p>We have gone through consumer-driven contracts; they mitigate the challenges of microservice architectures with the help of an open source tool called Pact-net.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance testing</h1>
                </header>
            
            <article>
                
<p>This is non-functional testing, and its main motto is not to verify the code or test the code's health. This is meant to ensure that the system is performing well, based on the various measures, namely scalability, reliability, and so on.</p>
<p>The following are the different techniques or types of performance testing:</p>
<ul>
<li>Load testing: This is a process where we test the behavior of the system under various circumstances of a specific load. It also covers critical transactions, database load, application servers, and so on.</li>
<li>Stress testing: This is an approach where the system goes under regress testing and finds the upper limit capacity of the system. It also determines how a system behaves in this critical situation, when the current load goes above the expected maximum load.</li>
<li>Soak testing: This is also called <em>endurance testing</em>. In this test, the main purpose is to monitor memory utilization, memory leaks, or various factors that affect the system performance.</li>
<li>Spike testing: This is an approach where we make sure that the system is able to sustain the workload. One of the best tasks to determine performance is by suddenly increasing the user load.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">End-to-end (UI/functional) testing</h1>
                </header>
            
            <article>
                
<p>End-to-end, UI, or functional tests are those that are performed for the entire system, including the entire service and database. These tests increase the scope of testing. It is the highest level of testing, includes frontend integration, and tests the system as an end user would use it. This testing is similar to how an end user would work on the system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sociable versus isolated unit tests</h1>
                </header>
            
            <article>
                
<p>Sociable unit tests are those that contain concrete collaborators and cross boundaries. They are not solitary tests. Solitary tests are those that ensure that the methods of a class are tested. Sociable testing is not new. This word is explained in detail by Martin Fowler as a unit test (<a href="https://martinfowler.com/bliki/UnitTest.html">https://martinfowler.com/bliki/UnitTest.html</a>):</p>
<ul>
<li>Sociable tests: This is a test that lets us know the application is working as expected. This is the environment where other applications behave correctly, run smoothly, and produce the expected results. It also, somehow, tests the functioning of new functions/methods, including other software for the same environment. Sociable tests resemble system testing because these tests behave like system tests.</li>
<li>Isolated unit tests: As the name suggests, you can use these tests to perform unit testing in an isolated way by performing stubbing and mocking. We can perform unit testing with a concrete class using stubs.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stubs and mocks</h1>
                </header>
            
            <article>
                
<p>Stubs are returned, canned responses to calls made during the test; mocks are meant to set expectations:</p>
<ul>
<li>Stubs: In a stubs object, we always get a valid stubbed response. The response doesn’t care what input you provide. In any circumstance, the output will be the same.</li>
<li>Mocks: In a mock object, we can test or validate methods that can be called on mocked objects. This is a fake object that validates whether a unit test has failed or passed. In other words, we can say that mock objects are just a replica of our actual object. In the following code, we use the <kbd>moq</kbd> framework to implement a mocked object:</li>
</ul>
<pre style="padding-left: 60px"> [Fact]<br/> public void Get_Returns_ActionResults()<br/> {<br/>    // Arrange<br/>    var mockRepo = new Mock&lt;IProductRepository&gt;();<br/>    mockRepo.Setup(repo =&gt; repo.GetAll().<br/>    ToViewModel()).Returns(GetProducts());<br/>    var controller = new ProductController(mockRepo.Object);<br/>    // Act<br/>    var result = controller.Get();<br/>    // Assert<br/>    var viewResult = Assert.IsType&lt;OkObjectResult&gt;(result);<br/>    var model = Assert.IsAssignableFrom&lt;<br/>    IEnumerable&lt;ProductViewModel&gt;&gt;(viewResult.Value);<br/>    Assert.Equal(2, model.Count());<br/> }</pre>
<p>In the preceding code example, we mocked our <kbd>IProductRepository</kbd> repository and verified the mocked result.</p>
<p>In the upcoming sections, we will understand these terms in more detail, using more code examples from our FlixOne bookstore application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tests in action</h1>
                </header>
            
            <article>
                
<p>So far, we have discussed test strategies and various types of microservice tests. We've also discussed how to test and what to test. In this section, we will see tests in action; we will implement tests with the use of the following:</p>
<ul>
<li>Visual Studio 2017 Update 3 or later</li>
<li>.NET Core 2.0</li>
<li>C# 7.0</li>
<li>ASP.NET Core 2.0</li>
<li>xUnit and MS tests</li>
<li>The moq framework </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready for the test project</h1>
                </header>
            
            <article>
                
<p>We will test our microservice application: FlixOne bookstore. With the help of code examples, we will see how to perform unit tests, stubbing, and mocking.</p>
<div class="packt_quote packt_infobox">We created the FlixOne bookstore application in <em>Chapter 2, Implementing Microservices.</em></div>
<p>Before we start writing tests, we should set up a test project in our existing application. There are a few simple steps we can take with this test project setup:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span> within Using Visual Studio, right-click on <span class="packt_screen">Solution</span> and click <span class="packt_screen">New Project—</span>refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c808f29-36e5-4506-87c3-163b0c2a098b.png"/></div>
<ol start="2">
<li>From the <span class="packt_screen">Add New Project</span> template select <span class="packt_screen">.NET Core</span> and <span class="packt_screen">xUnit Test Project</span> <span class="packt_screen">(.NET Core)</span>, and provide a meaningful name, for example, <kbd>FlixOne.BookStore.ProductService.UnitTests</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c418de5d-1b85-4093-b12b-255078d23952.png"/></div>
<ol start="3">
<li>Go to project <span class="packt_screen">Properties</span>, by right-clicking on the project name from <span class="packt_screen">Solution</span> <span class="packt_screen">Explorer</span>. Open the <span class="packt_screen">Build</span> tab from the <span class="packt_screen">Properties</span> page and click on <span class="packt_screen">Advance</span> and select <span class="packt_screen">C# 7.0</span> as <span class="packt_screen">Language version</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/75e04409-c014-4cf6-8c00-3e262122578e.png"/></div>
<p>Our project structure should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="252" src="assets/29a503f2-4471-43c0-861c-740ffbff730d.png" width="418"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>In <kbd>ProductService</kbd>, let's make sure our service returns product data without failure <span>by testing it</span>. Here we will use fake objects to do so, follow these steps:</p>
<ol>
<li>Add a new folder and name it <kbd>Fake</kbd> in the <kbd>FlixOne.BookStore.ProductService.UnitTests</kbd> project.</li>
<li>Under the <kbd>Fake</kbd> folder add the <kbd>ProductData.cs</kbd> class and add the following code:</li>
</ol>
<pre style="padding-left: 60px">public class ProductData<br/>{<br/>  public IEnumerable&lt;ProductViewModel&gt; GetProducts()<br/>  {<br/>    var productVm = new List&lt;ProductViewModel&gt;<br/>    {<br/>      new ProductViewModel<br/>      {<br/>        CategoryId = Guid.NewGuid(),<br/>        CategoryDescription = "Category Description",<br/>        CategoryName = "Category Name",<br/>        ProductDescription = "Product Description",<br/>        ProductId = Guid.NewGuid(),<br/>        ProductImage = "Image full path",<br/>        ProductName = "Product Name",<br/>        ProductPrice = 112M<br/>      },<br/>      new ProductViewModel<br/>      {<br/>        CategoryId = Guid.NewGuid(),<br/>        CategoryDescription = "Category Description-01",<br/>        CategoryName = "Category Name-01",<br/>        ProductDescription = "Product Description-01",<br/>        ProductId = Guid.NewGuid(),<br/>        ProductImage = "Image full path",<br/>        ProductName = "Product Name-01",<br/>        ProductPrice = 12M<br/>      }<br/>    };<br/>    return productVm;<br/>  }<br/>  public IEnumerable&lt;Product&gt; GetProductList()<br/>  {<br/>    return new List&lt;Product&gt;<br/>    {<br/>      new Product<br/>      {<br/>        Category = new Category(),<br/>        CategoryId = Guid.NewGuid(),<br/>        Description = "Product Description-01",<br/>        Id = Guid.NewGuid(),<br/>        Image = "image full path",<br/>        Name = "Product Name-01",<br/>        Price = 12M<br/>      },<br/>      new Product<br/>      {<br/>        Category = new Category(),<br/>        CategoryId = Guid.NewGuid(),<br/>        Description = "Product Description-02",<br/>        Id = Guid.NewGuid(),<br/>        Image = "image full path",<br/>        Name = "Product Name-02",<br/>        Price = 125M<br/>      }<br/>    };<br/>  }<br/>}</pre>
<p style="padding-left: 60px">In the previous code snippet, we are creating fake data by creating two lists of <kbd>ProductViewModel</kbd> and <kbd>Product</kbd>.</p>
<ol start="3">
<li>Add the <kbd>Services</kbd> folder in the <kbd>FlixOne.BookStore.ProductService.UnitTests</kbd> project.</li>
<li>Under the <kbd>Services</kbd> folder add the <kbd>ProductTests.cs</kbd> class.</li>
</ol>
<ol start="5">
<li>Open <span class="packt_screen">NuGet Manager</span> and then search for and add <kbd>moq</kbd>, refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad0eb9e9-68f1-4b04-95e1-0d6e1e177710.png"/></div>
<ol start="6">
<li>Add the following code to the <kbd>ProductTests.cs</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public class ProductTests<br/>{<br/>    [Fact]<br/>    public void Get_Returns_ActionResults()<br/>    {<br/>      // Arrange<br/>      var mockRepo = new Mock&lt;IProductRepository&gt;();<br/>      mockRepo.Setup(repo =&gt; repo.GetAll()).<br/>      Returns(new ProductData().GetProductList());<br/>      var controller = new ProductController(mockRepo.Object);<br/>      // Act<br/>      var result = controller.GetList();<br/>      // Assert<br/>      var viewResult = Assert.IsType&lt;OkObjectResult&gt;(result);<br/>      var model = Assert.IsAssignableFrom&lt;IEnumerable&lt;<br/>      ProductViewModel&gt;&gt;(viewResult.Value);<br/>      Assert.NotNull(model);<br/>      Assert.Equal(2, model.Count());<br/>    }<br/>}</pre>
<p>In the preceding code example, which is a unit test example, we are mocking our repository and testing the output of our WebAPI controller. This test is based on the <em>AAA</em> technique; it will be passed if you meet the mocked data during setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integration tests</h1>
                </header>
            
            <article>
                
<p>In <kbd>ProductService</kbd>, let's make sure that our service returns the product data without failure. Before we proceed, we have to add a new project and subsequent test classes, follow these steps:</p>
<ol>
<li>Right click on <span class="packt_screen">Solution</span> and then <span class="packt_screen">Add Project</span>.</li>
<li>
<p>From the <span class="packt_screen">Add New Project</span> window, select <span class="packt_screen">XUnit Test Project (.NET Core)</span> and provide a meaningful name, for example, <kbd>FlixOne.BookStore.ProductService.IntegrationTests</kbd>. Refer to the following screenshot:</p>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eca9d769-bb9e-4baa-94b5-f18794704e74.png"/></div>
<ol start="3">
<li>Add the <kbd>appsettings.json</kbd> file and add the following to it:</li>
</ol>
<pre style="padding-left: 60px"> {<br/>   "ConnectionStrings": <br/>   {<br/>     "ProductConnection": "Data Source=.;Initial<br/>     Catalog=ProductsDB;Integrated<br/>     Security=True;MultipleActiveResultSets=True"<br/>   },<br/>   "buildOptions": <br/>   {<br/>     "copyToOutput": <br/>     {<br/>       "include": [ "appsettings.json" ]<br/>     }<br/>   }<br/> } </pre>
<ol start="4">
<li>Open the <kbd>Startup.cs</kbd> file of the  <kbd>FlixOne.BookStore.ProductService</kbd> project.</li>
<li>Now make the <kbd>ConfigureServices</kbd> and <kbd>Configure</kbd> methods void. This is so we can override these methods in our <kbd>TestStartup.cs</kbd> class. These methods would look as follows:</li>
</ol>
<pre style="padding-left: 60px">public virtual void ConfigureServices(IServiceCollection services)<br/>{<br/>   services.AddTransient&lt;IProductRepository,<br/>   ProductRepository&gt;();<br/>   services.AddDbContext&lt;ProductContext&gt;(<br/>   o =&gt; o.UseSqlServer(Configuration.<br/>   GetConnectionString("ProductConnection")));<br/>   services.AddMvc();<br/>   //Code ommited<br/>}<br/>public virtual void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>{<br/>   if (env.IsDevelopment())<br/>   {<br/>      app.UseDeveloperExceptionPage();<br/>      app.UseBrowserLink();<br/>   }<br/>   else<br/>   {<br/>      app.UseExceptionHandler("/Home/Error");<br/>   }<br/>   app.UseStaticFiles();<br/>   app.UseMvc(routes =&gt;<br/>   {<br/>      routes.MapRoute(name: "default",<br/>      template: "{controller=Home}/{action=<br/>      Index}/{id?}");<br/>    });<br/>    // Enable middleware to serve generated Swagger <br/>    as a JSON endpoint.app.UseSwagger();<br/>    // Enable middleware to serve swagger-ui (HTML, JS, <br/>    CSS, etc.), specifying the Swagger JSON endpoint.<br/>    app.UseSwaggerUI(c =&gt;<br/>    {<br/>      c.SwaggerEndpoint("/swagger/v1/swagger.json", <br/>      "Product API V1");<br/>    });<br/>}</pre>
<ol start="6">
<li>Add a new folder called <kbd>Services</kbd>.</li>
<li>Add the <kbd>TestStartup.cs</kbd> class.</li>
<li>Open <span class="packt_screen">NuGet Manager</span>. Search and add the <span class="packt_screen">Microsoft.AspNetCore.TestHost</span> package. Refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0ed19dbd-6924-405e-b1db-d9e816767b36.png"/></div>
<ol start="9">
<li>Add the following code to <kbd>TestStartup.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class TestStartup : Startup<br/>{<br/>   public TestStartup(IConfiguration <br/>   configuration) : base(configuration)<br/>   { }<br/>   public override void ConfigureServices<br/>   (IServiceCollection services)<br/>   {<br/>   //mock context<br/>   services.AddDbContext&lt;ProductContext&gt;(<br/>   o =&gt; o.UseSqlServer(Configuration.<br/>   GetConnectionString("ProductConnection")));<br/>   services.AddMvc();<br/>   }<br/>   public override void Configure(IApplicationBuilder<br/>   app, IHostingEnvironment env)<br/>   { }<br/>}</pre>
<ol start="10">
<li>Under the<span> </span><kbd>Services</kbd><span> </span>folder, add a new <kbd>ProductTest.cs</kbd><span> class </span>and add the following code to this class:</li>
</ol>
<pre style="padding-left: 60px">public class ProductTest<br/>{<br/>  public ProductTest()<br/>  {<br/>    // Arrange<br/>    var webHostBuilder = new WebHostBuilder()<br/>    .UseStartup&lt;TestStartup&gt;();<br/>    var server = new TestServer(webHostBuilder);<br/>    _client = server.CreateClient();<br/>  }<br/>  private readonly HttpClient _client;<br/>  [Fact]<br/>  public async Task ReturnProductList()<br/>  {<br/>    // Act<br/>    var response = await _client.GetAsync<br/>    ("api/product/productlist"); //change per //setting<br/>    response.EnsureSuccessStatusCode();<br/>    var responseString = await response.Content.<br/>    ReadAsStringAsync();<br/>    // Assert<br/>    Assert.NotEmpty(responseString);<br/>  }<br/>}</pre>
<p>In the preceding code example, we are checking a simple test. We are trying to verify the response of a service by setting up a client with the use of <kbd>HttpClient</kbd>. The test will fail if the response goes empty.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consumer-driven contract tests</h1>
                </header>
            
            <article>
                
<p>In the previous section, <em>Contract testing</em>, we discussed things in detail. In this section, we will see how we can implement consumer-driven contract tests with the help of pact-net-core.</p>
<p>We will use our existing  <kbd>FlixOne.BookStore.ProductService</kbd> <span>project, </span>which contains all our APIs. Our <kbd>FlixOne.BookStore.ProductService</kbd> <span>project </span>contains provider tests that let you create a provider scenario, and our client project that actually consumes the services, makes a call, and tests the contract.</p>
<div class="packt_tip">To get started you should install the NuGet package. Execute <kbd><span>Install-Package PactNet.Windows</span></kbd> using the package console.</div>
<p>As per Pact specification (already discussed in a previous section, <em>Contract testing</em>), the client will create a contract called <em>consumer contract</em> (a <kbd>.json</kbd> file). We have written the following code to generate our contract:</p>
<pre>public class ConsumerProductApi : IDisposable<br/>{<br/>  public ConsumerProductApi()<br/>  {<br/>    PactBuilder = new PactBuilder(new PactConfig<br/>    {<br/>      SpecificationVersion = Constant.SpecificationVersion,<br/>      LogDir = Helper.SpecifyDirectory(Constant.LogDir),<br/>      PactDir = Helper.SpecifyDirectory(Constant.PactDir)<br/>    })<br/>    .ServiceConsumer(Constant.ConsumerName)<br/>    .HasPactWith(Constant.ProviderName);<br/>    MockProviderService = PactBuilder.MockService<br/>    (Constant.Port, Constant.EnableSsl);<br/>  }<br/>  public IPactBuilder PactBuilder { get; }<br/>  public IMockProviderService MockProviderService { get; }<br/>  public string ServiceBaseUri =&gt; $"http://localhost:{Constant.Port}";<br/>  public void Dispose()<br/>  {<br/>    PactBuilder.Build();<br/>  }<br/>}</pre>
<p>In the preceding code, we are building a contract. In addition to that, we mocked our client tests. See the following code snippet:</p>
<pre>[Fact]<br/>public void WhenApiIsUp_ReturnsTrue()<br/>{<br/>  //Arrange<br/>  _mockProviderService.UponReceiving("a request to<br/>  check the api status")<br/>  .With(new ProviderServiceRequest<br/>  {<br/>    Method = HttpVerb.Get,<br/>    Headers = new Dictionary&lt;string, object&gt; { { "Accept",<br/>    "application/json" } },<br/>    Path = "/echo/status"<br/>  })<br/>  .WillRespondWith(new ProviderServiceResponse<br/>  {<br/>    Status = 200,<br/>    Headers = new Dictionary&lt;string, object&gt; { {<br/>    "Content-Type", "application/json; charset=utf-8" } },<br/>    Body = new<br/>    {<br/>      up = true,<br/>      upSince = DateTime.UtcNow,<br/>      version = "2.0.0",<br/>      message = "I'm up and running from last 19 hours."<br/>    }<br/>  });<br/>  var consumer = new ProductApiClient(_serviceBaseUri);<br/>  //Act<br/>  var result = consumer.ApiStatus().Up;<br/>  //Assert<br/>  Assert.True(result);<br/>  _mockProviderService.VerifyInteractions();<br/>}</pre>
<p>Our code will create the consumer contract as shown in the following:</p>
<pre>{<br/>  "consumer": <br/>  {<br/>    "name": "Product API Consumer"<br/>  },<br/>  "provider": <br/>  {<br/>    "name": "Product API"<br/>  },<br/>  "interactions": <br/>  [<br/>    {<br/>      "description": "a request to check the api status",<br/>      "request": <br/>      {<br/>        "method": "get",<br/>        "path": "/echo/status",<br/>        "headers": <br/>        {<br/>          "Accept": "application/json"<br/>        }<br/>      },<br/>      "response": <br/>      {<br/>        "status": 200,<br/>        "headers": <br/>        {<br/>          "Content-Type": "application/json; charset=utf-8"<br/>        },<br/>        "body": <br/>        {<br/>          "up": true,<br/>          "upSince": "2017-11-06T00:52:01.3164539Z",<br/>          "version": "2.0.0",<br/>          "message": "I'm up and running from last 19 hours."<br/>        } <br/>      }<br/>    }<br/>  ],<br/>  "metadata": <br/>  {<br/>    "pactSpecification": <br/>    {<br/>      "version": "2.0.0"<br/>    }<br/>  }<br/>}</pre>
<p>Once the consumer-driven contract is created, it should adhere to a provider, so we need to write the APIs accordingly (we are using our existing product API). The following is the code snippet for a provider:</p>
<pre>//Arrange<br/>const string serviceUri = "http://localhost:13607";<br/>var config = new PactVerifierConfig<br/>{<br/>  Outputters = new List&lt;IOutput&gt;<br/>  {<br/>    new CustomOutput(_output)<br/>  }<br/>};<br/>//code omitted</pre>
<p>We have created a web API and a test to verify consumer-driven contracts and finally testing it from a client's perspective.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Testing microservices is a bit different from applications built on the traditional architectural style. In a .NET monolithic application, testing is a bit easier compared to microservices, and it provides implementation independence and short delivery cycles. Microservices face challenges while performing the testing. With the help of the testing pyramid concept, we can strategize our testing procedures. Referring to the testing pyramid, we can easily see that unit tests provide the facility to test a small function of a class and are less time-consuming. On the other hand, the top layer of the testing pyramid enters a large scope with system or end-to-end testing, and these tests are time-consuming and very expensive. Consumer-driven contracts are a very useful way to test microservices. Pact-net is an open source tool meant for this. Finally, we went through the actual test implementation.</p>
<p>In the next chapter, we will see how to deploy a microservice application. We will discuss continuation integration and continuation deployment in detail.</p>


            </article>

            
        </section>
    </body></html>