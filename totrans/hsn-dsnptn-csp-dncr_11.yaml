- en: Concurrent Programming in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter ([Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml),
    *Implementing Design Patterns for Web Applications - Part 2*), we created a sample
    web application with the help of various patterns for the web. We adapted authorization
    and authentication mechanisms to secure a web application and discussed **Test-driven
    development** (**TDD**) to make sure that our code has been tested and is working.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the best practices to adopt while performing concurrent
    programming in .NET Core. In the upcoming sections of this chapter, we will learn
    about the design patterns relevant for well-organized concurrency in C# and .NET
    Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await – Why is blocking bad?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and practices – TDD and Parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is only for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the code examples, you will need to install Visual Studio (preferred
    IDE). To do so, you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio from the download link mentioned with the installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions mentioned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple options are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have SQL Server installed, you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For troubleshooting and for more information, refer to the following link:
    [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Concurrency** is a part of our life: it exists in the real world. When we
    are discussing concurrency, we are referring to multitasking.'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, many of us perform multitasking frequently. For example,
    we can write a program while speaking on a mobile phone, we can watch a movie
    while having dinner, and we can sing while reading notations. There are a lot
    of examples of how we as humans can multitask. Without going into too much scientific
    detail, we can look at our brain trying to grasp new things while also commanding
    the other organs of the body to work, such as the heart or our sense of smell,
    as a form of multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach applies to our systems (computers). If we think about today's
    computers, every computer that is available has a CPU of multiple cores (more
    than one core). This is to allow multiple instructions simultaneously, and let
    us perform multiple tasks at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'True parallelism is not possible on a single CPU machine because tasks are
    not switchable, as the CPU has a single core. It is only possible on a machine
    with multiple CPUs (multiple cores). In simple terms, concurrent programming involves
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task management**: Managing/distributing work units to available threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: This sets up the initial parameter of the task and gets
    the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever things/tasks are happening at the same time, we call this *concurrency*.
    In our programming language, whenever any parts of our program run at the same
    time, this is called concurrent programming. You can also use **parallel programming**
    as a synonym for concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine a big conference that you need a ticket for, to gain
    entry into a specific conference hall. At the gate of a conference hall, you have
    to buy a ticket, making a payment with cash or by card. While you''re making a
    payment, the counter assistant could enter your details into the system, print
    an invoice, and provide you with the ticket. Now consider that there are more
    people who want to buy a ticket. Each person has to perform the required activities
    to collect the ticket from the ticket counter. In this case, only one person can
    be served at a time from one counter, and the rest of the people wait for their
    turn. Let''s assume that one person takes two minutes to collect their ticket
    from the counter; the next person, therefore, needs to wait for two minutes for
    their turn. Consider the wait time of the last person in line if it is a queue
    of 50 people. Things can be changed here. If there were two more ticket counters
    and every counter is performing the tasks in two minutes, this means that every
    two minutes, three people will be able to collect three tickets—or three counters
    are selling two tickets every two minutes. In other words, every ticket counter
    is performing the same task (that is, ticket selling) at the same point in time.
    This means all counters are served in parallel; therefore, they are concurrent.
    This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3375a9cf-5b1e-4100-bbe2-078e2b0da4a3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, it is clearly shown that every person who is in the
    queue is either in the wait position or is active at the counter, and there are
    three queues in which tasks are happening in a sequence. All three counters (`CounterA`,
    `CounterB`, and `CounterC`) are performing tasks at the same point in time—they
    are doing the activities in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** is when two or more tasks start, run, and complete in overlapping
    time periods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelism** is when two or more tasks run at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: These are concurrent activities, but think of a scenario in which a huge amount
    of people are in the queue (for example, 10,000 people); there is no use in performing
    parallelism here, as this would not resolve the issue of a likely bottleneck in
    this operation. On the other hand, you can increase the number of counters to
    50\. Will they resolve this problem? These kinds of problems would occur while
    we work with any software. This is an issue that is related to blocking. In the
    upcoming sections, we will discuss concurrent programming in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To put it simply, we can say that multithreading means that a program is running
    parallel on multiple threads. In asynchronous programming, a unit of work runs
    separately from the main application thread, and it tells the calling thread that
    the task has completed, failed, or is in progress. The interesting issues to consider
    around asynchronous programming are when we should use it and what its benefits
    are.
  prefs: []
  type: TYPE_NORMAL
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**. We have
    already discussed race condition in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml),
    *Implementing Design Patterns - Basics Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the scenario we discussed in the previous section, in which people
    from a queue are collecting their tickets. Let''s try to capture this scenario
    in a multithreading program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a `TicketCounter` class that represents our whole set up of ticket
    collecting counters (we discussed these in the previous section). The three methods:
    `CounterA()`, `CounterB()`, and `CounterC()` represent an individual ticket collection
    counter. These methods are simply writing a message to the console, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is our `Program` class that is initiating the activities
    from within the `Main` method. Here, we declared and started three threads for
    all the counters. Note that we have started these threads in a sequence/order.
    As we are expect that these threads will execute in the same sequence, let''s
    run the program and see the output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa77cf94-ea4a-42d7-bc79-a195f4d235f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding program is not executed as per the given sequence in the code.
    As per our code, the execution sequence should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is due to threads, and these threads are working simultaneously without
    the guarantee that these should execute in the order/sequence that they have been
    declared/started in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, run the program and see whether we get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90eeaf02-4eb6-48ac-9280-ebae4931624c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding snapshot is showing a different output from the previous results,
    so now we have the output in sequence/order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, the threads are working, but not in the sequence we defined them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the priorities of threads like this: `counterC.Priority = ThreadPriority.Highest;`,
    `counterB.Priority = ThreadPriority.Normal;`, and `counterA.Priority = ThreadPriority.Lowest;`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the threads in a synchronized way, let''s modify our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a new `SynchronizedTicketCounter` class with the `ShowMessage()`
    method; please note the `lock(this){...}` in the preceding code. Run the program
    and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/485977ff-b745-40fa-9d36-b62b53858573.png)'
  prefs: []
  type: TYPE_IMG
- en: We have the output we expected now that our counters are serving in the right
    sequence/order.
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await – why is blocking bad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous programming is very helpful in cases where we are expecting various
    activities at the same point in time. With the `async` keyword, we define our
    method/operation as asynchronous. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a `AsyncAwait` class with an `async` method, `ShowMessage()`.
    This method is simply printing a message that would show in the console window.
    Now, whenever we call/consume this method in another code, that part of the code
    could wait/hold/block the operation until the `ShowMessage()` method executes
    and completes its task. Refer to the following snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664b9a37-4b9d-492a-9c5c-5bf10071d809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our previous screenshot says that we have set a delay of 1,000 milliseconds
    for our `ShowMessage()` method. Here, we instructed the program to complete after
    1,000 milliseconds. If we try to remove `await` from the previous code, Visual
    Studio will immediately give the warning to put `await` back in; see the following
    snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90f87239-59f6-4cac-9693-651c66c8facd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the help of the `await` operator, we are using non-blocking API calls.
    Run the program and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/773d415b-b503-4812-b93d-36d7d3aeb4ed.png)'
  prefs: []
  type: TYPE_IMG
- en: We will get the output that is shown in the preceding snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET Core framework provides a variety of collections with which we can
    use LINQ queries. As a developer, there are far fewer options when looking for
    thread-safe collections. Without thread-safe collections, it can become difficult
    for developers when they have to perform multiple operations. In this case, we
    would meet the race condition that we have already discussed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml),
    *Implementing Design Patterns - Basics Part 2*. To overcome such situations, we
    need to use the `lock` statement, as we have used in the previous section. For
    example, we can write a code of a simplified implementation of the `lock` statement—refer
    to the following code snippet, where we have used the `lock` statement and collection
    class, `Dictionary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is from `InventoryContext`; in this code, we are blocking
    other threads from locking the operation in which we are trying to update the
    quantity.
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of the `Dictionary` collection class is that it is not thread-safe.
    We have to use this in the `lock` statement while we're using `Dictionary` with
    multiple threads. To make our code thread-safe, we can use the `ConcurrentDictionary`
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary` is a thread-safe collection class and stores key-value
    pairs. This class has the implementation for the `lock` statement and provides
    a thread-safe class. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is from the `InventoryContext` class of our FlixOne
    console application. In this code, we have the `_books` field, and it is initialized
    as a `ConcurrentDictionary` collection class.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using the `UpdateQuantity()` method of the `InventoryContext` class
    in multithreads, there is a chance that one thread adds the quantity, while the
    other thread resets the quantity to its initial level. This happens because our
    object is from a single collection, and any changes to the collection in one thread
    are not visible to the other threads. All threads are referencing the original
    unmodified collection, and, in simple terms, our method is not thread-safe, unless
    we use the `lock` statement or the `ConcurretDictionary` collection class.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and practices – TDD and Parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we work with multithreading, we should follow best practices to write
    a **smooth code**. A smooth code is where a developer doesn't face deadlock. In
    other words, multithreading requires a lot of care during the writing process.
  prefs: []
  type: TYPE_NORMAL
- en: While multiple threads are running in a class/program, deadlock occurs when
    each thread approaches the object or resource written under a `lock` statement.
    The actual deadlock occurs when each thread approaches to lock an object/resource
    that is already locked by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: A small mistake can result in developers having to tackle unknown bugs that
    occur due to threads that are blocked. In addition to this, a bad implementation
    of a few words in the code can impact 100 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our example of conference tickets, which we discussed at
    the beginning of this chapter. What would happen if ticket counters are unable
    to serve their purpose and distribute tickets? In this scenario, each person would
    try to reach a ticket counter and obtain a ticket, which could jam the ticket
    counter. This could cause the ticket counter to become blocked. The same logic
    applies to our program. We''d meet a deadlock situation in which multiple threads
    would try to lock our object/resource. The best practice to use to avoid such
    a condition is using a mechanism that synchronizes access to the object/resource.
    The .NET Core framework provides a `Monitor` class to achieve this. I have rewritten
    our old code to avoid a deadlock situation—see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `ProcessTicket` method; it starts three threads (each thread
    represents each ticket counter). Every thread is reaching to `ShowMessage` of
    the `TicketCounter` class. There will be a problem of deadlock if our `ShowMessage`
    method is not written well to handle this situation. All three threads will try
    to acquire a lock for the respective object/resource related to the `ShowMessage`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the implementation of the `ShowMessage` method, and I
    have written this code to handle a deadlock situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is the `ShowMessage()` method of our `TicketCounter` class. In
    this method, whenever a thread will try to lock `Object`, if `Object` is already
    locked, it tries for 300 milliseconds. The `Monitor` class handles this situation
    automatically. When using the `Monitor` class, the developer does not need to
    worry about a situation in which multiple threads are running, and each of these
    threads is trying to acquire the lock. Run the program to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5992517-e5e5-490e-bb0a-ef9d708e0994.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding snapshot, you will notice that after `counterA`, `counterC`
    is serving and then `counter B`. This means that after `thread A`, `thread C`
    was initiated, and then `thread B`. In other words, `thread A` acquires the lock
    first, and after 300 milliseconds, `thread C` tries to lock, and then `thread
    B` tries to lock the object. If you want to set the order or priorities of the
    thread, you can add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you add the preceding lines to the `ProcessTickets` method, all the threads
    will work: first `Thread C`, then `Thread B`, and, finally, `Thread A`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread priorities are an enum that tells us how to schedule the thread and
    `System.Threading.ThreadPriority` with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lowest**: This is the least priority, which means threads with the `Lowest`
    priority can be scheduled after the threads of any other priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BelowNormal**: Threads with a `BelowNormal` priority can be scheduled after
    threads having a `Normal` priority, but before threads having the `Lowest` priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal**: All threads are having the default priority as `Normal`. Threads
    with a `Normal` priority can be scheduled after threads having an `AboveNormal`
    priority, but before those threads that have a `BelowNormal` priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AboveNormal**: Threads with an `AboveNormal` priority can be scheduled before
    threads having a `Normal` priority, but after threads having the `Highest` priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highest**: This is the top-most priority level of threads. Threads with the
    `Highest` priority can be scheduled before threads having any other priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After setting a priority level for the threads, execute the program and see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ceaf2e4f-1185-4ac0-aa88-bf90055500bf.png)'
  prefs: []
  type: TYPE_IMG
- en: As per the preceding snapshot, after setting the priority, the counters are
    serving in the order `C`, `B`, and `A`. With a little caution and simple implementation,
    we can handle a deadlock situation as well as schedule our threads to be served
    in a specific order/priority.
  prefs: []
  type: TYPE_NORMAL
- en: The .Net Core framework also provides a **Task Parallel Library** (**TPL**)
    that is a set of public APIs that belong to the `System.Threading` and `System.Threading.Tasks`
    namespaces. With the help of TPL, developers can make applications concurrent
    by adapting its simplification implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the following code, we can see the simplest implementation of a
    TPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is a simple `ForEach` loop using a `Parallel` keyword. In the
    preceding code, we are just iterating a collection of `books` and processing it
    with the use of the `Process` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is our `Process` method (again, the simplest one), and it
    prints the details of the `books`. As per their requirement, users can perform
    as many actions as they want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have the `ParallelismExample` method, and it generates the
    book list and processes the books by executing the `PallelVersion` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you execute the program to see the following output, first consider
    the following code snippet of sequential implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a `Sequential` method; it uses a simple `foreach` loop
    to process the book collections. Execute the program and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcc24a14-5414-42e8-b803-a9dc83c0429f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take note of the preceding snapshot. First, there are four processes running
    in the system on which I am running this demo. The second iterated collection
    is in a sequence/order from 1 to 19\. The program does not divide the tasks into
    different processes running on the machine. Press any key to exit from the current
    process, execute the program for the `ParallelismVersion` method, and see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2119c1f-765c-4c1f-8350-971f9b585cab.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is of an output from a parallel code; you may notice
    that the code is not processed in sequence and the IDs are not coming through
    in sequence/order, as we can see `Id` `13` comes after `9` but before `10`. If
    these were running in sequence, then the order of the `Id`s would be `9`, `10`,
    and then `13`.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ was in the .NET world a long time before the birth of .NET Core. `LINQ-to-Objects`
    allows us to perform in-memory query operations by using arbitrary sequences of
    objects. `LINQ-to-Objects` is a collection of extension methods on top of `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deferred execution** means execution happens once the data is enumerated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PLINQ can be used as an alternative to TPL. It is a parallel implementation
    of LINQ. The PLINQ query operates on in-memory `IEnumerable` or `IEnumerable<T>`
    data sources. Also, it has a deferred execution. The LINQ query performs operations
    in sequence, while PLINQ executes operations in parallel and makes full use of
    all the processors on the machine. Consider the following code to see the implementation
    of PLINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the process method of our PLINQ class. Here, we are using
    PLINQ to query any books in stock with a quantity of more than `12250`. Execute
    the code to see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1c27ddb-a490-46ce-8df1-1ade2ec4f248.png)'
  prefs: []
  type: TYPE_IMG
- en: 'PLINQ uses all the processors of a machine, but we can limit the processors
    in PLINQ by using the `WithDegreeOfParallelism()` method. We can use the following
    code in our `Process ()` method of the `Linq` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will use only three processors of the machine. Execute them,
    and you'll find that you get the same output as in the case of the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed concurrent programming and concurrency in the
    real world. We looked at how we can handle various scenarios related to concurrency
    in our day-to-day life. We looked at collecting conference tickets from serving
    counters, and we understood what parallel programming and concurrent programming
    are. We have also covered multithreading, `Async`/`Await`, `Concurrent` collection,
    and PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will get a taste of functional programming using
    the C# language. We will dive deeper into the concepts that show us how to use
    C# in .NET Core to perform functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is concurrent programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does true parallelism happen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the race condition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we use a concurrent dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following book will help you learn more about the topics that have been
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Concurrent Patterns and Best Practices*, by *Atul S Khot*, published by *Packt
    Publishing*: [https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
