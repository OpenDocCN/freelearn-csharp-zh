<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor042"/>2</h1>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>The One Where Speed Matters</h1>
			<p><em class="italic">Writing </em><em class="italic">for performance</em></p>
			<p>Most users agree that applications can never be fast enough. Anytime you talk to people about what annoys them in a piece of software, performance, or lack thereof, it is the one thing that gets to the top of the list.</p>
			<p>And that makes sense: we are all busy, and we certainly don’t want to spend time waiting for a piece of machinery to catch up with us. It has to be the other way around!</p>
			<p>But if you think about it, you’ll realize it is a miracle that computers can do anything at all within a reasonable time. If you think you’re busy, just look at everything computers need to do! You can do the following experiment:</p>
			<ol>
				<li>Reboot your computer.</li>
				<li>Log in.</li>
				<li>Start (if you’re using Windows) Task Manager (hint: use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">Esc</em> combination).</li>
				<li>Look at how much stuff is going on in the section background processes.</li>
			</ol>
			<p>All of those processes are examples of system programming. They are all there to help the system do its job or to help the user-facing software get things done. And there are a lot of them. These processes all take up a bit of CPU time, a bit of networking, and some memory. Most are dormant and just waiting for something interesting to happen, but they are still there. They take away resources from the user-facing software.</p>
			<p>I guess it is pretty clear that system software needs to be as small and as fast as possible so that there are enough resources left for the rest of the system – that is, the part the user cares about. The next chapter deals with making it small (or as memory-efficient as possible).</p>
			<p>In this chapter, we will cover the following topics</p>
			<ul>
				<li>Why does speed matter?</li>
				<li>What is the <strong class="bold">Common Type </strong><strong class="bold">System</strong> (<strong class="bold">CTS</strong>)?</li>
				<li>What is the difference between value types and reference types?</li>
				<li>What has boxing got to do with performance, and what is it anyway?</li>
				<li>How to choose the right data structures and algorithms to be as fast as possible</li>
				<li>How do strings work and how can we make them faster?</li>
				<li>What is unsafe code and how can we deal with it safely?</li>
				<li>Some compiler flags that help speed things up</li>
			</ul>
			<p>To summarize, this chapter will show you how to make your systems as fast as possible. So, buckle up; we are about to go fast!</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>You will find all the code in this chapter in the following link: <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02</a>.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Setting up the stage</h1>
			<p>So far, we’ve established that we need as much performance as possible to allow the other systems <a id="_idIndexMarker115"/>to do their things. But there are other reasons you might want to optimize your code:</p>
			<ul>
				<li>Accessibility</li>
				<li>Hosting costs</li>
				<li>Planned obsolescence</li>
				<li>Energy usage</li>
			</ul>
			<p>Let’s examine these one by one.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Accessibility</h2>
			<p>Whenever<a id="_idIndexMarker116"/> I mention accessibility to software developers, they usually think about making software useable for people with physical challenges. I like to think a bit broader. Not everybody can afford the latest and fastest hardware. Many people need to make do with older, slower machines. Suppose your code slows that already sluggish machine down. In that case, you might be responsible for these people not being able to use the device anymore.</p>
			<p>Other people use shared devices. Often found in institutions, more than one person uses these devices, and everybody adds their software. If your software slows the machine down, it affects everybody.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Hosting costs</h2>
			<p>More <a id="_idIndexMarker117"/>software these days runs in the cloud, in which case you have to pay per usage. If your software requires a lot of horsepower to run, it might increase costs. When added up, every bit of performance loss impacts the monthly cloud provider bill.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Planned obsolescence</h2>
			<p>Machines<a id="_idIndexMarker118"/> have a fiscal lifetime and an economic lifetime. These lifetimes determine when the company decides to replace the device. The fiscal lifetime is easy to calculate: when the organization buys a machine, the accountants tell you in how many years the value is too low to keep it around. They take the purchase price, calculate the depreciation for each year, and make notes of that in their spreadsheets. I’m oversimplifying things here, but I’m not an accountant.</p>
			<p>The economic lifetime is harder to calculate. This lifetime is usually when a machine becomes so unusable that it is no longer worth upgrading or investing in. A computer that becomes too slow to be used should be replaced, even if the fiscal lifetime hasn’t expired.</p>
			<p>Your software could lead to that happening. If your performance is too low, the organization could write off the machine earlier than desired. And that leads to much e-waste: perfectly good computers get replaced simply because the software was written less-than-perfectly.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Energy usage</h2>
			<p>Using<a id="_idIndexMarker119"/> more CPU power means using more electrical power. You might think it might not be such a big difference, but in the end, all those machines use a lot of energy worldwide. Writing your code as efficiently as possible saves power usage and helps the environment. It’s as simple as that.</p>
			<p>Performance can be gained in a lot of places, even in pieces of your code where you deal with the humble integer. Let’s discuss that!</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Which integer is the fastest?</h1>
			<p>Choosing the<a id="_idIndexMarker120"/> right type of integer to use can have an impact on the performance of your system. I wouldn’t worry too much about this: the CLR is pretty good at optimizing your code, and<a id="_idIndexMarker121"/> the <code>for</code> loop that iterates over a piece of code. If we have less than 255 iterations, we might be tempted to use a byte. After all, a byte is just 1 byte. If you use an integer, it will be 4 bytes. That is more memory and probably takes longer to process, right?</p>
			<p>Wrong!</p>
			<p>Don’t try to outsmart the compiler. It knows the system a lot better than you do.</p>
			<p>Let me show you.</p>
			<p>We have the following four lines of C# code:</p>
			<pre class="source-code">
var a = byte.MaxValue;
var b = UInt16.MaxValue;
var c = UInt32.MaxValue;
var d = UInt64.MaxValue;</pre>			<p>We set four variables to some values. The following table describes the specifics of each type:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">C# Type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Short Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">MaxValue (Hexadecimal)</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>System.Byte</p>
						</td>
						<td class="No-Table-Style">
							<p>byte</p>
						</td>
						<td class="No-Table-Style">
							<p>A byte</p>
						</td>
						<td class="No-Table-Style">
							<p>0xFF</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>System.UInt16</p>
						</td>
						<td class="No-Table-Style">
							<p>ushort</p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned 16-bit integer</p>
						</td>
						<td class="No-Table-Style">
							<p>0xFFFF</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>System.UInt32</p>
						</td>
						<td class="No-Table-Style">
							<p>uint</p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned 32-bit integer</p>
						</td>
						<td class="No-Table-Style">
							<p>0xFFFFFFFF</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>System.UInt64</p>
						</td>
						<td class="No-Table-Style">
							<p>ulong</p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned 64-bit integer</p>
						</td>
						<td class="No-Table-Style">
							<p>0xFFFFFFFFFFFFFFFF</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1: Numeric types with their maximum values</p>
			<p>Let’s examine what<a id="_idIndexMarker122"/> the compiler makes out of it. If you want to see this for yourself, create a new C# console program in Visual Studio (using .NET 7 or .NET 8), use top-level statements, and copy those four lines. Then, set a breakpoint on the first line and run it. As soon as you hit the breakpoint, press <em class="italic">Ctrl</em> + <em class="italic">K</em>, <em class="italic">G</em>. Doing that opens the disassembler.</p>
			<p>You’ll get something like this (I’ve cut some of the code that isn’t that useful to us here):</p>
			<pre class="source-code">
01: # var a = byte.MaxValue;
02: 00007FFF956076EE  mov         dword ptr [rbp+3Ch],0FFh
03: # var b = UInt16.MaxValue;
04: 00007FFF956076F5  mov         dword ptr [rbp+38h],0FFFFh
05: # var c = UInt32.MaxValue;
06: 00007FFF956076FC  mov         dword ptr
[rbp+34h],0FFFFFFFFh
07: # var d = UInt64.MaxValue;
08: 00007FFF95607703  mov         eax,0FFFFFFFFh
09: 00007FFF95607708  cdqe
10: 00007FFF9560770A  mov         qword ptr [rbp+28h],rax</pre>			<p>I know I promised we wouldn’t be doing assembly programming, but you need to know what’s happening if you want your code to run as fast as possible. Let me talk you through it.</p>
			<p>Lines 1, 3, 5, and 7 are comment lines that show the C# code that resulted in this assembly.</p>
			<p>On line 2, we<a id="_idIndexMarker123"/> can see the code the CPU handles when we want it to set the value to a variable. The actual command is MOV, which means move. It then takes two parameters. The first is the target of the MOV, and the second is the value. There are several types of MOV commands; this particular one moves a DWORD. In Win32, DWORD stands for Double Word, which we know as an unsigned 32-bit integer. We are moving the hardcoded value, <code>0FFh</code> (255 in decimal), to <code>[rbp+3Ch]</code>. In case you’re wondering, <code>rbp</code> is the stack pointer. So, we’re moving our value, <code>0xFF</code>, to position 3C on our stack.</p>
			<p>Great. We should know that value types go on the stack instead of the heap. Don’t worry if you didn’t realize that. The next chapter is all about memory. For now, just accept that we have two types of memory: a small but fast stack and a slow but huge heap. This byte goes to the stack.</p>
			<p>Line 4 moves <code>0xFFFF</code> to <code>[rbp+38h]</code>. Again, we are moving a <code>DWORD</code> here.</p>
			<p>Line 6 does more or less the same: we move <code>0xFFFFFFFF</code> to the stack. Again, it is a <code>DWORD</code>.</p>
			<p>When compiled, a byte, a <code>UInt16</code>, and a <code>UInt32</code> are considered a <code>DWORD</code>. There is no difference between them. If you look at the assembly code, there’s no way of knowing what type the C# intended to use. That means there is no difference in performance here when using an 8-bit byte or a 32-bit unsigned integer. And in case you’re wondering, the signed 32-bit integer looks the same, with the difference that <code>Int32.MaxValue</code> is half the value of <code>UInt32.MaValue</code>. However, the compiled code is the same.</p>
			<p>Look at the code to copy the 64-bit integer to the stack. That works quite differently. On line 8, we move <code>0xFFFFFFFF</code> to a register (a register is a special piece of memory inside the CPU that holds temporary variables). Then, we call CDQE. That copies whatever is in the EAX register (which can hold 32 bits) into the <code>RAX</code> register, which can hold 64 bits. Then, on line 10, it copies the first 32 bits of the contents to the stack.</p>
			<p>As you can see, setting a variable to <code>Int64.MaxValue</code> involves a lot more work than the other three variants. It is considerably slower: the CPU has to do a lot more.</p>
			<p>However – and<a id="_idIndexMarker124"/> this is important – this might not always be the case. This is what happens on my modern, beefy 64-bit Windows 11 machine. Things might be completely different on a low-powered Raspberry PI running Linux on an ARM processor. And that is one of the challenges of system programming: you must know how types behave to have the highest possible performance.</p>
			<p>I think it’s time to discuss the CTS.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>The CTS</h1>
			<p>The CTS is a set <a id="_idIndexMarker125"/>of rules describing the types that are used in a .NET program. That’s it. Nothing binary is going on; it is just a set of rules – a standard that compilers, languages, and the runtime must adhere to.</p>
			<p>There are several different languages available on .NET Framework. Microsoft has C#, VB.Net, and F#. They also offer J#, a Java variant running on the CLR. You can also write .NET programs in C or C++. Other vendors also provide languages and tools you can choose from. Think of IronPython or Delphi.NET, for instance.</p>
			<p>All these languages must stick to the rules. The compiler must emit IL code (again, IL looks like assembly but isn’t). The JIT compiler then takes the IL to create machine code the CPU can understand and run.</p>
			<p>There is a subset of the rules in the CTS that are called the <code>[assembly: </code><code>CLSCompliant(true)]</code> attribute.</p>
			<p>Our aim here is not to design languages, so we aren’t going to dive deeper into this.</p>
			<p>All types used in .NET languages must adhere to the CTS rules. This book is not about learning to program in .NET. Still, knowing about the inner workings is crucial if you’re a system programmer. We will cover just the highlights of the CTS here.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Value types and reference types</h2>
			<p>Later in this chapter, I’ll discuss value and reference types<a id="_idIndexMarker127"/> in a lot <a id="_idIndexMarker128"/>more detail. Here, I will simply say that value types hold their values directly. In contrast, reference types are pointers that point to a value somewhere else in memory.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Classes and structs</h2>
			<p>.NET-based languages are supposed to be object-oriented. From this, it follows that the languages should support classes. These classes also have to have specific characteristics.</p>
			<p><strong class="bold">Classes</strong> should <a id="_idIndexMarker129"/>have visibility. They can be public, internal, protected, or private. We all know what those classifiers mean.</p>
			<p>Classes have methods, properties, fields, delegates, and so on. These items can be private, protected, or public. You probably already know all of this; I don’t have to explain what this all is.</p>
			<p>However, a lot of developers struggle<a id="_idIndexMarker130"/> with <strong class="bold">structs</strong>. To the casual observer, they are more or less the same. And yes, they are indeed similar. They can both have methods, properties, fields, and so on. They can both implement interfaces. And they can both have static members.</p>
			<p>The differences between classes and structs are more interesting. First, a class instance lives on the heap, and you will get a pointer that you store in the stack. However, a struct lives on the stack.</p>
			<p>Since the variable that “holds” the class is the pointer to the heap memory where the data is stored, that variable can be null. In that case, it points to nothing; it is just a placeholder for a future instance of that class.</p>
			<p>A struct cannot be null. There is an edge case: nullable types such as <code>MyStruct?</code> can be null, but that is the whole point of nullable types. Structs cannot inherit from each other. They can implement interfaces, though, just like classes can. That also means you cannot have an “abstract” or “sealed” struct. Those two modifiers are meant for classes that must be inherited. Since we cannot inherit from structs, this doesn’t make sense.</p>
			<p>Looking at this, you might think that a class is a better choice: there are only a few downsides and a lot of upsides in using them over structs. And you’re not wrong. But structs have one significant advantage over classes: they are initialized on the stack, not the heap. And as I said previously, the stack is way faster than the heap. Since we aim for maximum performance, structs are used much more in our applications than in others.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Floating-point numbers</h2>
			<p>We<a id="_idIndexMarker131"/> already saw that it doesn’t matter what kind of integer you use for most cases. UInt64, Int64, UInt128, and Int128 are generally slower than the other types, so only use them when you have thought it through and decided you need them.</p>
			<p>Things are a bit different for floating-point numbers, however. We have three floating-point types in the CLS and, thus, in C#. Please look at the following table to see which ones they are:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">C# Type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>float</p>
						</td>
						<td class="No-Table-Style">
							<p><code>System.Single</code></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit single-precision floating-point</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>double</p>
						</td>
						<td class="No-Table-Style">
							<p><code>System.Double</code></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit double-precision floating-point</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>decimal</p>
						</td>
						<td class="No-Table-Style">
							<p><code>System.Decimal</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The 128-bit decimal type is more precise but has a smaller range than a double</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2: Floating-point types</p>
			<p>Which type you choose depends on your scenarios. You must select a decimal over a float if you need more precision. That would be obvious. But things are slightly more complicated if you don’t need the 128-bit precision a decimal gives you.</p>
			<p>On a 64-bit machine, the double (<code>System.Double</code>) is the fastest floating-point number. The CPU can understand this natively, so no conversions are needed. Performance-wise, this is your best choice. However, a float (<code>System.Single</code>) is more memory efficient. However, this is only true on a 64-bit machine. If you’re targeting other platforms, the results might be different. For instance, if you want to run your code on an ARM-based device such as a Raspberry Pi, you will find that the CPU is optimized for the float type. So, you would be better off using a single-precision variety if you care about performance. Again, if your use case needs a higher precision, please use one of the other types. They are here for a reason, after all.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Where types live – the difference between value types and reference types</h1>
			<p>Types in the CTS <a id="_idIndexMarker132"/>can be either a value type or a reference type. It is essential to know the difference between these two options. Value types operate on the stack, while reference types live on the heap. Stuff residing on the stack is usually much faster than what happens on the heap.</p>
			<p>From this, you would think using value types on the stack is the best way to get your desired sweet performance. Unfortunately, that is not how things work. The reference types are there for a reason, and they can give you significant performance improvements if used correctly!</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>The stack and the heap</h2>
			<p>Before discussing <a id="_idIndexMarker133"/>the difference between value types and reference types, we need to quickly look at the difference between the stack and the heap. I have already mentioned that the stack is faster than the heap but smaller. This is true, but there’s a bit more to this.</p>
			<p>The following table shows the differences between the two types of memory:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Feature</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Stack</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Heap</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Allocation/Deallocation</p>
						</td>
						<td class="No-Table-Style">
							<p>Fast, compile time</p>
						</td>
						<td class="No-Table-Style">
							<p>Slow, runtime</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Lifespan</p>
						</td>
						<td class="No-Table-Style">
							<p>Limited to scope</p>
						</td>
						<td class="No-Table-Style">
							<p>Beyond scope</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Size Limitation</p>
						</td>
						<td class="No-Table-Style">
							<p>Smaller, fixed-size</p>
						</td>
						<td class="No-Table-Style">
							<p>Larger, dynamic size</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Data Types</p>
						</td>
						<td class="No-Table-Style">
							<p>Value types (usually)</p>
						</td>
						<td class="No-Table-Style">
							<p>Reference types</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Behavior</p>
						</td>
						<td class="No-Table-Style">
							<p>Deterministic</p>
						</td>
						<td class="No-Table-Style">
							<p>Non-deterministic</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Fragmentation</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
						<td class="No-Table-Style">
							<p>Possible</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Thread</p>
						</td>
						<td class="No-Table-Style">
							<p>Thread-specific</p>
						</td>
						<td class="No-Table-Style">
							<p>Shared between threads</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3: Differences between stack and heap memory</p>
			<p>The memory <a id="_idIndexMarker134"/>allocation for stack variables is done at compile time, and the memory is pushed on and popped off the stack. This makes allocation and deallocation extremely fast. For heap variables, the memory is allocated dynamically at runtime.</p>
			<p>However, the lifespan of variables on the stack is limited to the function’s scope or the block of code. Once your code no longer needs that variable, such as because you reached the end of a <code>for</code> loop, the memory for this variable is automatically freed. For the heap, it is up to you or the garbage collector to get rid of the memory when it’s unnecessary.</p>
			<p>The stack is smaller, and you are much more likely to run out of stack memory than heap memory. Heap memory can be huge, especially compared to stack memory.</p>
			<p>If you’re wondering how big that stack is, the answer is, “It depends.” You can even specify it yourself. Since the stack is tied to a thread, you can set the stack size when working with new threads:</p>
			<pre class="source-code">
// Create a new thread with a stack size of 1 MB
var thread = new Thread(new ThreadStart(ThreadMethod), 1024 * 1024);
thread.Start();</pre>			<p>Here, we created a new thread and gave it a <code>1 MB</code> stack. It’s easy to determine this! If you want to limit the amount of memory a thread uses, you can estimate how much you need and allocate it that way.</p>
			<p>On a side note, most developers know of <a href="https://StackOverflow.com">https://StackOverflow.com</a>. Strangely enough, I have met many developers who have no idea where that name comes from.</p>
			<p>When you create a thread with a given stack size but try to use more memory than available, you get a <code>StackOverflowException</code> error. That is where that name comes from.</p>
			<p>Let me show you. Oh – and don’t use this in production code. This sample is just for illustrative purposes:</p>
			<pre class="source-code">
try
{
    Recur();
}
catch (StackOverflowException e)
{
    Console.WriteLine($"Oh oh.. {e.Message}");
}
return;
static void Recur()
{
    Recur();
}</pre>			<p>The <a id="_idIndexMarker135"/>preceding code calls a recursive function that does one thing: it calls itself. When you call a function or a method, the system stores the address to return to when the function ends. The system stores this return address on the stack. After all, this is short-lived and needs to be fast. You want to continue with your regular flow after the function call.</p>
			<p>But this code does nothing except call a function repeatedly and never returns from it. Thus, the return address gets added to the stack thousands of times until the memory runs out, and you get that famous <code>StackOverflowException</code> error.</p>
			<p>If you want to experiment with this, run the preceding code in a separate thread and give it different stack sizes. Doing this will give you an idea of how significant an impact having the correct stack size has.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Boxing and unboxing</h1>
			<p>So far, things <a id="_idIndexMarker136"/>look pretty straightforward. Value types live in the stack; reference types live on the heap. An integer is a value type; thus, you have it on the stack. A class you define<a id="_idIndexMarker137"/> is on the heap since that is a reference type. If you want your class to be faster, you can turn it into a struct and have it available quicker since it goes on the stack. You might be thinking this is easy, but you’d be wrong. Things can be a lot more complicated than that.</p>
			<p>Let’s look at our good friend, the integer. An integer is a whole number, so it has no decimal point. As we saw earlier, we have a couple of variations of the integer. We have the 16-bit, the 32-bit, the 64-bit, and even a 128-bit version. And we have them in signed and unsigned versions. We even have a byte: this is technically not an integer, but since it compiles to a DWORD, we can have it in the same category. An integer is a value type, so it lives on the stack. However, if you look at <em class="italic">Table 2.1</em>, you’ll see that the official name of an integer is <code>System.Int32</code>. I don’t know about you, but that looks like a class or a struct name.</p>
			<p>A struct still lives on the stack, but it is less performant than you might expect compared to a simple integer. Luckily, the compiler helps us with this. As we saw earlier, the compiler turns our integers into DWORDs, so there is no performance penalty. But sometimes, things work differently. So, we need to talk about boxing and unboxing.</p>
			<p>C# is a genuine object-oriented language. That means everything is an object, and all descend from a base class. At the top level, one base class is the ancestor of all other classes. That is <code>System.Object</code>. Our integer is no different: the <code>System.Int32</code> struct derives from the <code>System.ValueType</code> class, which, in turn, is a descendant of <code>System.Object</code>. So, we still follow the rules of object orientation. Still, there seems to be a mix of classes and structs here. Don’t worry; these are semantics, and the compiler deals with them when needed.</p>
			<p>“Dealing with” sometimes means that the runtime converts value types into reference types or vice versa. That is what we call boxing and unboxing.</p>
			<p>Boxing happens when the system converts a value type into a reference type. Converting a reference type into a value type is known as unboxing. Think of it as putting our value type in a box, in the shape of a class, or getting it out again if you go the other way:</p>
			<pre class="source-code">
int i = 42;
object o = i; // Boxing
int j = (int)o; // Unboxing</pre>			<p>The first line declares <a id="_idIndexMarker138"/>a simple 32-bit integer, and we give it a value. We saw this<a id="_idIndexMarker139"/> previously; this is a relatively simple and fast instruction. In assembly, we move a hardcoded value into a DWORD position on the stack.</p>
			<p>We want to make a copy of it, but this time, we use an object instead of an integer. Since <code>System.Int32</code> is derived from <code>System.Object</code> (with <code>System.ValueType</code> in between), you wouldn’t expect this to be that much work. In the end, we still have an integer. But things are more complicated. Again, let’s have a look at the assembly code. To be clear, you don’t need to know assembly, but it is easier to understand how to get the most performance if you know what happens under the hood.</p>
			<p>Here, <code>object o = i</code> translates to quite a lot of code:</p>
			<pre class="source-code">
1: object o = i; // Boxing
2: 00007FF9625E76F1  mov         rcx,7FF96254E8D0h
3: 00007FF9625E76FB  call        CORINFO_HELP_NEWSFAST (07FF9C20D0960h)
4: 00007FF9625E7700  mov         qword ptr [rbp+20h],rax
5: 00007FF9625E7704  mov         rdx,qword ptr [rbp+20h]
6: 00007FF9625E7708  mov         ecx,dword ptr [rbp+3Ch]
7: 00007FF9625E770B  mov         dword ptr [rdx+8],ecx
8: 00007FF9625E770E  mov         rdx,qword ptr [rbp+20h]
9: 00007FF9625E7712  mov         qword ptr [rbp+30h],rdx</pre>			<p>I won’t explain everything that’s happening here, but there are a lot of moving parts here. Line 3, however, is the important one: <code>CORINFO_HELP_NEWSFAST</code> is a method in the CLR that allocates memory on the heap. Yes, the heap. Not the stack. This is what we call a very expensive operation: it takes a relatively long amount of time. After that, much copying occurs, all of which takes time.</p>
			<p>Compare this with copying that integer variable to another integer without going through boxing:</p>
			<pre class="source-code">
1: int j = i;
2: 00007FF9625B7716  mov         eax,dword ptr [rbp+3Ch]
3: 00007FF9625B7719  mov         dword ptr [rbp+2Ch],eax</pre>			<p>This <a id="_idIndexMarker140"/>assembly code takes the value of what’s in the <code>i</code> variable (in the <code>[rbp+0x3C]</code> memory location) and moves it to the eax register. Then, it transfers that register to <code>[rbp+0x2C]</code>, where the new variable, <code>j</code>, is.</p>
			<p>This was just<a id="_idIndexMarker141"/> two quick move calls, from the stack to the register (blazingly fast) and from the register back to the stack. That hardly takes time.</p>
			<p>Going from the heap to the stack seems to be quicker since less coding is going on. Here, <code>int j = (int)o</code> leads to unboxing. The assembly for that code looks like this:</p>
			<pre class="source-code">
1: int j = (int)o; // Unboxing
2: 00007FF9625F7726  mov         rdx,qword ptr [rbp+30h]
3: 00007FF9625F772A  mov         rcx,7FF96255E8D0h
4: 00007FF9625F7734  call        qword ptr [CLRStub[MethodDescPrestub]@00007FF9625EB8D0 (07FF9625EB8D0h)]
5: 00007FF9625F773A  mov         eax,dword ptr [rax]
6: 00007FF9625F773C  mov         dword ptr [rbp+2Ch],eax</pre>			<p>This assembly code doesn’t have that very expensive call to allocate memory. This makes sense: the stack doesn’t require this. The stack has a fixed amount of memory, so you can use it if needed. If you run out of it, you get the <code>StackOverflow</code> exception we looked at earlier. The rest is just moving data about. There’s still much more code here than what we saw when we copied two integers. Still, it doesn’t look that bad, does it?</p>
			<p>Don’t be fooled: if we decide to use the <code>j</code> variable from now and not use <code>o</code> anymore, it can be removed from the heap. The garbage collector takes care of that, so you don’t have to worry about it. But the garbage collector also comes with a lot of performance loss. The garbage collector is the topic of another chapter but be assured it can be a huge performance drain. This isn’t obvious from this bit of code. There are hidden costs involved.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Hidden boxing and unboxing</h2>
			<p>Copying a <a id="_idIndexMarker142"/>value type, such as an integer, to a reference type leads to boxing. If you can avoid that, you should do so. But sometimes, boxing and unboxing happen when<a id="_idIndexMarker143"/> you don’t expect it. Look at the following code:</p>
			<pre class="source-code">
internal void DoSomething()
{
    int i = 42;
    DoSomethingElse(i);
}
internal void DoSomethingElse(object o)
{
    Console.WriteLine(o.ToString());
}</pre>			<p>Here, we declare an integer, <code>i</code>, in <code>DoSomething()</code>. Then, we call <code>DoSomethingElse()</code> with that integer. The original author of <code>DoSomethingElse </code>was trying to write the code so it could be reused. So, they decided to accept <code>System.Object</code> as a parameter. Since everything is, in the end, derived from that, this seems like a good idea. But it isn’t. Here, <code>i</code> will be boxed before being passed to <code>DoSomethingElse</code>, along with the performance penalty that happens when boxing.</p>
			<p>It would be better if the developer wrote the method like this:</p>
			<pre class="source-code">
internal void DoSomething()
{
    int i = 42;
    DoSomethingElse(i);
}
internal void DoSomethingElse&lt;T&gt;(T o)
{
    Console.WriteLine(o.ToString());
}</pre>			<p>Here, instead <a id="_idIndexMarker144"/>of accepting an object, we take a generic type. Since we pass it as an integer, the compiler understands that this is a value type and doesn’t convert it into <a id="_idIndexMarker145"/>an object. No boxing is happening here. This code is a lot faster than the previous version.</p>
			<p>How about this line of code?</p>
			<pre class="source-code">
int i = 42;
string message = "Hello Integer " + i;</pre>			<p>It looks pretty simple. But again, boxing is happening here. Before string concatenation can happen, the <code>i</code> variable is first boxed to the reference type.</p>
			<p>The next one is nice as well:</p>
			<pre class="source-code">
var list = new ArrayList();
list.Add(i); // boxing!
int j = (int)list[0]; // unboxing!</pre>			<p>Value types are part of reference types that usually live on the heap. So, they need to be boxed. Getting the values back will then lead to unboxing.</p>
			<p>Moving value types to reference types leads to this behavior. Take a look at the following code:</p>
			<pre class="source-code">
IComparable i = 42;</pre>			<p>This is safe, right? We aren’t converting; we’re just declaring that we are interested in part of the integer that belongs to the <code>IComparable</code> interface. The <code>System.Int32</code> struct implements a lot of interfaces, and this happens to be one of them. Still, it is a struct, so all should be good.</p>
			<p>Let’s have a quick look at the associated assembly for that simple line of C# code:</p>
			<pre class="source-code">
1: IComparable i = 42;
2: 00007FF9625E76F1  mov         rcx,7FF96254E8D0h
3: 00007FF9625E76FB  call        CORINFO_HELP_NEWSFAST (07FF9C20D0960h)
4: 00007FF9625E7700  mov         qword ptr [rbp+20h],rax
5: 00007FF9625E7704  mov         rax,qword ptr [rbp+20h]
6: 00007FF9625E7708  mov         dword ptr [rax+8],2Ah
7: 00007FF9625E770F  mov         rax,qword ptr [rbp+20h]
8: 00007FF9625E7713  mov         qword ptr [rbp+30h],rax</pre>			<p>You <a id="_idIndexMarker146"/>should recognize this by now, especially the call to <code>CORINFO_HELP_NEWSFAST</code>. This is boxing in action. The same happens when using the <code>IEquatable&lt;int&gt; = 42</code> line. Although we now use a generic, we still get boxing.</p>
			<p>Let’s look at one more example. This one is a bit silly:</p>
			<pre class="source-code">
object myString = "some string";
var stuff = true ? 42 : myString;</pre>			<p>Here, we <a id="_idIndexMarker147"/>have a string that we appoint to an object, <code>myString</code> (that is not the silly part). Then, we assign something to <code>stuff</code>, depending on <code>true</code> being true (which it always is; this is the silly part). If <code>true</code> is true, we assign <code>42</code> to stuff. If not, we copy <code>myString</code> to <code>var</code>. At first glance, you might expect <code>stuff</code> to be of the <code>int</code> type since <code>true</code> is always true. But that is not how a static-typed language works. It needs to know what type <code>stuff</code> is at compile time. The conditional operator, <code>? :</code>, expects both sides to be equivalent types. Thus, it decides that one part is an object and can cast the integer literal to an object. Therefore, it boxes that <code>42</code> into an object instance, and <code>stuff</code> here is another object instance. And there you have it: more boxing.</p>
			<p>Boxing and unboxing allow you to mix and match value and reference types. It would be tough to write reusable code otherwise. But be aware of this, and be mindful of the costs associated with boxing and unboxing. It happens in places you might not be aware of. And that results in less-than-stellar performance.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Choosing the right data structures and algorithms</h1>
			<p>Object orientation <a id="_idIndexMarker148"/>is all about having the data and the operations on that data together in a cohesive and loosely coupled structure. That is what classes and structs do: they combine the two. This way, you can define your data structures in a way that makes sense concerning the system’s functionality.</p>
			<p>But when speaking<a id="_idIndexMarker149"/> about performance, other factors come into play. Having static classes is usually a code smell that you must avoid. However, they’re fast. You don’t need to instantiate something, resulting in that costly call to allocate heap <a id="_idIndexMarker150"/>memory. And that memory doesn’t need to be cleaned by the garbage collector later.</p>
			<p>Of course, if you have member variables for that class, you might as well instantiate it. Ultimately, all that happens is that those variables end up on the heap (with a little bit of housekeeping). The methods themselves are part of your application code and are stored differently.</p>
			<p>The BCL also has many classes and data structures you can use to store data. Some of them are better suited for high performance than others. Which one you choose depends on your use case, but I think writing a bit more code is worth it if that means you can use a more efficient class.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Arrays, Lists, and LinkedLists</h2>
			<p><strong class="bold">Arrays</strong>, <strong class="bold">Lists</strong>, and <strong class="bold">LinkedLists</strong> are all structures you can use to store data sequentially. That<a id="_idIndexMarker151"/> data is stored in the heap as well. Yes, you read that correctly. Look at the following two lines of code:</p>
			<pre class="source-code">
int i = 42;
int[] r = { 42 };</pre>			<p>The first line is a simple assignment. The system copies the hard-coded value of <code>42</code> (0x2A in hex) to a DWORD and stores it on the stack. The second line creates a new array, allocates memory for that on the heap, initializes the array, and then copies <code>42</code> into the first position.</p>
			<p>Read that again and try to see if you can guess if there’s any boxing going on.</p>
			<p>You might expect that there is, but there’s no boxing here. The array holds a pointer to a place in the heap that contains individual DWORD values. It knows how long each value is (32 bits, to be precise), so it can move the values directly without changing anything. Also, no unboxing occurs when taking an element from the array and storing it in a local variable. The system copies the DWORD value and leaves it at that.</p>
			<p>A list is the same as an array. Internally, the data is stored in an array. However, a list offers the option to resize it dynamically. Next to that, it has some nice methods such as <code>Add()</code>, <code>Remove()</code>, and <code>IndexOf()</code> that can be very helpful. But nothing comes for free: the methods take time to perform, and dynamic reallocation is very expensive in terms of performance. You must judge if you need those extra methods and dynamic reallocation. If you do, use a list. If you can go without, use an array.</p>
			<p>There is an<a id="_idIndexMarker152"/> in-between solution: you can use <code>List&lt;T&gt;</code> and initialize it with an appropriate size. After all, you must do the same for an array: you need to know how big it is. Doing that causes the <code>List</code> class to initialize the array it uses internally to that exact size, and no reallocations happen – unless, of course, you find out you need more room. But that’s great; you don’t run out of memory. Yes, you get the performance penalty in that case, but that’s okay. If you pre-initialize the <code>List</code> class, the performance is almost identical to the pure, basic array.</p>
			<p>The <code>LinkedList</code> class has some nice features. It is a double-linked list of items, which means each item is accompanied by a pointer to the next and the previous object. This means more data is needed to store things: we cannot just store the items themselves, but the system must also add those pointers. This results in slower behavior: those pointers must also be calculated and copied. So, you might think <code>LinkedList</code> is wrong when considering performance.</p>
			<p>However, <code>LinkedList</code> might<a id="_idIndexMarker153"/> be a great choice if your use case requires insertions and removals. Inserting an item simply means storing the object and adjusting some pointers. In an array or list, inserting would mean moving everything up one place in the internal array when you want something to sit in the middle.</p>
			<p>Again, use your judgment. If you can, use arrays (or pre-initialized lists), go for the uninitialized list, and only then look at <code>LinkedLists</code>.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Stacks and queues</h2>
			<p><strong class="bold">Stacks</strong> and <strong class="bold">queues</strong> look <a id="_idIndexMarker154"/>very similar. They are more or less similar performance-wise, with one big<a id="_idIndexMarker155"/> difference: a stack is fast if you need to access the latest added items, whereas a queue is very fast when you need quick access to the items in the order they were entered. In other words, a stack is <a id="_idIndexMarker156"/>optimized for <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) scenarios, while a queue <a id="_idIndexMarker157"/>is better in <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) scenarios.</p>
			<p>However, your code runs faster if you can think of a way to use a stack instead of a queue. A stack is slightly more efficient than a queue in handling its work, at least enough to make it worth rewriting your code.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>HashSets and lists</h2>
			<p>A <code>HashSet</code>. A <code>HashSet</code> can be efficient when you’re adding, removing, or looking up items.</p>
			<p>A <code>HashSet</code> has one significant advantage over a list concerning performance: a HashSet has a constant-time average complexity for add, delete, and search operations. A list, however, has a linear-time search complexity. In everyday English, a HashSet always takes the same time to look up items, no matter how many elements it contains. A list needs more search time when more items are added to it.</p>
			<p>But beware: a constant time means the time doesn’t change. This doesn’t imply a <code>HashSet</code> is faster! Quite the contrary: a <code>HashSet</code> can be pretty slow. And that makes sense: before an item is added to the <code>HashSet</code>, it needs to calculate the unique hash for that item. That hash is the key that’s used to store the object’s position. And then, it has to check if an object with that hash has already been added.</p>
			<p>Of course, once this has been done, looking up an item is very quick: it needs to have the hash, and then it can find it easily. Also, when you have one of these two collections and need to add an item, the HashSet is faster than the list in many cases.</p>
			<p>As with most of these cases, look at your requirements and try to do a couple of benchmark tests to see what you can use best.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>SortedList, SortedDictionary, and Dictionary</h2>
			<p><code>HashSet</code>, but the big difference is that you can retrieve the items by its key in a <code>Dictionary</code>. You can retrieve the data in the <code>HashSet</code>, but you must use a <code>foreach</code> statement to get them all or a <code>Linq</code> statement such as <code>Where()</code>.</p>
			<p>The keys in the <code>SortedLis</code>t, <code>SortedDictionary</code>, and <code>Dictionary</code> must be unique. If your use case allows for that, these collections can do wonders, but only if you choose the right one. The following table compares these three types in terms of their performance:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Dictionary</strong><strong class="bold">
&lt;</strong><strong class="bold">TKey, TValue&gt;</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">SortedList</strong><strong class="bold">
&lt;</strong><strong class="bold">TKey, TValue&gt;</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">SortedDictionary &lt;TKey,TValue&gt;</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Underlying data structure</p>
						</td>
						<td class="No-Table-Style">
							<p>Hash table.</p>
						</td>
						<td class="No-Table-Style">
							<p>Array for keys, array for values. Keys are sorted.</p>
						</td>
						<td class="No-Table-Style">
							<p>Balanced binary search tree.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Ordering</p>
						</td>
						<td class="No-Table-Style">
							<p>No ordering of elements.</p>
						</td>
						<td class="No-Table-Style">
							<p>Elements are sorted by key.</p>
						</td>
						<td class="No-Table-Style">
							<p>Elements are sorted by key.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Insertion</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1</em>) average time complexity.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(n</em>) time complexity since it might need to shift elements to maintain order.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> time complexity.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Deletion</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1)</em> average time complexity.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(n)</em> time complexity, for the same reason as insertion.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> time complexity.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Lookup</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1)</em> average time complexity.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> time complexity.</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> time complexity.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Memory</p>
						</td>
						<td class="No-Table-Style">
							<p>Generally less memory efficient than SortedList, but better than SortedDictionary.</p>
						</td>
						<td class="No-Table-Style">
							<p>More memory efficient than SortedDictionary since it uses arrays for the keys.</p>
						</td>
						<td class="No-Table-Style">
							<p>Generally less memory-efficient.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Use-case</p>
						</td>
						<td class="No-Table-Style">
							<p>When you don’t want ordering but want fast insertions, deletions, and lookups.</p>
						</td>
						<td class="No-Table-Style">
							<p>When you have a relatively small dataset that you want to keep sorted and you will be doing lots of lookups.</p>
						</td>
						<td class="No-Table-Style">
							<p>When you have a larger dataset that you want to keep sorted, and you need faster insertions and deletions than SortedList offers.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.4: Key-based collections</p>
			<p>Again, check your requirements and benchmarks to see what works best for you.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Dictionary or last of tuples/objects</h2>
			<p>A <strong class="bold">List&lt;Tuple&gt;</strong> and a <strong class="bold">Dictionary</strong> are different things, but with some rewrites, you could use both to achieve your goal.</p>
			<p>The lookup<a id="_idIndexMarker162"/> speed in<a id="_idIndexMarker163"/> the <code>Dictionary</code> is very fast. Since you look for the key instead of the actual item, you can achieve a much better performance than with the list, where you have to iterate through the whole list to find what you need. Also, insertion and deletion are fast and constant when using a Dictionary.</p>
			<p>However, with a <code>Dictionary</code>, the keys need to be unique. With a list, this is not necessary. Again, with some rewrites, you might be able to use a <code>Dictionary</code> instead of a list and benefit from some highly-needed performance gains.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>For versus ForEach</h2>
			<p><strong class="bold">ForEach</strong> is amazing. It helps us write our code so much faster. However, it can also slow down our code.</p>
			<p><code>ForEach</code> is <a id="_idIndexMarker164"/>so helpful that the people who built the compiler added all sorts of optimizations. ForEach does lots of work: it gets the enumerator and then enumerates through the collection using methods such as <code>MoveNext()</code>. They all take time, and you would think that it is much slower than using a <code>for</code> loop. However, these optimizations make the difference negligible when using For or ForEach on an array or <code>List&lt;T&gt;</code>.</p>
			<p>But suppose you use your own collection where you have implemented <code>IEnumerable&lt;T&gt;</code> and <code>IEnumerator&lt;T&gt;</code>. In that case, chances are the C# team did not optimize for that in the compiler. That might result in a slower loop than a regular <code>for</code> loop.</p>
			<p>As always, benchmark whether using the much more readable ForEach is better than a regular <code>for</code> loop.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Strings</h1>
			<p>In the old<a id="_idIndexMarker165"/> days, strings used to be simple. You identified the length needed to store a sentence, allocated memory, and copied each character’s ASCII values in a single row. Then, you put a 0 (zero) at the end, and you were done. Easy. But then you realized you needed something more dynamic as you were unsure how long the string would be. So, you wrote code to change the buffer required to store it. You also realized that you needed to have some operations on those characters. For instance, you might have wanted to know how long the string was and not have to count the characters every time, or maybe you wanted to convert all characters into uppercase. So, you wrote code for that as well. At that point, you had some data in the form of characters (with the zero at the end) and some methods on that data. That is the definition of a class, so in C++, you write a <code>String</code> class.</p>
			<p>Things got even more complicated when you realized that other cultures used other characters. Luckily, others also realized this, so<a id="_idIndexMarker166"/> they created the <strong class="bold">Unicode standard</strong>. But now, instead of storing a single byte per character, you must store a Unicode character. And that can be anything from 8 bits (in UTF-8) to 4 bytes. Then, you learned that although a single character can take 32 bits, that is technically incorrect: that applies to code points. A code point usually <em class="italic">is</em> the character, but sometimes, it isn’t. In those situations, the character you want to display has multiple code points in the string. That’s when most people give up.</p>
			<p>The good news is that you no longer have to worry about that since we have the <code>System.String</code> class in .NET. It takes care of all of those details, and they look deceivingly simple. Assigning a sentence to an instance of that <code>String</code> class is as simple as the following code:</p>
			<pre class="source-code">
string someMessage = "Hello, World!";
string theSameEmoji = "\U0001F600";
string someEmoji = "😀";</pre>			<p>The first line assigns <code>"Hello, World!"</code> to the <code>someMessage</code> variable. When we do this, the compiler generates all the code necessary to create an instance of the <code>System.String</code> class and initializes it with the correct text.</p>
			<p>The following two lines contain the same Unicode characters: a friendly smiley. The first uses the Unicode character, while the second uses the actual character. Yes, this is valid C#!</p>
			<p>Strings <a id="_idIndexMarker167"/>are reference types, so they live on the heap. We learned that the heap is slower than the stack earlier, but we have no choice in this case. The pointer is copied when we copy a reference type to a new variable. This means we have two variables pointing to the same data structure. This also happens when we copy a string: a new pointer is made and points to that class’s same instance.</p>
			<p>Strings are immutable. You cannot change the contents of a string. If you do that, the CLR creates a new string, and the old one is ready to be garbage collected. Again, this might lead to unwanted performance issues.</p>
			<p>There are some other things we must consider when talking about string performance. Let’s go through them.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Use StringBuilder for concatenation</h2>
			<p>When<a id="_idIndexMarker168"/> talking about string performance, this one gets the most attention. And for good reason: this simple “trick” can help get your application faster. The idea is that when you’re in a loop, do not concatenate strings. Create a <code>StringBuilder</code> object and use that. The difference in performance is enormous. And that makes sense: changing a string is impossible, so each time you add to one, a new one is created, the content is copied with the added string on top of it, and the old one is discarded.</p>
			<p>Use <code>StringBuilders</code> in loops. You can go ahead and just do it.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Interning strings</h2>
			<p>Strings are<a id="_idIndexMarker169"/> interned. If you have a string in your code and the actual text is known at compile time, any other string with the same content will point to the same class. Have a look at this code:</p>
			<pre class="source-code">
string str1 = "Hello Systems Programmers";
string str2 = "Hello Systems Programmers";
// Reference equality test
if (Object.ReferenceEquals(str1, str2))
    Console.WriteLine("Both strings point to the same         memory location.");
else
    Console.WriteLine("Strings do not point to the same         memory location.");</pre>			<p>When <a id="_idIndexMarker170"/>you run this code, you will get a message stating that both strings point to the same memory location.</p>
			<p>But if you read the contents of both strings from the console, use <code>Console.ReadLine()</code>. If you enter the same string twice, they will not be interned. This is because interning happens at compile time.</p>
			<p>You could call <code>String.Intern</code> yourself. This checks to see if the string you wish to intern is already there, and if so, it makes it point to that instead of having its own copy. This could save a lot of memory, but it has a performance penalty. So, use it wisely.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Use String.Concat or String.Join</h2>
			<p>I said that <a id="_idIndexMarker171"/>you should use <code>StringBuilder</code> when joining strings in a loop. But creating a <code>StringBuilder</code> object is a bit overkill if you’re outside a loop and only want to add to a string once. In that case, you should use <code>String.Concat</code> or <code>String.Join</code>.</p>
			<p>Just to be<a id="_idIndexMarker172"/> clear here: if you are looping, use <code>StringBuilder</code>. The <code>StringBuilder</code> object is the fastest way to concatenate strings. But creating an instance of a <code>StringBuilder</code> class takes time (it is a class, thus on the heap). If you only want to add one or two strings to an existing one, <code>String.Concat</code> is faster overall than having a <code>StringBuilder</code> object.</p>
			<p>That looks like this:</p>
			<pre class="source-code">
var startString = "Welcome to System ";
var longString = startString.Concat("Programmers!");</pre>			<p>The <code>String.Join</code> object is another good way to build up strings. You can use this one when you want to combine a collection of items into one string. The list of items can be anything <a id="_idIndexMarker173"/>since the <a id="_idIndexMarker174"/>CLR calls <code>ToString()</code> on them. Here, <code>ToString()</code> needs to make sense; otherwise, you’ll get a long list of class names.</p>
			<p>It looks like this:</p>
			<pre class="source-code">
string[] myElements = {"C#", "VB.Net", "F#", "Delphi.Net"};
string result = string.Join(",", myElements);</pre>			<p>Printing <code>result</code> will show <code>C#,VB.Net,F#,Delphi.Net</code> on your screen.</p>
			<p>Be careful what you use as the list of elements. If those are <code>ValueTypes</code>, a lot of boxing happens. That negates our performance gain when using the suitable string methods.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Comparison</h2>
			<p>Chances<a id="_idIndexMarker175"/> are that you have to compare strings in your code. There are several ways to improve your performance when doing that. For instance, taking into account a culture takes a lot longer compared to not doing that. If you don’t need a culture-specific check, you should specify that. The same goes for the casing: if you don’t care about the casing when comparing, please don’t use one of the comparisons that take care of that.</p>
			<p>There are several ways to compare strings. The most obvious one is the equality operator:</p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a == b; // true</pre>			<p>In this case, there’s no comparison at all. Since the compiler interns the strings, the pointers point to the same data. The equality checks for that and returns <code>true</code>.</p>
			<p>You could also do it like this:</p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.Equals(b); // true</pre>			<p>This code <a id="_idIndexMarker176"/>does the same thing, with the same caveat concerning the interning. Here, <code>operator == calls Equals()</code>, so it shouldn’t be surprising that the results are the same, with the same performance.</p>
			<p>Now, look at this code:</p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.Equals(b,
StringComparison.InvariantCultureIgnoreCase); // true</pre>			<p>This way of comparing is significantly slower than the previous examples. The CLR now has to compare the strings in all their different appearances: in all sorts of cultures and all casings.</p>
			<p>This way works brilliantly if you need it, but if you don’t, please omit the options!</p>
			<p>I see many people writing this sort of code:</p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.ToUpper() == b.ToUpper(); // true</pre>			<p>This way of comparing is the worst way of doing this. Calling <code>ToUpper()</code> doesn’t convert a string into all uppercase. Instead, it creates a new string with all uppercase characters. Again, strings are immutable, so the runtime creates a new one whenever you change something. Here, we are doing that twice so that we can compare them.</p>
			<p>Using <code>StringComparison.IgnoreCase</code> is about five times as fast compared to calling <code>ToUpper()</code> (or <code>ToLower()</code> for that matter).</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Preallocating StringBuilder</h2>
			<p>One final tip: knowing the length of the resulting string when using <code>StringBuilder</code> helps <a id="_idIndexMarker177"/>tremendously if you tell that class about that. Preallocating helps optimize the code and reduces many allocations, resulting in better performance.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Writing unsafe code</h1>
			<p>A word of <a id="_idIndexMarker178"/>warning before we start talking about unsafe code. There is a reason it is called “unsafe.” You could be in for much trouble when you leave safe code.</p>
			<p>The CLR checks many things for you when you run your code. For instance, it ensures type safety and ensures you are not playing around with spaces in memory that are not yours to play with.</p>
			<p>In the “old” days, when using C++ or C in Windows development, this was the primary source of program crashes. Developers made a slight mistake in their pointer arithmetic and ended up reading or writing memory they had no access to. The operating system immediately killed your process, and you got that dreaded <code>AccessViolationException</code> error. This is the ultimate slap on the wrist: the operating system telling you to stay out of someone else’s memory. Sometimes, it would be worse: the operating system might not have caught it, and you messed up the operating system or another program. That could lead to even worse situations: the whole machine could crash.</p>
			<p>The safe environment of the CLR in .NET has practically removed that completely. The CLR governs everything you do and ensures you stay in the areas where you are allowed to stay.</p>
			<p>You’ve probably realized that this is nice, but checking what’s happening always has a performance hit. Nothing comes for free. We give up some performance in exchange for a stable system.</p>
			<p>If you want that performance back, you could tell the CLR to stay out of your way. The CLR will obey and hand over the reins to you. Again, you are on your own and responsible for not messing things up. But things run a bit faster now!</p>
			<p>Let’s consider an example.</p>
			<p>An array is a pointer to a consecutive list of items. So, <code>int[1000]</code> is just a pointer to a long list of a thousand integers, all nicely lined up.</p>
			<p>You can access these items in the list by giving the array the index of the item you want. First, the CLR checks if the array has been initialized and not pointing to some weird random place in memory. Then, it checks if your index falls in the range that the CLR allocated for the array. If that checks out, it gets and returns the item for you. Nice.</p>
			<p>The following code example iterates through the array and adds up all the values:</p>
			<pre class="source-code">
long sum = 0;
for (int i = 0; i &lt; array.Length; ++i)
{
    sum += array[i];
}</pre>			<p>This piece <a id="_idIndexMarker179"/>of code works nicely, but it can be faster. All those checks take time, and we might decide we don’t need them. We tell the CLR to take a break and leave it all to us!</p>
			<p>The following snippet shows how to do this:</p>
			<pre class="source-code">
unsafe
{
    long sum = 0;
    fixed (int* pArray = array)
    {
        int* pEnd = pArray + array.Length;
        for (int* p = pArray; p &lt; pEnd; p++)
        {
            sum += *p;
        }
    }
}</pre>			<p>We declare the block we want to optimize with the <code>unsafe</code> keyword. Everything in that block is now no longer checked.</p>
			<p>Then, we retrieve the pointer to the array. We mark it as <code>fixed</code>. This keyword means the garbage collector doesn’t move the array until we are done with it. It would be disastrous if the garbage collector moved the array to another place in memory when we accessed it. The <code>fixed</code> keyword prevents that.</p>
			<p>Then, we get the pointer to the end of the array in memory so that we know when to end. In the <code>for</code> loop, we get the pointer to the elements, read the data at that memory position, and add the <code>sum</code> variable.</p>
			<p>This piece <a id="_idIndexMarker180"/>of code works fine. It is also faster than the safe version. But just for fun, mess around a bit with the pointers. Instead of letting it end at the end of the array, let it end at that position plus <code>0xFFFF</code>. Now, there is no way to tell what’s going to happen. It might continue reading past the end of the array, getting all those byes and adding them to <code>sum</code>. That would mean you are getting the wrong result. It is more likely that you get the <code>AccessViolationException</code> error, followed by your program being terminated.</p>
			<p>We use unsafe code to improve performance, such as in the preceding example, but also when we need to interact with native libraries written in C/C++. But if you can avoid it without sacrificing performance too much, please do.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Compiler optimizations</h1>
			<p>I have said it <a id="_idIndexMarker181"/>before and will repeat it here: don’t try to outsmart the compiler. The C# compiler is a fantastic piece of software that can do tricks we can’t even think of. But sometimes, we can help the compiler make choices that affect performance in a good way.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Aggressive optimization</h2>
			<p>Look at the<a id="_idIndexMarker182"/> following method:</p>
			<pre class="source-code">
private int AddUp(int a, int b)
{
    return a + b;
}</pre>			<p>I am sure you agree that this is not an exciting method. Calling this, however, does take a lot of time: the calling method has to store the return address, move all parameters (the integer values, <code>a</code> and <code>b</code>) to the right place, jump to the method, retrieve the parameters, do the actual work, store the return value in the right place, retrieve the return address, jump to that return address, and assign the result to the variable in the calling method.</p>
			<p>The compiler <a id="_idIndexMarker183"/>knows this. So, in this particular case, it will probably optimize it and “inline” it. But if you think the compiler doesn’t know about this, you can instruct it to take a closer look at the code and be a bit more aggressive about it. You do that like so:</p>
			<pre class="source-code">
[MethodImpl(MethodImplOptions.AggressiveOptimization)]
private int AddUp(int a, int b)
{
    return a + b;
}</pre>			<p>This tells the compiler to be aggressive when optimizing the code. This is a hint to the compiler: there is no guarantee it will do what you ask. But in this case, it will probably honor your request (again, it would likely have done it already) and inline the method.</p>
			<p>Inlining means it takes the method’s body and injects it into the calling method directly. So, instead of all this copying and moving I described previously, it will now execute the code inline, as if it is part of the original method.</p>
			<p>This is way faster, of course. It also means your original method gets bigger: it now contains that extra bit of code, as do all the other methods that use this <code>AddUp()</code> method. It gets copied all over the place.</p>
			<p>It is a matter of choice: more performance over less efficient memory usage.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>The optimize flag</h2>
			<p>The compiler can<a id="_idIndexMarker184"/> optimize your code. But it doesn’t always do that. You can<a id="_idIndexMarker185"/> add the <code>optimize</code> flag to the compiler to force optimization.</p>
			<p>There are several ways to do that. First, you can add it to the command line if you use that to build your code:</p>
			<pre class="console">
dotnet build -c Release -property:Optimize=true</pre>			<p>Alternatively, you can use <code>MSBuild</code>:</p>
			<pre class="source-code">
msbuild /p:Configuration=Release /p:Optimize=true</pre>			<p>They both achieve the same result.</p>
			<p>You could also <a id="_idIndexMarker186"/>set it as an option in your <code>CSProj</code> file. The best way to do that is to add it to the project properties:</p>
			<div><div><img alt="Figure 2.1: The project properties showing the Optimize code option" src="img/B20924_03_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The project properties showing the Optimize code option</p>
			<p>As you can see, you can set <strong class="bold">Optimize code</strong> for <strong class="bold">Debug</strong> and <strong class="bold">Release</strong>.</p>
			<p>This will add or change the following setting to your <code>.</code><code>csproj</code> file:</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;Optimize&gt;True&lt;/Optimize&gt;
&lt;/PropertyGroup&gt;</pre>			<p>It’s good to know that by default, programs compiled in the <strong class="bold">Debug</strong> configuration have optimizations turned off. In contrast, programs compiled in the <strong class="bold">Release</strong> configuration have it turned on.</p>
			<p>When debugging, you are better off using non-optimized code. When releasing, the opposite applies.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Next steps</h1>
			<p>Performance – that was what this chapter was all about. We learned why it is crucial, especially for system programming, to write software that is as fast and efficient as possible.</p>
			<p>First, we looked at the BCL and the CLR and saw how the different data types can affect performance, but also that things don’t always behave as expected.</p>
			<p>Then, we examined the types in the CTS and identified which types give us the best-performing systems and what to avoid. We spent quite some time in the <code>Strings</code> class. We also learned how to rewrite our code so that it uses the best tools this class gives us to make it behave faster.</p>
			<p>After, we dove into the dark underworld of unsafe types and saw that they could give us even more performance but with the downside of the possibility of crashing our application, or even our system, in the most spectacular way.</p>
			<p>Finally, we looked at ways to help the compiler make our systems even faster. Here, we learned that the compiler is smart enough to make those changes. It’s worth repeating that you shouldn’t try to outsmart the system. You really should only use the unsafe code and compiler tricks if benchmarking shows that you have an issue. Otherwise, leave those two alone. However, they are good tricks to understand if you do need them.</p>
			<p>However, better performance often leads to less efficient memory usage. It is a trade-off. Sometimes, it is better to have a more memory-efficient system than it is to have a fast system. Sometimes, you have to mix and match. In the next chapter, we’ll consider memory and cover these aspects in greater detail.</p>
		</div>
	</body></html>