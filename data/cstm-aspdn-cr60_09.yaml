- en: '*Chapter 9*: Working with Endpoint Routing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用端点路由'
- en: In this chapter, we will talk about the new endpoint routing in **ASP.NET**
    **Core**. We will learn what endpoint routing is, how it works, where it is used,
    and how you are able to create your own routes to your own endpoints.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**ASP.NET Core**中的新端点路由。我们将学习端点路由是什么，它是如何工作的，它在哪些地方被使用，以及你如何创建自己的路由到自己的端点。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring endpoint routing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索端点路由
- en: Creating custom endpoints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义端点
- en: Creating a more complex endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个更复杂的端点
- en: 'The topics in this chapter refer to the routing layer of the ASP.NET Core architecture:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的主题涉及ASP.NET Core架构的路由层：
- en: '![Figure 9.1 – The ASP.NET Core architecture'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – ASP.NET Core架构'
- en: '](img/Figure_9.1_B17996.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B17996.jpg)'
- en: Figure 9.1 – The ASP.NET Core architecture
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – ASP.NET Core架构
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this series, we just need to set up a small, empty web application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个系列，我们只需要设置一个小型的空Web应用程序：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s it! Open the application with Visual Studio Code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！使用Visual Studio Code打开应用程序：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at: [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的**GitHub**仓库中找到：[https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09)。
- en: Exploring endpoint routing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索端点路由
- en: To learn about **endpoint routing**, you need to learn what an *endpoint* is
    and what *routing* is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解**端点路由**，你需要了解什么是**端点**以及什么是**路由**。
- en: '**Endpoints** are part of an app that get executed when a route maps the incoming
    request to it. Let''s analyze this definition in a little more detail.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**端点**是应用程序的一部分，当路由将进入的请求映射到它时，它会被执行。让我们更详细地分析这个定义。'
- en: A client usually requests a resource from a server. In most cases, the client
    is a browser. The resource is defined by a URL, which points to a specific target.
    In most cases, the target is a web page. It could also be a mobile app that requests
    specific data from a JSON web API. What data the app requests is defined in the
    URL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通常从服务器请求资源。在大多数情况下，客户端是浏览器。资源由URL定义，指向特定的目标。在大多数情况下，目标是网页。它也可能是一个请求特定数据的移动应用，该数据来自JSON
    Web API。应用请求的数据在URL中定义。
- en: 'This means that the incoming request is also defined by the URL. The executing
    endpoint, on the other hand, is mapped to a specific route. A route is a URL or
    a pattern for a URL. ASP.NET Core developers are already familiar with such a
    route pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着进入的请求也由URL定义。另一方面，正在执行的端点映射到特定的路由。路由是一个URL或URL的模式。ASP.NET Core开发者已经熟悉这样的路由模式：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the route or the route pattern matches the URL of the incoming request, the
    request gets mapped to that endpoint. In this case, the request gets mapped to
    the MVC endpoint.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由或路由模式与进入请求的URL匹配，请求就会被映射到该端点。在这种情况下，请求被映射到MVC端点。
- en: 'ASP.NET Core can map to the following endpoints:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core可以映射到以下端点：
- en: Controllers (for example, MVC or web APIs)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器（例如，MVC或Web API）
- en: Razor Pages
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor Pages
- en: SignalR (and Blazor Server)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR（和Blazor Server）
- en: gRPC services
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC服务
- en: Health checks
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查
- en: Most of the endpoints have really simple route patterns. Only the MVC and web
    API endpoints use the more complex patterns. The route definitions of Razor pages
    are based on the folder and file structure of the actual pages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数端点都有非常简单的路由模式。只有MVC和Web API端点使用更复杂的模式。Razor页面的路由定义基于实际页面的文件夹和文件结构。
- en: Before endpoints were introduced in ASP.NET Core 2.2, routing was only a thing
    in MVC and web APIs. The implicit routing in **Razor Pages** was built-in there,
    and SignalR wasn't really ready. Blazor and gRPC weren't a thing back then, and
    the health checks were initially implemented as a middleware component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 2.2引入端点之前，路由仅在MVC和Web API中存在。**Razor Pages**中的隐式路由是内置的，而SignalR还没有准备好。那时，Blazor和gRPC还没有出现，健康检查最初被实现为一个中间件组件。
- en: Endpoint routing was introduced to separate routing from the actual endpoints.
    This makes the framework much more flexible, and it means that new endpoints don't
    need to implement their own kind of routing. This way, the endpoints can use the
    existing flexible routing technology to get mapped to a specific route.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 端点路由被引入以将路由与实际端点分离。这使得框架更加灵活，并且意味着新的端点不需要实现自己的路由方式。这样，端点可以使用现有的灵活路由技术来映射到特定的路由。
- en: Next, we'll see how you can create your own custom endpoints.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何创建自己的自定义端点。
- en: Creating custom endpoints
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义端点
- en: 'The easiest way to create an endpoint is by using the lambda-based endpoints:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建端点最简单的方法是使用基于 lambda 的端点：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This maps the `/map` route to a simple endpoint that writes the word `"OK"`
    to the response stream.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `/map` 路由映射到一个简单的端点，该端点将单词 `"OK"` 写入响应流。
- en: A Note regarding Prior .NET 6.0 Versions
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于先前 .NET 6.0 版本的一则说明
- en: Prior to .NET 6.0, you would map custom endpoints on the `endpoints` object
    inside the lambda that gets passed to the `UseEndpoints` method in the `Startup.cs`
    file. With .NET 6.0 and the new `app` object in the `Program.cs` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6.0 之前，你会在 `Startup.cs` 文件中传递给 `UseEndpoints` 方法的 lambda 中定义的 `endpoints`
    对象上映射自定义端点。在 .NET 6.0 及 `Program.cs` 文件中的新 `app` 对象中。
- en: You might need to add the `Microsoft.AspNetCore.Http` namespace to the `using`
    statements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要将 `Microsoft.AspNetCore.Http` 命名空间添加到 `using` 语句中。
- en: 'You can also map specific HTTP methods (such as `GET`, `POST`, `PUT`, and `DELETE`)
    to an endpoint. The following code shows how to map the `GET` and `POST` methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将特定的 HTTP 方法（如 `GET`、`POST`、`PUT` 和 `DELETE`）映射到一个端点。以下代码展示了如何映射 `GET` 和
    `POST` 方法：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also map two or more HTTP methods to an endpoint:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将两个或多个 HTTP 方法映射到一个端点：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These endpoints look like the lambda-based terminating middleware components
    that we saw in [*Chapter 8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing
    Custom Middleware*. These are middleware components that terminate the pipeline
    and return a result, such as HTML-based views, JSON structured data, or similar.
    Endpoint routing is a more flexible way to create an output, and it should be
    used in all versions from ASP.NET Core 3.0 onward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点看起来像我们在 [*第 8 章*](B17996_08_ePub.xhtml#_idTextAnchor124) *编写自定义中间件* 中看到的基于
    lambda 的终止中间件组件。这些是终止管道并返回结果的中间件组件，例如基于 HTML 的视图、JSON 结构化数据或类似内容。端点路由是创建输出的更灵活方式，并且应该从
    ASP.NET Core 3.0 及以后的版本开始使用。
- en: 'In [*Chapter 8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing Custom Middleware*,
    we saw that we can branch pipelines like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B17996_08_ePub.xhtml#_idTextAnchor124) *编写自定义中间件* 中，我们看到了我们可以像这样分支管道：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This also creates a route, but this will only listen to URLs that start with
    `/map`. If you would prefer to have a routing engine that handles patterns such
    as `/map/{id:int?}` to also match `/map/456` and not `/map/abc`, you should use
    the new routing, as demonstrated earlier in this section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这也创建了一个路由，但这个路由只会监听以 `/map` 开头的 URL。如果你希望有一个能够处理类似 `/map/{id:int?}` 的模式的路由引擎，同时匹配
    `/map/456` 而不是 `/map/abc`，你应该使用新的路由，就像在本节前面所展示的那样。
- en: Those lambda-based endpoints are useful for simple scenarios. However, because
    they are defined in `Program.cs`, things will quickly become messy if you start
    to implement more complex scenarios using this kind of lambda-based approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于 lambda 的端点对于简单场景很有用。然而，由于它们定义在 `Program.cs` 中，如果你开始使用这种基于 lambda 的方法实现更复杂的场景，事情会很快变得混乱。
- en: So, we should try to find a more structured way to create custom endpoints.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该尝试找到一种更结构化的方式来创建自定义端点。
- en: Creating a more complex endpoint
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更复杂的端点
- en: 'In this section, we will create a more complex endpoint, step by step. Let''s
    do this by writing a really simple health check endpoint, similar to what you
    might need if you were to run your application inside a **Kubernetes** cluster,
    or just to tell others about your health status:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步创建一个更复杂的端点。让我们通过编写一个非常简单的健康检查端点来实现，这类似于如果你在 **Kubernetes** 集群内部运行应用程序或只是告诉他人你的健康状态时可能需要的情况：
- en: 'Microsoft advices starting with the definition of the API to add the endpoint
    from the developer''s point of view. We do the same here. This means that we will
    add a `MapSomething` method first, without an actual implementation. This will
    be an extension method on the `IEndpointRouteBuilder` object. We are going to
    call it `MapMyHealthChecks`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软建议从定义API开始，从开发者的角度添加端点。我们在这里也是这样做。这意味着我们首先会添加一个`MapSomething`方法，但不包含实际实现。这将是一个在`IEndpointRouteBuilder`对象上的扩展方法。我们将称之为`MapMyHealthChecks`：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new endpoint should be added in the same way as the prebuilt endpoints,
    so as not to confuse the developer who needs to use it.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的端点应该以与预构建端点相同的方式添加，以免混淆需要使用它的开发者。
- en: Now that we know how the method should look, let's implement it.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经知道了这个方法应该是什么样子，让我们来实施它。
- en: 'Create a new static class called `MapMyHealthChecksExtensions` and place an
    extension method inside the `MapMyHealthChecks` object that extends `IEndpointRouteBuilder`
    and returns an `IEndpointConventionBuilder` object. I placed it in the `MapMyHealthChecksExtensions.cs`
    file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的静态类`MapMyHealthChecksExtensions`，并在`MapMyHealthChecks`对象内部放置一个扩展方法，该扩展方法扩展`IEndpointRouteBuilder`并返回一个`IEndpointConventionBuilder`对象。我将其放置在`MapMyHealthChecksExtensions.cs`文件中：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just the skeleton. Let's start with the actual endpoint first before
    using it.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是一个框架。让我们先从实际的端点开始，然后再使用它。
- en: 'The actual endpoint will be written as a *terminating* middleware component
    – that is, a middleware component that doesn''t call the next one (see [*Chapter
    8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing Custom Middleware*) and creates
    an output to the response stream:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的端点将被编写为一个*终止*中间件组件——也就是说，一个不调用下一个组件的中间件组件（参见[*第8章*](B17996_08_ePub.xhtml#_idTextAnchor124)，*编写自定义中间件*）并创建输出到响应流：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The actual work is done in the `Invoke` method. Currently, this doesn't really
    do more than respond with `OK` in plaintext and the `200` HTTP status, which is
    fine if you just want to show that your application is running. Feel free to extend
    the method with actual checks, such as checking for the availability of a database
    or related services, for example. Then, you would need to change the HTTP status
    and the output related to the result of your checks.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际的工作是在`Invoke`方法中完成的。目前，这实际上并没有做更多的事情，只是以纯文本形式响应`OK`和`200` HTTP状态，如果你只是想显示你的应用程序正在运行，这是完全可以接受的。你可以自由地扩展这个方法，添加实际的检查，例如检查数据库或相关服务的可用性，例如。然后，你需要更改HTTP状态和与检查结果相关的输出。
- en: Let's use this terminating middleware.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用这个终止中间件。
- en: 'Let''s go back to the skeleton of the `MapMyHealthChecks` method. We now need
    to create our own pipeline, which we map to a given route. Place the following
    lines in that method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`MapMyHealthChecks`方法的框架。我们现在需要创建自己的管道，并将其映射到给定的路由。将以下行放置在该方法中：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach allows you to add some more middleware just for this new pipeline.
    The `WithDisplayName` extension method sets the configured display name to the
    endpoint.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法允许你只为这个新的管道添加一些额外的中间件。`WithDisplayName`扩展方法将配置的显示名称设置为端点。
- en: 'That''s it! Press *F5* in your IDE to start the application and call `https://localhost:7111/myhealth`
    in your browser. You should see **OK** in your browser:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！在你的IDE中按*F5*启动应用程序，并在浏览器中调用`https://localhost:7111/myhealth`。你应该在浏览器中看到**OK**：
- en: '![Figure 9.2 – A screenshot of the endpoint routing output](img/Figure_9.2_B17996.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 端点路由输出的截图](img/Figure_9.2_B17996.jpg)'
- en: Figure 9.2 – A screenshot of the endpoint routing output
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 端点路由输出的截图
- en: Please note the port number might vary. You can also convert an already existing
    terminating middleware component to a routed endpoint to benefit from much more
    flexible routing. And that's it for this chapter!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意端口号可能不同。你还可以将现有的终止中间件组件转换为路由端点，以获得更灵活的路由。这就是本章的全部内容！
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: ASP.NET Core knows many ways in which to work with a request and to provide
    information to the requesting client. Endpoint routing is a way to provide resources
    based on the requested URL and the requested method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core知道许多处理请求和向请求客户端提供信息的方式。端点路由是一种基于请求的URL和请求方法提供资源的方式。
- en: In this chapter, you learned how to use a terminating middleware component as
    an endpoint that gets mapped to the new routing engine to be more flexible, matching
    the routes by which you want to serve the information to the requesting client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用终止中间件组件作为端点，并将其映射到新的路由引擎，以实现更高的灵活性，匹配您希望用于向请求客户端提供信息的路由。
- en: Every web application needs to know its users to allow or restrict access to
    specific areas of the application or to specific data. In the next chapter, we
    show how to configure authentication to recognize your users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应用程序都需要了解其用户，以便允许或限制对应用程序特定区域或特定数据的访问。在下一章中，我们将展示如何配置身份验证以识别您的用户。
