- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Advanced MVVM Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 MVVM 概念
- en: After learning the basics of the MVVM pattern and its implementation in WinUI,
    it’s now time to build on that knowledge base to handle some more advanced techniques.
    Now, you will learn how to keep components loosely coupled and testable when adding
    new dependencies to the project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了 MVVM 模式的基础知识及其在 WinUI 中的实现之后，现在是时候在此基础上构建知识库，以处理一些更高级的技术了。现在，你将学习如何在向项目中添加新依赖项时，保持组件松散耦合且可测试。
- en: Few modern applications have only a single page or window. There are MVVM techniques
    that can be leveraged to navigate between pages from a `ViewModel` command without
    being coupled to the UI layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用很少只有单个页面或窗口。有一些 MVVM 技巧可以用来在 `ViewModel` 命令之间导航页面，而不与 UI 层耦合。
- en: 'In this chapter, you will learn about the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下概念：
- en: Understanding the basics of **Dependency** **Injection** (**DI**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入（DI）的基本概念
- en: Leveraging DI to expose `ViewModel` classes to WinUI views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用依赖注入（DI）将 `ViewModel` 类暴露给 WinUI 视图
- en: Using MVVM and `x:Bind` to handle additional UI events with event handlers in
    the ViewModel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVVM 和 `x:Bind` 在 ViewModel 中处理额外的 UI 事件
- en: Navigating between pages with MVVM and DI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVVM 和 DI 在页面之间导航
- en: By the end of this chapter, you will have a deeper understanding of the MVVM
    pattern and will know how to decouple your view models from any external dependencies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更深入地理解 MVVM 模式，并将知道如何将你的 ViewModel 与任何外部依赖项解耦。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the examples in this chapter, please reference the *Technical
    requirements* section in [*Chapter 2*](B20908_02.xhtml#_idTextAnchor044), *Configuring
    the Development Environment and Creating* *the Project*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，请参考[*第 2 章*](B20908_02.xhtml#_idTextAnchor044)中的*技术要求*部分，*配置开发环境和创建项目*。
- en: 'You will find the code files for this chapter here: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的代码文件：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04)。
- en: Understanding the basics of DI
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖注入（DI）的基本概念
- en: 'Before starting down the path of using DI in our project, we should take some
    time to understand what DI is and why it is fundamental for building modern applications.
    You will often see DI referenced with another related concept, **Inversion of
    Control** (**IoC**). Let’s discuss these two concepts by doing the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目中使用依赖注入（DI）之前，我们应该花些时间了解 DI 是什么以及为什么它是构建现代应用的基础。你经常会看到 DI 与另一个相关概念**控制反转（IoC**）一起提及。让我们通过以下方式来讨论这两个概念：
- en: Clarify the relationship between them
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐明它们之间的关系
- en: Prepare you to use DI properly in this chapter
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章将为你准备正确使用 DI 的知识
- en: 'DI is used by modern developers to inject dependent objects into a class rather
    than creating instances of the objects inside the class. There are several ways
    to inject those objects:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发者使用依赖注入（DI）将依赖对象注入到类中，而不是在类内部创建对象的实例。有几种方法可以注入这些对象：
- en: '**Method injection**: Objects are passed as parameters to a method in the class'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法注入**：对象作为参数传递给类中的方法'
- en: '**Property injection**: Objects are set through properties'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性注入**：对象通过属性设置'
- en: '**Constructor injection**: Objects are passed as constructor parameters'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：对象作为构造函数参数传递'
- en: The most common method of DI is constructor injection. In this chapter, we will
    be using both property injection and constructor injection. Method injection will
    not be used because it is not common to use methods to set a single object’s value
    in .NET projects. Most developers use properties for this purpose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）最常见的方法是构造函数注入。在本章中，我们将使用属性注入和构造函数注入。方法注入将不会使用，因为在 .NET 项目中通常不使用方法来设置单个对象的值。大多数开发者使用属性来完成这个目的。
- en: 'IoC is the concept that a class should not be responsible for (or have knowledge
    of) the creation of its dependencies. You’re inverting control over object creation.
    This sounds a bit like DI, doesn’t it? Well, DI is one method of achieving this
    IoC in your code. There are other ways to implement IoC, including the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转（IoC）的概念是，一个类不应该负责（或了解）其依赖项的创建。你正在反转对象创建的控制。这听起来有点像 DI，不是吗？好吧，DI 是在代码中实现这种
    IoC 的方法之一。还有其他实现 IoC 的方法，包括以下内容：
- en: '**Delegate**: This holds a reference to a method that can be used to create
    and return an object'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：这个委托持有对可以用来创建和返回对象的方法的引用'
- en: '**Event**: Like a delegate, this is typically used in association with user
    input or other outside actions'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：与委托类似，这通常用于与用户输入或其他外部动作相关联'
- en: '**Service Locator Pattern**: This is used to inject the implementation of a
    service at runtime'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务定位器模式**：这个模式用于在运行时注入服务的实现'
- en: When you separate the responsibilities of object creation and use, it facilitates
    code reuse and increases testability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将对象创建和使用职责分离时，它有助于代码重用并提高可测试性。
- en: The classes that will be taking advantage of DI in this chapter are views and
    ViewModels. So, if we will not be creating instances of objects in those classes,
    where will they be created? Aren’t we just moving the tight coupling somewhere
    else? In a way, that is true, but the coupling will be minimized by centralizing
    it to one part of the project, the `App.xaml.cs` file. If you remember from the
    previous chapter, the `App` class is where we handle application-wide actions
    and data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将利用DI的类是视图和ViewModel。所以，如果我们不会在那些类中创建对象实例，它们将在哪里创建？我们不是只是将紧密耦合移动到了别处吗？从某种意义上说，这是真的，但通过将其集中到项目的某个部分，即`App.xaml.cs`文件，我们可以最小化耦合。如果你还记得上一章，`App`类是我们处理应用程序范围操作和数据的地方。
- en: We are going to use a `App` class to manage the application’s dependencies.
    A DI container is responsible for creating and maintaining the lifetime of the
    objects it manages. The object’s lifetime in the container is usually either *per
    instance* (each object request returns a new instance of the object) or a *singleton*
    (every object request returns the same instance of the object). The container
    is configured in the `App` class, and it makes instances available to other classes
    in the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个`App`类来管理应用程序的依赖。DI容器负责创建和维护它所管理的对象的生存期。在容器中，对象的生存期通常是*实例化*（每个对象请求返回对象的新实例）或*单例*（每个对象请求返回相同的对象实例）。容器在`App`类中配置，并使实例对应用程序中的其他类可用。
- en: In .NET 6 and later, DI is now a part of .NET itself. We will leverage the **host
    builder** configuration in .NET to register our application’s dependencies and
    resolve them in the classes where they are needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6及更高版本中，DI现在是.NET本身的一部分。我们将利用.NET中的**主机构建器**配置来注册应用程序的依赖关系，并在需要的地方解决它们。
- en: 'There are a number of other DI implementations that can be leveraged from MVVM
    frameworks. If you would like to explore some of them, here are their respective
    links:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他可以从MVVM框架中利用的DI实现。如果你想探索其中的一些，以下是它们各自的链接：
- en: '**Unity**: This DI implementation supports all types of .NET applications and
    has a full-featured IOC container ([http://unitycontainer.org/articles/introduction.html)](http://unitycontainer.org/articles/introduction.html)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity**：这个DI实现支持所有类型的.NET应用程序，并具有功能齐全的IOC容器([http://unitycontainer.org/articles/introduction.html](http://unitycontainer.org/articles/introduction.html))'
- en: )
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**DryIoc**: This small, lightweight IOC container supports .NET Standard 2.0
    and .NET 4.5 and later applications ([https://github.com/dadhi/DryIoc](https://github.com/dadhi/DryIoc))'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DryIoc**：这个小型、轻量级的IOC容器支持.NET Standard 2.0和.NET 4.5及更高版本的应用程序([https://github.com/dadhi/DryIoc](https://github.com/dadhi/DryIoc))'
- en: '**Prism**: This MVVM framework does not support WinUI 3, but developers can
    still leverage the DI capabilities ([https://prismlibrary.com/docs/dependency-injection/index.html](https://prismlibrary.com/docs/dependency-injection/index.html))'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prism**：这个MVVM框架不支持WinUI 3，但开发者仍然可以利用DI功能([https://prismlibrary.com/docs/dependency-injection/index.html](https://prismlibrary.com/docs/dependency-injection/index.html))'
- en: These concepts will be easier to understand as we implement the code in our
    application. Now, it’s time to see DI and DI containers in practice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中实现代码时，这些概念将更容易理解。现在，是时候看看DI和DI容器在实际中的应用了。
- en: Using DI with ViewModel classes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ViewModel类与DI结合
- en: 'Most of the popular MVVM frameworks today include a DI container to manage
    dependencies. Because .NET now includes its own DI container, we will use that
    one. The .NET team has incorporated the DI container that used to be bundled with
    **ASP.NET Core**. It’s both lightweight and easy to use. Luckily, this container
    is now available to all types of .NET projects via a **NuGet** package:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数流行的 MVVM 框架都包含一个 DI 容器来管理依赖项。因为 .NET 现在包含了自己的 DI 容器，所以我们将使用它。.NET 团队已经将之前与
    **ASP.NET Core** 一起捆绑的 DI 容器整合进来。它既轻量又易于使用。幸运的是，这个容器现在可以通过 **NuGet** 包供所有类型的 .NET
    项目使用：
- en: 'Open the project from the previous chapter or use the project in the `Start`
    folder in the GitHub repository for this chapter. In the `MyMediaCollection` project,
    open `Microsoft.Extensions.Hosting`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一章的项目或使用 GitHub 仓库中本章的 `Start` 文件夹中的项目。在 `MyMediaCollection` 项目中，打开 `Microsoft.Extensions.Hosting`：
- en: '![Figure 4.1 – Microsoft’s DI NuGet package](img/B20908_04_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 微软的 DI NuGet 包](img/B20908_04_01.jpg)'
- en: Figure 4.1 – Microsoft’s DI NuGet package
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 微软的 DI NuGet 包
- en: Select the package and install the latest stable version. After the installation
    completes, close the `App.xaml.cs`. We will make a few changes here to start using
    the DI container.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包并安装最新稳定版本。安装完成后，关闭 `App.xaml.cs`。我们在这里将进行一些更改以开始使用 DI 容器。
- en: The DI container implements DI through interfaces called `IHostBuilder` and
    `IServiceCollection`. As the names imply, they are intended to create a collection
    of services for the application through a shared host. However, we can add any
    type of class to the container. Its use is not restricted to services. `IServiceCollection`
    builds the container, implementing the `IServiceProvider` interface. In the following
    steps, you will add support for DI to the application.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DI 容器通过名为 `IHostBuilder` 和 `IServiceCollection` 的接口实现依赖注入。正如其名称所暗示的，它们旨在通过共享宿主创建应用程序的服务集合。然而，我们可以将任何类型的类添加到容器中。其使用并不局限于服务。`IServiceCollection`
    构建容器，实现 `IServiceProvider` 接口。在以下步骤中，你将为应用程序添加依赖注入的支持。
- en: 'The first thing you should do is add a `public` property to the `App` class
    that makes the host container available to the project:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该做的第一件事是在 `App` 类中添加一个 `public` 属性，使宿主容器对项目可用：
- en: '[PRE0]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `get` is public, but the property has a `private set` accessor. This
    restricts the creation of the container to the `App` class. Don’t forget to add
    the required `using` statements to the code:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`get` 是公共的，但属性有一个 `private set` 访问器。这限制了容器创建仅限于 `App` 类。别忘了在代码中添加所需的 `using`
    语句：
- en: '[PRE1]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to create a new method that initializes the container, sets
    it to the `public` property, and adds our first dependency:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个新的方法来初始化容器，将其设置为 `public` 属性，并添加我们的第一个依赖项：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the new `RegisterComponents` method, we are creating `HostContainer` and
    its service collection, registering `MainViewModel` as a `Build` method to create
    and return the DI container. Although it’s not strictly required, when adding
    multiple types to the container, it’s a good practice to add dependent objects
    to the service collection first. We’ll be adding more items to the container soon.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在新的 `RegisterComponents` 方法中，我们正在创建 `HostContainer` 和其服务集合，将 `MainViewModel`
    注册为 `Build` 方法以创建和返回 DI 容器。尽管这不是严格必要的，但在向容器添加多个类型时，首先将依赖对象添加到服务集合中是一种良好的做法。我们很快将向容器中添加更多项。
- en: 'Finally, you will call `RegisterComponents` before creating the instance of
    `MainWindow` in the `App.OnLaunched` event handler:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要在 `App.OnLaunched` 事件处理程序中创建 `MainWindow` 实例之前调用 `RegisterComponents`：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s all the code needed to create and expose the DI container to the application.
    Now that we are delegating the creation of `MainViewModel` to the container, you
    can remove the property that exposes a static instance of `MainViewModel` from
    the `App` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建和向应用程序公开 DI 容器所需的全部代码。现在，由于我们将 `MainViewModel` 的创建委托给了容器，你可以从 `App` 类中删除公开
    `MainViewModel` 静态实例的属性。
- en: 'Using the ViewModel controlled by the container is simple. Go ahead and open
    `MainWindow.xaml.cs` and update the `ViewModel` property to remove the initialization.
    Then, set the value of the `ViewModel` property using `HostContainer.Services.GetService`
    from the `App` class before the call to `InitializeComponent`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用由容器控制的 ViewModel 简单。继续打开 `MainWindow.xaml.cs` 并更新 `ViewModel` 属性以删除初始化。然后，在调用
    `InitializeComponent` 之前，使用 `App` 类中的 `HostContainer.Services.GetService` 设置 `ViewModel`
    属性的值：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you build and run the application now, it will work just as it did before.
    However, now our `MainViewModel` instance will be registered in the `App` class
    and managed by the container. As new models, view models, services, and other
    dependencies are added to the project, they can be added to the `HostContainer`
    in the `RegisterComponents` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在构建并运行应用程序，它将像以前一样工作。然而，现在我们的`MainViewModel`实例将在`App`类中注册并由容器管理。随着新模型、视图模型、服务和其他依赖项被添加到项目中，它们可以被添加到`RegisterComponents`方法中的`HostContainer`。
- en: We will be adding page navigation to the app later in this chapter. First, let’s
    discuss the **event-to-command** pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面添加页面导航到应用程序。首先，让我们讨论**事件到命令**模式。
- en: Leveraging x:Bind with events
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用x:Bind和事件
- en: 'In the previous chapter, we bound `ViewModel` commands to the `Command` properties
    of the `Command` property? For this scenario, you have two options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将`ViewModel`命令绑定到`Command`属性的`Command`属性？对于这种情况，您有两个选择：
- en: Use a custom behavior such as `EventToCommandBehavior` in the .NET MAUI Community
    Toolkit. This allows you to wire up a command in the ViewModel to any event.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET MAUI社区工具包中使用自定义行为，例如`EventToCommandBehavior`。这允许您将ViewModel中的命令与任何事件连接起来。
- en: Use `x:Bind` in the view to bind directly to an event handler on the view model.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中使用`x:Bind`直接绑定到视图模型上的事件处理程序。
- en: 'In this application, we will use `x:Bind`. This option will provide compile-time
    type checking and added performance. If you want to learn more about the .NET
    MAUI Community Toolkit, you can read the documentation on Microsoft Learn: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将使用`x:Bind`。此选项将提供编译时类型检查和性能提升。如果您想了解更多关于.NET MAUI社区工具包的信息，可以阅读Microsoft
    Learn上的文档：[https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior)。
- en: 'We want to provide users of the **My Media Collection** application with the
    option to double-click (or double-tap) a row on the list to view or edit its details.
    The new **Item Details** window will be added in the next section. Until then,
    double-clicking an item will invoke the same code as the **Add Item** button,
    as this will become the **Add/Edit Item** button later:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为**我的媒体收藏**应用程序的用户提供双击（或双击）列表中的行以查看或编辑其详细信息的选项。新的**项目详情**窗口将在下一节中添加。在此之前，双击项目将调用与**添加项目**按钮相同的代码，因为这将成为**添加/编辑项目**按钮：
- en: 'Start by adding an `ItemRowDoubleTapped` event handler to the `MainViewModel`
    class that calls the existing `AddEdit` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向`MainViewModel`类添加一个名为`ItemRowDoubleTapped`的事件处理程序，该处理程序调用现有的`AddEdit`方法：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, bind the `ListView.DoubleTapped` event to the ViewModel:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`ListView.DoubleTapped`事件绑定到ViewModel：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <ListView.ItemTemplate>
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ListView.ItemTemplate>
- en: <DataTemplate x:DataType="model:MediaItem">
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <DataTemplate x:DataType="model:MediaItem">
- en: <Grid IsHitTestVisible="False">
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Grid IsHitTestVisible="False">
- en: '...'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: </Grid>
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </Grid>
- en: </DataTemplate>
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </DataTemplate>
- en: </ListView.ItemTemplate>
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </ListView.ItemTemplate>
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now when you run the application, you can either click the **Add Item** button
    or double-click a row in the list to add new items. In the next section, you will
    update the **Add Item** button to be an **Add/Edit** **Item** button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序时，您可以通过点击**添加项目**按钮或双击列表中的行来添加新项目。在下一节中，您将更新**添加项目**按钮以成为**添加/编辑****项目**按钮。
- en: Page navigation with MVVM and DI
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVVM和DI进行页面导航
- en: Until this point, the application has consisted of only a single window. Now
    it’s time to implement page navigation by adding a host `Frame` and two `Page`
    objects so we can handle adding new items or editing existing items. The new `Page`
    will be accessible from the **Add/Edit Item** button or by double-clicking on
    an item in the list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序只包含一个窗口。现在，是时候通过添加一个宿主`Frame`和两个`Page`对象来实现页面导航，这样我们就可以处理添加新项目或编辑现有项目。新的`Page`将通过**添加/编辑项目**按钮或通过在列表中双击项目来访问。
- en: Migrating MainWindow to MainPage
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MainWindow迁移到MainPage
- en: 'If you’re familiar with UWP app development, you should already understand
    page navigation. In UWP, the application consists of only a single window. At
    the root of the window, there is a `Frame` object, which hosts pages and handles
    the navigation between them. To achieve the same result in a desktop WinUI 3 app,
    we will create a new `MainPage`, move all the XAML content from `MainWindow` into
    `MainPage`, and update the `App` class to create a `Frame` as the new content
    of `MainWindow`. Then we can display the same contents by navigating to `MainPage`.
    Let’s get started:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 UWP 应用开发，你应该已经理解了页面导航。在 UWP 中，应用程序仅由一个窗口组成。窗口的根处有一个 `Frame` 对象，它承载页面并处理它们之间的导航。为了在桌面
    WinUI 3 应用中实现相同的结果，我们将创建一个新的 `MainPage`，将 `MainWindow` 中的所有 XAML 内容移动到 `MainPage`
    中，并将 `App` 类更新为创建一个 `Frame` 作为新的 `MainWindow` 内容。然后我们可以通过导航到 `MainPage` 来显示相同的内容。让我们开始吧：
- en: First, add a new folder to the project named `Views`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目中添加一个名为 `Views` 的新文件夹。
- en: Right-click the **Views** folder and select **Add** | **New Item**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Views` 文件夹，选择 **添加** | **新建项**。
- en: On the `MainPage` and click **Create**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainPage` 上点击 **创建**。
- en: Open `MainWindow.xaml` and cut the entire XAML contents of the `Window`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 并剪切掉整个 `Window` 的 XAML 内容。
- en: Open `MainPage.xaml` and paste the XAML from `MainWindow`, replacing the empty
    `Grid` control.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml` 并将 `MainWindow` 中的 XAML 粘贴进去，替换掉空的 `Grid` 控件。
- en: 'You will also need to cut and paste the `xmlns` declaration for `model` from
    `MainWindow` to `MainPage`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要将 `MainWindow` 中的 `xmlns` 声明从 `model` 复制粘贴到 `MainPage` 中：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `MainWindow.xaml.cs`, remove the `ViewModel` variable and the constructor
    code that fetches it from the `HostContainer`. Put this same code into `MainPage.xaml.cs`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 中，删除 `ViewModel` 变量和从 `HostContainer` 中获取它的构造函数代码。将此相同的代码放入
    `MainPage.xaml.cs` 中：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, open `App.xaml.cs` and add some code inside `OnLaunched` to create a
    `rootFrame`, add it to the `MainWindow`, and navigate to `MainPage` before activating
    the window:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `App.xaml.cs` 并在 `OnLaunched` 方法内部添加一些代码来创建一个 `rootFrame`，将其添加到 `MainWindow`
    中，并在激活窗口之前导航到 `MainPage`：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve also added an event handler to handle navigation failures for the `Frame`.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还添加了一个事件处理程序来处理 `Frame` 的导航失败。
- en: 'Make sure to add the necessary `using` statements to the file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将必要的 `using` 语句添加到文件中：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run the app now, it should look and behave just as it did before, but
    now the controls are nested within a `Page` and a `Frame` on the `Window`. Let’s
    add a second page and get ready to start navigating between our list and detail
    pages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，它应该看起来和之前一样，但现在的控件嵌套在 `Window` 中的 `Page` 和 `Frame` 内。让我们添加第二个页面并准备开始在列表页面和详情页面之间导航。
- en: Adding ItemDetailsPage
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 ItemDetailsPage
- en: The full `ItemDetailsPage.xaml` code can be found on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml)).
    You can follow along with the steps in this section or review the final code on
    GitHub.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `ItemDetailsPage.xaml` 代码可以在 GitHub 上找到 ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml))。您可以跟随本节中的步骤，或者在
    GitHub 上查看最终代码。
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The project will not compile successfully until we have added the new ViewModel
    to the project and added it to the DI container for consumption by the view. Before
    we add the ViewModel, we need to create some services to enable navigation and
    data persistence between views.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将新的 ViewModel 添加到项目中并将其添加到 DI 容器以供视图使用之前，项目将无法成功编译。在添加 ViewModel 之前，我们需要创建一些服务以启用视图之间的导航和数据持久性。
- en: 'We will be showing `Page` control. The `Page` will be set as the content and
    navigated to by the `Frame` we created. For more information about page navigation
    with WinUI, you can read this Microsoft Learn article: [https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk](https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示 `Page` 控件。`Page` 将被设置为内容，并通过我们创建的 `Frame` 进行导航。有关使用 WinUI 进行页面导航的更多信息，您可以阅读这篇
    Microsoft Learn 文章：[https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk](https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk)。
- en: 'To add `ItemDetailsPage`, follow these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `ItemDetailsPage`，请按照以下步骤操作：
- en: Right-click the **Views** folder in **Solution Explorer** and select **Add**
    | **New Item**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中的**Views**文件夹上右键单击，然后选择**添加** | **新项**。
- en: On the new item dialog, select `ItemDetailsPage`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目对话框中，选择`ItemDetailsPage`。
- en: 'There are going to be several input controls with some common attributes on
    the page. Start by adding three styles to a `Page.Resources` section just before
    the top-level `Grid` control:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面上将有几个输入控件，具有一些常见的属性。首先，在顶级`Grid`控件之前，在`Page.Resources`部分添加三个样式：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next step, we can assign `AttributeTitleStyle` to each `TextBlock`, `AttributeValueStyle`
    to each `TextBox`, and `AttributeComboValueStyle` to each `ComboBox`. If you need
    to add any other attributes to input labels later, you will only update `AttributeTitleStyle`
    and the attributes will automatically be applied to every `TextBlock` using that
    style.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一步中，我们可以将`AttributeTitleStyle`分配给每个`TextBlock`，`AttributeValueStyle`分配给每个`TextBox`，以及`AttributeComboValueStyle`分配给每个`ComboBox`。如果您以后需要添加任何其他属性到输入标签，您只需更新`AttributeTitleStyle`，属性将自动应用于使用该样式的每个`TextBlock`。
- en: 'The top-level `Grid` will contain three child `Grid` controls to partition
    the view into three areas—a header, the input controls, and the `Grid.RowDefinitions`
    like this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶级`Grid`将包含三个子`Grid`控件，将视图分为三个区域——一个标题、输入控件和`Grid.RowDefinitions`如下：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The header area will contain only a `TextBlock`. You are welcome to design
    this area however you like:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题区域将只包含一个`TextBlock`。您可以根据自己的喜好设计这个区域：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The input area contains a `Grid` with four `RowDefinitions` and two `ColumnDefinitions`
    for the labels and input controls for the four fields that users can currently
    edit:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入区域包含一个`Grid`，有四个`RowDefinitions`和两个`ColumnDefinitions`用于标签和用户可以当前编辑的四个字段的输入控件：
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The item’s `Name` is a free-text entry field, while the others are `ComboBox`
    controls to allow the user to pick values from lists bound to `ItemsSource`. The
    final child element of the top-level `Grid` is a right-aligned horizontal `StackPanel`
    containing the **Save** and **Cancel** buttons:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该项目的`名称`是一个自由文本输入字段，而其他的是`ComboBox`控件，允许用户从绑定到`ItemsSource`的列表中选择值。顶级`Grid`的最后一个子元素是一个右对齐的水平`StackPanel`，包含**保存**和**取消**按钮：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next stage is to add interfaces and services, so let’s work on this next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是添加接口和服务，让我们继续这个工作。
- en: Adding new interfaces and services
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的接口和服务
- en: Now that we have more than a single page to manage in the application, we need
    some services to centralize the page management and abstract the details from
    the `ViewModel` code. Start by creating `Services` and `Interfaces` folders in
    the project. Each service will implement an interface. This interface will be
    used for DI and later, if you were to add unit tests to a test project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在应用程序中管理多个页面，我们需要一些服务来集中页面管理和从`ViewModel`代码中抽象细节。首先，在项目中创建`Services`和`Interfaces`文件夹。每个服务将实现一个接口。这个接口将用于依赖注入（DI），如果将来您要向测试项目添加单元测试，它也会被使用。
- en: Creating a navigation service
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建导航服务
- en: 'The first service we need is a `INavigationService` interface in the `Interfaces`
    folder. The interface defines methods to get the current page name, navigate to
    a specific page, or navigate back to the previous page:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一个服务是`Interfaces`文件夹中的`INavigationService`接口。该接口定义了获取当前页面名称、导航到特定页面或导航回上一页的方法：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, create a `NavigationService` class in the `Services` folder. In the class
    definition, make sure that `NavigationService` implements the `INavigationService`
    interface. The full class can be viewed on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs)).
    Let’s discuss a few highlights.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Services`文件夹中创建一个`NavigationService`类。在类定义中，确保`NavigationService`实现了`INavigationService`接口。完整的类可以在GitHub上查看（[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs)）。让我们讨论一些亮点。
- en: The purpose of a navigation service in MVVM is to store a collection of available
    pages in the application so that when its `NavigateTo` method is called, the service
    can find a page that matches the requested `Name` or `Type` and navigate to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM中，导航服务的目的是在应用程序中存储一组可用的页面，以便当其`NavigateTo`方法被调用时，该服务可以找到一个与请求的`名称`或`类型`匹配的页面并导航到它。
- en: 'The collection of pages will be stored in a `ConcurrentDictionary<T>` collection.
    The `ConcurrentDictionary<T>` functions like the standard `Dictionary<T>`, but
    it can automatically add locks to prevent changes to the dictionary simultaneously
    across multiple threads:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 页面集合将存储在 `ConcurrentDictionary<T>` 集合中。`ConcurrentDictionary<T>` 的功能类似于标准的 `Dictionary<T>`，但它可以自动添加锁，以防止多个线程同时更改字典：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Configure` method will be called when you create `NavigationService` before
    adding it to the DI container. This method is not a part of the `INavigationService`
    interface and will not be available to classes that consume the service from the
    container. There is a check here to ensure views are only added to the service
    once. We check the dictionary to determine whether any pages of the same data
    type exist. If this condition is `true`, then the page has already been registered:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 `NavigationService` 并将其添加到 DI 容器之前，将调用 `Configure` 方法。这个方法不是 `INavigationService`
    接口的一部分，并且不会对从容器中消费服务的类可用。这里有一个检查，以确保视图只添加到服务一次。我们检查字典以确定是否存在相同数据类型的任何页面。如果这个条件是
    `true`，则页面已经注册：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are the implementations of the three navigation methods in the service.
    The two `NavigateTo` methods navigate to a specific page, with the second providing
    the ability to pass a parameter to the page. The third is `GoBack`, which does
    what you would think: it navigates to the previous page in the application. They
    wrap the `Frame` navigation calls to abstract the UI implementation from the view
    models that will be consuming this service:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是服务中三个导航方法的实现。两个 `NavigateTo` 方法导航到特定的页面，第二个方法提供了向页面传递参数的能力。第三个是 `GoBack`，它执行你想象中的操作：导航到应用程序中的上一页。它们封装了
    `Frame` 导航调用，以将 UI 实现从使用此服务的视图模型中抽象出来：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’re ready to start using `NavigationService`, but first, let’s create a data
    service for the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始使用 `NavigationService`，但首先，让我们为应用程序创建一个数据服务。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can jump ahead to implementing the services in the next section if you
    like. The `DataService` and `IDataService` code is available in the completed
    solution on GitHub: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以跳到下一节实现服务。`DataService` 和 `IDataService` 代码可在 GitHub 上的完成解决方案中找到：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection).
- en: Creating a data service
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据服务
- en: The data on `MainPage` of `MainViewModel`. This isn’t going to work very well
    across multiple pages. By using a data service, view models will not need to know
    how the data is created or stored.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel` 的 `MainPage` 上的数据。这不会在多个页面之间很好地工作。通过使用数据服务，视图模型不需要知道数据是如何创建或存储的。'
- en: For now, the data will still be sample records that are not saved between sessions.
    Later, we can update the data service to save and load data from a database without
    any changes to the view models that use the data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，数据仍然是样本记录，这些记录在会话之间不会保存。稍后，我们可以更新数据服务以从数据库中保存和加载数据，而无需更改使用数据的视图模型。
- en: 'The first step is to add an interface named `IDataService` to the `Interfaces`
    folder:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将名为 `IDataService` 的接口添加到 `Interfaces` 文件夹中：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These methods should look familiar to you from previous chapters, but let’s
    briefly review the purpose of each:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法应该让你想起前面的章节，但让我们简要回顾一下每个方法的用途：
- en: '`GetItems`: Returns all the available media items'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItems`: 返回所有可用的媒体项'
- en: '`GetItem`: Finds a media item with the provided `id`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItem`: 根据提供的 `id` 查找媒体项'
- en: '`AddItem`: Adds a new media item to the collection'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddItem`: 向集合中添加新的媒体项'
- en: '`UpdateItem`: Updates a media item in the collection'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateItem`: 更新集合中的媒体项'
- en: '`GetItemTypes`: Gets the list of media item types'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItemTypes`: 获取媒体项类型的列表'
- en: '`GetMedium`: Gets a `Medium` with the provided name'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMedium`: 根据提供的名称获取 `Medium`'
- en: '`GetMediums`: These two methods either get all available mediums or any available
    for the provided `ItemType`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMediums`: 这两个方法要么获取所有可用的媒体，要么获取提供的 `ItemType` 的任何可用媒体'
- en: '`GetLocationTypes`: Gets all the available media locations'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetLocationTypes`: 获取所有可用的媒体位置'
- en: '`SelectedItemId`: Persists the ID of the selected item on `MainPage`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedItemId`: 在 `MainPage` 上持久化所选项的 ID'
- en: Now, create the `DataService` class in the `Services` folder. Make sure that
    `DataService` implements `IDataService` in the class definition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `Services` 文件夹中创建 `DataService` 类。确保 `DataService` 在类定义中实现了 `IDataService`。
- en: 'Again, we will only review parts of the code. You can review the entire implementation
    on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs)).
    The data in `DataService` will be persisted in four lists and the `SelectedItemId`
    property:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们只会审查部分代码。你可以在 GitHub 上审查整个实现（[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs)）。`DataService`
    中的数据将保存在四个列表和 `SelectedItemId` 属性中：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Copy the `PopulateItems` method from `MainViewModel` and modify it to use `List<T>`
    collections and add the `Location` property assignment to each item.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MainViewModel` 复制 `PopulateItems` 方法，并将其修改为使用 `List<T>` 集合，并为每个项目添加 `Location`
    属性赋值。
- en: 'Start by creating the three `MediaItem` objects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建三个 `MediaItem` 对象：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, initialize the `_items` list and add the three `MediaItem` objects you
    just created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始化 `_items` 列表，并添加你刚刚创建的三个 `MediaItem` 对象：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are three other methods to pre-populate the sample data: `PopulateMediums`,
    `Populate``     ItemTypes`, and `PopulateLocationTypes`. All of these are called from the `Data``     Service` constructor. These methods will be updated later to use an **SQLite**
    data store for data persistence.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个其他方法用于预填充示例数据：`PopulateMediums`、`PopulateItemTypes` 和 `PopulateLocationTypes`。所有这些方法都从
    `Data` 服务构造函数中调用。这些方法将在以后更新，以使用 **SQLite** 数据存储进行数据持久化。
- en: 'Most of the `Get` method implementations are very straightforward. The `GetMediums(ItemType
    itemType)` method uses `Medium` objects for the selected `ItemType`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `Get` 方法的实现都非常直接。`GetMediums(ItemType itemType)` 方法使用 `Medium` 对象来处理选定的
    `ItemType`：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not familiar with LINQ expressions, Microsoft has some good documentation
    on the topic: [https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 LINQ 表达式，Microsoft 在这个主题上有一些很好的文档：[https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/)。
- en: 'The `AddItem` and `UpdateItems` methods are also simple. They add to and update
    the `_items` collection:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItem` 和 `UpdateItems` 方法也很简单。它们向 `_items` 集合添加和更新内容：'
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AddItem` method has some basic logic to find the highest `Id` and increment
    it by `1` to use at the new item’s `Id`. `Id` is also returned to the calling
    method in case the caller needs the information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItem` 方法有一些基本的逻辑来找到最高的 `Id` 并将其增加 `1` 以用于新项目的 `Id`。`Id` 也会返回给调用方法，以防调用者需要这些信息。'
- en: The services are all created. It is time to set them up when the application
    launches and consume them in the view models.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都已创建。当应用程序启动时，是时候设置它们并消费它们在视图模型中。
- en: Increasing maintainability by consuming services
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过消费服务提高可维护性
- en: 'Before using the services in view models, open the `RegisterServices` method
    in `App.xaml.cs` and add the following code to register the new services in the
    DI container and register a new `ItemDetailsViewModel` (yet to be created). We’re
    also adding a parameter to the method to pass along to the constructor of the
    `NavigationService`. This will provide access to the `Frame` for page navigation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模型中使用服务之前，打开 `App.xaml.cs` 中的 `RegisterServices` 方法，并将以下代码添加到 DI 容器中注册新服务，并注册一个新的
    `ItemDetailsViewModel`（尚未创建）。我们还在方法中添加了一个参数，将其传递给 `NavigationService` 构造函数。这将提供对
    `Frame` 的访问，以便进行页面导航：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both `INavigationService` and `IDataService` are registered as **singletons**.
    This means that there will be only a single instance of each stored in the container.
    Any state held in these services is shared across all classes that consume them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`INavigationService` 和 `IDataService` 都注册为 **单例**。这意味着容器中将只存储每个的单个实例。这些服务中持有的任何状态都将跨所有使用它们的类共享。'
- en: You will notice that when we’re registering `INavigationService`, we are passing
    the instance we already created to the constructor. This is a feature of Microsoft’s
    DI container and most other DI containers. It allows for initialization and configuration
    of instances before they’re added to the container.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们注册`INavigationService`时，我们正在将已创建的实例传递给构造函数。这是Microsoft的DI容器以及大多数其他DI容器的一个特性。它允许在实例被添加到容器之前进行初始化和配置。
- en: 'We need to make a few changes to `MainViewModel` to consume `IDataService`
    and `INavigationService`, update the `PopulateData` method, and navigate to `ItemDetailsPage`
    when `AddEdit()` is invoked:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`MainViewModel`进行一些更改以消费`IDataService`和`INavigationService`，更新`PopulateData`方法，并在调用`AddEdit()`时导航到`ItemDetailsPage`：
- en: 'Start by adding properties to `MainViewModel` for `INavigationService` and
    `IDataService`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向`MainViewModel`添加`INavigationService`和`IDataService`的属性：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Don’t forget to add a `using` statement for `MyMediaCollection.Interfaces`.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记为`MyMediaCollection.Interfaces`添加一个`using`语句。
- en: 'Next, update the constructor to receive and store the services:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新构造函数以接收和存储服务：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wait, we’ve added two parameters to the constructor but haven’t changed the
    code that adds them to the DI container. How does that work? Well, the container
    is smart enough to pass them because both of those interfaces are also registered.
    Pretty cool!
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等，我们已经向构造函数中添加了两个参数，但还没有更改将它们添加到DI容器的代码。这是怎么工作的呢？嗯，容器足够智能，可以传递它们，因为这两个接口也已经注册了。非常酷！
- en: 'Next, update `PopulateData` to get the data the view model needs from `_dataService`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`PopulateData`以从`_dataService`获取视图模型所需的数据：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You need to add the `AllMediums` string constant with a value of `"All"` to
    the `mediums` collection because it’s not part of the persisted data. It’s only
    needed for the UI filter. Be sure to add this constant definition to `MainViewModel`.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要向`mediums`集合中添加一个名为`AllMediums`的字符串常量，其值为`"All"`，因为它不是持久化数据的一部分。它仅用于UI过滤器。务必将此常量定义添加到`MainViewModel`中。
- en: 'Finally, when the hidden `AddEditCommand` calls the `AddEdit` method, instead
    of adding hardcoded items to the collection, you will pass `selectedItemId` as
    a parameter when navigating to `ItemDetailsPage`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当隐藏的`AddEditCommand`调用`AddEdit`方法时，而不是将硬编码的项目添加到集合中，你将在导航到`ItemDetailsPage`时传递`selectedItemId`作为参数：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s it for `MainViewModel`. Now let’s work on the `ItemDetailsPage`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MainViewModel`来说，这就完成了。现在让我们来处理`ItemDetailsPage`。
- en: Handling parameters in ItemDetailsPage
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ItemDetailsPage中处理参数
- en: 'To accept a parameter passed from another page during navigation, you must
    override the `OnNavigatedTo` method in `ItemDetailsPage.xaml.cs`. The `NavigationEventArgs`
    parameter contains a property named `Parameter`. In our case, we passed an `int`
    containing the selected item’s `Id`. Cast this `Parameter` property to `int` and
    pass it to a method on the `ViewModel` named `InitializeItemDetailData`, which
    will be created in the next section:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要在导航期间接受从另一个页面传递的参数，你必须覆盖`ItemDetailsPage.xaml.cs`中的`OnNavigatedTo`方法。`NavigationEventArgs`参数包含一个名为`Parameter`的属性。在我们的情况下，我们传递了一个包含所选项目`Id`的`int`。将此`Parameter`属性转换为`int`并将其传递给`ViewModel`上的一个名为`InitializeItemDetailData`的方法，该方法将在下一节中创建：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next section, we’ll add the final piece of the puzzle, the `ItemDetailsViewModel`
    class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加拼图的最后一块，即`ItemDetailsViewModel`类。
- en: Creating the ItemDetailsViewModel class
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建ItemDetailsViewModel类
- en: 'To add or edit items in the application, you will need a view model to bind
    to `ItemDetails``     Page`. Right-click the `ViewModels` folder in `ItemDetailsViewModel`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中添加或编辑项目，你需要一个视图模型来绑定到`ItemDetails`页面。在`ItemDetailsViewModel`的`ViewModels`文件夹上右键单击。
- en: The class will inherit from `ObservableObject` like `MainViewModel`. The full
    class can be found on GitHub at [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs).
    Let’s review some of the important members of the class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将像`MainViewModel`一样继承自`ObservableObject`。完整的类可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs)。让我们回顾一下该类的一些重要成员。
- en: 'The constructor receives the two services from the container and calls `PopulateLists`
    to populate `ComboBox` data from the data service:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从容器中接收两个服务并调用`PopulateLists`以从数据服务中填充`ComboBox`数据：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A `public` method named `InitializeItemDetailData` will accept the `itemId`
    parameter passed by `ItemDetailsPage.OnNavigatedTo`. It will call methods to populate
    the lists and initializes an `IsDirty` flag to enable or disable the `SaveCommand`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`InitializeItemDetailData`的`public`方法将接受`ItemDetailsPage.OnNavigatedTo`传递的`itemId`参数。它将调用方法来填充列表并初始化一个`IsDirty`标志来启用或禁用`SaveCommand`：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `PopulateExistingItem` method will add existing item data if the page is
    in edit mode, and `PopulateLists`, called from the constructor, fills the drop-down
    data to be bound to the view:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`PopulateExistingItem`方法将在页面处于编辑模式时添加现有项目数据，而`PopulateLists`方法，从构造函数中调用，填充要绑定到视图的下拉数据：'
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Most of this view model’s properties are straightforward, but `SelectedItemType`
    has some logic to repopulate the list of `Mediums` based on the `ItemType` selected.
    For instance, if you are adding a book to the collection, there’s no need to see
    the DVD or CD mediums in the selection list. We’ll handle this custom logic in
    `OnSelectedItemTypeChanged`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模型的大多数属性都很直接，但`SelectedItemType`有一些逻辑，根据选定的`ItemType`重新填充`Mediums`列表。例如，如果你正在向收藏夹添加一本书，就没有必要在选择列表中看到DVD或CD媒体。我们将在`OnSelectedItemTypeChanged`中处理这个自定义逻辑：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, let’s look at the code that `SaveCommand` and `CancelCommand` will
    invoke to save and navigate back to `MainPage`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`SaveCommand`和`CancelCommand`将调用来保存并导航回`MainPage`的代码：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The other change needed before you run the application to test the new page
    is to consume `ItemDetailsViewModel` from `ItemDetailsPage.xaml.cs`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行应用程序以测试新页面之前，需要做的另一个更改是从`ItemDetailsPage.xaml.cs`中消费`ItemDetailsViewModel`：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, run the app and try to add or edit an item—you should see the new page.
    If you are editing, you should also see the existing item data in the controls:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并尝试添加或编辑一个项目——你应该能看到新页面。如果你正在编辑，你也应该看到控件中的现有项目数据：
- en: '![Figure 4.2 – The Item Details page with edited data populated](img/B20908_04_02.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 填充了编辑数据的项详情页面](img/B20908_04_02.jpg)'
- en: Figure 4.2 – The Item Details page with edited data populated
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 填充了编辑数据的项详情页面
- en: Great! Now when you save, you should see any added records or edited data appear
    on `MainPage`. Things are really starting to take shape in our project. Let’s
    review what we have learned about WinUI and MVVM in this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在当你保存时，你应该能看到任何添加的记录或编辑的数据出现在`MainPage`上。我们的项目开始真正成形。让我们回顾一下在本章中我们学到的关于WinUI和MVVM的知识。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have learned quite a bit about MVVM and WinUI page navigation in this chapter.
    You have learned how to create and consume services in your application, and you
    have leveraged DI and DI containers to keep your view models and services loosely
    coupled. Understanding and using DI is key to building testable, maintainable
    code. At this point, you should have enough knowledge to create a robust, testable
    WinUI application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了很多关于MVVM和WinUI页面导航的知识。你学习了如何在应用程序中创建和消费服务，并利用依赖注入（DI）和DI容器来保持视图模型和服务的松耦合。理解和使用DI是构建可测试、可维护代码的关键。此时，你应该有足够的知识来创建一个健壮、可测试的WinUI应用程序。
- en: In the next chapter, you will learn about more of the available controls and
    libraries in WinUI 3.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于WinUI 3中可用的控件和库。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do DI and IoC relate?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DI和IoC如何相关？
- en: How do you navigate to the previous page in a WinUI application?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在WinUI应用程序中导航到上一页？
- en: What object do we use to manage dependencies?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用什么对象来管理依赖关系？
- en: With Microsoft’s DI container, what method can you call to get an object instance?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用微软的DI容器，你可以调用什么方法来获取对象实例？
- en: What is the name of the framework that queries objects in memory?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询内存中对象的框架的名称是什么？
- en: What event argument property can you access to get a parameter passed to another
    `Page`?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以访问哪个事件参数属性来获取传递给另一个`Page`的参数？
- en: Which dictionary type is safe to use across threads?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种字典类型可以在多线程之间安全使用？
