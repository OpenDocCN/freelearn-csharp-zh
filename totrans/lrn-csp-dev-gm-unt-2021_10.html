<html><head></head><body><div><p>&#13;
    <h1 class="chapterNumber">10</h1>&#13;
    <h1 id="_idParaDest-206" class="chapterTitle">Revisiting Types, Methods, and Classes</h1>&#13;
    <p class="normal">Now that you've programmed the game's mechanics and interactions with Unity's built-in classes, it's time to expand our core C# knowledge and focus on the intermediate applications of the foundation we've laid. We'll revisit old friends—variables, types, methods, and classes—but we'll target their deeper applications and relevant use cases. Many of the topics we'll be covering don't apply to <em class="italic">Hero Born</em> in its current state, so some examples will be standalone rather than being applied directly to the game prototype.</p>&#13;
    <p class="normal">I'll be throwing a lot of new information your way, so if you feel overwhelmed at any point, don't hesitate to revisit the first few chapters to solidify those building blocks. We'll also be using this chapter to break away from gameplay mechanics and features specific to Unity by focusing on the following topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Intermediate modifiers</li>&#13;
      <li class="bullet">Method overloading</li>&#13;
      <li class="bullet">Using the <code class="Code-In-Text--PACKT-">out</code> and <code class="Code-In-Text--PACKT-">ref</code> parameters</li>&#13;
      <li class="bullet">Working with interfaces</li>&#13;
      <li class="bullet">Abstract classes and overriding</li>&#13;
      <li class="bullet">Extending class functionality</li>&#13;
      <li class="bullet">Namespace conflicts</li>&#13;
      <li class="bullet">Type aliasing</li>&#13;
    </ul>&#13;
    <p class="normal">Let's get started!</p>&#13;
    <h1 id="_idParaDest-207" class="title">Access modifiers</h1>&#13;
    <p class="normal">While we've <a id="_idIndexMarker684"/>gotten into the habit of pairing the public and private access modifiers with our variable declarations, like we did with player health and items collected, there remains a laundry list of modifier keywords that we haven't seen. We can't go into detail about every one of them in this chapter, but the five that we'll focus on will further your understanding of the C# language and give your programming skills a boost.</p>&#13;
    <p class="normal">This section will cover the first three modifiers in the following list, while the remaining two will be discussed later on in the <em class="italic">Intermediate OOP</em> section:</p>&#13;
    <ul>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">const</code></li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">readonly</code></li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">static</code></li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">abstract</code></li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">override</code></li>&#13;
    </ul>&#13;
    <div>&#13;
      <p class="Information-Box--PACKT-">You can<a id="_idIndexMarker685"/> find a full list of available modifiers at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Let's start with the first three access modifiers provided in the preceding list.</p>&#13;
    <h2 id="_idParaDest-208" class="title">Constant and read-only properties</h2>&#13;
    <p class="normal">There will <a id="_idIndexMarker686"/>be <a id="_idIndexMarker687"/>times when you need to create variables that store constant, unchanging values. Adding the <code class="Code-In-Text--PACKT-">const</code> keyword after a variable's access modifier will do just that, but only for built-in C# types. For example, you couldn't mark an instance of our <code class="Code-In-Text--PACKT-">Character</code> class as a constant. A good candidate for a constant value is <code class="Code-In-Text--PACKT-">MaxItems</code> in the <code class="Code-In-Text--PACKT-">GameBehavior</code> class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public <strong class="hljs-keyword-slc">const</strong> int MaxItems = 4; &#13;
</code></pre>&#13;
    <p class="normal">The above code would essentially lock the value of <code class="Code-In-Text--PACKT-">MaxItems</code> at <code class="Code-In-Text--PACKT-">4</code>, making it unchangeable. The problem you'll run into with constant variables is that they can only be assigned a value in their declaration, meaning we can't leave <code class="Code-In-Text--PACKT-">MaxItems</code> without an initial value. As an alternative, we can use <code class="Code-In-Text--PACKT-">readonly</code>, which won't let you write to the variable, meaning it can't be changed:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public <strong class="hljs-keyword-slc">readonly</strong> int MaxItems; &#13;
</code></pre>&#13;
    <p class="normal">Using the <code class="Code-In-Text--PACKT-">readonly</code> keyword to declare a variable will give us the same unmodifiable value as a constant, while still letting us assign its initial value at any time. A good place for this <a id="_idIndexMarker688"/>would be the <code class="Code-In-Text--PACKT-">Start()</code> or <code class="Code-In-Text--PACKT-">Awake()</code> methods in one <a id="_idIndexMarker689"/>of our scripts.</p>&#13;
    <h2 id="_idParaDest-209" class="title">Using the static keyword</h2>&#13;
    <p class="normal">We've already<a id="_idIndexMarker690"/> gone over how objects, or instances, are created from a class blueprint, and that all properties and methods belong to that particular instance, like we had with our very first <code class="Code-In-Text--PACKT-">Character</code> class instance. While this is great for object-oriented functionality, not all classes need to be instantiated, and not all properties need to belong to a specific instance. However, static classes are sealed, meaning they cannot be used in class inheritance.</p>&#13;
    <p class="normal">Utility methods are a good case for this situation, where we don't necessarily care about instantiating a particular <code class="Code-In-Text--PACKT-">Utility</code> class instance since all its methods wouldn't be dependent on a particular object. Your task is to create just such a utility method in a new script.</p>&#13;
    <p class="normal">Let's create a new class to hold some of our future methods that deal with raw computations or repeated logic that doesn't depend on the gameplay:</p>&#13;
    <ol>&#13;
      <li class="numbered">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder and name it <code class="Code-In-Text--PACKT-">Utilities</code>.</li>&#13;
      <li class="numbered">Open it up and add the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">using System.Collections; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
 &#13;
// 1 &#13;
using UnityEngine.SceneManagement; &#13;
 &#13;
// 2 &#13;
public static class Utilities  &#13;
{ &#13;
    // 3 &#13;
    public static int PlayerDeaths = 0; &#13;
 &#13;
    // 4 &#13;
    public static void RestartLevel() &#13;
    { &#13;
        SceneManager.LoadScene(0); &#13;
        Time.timeScale = 1.0f; &#13;
    } &#13;
} &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Delete the code inside <code class="Code-In-Text--PACKT-">RestartLevel()</code> from <code class="Code-In-Text--PACKT-">GameBehavior</code> and instead call the new <code class="Code-In-Text--PACKT-">utility</code> method with the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">// 5&#13;
public void RestartScene()&#13;
{&#13;
    Utilities.RestartLevel();&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Let's break <a id="_idIndexMarker691"/>down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it adds the <code class="Code-In-Text--PACKT-">using SceneManagement</code> directive so that we can access the <code class="Code-In-Text--PACKT-">LoadScene()</code> method.</li>&#13;
      <li class="numbered">Then, it declares <code class="Code-In-Text--PACKT-">Utilities</code> as a public <code class="Code-In-Text--PACKT-">static</code> class that does not inherit from <code class="Code-In-Text--PACKT-">MonoBehavior</code> because we won't need it to be in the game scene.</li>&#13;
      <li class="numbered">Next, it creates a public <code class="Code-In-Text--PACKT-">static</code> variable to hold the number of times our player has died and restarted the game.</li>&#13;
      <li class="numbered">After, it declares a public <code class="Code-In-Text--PACKT-">static</code> method to hold our level restart logic, which is currently hardcoded in <code class="Code-In-Text--PACKT-">GameBehavior</code>.</li>&#13;
      <li class="numbered">Finally, our update to <code class="Code-In-Text--PACKT-">GameBehavior </code>calls <code class="Code-In-Text--PACKT-">RestartLevel()</code> from the static <code class="Code-In-Text--PACKT-">Utilities</code> class when the win or the lose button is pressed. Notice that we didn't need an instance of the <code class="Code-In-Text--PACKT-">Utilities</code> class to call the method because it's static—it's just dot notation.</li>&#13;
    </ol>&#13;
    <p class="normal">We've now extracted the restart logic from <code class="Code-In-Text--PACKT-">GameBehavior</code> and put it into its static class, which makes it easier to reuse across our codebase. Marking it as <code class="Code-In-Text--PACKT-">static</code> will also ensure that we never have to create or manage instances of the <code class="Code-In-Text--PACKT-">Utilities</code> class before we use its class members.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Non-static classes can have properties and methods that are static and non-static. However, if an entire class is marked as static, all properties and methods must follow suit.</p>&#13;
    </p>&#13;
    <p class="normal">That wraps up our second visit of variables and types, which will enable you to build out your own set of utilities and tools when managing larger and more complex projects down the road. Now it's time to move on to methods and their intermediate capabilities, which<a id="_idIndexMarker692"/> includes method overloading and <code class="Code-In-Text--PACKT-">ref</code> and <code class="Code-In-Text--PACKT-">out</code> parameters.</p>&#13;
    <h1 id="_idParaDest-210" class="title">Revisiting methods</h1>&#13;
    <p class="normal">Methods have<a id="_idIndexMarker693"/> been a big part of our code since we learned how to use them in <em class="chapterRef">Chapter 3</em>, <em class="italic">Diving into Variables, Types, and Methods</em>, but there are two intermediate use cases we haven't covered yet: method overloading and using the <code class="Code-In-Text--PACKT-">ref</code> and <code class="Code-In-Text--PACKT-">out</code> parameter keywords.</p>&#13;
    <h2 id="_idParaDest-211" class="title">Overloading methods</h2>&#13;
    <p class="normal">The<a id="_idIndexMarker694"/> term <strong class="keyword">method overloading</strong> refers to creating multiple methods with the same name but with different signatures. A method's signature is made up of its name and parameters, which is how the C# compiler recognizes it. Take the following method as an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public bool AttackEnemy(int damage) {}&#13;
</code></pre>&#13;
    <p class="normal">The method signature of <code class="Code-In-Text--PACKT-">AttackEnemy()</code> is written as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">AttackEnemy(int)&#13;
</code></pre>&#13;
    <p class="normal">Now that we know the signature of <code class="Code-In-Text--PACKT-">AttackEnemy()</code>, it can be overloaded by changing the number of parameters or the parameter types themselves, while still keeping its name. This provides added flexibility when you need more than one option for a given operation.</p>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">RestartLevel()</code> method in <code class="Code-In-Text--PACKT-">Utilities</code> is a great example of a situation where method overloading comes in handy. Right now, <code class="Code-In-Text--PACKT-">RestartLevel()</code> only restarts the current level, but what happens if we expand the game so that it includes multiple scenes? We could refactor <code class="Code-In-Text--PACKT-">RestartLevel()</code> to accept parameters, but that often leads to bloated and confusing code.</p>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">RestartLevel()</code> method is, once again, a good candidate for testing out our new knowledge. Your task is to overload it to take in different parameters.</p>&#13;
    <p class="normal">Let's add an overloaded version of <code class="Code-In-Text--PACKT-">RestartLevel()</code>:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Open up <code class="Code-In-Text--PACKT-">Utilities</code> and add the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">public static class Utilities  &#13;
{&#13;
    public static int PlayerDeaths = 0;&#13;
    public static void RestartLevel()&#13;
    {&#13;
        SceneManager.LoadScene(0);&#13;
        Time.timeScale = 1.0f;&#13;
    }&#13;
    <strong class="hljs-comment-slc">// 1</strong> &#13;
    <strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-keyword-slc">static</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-built_in-slc">bool</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">RestartLevel</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-built_in-slc">int</strong><strong class="hljs-params-slc"> sceneIndex</strong><strong class="hljs-function-slc">)</strong>&#13;
    <strong class="hljs-slc">{</strong> &#13;
        <strong class="hljs-comment-slc">// 2</strong> &#13;
        <strong class="hljs-slc">SceneManager.LoadScene(sceneIndex);</strong>&#13;
        <strong class="hljs-slc">Time.timeScale = </strong><strong class="hljs-number-slc">1.0f</strong><strong class="hljs-slc">;</strong>&#13;
        <strong class="hljs-comment-slc">// 3</strong> &#13;
        <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-literal-slc">true</strong><strong class="hljs-slc">;</strong>&#13;
    <strong class="hljs-slc">}</strong> &#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Open <code class="Code-In-Text--PACKT-">GameBehavior</code> and update the call to the <code class="Code-In-Text--PACKT-">Utilities.RestartLevel()</code> method to <a id="_idIndexMarker695"/>the following:&#13;
        <pre class="programlisting code"><code class="hljs-code">// 4&#13;
public void RestartScene()&#13;
{&#13;
    Utilities.RestartLevel(0);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares an overloaded version of the <code class="Code-In-Text--PACKT-">RestartLevel()</code> method that takes in an <code class="Code-In-Text--PACKT-">int</code> parameter and returns a <code class="Code-In-Text--PACKT-">bool</code>.</li>&#13;
      <li class="numbered">Then, it calls <code class="Code-In-Text--PACKT-">LoadScene()</code> and passes in the <code class="Code-In-Text--PACKT-">sceneIndex</code> parameter instead of manually hardcoding that value. </li>&#13;
      <li class="numbered">Next, it returns <code class="Code-In-Text--PACKT-">true</code> after the new scene is loaded and the <code class="Code-In-Text--PACKT-">timeScale</code> property has been reset.</li>&#13;
      <li class="numbered">Finally, our update to <code class="Code-In-Text--PACKT-">GameBehavior</code> calls the overloaded <code class="Code-In-Text--PACKT-">RestartLevel()</code> method and passes in <code class="Code-In-Text--PACKT-">0</code> as the <code class="Code-In-Text--PACKT-">sceneIndex</code>. Overloaded methods are automatically detected by Visual Studio and are displayed by number, as shown here:<figure class="mediaobject"><img src="img/B17573_10_01.png" alt="" width="750" height="111"/></figure>&#13;
    <p class="packt_figref">Figure 10.1: Multiple method overloads in Visual Studio</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">The functionality in the <code class="Code-In-Text--PACKT-">RestartLevel()</code> method is now much more customizable and can account for additional situations you may need later. In this case, it is restarting the game from any scene we choose.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Method overloading is not limited to static methods—this was just in line with the previous example. Any method can be overloaded as long as its signature differs from the original.</p>&#13;
    </p>&#13;
    <p class="normal">Next up, we're <a id="_idIndexMarker696"/>going to cover two additional topics that can take your method game to a whole new level—<code class="Code-In-Text--PACKT-">ref</code> and <code class="Code-In-Text--PACKT-">out</code> parameters.</p>&#13;
    <h2 id="_idParaDest-212" class="title">ref parameters</h2>&#13;
    <p class="normal">When we<a id="_idIndexMarker697"/> talked <a id="_idIndexMarker698"/>about classes and structs back in <em class="chapterRef">Chapter 5</em>, <em class="italic">Working with Classes, Structs</em>, <em class="italic">and OOP</em>, we discovered that not all objects are passed the same way: value types are passed by copy, while reference types are passed by reference. However, we didn't go over how objects, or values, are used when they're passed into methods as parameter arguments.</p>&#13;
    <p class="normal">By default, all arguments are passed by value, meaning that a variable passed into a method will not be affected by any changes that are made to its value inside the method body. This protects us from making unwanted changes to existing variables when we use them as method parameters. While this works for most cases, there are situations where you'll want to pass in a method argument by reference so that it can be updated and have that change reflected in the original variable. Prefixing a parameter declaration with either the <code class="Code-In-Text--PACKT-">ref</code> or <code class="Code-In-Text--PACKT-">out</code> keyword will mark the argument as a reference.</p>&#13;
    <p class="normal">Here are a few key points to keep in mind about using the <code class="Code-In-Text--PACKT-">ref</code> keyword:</p>&#13;
    <ul>&#13;
      <li class="bullet">Arguments have to be initialized before being passed into a method.</li>&#13;
      <li class="bullet">You don't need to initialize or assign the reference parameter value before ending the method.</li>&#13;
      <li class="bullet">Properties with get or set accessors can't be used as <code class="Code-In-Text--PACKT-">ref</code> or <code class="Code-In-Text--PACKT-">out</code> arguments.</li>&#13;
    </ul>&#13;
    <p class="normal">Let's try this out by adding some logic to keep track of how many times a player has restarted the game.</p>&#13;
    <p class="normal">Let's create a method to update <code class="Code-In-Text--PACKT-">PlayerDeaths</code> to see the method arguments that are being passed by reference in action.</p>&#13;
    <p class="normal">Open up <code class="Code-In-Text--PACKT-">Utilities</code> and <a id="_idIndexMarker699"/>add <a id="_idIndexMarker700"/>the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public static class Utilities  &#13;
{ &#13;
    public static int PlayerDeaths = 0; &#13;
    <strong class="hljs-comment-slc">// 1</strong> &#13;
    <strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-keyword-slc">static</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">UpdateDeathCount</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-keyword-slc">ref</strong><strong class="hljs-params-slc"> </strong><strong class="hljs-built_in-slc">int</strong><strong class="hljs-params-slc"> countReference</strong><strong class="hljs-function-slc">)</strong> &#13;
    <strong class="hljs-slc">{ </strong>&#13;
        <strong class="hljs-comment-slc">// 2</strong> &#13;
        <strong class="hljs-slc">countReference += </strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">;</strong> &#13;
        <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"Next time you'll be at number "</strong><strong class="hljs-slc"> + countReference;</strong>&#13;
    <strong class="hljs-slc">}</strong>&#13;
    public static void RestartLevel()&#13;
    { &#13;
       // ... No changes needed ...   &#13;
    } &#13;
    public static bool RestartLevel(int sceneIndex)&#13;
    { &#13;
        <strong class="hljs-comment-slc">// 3</strong> &#13;
        <strong class="hljs-slc">Debug.Log(</strong><strong class="hljs-string-slc">"Player deaths: "</strong><strong class="hljs-slc"> + PlayerDeaths);</strong> &#13;
        <strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> message = UpdateDeathCount(</strong><strong class="hljs-keyword-slc">ref</strong><strong class="hljs-slc"> PlayerDeaths);</strong>&#13;
        <strong class="hljs-slc">Debug.Log(</strong><strong class="hljs-string-slc">"Player deaths: "</strong><strong class="hljs-slc"> + PlayerDeaths);</strong>&#13;
        <strong class="hljs-slc">Debug.Log(message);</strong>&#13;
        SceneManager.LoadScene(sceneIndex);&#13;
        Time.timeScale = 1.0f;&#13;
        return true;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares a new <code class="Code-In-Text--PACKT-">static</code> method that returns a <code class="Code-In-Text--PACKT-">string</code> and takes in an <code class="Code-In-Text--PACKT-">int</code> passed by reference.</li>&#13;
      <li class="numbered">Then, it updates the reference parameter directly, incrementing its value by <code class="Code-In-Text--PACKT-">1</code> and returning a string that contains the new value.</li>&#13;
      <li class="numbered">Finally, it debugs the <code class="Code-In-Text--PACKT-">PlayerDeaths</code> variable in <code class="Code-In-Text--PACKT-">RestartLevel(int sceneIndex)</code> before and after it is passed by reference to <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code>. We also store a reference to the returned string value from <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> in the <code class="Code-In-Text--PACKT-">message</code> variable and print it out.</li>&#13;
    </ol>&#13;
    <p class="normal">If you play<a id="_idIndexMarker701"/> the game<a id="_idIndexMarker702"/> and lose, the debug log will show that <code class="Code-In-Text--PACKT-">PlayerDeaths</code> has increased by 1 inside <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> because it was passed by reference and not by value:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_10_02.png" alt="" width="807" height="209"/></figure>&#13;
    <p class="packt_figref">Figure 10.2: Example output from ref parameters</p>&#13;
    <p class="normal">For clarity, we could have updated the player death count without a <code class="Code-In-Text--PACKT-">ref</code> parameter because <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> and <code class="Code-In-Text--PACKT-">PlayerDeaths</code> are in the same script. However, if this wasn't the case and you wanted the same functionality, <code class="Code-In-Text--PACKT-">ref</code> parameters are super useful.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">We're using the <code class="Code-In-Text--PACKT-">ref</code> keyword in this situation for the sake of our example, but we could have also updated <code class="Code-In-Text--PACKT-">PlayerDeaths</code> directly inside <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> or added logic inside <code class="Code-In-Text--PACKT-">RestartLevel()</code> to only fire <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> when the restart was due to a loss.</p>&#13;
    </p>&#13;
    <p class="normal">Now that we know how to use a <code class="Code-In-Text--PACKT-">ref</code> parameter in our project, let's take a look at the <code class="Code-In-Text--PACKT-">out</code> parameter <a id="_idIndexMarker703"/>and <a id="_idIndexMarker704"/>how it serves a slightly different purpose.</p>&#13;
    <h2 id="_idParaDest-213" class="title">out parameters</h2>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">out</code> keyword does<a id="_idIndexMarker705"/> the same job as <code class="Code-In-Text--PACKT-">ref</code> but with different<a id="_idIndexMarker706"/> rules, which means they're similar tools but they're not interchangeable—each has its own use cases:</p>&#13;
    <ul>&#13;
      <li class="bullet">Arguments do not need to be initialized before being passed into a method.</li>&#13;
      <li class="bullet">The referenced parameter value does need to be initialized or assigned in the calling method before it's returned.</li>&#13;
    </ul>&#13;
    <p class="normal">For instance, we could have replaced <code class="Code-In-Text--PACKT-">ref</code> with <code class="Code-In-Text--PACKT-">out</code> in <code class="Code-In-Text--PACKT-">UpdateDeathCount()</code> as long as we initialized or assigned the <code class="Code-In-Text--PACKT-">countReference</code> parameter before returning from the method:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public static string UpdateDeathCount(<strong class="hljs-keyword-slc">out</strong> int countReference) &#13;
{ &#13;
     countReference = 1;&#13;
     return "Next time you'll be at number " + countReference;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Methods that use the <code class="Code-In-Text--PACKT-">out</code> keyword are better suited to situations where you need to return multiple values from a single function, while the <code class="Code-In-Text--PACKT-">ref</code> keyword works best when a reference value only needs to be modified. It's also more flexible than the <code class="Code-In-Text--PACKT-">ref</code> keyword because the initial parameter values don't need to be set before they're used in the method. The <code class="Code-In-Text--PACKT-">out</code> keyword is especially useful if you need to initialize the parameter value before you change it. Even though these keywords are a little more esoteric, it's important to have them in your C# toolkit for special use cases.</p>&#13;
    <p class="normal">With these new<a id="_idIndexMarker707"/> method features under our belts, it's time to revisit the big one: <strong class="keyword">object-oriented programming</strong> (<strong class="keyword">OOP</strong>). There's so much to this topic that it's impossible to cover everything in a chapter or two, but there are a few key tools that will come in handy early on in your development career. OOP is one of those topics that you're encouraged to follow up on after finishing this book.</p>&#13;
    <h1 id="_idParaDest-214" class="title">Intermediate OOP</h1>&#13;
    <p class="normal">An object-oriented<a id="_idIndexMarker708"/> mindset is crucial to creating meaningful applications and understanding how the C# language works behind the scenes. The tricky part is that classes and structs by themselves aren't the end of the line when it comes to OOP and designing your objects. They'll always be the building blocks of your code, but classes are limited to single inheritance, meaning they can only ever have one parent or superclass, and structs can't inherit at all. So, the question you should be asking yourself right about now is simple: <em class="italic">"How can I create objects from the same blueprint and have them perform different actions based on a specific scenario?"</em></p>&#13;
    <p class="normal">To answer this <a id="_idIndexMarker709"/>question, we'll be learning about interfaces, abstract classes, and class extensions.</p>&#13;
    <h2 id="_idParaDest-215" class="title">Interfaces</h2>&#13;
    <p class="normal">One of the <a id="_idIndexMarker710"/>ways to gather groups of functionality together is through interfaces. Like classes, interfaces are blueprints for data and behaviors, but with one important difference: they can't have any actual implementation logic or stored values. Instead, they contain the implementation blueprint, and it's up to the adopting class or struct to fill in the values and methods outlined in the interface. You can use interfaces with both classes and structs, and there's no upper limit to how many interfaces a single class or struct can adopt.</p>&#13;
    <p class="normal">Remember, a single class can only have one parent class, and structs can't subclass at all. Breaking out functionality into interfaces lets you build up classes like building blocks, picking and choosing how you want them to behave like food from a menu. This would be a huge efficiency boost to your code base, breaking away from long, messy subclassing hierarchies.</p>&#13;
    <p class="normal">For example, what if we wanted our enemies to be able to shoot back at our player when they're in close range? We could create a parent class that both the player and enemy could derive from, which would base them both on the same blueprint. The problem with that approach, however, is that enemies and players won't necessarily share the same behaviors and data. </p>&#13;
    <p class="normal">The more efficient way to handle this would be to define an interface with a blueprint for what shootable objects need to do, and then have both the enemy and player adopt it. That way, they have the freedom to be separate and exhibit different behaviors while still sharing common functionality.</p>&#13;
    <p class="normal">Refactoring the shooting mechanic into an interface is a challenge I'll leave to you, but we still need to know how to create and adopt interfaces in code. For this example, we'll create an interface that all manager scripts might need to implement for sharing a common structure.</p>&#13;
    <p class="normal">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">IManager</code>, and update its code as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine; &#13;
// 1 &#13;
public interface IManager  &#13;
{ &#13;
    // 2 &#13;
    string State { get; set; } &#13;
    // 3 &#13;
    void Initialize();&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares a public interface called <code class="Code-In-Text--PACKT-">IManager</code> using the <code class="Code-In-Text--PACKT-">interface</code> keyword.</li>&#13;
      <li class="numbered">Then, it adds a <code class="Code-In-Text--PACKT-">string</code> variable to <code class="Code-In-Text--PACKT-">IManager</code> named <code class="Code-In-Text--PACKT-">State</code> with <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">set</code> accessors<a id="_idIndexMarker711"/> to hold the current state of the adopting class.<p>&#13;
          <p class="Information-Box--PACKT-">All interface properties need at least a get accessor to compile but can have both get and set accessors if necessary.</p>&#13;
        </p>&#13;
      </li>&#13;
      <li class="numbered">Finally, it defines a method named <code class="Code-In-Text--PACKT-">Initialize()</code> with no return type for the adopting class to implement. However, you could absolutely have a return type for a method inside an interface; there's no rule against it.</li>&#13;
    </ol>&#13;
    <p class="normal">You've now created a blueprint for all manager scripts, meaning that each manager script adopting this interface needs to have a state property and an initialize method. Your next task is to use the <code class="Code-In-Text--PACKT-">IManager</code> interface, which means it needs to be adopted by another class.</p>&#13;
    <p class="normal">To keep things simple, let's have the game manager adopt our new interface and implement its blueprint.</p>&#13;
    <p class="normal">Update <code class="Code-In-Text--PACKT-">GameBehavior</code> with the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-comment-slc">// 1</strong> &#13;
public class GameBehavior : MonoBehaviour, <strong class="hljs-title-slc">IManager</strong> &#13;
{ &#13;
    <strong class="hljs-comment-slc">// 2</strong> &#13;
    <strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> _state;</strong> &#13;
    <strong class="hljs-comment-slc">// 3</strong> &#13;
    <strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> State</strong>  &#13;
    <strong class="hljs-slc">{</strong> &#13;
        <strong class="hljs-keyword-slc">get</strong><strong class="hljs-slc"> { </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> _state; }</strong> &#13;
        <strong class="hljs-keyword-slc">set</strong><strong class="hljs-slc"> { _state = </strong><strong class="hljs-keyword-slc">value</strong><strong class="hljs-slc">; }</strong> &#13;
    <strong class="hljs-slc">}</strong>&#13;
    // ... No other changes needed ... &#13;
    <strong class="hljs-comment-slc">// 4</strong> &#13;
    <strong class="hljs-keyword-slc">void</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Start</strong><strong class="hljs-function-slc">()</strong> &#13;
    <strong class="hljs-slc">{</strong> &#13;
        <strong class="hljs-slc">Initialize();</strong> &#13;
    <strong class="hljs-slc">}</strong>&#13;
    <strong class="hljs-comment-slc">// 5</strong> &#13;
    <strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-keyword-slc">void</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Initialize</strong><strong class="hljs-function-slc">()</strong>  &#13;
    <strong class="hljs-slc">{</strong> &#13;
        <strong class="hljs-slc">_state = </strong><strong class="hljs-string-slc">"Game Manager initialized.."</strong><strong class="hljs-slc">;</strong>&#13;
        <strong class="hljs-slc">Debug.Log(_state);</strong>&#13;
    <strong class="hljs-slc">}</strong>&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break <a id="_idIndexMarker712"/>down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares that <code class="Code-In-Text--PACKT-">GameBehavior</code> adopts the <code class="Code-In-Text--PACKT-">IManager</code> interface using a comma and its name, just like with subclassing.</li>&#13;
      <li class="numbered">Then, it adds a private variable that we'll use to back the public <code class="Code-In-Text--PACKT-">State</code> value we have to implement from <code class="Code-In-Text--PACKT-">IManager</code>.</li>&#13;
      <li class="numbered">Next, it adds the public <code class="Code-In-Text--PACKT-">State</code> variable declared in <code class="Code-In-Text--PACKT-">IManager</code> and uses <code class="Code-In-Text--PACKT-">_state</code> as its private backing variable.</li>&#13;
      <li class="numbered">After that, it declares the <code class="Code-In-Text--PACKT-">Start()</code> method and calls the <code class="Code-In-Text--PACKT-">Initialize()</code> method.</li>&#13;
      <li class="numbered">Finally, it declares the <code class="Code-In-Text--PACKT-">Initialize()</code> method declared in <code class="Code-In-Text--PACKT-">IManager</code> with an implementation that sets and prints out the public <code class="Code-In-Text--PACKT-">State</code> variable.</li>&#13;
    </ol>&#13;
    <p class="normal">With this, we specified that <code class="Code-In-Text--PACKT-">GameBehavior</code> adopts the <code class="Code-In-Text--PACKT-">IManager</code> interface and implemented its <code class="Code-In-Text--PACKT-">State</code> and <code class="Code-In-Text--PACKT-">Initialize()</code> members, as shown here:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_10_03.png" alt="" width="774" height="123"/></figure>&#13;
    <p class="packt_figref">Figure 10.3: Example output from an interface</p>&#13;
    <p class="normal">The great part of this is that the implementation is specific to <code class="Code-In-Text--PACKT-">GameBehavior</code>; if we had another manager class, we could do the same thing but with different logic. Just for fun, let's set up a new manager script to test this out:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">In the <strong class="screenText">Project</strong>, right-click inside the <strong class="screenText">Scripts</strong> folder and choose <strong class="screenText">Create</strong> | <strong class="screenText">C# Script</strong>, then name it <code class="Code-In-Text--PACKT-">DataManager</code>.</li>&#13;
      <li class="numbered">Update the<a id="_idIndexMarker713"/> new script with the following code and adopt the <code class="Code-In-Text--PACKT-">IManager </code>interface:&#13;
        <pre class="programlisting code"><code class="hljs-code">using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
public class DataManager : MonoBehaviour, IManager&#13;
{&#13;
    private string _state;&#13;
    public string State&#13;
    {&#13;
        get { return _state; }&#13;
        set { _state = value; }&#13;
    }&#13;
    void Start()&#13;
    {&#13;
        Initialize();&#13;
    }&#13;
    public void Initialize()&#13;
    {&#13;
        _state = "Data Manager initialized..";&#13;
        Debug.Log(_state);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Drag and drop the new script onto the <strong class="screenText">Game_Manager</strong> object in the <strong class="screenText">Hierarchy</strong> panel:<figure class="mediaobject"><img src="img/B17573_10_04.png" alt="" width="750" height="660"/></figure>&#13;
        <p class="packt_figref">Figure 10.4: Data manager script attached to a GameObject</p>&#13;
      </li>&#13;
      <li class="numbered">Then <a id="_idIndexMarker714"/>click play:<figure class="mediaobject"><img src="img/B17573_10_05.png" alt="" width="753" height="117"/></figure>&#13;
    <p class="packt_figref">Figure 10.5: Output from data manager initialization</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">While we could have done all of this with subclassing, we'd be limited to one parent class for all our managers. Instead, we have the option of adding new interfaces if we choose. We'll revisit this new manager script in <em class="chapterRef">Chapter 12</em>, <em class="italic">Saving, Loading, and Serializing Data</em>. This opens up a whole world of possibilities for building classes, one of which is a new OOP <a id="_idIndexMarker715"/>concept called abstract classes.</p>&#13;
    <h2 id="_idParaDest-216" class="title">Abstract classes</h2>&#13;
    <p class="normal">Another approach <a id="_idIndexMarker716"/>to separating common blueprints and sharing them between objects is the abstract class. Like interfaces, abstract classes cannot include any implementation logic for their methods; they can, however, store variable values. This is one of the key differences from interfaces—in situations where you might need to set initial values, an abstract class would be the way to go.</p>&#13;
    <p class="normal">Any class that subclasses from an abstract class must fully implement all variables and methods marked with the <code class="Code-In-Text--PACKT-">abstract</code> keyword. They can be particularly useful in situations where you want to use class inheritance without having to write out a base class's default implementation.</p>&#13;
    <p class="normal">For example, let's take the <code class="Code-In-Text--PACKT-">IManager</code> interface functionality we just wrote and see what it would look like as an abstract base class. <em class="italic">Don't change any of the actual code in our project</em>, as we still want to keep things working as they are:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// 1 &#13;
public abstract class BaseManager  &#13;
{ &#13;
    // 2 &#13;
    protected string _state = "Manager is not initialized...";&#13;
    public abstract string State { get; set; }&#13;
    // 3 &#13;
    public abstract void Initialize();&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares a new class named <code class="Code-In-Text--PACKT-">BaseManager</code> using the <code class="Code-In-Text--PACKT-">abstract</code> keyword.</li>&#13;
      <li class="numbered">Then, it creates two variables: A <code class="Code-In-Text--PACKT-">protected string</code> named <code class="Code-In-Text--PACKT-">_state</code> that can only be accessed by classes that inherit from <code class="Code-In-Text--PACKT-">BaseManager</code>. We've also set an initial value for <code class="Code-In-Text--PACKT-">_state</code>, something we couldn't do in our interface.<ul>&#13;
          <li class="bullet-l2">We also have an abstract string named <code class="Code-In-Text--PACKT-">State</code> with <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">set</code> accessors to be implemented by the subclass.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Finally, it adds <code class="Code-In-Text--PACKT-">Initialize()</code> as an <code class="Code-In-Text--PACKT-">abstract</code> method, also to be implemented in the subclass.</li>&#13;
    </ol>&#13;
    <p class="normal">In doing so, we have created an abstract class that does the same thing as an interface. In this setup, <code class="Code-In-Text--PACKT-">BaseManager</code> has the same blueprint as <code class="Code-In-Text--PACKT-">IManager</code>, allowing any subclasses to define their<a id="_idIndexMarker717"/> implementations of <code class="Code-In-Text--PACKT-">state</code> and <code class="Code-In-Text--PACKT-">Initialize()</code> using the <code class="Code-In-Text--PACKT-">override</code> keyword:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// 1 &#13;
public class CombatManager: BaseManager  &#13;
{ &#13;
    // 2 &#13;
    public override string State &#13;
    { &#13;
        get { return _state; } &#13;
        set { _state = value; } &#13;
    }&#13;
    // 3 &#13;
    public override void Initialize() &#13;
    { &#13;
        _state = "Combat Manager initialized..";&#13;
        Debug.Log(_state);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">If we break down the preceding code, we can see the following:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares a new class called <code class="Code-In-Text--PACKT-">CombatManager</code> that inherits from the <code class="Code-In-Text--PACKT-">BaseManager</code> abstract class.</li>&#13;
      <li class="numbered">Then, it adds the <code class="Code-In-Text--PACKT-">State</code> variable implementation from <code class="Code-In-Text--PACKT-">BaseManager</code> using the <code class="Code-In-Text--PACKT-">override</code> keyword.</li>&#13;
      <li class="numbered">Finally, it adds the <code class="Code-In-Text--PACKT-">Initialize()</code> method implementation from <code class="Code-In-Text--PACKT-">BaseManager</code> using the <code class="Code-In-Text--PACKT-">override</code> keyword again and sets the protected <code class="Code-In-Text--PACKT-">_state</code> variable.</li>&#13;
    </ol>&#13;
    <p class="normal">Even though this is only the tip of the iceberg of interfaces and abstract classes, their possibilities should be jumping around in your programming brain. Interfaces will allow you to spread and share pieces of functionality between unrelated objects, leading to a building block-like assembly when it comes to your code.</p>&#13;
    <p class="normal">Abstract classes, on the other hand, will let you keep the single-inheritance structure of OOP while separating a class's implementation from its blueprint. These approaches can even be mixed and matched, as abstract classes can adopt interfaces just like non-abstract ones.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">As always with complicated topics, your first stop should be the documentation. Check it out at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface</a>. </p>&#13;
    </p>&#13;
    <p class="normal">You won't<a id="_idIndexMarker718"/> always need to build a new class from scratch. Sometimes, it's enough to add the feature or logic you want to an existing class, which is called a class extension.</p>&#13;
    <h2 id="_idParaDest-217" class="title">Class extensions</h2>&#13;
    <p class="normal">Let's step away<a id="_idIndexMarker719"/> from custom objects and talk about how we can extend existing classes so that they fit our own needs. The idea behind class extensions is simple: take an existing built-in C# class and add on any functionality that you need it to have. Since we don't have access to the underlying code that C# is built on, this is the only way to get custom behavior out of objects the language already has.</p>&#13;
    <p class="normal">Classes can only be modified with methods—no variables or other entities are allowed. However limiting this might be, it makes the syntax consistent:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public <strong class="hljs-keyword-slc">static</strong> returnType MethodName(<strong class="hljs-keyword-slc">this</strong><strong class="hljs-params-slc"> ExtendingClass</strong> localVal) {}&#13;
</code></pre>&#13;
    <p class="normal">Extension methods are declared using the same syntax as normal methods, but with a few caveats:</p>&#13;
    <ul>&#13;
      <li class="bullet">All extension methods need to be marked as <code class="Code-In-Text--PACKT-">static</code>.</li>&#13;
      <li class="bullet">The first parameter needs to be the <code class="Code-In-Text--PACKT-">this</code> keyword, followed by the name of the class we want to extend and a local variable name:<ul>&#13;
          <li class="bullet-l2">This special parameter lets the compiler identify the method as an extension, and gives us a local reference for the existing class.</li>&#13;
          <li class="bullet-l2">Any class methods and properties can then be accessed through the local variable.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bullet">It's common to store extension methods inside a static class, which, in turn, is stored inside its namespace. This allows you to control what other scripts have access to your custom functionality.</li>&#13;
    </ul>&#13;
    <p class="normal">Your next task is to put class extensions into practice by adding a new method to the built-in C# <code class="Code-In-Text--PACKT-">String</code> class.</p>&#13;
    <p class="normal">Let's take a look at extensions in practice by adding a custom method to the <code class="Code-In-Text--PACKT-">String </code>class. Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">CustomExtensions</code>, and add the following<a id="_idIndexMarker720"/> code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">using System.Collections; &#13;
using System.Collections.Generic;&#13;
using UnityEngine;  &#13;
// 1 &#13;
namespace CustomExtensions  &#13;
{ &#13;
    // 2 &#13;
    public static class StringExtensions &#13;
    { &#13;
        // 3 &#13;
        public static void FancyDebug(this string str)&#13;
        { &#13;
            // 4 &#13;
            Debug.LogFormat("This string contains {0} characters.", str.Length);&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it declares a namespace named <code class="Code-In-Text--PACKT-">CustomExtensions</code> to hold all the extension classes and methods.</li>&#13;
      <li class="numbered">Then, it declares a <code class="Code-In-Text--PACKT-">static</code> class named <code class="Code-In-Text--PACKT-">StringExtensions</code> for organizational purposes; each group of class extensions should follow this setup.</li>&#13;
      <li class="numbered">Next, it adds a <code class="Code-In-Text--PACKT-">static</code> method named <code class="Code-In-Text--PACKT-">FancyDebug</code> to the <code class="Code-In-Text--PACKT-">StringExtensions</code> class:<ul>&#13;
          <li class="bullet-l2">The first parameter, <code class="Code-In-Text--PACKT-">this string str</code>, marks the method as an extension.</li>&#13;
          <li class="bullet-l2">The <code class="Code-In-Text--PACKT-">str</code> parameter will hold a reference to the actual text value that <code class="Code-In-Text--PACKT-">FancyDebug()</code> is called from; we can operate on <code class="Code-In-Text--PACKT-">str</code> inside the method body as a stand-in for all string literals.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Finally, it prints out a debug message whenever <code class="Code-In-Text--PACKT-">FancyDebug</code> is executed, using <code class="Code-In-Text--PACKT-">str.Length</code> to reference the string variable that the method is called on.</li>&#13;
    </ol>&#13;
    <p class="normal">In practice, this will let you add any of your own custom functionality to existing C# classes or even your own custom ones. Now that the extension is part of the <code class="Code-In-Text--PACKT-">String</code> class, let's test it out. To use our new custom string method, we'll need to include it in whatever class we want to have access to it.</p>&#13;
    <p class="normal">Open <a id="_idIndexMarker721"/>up <code class="Code-In-Text--PACKT-">GameBehavior</code> and update the class with the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">using System.Collections; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
<strong class="hljs-comment-slc">// 1</strong> &#13;
<strong class="hljs-keyword-slc">using</strong><strong class="hljs-slc"> CustomExtensions;</strong> &#13;
 &#13;
public class GameBehavior : MonoBehaviour, IManager &#13;
{ &#13;
    // ... No changes needed ... &#13;
    void Start() &#13;
    { &#13;
        // ... No changes needed ... &#13;
    } &#13;
    public void Initialize()  &#13;
    { &#13;
        _state = "Game Manager initialized..";&#13;
        <strong class="hljs-comment-slc">// 2</strong> &#13;
        <strong class="hljs-slc">_state.FancyDebug();</strong>&#13;
        Debug.Log(_state);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down the code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">First, it adds the <code class="Code-In-Text--PACKT-">CustomExtensions</code> namespace with a <code class="Code-In-Text--PACKT-">using</code> directive at the top of the file.</li>&#13;
      <li class="numbered">Then, it calls <code class="Code-In-Text--PACKT-">FancyDebug</code> on the <code class="Code-In-Text--PACKT-">_state</code> string variable with dot notation inside <code class="Code-In-Text--PACKT-">Initialize()</code> to print out the number of individual characters its value has.</li>&#13;
    </ol>&#13;
    <p class="normal">Extending the entire <code class="Code-In-Text--PACKT-">string</code> class with <code class="Code-In-Text--PACKT-">FancyDebug()</code> means that any string variable has access to it. Since the first extension method parameter has a reference to whatever <code class="Code-In-Text--PACKT-">string</code> value that <code class="Code-In-Text--PACKT-">FancyDebug()</code> is called on, its length will be printed out properly, as shown here:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_10_06.png" alt="" width="821" height="149"/></figure>&#13;
    <p class="packt_figref">Figure 10.6: Example output from custom extension</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">A custom class can also be extended using the same syntax, but it's more common to just add extra functionality directly into the class if it's one you control.</p>&#13;
    </p>&#13;
    <p class="normal">The last topic <a id="_idIndexMarker722"/>we'll explore in this chapter is namespaces, which we briefly learned about earlier in the book. In the next section, you'll learn about the larger role that namespaces play in C# and how to create your type alias.</p>&#13;
    <h1 id="_idParaDest-218" class="title">Namespace conflicts and type aliasing</h1>&#13;
    <p class="normal">As your <a id="_idIndexMarker723"/>applications<a id="_idIndexMarker724"/> get more complicated, you'll start to section off your code into namespaces, ensuring that you have control over where and when it's accessed. You'll also use third-party software tools and plugins to save on time implementing a feature from the ground up that someone else has already made available. Both of these scenarios show that you're progressing with your programming knowledge, but they can also cause namespace conflicts.</p>&#13;
    <p class="normal"><strong class="keyword">Namespace conflicts</strong> happen when there are two or more classes or types with the same name, which happens more than you'd think. </p>&#13;
    <p class="normal">Good naming habits tend to produce similar results, and before you know it, you're dealing with multiple classes named <code class="Code-In-Text--PACKT-">Error</code> or <code class="Code-In-Text--PACKT-">Extension</code>, and Visual Studio is throwing out errors. Luckily, C# has a simple solution to these situations: <strong class="keyword">type aliasing</strong>.</p>&#13;
    <p class="normal">Defining a type alias lets you explicitly choose which conflicting type you want to use in a given class, or create a more user-friendly name for a long-winded existing one. Type aliases are added at the top of the class file with a <code class="Code-In-Text--PACKT-">using</code> directive, followed by the alias name and the assigned type:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">using AliasName = type;&#13;
</code></pre>&#13;
    <p class="normal">For instance, if <a id="_idIndexMarker725"/>we wanted to create a type alias to refer to the existing <code class="Code-In-Text--PACKT-">Int64</code> type, we <a id="_idIndexMarker726"/>could say the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">using CustomInt = System.Int64;&#13;
</code></pre>&#13;
    <p class="normal">Now that <code class="Code-In-Text--PACKT-">CustomInt</code> is a type alias for the <code class="Code-In-Text--PACKT-">System.Int64</code> type, the compiler will treat it as an <code class="Code-In-Text--PACKT-">Int64</code>, letting us use it like any other type:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public CustomInt PlayerHealth = 100;&#13;
</code></pre>&#13;
    <p class="normal">You can use type aliasing with your custom types, or existing ones with the same syntax, as long as they're <a id="_idIndexMarker727"/>declared <a id="_idIndexMarker728"/>at the top of script files with the other <code class="Code-In-Text--PACKT-">using</code> directives.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">For more <a id="_idIndexMarker729"/>information<a id="_idIndexMarker730"/> on the <code class="Code-In-Text--PACKT-">using</code> keyword and type aliasing, check out the C# documentation at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive</a>.</p>&#13;
    </p>&#13;
    <h1 id="_idParaDest-219" class="title">Summary</h1>&#13;
    <p class="normal">With new modifiers, method overloading, class extensions, and object-oriented skills under our belts, we are only one step away from the end of our C# journey. Remember, these intermediate topics are intended to get you thinking about more complex applications of the knowledge you've been gathering throughout this book; don't think that what you've learned in this chapter is all that there is to know on these concepts. Take it as a starting point and continue from there.</p>&#13;
    <p class="normal">In the next chapter, we'll discuss the basics of generic programming, get a little hands-on experience with delegates and events, and wrap up with an overview of exception handling.</p>&#13;
    <h1 id="_idParaDest-220" class="title">Pop quiz – leveling up</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Which keyword would mark a variable as unmodifiable but requires an initial value?</li>&#13;
      <li class="numbered">How would you create an overloaded version of a base method?</li>&#13;
      <li class="numbered">What is the main difference between classes and interfaces?</li>&#13;
      <li class="numbered">How would you solve a namespace conflict in one of your classes?</li>&#13;
    </ol>&#13;
    <h1 class="heading-1">JOIN us on Discord!</h1>&#13;
    <p class="normal">Read this book alongside other users, Unity/C# experts, and Harrison Ferrone. Ask questions, provide solutions to other readers, chat with the author via <em class="italic">Ask Me Anything sessions</em> and much more.</p>&#13;
<p class="normal">Join Now! </p>&#13;
    <p class="normal"><a href="https://packt.link/csharpunity2021">https://packt.link/csharpunity2021</a></p>&#13;
    <p class="normal"><img style="height: 8em; width: auto;" src="img/QR_Code_9781801813945.png" alt="" width="354" height="354"/></p>&#13;
  </div>&#13;
</div></body></html>