<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-221"><a id="_idTextAnchor222"/>10</h1>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor223"/>The One with the Systems Check-Ups</h1>
			<p><em class="italic">Logging, Monitoring, </em><em class="italic">and Metrics</em></p>
			<p>Now and then, software fails. Whether we like it or not, that is simply a fact of life. We make mistakes during development. Other people make mistakes. The environment changes. A network becomes unstable. These are all reasons the system might not behave as we intended.</p>
			<p>Testing can help. A good and solid set of tests can show you the errors in your work and help make your system more robust. However, sometimes things still go wrong. Let’s face it: building software is a creative art form and thus subject to influences beyond our control. So, when things go wrong and our systems do not do what we thought they would be doing, we need a way to look into their workings. That can help us figure out what happened and what we can do to fix things.</p>
			<p>This is where logging and monitoring comes into play. Logging helps us write important information and store it in a well-known place. Logging is part of our code base. Monitoring is watching the system from the outside to track what is happening. In this chapter, I will show you exactly how to do everything from a systems developer’s perspective.</p>
			<p>In this chapter, we will learn about the following topics:</p>
			<ul>
				<li>What logging frameworks are there?</li>
				<li>How do I set up the correct levels of logging?</li>
				<li>What is structured logging?</li>
				<li>How can I monitor my logs outside my system?</li>
				<li>What is monitoring?</li>
				<li>How do I set up monitoring?</li>
				<li>What should I monitor or log?</li>
			</ul>
			<p>I hope you are as excited about this as I am!</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor224"/>Technical requirements</h1>
			<p>In this chapter, we look into monitoring and logging tools. One of the tools I often use is <strong class="bold">Seq</strong>. I am not affiliated with them; it is just a tool I like to use. You can download a free-to-use personal version at <a href="https://datalust.co/download">https://datalust.co/download</a>. You can download the installer or run the tool as a Docker image. To use this, you have to install Docker on your environment. I suggest you go to <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a> to learn more about Docker.  If you want to play around, I suggest you choose the Docker version. You can run the image locally by invoking the following command from a terminal:</p>
			<pre class="console">
docker run -d
    --restart unless-stopped
    --name seq
    -e ACCEPT_EULA=Y
    -v c:\data:/data
    -p 80:80
    -p 5341:5341
    datalust/seq:latest</pre>			<p>This Docker command downloads the image from <code>datalust/seq</code>. It listens to ports <code>80</code> for the <code>5341</code> to intercept logs. All settings are stored in the <code>C:\data</code> folder, so you must create that folder beforehand (or change the <code>-v</code> property in the Docker command).</p>
			<p>I will also show you how to use Prometheus in this chapter. To get that up and running, you could do the same thing. Either download the software from their website at <a href="https://prometheus.io/">https://prometheus.io/</a> or run it in a Docker container:</p>
			<pre class="console">
docker run -d
    --name prom
    -p 9090:9090
    -v c:\data\prometheus.yml:/etc/prometheus/prometheus.yml
    prom/prometheus</pre>			<p>You need to have a <code>prometheus.yml</code> file that contains information about what you want to monitor. I will show you what that file looks like later in this chapter, where I will also explain what each part does.</p>
			<p>We will be using a lot of NuGet packages as well; they are all mentioned in the paragraphs where I discuss each of them and how to use them.</p>
			<p>You can download all code samples mentioned in this chapter from our GitHub repo at <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10</a></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor225"/>Available logging frameworks</h1>
			<p>Logging has been <a id="_idIndexMarker736"/>around forever. In the early days of computing, operators would walk around the machines and note whatever they saw happening to them. If a light blinked when it should not have blinked or vice versa, they wrote it down a journal somewhere. Later, systems would log everything they could onto paper and punch cards. If systems did something unexpected, the operators could go to the paper trail and figure out what had caused the event. After that, people used serial monitors that logged everything onto a separate device.</p>
			<p>These days, we hardly use punch cards anymore. However, we still log. There are many frameworks out there that help you get the job done. In this chapter, I will explain three of those frameworks. They all have pros and cons. I will highlight these as much as possible. That way, you can make your own decisions about what to use and when to use it.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor226"/>Default logger in .NET</h2>
			<p>Microsoft <a id="_idIndexMarker737"/>offers a <strong class="bold">default logger</strong>. We have<a id="_idIndexMarker738"/> seen it before: if you create an ASP.Net application or, as we have done, a worker process, you will get a logger framework for free. This framework is surprisingly full-featured. This framework offers enough features to satisfy the needs of most developers. So, let’s have a look at it!</p>
			<p>As I said, many <a id="_idIndexMarker739"/>of the templates in Visual Studio already include the standard <code>Logger</code> class. Some templates, however, do not have this. So, let’s <a id="_idIndexMarker740"/>have a look at how to add it. We’ll begin with a clean, empty Console application.</p>
			<p>The first thing we need to do is add the correct NuGet package. In this case, you need to install <code>Microsoft.Extensions.Logging</code> in your project. Once you have done that, you will have access to the logging framework.</p>
			<p>In your main project, you can set up the logging like this:</p>
			<pre class="source-code">
using Microsoft.Extensions.Logging;
ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.SetMinimumLevel(LogLevel.Information);
});
var logger = loggerFactory.CreateLogger&lt;Program&gt;();
logger.LogInformation("This is some information");</pre>			<p>This code works. If you run it, you will not get any errors. However, you will also not get any output, so that is pretty useless, to be honest.</p>
			<p>This is because the framework is quite flexible. It can handle all sorts of outputs to various destinations. However, you have to specify what you want.</p>
			<p>Let’s fix this. Install another NuGet package; this time, we need the <code>Microsoft.Extensions.Logging.Console</code> package. Once you have installed that, we need to change the code in the <code>LoggerFactory.Create()</code> method to look like this:</p>
			<pre class="source-code">
var loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.AddConsole();
    builder.SetMinimumLevel(LogLevel.Information);
});</pre>			<p>In the<a id="_idIndexMarker741"/> second line, we added the Console as a way to output.</p>
			<p>If you run the program this time, you will get the desired information:</p>
			<div><div><img alt="Figure 10.1: Output from the log" src="img/B20924_11_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Output from the log</p>
			<p>OK. We <a id="_idIndexMarker742"/>got something on our screen. Let’s see what we have done so far since I deliberately skipped over some steps.</p>
			<p><code>LoggerFactory</code> is a factory class that can create instances of a class that implements <code>Ilogger&lt;T&gt;</code>. We set up <code>LoggerFactory</code> by hooking up the desired outputs (in our case, Console; we’ll add others later). We also gave it the minimum log level we wanted.</p>
			<p>Let’s dive into this. I want to discuss log levels and configuration, as well as the different tools we have.</p>
			<h3>Log levels</h3>
			<p>Not all<a id="_idIndexMarker743"/> messages are equally important. If you are starting out on your project, you will probably want to log a lot. You can output anything you want and you will probably do so. You can write the contents of variables, loop controls, where you are in the flow, and so on. Anything that can help you understand the flow of your program as you run it is a candidate for logging.</p>
			<p>However, once you have written and tested your software, you will probably not want all of that information anymore. You might want to log exceptional cases and errors, but that is about it.</p>
			<p>To achieve that, you must remove all the logging code that you do not need anymore. Alternatively, you could wrap up the code in <code>#IF / #ENDIF</code> statements and thus effectively remove the calls when you recompile using a different <code>#DEFINE</code>. However, that means changing your code. That could lead to side effects. If you later find a bug and decide that you need that code in again, you will need to rewrite or recompile the system.</p>
			<p><code>Loglevels</code> eliminates that problem.</p>
			<p>Each log message we write has a level. In the preceding example, we used <code>Log.LogInformation()</code>. That means that we want to write something informational. There <a id="_idIndexMarker744"/>are other levels we can use as well. What you use them for is entirely up to you. However, in general, there is meaning to each level. These are the levels we can use with <code>ILogger</code>:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"> </strong><strong class="bold">Log level</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold"> </strong><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Trace</p>
						</td>
						<td class="No-Table-Style">
							<p> This refers to the most detailed messages. These messages may contain sensitive application data and are therefore not recommended to be enabled in a production environment unless they are necessary for troubleshooting and only for short periods.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Debug</p>
						</td>
						<td class="No-Table-Style">
							<p>This displays messages that are useful for debugging. It is less verbose than Trace, but more than Information.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Information</p>
						</td>
						<td class="No-Table-Style">
							<p>This allows the system to show informational messages that highlight the general flow of the application. It is useful for general application insights.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Warning</p>
						</td>
						<td class="No-Table-Style">
							<p>This is all about messages that highlight an abnormal or unexpected event in the application flow, but which do not otherwise cause the application execution to stop.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Error</p>
						</td>
						<td class="No-Table-Style">
							<p>These are messages that highlight when the current flow of execution is stopped due to a failure. These should indicate a failure in the current activity, not an application-wide failure.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Critical</p>
						</td>
						<td class="No-Table-Style">
							<p>This is about messages describing an unrecoverable application, system crash, or catastrophic failure requiring immediate attention.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> None</p>
						</td>
						<td class="No-Table-Style">
							<p>This results in no messages being logged. This level is used to turn off logging.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 Log levels in Microsoft Logger</p>
			<p>There are two ways in which you can specify what level your message has to be. You can use one of the dedicated log methods (such as <code>LogInformation</code>, <code>LogTrace</code>, <code>LogDebug</code>, and so on) or the generic <code>Log()</code> method. That looks like this:</p>
			<pre class="source-code">
logger.Log(LogLevel.Critical, "This is a critical message");</pre>			<p>You just <a id="_idIndexMarker745"/>call <code>Log()</code> and then give it the <code>LogLevel</code>. Whatever method you choose, you can decide what level the log is supposed to be on.</p>
			<p>However, that only solves a part of the issue. We want to be flexible in what we output to the screen. That’s where the <code>SetMinimumLevel()</code> method on the <code>ILoggingBuilder</code> comes into play.</p>
			<p>The method determines what the log is writing to the chosen output channels. If you set it to <code>Information</code>, all calls to the log are processed if they are of the Information level or higher. In other words, all calls to <code>Log.LogTrace()</code>, <code>Log.Debug()</code>, <code>Log.Log(LogLevel.Trace)</code>, and <code>Log.Log(LogLevel.Debug)</code> are ignored. So you can, in one line, determine what you do and do not want to appear on the logs. You specify the level and all information on that level or above is outputted. The rest is ignored.</p>
			<p>During development, you might want to set the level to Trace. After extensive testing, you might want to set it to <code>Critical</code> or maybe <code>Error</code> during production.</p>
			<h3>Using a Settings file</h3>
			<p>Of course, we<a id="_idIndexMarker746"/> are not there yet. If you want to change the log level, you still need to change the code and recompile the system. Let’s change that so we can use something else.</p>
			<p>Add a new file to your program called <code>appsettings.json</code>. Make sure you change the <code>Copy to output directory</code> property to <code>Copy if newer</code>; you need this file next to the binaries.</p>
			<p>The file should look like this:</p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  }
}</pre>			<p>Now, we need to add a couple of NuGet packages. Install <code>Microsoft.Extensions.Configuration.JSon</code> and <code>Microsoft.Extensions.Logging.Configuration</code>.</p>
			<p>When we have<a id="_idIndexMarker747"/> done that, we will add the following code that actually reads the configuration:</p>
			<pre class="source-code">
var configurationBuilder = new ConfigurationBuilder()
    .AddJsonFile(
        path: "appsettings.json",
        optional:true,
        reloadOnChange:true);
var configuration = configurationBuilder.Build();
var configurationSection=
    configuration.GetSection("Logging");</pre>			<p>This code creates a <code>ConfigurationBuilder</code> and then adds the JSON file we just added. We set the <code>optional</code> parameter to <code>true</code>; if people decide to remove the file, our app will still work. We also specify that the <code>reloadOnChange</code> parameter is <code>true</code>. As you have probably guessed, the configuration is reloaded when the file changes.</p>
			<p>The following is relatively straightforward: we call <code>Build()</code> to get the <code>IConfiguration</code>, then call <code>GetSection</code> (Logging) to load that specific part of our JSON file.</p>
			<p>We need to do some work on our <code>LoggerFactory</code> as well. Change it to look like this:</p>
			<pre class="source-code">
var loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.AddConsole();
    builder.AddConfiguration(configurationSection);
});</pre>			<p>Instead of <a id="_idIndexMarker748"/>hardcoding the log level, we will now give it the configuration section from the JSON file.</p>
			<p>Lastly, let’s change the code that does the actual logging a bit. I will wrap it in a continuous loop:</p>
			<pre class="source-code">
while (true)
{
    logger.LogTrace("This is a trace");
    logger.LogDebug("This is debug");
    logger.LogInformation("This is information");
    logger.LogWarning("This is warning");
    logger.LogError("This is an error");
    logger.LogCritical("This is a critical message");
    await Task.Delay(1000);
}</pre>			<p>Run your program and see all the different ways of displaying your message. Open another terminal window, navigate to the compiled application folder, and change the log setting in the <code>appsettings.json</code> file. As soon as you save the file, you will see a different behavior in the application. Depending on your desire, it will display more or fewer lines of logging.</p>
			<p>Now, you can add all the logging you want to your application, use <code>Trace</code> during debugging and development, and then move to <code>Critical</code> or <code>Error</code> if your system is ready for production. You can quickly return to a more detailed debugging level as soon as something happens. All of that is done without recompiling!</p>
			<h3>Using EventId</h3>
			<p>Having different debugging levels is nice, but that is not enough to structure the information if you<a id="_idIndexMarker749"/> have a lot of messages. To help you create a bit of order in the logging chaos, you can use the <code>EventId</code>.</p>
			<p>All log methods have an overload that allows you to add an <code>EventId</code>. An <code>EventId</code> is a class that contains an ID in the <code>integer</code> form and a name in the <code>string</code> form. What those are is entirely left up to you. The name is not even used in the logs, but it is there for your convenience during development. We can create an <code>EventId</code>, or multiple, as follows:</p>
			<pre class="source-code">
var initEventId = new EventId(1, "Initialization");
var shutdownEventId = new EventId(2, "Shutdown");
var fileReadingEventId = new EventId(3, "File Reading");</pre>			<p>I just made up a bunch of categories: <code>Initialization</code>, <code>Shutdown</code>, and <code>File Reading</code>. This is just an example; I am sure that you can come up with much better names.</p>
			<p>When you log something, you can use an <code>EventId</code> to indicate that the message you log has to do with a certain part of the system. That looks like this:</p>
			<pre class="source-code">
logger.LogInformation(initializationEventId, "Application started");
logger.LogInformation(shutdownEventId, "Application shutting down");
logger.LogError(fileReadingEventId, "File not found");</pre>			<p>The output now looks a bit different:</p>
			<div><div><img alt="FIgure 10.2: Output of logging with an EventId (or multiple)" src="img/B20924_11_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">FIgure 10.2: Output of logging with an EventId (or multiple)</p>
			<p>Next to the <code>Log</code> type and the <code>Program</code>, you can see the number between brackets. That is the number of the <code>EventId</code> type. In our case, <code>1</code> was initialization, <code>2</code> was shut down, and <code>3</code> was<a id="_idIndexMarker750"/> file reading. Again, these strings are never used and, unfortunately, are not shown on the screen. However, having these numbers in there can help you find the areas that you are interested in.</p>
			<h3>Using Type information</h3>
			<p>There is one last <a id="_idIndexMarker751"/>thing you can use to organize your logs. I didn’t explain it earlier, but you must have noticed that when we created the instance of our <code>logger</code>, we gave it a <code>Program</code> type parameter:</p>
			<pre class="source-code">
var logger = loggerFactory.CreateLogger&lt;Program&gt;();</pre>			<p>Since we called <code>CreateLogger</code> with the <code>Program</code> type, we see the <code>Program</code> string on the screen in the logs.</p>
			<p>You can create several instances of the <code>ILogger</code> interface, each with its own type attached to it. That way, you can create different loggers for each application part. If you have a part of your system that handles printing and the main class is called <code>Printer</code>, you can create a logger of the <code>Printer</code> type like this:</p>
			<pre class="source-code">
var printLogger = loggerFactory.CreateLogger&lt;Printer&gt;();</pre>			<p>All logs written to the <code>printLogger</code> instance will now show <code>Printer</code> in their log lines instead of <code>Program</code>. Of course, it doesn’t really matter what you pass in that parameter. You can use the <code>Printer</code> logger in your main program if you want to. It is just decoration that helps you organize the output of the logs. That’s it. There is no logic behind it.</p>
			<p class="callout-heading">Using categories wisely</p>
			<p class="callout">I suggest you use these categories, but use them sparingly; too many will only clutter your logs. I usually create empty classes just for use in the logger creation. That way, I can get a nice set of logger instances without relying on internal code that nobody outside should see. However, I will leave that entirely up to you.</p>
			<p>Now that we have basic logging out of the way, it is time to look at some popular alternatives that offer some other nifty tricks we can use. Let us begin with NLog!</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor227"/>NLog</h2>
			<p>Microsoft is <a id="_idIndexMarker752"/>not the only company that offers a logging framework. There <a id="_idIndexMarker753"/>are others out there, each with their own strengths and weaknesses. One of the more popular ones out there is <strong class="bold">NLog</strong>.</p>
			<p>NLog was created by Jared Kowalski in 2006 as an alternative to the popular log4net solution, which is a port of the immensely popular log4j Java logging solution. Kowalski aimed to build a logging solution that was high in performance but also flexible in the configuration of the settings.</p>
			<h3>Setting up NLog</h3>
			<p>To use <a id="_idIndexMarker754"/>NLog, you need to install the corresponding NuGet package. The name of the package is simply <code>NLog</code>.</p>
			<p>Once you have installed that package, we must create a configuration file. To do that, add a new XML file to your project (do not forget to set the properties to <code>Copy if newer</code> so that the project can find the file when it runs). By convention, this file is called <code>NLog.config</code>, but you can choose any name. The file should look like this:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd
      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
      &gt;
  &lt;targets&gt;
    &lt;target
      name="logfile"
      xsi:type="File"
      fileName="${basedir}/logs/logfile.txt"
      layout="${date:format=HH\:mm\:ss} ${logger} ${uppercase:${level}} ${message}" /&gt;
    &lt;target
      name="logconsole"
      xsi:type="Console" /&gt;
  &lt;/targets&gt;
  &lt;rules&gt;
    &lt;logger name="*"
            minlevel="Info"
            writeTo="logfile,logconsole" /&gt;
  &lt;/rules&gt;
&lt;/nlog&gt;</pre>			<p>You can control <a id="_idIndexMarker755"/>almost all of NLog through this configuration file. You can set up all parameters in code, but that kind of defeats the purpose of NLog. I suggest that you use the <code>configuration</code> file and avoid setting things in the code. That is unless you have a really good reason to do otherwise, of course. After all, it is still your code, not mine.</p>
			<p>Now, it is time to start logging. In your program, add the following code:</p>
			<pre class="source-code">
using NLog;
LogManager.Configuration =
    new XmlLoggingConfiguration(
        "NLog.config"
    );
try
{
    Logger logger = LogManager.GetCurrentClassLogger();
    logger.Trace("This is a trace message");
    logger.Debug("This is a debug message");
    logger.Info("Application started");
    logger.Warn("This is a warning message");
    logger.Error("This is an error message");
    logger.Fatal("This is a fatal error message");
}finally{
    LogManager.Shutdown();
}</pre>			<p>First, we<a id="_idIndexMarker756"/> will load the configuration in the <code>LogManager</code>. You usually have one setup for all your logging needs in your entire application, so you might as well do this first.</p>
			<p>Then, we will call <code>GetCurrentClassLogger()</code>. This call is the equivalent of the call to <code>CreateLogger&lt;T&gt;</code> in the Microsoft framework. It ties the current class name to the logger so you can categorize your logs.</p>
			<p>If you want other loggers to be associated with different classes, you can do so by calling something like this:</p>
			<pre class="source-code">
var otherLogger  = LogManager.GetLogger("OtherLogger");</pre>			<p>This call creates another logger with the same configuration but will show <code>"OtherLogger"</code> in the output this time.</p>
			<p>The rest of the code is self-explanatory, except for the line that says <code>LogManager.Shutdown()</code>. This line is needed to flush out all logs in the code and ensure that no message is left behind.</p>
			<h3>Log levels in NLog logging</h3>
			<p>As with the<a id="_idIndexMarker757"/> Microsoft framework, you can specify which level you want to see in the log files. The levels for NLog are comparable, but there are minor differences. The following table shows the available options:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-7">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">NLog level</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Trace</p>
						</td>
						<td class="No-Table-Style">
							<p>This provides the most detailed information. Use this for the most low-level debug information.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Debug</p>
						</td>
						<td class="No-Table-Style">
							<p>This provides coarse-grained debugging information. It is less detailed than Trace.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Info</p>
						</td>
						<td class="No-Table-Style">
							<p>Informational messages that highlight the general flow of the application come with this level.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Warn</p>
						</td>
						<td class="No-Table-Style">
							<p>Potentially harmful situations of interest to end users or system managers that indicate potential problems are flagged at this level.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Error</p>
						</td>
						<td class="No-Table-Style">
							<p>Error events of considerable importance that will prevent normal program execution but might still allow the application to continue running are flagged here.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Fatal</p>
						</td>
						<td class="No-Table-Style">
							<p>This level focuses on very severe error events that will presumably lead the application to abort.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> Off</p>
						</td>
						<td class="No-Table-Style">
							<p>This involves no logging at all.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.2: Log levels in NLog</p>
			<p>As you can see, the<a id="_idIndexMarker758"/> levels are almost the same; they are just named differently. That makes it harder to remember when you switch from one framework to another, but we can do nothing about that. We have to memorize the terms, I guess.</p>
			<h3>NLog targets</h3>
			<p>You <a id="_idIndexMarker759"/>control NLog through the configuration file. That is one of the two main principles that drove the development of NLog (the other being that NLog should be highly performant).</p>
			<p>In the sample we have worked on, we wrote the logs in both the Console and a file. In the <code>settings</code> file, we have defined different targets where NLog writes the logs. Currently, more than 100 different targets are available, some of which are part of the core package and some of which require a NuGet package.</p>
			<p>Let’s have a look at another target. We currently use <code>Console</code>, but we can replace that with <code>ColoredConsole</code>. That is part of the default package, so we do not have to add a NuGet package.</p>
			<p>In the <a id="_idIndexMarker760"/>configuration, add a new target to the <code>targets</code> section. It looks like this:</p>
			<pre class="source-code">
&lt;target
  name="logcolorconsole"
  xsi:type="ColoredConsole"
  header="Logfile for run ${longdate)"
  footer="-----------"
  layout="${date:format=HH\:mm\:ss} ${logger}
${uppercase:${level}} ${message}" /&gt;</pre>			<p>This segment tells NLog that we want to use a new target of the <code>ColoredConsole</code> type. We can call it <code>logcolorconsole</code>.</p>
			<p>We also specified a header that should display the <code>Logfile for run</code> text and then the current data. I also added a footer that consists of a simple line. The layout section is the same as the one we used with the file: we display the time (in the <code>HH:mm:ss</code> format), the name of the logger (which is <code>Program</code> or <code>OtherLogger</code>, depending on the line we are on), the level of the log in uppercase, and finally the message itself.</p>
			<p>You can vary this as much as you want and add or remove elements at will. You can also set up rules on what to display depending on various factors, such as the level.</p>
			<p>We must also add it to the rules. Just for simplicity, I removed the file and console as a target and used the new <code>logcolorconsole</code> one:</p>
			<pre class="source-code">
&lt;rules&gt;
  &lt;logger name="*"
          minlevel="Info"
          writeTo="logcolorconsole" /&gt;
&lt;/rules&gt;</pre>			<p>If you run the sample after making these changes, you will see a set of colorful lines. Yes, you can change or alter the colors based on the level. The options are almost endless.</p>
			<p>As I said, there<a id="_idIndexMarker761"/> are over 100 targets available. Let me give you a shortened list of some of the more commonly used targets:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Target name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">NuGet package</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>File Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Logs data to files on a disk with options for filenames, directories, rotations, and archiving</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Console Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to the standard output or error streams; useful during development</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ColoredConsole Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to the Console with color coding based on log level</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Database Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Logs messages to a database using parameterized SQL commands</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>EventLog Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Writes log entries to the Windows Event Log; ideal for Windows apps</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog.WindowsEventLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Mail Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log entries as email messages; suitable for alerts and monitoring</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog.MailKit</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Network Targets</p>
						</td>
						<td class="No-Table-Style">
							<p>Includes WebService, TCP, and UDP targets for logging over networks</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Trace Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to .NET trace listeners, integrating with other diagnostics tools</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Memory Target</p>
						</td>
						<td class="No-Table-Style">
							<p>Logs messages to an in-memory list of strings, mainly for debugging purposes</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Null Target</p>
						</td>
						<td class="No-Table-Style">
							<p>A target that does nothing; useful for disabling logging in certain scenarios</p>
						</td>
						<td class="No-Table-Style">
							<p>NLog</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.3: Targets in NLog</p>
			<p>I recommend you <a id="_idIndexMarker762"/>look at the documentation at <a href="https://nlog-project.org/config/">https://nlog-project.org/config/</a> to see the different options and the settings per option. It is pretty extensive!</p>
			<h3>Rules in NLog</h3>
			<p>In addition to the <a id="_idIndexMarker763"/>targets, you can set rules in NLog. The rules define which target is used under which circumstances.</p>
			<p>In our example, we used one rule: all logs should go to the Console and <code>file</code> targets or the <code>ColoredConsole</code> target, which we named <code>logcolorconsole</code>.</p>
			<p>Let’s change that a bit; I want to make it more intelligent. Change the rules section so that it looks like this:</p>
			<pre class="source-code">
&lt;rules&gt;
  &lt;logger name="*"
          minlevel="Trace"
          writeTo="logfile" /&gt;
  &lt;logger name="Program"
          minLevel="Warn"
          writeTo="logcolorconsole" /&gt;
  &lt;logger name="OtherLogger"
          minLevel="Info"
          writeTo="logconsole" /&gt;
&lt;/rules&gt;</pre>			<p>We now have<a id="_idIndexMarker764"/> three rules:</p>
			<ul>
				<li>The first is the catch-all. By writing <code>name="*"</code>, we tell the system to take all loggers. The minimum level we want is Trace, the lowest level, so we want all messages (yes, you can also define a maximum level). We define the target as a <strong class="bold">logfile</strong>. This target is the one that writes to a file.</li>
				<li>The second rule only applies to the logger that has the name <code>Program</code>. Thus, all loggers are created by calling <code>GetCurrentClassLogger()</code> using our <code>Main</code> method. We raise the minimum level to Warn; we are not interested in anything below that. The file catches this. We want to see them in nice colors, so we specify the <code>writeTo</code> parameter as <code>logcolorconsole</code>.</li>
				<li>All messages sent to the logger named <code>OtherLogger</code> are the subject of the third rule. We want all messages of the Info level or above, and we want to see them processed by our colorless, default Console logger.</li>
			</ul>
			<p>Run the sample. See how messages on different loggers get sent to the right place.</p>
			<h3>Asynchronous logging</h3>
			<p>Remember <a id="_idIndexMarker765"/>when I said that anything that takes longer than a few clock cycles should be done asynchronously? Well, NLog allows you to log to databases or network connections. They definitely have long-running operations. Unfortunately, there is no such method as <code>LogAsync()</code> in NLog. However, there is another solution to this.</p>
			<p>There is a target called <code>AsyncWrapper</code>. As the name suggests, this is a wrapper around other targets that make them work asynchronously. All you have to do is add that to the configuration like this:</p>
			<pre class="source-code">
&lt;target
  name="asyncWrapper"
  xsi:type="AsyncWrapper"&gt;
  &lt;target
    name="logfile"
    xsi:type="File"
    fileName="${basedir}/logs/logfile.txt"
    layout="${date:format=HH\:mm\:ss} ${logger} ${uppercase:${level}} ${message}" /&gt;
  &lt;/target&gt;</pre>			<p>Although the <a id="_idIndexMarker766"/>methods are still synchronous, NLog places all the log messages in a queue on a separate thread and writes them to the target on that thread instead of on the calling thread. You can set several variables to determine how long the delay must be, how long the queue can become, and so on. However, we have eliminated our delay when writing to a file, a database, or a network connection. I strongly suggest that you use that wrapper for anything besides Console!</p>
			<h3>Two useful but often neglected additional settings</h3>
			<p>There <a id="_idIndexMarker767"/>are two more things I want to show you in the configuration file.</p>
			<p>The root element, NLog, can have a property named <code>autoReload=true</code>. If you set that, you can have NLog pick up changes in the log file while the application runs. We saw a similar option with the Microsoft logger; it is good to know that NLog also supports this.</p>
			<p>With all the available rules, targets, variables, and other things you can set in the configuration file, you might wonder what to do if things go wrong.</p>
			<p>The people behind NLog thought of that as well. You can turn on logging for NLog itself. All you have to do is change the root entry to look like this:</p>
			<pre class="source-code">
&lt;nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd
      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
      autoReload="true"
      internalLogFile="${basedir}/logs/internallog.txt"
      internalLogLevel="Trace"
      &gt;</pre>			<p>I have added the <code>internalLogFile</code> and <code>internalLogLevel</code> properties. Adding these properties results in NLog logging its internal logs to the given file. Doing this might help<a id="_idIndexMarker768"/> you find issues in your logging. It is all becoming a bit metaphysical, but you can log better by logging the workings of the log. Give it a try!</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor228"/>Serilog</h2>
			<p>There is one<a id="_idIndexMarker769"/> more framework I want to share with you. Serilog is a<a id="_idIndexMarker770"/> popular logging framework that first saw the light of day in 2013.</p>
			<p>The idea behind Serilog is that it allows for structured logging. So far, all the logs we have seen have all just been one-liners with some text. Serilog is built around the idea that structure can bring clarity.</p>
			<p>Let me show you what I mean by that. Let’s build a sample.</p>
			<p>Although Serilog can (and should) be controlled by the settings in a configuration file, I will control this final example exclusively through code. I want to show you how to do that so you have at least seen it once.</p>
			<p>However, again, since you want to change logging depending on the state of the system, you are better off having a configuration file that you can change without recompiling.</p>
			<p>Of course, we will begin by creating a new Console application and adding some NuGet packages.</p>
			<h3>Standard logging with Serilog</h3>
			<p>NLog has<a id="_idIndexMarker771"/> targets, and Serilog <a id="_idIndexMarker772"/>has <strong class="bold">sinks</strong>. You have to install all the sinks you need from different packages. I will only use Console and File in my sample, but there are others: SQL Server, HTTP, AWS, and so on.</p>
			<p>You need to install the <code>Serilog</code>, <code>Serilog.Sinks.Console</code> and <code>Serilog.Sinks.File</code> NuGet packages.</p>
			<p>Let’s write the code:</p>
			<pre class="source-code">
using Serilog;
var logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console()
    .WriteTo.File(path:
        "logs\\log.txt",
        rollingInterval: RollingInterval.Day)
    .CreateLogger();
try
{
    logger.Verbose("This is verbose");
    logger.Debug("This is debug");
    logger.Information("This is information");
    logger.Warning("This is warning");
    logger.Error("This is error");
    logger.Fatal("This is fatal");
}
finally
{
    await Log.CloseAndFlushAsync();
}</pre>			<p>This code should <a id="_idIndexMarker773"/>look familiar. We create a configuration, this time all in code; we create a logger and log our messages. We end with a <code>CloseAndFlushAsync()</code> to ensure nothing is left in some buffer.</p>
			<p>There is nothing special about this code. OK, the new thing here is the <code>RollingInterval</code>. This property determines when the system should create a new file. You can set that to anything from a minute to a year. If you do not want to create a new file at any point, you can also set it to <code>Infinite</code>. That way, the system creates the file once and never again (unless you delete it, of course).</p>
			<p>Apart from<a id="_idIndexMarker774"/> that, there is nothing remarkable about Serilog. However, let’s change that. Change the parameters in the call to <code>WriteTo.File()</code> so that it looks like the following:</p>
			<pre class="source-code">
var logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.File(
        new JsonFormatter(),
        "logs\\log.txt",
        rollingInterval: RollingInterval.Day)
    .CreateLogger();</pre>			<p>In this code sample, I added a <code>JsonFormatter</code> to the output of both the console and the file. When you add a formatter, you tell Serilog to output the logs a certain way. The <code>JsonFormatter</code> formatter forces the output to be in (well, you guessed it) the JSON format.</p>
			<p>To truly use the structure log, we must change how we log the messages. Let’s add one line to the part where we write the logs:</p>
			<pre class="source-code">
logger.Information(
    "The user with userId {userId} logged in at {loggedInTime}",
    42,
    DateTime.UtcNow.TimeOfDay);</pre>			<p>As you can see, we log a line of text, but instead of building that string beforehand, we do it in the message. In this case, we give it named parameters, <code>userId,</code> and <code>loggedInTime</code>, and<a id="_idIndexMarker775"/> then pass in the values that we want to display.</p>
			<p>If you run it now, that last line, after formatting, results in this:</p>
			<pre class="source-code">
{
    "Timestamp": "2024-04-20T11:47:31.5139218+02:00",
    "Level": "Information",
    "MessageTemplate": "The user with userId {userId} logged in at {loggedInTime}",
    "Properties": {
        "userId": 42,
        "loggedInTime": "09:47:31.5125828"
    }
}</pre>			<p>As you can see, a lot more information is suddenly available. The structure of the logline is such that if we store it in a system somewhere, we can easily query the lines. Later in this chapter, I will show you how this is done.</p>
			<p>So, Serilog is comparable to the other two frameworks until you use one of the many formatters. The ability to store the log information to easily query it makes it a very powerful tool to have in your toolbelt!</p>
			<h3>Log levels in Serilog logging</h3>
			<p>As you will <a id="_idIndexMarker776"/>probably expect by now, Serilog also has levels. Those levels should look very familiar to you. This table shows the levels that Serilog offers and what they are meant to do.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-3">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Serilog level</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Verbose</p>
						</td>
						<td class="No-Table-Style">
							<p>This contains the most detailed information. These messages may contain sensitive application data and are therefore not recommended for production unless hidden.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Debug</p>
						</td>
						<td class="No-Table-Style">
							<p>This level contains information that is useful in development and debugging.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Information</p>
						</td>
						<td class="No-Table-Style">
							<p>This level contains informational messages that highlight the general flow of the application. It is useful for general application insights.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Warning</p>
						</td>
						<td class="No-Table-Style">
							<p>Indications of possible issues or service and functionality degradation are included at this level.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Error</p>
						</td>
						<td class="No-Table-Style">
							<p>Errors and exceptions that cannot be handled or are unexpected are included here.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Fatal</p>
						</td>
						<td class="No-Table-Style">
							<p>This level focuses on critical errors causing complete failure of the application and requiring immediate attention.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Silent</p>
						</td>
						<td class="No-Table-Style">
							<p>This is the level for no logging at all (Serilog does not explicitly define a Silent level, but logging can effectively be turned off).</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.4: Serilog log levels</p>
			<p>Again, there are <a id="_idIndexMarker777"/>no surprises here. As with the other frameworks, you can use this however you want: no one can stop you from adding lots of debug information to the Error level. It is just not a very good idea.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor229"/>Comparing the logging frameworks</h2>
			<p>After <a id="_idIndexMarker778"/>having seen all of these frameworks, you might wonder: which one should I pick? The answer is simple: choose whichever one you feel most comfortable with.</p>
			<p>All frameworks have pros and cons; none are bad or extremely good. They do have different use cases and areas of attention. The following table highlights some of those:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Feature</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">.</strong><strong class="bold">NET Logger</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">NLog</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Serilog</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Overview</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Reliable and integrates seamlessly with .NET</p>
						</td>
						<td class="No-Table-Style">
							<p>Rich in features, great for a wide range of applications</p>
						</td>
						<td class="No-Table-Style">
							<p>Excels in structured logging, making data meaningful and searchable</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Integration</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Deeply integrated with .NET Core, supports dependency injection and configuration settings</p>
						</td>
						<td class="No-Table-Style">
							<p>Flexible, can be used in various .NET applications, supports multiple targets</p>
						</td>
						<td class="No-Table-Style">
							<p>Great with .NET applications, especially for structured data stores such as Seq or Elasticsearch</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Pros</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Minimal setup</p>
							<p>Supports structured logging</p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced log routing and filtering; logs to multiple targets simultaneously</p>
						</td>
						<td class="No-Table-Style">
							<p>Exceptional at structured logging; supports enrichers for additional context</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Cons</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Less feature-rich without third-party providers</p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration can get complex</p>
						</td>
						<td class="No-Table-Style">
							<p>Might be overkill for simple needs; best features require compatible logging targets</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Best for</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Projects that need straightforward logging with minimal setup</p>
						</td>
						<td class="No-Table-Style">
							<p>Applications requiring detailed control over logging, or when logging into multiple places</p>
						</td>
						<td class="No-Table-Style">
							<p>Projects where structured logging and data querying are priorities</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.5: Comparison between the logging frameworks</p>
			<p>You just have to<a id="_idIndexMarker779"/> look at your own needs and determine your scenario and way of working best. Pick that tool. My advice is to give the others a go. You might find a new favorite logging framework!</p>
			<p>So, we have now looked at logging. We have seen the most commonly used frameworks and how to use them. We have looked at default Microsoft logging; we have had an in-depth look at NLog and its robust collection of targets and rules. Finally, we have looked at Serilog’s structured logging approach.</p>
			<p>You should be<a id="_idIndexMarker780"/> able to use logging from now on. However, logging is part of your application. What if you do not get all the information you need from logging? That is where monitoring comes into play. Let’s have a look at that next!</p>
			<p class="callout-heading">A word of caution</p>
			<p class="callout">Logging is very useful. In fact, I would suggest that you cannot do serious development on systems without a UI if you do not have extensive logging. However, you must be careful: it is too easy to leak sensitive information about your system. Consider things such as connection strings, credentials, and other sensitive information. Also, you might sometimes accidentally disclose information about the inner workings of your system or even about the organization that this system runs. Be careful. Do not assume that people will not try to move the log level to Trace to see what is happening. Log as much as possible, but be mindful of the dangers!</p>
			<p>Logging is one of the best things you can do to solve development and production issues. However, there is more that we can do. We need insights into these logs, but we must also monitor things such as memory usage, CPU usage, and much more. Let’s talk about monitoring next!</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/>Monitoring your applications</h1>
			<p>We need to keep<a id="_idIndexMarker781"/> an eye on things as our software runs. During development, we can turn on extensive logging to the console or to a file, which helps us track errors and issues. However, once our code runs on the final machine, it needs to run, and it might be a bit harder to look at all those log files.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/>Monitoring with Seq</h1>
			<p>Monitoring<a id="_idIndexMarker782"/> the system’s state is essential to keep things healthy. One of the great tools we have available to do this is Seq. Seq and Serilog are a match made in heaven!</p>
			<p>One of the reasons why Serilog is getting so much attention these days is because of its ability to write<a id="_idIndexMarker783"/> logs in a structured manner. We looked at this in the previous section but did not dive into what we could do. It is time to change that.</p>
			<p>Since the logs coming <a id="_idIndexMarker784"/>from Serilog are formatted in a particular way, we can also store them in a specific way. One of the tools that allow us to do so is Seq. Seq is a tool by the company Datalust. You can get a free personal license from them to play around with your logs. You can choose to install Seq on your machine, or you can choose to download a Docker image that contains everything you need. I prefer the latter, but it doesn’t matter which option you choose. The Datalust website clearly explains how to get the bits. You can find the documentation at <a href="https://docs.datalust.co/docs/an-overview-of-seq">https://docs.datalust.co/docs/an-overview-of-seq</a>. In the <em class="italic">Technical requirements</em> section of this chapter, I have shown you the Docker command that you will need to execute to get a local version of Seq running.</p>
			<p>Once you <a id="_idIndexMarker785"/>have done that, you can actually start to use Seq. We need to change our code a little bit. In addition to the packages that we installed earlier to enable logging to <code>Console</code> and <code>File</code>, we will also need a new package: <code>Serilog.Sinks.Seq</code>.</p>
			<p>Once you have installed that, we must change the setup of the log a bit. That looks like this:</p>
			<pre class="source-code">
var logger = new LoggerConfiguration()
    .MinimumLevel.Verbose()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.File(
        new JsonFormatter(),
        "logs\\log.json",
        rollingInterval: RollingInterval.Day)
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();</pre>			<p>As you can see, we added a new <code>Sink</code> to our configuration, and this time, we are writing to Seq. I use the default port <code>5341</code>, since this is the port that Seq listens to.</p>
			<p>If I run the application and go to the Seq dashboard on my machine, I will also get to see the logs there. That looks like this:</p>
			<div><div><img alt="Figure 10.3: Serilog captured by Seq" src="img/B20924_11_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: Serilog captured by Seq</p>
			<p>You can<a id="_idIndexMarker786"/> clearly see all log messages. They are nicely colored. I<a id="_idIndexMarker787"/> have also opened the last message, in which we added some structural information. Seq captures this information and shows you exactly what is going on.</p>
			<p>You can also query over the logs by entering a SQL-like statement in the top edit box. That looks like this:</p>
			<div><div><img alt="Figure 10.﻿4: Seq dashboard with a filter for user Id." src="img/B20924_11_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: Seq dashboard with a filter for user Id.</p>
			<p>I added the <code>userId = 42</code> query in the edit box. This results in Seq only showing all messages about the user whose <code>userId</code> is <code>42</code>.</p>
			<p>The<a id="_idIndexMarker788"/> query language is extensive and you can write complex queries. This<a id="_idIndexMarker789"/> means that you can always find what you need even if you log many messages.</p>
			<p>Seq is extremely powerful and yet easy to set up. I highly recommend checking it out!</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/>Performance counters</h1>
			<p>Windows gives <a id="_idIndexMarker790"/>us lots of tools to monitor our systems, such as <code>EventViewer</code>. We can use those tools in our own systems as well. For instance, there are a lot of performance counters available that you can access both inside and outside of your code.</p>
			<p>Let’s look at how to get that in our code first.</p>
			<p>I started a new Console application, added the <code>System.Diagnostic</code> NuGet package, and then wrote the following code:</p>
			<pre class="source-code">
using System.Diagnostics;
using ExtensionLibrary;
#pragma warning disable CA1416
var counter = 0;
var cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
while (true)
{
    if (counter++ == 10)
        // Start a method on a background thread
        Task.Run(() =&gt;
        {
            Parallel.For(0, Environment.ProcessorCount, j =&gt;
            {
                for (var i = 0; i &lt; 100000000; i++)
                {
                    var result = Math.Exp(Math.Sqrt(Math.PI));
                }
            });
            counter = 0;
        });
    var cpuUsage = cpuCounter.NextValue();
    var message = $"CPU Usage: {cpuUsage}%";
    var color = cpuUsage &gt; 10 ? ConsoleColor.Red : ConsoleColor.Green;
    message.Dump(color);
    await Task.Delay(200);
}</pre>			<p>Near <a id="_idIndexMarker791"/>the top of the file, I have created an instance of the <code>PerformanceCounter </code>class. This class gives us access to all the performance counters that we have mentioned, so we can also use them in our code. We need to specify the category and the item in that category we want to monitor. In my case, I went for <code>Processor</code> and <code>% Processor Time</code>, which are indicators of the load on the CPUs</p>
			<p>Then, I start a never-ending loop in which I increase a counter. As soon as that counter reaches <code>10</code>, I do some silly calculations on all the CPUs available on my machine. These calculations do not do anything useful besides keeping the CPUs busy. All this happens on a background thread, so the main loop keeps displaying how busy the system is.</p>
			<p>For readability, I will also change the color of the output if the CPU percentage is over 10%. You might have to change this threshold if you have a slower or faster machine than I do.</p>
			<p>If you<a id="_idIndexMarker792"/> run this, you will be able to see how busy the system is. You should see a nice green output, but the system will get busier every few seconds, as shown by the red output.</p>
			<p>You can measure many items, tracking what the computer is doing. Suppose that you want to find out what you can monitor. In that case, you only need to open the Performance Monitor application on your Windows machine (search for <code>perfmon.exe</code>). You can add counters to the main screen; the dialog that shows them is a good source of information. Make sure that you check the <strong class="bold">Show description</strong> box at the bottom of the screen to see what all the counters do. To give you an idea, this is what that screen looks like when you search for the counter that we just used:</p>
			<div><div><img alt="Figure 10.5: Perfmon.exe example with % Processor Time" src="img/B20924_11_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Perfmon.exe example with % Processor Time</p>
			<p>I suggest <a id="_idIndexMarker793"/>that you browse through that list and see what you can find that might be useful. There are even categories specifically for the .NET CLR, so you can see how often the garbage collector runs or how frequently an exception has been raised per second!</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor233"/>Prometheus</h1>
			<p>Keeping an<a id="_idIndexMarker794"/> eye on your system’s vital metrics can help you pinpoint issues. If your system suddenly starts using a lot more memory, or if at certain times the CPU usage spikes, you might have a problem that needs fixing. Thus, it is important to track those metrics. As we just learned, we can use the <code>PerformanceCounter</code> class to get the necessary information and do something with it, such as writing it to Seq with Serilog.</p>
			<p>However, that is <a id="_idIndexMarker795"/>not the only way. There is nothing wrong with the combination of Serilog and Seq. However, their primary goal is to log events. You can use a tool such as Prometheus to track trends, such as CPU usage or memory pressure.</p>
			<p>Prometheus <a id="_idIndexMarker796"/>is similar to Serilog and Seq: they allow you to write something in your code to an external system that you can look at in your web browser. However, Prometheus is primarily used for ad monitoring and time series databases. It is designed to record real-time metrics in a scalable fashion. It excels at monitoring the state of your applications and infrastructure.</p>
			<p>Let’s have a look at how all of that works.</p>
			<p>The application that you want to monitor needs a NuGet package. So, let’s install that. It is called <code>prometheus-net</code>. However, that is only part of the equation. As I said, you can use your browser to see the events that you are interested in, so we will also need to install the server.</p>
			<p>You can download Prometheus<a id="_idIndexMarker797"/> from <a href="https://prometheus.io">https://prometheus.io</a> and run it on your machine. However, if you are just trying to figure out how it works and see whether this is the tool for you, I recommend downloading the Docker image and running it.</p>
			<p>Prometheus needs a configuration file. This is a simple YAML file telling it how to behave. We need to link to that configuration file when we start the Docker image, so let’s write that file first.</p>
			<p>Open your favorite code editor and create a file called <code>prometheus.yml</code> somewhere. I have placed mine in a folder called <code>c:\data</code>. The preceding Docker command will ensure that it gets read and used inside the running container. This is what the file looks like:</p>
			<pre class="source-code">
global:
  scrape_interval: 5s
  evaluation_interval: 5s
scrape_configs:
  - job_name: 'c# worker'
    static_configs:
      - targets: ['host.docker.internal:1234']</pre>			<p>Let’s see what is going on here.</p>
			<p>The first line defines the <code>scrape_interval</code>. This is the interval that determines how often Prometheus looks at the metrics. Since metrics are usually interesting over a longer time, you do not need the system to measure them continuously. In our example, I have set it to do a scrape every five seconds.</p>
			<p>The following line <a id="_idIndexMarker798"/>defines the <code>evaluation_interval</code>. Prometheus can have rules and alerts that fire when a particular metric goes over or under a specific metric. This interval determines how often it checks to see whether the alert needs to be fired. Again, I have set it to five seconds.</p>
			<p>These <a id="_idIndexMarker799"/>two settings are global; they apply to all the metrics for all the applications that we monitor. We can later change these for each specific metric or application if we want to.</p>
			<p>The following section, called <code>scrape_configs</code>, defines the specific metrics that we want to collect. In my case, I have given it a name: <code>C# worker</code>. Then, we will tell it which server supplies the metrics. Again, in my case, it is <code>host.docker.internal:1234</code>. This means that the server runs on that URL with that specific port.</p>
			<p>“Wait a minute,” you might say, “I am not running a server; I am running a Console application!” Do not worry; Prometheus takes care of this.</p>
			<p>The server application of Prometheus calls into the systems it needs to monitor over an HTTP connection. Thus, the clients it monitors need a web server that supplies that information. We do not have to take care of that; Prometheus does that for us.</p>
			<p class="callout-heading">IP addresses in Docker</p>
			<p class="callout">You might wonder why I use the <code>host.docker.internal</code> hostname as the server address. After all, both Docker and our Console application run on the same system. They both are available on <code>localhost</code>, right? That is incorrect; Docker containers all run in their own network (I am simplifying things here, but the idea still works). That means that if the Prometheus server would listen to anything on <code>localhost:1234</code>, it would only listen to the virtual network in the image. We need to supply the actual IP address of the machine that runs our application. However, if you do not want to hardcode that, use the <code>host.docker.internal</code> DNS name. The DNS system in Docker knows this name. It resolves the actual IP address of the host machine so that the containers in Docker can find the correct machine.</p>
			<p>Let’s have a<a id="_idIndexMarker800"/> look at our code. I have started a new<a id="_idIndexMarker801"/> Console application and added the NuGet package. The code itself looks like this. I start by setting up our metrics:</p>
			<pre class="source-code">
Gauge memoryGauge =
    Metrics.CreateGauge(
        "app_memory_usage_bytes",
        "Memory Usage of the application in bytes.");
var server =
    new MetricServer(
        hostname:"127.0.0.1",
        port: 1234);
server.Start();</pre>			<p>First, I create a <code>Gauge</code>. This is like a thermometer that you use to measure metrics. In this case, I will make one that measures <code>app_memory_usage_bytes</code>, one of the many metrics that we can use.</p>
			<p>Then, we will create an instance of a <code>MetricServer</code>. You must specify the host from which the app runs and the port from which it broadcasts the metrics. Remember when I said that Prometheus listens to servers to collect its metrics? Well, this is where we set up that server.</p>
			<p class="callout-heading">IP addresses and Docker, again</p>
			<p class="callout">I have used the <code>127.0.0.1</code> hostname here. If I used <code>localhost</code>, I would get errors for some reason. If I used the machine’s actual hostname, I would get errors. Either the app does not start up, or the Prometheus server can’t find my app. However, if I specify the IP address here (my actual IP address also works), the system works just fine. So, if you have issues with getting things to work, just try to use <code>127.0.0.1</code> here.</p>
			<p>Then, I will start the server.</p>
			<p>Now, you are <a id="_idIndexMarker802"/>ready to send the metrics to the server. I have created a simple method that does this:</p>
			<pre class="source-code">
static void UpdateMemoryGauge(Gauge memoryGauge)
{
    var memoryUsage = GC.GetTotalMemory(forceFullCollection: false);
    memoryGauge.Set(memoryUsage);
}</pre>			<p>That is <a id="_idIndexMarker803"/>basically all that you have to do.</p>
			<p>However, let’s see what happens when we actually do something. In the main body of my code, I have a simple loop that adds a block of memory every five seconds and then clears them all after 20 seconds, after which the whole thing starts all over again.</p>
			<p>The code looks like this:</p>
			<pre class="source-code">
var counter = 0;
List&lt;byte[]&gt; buffer = [];
Random rnd = new Random();
while (true)
{
    if (counter++ % 5 == 0)
        AllocateMemoryBlock(rnd, buffer);
    if (counter == 20)
    {
        ClearMemory(buffer);
        counter = 0;
    }
    UpdateMemoryGauge(memoryGauge);
    await Task.Delay(1000);
}</pre>			<p>I have defined<a id="_idIndexMarker804"/> some variables, such as <code>counter</code>, <code>buffer,</code> and <code>rnd</code>. In the loop, I will either add memory to the system, clear the memory, or do nothing. At the end, I will make sure to call the <code>UpdateMemoryGauge()</code> method. Then, the app sleeps for one second.</p>
			<p>The <code>AllocateMemoryBlock()</code> looks like this:</p>
			<pre class="source-code">
static void AllocateMemoryBlock(Random random, List&lt;byte[]&gt; bytesList)
{
    var memoryToAllocate =
        random.Next(50000000, 200000000);
    var dummyBlock =
        new byte[memoryToAllocate];
    bytesList.Add(dummyBlock);
    "Memory block added".Dump(ConsoleColor.Blue);
}</pre>			<p>Again, this is <a id="_idIndexMarker805"/>silly code; I hope you never write this in actual production code. However, it works here; we want to measure the memory usage of our app, so we might as well allocate lots of it. I have used a randomizer to make the system a bit less predictable because I like the look of the charts a bit better that way.</p>
			<p>The <code>ClearMemory()</code> is even simpler:</p>
			<pre class="source-code">
static void ClearMemory(List&lt;byte[]&gt; list)
{
    list.Clear();
    GC.Collect();
    "Memory block cleared".Dump(ConsoleColor.Green);
}</pre>			<p>We then <a id="_idIndexMarker806"/>clear the list and clean up the memory by calling <code>GC.Collect()</code>, and we will log that to the screen.</p>
			<p>That is it! If you run this for a while and open your browser to the default Prometheus URL of <a href="http://localhost:9090">http://localhost:9090</a>, you can search for the <code>app_memory_usage_bytes</code> metric. If you<a id="_idIndexMarker807"/> run the app for a while, you will get a nice chart like this:</p>
			<div><div><img alt="Figure 10.6: Prometheus sampling our memory usage" src="img/B20924_11_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: Prometheus sampling our memory usage</p>
			<p>The chart shows <a id="_idIndexMarker808"/>our app in action, depicting how much memory it uses. You can probably also see why I used a randomizer; the chart looks slightly more interesting. However, that is just my personal preference.</p>
			<p>You can<a id="_idIndexMarker809"/> search for metrics in the top part of the screen, or you can search for jobs. If you specify the <code>{job = "c# worker"}</code> search string, you will get over 30 metrics for your app. You can click on each of them to add them to the chart. There is a ton of information there!</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor234"/>Other platforms for monitoring</h2>
			<p>We have looked at <a id="_idIndexMarker810"/>Seq to collect our logs. We looked at performance counters and we looked at Prometheus. These are all great tools and I believe they are the ones that fit us as system programmers the best. However, there are many more systems out there that might work better for you and your specific use case. I will not describe them all in detail; that would justify a book in itself. However, here is an overview of some of the most used ones. If you are interested in them, I suggest that you do research and find out how they can help you!</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table006-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Tool</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Use case</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Application Insights</p>
						</td>
						<td class="No-Table-Style">
							<p>Part of Azure Monitor, it provides APM features and telemetry data</p>
						</td>
						<td class="No-Table-Style">
							<p>Cloud-based monitoring</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>New Relic</p>
						</td>
						<td class="No-Table-Style">
							<p>Offers full-stack observability, including application monitoring</p>
						</td>
						<td class="No-Table-Style">
							<p>Performance insights</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Dynatrace</p>
						</td>
						<td class="No-Table-Style">
							<p>Utilizes AI for automatic monitoring and problem resolution</p>
						</td>
						<td class="No-Table-Style">
							<p>Full-stack monitoring</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Datadog</p>
						</td>
						<td class="No-Table-Style">
							<p>Provides monitoring, troubleshooting, and security for cloud applications</p>
						</td>
						<td class="No-Table-Style">
							<p>Cloud-native environments</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ELK Stack</p>
						</td>
						<td class="No-Table-Style">
							<p>Elasticsearch, Logstash for data processing, Kibana for visualization</p>
						</td>
						<td class="No-Table-Style">
							<p>Log Management</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Nagios</p>
						</td>
						<td class="No-Table-Style">
							<p>Offers monitoring and alerting services for servers, switches, applications, and services</p>
						</td>
						<td class="No-Table-Style">
							<p>Infrastructure monitoring</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>AppDynamics</p>
						</td>
						<td class="No-Table-Style">
							<p>Application performance management and IT operations analytics</p>
						</td>
						<td class="No-Table-Style">
							<p>Business performance monitoring</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.6: Monitoring tools</p>
			<p>As you can see, there are<a id="_idIndexMarker811"/> many options available, so there is definitely something that you can use that fits your specific needs!</p>
			<p>Now that you know how to monitor using Seq, performance counters, and Prometheus, we should look at what we are logging and monitoring.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor235"/>What you should be monitoring or logging</h1>
			<p>We have seen a lot of ways in which we can log and monitor our systems. However, the question remains: what should you be logging and monitoring? The answer is simple: whatever you need to keep your systems healthy.</p>
			<p>OK, that answer is probably the easy way out. Let’s be a bit more specific.</p>
			<h3>Basic health monitoring</h3>
			<p>You should <a id="_idIndexMarker812"/>monitor the overall health of your system. Your application does not live in a vacuum, so you should be mindful of the state of the complete system and how you interact with it. These are some of the items you might want to keep an eye on:</p>
			<ul>
				<li><strong class="bold">CPU usage</strong>: Track CPU usage to determine whether your application is causing a high CPU load</li>
				<li><strong class="bold">Memory usage</strong>: Monitor memory consumption to detect memory leaks or excessive memory usage, which is critical in a managed environment such as .NET, where garbage collection occurs</li>
				<li><strong class="bold">Disk I/O</strong>: Monitor read/write operations and disk usage to ensure that disk I/O is not a bottleneck</li>
				<li><strong class="bold">Network I/O</strong>: Keep an eye on inbound and outbound network traffic, especially if your system communicates with other services</li>
			</ul>
			<p>Of course, there are many other metrics you might be interested in, but these are usually the ones that people care about the most.</p>
			<h3>Application-specific metrics</h3>
			<p>Of course, your<a id="_idIndexMarker813"/> system itself is also something that you should look into. These are the metrics I would suggest you add to your monitoring tool:</p>
			<ul>
				<li><strong class="bold">Thread counts and thread pool health</strong>: It is helpful to know whether your threads are getting starved or whether the pool is overworked</li>
				<li><strong class="bold">Garbage collection metrics</strong>: Track the frequency and duration of garbage collection events to manage memory more effectively and optimize application performance</li>
				<li><strong class="bold">Queue lengths</strong>: If your application uses message queues or similar structures, monitoring their lengths can help you understand throughput and backlogs</li>
			</ul>
			<p>These metrics are more geared toward your application than the whole system, so I really recommend that you use these.</p>
			<h3>Errors and exceptions</h3>
			<p>Exceptions happen. That<a id="_idIndexMarker814"/> is just a fact of life. So, you might want to track those as well. Monitoring tools can capture these exceptions, but I <a id="_idIndexMarker815"/>would not solely rely on them. Always log what is happening in your exception-handling code blocks. You should be thinking about these items:</p>
			<ul>
				<li><strong class="bold">Unhandled exceptions</strong>: Log all unhandled exceptions with complete stack traces for debugging</li>
				<li><strong class="bold">Handled exceptions</strong>: Sometimes, knowing about handled exceptions can provide insights into potential issues that are not critical yet but may become problematic</li>
			</ul>
			<p>Monitoring errors and exceptions is, in my opinion, a given. You really want to know about these events!</p>
			<h4>Application logs</h4>
			<p>Several things are <a id="_idIndexMarker816"/>happening around your application that might be worthwhile to keep track of. These are some of them:</p>
			<ul>
				<li><strong class="bold">Start/stop events</strong>: Log when services or components start and stop to understand application life cycle events</li>
				<li><strong class="bold">Significant state changes</strong>: Any change in the state that might affect the application’s behavior should be logged</li>
				<li><strong class="bold">Security-related events</strong>: These events include authentication attempts, access violations, and other security checks</li>
			</ul>
			<h3>Dependency health</h3>
			<p>Applications rarely<a id="_idIndexMarker817"/> work in isolation. There are usually other systems that they depend on. You should track those dependencies as well:</p>
			<ul>
				<li><strong class="bold">Database connectivity</strong>: Regular checks to ensure that your application can connect to databases or other storage systems</li>
				<li><strong class="bold">External services</strong>: Monitor the availability and response times of any APIs or external services that your application relies on</li>
			</ul>
			<h3>Custom business logic monitoring</h3>
			<p>Of course, the application does some specific things that only apply to your environment. These might also be targets to monitor. Think about things such as these:</p>
			<ul>
				<li><strong class="bold">Performance of critical operations</strong> such as algorithms or processes central to your application’s functionality</li>
				<li><strong class="bold">Data processing rates</strong>, especially in systems that handle large volumes of data or streaming data</li>
			</ul>
			<p>These are just some of the things you might add to your toolbelt.</p>
			<p class="callout-heading">Use the right level!</p>
			<p class="callout">Remember: assigning the right level to each event is essential when logging. Not everything should be Information; you must distinguish between an error and debug information. Again, please make sure that you are not leaking sensitive information through your logs.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor236"/>Next steps</h1>
			<p>I hope that you took note of all of these items and kept a log of what we have been talking about! Logging and monitoring are extremely important, especially when you do not have a UI. We covered the logging frameworks available to you as a systems programmer in this chapter: the good and default Microsoft log, as well as NLog and structured logging in Serilog.</p>
			<p>We also looked at monitoring the health of your system and your application. We looked at Seq to collect our logs, discussed how to use performance counters, and dove into monitoring with Prometheus.</p>
			<p>We also talked about what you should be logging and monitoring and why you should do that.</p>
			<p>All in all, from now on, you will no longer be in the dark when unexpected things happen. Since they <em class="italic">will</em> happen, you’d better make sure that you are prepared. A good logging and monitoring strategy can save your life. Well, maybe not your life, but it can help your system. That is what makes it all worth it. After all, a good log can set you on the right track when you want to start debugging your system. Incidentally, that is the topic of the next chapter!</p>
		</div>
	</body></html>