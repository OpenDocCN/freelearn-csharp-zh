- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world full of different types of cables and plugs, we have all become accustomed
    to the concept of adapters. The Adapter pattern will be one of those patterns
    that will be easy for you to grasp, because it correlates so perfectly with our
    real-world experiences with technology. The Adapter pattern's name perfectly reveals
    its core purpose; it offers us a way to seamlessly use old code with new code
    by adding an interface between the code that will act as an Adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the basics of the Adapter pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the Adapter pattern to adjust an online user management system without
    modifying any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a hands-on chapter; you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Sealed class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2UieM9v](http://bit.ly/2UieM9v)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, the Adapter pattern adapts two incompatible interfaces;
    like a plug adapter, it doesn't modify what it adjusts, but bridges one interface
    with another. This approach can be beneficial when you are dealing with legacy
    code that you cannot refactor due to its fragility.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are two main approaches to implementing the Adapter pattern; here''s a
    quick breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object adapter**: A simple approach that uses composition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class adapter**: A more advanced approach that uses inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to learn both at the same time can get confusing, so in this chapter,
    we will try to focus on the core purpose of the Adapter pattern by implementing
    an object adapter and briefly reviewing the class adapter afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a side-by-side diagram of the Object and Class adapters;
    the core differences can be subtle, but the similarities are apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98b3339b-57b7-4db4-ac53-d2e0a72eaf80.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, in both cases, the **Adapter** class is positioned between the
    **Client** and the class that's being adapted (**Adaptee**). They only differ
    through their relationship to the **Adaptee**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the core differences between the **Object** and **Class** adapters are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Object Adapter** usually contains an instance of the **Adaptee** and translates
    the calls from the **Client** to the **Adaptee**; in other words, it acts slightly
    like a wrapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Class Adapter** implements the expected interface while inheriting the
    **Adaptee**; it's a more advanced approach to adaption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From experience, I have found that the Adapter pattern can sometimes be confused
    with the Facade pattern. It's essential we understand that the core difference
    between them is that the Facade pattern offers a simple interface to a complicated
    collection of interdependent sub-systems, while the Adapter pattern adapts an
    interface of another class so that it's consistent with the expectations of a
    client.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you're attempting to adapt access to multiple classes with a singular
    interface, then you are probably implementing a Facade and not an Adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't consider the Adapter pattern a long-term solution to architecture issues;
    even though it offers some benefits, its long-term drawbacks should always be
    taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapting without modifying**: The main benefit of the Adapter pattern is
    that it offers a standard approach to adapting code without modifying it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability and flexibility**: This pattern permits continuing to use legacy
    code with new systems with a minimal amount of changes; this has an immediate
    return on investment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persisting legacy**: The ability to use legacy code with new systems is cost-effective,
    but in the long term, it can become an issue, because the old code might limit
    your upgrading options as it becomes deprecated and incompatible with new versions
    of Unity or third-party libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slight overhead**: Because you are redirecting calls between objects, there
    might be a slight performance hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From experience, migrating code bases from one version of Unity to another can
    be quite time-consuming. So, don't be surprised if you end up having multiple
    versions of Unity installed on your computer so that you can maintain legacy code
    that's too expensive to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that we are dealing with a typical real-world game development
    scenario. Our lead online programmer is on vacation and has left explicit instructions
    that we should not make any modifications to his online player management system
    during his absence. However, our producer needs a change to our online components
    because he wants to showcase our live streaming service to a new investor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this in time, we will need to make changes; so, we have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the online player management system directly, even if we are not the
    owner of this section of the code base and don't understand it well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a way to extend the current system and implement the requested changes
    using a temporary adapter, which will limit the direct modification of our colleague's
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Adapter pattern, we can implement the second option in a structured
    and consistent manner. In the next section, we will apply this use case with a
    straightforward example, which will undoubtedly showcase the usefulness of this
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned, we are going to implement a change to our online player
    management system by adapting the `OnlinePlayer` class, without modifying it directly.
    The example is straightforward, but from experience, it's always better to learn
    a new pattern by implementing the simplest systems first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons of brevity, we are going to adapt the way the following `OnlinePlayer`
    class returns the full name of a specific player. Let''s keep in mind that we
    can''t refactor or extend this class; we can only adapt it. We will do this by
    using these two primary forms of the Adapter pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Object adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following `OnlinePlayer` class can return the first and last name of an
    online player, as well as their full name. However, the programmer that implemented
    the class decided to return the string in a formal naming structure. We need to
    have the full name in a standard sequence, which is the first then the last name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could call the first and last name `GET` functions individually,
    and then concatenate them together in our client, but this means that we will
    have to do it everywhere that we might need to get a user''s full name. In other
    words, we lose consistency and localized control of how the full name is returned.
    You can imagine how this could become risky if we were to adapt something more
    complex, such as an in-game currency transaction system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s something else important to note in the `OnlinePlayer` class; it''s
    `sealed`, which means that we can''t use it as a base class. As a consequence,
    we can''t extend it directly, so adapting it is our only option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build an adapter class that will fix our issue with the `GetFullName()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `OnlinePlayerObjectAdapter` class receives an instance of
    the `OnlinePlayer` class and wraps the `GetFullName()` method, so it returns the
    expected full name format. So, we are not modifying or extending the behavior
    of the class that's being adapted, but are merely adjusting it to the client's
    expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a `Client` class in order to test our implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an adapter, we have access to the `OnlinePlayer` class's original
    implementation of the `GetFullName()` function, and also an adapted version of
    it. This approach offers us a lot of flexibility with minimal risk, because we
    are not modifying anything, but are merely adapting.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we implemented a simple example of the object adapter. In the
    next section, we will review a sophisticated approach to the adapter by implementing
    a class adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Class adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s one detail that we are going to modify in our `OnlinePlayer` class
    for this section; we are going to remove the sealed modifier, because we want
    to be able to inherit the `OnlinePlayer` class. So, let''s pretend that it was
    never there in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the class adapter approach, let''s follow a step-by-step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a target interface for our clients; we are going
    to call it `IOnlinePlayer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should notice that we are adapting the `OnlinePlayer` class by adding a
    new interface that will expose the new functionality for the class that we are
    improving. This approach is flexible, as you will see in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our adapter class, we are going to implement the `IOnliePlayer` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks simple, but there are a lot of things going on. Let''s try to unwrap
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnlinePlayerClassAdapter` is implementing the `IOnlinePlayer` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlinePlayerClassAdapter` is also inheriting the `OnlinePlayer` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we are inheriting the `OnlinePlayer` class, `GetFirstName()` and `GetLastName()`
    are implemented by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlinePlayerClassAdapter` only needs to explicitly implement `GetFullNameLastFirst()`
    and `GetFullNameFirstLast()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFullNameLastFirst()` redirects the call to `GetFullName()`, implemented
    inside the `OnlinePlayer` parent class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFullNameFirstLast()` actually adapts the way that we return a full name
    to a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at how we can use this to our advantage with a `Client` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have decoupled the client from the adapted class because we only need to
    point it towards the adapter during the assignment of the `m_OnlinePlayer` member
    variable. For the client, the interaction with the adapted `OnlinePlayer` class
    is relatively transparent and is consistent with the previous implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we were able to adapt the `OnlinePlayer` class without modifying
    it while maintaining a consistent interface. That's the core purpose of the Adapter
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the Adapter pattern to our toolbox. It's a type of
    pattern that's very useful in the field, because one of the biggest challenges
    for a professional programmer is dealing with legacy code, which is often maintained
    by people you don't know. So, having a consistent approach to adapting other peoples'
    code without causing regression with unnecessary changes is the secret to a long
    career and a good reputation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review the decorator, a more complex and advanced
    structural pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a straightforward use case of the Adapter pattern,
    but its return on investment is in adapting legacy code into a new context. As
    an exercise, I recommend looking into your Unity projects and finding components
    or systems that you could adapt from one project to another without modifying
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
