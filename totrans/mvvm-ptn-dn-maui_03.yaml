- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Binding Building Blocks in .NET MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we familiarized ourselves with the core concepts of
    the MVVM pattern and explored the fundamentals of .NET MAUI. With the knowledge
    of MVVM principles and .NET MAUI’s capabilities, we can now start looking at how
    to apply MVVM to .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding, a crucial component in .NET MAUI, is the key enabler of the MVVM
    pattern. In this chapter, we will focus on the fundamental concepts, components,
    and techniques that facilitate data binding in .NET MAUI. These critical elements
    link the View and ViewModel layers of your application, enabling efficient communication
    and ensuring a clean separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the course of this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Key components for data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding modes and the **INotifyPropertyChanged** interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling interactions with the **ICommand** interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the essential
    data-binding building blocks that come with .NET MAUI. This will help you understand
    the inner workings of data binding in .NET MAUI and what role each component plays.
    With this foundation in place, you will be well equipped to explore more advanced
    topics and techniques in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will add functionality to the **Recipes!** app.
    All required assets needed to follow along, including all the code used in this
    chapter, can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Key components for data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s first turn our attention to the core components that enable data binding
    in .NET MAUI: `BindableObject`, `BindableProperty`, and `BindingContext`. These
    components work in harmony to establish and manage the connections between your
    Views and ViewModels. Understanding the role and functionality of these elements
    is crucial, as they form the backbone of data binding in .NET MAUI.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly discuss the elements that play a role in data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the key components, let’s go through the elements that
    we need to understand to effectively work with data binding in .NET MAUI applications.
    These elements play a vital role in facilitating communication between the View
    and ViewModel layers, enabling seamless synchronization of data and user interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INotifyPropertyChanged` interface. This interface ensures that the View is
    notified whenever the data in the ViewModel changes, allowing the UI to update
    accordingly. It’s essential to understand that implementing the `INotifyPropertyChanged`
    interface is not strictly required for a property to act as a binding source.
    In fact, any property, regardless of its enclosing class implementing `INotifyPropertyChanged`
    or not, can serve as a binding source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BindableProperty` on a UI element – or another `BindableObject` – that you
    may want to connect to the binding source. In .NET MAUI, most UI elements, such
    as labels, text boxes, and buttons, derive from the `Microsoft.Maui.Controls.BindableObject`
    class, which enables them to serve as a binding target. As opposed to the binding
    source, not every property can be a binding target, only properties of type `BindableProperty`
    on a class that inherits from a `BindableObject`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding context**: The binding context establishes the relationship between
    the ViewModel and the View. It serves as a reference point for the data binding
    engine, providing a connection to the ViewModel instance. The binding context
    is usually set at the page level or on individual UI elements. By default, child
    elements inherit the context from their parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding path**: The binding path is an expression that specifies the property
    of the binding source that need to be bound to the binding target. In the simplest
    case, the binding path refers to a single property name in the ViewModel, but
    it can also include more complex expressions, such as property chains or indexers.
    The combination of the binding path and the binding context form the binding source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding mode**: The binding mode determines the direction of data flow between
    the binding source and target, as we saw earlier in [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015),
    *What Is the MVVM* *Design Pattern?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ValueConverter**: A value converter modifies the data between the ViewModel
    and the View and vice versa. It allows us to convert the data value that is being
    bound and is particularly useful when the ViewModel’s data type does not match
    the data type expected by the UI element in the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this and [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding
    in .NET MAUI*, all aspects of data binding will be thoroughly discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first take a look at the core component that makes data binding possible
    in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: BindableObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET MAUI, the `Microsoft.Maui.Controls.BindableObject` class is the base
    class for objects that leverage data binding. It provides the foundation to enable
    data binding with UI elements and other objects by implementing essential properties,
    methods, and events related to the binding process. It is, in fact, the cornerstone
    of data-binding functionality in .NET MAUI, which is a crucial component of applying
    the MVVM pattern. It allows us to connect the View and the ViewModel, allowing
    them to communicate and stay in sync with each other without direct coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Most UI elements in .NET MAUI, such as labels, buttons, and text boxes, are
    derived from the `BindableObject` class. This inheritance enables these elements
    to participate in data binding.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the `BindableObject` stores instances of `Microsoft.Maui.Controls.BindableProperty`
    and manages the `BindingContext`. These are crucial aspects to enable effective
    data binding, which in turn fosters seamless communication between the View and
    ViewModel, facilitating MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: BindableProperty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BindableProperty` is a special kind of property that can act as a binding
    target. It basically is an advanced CLR property, a property on steroids, if you
    will. Ultimately, a bindable property serves as a container for storing data related
    to the property, such as its default value and validation logic. It also provides
    a mechanism to enable data binding and property change notifications. It is associated
    with a public instance property, which serves as the interface for getting and
    setting the value of the bindable property. Many properties of UI elements in
    .NET MAUI are bindable properties, which allows us to set their values through
    data binding or using styles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at the `Text` property of `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by looking at the `Text` property. This is just a CLR property,
    but instead of storing and retrieving the value from a backing field, it does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The getter retrieves the value by calling the `GetValue` method, passing in
    `TextProperty`. This `GetValue` method is a method on the `BindableObject` base
    class that `Label` inherits from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setter calls the `SetValue` method of `BindableObject`, passing in `TextProperty`
    and the given value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TextProperty` used in the `GetValue` and `SetValue` methods is a `BindableProperty`.
    It’s static and belongs to the `Label` class. As mentioned earlier, `BindableProperty`
    is a sort of “container” that holds various bits of information about the property,
    including its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down this `TextProperty`. This property is defined as a public
    static field of type `BindableProperty`. It is instantiated by calling the `BindableProperty.Create`
    method, passing in the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BindableProperty` field. In this particular case, `nameof(Text)` is used to
    refer to the `Text` property of the `Label` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type` and defines the data type of the property that the bindable property
    is referring to. As the `Text` property is of type `string`, `typeof(string)`
    is passed in as a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type`. It refers to the owner type of the property, which is the class that
    the property belongs to. In this particular example, the `Text` property is defined
    in the `Label` class, so this type is passed as a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue` parameter, which is of type `object`. This parameter is optional
    and allows us to provide a default value to the bindable property. In this case,
    `default(string)` is passed, which means `NULL` will be the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnTextpropertyChanged**: Optionally, we can provide a delegate that needs
    to be called when the value of the property changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BindableProperty.Create` method has a lot more optional parameters that
    you can provide if needed.
  prefs: []
  type: TYPE_NORMAL
- en: More about bindable properties
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B20941_11.xhtml#_idTextAnchor182), *Creating MVVM-Friendly
    Controls*, we will look at building our own controls. Understanding the concept
    of a `BindableProperty` is essential when it comes to creating MVVM-friendly controls.
    So, you can expect to dive deeper into this in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a `BindableProperty` can be a little overwhelming or hard to
    understand to start with. For now, just remember that all of the UI elements inherit
    from `BindableObject` and that many of their properties are bindable properties,
    allowing us to use them as a binding target.
  prefs: []
  type: TYPE_NORMAL
- en: BindingContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `BindableObject` has a `BindingContext` property of type `object`, which acts
    as the glue between the binding source and the binding target. It points the data
    binding engine to an instance of a class that serves as the binding source. When
    you set the `BindingContext` property on a `BindableObject`, such as a .NET MAUI
    page or a UI element, you are specifying the source object for data binding expressions
    within that object’s scope. Child elements within that scope will inherit the
    `BindingContext` by default unless a different `BindingContext` is explicitly
    set for them.
  prefs: []
  type: TYPE_NORMAL
- en: When the `BindingContext` is set on a `BindableObject`, the data-binding engine
    will resolve all bindings having their `Source` set to the `BindingContext`. Also,
    when the value of the `BindingContext` property changes, these bindings are reevaluated
    using the updated `BindingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed all the core components that allow us to do data binding
    in .NET MAUI, let’s see how to define and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start writing our data binding, we first need to add our ViewModels
    to our solution. In order to fully embrace the separation of concerns, let’s put
    them into a separate project:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Solution Explorer**, right-click on your solution and select **Add**
    | **New Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Class Library** from the list of project templates and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Recipes.Client.Core` under **Project name** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `.NET 8.0` as **Framework** and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project is created, let’s delete `Class1.cs`, which was created by
    default. Next, we want to add our ViewModels to this project. In order to keep
    everything nice and organized, let’s first create a `ViewModels` folder to put
    all of our ViewModels in:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Recipes.Client.Core` project in the `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the newly added folder and select `RecipeDetailViewModel`, and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RecipeDetailViewModel` represents the details of a recipe. For now, it only
    contains a `Title` property, which we now give a hardcoded value of `"Classic`
    `Caesar Salad"`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we need to add a reference to this `Recipes.Client.Core` project from
    the `Recipes.Mobile` project. To do this, simply right-click on the `Recipes.Mobile`
    project, select `Recipes.Client.Core` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very last step, before we dive into data binding, we need to add a new
    page to our `Recipes.Mobile` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the project name and select **Add** | **New Item…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `RecipeDetailPage.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `App.xaml.cs` and, in the constructor, assign an instance of `RecipeDetailPage`
    to the `MainPage` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This ensures that on startup, the mobile app will show our newly created `RecipeDetailPage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in the code-behind of `RecipeDetailPage`, we need to assign its `BindingContext`
    property to an instance of `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can focus on `RecipeDetailPage` and start implementing some data bindings.
    Data bindings can be defined in code using C# and in XAML. Both have their cons
    and their pros, but essentially it comes down to preference. You can even mix
    and match both approaches if you want, although I wouldn’t recommend doing that.
    Most commonly, data bindings are defined in XAML, minimizing the amount of code
    in the code-behind. Nevertheless, let’s first see how we can define data bindings
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go to our new `RecipeDetailPage.xaml` file and start updating some XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove any default XAML elements inside the `ContentPage` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following elements inside `ContentPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are keeping the UI very simple and straightforward for now. That’s why we
    are going to put everything in a `VerticalStackLayout`, which organizes child
    elements in a vertical stack. We’re surrounding the `VerticalStackLayout` with
    a `ScrollView` in order to make sure we get scrollbars when not everything fits
    on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `Label` to the `VerticalStackLayout` with the name `lblTitle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This label will be showing the recipe’s title.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the code-behind, within the constructor of `RecipeDetailPage`, we can now
    add data-binding code so that the value of the `Title` property of the `RecipeDetailViewModel`
    is shown in the `lblTitle` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we have given the `Label` the name `lblTitle`, a field with this name
    is generated, which allows us to access this label from the code-behind. By calling
    the `SetBinding` method, we can define and apply a binding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the app and you should see the `Title` of `RecipeDetailViewModel`, which
    is currently hardcoded as `"Classic Caesar Salad"` on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By looking at the first data binding we’ve just implemented, you should be
    able to identify most of the data binding elements we’ve discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetBinding` method is a method on the `BindableObject` class. The first parameter
    the `SetBinding` method needs is a `BindableProperty`. In this case, we are passing
    in the static `Label.TextProperty`, which corresponds to the `Text` instance property
    of a `Label`. The instance of the `BindableObject` we are calling the `SetBinding`
    method on, together with the `BindableProperty` we’re specifying as the first
    parameter, form the binding target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetBinding` method expects is the property path to bind to. This, together
    with the `BindingContext`, forms the binding source – but what is the `BindingContext`
    in this case? As we don’t explicitly specify the `BindingContext` on the `Label`,
    the `BindingContext` is inherited from `lblTitle`’s parent, which is `RecipeDetailPage`.
    Therefore, the `BindingContext` of the label is also the instance of `RecipeDetailViewModel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BindingMode` is the third parameter in this example. This one, however, is
    optional. In this case, we are setting the `BindingMode` to `OneTime`. In [*Chapter
    1*](B20941_01.xhtml#_idTextAnchor015), *What Is the MVVM Design Pattern?*, we
    briefly discussed different binding modes, and we will discuss binding modes in
    a bit more depth later on in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining data binding in code is quite easy and straightforward. However, most
    of the time, data bindings are defined in XAML. Personally, I think defining them
    in XAML feels more natural and requires less context switching when creating your
    UI with XAML. So, let’s have a look!
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in XAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are going to write our data binding in XAML, we can delete or comment
    out the binding code that we added to the constructor of `RecipeDetailPage` in
    *step 4* of the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now switch to `RecipeDetailPage.xaml` and update the label by removing
    the `x:Name` property and adding the `Text` property, which contains a **Binding**
    **markup extension**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <Label
  prefs: []
  type: TYPE_NORMAL
- en: FontAttributes="Bold"
  prefs: []
  type: TYPE_NORMAL
- en: FontSize="22"
  prefs: []
  type: TYPE_NORMAL
- en: Mode=, we can indicate the binding mode, just like we did in the previous example;
    we’re setting it to OneTime in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from `Path` and `Mode`, there are more properties to the binding markup
    extension, such as `Source`, which allows us to point to another binding source,
    `Converter`, `TargetNullValue`, and others. [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069),
    *Data Binding in .NET MAUI*, will cover all of this in much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the different binding modes in more detail and how
    to reflect changes from the binding source automatically in the binding target.
  prefs: []
  type: TYPE_NORMAL
- en: Binding modes and the INotifyPropertyChanged interface
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), *What Is the MVVM Design
    Pattern*, we already discussed how data can flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-way**: From ViewModel to View'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-way-to-source**: From View to ViewModel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-time**: Only once from ViewModel to View'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-way**: From ViewModel to View and from View to ViewModel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s take a look at how this is handled in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Binding modes in .NET MAUI
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI supports all of these data flows, represented through the `Microsoft.Maui.Controls.BindingMode`
    enum: `OneWay`, `OneWayToSource`, `OneTime` and `TwoWay`. There is in fact a fifth
    value as well: `Default`. Remember when we talked about bindable properties earlier
    in this chapter? When creating a bindable property, there are some optional values
    we can set. One of those optional parameters is `defaultBindingMode`. This allows
    us to set a default binding mode on a bindable property. On `Entry`, for example,
    it makes sense to have the default binding mode on the `Text` property set to
    `TwoWay`, as it shows the value of the binding source, and the user is able to
    update the value as well. The `Text` property on a `Label`, on the other hand,
    is read-only, so the default binding mode there is `OneWay`. Now, going back to
    the `BindingMode` enum and more specifically, the `Default` value, when we don’t
    specify a binding mode or use `Default`, the data-binding engine will use the
    binding mode that is specified as the default one on the bindable property of
    the binding target.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of data binding and the various binding modes in .NET MAUI, it’s
    crucial to have an efficient way to inform the UI about changes to the ViewModel’s
    properties. The `INotifyPropertyChanged` interface addresses this need by providing
    a mechanism for your ViewModel to notify the UI when a property value has been
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: INofityPropertyChanged
  prefs: []
  type: TYPE_NORMAL
- en: The `INotifyPropertyChanged` interface, part of the `System.ComponentModel`
    namespace, allows your binding source to communicate property changes to the binding
    target. This interface isn’t specific to .NET MAUI; it’s part of the .NET `PropertyChanged`
    event when the object that is being bound to implements the `INotifyPropertyChanged`
    interface. When the event is triggered, the engine will update the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `INotifyPropertyChanged` interface, your ViewModel must include
    a `PropertyChanged` event, which can be triggered whenever a property’s value
    changes. Furthermore, you typically create a method, usually called `OnPropertyChanged`,
    that triggers this event while providing the name of the altered property as a
    parameter. This method should be called within the property setter, immediately
    after the property value is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding sample, this `SampleViewModel` implements the
    `INotifyPropertyChanged` interface, which requires us to implement the `PropertyChanged`
    event of the `PropertyChangedEventHandler` type. The `PropertyChanged` event can
    easily be invoked by calling the `OnPropertyChanged` method and passing in the
    name of the property that has been changed. When looking at the code, in the setter
    of the `Title` property, the `OnPropertyChanged` method is called when a new value
    is assigned to the property’s backing field, passing in the name of the property.
    When calling the `PropertyChanged` event, the current instance of the `SampleViewModel`
    is passed-in as the sender through the `this` keyword, followed by an instance
    of `PropertyChangedEventArgs`, which requires the name of the updated property.
    Through this event, the data-binding engine gets notified about the updated property
    and can, depending on the data-binding mode, update the binding target automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '`CallerMemberNameAttribute` is something that is very commonly used as an attribute
    on the `propertyName` parameter of the `OnPropertyChanged` method. This attribute
    automatically obtains the name of the method or property that calls the attributed
    method. This facilitates calling the `PropertyChanged` event from the property’s
    setter even more, as the name of the property doesn’t need to be explicitly passed
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As the `Title` property calls the `OnPropertyChanged` method, without providing
    an explicit value as a parameter, the name of the caller  – `Title` in this case
    – will be passed in as a value. In [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086),
    *Community Toolkits*, we’ll see how we can eliminate a lot of the ceremony here
    when triggering the `PropertyChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: Different binding modes in action
  prefs: []
  type: TYPE_NORMAL
- en: In the example earlier in this chapter, we bound the `Title` property of our
    `RecipeDetailViewModel` one time to the `Text` property of a `Label`. This means
    that the binding source is set only when the `BindingContext` of the binding target
    is set or when the `BindingContext` is assigned a new instance. In the context
    of our current setup, `BindingContext`, the initial value of the `Title` property
    is bound right away. However, any subsequent changes made to the `Title` property
    (such as updating it after the ViewModel loads data) won’t be reflected in the
    UI due to the nature of one-time data binding. This won’t be a problem for us
    right now since we’re working with static data for demonstration purposes, but
    it’s something to be aware of in a real-world application. As we progress through
    this book, we will revise this binding mode to handle such situations more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some more code and discuss the other binding modes. First, let’s
    add an additional `IngredientsListViewModel` and extend our `RecipeDetailViewModel`
    with a property of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ViewModels` folder in the `Recipes.Client.Core` project and select **Add**
    | **Class…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `IngredientsListViewModel.cs` as name and click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let the class implement the `INotifyPropertyChanged` interface and add the
    `OnPropertyChanged` method. Add the following code to the newly created class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a typical implementation of the `INotifyPropertyChanged` interface with
    the `PropertyChangedEvent` and an `OnPropertyChanged` method that triggers the
    implemented `PropertyChhanged` event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  Next, we can add the `NumberOfServings` property, as shown in the following
    snippet. For brevity, the implementation of the `INotifyPropertyChanged` interface
    is left out:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IngredientsListViewModel` contains a list of all ingredients and the quantities
    of them that are needed for a particular recipe. It also contains a `NumberOfServings`
    property, which indicates the number of servings for which the listed ingredients
    and their quantities are intended. The user should be able to adjust the number
    of servings in the UI and see how the quantity of the ingredients is being updated
    according to the selected amount. We will add the list of ingredients later.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.  Move over to `RecipeDetailViewModel` and add an `IngredientsList` property
    of type `IngredientsListViewModel` and assign it a new instance by default:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this updated code in place, we can now go to `RecipeDetailPage` and focus
    on the XAML again. We want to update the UI to allow users to choose the desired
    number of servings. For this use case, we will create a `OneWay` and a `TwoWay`
    data binding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to `RecipeDetail` and add the following XAML below the `Label` that shows
    the recipe’s title:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s have a look at the binding statements that we’ve added through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` property of the label is bound to the `NumberOfServings` property
    using the following binding statement: `{Binding IngredientsList.NumberOfServings,
    Mode=OneWay}`. The label displays the currently selected number of servings. The
    `NumberOfServings` property is part of the `IngredientsList` property on `RecipeDetailViewModel`,
    which is why the binding path is set to `IngredientsList.NumberOfServings`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the user can change the number of servings, we use the `OneWay` binding
    mode. This ensures that when the value of `NumberOfServings` is updated, the UI
    reflects the change accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Value` property of the `Stepper` control is bound to the `NumberOfServings`
    property using the following binding statement: `{Binding IngredientsList.NumberOfServings,
    Mode=TwoWay}`. `Stepper` allows the user to adjust the currently selected number
    of servings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the user can change the number of servings and the ViewModel should update
    accordingly, we use the `TwoWay` binding mode. This ensures that not only the
    UI reflects the `NumberOfServings` property’s value but also that the ViewModel
    is updated when the user modifies the number of servings via the `Stepper` control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Increments or decrements to the `NumberOfServings` property made using `Stepper`
    will be reflected in the previously discussed label due to `OneWay` binding, and
    the property triggers the `PropertyChanged` event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the XAML code, both bindings target properties within the `IngredientsList`
    property. In this example, all child elements of `HorizontalStackLayout` are bound
    to properties of the `IngredientsList` property in `RecipeDetailViewModel`. Since
    child elements inherit the binding context from their parent, it’s possible to
    move the binding to the `IngredientsList` property one level up, if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are binding the `BindingContext` of `HorizontalStackLayout`
    to the `IngredientsList` property of `RecipeDetailViewModel`. This allows us to
    simplify the binding statements on the child elements. Of course, you can only
    do this when all the child elements have the same binding source.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example, let’s implement a `OneWayToSource` data binding in our
    **Recipes!** app. Here our aim is to show the allergen information for each recipe.
    As not everyone is interested in viewing this information, we will not show it
    by default. However, we want to allow the user to tick a box to get this information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `RecipesDetailViewModel` and let it implement `INotifyPropertyChanged`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Create an `OnPropertyChanged` method that accepts `propertyName` as a parameter
    and calls the `PropertyChanged` event, just like we did in `IngredientsListViewModel`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Now, let’s add a `ShowAllergenInformation` property of type `bool`. This
    property will be responsible for the visibility of the allergen information on
    `RecipeDetailPage`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 4.  This property triggers the `PropertyChanged` event when its value changes.
    This allows us to bind it to the `IsVisible` property of a `VisualElement` so
    that whenever the value on the ViewModel changes, the UI element’s visibility
    is updated automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can go to `RecipeDetailPage` and add the following XAML between
    the label that shows the recipe’s title and the `HorizontalStackLayout` that is
    bound to `IngredientsList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, we bind the same `ShowAllergenInformation` property using the
    `OneWay` mode to the `IsVisible` property of a label. This label will eventually
    display the allergen information. As a result, when the user toggles the checkbox,
    it updates the `ShowAllergenInformation` property in the ViewModel, which in turn
    triggers `PropertyChangedEvent`. This event will be picked up by the binding engine,
    which will update the `IsVisible` property of the label, allowing the allergen
    information to be displayed or hidden based on the user’s preference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: INotifyPropertyChanged is not a requirement for the binding source
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a binding target should always be a `BindableProperty`
    on a class that inherits from the `BindableObject`. The binding source, on the
    other hand, can be any property of any class. Most of the time, the binding source’s
    class implements the `INotifyPropertyChanged` interface, but that’s not a requirement.
    Only when using `OneWay` and `TwoWay` binding modes in scenarios where the values
    on the binding source can update and need to be reflected in the UI does the `INotifyPropertyChanged`
    interface need to be implemented. Alternatively, setting the `BindingContext`
    again would also update all the values, but that means everything needs to be
    reevaluated, which might not be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how .NET MAUI supports data binding and different binding
    modes, let’s see how we can handle user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling interactions with the ICommand interface
  prefs: []
  type: TYPE_NORMAL
- en: In most applications, user interaction plays a vital role. Common interactions
    include clicking buttons, selecting items from a list, toggling switches, and
    more. To handle these interactions effectively while adhering to the MVVM pattern,
    it’s essential to utilize a robust mechanism that encapsulates the necessary logic
    within the ViewModel. The `ICommand` interface is designed specifically for this
    purpose, enabling you to manage user interactions in a clean and maintainable
    way while ensuring a clear separation of concerns between the View and the ViewModel.
    In this section, we’ll explore how to implement and use `ICommand` to handle user
    interactions in your .NET MAUI application.
  prefs: []
  type: TYPE_NORMAL
- en: The ICommand interface
  prefs: []
  type: TYPE_NORMAL
- en: The `ICommand` interface plays a crucial role in handling user interactions
    within the context of the MVVM pattern in .NET MAUI applications. `ICommand` is
    part of the `System.Windows.Input` namespace and allows you to encapsulate the
    logic for executing a specific action and determining whether that action can
    be executed in a ViewModel. Again, this interface isn’t specific to .NET MAUI;
    it’s an integral part of the .NET BCL.
  prefs: []
  type: TYPE_NORMAL
- en: '`ICommand` has two main members: `Execute` and `CanExecute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute (object parameter)**: This method is what gets executed when the
    command is invoked. Through an optional parameter, additional data can be passed
    in if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CanExecute (object parameter)**: This method indicates whether the command
    can be executed in its current state or not. Optionally, a parameter can be passed
    in if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ICommand` also exposes an event called `CanExecute` method changes, signaling
    the UI to re-evaluate whether the command can be executed. This enables automatic
    enabling/disabling of UI elements (such as buttons) based on the current state
    of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: To use `ICommand` in your ViewModel, you can create a custom command class that
    implements the `ICommand` interface or use a built-in command class such as `Microsoft.Maui.Controls.Command`.
    There are also third-party implementations available such as `CommunityToolkit.Mvvm.Input.RelayCommand`
    from the MVVM Toolkit, which we will dive into in more detail in [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086),
    *Community Toolkits*. Typically, these implementations contain a method called
    `ChangeCanExecute` or `NotifyCanExecuteChanged`, which is called the `CanExecuteChanged`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with the `ICommand` interface and its role in a ViewModel,
    it’s time to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it into action
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple demonstration, we want to allow users to add or remove a recipe
    as a favorite. For this, let’s add two buttons to `RecipeDetailPage`, right below
    the `VerticalStackLayout` that contains the `CheckBox` element to display the
    allergen information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first button’s `Command` property binds to the `AddAsFavoriteCommand` property
    on our binding source, `RecipeDetailViewModel`. This button should allow a user
    to mark a recipe as a favorite when the recipe is not yet favorited. The second
    button does the exact opposite: it should allow a user to remove a recipe as a
    favorite. Let’s take a look at the implementation of both commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `RecipeDetailViewModel`, we can add an `IsFavorite` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property holds a `bool` value to indicate whether the user has marked this
    recipe as a favorite or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Next, we need to add the two commands, `AddAsFavoriteCommand` and `RemoveAsFavoriteCommand`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the two properties of type `ICommand` that the `Command` properties
    of the buttons bind to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.  Now, we need to instantiate both commands. Whilst .NET contains an `ICommand`
    interface, it doesn’t contain a concrete implementation. .NET MAUI, on the other
    hand, does have one! In order to access this implementation from the `Recipes.Client.Core`
    project, we need to configure the project to use the .NET MAUI framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Recipes.Client.Core` project. This should open up the associated `csproj`
    file, wherein you need to add `<UseMaui>true</UseMaui>`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to access .NET MAUI-specific libraries from our `Core` project,
    such as `Microsoft.Maui.Controls.Command`, which implements `ICommand`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  In the constructor of `RecipeDetailViewModel`, we can now instantiate `AddAsFavoriteCommand`
    and `RemoveAsFavoriteCommand`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we have two commands on the ViewModel: `AddAsFavoriteCommand`
    and `RemoveAsFavoriteCommand`. Each command is created with an associated `Action`
    and a `Func<bool>` to determine its executability.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AddAsFavoriteCommand` has an `AddAsFavorite` method as its action, which simply
    sets the `IsFavorite` property to `true`. Its `CanExecute` method is determined
    by the `CanAddAsFavorite` method, which returns `true` when the `IsFavorite` property
    has a value of `false`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the other hand, `RemoveAsFavoriteCommand` has a `RemoveAsFavorite` method
    as its action, which sets the `IsFavorite` property to `false`. The `CanRemoveAsFavorite`
    method is provided as the `CanExecute` check for this command, and it returns
    `true` when the `IsFavorite` property has a value of `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that it is up to the control to check and adhere to the
    `CanExecute` method. It should not be a thing to blindly rely on, as it might
    not be implemented or work the way you expect. Make sure to read the control’s
    documentation and test it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, when the `IsFavorite` property is `true`, only `RemoveAsFavoriteCommand`
    can be executed, while  `AddAsFavoriteCommand` cannot be. Conversely, when the
    `IsFavorite` property is `false`, `AddAsFavoriteCommand` can be executed, and
    `RemoveAsFavoriteCommand` cannot be. This ensures that the appropriate command
    is available for execution based on the current state of the `IsFavorite` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just one piece of the puzzle missing: whenever the `IsFavorite` property’s
    value changes, the `CanExecute` method of both commands needs to be re-evaluated.
    In order to do that, we need to update the setter of the `IsFavorite` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With all this code in place, we can run the app again. By default, only the
    first button (bound to `AddAsFavoriteCommand`) is enabled when the recipe is not
    a user favorite. Upon clicking this button, the `IsFavorite` property is updated,
    and the `ChangeCanExecute` method is called for both commands. As a result, the
    first button becomes disabled, while the second button (bound to `RemoveAsFavoriteCommand`)
    is automatically enabled. This ensures that the correct button is enabled or disabled
    based on the `IsFavorite` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could also use a single command and use a `CommandParameter`
    to handle the toggling of the `IsFavorite` property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, let’s add a new `SetFavoriteCommand` property of type `ICommand`
    and initialize it in the constructor of `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By assigning the command to an instance of `Command<bool>`, we are specifying
    that we expect a parameter of type bool in both the `Execute` and `CanExecute`
    methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.  In the setter of the `IsFavorite` property, we now need to call the `CanExecuteChanged`
    method of `SetFavoriteCommand`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can update the binding statements on both buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both buttons call the same command, but they each pass in a different parameter,
    which gets passed to both the `Execute` and `CanExecute` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UseMaui and MVVM best practices
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduced the `UseMaui` property in our `Core` project,
    which may seem to contradict our previous statements about ViewModels being framework-agnostic.
    While adhering to the MVVM pattern, it is recommended to keep the ViewModels free
    from any framework-specific dependencies. However, in this specific case, we have
    opted for a more practical approach to demonstrate an implementation of `ICommand`
    through the `Microsoft.Maui.Controls.Command` class. In a strictly MVVM-compliant
    scenario, you would want to avoid such dependencies in your ViewModels to ensure
    maximum flexibility and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B20941_05.xhtml#_idTextAnchor086), *Community Toolkits*, we
    will take a look at the possibility of how to improve this code so that it follows
    these best practices more closely.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a little extra, we also might want to display an icon indicating whether
    a recipe is a favorite or not. The visibility of this icon can be bound to the
    `IsFavorite` property. When toggling this property through the buttons and commands
    we’ve just created, the icon’s visibility will be updated as well:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s add the `Chapter 03``/Assets/favorite.png` file to the `Resources/Images`
    folder in the `favorite.png` file. You might need to adjust the file type filter
    in the file picker popup to include `.``png` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `RecipeDetailPage.xaml`, add the following XAML directly below the `Label`
    displaying the recipe’s title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when we tap the **Add as favorite** or **Remove as favorite** button, you
    should see the favorite icon appearing or disappearing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ICommand` interface plays a vital role in implementing the MVVM. By encapsulating
    user interactions within commands, it promotes a clean separation of concerns
    between the View and ViewModel. This allows for more maintainable, testable, and
    modular code. As demonstrated, `ICommand`, along with its `CanExecute` functionality,
    ensures that the appropriate actions are available to users based on the application’s
    state, further enhancing the user experience. By leveraging `ICommand`, developers
    can effectively implement the MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve explored the `ICommand` interface, you may be interested to know that
    there are additional tools and resources available for implementing MVVM in .NET
    MAUI. Thanks to the fantastic .NET and .NET MAUI community, various Community
    Toolkits provide even more support for the MVVM pattern in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we delved into the core components that enable the MVVM pattern
    in .NET MAUI. We discussed the essential building blocks, including `BindableObject`,
    `BindableProperty`, and `BindingContext`, and how they facilitate seamless communication
    between the View and ViewModel. Furthermore, we examined the importance of the
    `INotifyPropertyChanged` interface in notifying the UI of changes in ViewModel
    properties and demonstrated how the `ICommand` interface helps handle user interactions
    in a decoupled manner. By understanding these fundamental concepts, it becomes
    evident why .NET MAUI and the MVVM pattern are such a harmonious match.
  prefs: []
  type: TYPE_NORMAL
- en: As we move on to [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding
    in .NET MAUI*, we will take a closer look at data binding, diving deeper into
    topics such as value converters, fallback values, element and relative binding,
    multi-bindings, and compiled bindings. This will enable you to leverage the full
    power of data binding. Let’s continue our journey!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindable properties: [https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties](https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BindableObject` class: [https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject](https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `INotifyPropertyChanged` interface: [https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged](https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
