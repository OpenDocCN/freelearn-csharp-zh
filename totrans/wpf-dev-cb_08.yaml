- en: Working with Animations
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling an element while rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating an element while rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skewing an element while rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving an element while rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping multiple transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating property-based animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating path-based animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating key-frame-based animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding easing effects to animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Windows Presentation Foundation** (**WPF**) is well-known for its rich **graphical
    user interface** (**GUI**) and layout features, which enables you to create stunning
    desktop applications. Animations can be used to create an attractive **user interface**
    (**UI**) by just animating UI elements, transformations, screen transitions, and
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create animations using **storyboards**.
    We will first start with recipes that will help you to understand various transformations,
    such as `ScaleTransform`, `RotateTransform`, `SkewTransform`, and `TranslateTransform`.
    Then we will proceed towards recipes to learn various kinds of animations, such
    as property-based animations, path-based animations, and key-frame-based animations.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we will learn various easing functions introduced in WPF 4, which
    can be used to create easing effects on your linear animations to give them a
    non-linear look.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling an element while rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScaleTransform` is used to scale (stretch or shrink) an object horizontally
    or vertically. The `ScaleX` property is used to specify how much to stretch or
    shrink the object along the *X* axis, whereas the `ScaleY` property is used to
    specify how much to stretch or shrink the object along the *Y* axis. Using the
    `CenterX` and `CenterY` properties, the operations are performed based on the
    center pointing at certain coordinate points.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to stretch or shrink an element using the
    scale transform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, open your Visual Studio instance and create a new WPF App project named
    `CH08.ScaleTransformDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add `Image` controls to the application UI, and apply
    `ScaleTransform` to scale the image:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, right-click on the project node and create a new
    folder. Name it as `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, right-click on the `Images` folder and add an existing image from your
    system. Name it as `image1.png`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/367d1722-3e93-4762-a52a-2986094fb139.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the `MainWindow.xaml` page and replace the default `Grid` with a
    horizontal `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `StackPanel`, add the following `Grid` with two image controls.
    Both, the image controls should be pointing to the `Images/image1.png` image file.
    The second image will have a transform set to it to scale the image to 80%, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add one more `Grid` inside the `StackPanel` with the following XAML
    mark-up, where the two images are scaled to 50% and mark the scaling center position
    to (`0`,`0`) and (`100`,`100`), respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application now and check the scaling behavior of the various
    images on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RenderTransform` attribute helps you to set runtime transformation to any
    UI Element. In this example, we used `ScaleTransform` to scale the image on the
    application window.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, the first one is the default image with an opacity
    set to 20%, whereas the second one is scaled to 80% with an opacity of 100%. The
    `ScaleX` and `ScaleY` properties are used to scale an element, which takes a decimal
    value to represent the ratio. For example, 0.8 denotes 80%, whereas 1.2 denotes
    120% of the scaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e7f79b7-1bf8-4871-9477-bed7ebb260c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the third and fourth images, both are scaled to 50%. But, as you see on
    the UI, the positions of the said images are different. The properties `CenterX`
    and `CenterY` are used to set the scaling center position. The third image has
    the scaling center set at (`0`,`0`), whereas the fourth one has its center position
    set at (`100`,`100`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rotating an element while rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to rotate an element at runtime, the `RotateTransform` is used.
    It rotates the element around a center position denoted by `CenterX` and `CenterY`,
    at an angle in degrees specified by the `Angle` property.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to use `RotateTransform` to rotate a UI element at a specified
    angle. In this recipe, we are going to discuss this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new project named `CH08.RotateTransformDemo`.
    Make sure to select the WPF App template while creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps mentioned here to apply rotation to an `Image` control:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, right-click on the project node and create a new folder.
    Name it as `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the Images folder and add an existing image from your system.
    Name it `image1.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and replace the existing `Grid` with a horizontal
    `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following XAML mark-up inside the `StackPanel` to add two images
    the application window. The first image will have an opacity set to 20%, and the
    second image will have a `RotateTransform` set at an angle of 45 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's add one more `Grid` inside the `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two more images into the new `Grid` panel. Set the `RenderTransform` attribute
    of both the images to have a `RotateTransform` set to it at an angle of `45` degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the following XAML snippet, set the center position of the rotation
    of the images using the `CenterX` and `CenterY` properties. In this demonstration,
    we will set (`0`,`0`) and (`30`,`30`) as the rotation center of the respective
    images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, build the project and run it. You will see four images on
    the screen, which will look like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d35d641-4068-452c-9c5c-ae8c2572d7ad.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RotateTransform` allows you to rotate an element at a certain degree specified
    by the `Angle` property. In the first image, no transformation was applied and
    thus it will look as default. If you compare this with the other images on the
    screen, the second image is rotated clockwise at an angle of `45` degrees. The
    third and fourth images are also rotated at an angle of `45` degrees, but with
    a small difference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the third image, the rotation was done at the center position (`0`,`0`).
    For the fourth image, it was done at the center position (`30`,`30`). Here''s
    how the difference will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18936217-fe66-4463-a564-32de3e08e231.png)'
  prefs: []
  type: TYPE_IMG
- en: Skewing an element while rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SkewTransform` is used in a WPF platform to shear an element so that it has
    a 3D look in a 2D plate by adding depth to it. The `AngleX` and `AngleY` properties
    are used to specify the skew angle of the *X* axis and the *Y* axis, while the
    `CenterX` and `CenterY` properties are used to specify the *X* and *Y* coordinates
    of the center point.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to apply skew transform to an image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open your Visual Studio IDE and create a new project named `CH08.SkewTransformDemo`,
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add some images to the application window and apply skew to those at
    a certain angle and certain center positions. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, right-click on the project node and create a new folder.
    Name it `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the `Images` folder and add an existing image from your system.
    Name it as `image1.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and replace the existing `Grid` with a horizontal
    `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following `Grid` inside the `StackPanel` to have two images. The
    first one will have opacity set to 20%, whereas the other will have a Skew applied
    to it at an angle of `50` degrees and `5` degrees on the *X* and *Y* axes. To
    set these, use the `AngleX` and `AngleY` properties, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add one more `Grid` inside the `StackPanel` and insert two images inside the
    new `Grid`. Set `SkewTransform` to both of the images at the *X* and *Y* axes
    as `30` degrees and `5` degrees, respectively. For one of the images, set the
    skew center position at (`0`,`0`), and for the other image, set the skew center
    position at (`200`,`-100`) by specifying the `CenterX` and `CenterY` properties
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application. You will see images on the screen, such as the
    following ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9ed747f-bf86-4bf2-bd2a-67cb8927f455.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you set `AngleX` and `AngleY` to a `SkewTransform`, the associated element
    skews/shears counterclockwise from the *Y* axis and the *X* axis, respectively,
    at an angle specified, which is measured in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CenterX` property is used to set the *X* coordinate of the transform center,
    whereas the `CenterY` property is used to set the *Y* coordinate of the transform
    center. In the preceding example, when we specified `CenterX` and `CenterY` to
    the image, it changed the skew position centered at (`200`,`-100`) coordinate
    point, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/242686f9-efae-441c-9d4c-c33dbfd458f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving an element while rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TranslateTransform` is used to move an element from one position to another
    in the 2D interface. The `X` and `Y` properties are used to move an element towards
    the *X* and *Y* axes. In this recipe, we will learn how to apply this transforming
    to an element.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open Visual Studio and create a project named `CH08.TranslateTransformDemo`
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to move an image from a certain coordinate location
    specified by the `X` and `Y` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Before working on this, we need to add an image file to the project. From Solution
    Explorer, right-click on the project node and create a new folder. Name it `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the `Images` folder and add an existing image from your system.
    Name it `image1.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and add two images inside the `Grid` panel.
    Set the first one with a transparency of 30%. For the second image, add a `TranslateTransform`
    to it at a (`300`,`80`) location specified by the `X` and `Y` properties, as shared
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Let's build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the application, you will see two images on the screen. The first
    one, which has a 20% opacity level, is placed at the far left of the window. The
    second image, which was placed on top of it, has been moved to a coordinate point
    (`300`, `80`), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adc4c088-b021-40ed-86fa-0e5408a390f5.png)'
  prefs: []
  type: TYPE_IMG
- en: To set the distance to translate along the *X* axis, the `X` property of the
    `TranslateTransform` is used, which is `300` here. Similarly, to set the distance
    to translate along the *Y* axis, the `Y` property of the `TranslateTransform`
    is used. It is `80` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping multiple transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not mandatory to have a single transform to a single element. You can
    group multiple transforms to it, by using the `<TransformGroup></TransformGroup>`
    tag. In this recipe, we will learn how to group multiple transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open Visual Studio and create a new project named `CH08.GroupedTransformsDemo`
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to add two images to the application window and flip
    the second image to give a reflection effect. This will be done by grouping multiple
    transforms to that image:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add an image to the project. To do this, create a folder named
    `Images` in the project root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Images` folder and add an existing image to it. Name it
    `image1.png`, which will be accessible from XAML as `Images/image1.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Solution Explorer, navigate to the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `Grid` panel with a horizontal `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert two `Image` controls inside it and set their names as `originalImage`
    and `flippedImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now set the image source of both the controls to `Images/image1.png` and then
    set their size. This is how the XAML will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application, which will give the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d48f1a02-d776-4077-b41b-f86478da9ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: Close the application and return to the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will flip the second image (`flippedImage`) to give a reflection effect.
    To do so, first set the `RenderTransformOrigin` of the `Image` control to `0.5,0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add `<Image.RenderTransform>` to add the transforms mark-up. In this case,
    as we are going to add multiple transforms, add a `<TransformGroup>` tag inside
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add `ScaleTransform`, `SkewTransform`, `RotateTransform`, and `TranslateTransform`
    inside the `<TransformGroup>` tag to flip the image. This is how the `RenderTransform`
    of the `Image` will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done with the changes, your XAML will look as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the project and run the application again. What did you see? There''s
    a reflection of the first image created by flipping the second image. Here''s
    a screenshot of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f95dc29-e35d-445c-a828-3f1403d9df41.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works by defining the transformation mark-up inside the `<TransformGroup>`
    tag. In our example, we applied the `ScaleTransform`, which created a flip effect.
    The rest of the other transforms that we applied here use default values. You
    can modify their values and check how this works in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio provides you with a straightforward way to add transforms to any
    UI element. From the designer view, select the element for which you want to apply
    the transform and navigate to its Properties pane. Here, you can find an expander
    pane with the title Transform. This is used to set various values to different
    transforms available in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, you can define `TranslateTransform`,
    `RotateTransform`, `ScaleTransform`, `SkewTransform`, and `Flip`. Each tab/section
    consists of different values that it can accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e62bc3c-c59d-4ab4-99b5-02dfb56950cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating property-based animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Property-based animations** are used to change a dependency property from
    one value to another in a duration specified. There exists various animation classes
    under the namespace `System.Windows.Media.Animation`, which includes `DoubleAnimation`,
    `ColorAnimation`, and `PointAnimation`. These are used to create animation based
    on the type of property being animated.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create property-based animations. Keep
    in mind that only Dependency Properties can be modifiable during an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, let's first create a project. Open Visual Studio
    IDE and create a project named `CH08.PropertyBasedAnimationDemo`, based on the
    WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this demonstration, we will add a square box to the application window.
    On mouse hover, we will run a storyboard to change the size and color of the box
    and then reset it to the initial value on mouse leave. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, navigate to the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the XAML file, you will find a `Grid` panel placed by default. Let's
    add a `Rectangle` control inside it and set its `Height` and `Width` properties
    to `100` to give it a square look.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the rectangle the name `squareBox` so that we can identify it from our
    `Storyboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `SolidColorBrush` to fill the background of the `Rectangle`. Set a color
    to the brush and name it `squareBoxFillBrush`. Here''s the XAML snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we need to add a `Storyboard` animation to the `MouseEnter` and `MouseLeave`
    events of the `Rectangle`, let''s control these using triggers. As shown, add
    a `<Rectangle.Triggers></Rectangle.Triggers>` element to our `Rectangle` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we will be triggering the animation on `MouseEnter` and `MouseLeave` events,
    add an `EventTrigger` inside the `<Rectangle.Triggers></Rectangle.Triggers>` element
    that we have added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now expand the trigger to have `Actions` to begin a `Storyboard` animation.
    Modify your XAML mark-up as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Storyboard` animation for the `MouseEnter` event, we will be changing
    the size and color of the `squareBox` rectangle control. By using `DoubleAnimation`,
    we will be changing the `Height` and `Width` properties of the rectangle, and
    by using the `ColorAnimation` we will be changing the `Fill` color. Update the
    `Storyboard` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, add another `EventTrigger` to the `Rectangle` control to trigger
    another `Storyboard` on the `MouseLeave` event to reset the size and the color.
    This new mark-up will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application now. You will see a square with a `Black` background, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1935020f-19bc-470c-9d93-ccaeccc31b9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Mouse hover on the square. This will resize the square to a rectangle and change
    the color to `OrangeRed`. Check the transition of the size and color, which will
    have a nice animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/533e41c5-8a5c-4f35-8622-64d4079933af.png)'
  prefs: []
  type: TYPE_IMG
- en: Now hover out your mouse cursor from the rectangle. What happens now? With a
    nice animation, the rectangle will reset back to a square. Also, the background
    color will change from `OrangeRed` to `Black`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animations may be created manually by constructing the appropriate animation
    type, specifying properties, and then calling `BeginStoryboard` on the element
    to animate. The properties must be of type dependency property, which you want
    to animate on the animation object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, when the `MouseEnter` event triggers, the following `Storyboard`
    animation runs. `DoubleAnimation` and `ColorAnimation` accepts the attached properties,
    `Storyboard.TargetName` and `Storyboard.TargetProperty`, which allows the `Storyboard`
    to change the said property of the targeted element at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`From` and `To` properties are used to change the property from a specified
    value to another. Though it is optional to set the `From` field, you need to specify
    the `To` field in order to have the change in effect for the `Storyboard`. In
    the preceding example, the animation will change the `Height`, `Width`, and `Color`
    from its initial value.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a `TimeSpan` to the animation to set the time for the transition
    to occur. You can use the `Duration` property to set the value. In the preceding
    example, it will take `1` second for the transition to happen from a `Black` color
    to an `OrangeRed` color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when the `MouseLeave` event triggers, the following `Storyboard`
    responsible for resetting the value will trigger, which will set the `To` field
    to its initial value. When the `Storyboard` runs, you will see a nice transitional
    animation on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These are some common properties that you will find in most of the animation
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`From`: It is used to indicate the starting value of the animation. If you
    omit the `From` field, it will use the current value of the dependency property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`To`: It is the target value of the animation, which you should fill. If you
    omit it or put the current value, the said animation will have no effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Duration`: It is the duration of the animation. Apart from a `TimeSpan` type
    value in `hh:mm:ss.ms` format, it can also contain two special values—`Duration.Automatic`
    (default value) and `Duration.Forever`. When you specify `Duration.Forever`, it
    will run for an infinite length. In XAML, `hh:mm:ss.ms` format is mostly used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FillBehavior`: It indicates the animation''s behavior when it ends. The default
    value `FillEnd` asks to keep the last animation value; the previous value, which
    was used before the animation, will have no effect. The other value, `Stop`, destroys
    the animation and reverts the property to its value without the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginTime`: When you want to set a delay before the animation begins, you
    can use this attribute to define the delay time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoReverse`: If you want to automatically reverse the animation, after it
    ends, you can set it to `true`. The total animation duration will be effectively
    doubled when enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpeedRatio`: It allows you to speed up or slow down the animation duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepeatBehavior`: This attribute specifies the count or the time you want to
    repeat the animation, after it ends. This is often useful when you set `AutoReverse`
    to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating path-based animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with property-based animations, which we learned about in the previous
    recipe, WPF also supports **path-based animations** that run along a path specified
    by the `PathGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a `PathGeometry` to animate an element
    along its way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with creating a new WPF application project. Name it `CH08.PathBasedAnimationDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this demonstration, we will use a circle to animate it on the click of a
    button. The animation will be performed based on a path specified by a set of
    geometry coordinates. Let''s build this by following the steps mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, navigate to the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A default `Grid` panel will be present inside the file. Let''s divide it into
    two rows by specifying the row definition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's place a `Canvas` panel inside the first row. Add an `Ellipse` of `Height="30"`
    and `Width="30"` to form the circle. Give it a name `circle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the fill color of the `Ellipse` and position it at the (`100`, `100`) coordinate
    location of the canvas. Here''s the complete mark-up for your reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using this `Ellipse` to animate inside the canvas along a path.
    For this, we will need a `PathGeometry` defined. To do so, add the following inside
    the `Window` tag as `Resources` to define the `PolyLineSegment` points as a collection
    of coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a `Button` control inside the `Window`, which will be used to trigger
    the animation. Surround the button with a horizontal `StackPanel` and place it
    inside the second row of the `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to catch the `Button.Click` event. For this, we will need an `EventTrigger`
    to define against the `Button` control. And, once the trigger fires, the action
    is to begin a `Storyboard` to perform an animation. Let''s modify the `Button`
    control to have this trigger set to start a storyboard. Here''s the code to refer
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to add some path animations to the `Storyboard` that we have added
    inside the `Button.Click` event handler. Let's use `DoubleAnimationUsingPath`
    to bind the `PathGeometry` that we added to the `Window.Resources` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Storyboard.TargetName` to `circle` and the `Storyboard.TargetProperty`
    to `(Canvas.Left)` and `(Canvas.Top)` to create an animation in both the *X* and
    *Y* axes. Here''s the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the application and run it. You will see the following UI with
    a circle and a button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb9dc284-e516-4edc-b560-75406166e27c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Animate button and observe the positions of the circle. You will
    see a nice animated flow on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f8d3070-7d43-4f4c-bdba-70e7129a234a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The path-based animations use a `PathGeometry` as a path to create the animation.
    In our example, we defined it under the `Window.Resources` tag as an `animationPath`,
    which represents the path in a 2D interface as a collection of coordinate points.
    See the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `DoubleAnimationUsingPath` that we used in our storyboard animation uses
    `Canvas.Left` and `Canvas.Top` as the target properties to animate along the *X*
    and *Y* axes. When the `Storyboard` plays, the target element moves from one coordinate
    point to another, having a smooth animation between the two points.
  prefs: []
  type: TYPE_NORMAL
- en: Creating key-frame-based animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key frame animations in WPF enable you to animate an element using more than
    two target-values and control an animation's interpolation method. A key frame
    animation has no `From`/`To` properties with which we can set its target values.
  prefs: []
  type: TYPE_NORMAL
- en: The animation's target values are described using key frame objects, which you
    need to add to the animation's `KeyFrames` collection. When the animation runs,
    it transitions between the key frames that you specified.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a key-frame-based animation and
    use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create a project first. Open Visual Studio IDE and create a new project
    named `CH08.KeyFrameBasedAnimationDemo`, based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to create a key-frame-based animation:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two rows inside the `Grid`, by specifying `RowDefinitions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add a `Canvas` panel at 0^(th) row of the `Grid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert an `Ellipse` inside the canvas and set its `Height` and `Width` properties
    to `30`, so that it displays as a circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name to the `Ellipse`, and position it to the (`50`,`100`) coordinate
    position on the `Canvas` panel, and fill the background with an `OrangeRed` color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a `Button` control inside a horizontal `StackPanel`, and place the panel
    inside the second row. Here''s the complete XAML of the UI that we have generated
    for this demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On pressing the button, we need to animate the circle around the application
    window. To do this, we will be using an `EventTrigger`. Define the trigger for
    a `Button.Click` event and set its action to begin a storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `AutoReverse` property of the `Storyboard` to `True`. Here''s the code
    for launching the storyboard when a user triggers the button click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside the storyboard, we need to define an animation that will run based on
    the key frame specified. This is done by adding one or more `LinearDoubleKeyFrame`(s)
    inside a `DoubleAnimationUsingKeyFrames` element. Insert two instances of `DoubleAnimationUsingKeyFrames`
    inside the `Storyboard` definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Storyboard.TargetName` property of `DoubleAnimationUsingKeyFrames`
    to `circle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `AutoReverse` to `True` and `RepeatBehavior` to `Forever`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first `DoubleAnimationUsingKeyFrames`, set the `Storyboard.TargetProperty`
    to `(Canvas.Left)`. For the other one, set it to `(Canvas.Top)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define key frames by adding one or more `LinearDoubleKeyFrame` instances to
    the `DoubleAnimationUsingKeyFrames`. Set their `KeyTime` and `Value`. Here''s
    the complete code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, let''s run the application. You will see a circle on the screen
    at the (`50`, `100`) coordinate point. There also exists a button labeled Animate,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/080c21ef-7ee7-4a5a-8bc3-946293c5a839.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Animate button to start the defined storyboard. See the movement
    and the speed of the circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ffa3ac35-4712-45d0-b494-5264fee82e63.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a key frame animation begins, it iterates through the specified key frames
    in the order they were defined by their `KeyTime` properties. If there exists
    no key frame at time `0` (initial point), the animation creates a transition between
    the target property's current value and the `Value` of the first key frame defined
    in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: If the animation's `Duration` is `Automatic` or set to the time of the last
    key frame, the animation ends.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding demonstration, the first key frame (at time `0`) sets the animation's
    output value to `Canvas.Left="50"` and `Canvas.Top="100"`. In the next key frame
    (at time `1 sec`), the output value sets to the (`450`,`200`) coordinate point,
    and you will see a smooth transition between the (`50`,`100`) and the (`450`,`200`)
    points. Similarly, in the third and fourth seconds, the circle transitions from
    (`450`,`200`) to (`450`,`50`) and then to the (`250`,`150`) coordinate points.
  prefs: []
  type: TYPE_NORMAL
- en: As the defined `Storyboard` has an `AutoReverse` property set to `True`, the
    animation will have a reverse transition to move the circle from the end point
    (`250`,`150`) to the initial start point (`50`,`100`) via the (`450`,`50`) and
    the (`450`,`200`) coordinate points.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key-frame-based animation class type is not limited to only `DoubleAnimationUsingKeyFrames`.
    You can use any of the following key frame animation classes to construct your
    storyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean: `BooleanAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Byte: `ByteAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color: `ColorAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decimal: `DecimalAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Double: `DoubleAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Int16: `Int16AnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Int32: `Int32AnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Int64: `Int64AnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matrix: `MatrixAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object: `ObjectAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Point: `PointAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quaternion: `QuaternionAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rect: `RectAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation3D: `Rotation3DAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single: `SingleAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: `StringAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: `SizeAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thickness: `ThicknessAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector3D: `Vector3DAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector: `VectorAnimationUsingKeyFrames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding easing effects to animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property-based animations are linear, whereas the key-frame-based animations
    are non-linear and are used to create **Beizer**-based interpolations. But creation
    of such effects is not so easy. To overcome this, WPF 4 introduces **easing functions**
    to turn a linear animation into a non-linear one and add some easing effects to
    those animation objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to do this with a suitable example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with adding easing effects to an animation, let's open Visual
    Studio and create a new project named `CH08.EasingEffectDemo`. Select a WPF application
    template while creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to create an animation with various kinds of easing
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: From Solution Explorer, open the `MainWindow.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Divide the existing `Grid` panel into two columns, by applying `ColumnDefinition`
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside the `Grid`, place a `Canvas` panel, and set its `Grid.Column` attribute
    to `0` (zero).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the canvas, add an `Ellipse` (name it as `circle`) and set its `Height`
    and `Width` properties to `80` to give it a circular look. Set its `Fill` color
    property, and position it to a (`150`,`80`) location. Here''s the code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now add a vertical `StackPanel` inside the `Grid` and set its `Grid.Column`
    attribute to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three radio buttons (`GroupName="AnimationSelector"`) inside the `StackPanel`,
    and add a `Storyboard` animation to fire when the `RadioButton.Checked` event
    is triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a simple `DoubleAnimation` to move the circle horizontally by setting its
    `Storyboard.TargetProperty` to `(Canvas.Left)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now expand the animation to add an easing effect to it. Insert a `<DoubleAnimation.EasingFunction></DoubleAnimation.EasingFunction>`
    attribute to hold the effect that we are going to add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add a `BackEase` effect to the three radio buttons. This type of effect
    represents an easing function that retracts the motion of an animation slightly
    before it begins to animate in the path indicated, and is denoted by the following
    function—`f(t) = t3 - t * a * sin(t * pi)`. Set the `Amplitude` property of the
    function to `0.3` and the `EasingMode` property to `EaseIn`, `EaseOut`, and `EaseInOut`,
    respectively. The complete code will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application. You will see the following UI on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd5160b5-c666-4043-814f-550ce423786f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now change the selection of the radios and observe the effects added to the
    animation of the circular object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animation easing applies a function to the animation value to alter a linear
    animation to form a non-linear one. A mode option, defined by the `EasingMode`
    property, allows you to set when to apply the easing function. This could be at
    the beginning (`EaseIn`), at the end (`EaseOut`), or both (`EaseInOut`).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we defined a `BackEase` function to the animation
    with different easing modes, which will animate when the `Checked` event of the
    radio buttons trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `BackEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5bad042-6e0a-4aef-af32-0a1e75a7eac8.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s not limited to only the `BackEase` function, but it can have any of the
    11 built-in easing functions defined in WPF. The complete list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BackEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BounceEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CircleEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CubicEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ElasticEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExponentialEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PowerEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuadraticEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuarticEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuinticEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SineEase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these listed easing functions derive from the abstract class `EasingFunctionBase`,
    which implements the `IEasingFunction` interface. It contains an `Ease` method
    and adds the `EasingMode` property, which indicates whether the function should
    be applied at the start of the animation (`EaseIn`), the end of the animation
    (`EaseOut`), or both ways (`EaseInOut`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify our existing UI to have some more built-in easing functions added
    to the animation. To demonstrate this, we are going to add 10 more radio buttons
    inside the `StackPanel` and apply the easing functions to each one of them, as
    discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: BounceEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of function creates an animated bouncing effect to the target. The
    `Bounces` and `Bounciness` properties can be used to control the bounces. The
    `Bounces` property denotes the number of bounces and the `Bounciness` property
    defines how bouncy the bounce animation is. The lower the value of `Bounciness`,
    the higher the bouncing animation; the higher the value of `Bounciness`, the lower
    the bounces of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, let''s apply a `BounceEase` function to the `DoubleAnimation`
    to create a bouncing effect. Let''s add the following `RadioButton` inside the
    `StackPanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `BounceEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fec5c15-2d6f-47d1-9b46-2d261965ab46.png)'
  prefs: []
  type: TYPE_IMG
- en: CircleEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This represents an easing function that creates an animation that accelerates/decelerates
    using a `circular` function, and is denoted by the following function `f(t) =
    1 - sqrt(1 - t2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following `RadioButton` inside the `StackPanel` to create an
    animation with a circular easing effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `CircleEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c4a73e-008e-492b-b48d-53f56249901a.png)'
  prefs: []
  type: TYPE_IMG
- en: CubicEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This creates an animation that accelerates/decelerates using the formula `f(t)
    = t3`, where `EasingMode` can be applied to control acceleration, deceleration,
    or both, by setting the value `EaseIn`, `EaseOut`, or `EasInOut`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following `RadioButton` inside the `StackPanel` to create an
    animation with an accelerating `CubicEase` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `CubicEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bcf1a9-75cd-42d1-89d8-d0ef79f52800.png)'
  prefs: []
  type: TYPE_IMG
- en: ElasticEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name says, it represents an easing function that creates an animation
    that resembles a spring oscillating back and forth until it comes to rest. The
    `Oscillations` property can be used to get/set the number of times the target
    slides back and forth over the animation destination. The `Springiness` property
    can be used to define the stiffness of the spring. The smaller the value of `Springiness`,
    means a stiffer spring in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let''s add the following `RadioButton` inside the `StackPanel`
    to create an animation with `ElasticEase`, having `Oscillations="3"` and `Springiness="1"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `ElasticEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0c8a3a2-0b6c-4b86-8e56-8aa247bebfac.png)'
  prefs: []
  type: TYPE_IMG
- en: ExponentialEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of easing function creates an animation that accelerates/decelerates
    using an exponential formula `f(t) = [[e(at) - 1] / [e(a) - 1]]`. The `Exponent`
    property is used to determine the interpolation of the animation; whereas the
    `EasingMode` property is used to accelerate and decelerate the animation of the
    target control.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, add the following `RadioButton` control inside the `StackPanel`,
    which will create a decelerate exponential easing effect with the interpolation
    value `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `ExponentialEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5141208a-c2db-4f71-a24a-7440aab2ec36.png)'
  prefs: []
  type: TYPE_IMG
- en: PowerEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It defines an easing function that creates an animation that accelerates/decelerates
    using the formula `f(t) = tp`, where `p` is equal to the value of the `Power`
    property. As with other easing functions, you can add an easing mode to specify
    whether the animation will accelerate or decelerate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demonstration, add the following `RadioButton` that defines the `PowerEase`
    easing function to the `DoubleAnimation` specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can use `PowerEase` to substitute `QuadraticEase` [`f(t) = t2`], `CubicEase`
    [`f(t) = t3`], `QuarticEase` [`f(t) = t4`], and `QuinticEase` [`f(t) = t5`] type
    of easing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `PowerEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fffc620-49dc-4af9-995f-d601a9051ed0.png)'
  prefs: []
  type: TYPE_IMG
- en: QuadraticEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It creates an animation that accelerates/decelerates using the formula `f(t)
    = t2`. You can use `PowerEase` to create the same behavior by specifying `Power="2"`.
    In this example, we will learn how to add the `QuadraticEase` function to an animation.
    Add the following mark-up inside the `StackPanel` that we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuadraticEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea56386b-65d1-4321-8184-7c5a77f1e7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: QuarticEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like `QuadraticEase`, you can also define `QuarticEase` to create an animation
    that accelerates/decelerates using the formula `f(t) = t4`. You can use `PowerEase`
    to create the same behavior by specifying `Power="4"`. Let''s add the following
    mark-up inside our `StackPanel` to define the animation with the said easing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuarticEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c39fa632-f23d-44ab-af62-35b387bfcea7.png)'
  prefs: []
  type: TYPE_IMG
- en: QuinticEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to add the `QuinticEase` effect to your easing function, add it
    to your animation. It accelerates/decelerates using the formula `f(t) = t5`. You
    can use `PowerEase` to create the same by specifying `Power="5"`. Add the following
    `RadioButton` to define an animation with the `QuinticEase` easing function in
    our `StackPanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `QuinticEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3027a6c0-de5b-4766-9371-06db49cfde58.png)'
  prefs: []
  type: TYPE_IMG
- en: SineEase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This represents an easing function that creates an animation that accelerates
    and/or decelerates using a sine formula `f(t) = [1 - [sin(1 - t) * [pi / 2]]]`.
    Add the `EasingMode` property to accelerate and/or decelerate the effect. Let''s
    add the following code inside the `StackPanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph demonstrates different values of `EasingMode`, for the
    `SineEase` effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/490dbba7-b709-4781-8889-df4cddf4139a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are ready, let''s build the project and run it. You will now see the
    following UI, which contains additional radio buttons inside the right-hand panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99b9771d-cb86-4ccb-9f91-f4957d54ec4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the selection of the radios to see the animations for each easing function
    associated with them.
  prefs: []
  type: TYPE_NORMAL
