<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object Lifetime</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Object Lifetime is the time duration between an object's creation and destruction. </span><span class="koboSpan" id="kobo.2.2">In Functional Programming Languages, data stored in constant variables have a scope defined which is immutable in nature. </span><span class="koboSpan" id="kobo.2.3">This means that their lifetimes have a functional scope (no destruction) as long as the app is not stopped. </span><span class="koboSpan" id="kobo.2.4">On the other hand, the objects in Object Oriented Programming are mutable and have different types of scope which leads to different lifestyles.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">Memory plays a vital role in application life cycle. </span><span class="koboSpan" id="kobo.3.2">All objects and variables use memory space. </span><span class="koboSpan" id="kobo.3.3">Therefore, it is important to learn the concepts which deal with an object's flow during application execution. </span><span class="koboSpan" id="kobo.3.4">Unless we know how to free up space by using proper codes or patterns, it would result in </span><strong><span class="koboSpan" id="kobo.4.1">Memory Leaks</span></strong><span class="koboSpan" id="kobo.5.1">.</span></p>
<p><span class="koboSpan" id="kobo.6.1">If a computer program exposes bugs and erroneously manages the memory allocations, then resources become unavailable. </span><span class="koboSpan" id="kobo.6.2">This condition is called Memory Leaks.</span></p>
<p><span class="koboSpan" id="kobo.7.1">To avoid Memory Leaks, we should take proper care while designing our classes, so that the resources are available when needed. </span><span class="koboSpan" id="kobo.7.2">That would only happen if and only if resources attached to objects are released by the program as soon as objects go out of scope. </span><span class="koboSpan" id="kobo.7.3">Thus, the app runs seamlessly as unused space is regularly cleared. </span><span class="koboSpan" id="kobo.7.4">However, this process is not automatic in all scenarios. </span><span class="koboSpan" id="kobo.7.5">The reason, we are going to explore this topic, is to understand how exactly the DI technique manages the lifetime of objects differently in different scenarios, which in return helps us take appropriate decisions while designing our classes.</span></p>
<p><span class="koboSpan" id="kobo.8.1">An object is born when it's related class is instantiated. </span><span class="koboSpan" id="kobo.8.2">The newly born object stays around for a limited period of time as long as the application keeps a reference of that and continues to use that. </span><span class="koboSpan" id="kobo.8.3">If your application is closed or the reference of the object goes out of scope in the code, then .NET Framework will flag that object to be removed from memory.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In this particular chapter, we will learn how objects are managed by .NET Core. </span><span class="koboSpan" id="kobo.9.2">Also, we will look into techniques to determine when an object is disposable and how to work with it.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Topics we will cover in this chapter are:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Managed and unmanaged resources.</span></li>
<li><span class="koboSpan" id="kobo.12.1">Object's creation and destruction</span></li>
<li><kbd><span class="koboSpan" id="kobo.13.1">IDisposal</span></kbd><span class="koboSpan" id="kobo.14.1"> interface</span></li>
<li><span class="koboSpan" id="kobo.15.1">Object lifetime management in .NET Core</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Manage the object life cycle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are two basic places in the memory--stack and heap.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Stack versus heap</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Let's learn a little bit about these memory space types.</span><strong><br/></strong></p>
<table>
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.3.1">Stack</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.4.1">Heap</span></strong></td>
</tr>
<tr>
<td>
<p class="mce-root"><span class="koboSpan" id="kobo.5.1">Static memory: Fixed memory space allocated for the app.</span></p>
</td>
<td><span class="koboSpan" id="kobo.6.1">Dynamic memory: No fixed space.</span></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.7.1">When a method is called, a chunk of stack is reserved to store the method's information like a method name, local variables, return type, and so on.</span></td>
<td><span class="koboSpan" id="kobo.8.1">Can store anything. </span><span class="koboSpan" id="kobo.8.2">The developer has the flexibility to manage this space.</span></td>
</tr>
<tr>
<td><span><span class="koboSpan" id="kobo.9.1">Memory allocation has a pattern in </span><strong><span class="koboSpan" id="kobo.10.1">LIFO</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">Last In First Out</span></strong><span class="koboSpan" id="kobo.13.1">) order. </span><span class="koboSpan" id="kobo.13.2">So, when the </span><kbd><span class="koboSpan" id="kobo.14.1">Main</span></kbd><span class="koboSpan" id="kobo.15.1"> function calls method </span><kbd><span class="koboSpan" id="kobo.16.1">A()</span></kbd><span class="koboSpan" id="kobo.17.1"> and then </span><kbd><span class="koboSpan" id="kobo.18.1">A()</span></kbd><span class="koboSpan" id="kobo.19.1"> calls </span><kbd><span class="koboSpan" id="kobo.20.1">B()</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">B()</span></kbd><span class="koboSpan" id="kobo.23.1"> will be stored at the top and executes first. </span><span class="koboSpan" id="kobo.23.2">Refer to the following diagram:</span></span></td>
<td>
<p class="mce-root"><span class="koboSpan" id="kobo.24.1">No such pattern to store data.</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.25.1"> </span></p>
<p><span class="koboSpan" id="kobo.26.1">The following diagram shows how the data gets stored in stack and heap for one program:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1"><img height="233" width="389" src="assets/dff1fbbb-ae31-446a-87ba-1c011ddfec81.png"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.28.1">Main()</span></kbd><span><span class="koboSpan" id="kobo.29.1"> calls </span></span><kbd><span class="koboSpan" id="kobo.30.1">A()</span></kbd><span><span class="koboSpan" id="kobo.31.1"> which then calls </span></span><kbd><span class="koboSpan" id="kobo.32.1">B()</span></kbd><span><span class="koboSpan" id="kobo.33.1"> method. </span><span class="koboSpan" id="kobo.33.2">According to stack properties, it first moves the last one out, which is </span></span><kbd><span class="koboSpan" id="kobo.34.1">B()</span></kbd><span><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">So, </span></span><kbd><span class="koboSpan" id="kobo.36.1">B()</span></kbd><span><span class="koboSpan" id="kobo.37.1"> executes first. </span><span class="koboSpan" id="kobo.37.2">Then </span></span><kbd><span class="koboSpan" id="kobo.38.1">B()</span></kbd><span><span class="koboSpan" id="kobo.39.1"> is removed from the stack and then </span></span><kbd><span class="koboSpan" id="kobo.40.1">A()</span></kbd><span><span class="koboSpan" id="kobo.41.1"> is processed and removed from memory. </span><span class="koboSpan" id="kobo.41.2">After that, the </span></span><kbd><span class="koboSpan" id="kobo.42.1">Main()</span></kbd><span><span class="koboSpan" id="kobo.43.1"> method executes and removed. </span><span class="koboSpan" id="kobo.43.2">The reference type variable named as </span></span><kbd><span class="koboSpan" id="kobo.44.1">foo</span></kbd><span><span class="koboSpan" id="kobo.45.1"> inside </span><kbd><span class="koboSpan" id="kobo.46.1">Main()</span></kbd><span class="koboSpan" id="kobo.47.1"> is stored in stack, but the actual object is allocated memory in heap.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Consider the following example:</span></p>
<pre><span class="koboSpan" id="kobo.49.1">    static void Main(string[] args)
    {
      string name = "Dependency Injection";
      SomeClass sc = new SomeClass()
    }</span></pre>
<p><span class="koboSpan" id="kobo.50.1">The variable </span><kbd><span class="koboSpan" id="kobo.51.1">name</span></kbd><span class="koboSpan" id="kobo.52.1"> is a value type, which is directly stored on the stack. </span><span class="koboSpan" id="kobo.52.2">But, when we write </span><kbd><span class="koboSpan" id="kobo.53.1">SomeClass sc = new SomeClass()</span></kbd><span class="koboSpan" id="kobo.54.1">, it actually tells the framework to store the object in heap. </span><span class="koboSpan" id="kobo.54.2">In addition to this, it also allocates a memory space for a variable </span><kbd><span class="koboSpan" id="kobo.55.1">sc</span></kbd><span class="koboSpan" id="kobo.56.1"> in the stack, which holds the reference to this object.</span></p>
<p><span class="koboSpan" id="kobo.57.1">Now, when the </span><kbd><span class="koboSpan" id="kobo.58.1">Main</span></kbd><span class="koboSpan" id="kobo.59.1"> method execution is completed, the variables </span><kbd><span class="koboSpan" id="kobo.60.1">name</span></kbd><span class="koboSpan" id="kobo.61.1"> and </span><kbd><span class="koboSpan" id="kobo.62.1">sc</span></kbd><span class="koboSpan" id="kobo.63.1"> will be released and memory space becomes free. </span><span class="koboSpan" id="kobo.63.2">Here is the catch though. </span><span class="koboSpan" id="kobo.63.3">The variable </span><kbd><span class="koboSpan" id="kobo.64.1">sc</span></kbd><span class="koboSpan" id="kobo.65.1"> (reference type) is released from the stack, but the actual object is still on the heap. </span><span class="koboSpan" id="kobo.65.2">It's just the reference, which is removed. </span><span class="koboSpan" id="kobo.65.3">As the reference is removed from the stack, so there is no way to actually know if there is an object existing on the heap., related to it. </span><span class="koboSpan" id="kobo.65.4">We have ended up with a management problem now.</span></p>
<p><span class="koboSpan" id="kobo.66.1">To get rid of this (in C++), we could have done something like this </span><kbd><span class="koboSpan" id="kobo.67.1">delete sc;</span></kbd><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">However, in C#, which is a managed language, there is a service known as </span><strong><span class="koboSpan" id="kobo.69.1">Garbage Collector</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong><span class="koboSpan" id="kobo.71.1">GC</span></strong><span class="koboSpan" id="kobo.72.1">), which automatically cleans up the unused memory by analyzing all those flagged </span><em><span class="koboSpan" id="kobo.73.1">out of scoped</span></em><span class="koboSpan" id="kobo.74.1"> objects.</span></p>
<div class="packt_infobox"><strong><span class="koboSpan" id="kobo.75.1">Managed Language</span></strong><span class="koboSpan" id="kobo.76.1"> is a high-level language that depends on services provided by a runtime environment to execute, such as Garbage Collection service, Security Service, Exception Handling, and more. </span><span class="koboSpan" id="kobo.76.2">It uses Common Language Runtime (CLR) to execute in .Net languages or </span><strong><span class="koboSpan" id="kobo.77.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.78.1"> (</span><strong><span class="koboSpan" id="kobo.79.1">JVM</span></strong><span class="koboSpan" id="kobo.80.1">) in Java.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Managed and unmanaged resources</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Pure .NET code is called </span><strong><span class="koboSpan" id="kobo.3.1">managed resources</span></strong><span class="koboSpan" id="kobo.4.1"> as that can be directly managed by the runtime environment. </span><span class="koboSpan" id="kobo.4.2">On the other hand, unmanaged resources are those that are not in direct control of the runtime such as, file handles, COM objects, database connections, and so on. </span><span><span class="koboSpan" id="kobo.5.1">For example, if you open a connection to a database server this will use resources on the server (for maintaining the connection) and possibly other non .NET resources.</span></span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.6.1">The managed resources are targeted directly by CLR, therefore, Garbage Collector cleans them up, which is an automatic process. </span><span class="koboSpan" id="kobo.6.2">As a developer, you don't usually need to explicitly call GC. </span><span class="koboSpan" id="kobo.6.3">However, there is a catch, when we consider the unmanaged resources like database connections. </span><span class="koboSpan" id="kobo.6.4">We have to deal with them ourselves as the CLR can't. </span><span class="koboSpan" id="kobo.6.5">We have to release them manually using the </span><kbd><span class="koboSpan" id="kobo.7.1">Finalize</span></kbd><span class="koboSpan" id="kobo.8.1"> method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Generations</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">The heap is categorized into three generations so it can handle long-lived and short-lived objects. </span><span class="koboSpan" id="kobo.2.2">Garbage collection basically reclaims short-lived objects that typically occupy only a small part of the heap.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">There are the following three generations of objects on the heap:</span></p>
<ul>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.4.1">Generation 0</span></strong><span class="koboSpan" id="kobo.5.1">: When an object is initialized, it's generation gets started. </span><span class="koboSpan" id="kobo.5.2">It first falls into Generation 0. </span><span class="koboSpan" id="kobo.5.3">This generation's objects are usually short-lived. </span><span class="koboSpan" id="kobo.5.4">These objects are more prone to GC for destruction. </span><span class="koboSpan" id="kobo.5.5">GC collects these short-lived objects so that they can be released to free up memory space. </span><span class="koboSpan" id="kobo.5.6">If the objects survive from being collected by GC, that means they are going to stay for a longer time, thereby being promoted to the next generation.</span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.6.1">Generation 1</span></strong><span class="koboSpan" id="kobo.7.1">: This generation objects live for a longer duration than Generation 0 objects. </span><span class="koboSpan" id="kobo.7.2">GC does collect the objects from this generation, but not so regularly as it does for Generation 0 because their existence is extended by the application for more operations. </span><span class="koboSpan" id="kobo.7.3">Survivors of this generation go to Generation 2.</span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.8.1">Generation 2</span></strong><span class="koboSpan" id="kobo.9.1">: These are the longest existing objects in the application. </span><span class="koboSpan" id="kobo.9.2">Prolonged objects which successfully pass through the previous two generations are automatically considered for Generation 2. </span><span class="koboSpan" id="kobo.9.3">GC rarely comes into the picture when it comes to releasing these objects.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object creation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Constructors are responsible for giving birth to the object of a particular class. </span><span><span class="koboSpan" id="kobo.3.1">If we create any class without a constructor, the compiler will automatically create a one default constructor for that class. </span><span class="koboSpan" id="kobo.3.2">At least one constructor is present in every class.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">The constructors can be overloaded too which provide a convenient way to build the object with different attributes, meaning, it can instantiate the object by taking certain parameters (like a normal method) and assign them to its properties inside its body (also called as a parameterized constructor). </span><span class="koboSpan" id="kobo.4.2">A constructor should have the same name as the class name.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Copy constructor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There is another type of constructor called the </span><strong><span class="koboSpan" id="kobo.3.1">Copy constructor</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">As the name suggests, it can copy one object to the new object (of the same class) which is going to be instantiated. </span><span class="koboSpan" id="kobo.4.3">In other words, it is a</span><span><span class="koboSpan" id="kobo.5.1"> parameterized constructor that contains a parameter of same class type. </span><span class="koboSpan" id="kobo.5.2">The main purpose of a copy constructor is to initialize a new instance to the values of an existing instance.</span></span><span class="koboSpan" id="kobo.6.1"> We will see how this can be done with an example in a while.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object destruction</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have different ways to destroy an object. </span><span class="koboSpan" id="kobo.2.2">Let's explore them one by one.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Finalize</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Finalizers are used to destroy the objects. </span><span class="koboSpan" id="kobo.2.2">We can design Finalizers using destructor methods using the tilde (</span><kbd><span class="koboSpan" id="kobo.3.1">~</span></kbd><span class="koboSpan" id="kobo.4.1">) sign with the class name. </span><span class="koboSpan" id="kobo.4.2">We will see it in action soon:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    ~Order()</span><br/><span class="koboSpan" id="kobo.6.1">    {</span><br/><span class="koboSpan" id="kobo.7.1">      // Destructor or Finalizer</span><br/><span class="koboSpan" id="kobo.8.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.9.1">Garbage Collector has full control on the finalization process as it internally calls this method when objects go out of scope. </span><span class="koboSpan" id="kobo.9.2">We can, however, write codes inside the destructor to customize our requirements, but we can't just say to someone to call the destructor. </span><span class="koboSpan" id="kobo.9.3">Even if you are very sure that the object is not required anymore and decide to release it, you can't explicitly execute destructor in order to free up space. </span><span class="koboSpan" id="kobo.9.4">You have to wait until GC collects the object for destruction.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The finalization process has two collection cycles. </span><span class="koboSpan" id="kobo.10.2">In the first cycle, short-lived objects are flagged for finalization. </span><span class="koboSpan" id="kobo.10.3">In the next cycle, it calls the finalizers to release them completely from memory space.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The IDisposable interface</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Unmanaged resources, as we discussed, are not in direct control of the framework. </span><span class="koboSpan" id="kobo.2.2">We can easily reclaim these resources inside Finalizers, as we discussed. </span><span class="koboSpan" id="kobo.2.3">That means, they will be released when the objects are destroyed by the garbage collector. </span><span class="koboSpan" id="kobo.2.4">However, the GC destroys the objects only when the CLR demands more free memory. </span><span class="koboSpan" id="kobo.2.5">So, resources may still exist even long even after the object goes out of scope.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">Thus, there is a need to free up resources as soon as we are done with them. </span><span class="koboSpan" id="kobo.3.2">Your classes can provide a mechanism to actively manage system resources if they implement the </span><kbd><span class="koboSpan" id="kobo.4.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.5.1"> interface. </span><span class="koboSpan" id="kobo.5.2">This interface exposes one method, </span><kbd><span class="koboSpan" id="kobo.6.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.7.1">, which clients should call when they finish using an object. </span><span class="koboSpan" id="kobo.7.2">You can use the </span><kbd><span class="koboSpan" id="kobo.8.1">Dispose</span></kbd><span class="koboSpan" id="kobo.9.1"> method to immediately release resources to perform tasks such as closing files and database connections etc. </span><span class="koboSpan" id="kobo.9.2">Unlike the </span><kbd><span class="koboSpan" id="kobo.10.1">Finalize</span></kbd><span class="koboSpan" id="kobo.11.1"> destructor, the </span><kbd><span class="koboSpan" id="kobo.12.1">Dispose</span></kbd><span class="koboSpan" id="kobo.13.1"> method is not called automatically. </span><span class="koboSpan" id="kobo.13.2">Objects must explicitly call </span><kbd><span class="koboSpan" id="kobo.14.1">Dispose</span></kbd><span class="koboSpan" id="kobo.15.1"> when they want to release the resources.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.16.1">This method is the single method in an </span><kbd><span class="koboSpan" id="kobo.17.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.18.1"> interface and can be used to release unmanaged resources manually.</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.19.1">    public interface IDisposable</span><br/><span class="koboSpan" id="kobo.20.1">    {</span><br/><span class="koboSpan" id="kobo.21.1">      void Dispose();</span><br/><span class="koboSpan" id="kobo.22.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.23.1">Now it's just a matter of calling the </span><kbd><span class="koboSpan" id="kobo.24.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">But wait. </span><span class="koboSpan" id="kobo.25.3">You can only call this method from an object of a class which have implemented this interface and defined the </span><kbd><span class="koboSpan" id="kobo.26.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.27.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.28.1">For example, the </span><kbd><span class="koboSpan" id="kobo.29.1">SqlConnection</span></kbd><span class="koboSpan" id="kobo.30.1"> class has implemented this interface and provided us with the </span><kbd><span class="koboSpan" id="kobo.31.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.32.1"> method, which can be used as follows. As soon as you are finished using the connection object, call </span><kbd><span class="koboSpan" id="kobo.33.1">Dispose</span></kbd><span class="koboSpan" id="kobo.34.1">:</span></p>
<pre><span class="koboSpan" id="kobo.35.1">    var connection = new SqlConnection("ConnectionString");</span><br/><span class="koboSpan" id="kobo.36.1">    // Do Database related stuff here.</span><br/><br/><span class="koboSpan" id="kobo.37.1">    // After we are done, let's call Dispose.</span><br/><span class="koboSpan" id="kobo.38.1">    connection.Dispose();</span></pre>
<p><span class="koboSpan" id="kobo.39.1">There is another beautiful way to deal with the disposal of objects in .NET. </span><span class="koboSpan" id="kobo.39.2">Instead of calling </span><kbd><span class="koboSpan" id="kobo.40.1">Dispose</span></kbd><span class="koboSpan" id="kobo.41.1"> directly, we can use the </span><kbd><span class="koboSpan" id="kobo.42.1">using</span></kbd><span class="koboSpan" id="kobo.43.1"> block. </span><span class="koboSpan" id="kobo.43.2">The same statement can be decorated with the </span><kbd><span class="koboSpan" id="kobo.44.1">using</span></kbd><span class="koboSpan" id="kobo.45.1"> block coded as follows:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.46.1">     using (var connection = new SqlConnection("ConnectionString"))
    {
      // Use the connection object and do database operation.
    </span><span class="koboSpan" id="kobo.46.2">}</span></pre>
<p><span class="koboSpan" id="kobo.47.1">When we do this, it converts the code to </span><kbd><span class="koboSpan" id="kobo.48.1">try...finally</span></kbd><span class="koboSpan" id="kobo.49.1"> intermediate code. </span><span class="koboSpan" id="kobo.49.2">It disposes the connection object inside the </span><kbd><span class="koboSpan" id="kobo.50.1">finally</span></kbd><span class="koboSpan" id="kobo.51.1"> block, which we created. </span><span class="koboSpan" id="kobo.51.2">Unless you do this, the connection object stays in memory. </span><span class="koboSpan" id="kobo.51.3">In due course, when we get a huge number of connections, memory starts to leak.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.52.1">If you are using the finalizer (destructor) method, then make sure to call </span><kbd><span class="koboSpan" id="kobo.53.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.54.1"> inside it for the resources you want to deallocate. </span><span class="koboSpan" id="kobo.54.2">Thus, you will be doubly sure that your resources will be cleaned by GC even if someone forgets to release them in their code while using your class.</span></div>
<p><span class="koboSpan" id="kobo.55.1">Out of curiosity, you must be asking yourself, what would happen if some exception occurs before </span><kbd><span class="koboSpan" id="kobo.56.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.57.1"> is called? </span><span class="koboSpan" id="kobo.57.2">Will that object be disposed of? </span><span class="koboSpan" id="kobo.57.3">The solution to this is to wrap that with a </span><kbd><span class="koboSpan" id="kobo.58.1">try...finally</span></kbd><span class="koboSpan" id="kobo.59.1"> block, so that no matter what happens to the program, finally will be called and you can dispose of objects inside that. </span><span class="koboSpan" id="kobo.59.2">To make it simple, the framework has a beautiful thing called the </span><kbd><span class="koboSpan" id="kobo.60.1">using</span></kbd><span class="koboSpan" id="kobo.61.1"> block which can be used as follows:</span></p>
<div class="packt_infobox"><kbd><span class="koboSpan" id="kobo.62.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.63.1"> versus </span><kbd><span class="koboSpan" id="kobo.64.1">Close()</span></kbd><span class="koboSpan" id="kobo.65.1">: Are you confused which one to call for an </span><kbd><span class="koboSpan" id="kobo.66.1">SqlConnection</span></kbd><span class="koboSpan" id="kobo.67.1"> object? </span><span class="koboSpan" id="kobo.67.2">They are two different methods which solve different problems. </span><kbd><span class="koboSpan" id="kobo.68.1">Close()</span></kbd><span class="koboSpan" id="kobo.69.1"> just closes the connection. </span><span class="koboSpan" id="kobo.69.2">You can reopen the connection using the same object. </span><span class="koboSpan" id="kobo.69.3">However, </span><kbd><span class="koboSpan" id="kobo.70.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.71.1"> closes the connection (calls </span><kbd><span class="koboSpan" id="kobo.72.1">Close()</span></kbd><span class="koboSpan" id="kobo.73.1"> under the hood) and then deallocates the object from memory. </span><span class="koboSpan" id="kobo.73.2">You can't use the object anymore.</span></div>
<p><span class="koboSpan" id="kobo.74.1">You can find out more about Garbage Collector at </span><a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/"><span class="koboSpan" id="kobo.75.1">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/</span></a><span class="koboSpan" id="kobo.76.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Consider an example</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A simple </span><kbd><span class="koboSpan" id="kobo.3.1">Order</span></kbd><span class="koboSpan" id="kobo.4.1"> class can have a default, parameterized, copy constructor along with a destructor (to destroy the object):</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    class Order
    {
        public string ProductName { get; set; }
        public int Quantity { get; set; }

        public Order()
        {
           // Default Constructor
        }

        public Order(string productName, int quantity)
        {
           // Constructor with two arguments
           ProductName = productName;
           Quantity = quantity;
        }

        public Order(Order someOrder)
        {
           // Copy constructor
           ProductName = someOrder.ProductName;
           Quantity = someOrder.Quantity;
        }

        ~Order()
        {
           // Destructor or Finalizer
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.6.1">You can see how the constructors are formed using and without the parameters. </span><span class="koboSpan" id="kobo.6.2">Notice the copy constructor, which takes an object of the same class as an argument and inside the body, assigns it's properties to the object in making.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The finalizer implicitly calls </span><kbd><span class="koboSpan" id="kobo.8.1">Finalize</span></kbd><span class="koboSpan" id="kobo.9.1"> on the base class of the object. </span><span class="koboSpan" id="kobo.9.2">Therefore, when GC calls the Finalizer, that might call a method something like shown in the following:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    protected override void Finalize()
    {  
      try  
      {  
        // Cleanup statements...  
      </span><span class="koboSpan" id="kobo.10.2">}  
      finally  
      {  
         base.Finalize();  
      }  
    }</span></pre>
<p><span class="koboSpan" id="kobo.11.1">Let's verify this behavior with a code snippet inside a console app using .NET Core 2.0:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">    class BaseClass
    {
      ~BaseClass()
      {
        System.Diagnostics.Trace.WriteLine("BaseClass's destructor is called.");
      }
    }
    class DeriveClass1 : BaseClass
    {
      ~DeriveClass1()
      {
        System.Diagnostics.Trace.WriteLine("DeriveClass1's destructor</span><br/><span class="koboSpan" id="kobo.13.1">            is called.");
      }
    }

   class DeriveClass2 : DeriveClass1
   {
      public DeriveClass2()
      {
        System.Diagnostics.Trace.WriteLine("DeriveClass2's constructor is called.");
      }

      ~DeriveClass2()
      {        </span><br/><span class="koboSpan" id="kobo.14.1">         System.Diagnostics.Trace.WriteLine("DeriveClass2's destructor </span><br/><span class="koboSpan" id="kobo.15.1">          is called.");
      }
   }

   class Program
  {
    static void Main(string[] args)
    {
       DeriveClass2 t = new DeriveClass2();</span><br/><br/><span class="koboSpan" id="kobo.16.1">       // Unlike .NET Framework, .NET Core 2.0, as of now, </span><br/><span class="koboSpan" id="kobo.17.1">       // does not call GC on application termination </span><br/><span class="koboSpan" id="kobo.18.1">       // to finalise the objects.</span><br/><span class="koboSpan" id="kobo.19.1">       // So, we are trying to manually call GC</span><br/><span class="koboSpan" id="kobo.20.1">       // to see the output.</span><br/><span class="koboSpan" id="kobo.21.1">       System.GC.Collect();
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.22.1">The </span><kbd><span class="koboSpan" id="kobo.23.1">DeriveClass2</span></kbd><span class="koboSpan" id="kobo.24.1"> object is created first which logs the constructor messages. </span><span class="koboSpan" id="kobo.24.2">Then the </span><kbd><span class="koboSpan" id="kobo.25.1">DeriveClass2</span></kbd><span class="koboSpan" id="kobo.26.1"> destructor is executed. </span><span class="koboSpan" id="kobo.26.2">Thus, it is destroyed first when the </span><kbd><span class="koboSpan" id="kobo.27.1">Main</span></kbd><span class="koboSpan" id="kobo.28.1"> function execution completes. Additionally, the parent classes have destructors. </span><span class="koboSpan" id="kobo.28.2">As the child class (</span><kbd><span class="koboSpan" id="kobo.29.1">DeriveClass2</span></kbd><span class="koboSpan" id="kobo.30.1">) object is already destroyed, it runs the parent class destructors too. </span><span class="koboSpan" id="kobo.30.2">The following screenshot is taken from the output window of visual studio. </span><span class="koboSpan" id="kobo.30.3">Make sure you run the app in </span><span class="packt_screen"><span class="koboSpan" id="kobo.31.1">Release</span></span><span class="koboSpan" id="kobo.32.1"> mode:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.33.1"><img height="74" width="315" src="assets/ffc917d6-732d-47c0-b688-4056666c2f2e.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementing the IDisposable Interface</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's important to learn how to implement </span><kbd><span class="koboSpan" id="kobo.3.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.4.1"> interface as you might work with a user-defined class in your project which will deal with unmanaged resources. </span><span class="koboSpan" id="kobo.4.2">The system defines classes using unmanaged resources implement </span><kbd><span class="koboSpan" id="kobo.5.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.6.1"> and expose Dispose so that we can easily call that method to dispose of the object like we saw in the code snippet for </span><kbd><span class="koboSpan" id="kobo.7.1">SqlConnection</span></kbd><span class="koboSpan" id="kobo.8.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.9.1">There is a pattern called </span><strong><span class="koboSpan" id="kobo.10.1">Dispose Pattern</span></strong><span class="koboSpan" id="kobo.11.1">, which the developers must follow while implementing </span><kbd><span class="koboSpan" id="kobo.12.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Let's explore that. </span><span class="koboSpan" id="kobo.13.3">I will go through it step by step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Step1 -  Basic structure of class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will have an </span><kbd><span class="koboSpan" id="kobo.3.1">ExampleIDisposable</span></kbd><span class="koboSpan" id="kobo.4.1"> class which implements the </span><kbd><span class="koboSpan" id="kobo.5.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.6.1"> interface. </span><span class="koboSpan" id="kobo.6.2">I am not going to demonstrate usage of unmanaged resources, as our intention is to learn the pattern. </span><span class="koboSpan" id="kobo.6.3">I just have a console line inside the constructor telling that we are acquiring unmanaged resources.</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    class ExampleIDisposable : IDisposable
    {
        public Dictionary&lt;int, string&gt; Chapters{ get; set; }
        public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
        {
           // Managed resources
           Console.WriteLine("Managed Resources acquired");
           Chapters = chapters;

           // Some Unmanaged resources
           Console.WriteLine("Unmanaged Resources acquired");
        }

        public void Dispose()
        {
           Console.WriteLine("Someone called Dispose");

           // Dispose managed resources
           if (Chapters != null)
           {
              Chapters = null;
           }

          // Dispose unmanaged resources
        }
     }</span></pre>
<p><span class="koboSpan" id="kobo.8.1">You can see that the class contains one managed property which is initialized inside the constructor. </span><span class="koboSpan" id="kobo.8.2">We will print a line for it. </span><span class="koboSpan" id="kobo.8.3">Likewise, we might have some property using unmanaged resources declared in the class and given life by the constructor. </span><span class="koboSpan" id="kobo.8.4">Since we implemented </span><kbd><span class="koboSpan" id="kobo.9.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.10.1">, we are bound to define the only method </span><kbd><span class="koboSpan" id="kobo.11.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">For now, we just have a console line inside this.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Let's try it out:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    static void Main(string[] args)
   {
      ExampleIDisposable disposable = new ExampleIDisposable(new Dictionary&lt;int,</span><br/><span class="koboSpan" id="kobo.15.1">        string&gt; {{ 5, "Object Composition" },
                { 6, "Object Lifetime" }
        });
                        
      disposable.Dispose();
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.16.1">This produces the following output:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="102" width="285" src="assets/af3d32ed-b02a-4594-b70c-2984ed113c4d.png"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">We need to understand two important points before moving forward.</span></p>
<p><strong><span class="koboSpan" id="kobo.19.1">What happens when Finalizer is called by GC? </span></strong><span class="koboSpan" id="kobo.20.1">When an object goes out of scope, that will be added to the Finalizer queue for Garbage Collector to take action on them to release it from memory. </span><span class="koboSpan" id="kobo.20.2">And we don't know when that will happen. </span><span class="koboSpan" id="kobo.20.3">If you kill the managed resources inside </span><kbd><span class="koboSpan" id="kobo.21.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.22.1">, then we need to restrict the objects going into the finalizer queue thereby informing GC not to take action on them as they don't exist anymore. </span><span class="koboSpan" id="kobo.22.2">Also, that is an overhead for GC.</span></p>
<p><strong><span class="koboSpan" id="kobo.23.1">What if the developer forgets to call Dispose? </span></strong><span class="koboSpan" id="kobo.24.1">Suppose, the developer who is using our class does not dispose of it. </span><span class="koboSpan" id="kobo.24.2">Still, we need to handle this situation. </span><span class="koboSpan" id="kobo.24.3">We can easily do that by calling </span><kbd><span class="koboSpan" id="kobo.25.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.26.1"> inside Finalizer, but wait! </span><span class="koboSpan" id="kobo.26.2">We need to ask the </span><kbd><span class="koboSpan" id="kobo.27.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.28.1"> method to kill unmanaged resources only, not managed ones because GC is there to automatically deal with them.</span></p>
<p><span class="koboSpan" id="kobo.29.1">This is where another method comes into the picture.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Step2 - Defining a Dispose Overload method</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.4.1"> method we defined inside the class is going to help us while calling it directly through the object of the class. </span><span class="koboSpan" id="kobo.4.2">However, we need another overload of </span><kbd><span class="koboSpan" id="kobo.5.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.6.1"> inside the class which would answer the questions we previously discussed. </span><span class="koboSpan" id="kobo.6.2">Let's introduce that to our class.</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    class ExampleIDisposable : IDisposable
    {
      public Dictionary&lt;int, string&gt; Chapters { get; set; }
      public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
      {
        // Managed resources
        System.Diagnostics.Trace.WriteLine("Managed Resources acquired");
        Chapters = chapters;

        // Some Unmanaged resources
         System.Diagnostics.Trace.WriteLine("Unmanaged Resources acquired");
      }
      public void Dispose()
       {
         System.Diagnostics.Trace.WriteLine("Someone called Dispose");
         Dispose(true);
         GC.SuppressFinalize(this);
       }
       public void Dispose(bool disposeManagedResources)
        {
          if (disposeManagedResources)
          {
            if (Chapters != null)
            {
              Chapters = null;
            }

            System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
          }
          System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
        }

        ~ExampleIDisposable()
        {
          System.Diagnostics.Trace.WriteLine("Finalizer called: Managed</span><br/><span class="koboSpan" id="kobo.8.1">              resources will be cleaned");
          Dispose(false);
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.9.1">Modifications done to the </span><kbd><span class="koboSpan" id="kobo.10.1">Dispose</span></kbd><span class="koboSpan" id="kobo.11.1"> methods are explained as follows:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.12.1">public void Dispose()</span></kbd><span class="koboSpan" id="kobo.13.1">: Now, we are asking the </span><kbd><span class="koboSpan" id="kobo.14.1">Dispose(bool)</span></kbd> <span><span class="koboSpan" id="kobo.15.1">method to release all type of resources.</span></span> <kbd><span class="koboSpan" id="kobo.16.1">public void Dispose(). </span><span class="koboSpan" id="kobo.16.2">GC.SuppressFinalize(this)</span></kbd><span class="koboSpan" id="kobo.17.1">; suppresses the GC finalizer call, as we have already disposed of </span><span><span><span class="koboSpan" id="kobo.18.1">everything inside the </span><kbd><span class="koboSpan" id="kobo.19.1">Dispose(bool)</span></kbd></span></span></li>
<li><kbd><span class="koboSpan" id="kobo.20.1">public void Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.21.1">: This method is the important part of this pattern. </span><span class="koboSpan" id="kobo.21.2">With the </span><kbd><span class="koboSpan" id="kobo.22.1">bool</span></kbd><span><span class="koboSpan" id="kobo.23.1"> param, it decides whether there is a need to kill the managed resources or not</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.24.1">I have replaced the console lines with trace lines so that the </span><kbd><span class="koboSpan" id="kobo.25.1">main</span></kbd><span class="koboSpan" id="kobo.26.1"> method ends and we can see the lines on the output screen. </span><span class="koboSpan" id="kobo.26.2">If you just remove </span><kbd><span class="koboSpan" id="kobo.27.1">Console.ReadLine();</span></kbd><span class="koboSpan" id="kobo.28.1"> from the </span><kbd><span class="koboSpan" id="kobo.29.1">Main</span></kbd><span class="koboSpan" id="kobo.30.1"> method and run the app again, the output produced will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img height="173" width="421" src="assets/fd4c2965-f338-4a83-96b1-6dca53511e7c.png"/></span></div>
<p class="mce-root"><span class="koboSpan" id="kobo.32.1">Removal of the </span><kbd><span class="koboSpan" id="kobo.33.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.34.1"> calls from the </span><kbd><span class="koboSpan" id="kobo.35.1">Main</span></kbd><span class="koboSpan" id="kobo.36.1"> method that is </span><kbd><span class="koboSpan" id="kobo.37.1">disposable.Dispose();</span></kbd><span class="koboSpan" id="kobo.38.1">, will result in something as follows. </span><span class="koboSpan" id="kobo.38.2">Note to call </span><kbd><span class="koboSpan" id="kobo.39.1">GC.Collect();</span></kbd><span class="koboSpan" id="kobo.40.1"> at the end of </span><kbd><span class="koboSpan" id="kobo.41.1">Main</span></kbd><span class="koboSpan" id="kobo.42.1"> method as we did in Step 1:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.43.1"><img height="145" width="567" src="assets/3ab0882c-c4b8-412a-a457-cc9b83b35a01.png"/></span></div>
<p><span class="koboSpan" id="kobo.44.1">That means whenever developer forgets to dispose, the finalizer is called where we have called </span><kbd><span class="koboSpan" id="kobo.45.1">Dispose(false);</span></kbd><span class="koboSpan" id="kobo.46.1">, which eventually released unmanaged resources. </span><span class="koboSpan" id="kobo.46.2">Of course, finalizer will remove the managed resources automatically. </span><span class="koboSpan" id="kobo.46.3">You can see that the lines </span><span class="packt_screen"><span class="koboSpan" id="kobo.47.1">Someone called Dispose</span></span><span class="koboSpan" id="kobo.48.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.49.1">Managed Resources disposed</span></span><span class="koboSpan" id="kobo.50.1"> are missing in the last case.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Step3 -Modifying the Dispose(bool) for Derived classes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we have </span><kbd><span class="koboSpan" id="kobo.3.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.4.1"> overload, it will be available directly on the object to call. </span><span class="koboSpan" id="kobo.4.2">There is no need to expose </span><kbd><span class="koboSpan" id="kobo.5.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.6.1"> to the object for the direct call as we are internally calling it from </span><kbd><span class="koboSpan" id="kobo.7.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.8.1"> and Finalizer.</span></p>
<p><span class="koboSpan" id="kobo.9.1">The user should not pass boolean and decide what to dispose of and how. </span><span class="koboSpan" id="kobo.9.2">The only thing they will do is to call </span><kbd><span class="koboSpan" id="kobo.10.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.11.1"> which will release all type of resources. </span><span class="koboSpan" id="kobo.11.2">For that reason, we will restrict the call to </span><kbd><span class="koboSpan" id="kobo.12.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.13.1"> by changing the access specifier from </span><kbd><span class="koboSpan" id="kobo.14.1">public</span></kbd><span class="koboSpan" id="kobo.15.1"> to </span><kbd><span class="koboSpan" id="kobo.16.1">protected</span></kbd><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">The </span><kbd><span class="koboSpan" id="kobo.19.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.20.1"> is a logical block for the class which is implementing </span><kbd><span class="koboSpan" id="kobo.21.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Any class which is going to derive a base class implementing </span><kbd><span class="koboSpan" id="kobo.23.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.24.1"> might have their own custom logic for disposal. </span><span class="koboSpan" id="kobo.24.2">So, instead of adding another dispose method, they can just override the base class </span><kbd><span class="koboSpan" id="kobo.25.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">To make that happen, we need to prepend a </span><kbd><span class="koboSpan" id="kobo.27.1">virtual</span></kbd><span class="koboSpan" id="kobo.28.1"> keyword before the method name.</span></p>
<p><span class="koboSpan" id="kobo.29.1">The preceding paragraphs call for a modification of our very well known method </span><kbd><span class="koboSpan" id="kobo.30.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.31.1">:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">    protected virtual void Dispose(bool disposeManagedResources)
    {
      if (disposeManagedResources)
      {
        if (Chapters != null)
        {
           Chapters = null;
        }
        System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
      }
      System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Step 4 - Handling duplicate Dispose calls</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We should manage the scenario where the user might call Dispose more than once. </span><span class="koboSpan" id="kobo.2.2">If we don't tackle this situation, the subsequent calls will just be unnecessary executions for the runtime because the runtime will try to release an object which has been already disposed of.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We can easily put a flag inside the class which will indicate whether the object was disposed or not.</span></p>
<pre><span class="koboSpan" id="kobo.4.1">    bool disposed = false;
    protected virtual void Dispose(bool disposeManagedResources)
    {
      if (disposed)
      {
        System.Diagnostics.Trace.WriteLine("Dispose(bool) already called");
         return;
      }
      if (disposeManagedResources)
        {
          if (Chapters != null)
          {
             Chapters = null;
          }
          System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
       }
       System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
       disposed = true;
     }</span></pre>
<p><span class="koboSpan" id="kobo.5.1">Notice the </span><kbd><span class="koboSpan" id="kobo.6.1">disposed</span></kbd><span class="koboSpan" id="kobo.7.1"> variable, which is used inside </span><kbd><span class="koboSpan" id="kobo.8.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">We are checking if that is true inside the method. </span><span class="koboSpan" id="kobo.9.3">If true, then we return/exit from the method, otherwise execute the disposal codes. </span><span class="koboSpan" id="kobo.9.4">At last, we set it as true. </span><span class="koboSpan" id="kobo.9.5">So, for the first time </span><kbd><span class="koboSpan" id="kobo.10.1">Dispose(bool)</span></kbd><span class="koboSpan" id="kobo.11.1"> is going to execute fully, after that, it will just return once called. </span><span class="koboSpan" id="kobo.11.2">This way, we are preventing disposing of the same object many times which is an overhead.</span></p>
<p><span class="koboSpan" id="kobo.12.1">Let's modify the code to call </span><kbd><span class="koboSpan" id="kobo.13.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.14.1"> multiple times:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    disposable.Dispose();
    disposable.Dispose();
    disposable.Dispose();</span></pre>
<p><span class="koboSpan" id="kobo.16.1">This would give us the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="172" width="281" src="assets/ac96fa07-23c1-4416-9e2f-fb32c5d50b49.png"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">You can see, for the first call, everything works as expected. </span><span class="koboSpan" id="kobo.18.2">The the next two subsequent Dispose() calls for the same object results in a simple return from the method. </span><span class="koboSpan" id="kobo.18.3">That is why we see two sets of </span><span class="packt_screen"><span class="koboSpan" id="kobo.19.1">Someone called Dispose</span></span><span class="koboSpan" id="kobo.20.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.21.1">Dispose(bool) already called</span></span><span class="koboSpan" id="kobo.22.1"> messages.</span></p>
<p><span class="koboSpan" id="kobo.23.1">Alright, I would like to show you the final code after all these steps:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    class ExampleIDisposable : IDisposable
    {
        public Dictionary&lt;int, string&gt; Chapters { get; set; }
        bool disposed = false;

        public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
        {
            // Managed resources
            System.Diagnostics.Trace.WriteLine("Managed Resources acquired");
            Chapters = chapters;

            // Some Unmanaged resources
            System.Diagnostics.Trace.WriteLine("Unmanaged Resources acquired");
        }

        public void Dispose()
        {
           System.Diagnostics.Trace.WriteLine("Someone called Dispose");

           Dispose(true);
           GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposeManagedResources)
        {
           if (disposed)
           {
               System.Diagnostics.Trace.WriteLine("Dispose(bool) already called");
               return;
           }

           if (disposeManagedResources)
           {
              if (Chapters != null)
              {
                 Chapters = null;
              }
              System.Diagnostics.Trace.WriteLine("Managed Resources</span><br/><span class="koboSpan" id="kobo.25.1">                  disposed");
           }

           System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
           disposed = true;
        }

        ~ExampleIDisposable()
        {
          System.Diagnostics.Trace.WriteLine("Finalizer called: Managed </span><br/><span class="koboSpan" id="kobo.26.1">                resources will be cleaned");
          Dispose(false);
        }
      }</span></pre>
<p><span class="koboSpan" id="kobo.27.1">Don't forget that you can use the </span><kbd><span class="koboSpan" id="kobo.28.1">using</span></kbd><span class="koboSpan" id="kobo.29.1"> statement with any class which implements </span><kbd><span class="koboSpan" id="kobo.30.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">For instance, let's write that for </span><kbd><span class="koboSpan" id="kobo.32.1">ExampleIDisposable</span></kbd><span class="koboSpan" id="kobo.33.1">:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">    using (ExampleIDisposable disposable = 
        new ExampleIDisposable(new Dictionary&lt;int, string&gt; {
        { 5, "Object Composition" },
        { 6, "Object Lifetime" }
        }))
    {
      // Do something with the "disposable" object.
    </span><span class="koboSpan" id="kobo.34.2">}</span></pre>
<p><span class="koboSpan" id="kobo.35.1">If you run this, it would produce the same result as shown in the first screenshot under </span><em><span class="koboSpan" id="kobo.36.1">Step 2: Defining a Dispose Overload method </span></em><span class="koboSpan" id="kobo.37.1">section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object lifetime management in .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In previous chapters, we have already explored how Dependency Injection is built into .NET Core. </span><span class="koboSpan" id="kobo.2.2">Now that we learned how objects are managed by .NET Framework, let's shed some light on their lifestyle in .NET Core.</span></p>
<p><span class="koboSpan" id="kobo.3.1">With just one line, I can say, in Startup, .NET Core takes one class, tags a lifetime to it as specified in code, then instantiates and stores it in the container or service collection. </span><span class="koboSpan" id="kobo.3.2">Consider the following screenshot: </span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img height="222" width="262" src="assets/663079d7-0bb5-478d-a787-557867ec8ef7.png"/></span></div>
<p><span class="koboSpan" id="kobo.5.1">We will be covering how the following is addressed in .NET Core:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Object Creation.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Object's Lifestyles.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Object's Disposal after everything is done.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object creation</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Typically in ASP.NET Core 2.0, an injected type is called a </span><strong><span class="koboSpan" id="kobo.3.1">service</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">For example, the injected interface is called as </span><kbd><span class="koboSpan" id="kobo.5.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.6.1"> and we can add services, as we need, by using the </span><kbd><span class="koboSpan" id="kobo.7.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.8.1"> method here. </span><span class="koboSpan" id="kobo.8.2">We will learn more about it soon:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    public void ConfigureServices(IServiceCollection services)
    {
      services.AddMvc();
      services.AddSingleton&lt;IExampleService, ExampleService&gt;();
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.10.1">The built-in DI framework in ASP.NET Core performs two important steps when we perform the preceding code:</span></p>
<ul>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.11.1">Instantiation:</span></strong><span class="koboSpan" id="kobo.12.1"> The object of the provided service (example: </span><kbd><span class="koboSpan" id="kobo.13.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.14.1">) is instantiated so that it can be made available to controllers when they are called. </span><span class="koboSpan" id="kobo.14.2">The object gets injected through constructor injection or property injection. </span><kbd><span class="koboSpan" id="kobo.15.1">IExampleService</span></kbd><span class="koboSpan" id="kobo.16.1"> will be an argument to the controller. </span><span class="koboSpan" id="kobo.16.2">The implementer of this interface </span><kbd><span class="koboSpan" id="kobo.17.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.18.1"> can be instantiated and injected. </span><span class="koboSpan" id="kobo.18.2">We will see the constructor in a while.</span></li>
<li><strong><span class="koboSpan" id="kobo.19.1">Lifetime Management:</span></strong><span class="koboSpan" id="kobo.20.1"> Then it decides the lifetime (creation and disposal) of the object injected to the controller. </span><span class="koboSpan" id="kobo.20.2">There are different types of lifestyles served by the framework, which we will learn next.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">Let's explore the three-lifetime modes served by </span><em><span class="koboSpan" id="kobo.22.1">ASP.NET Core</span></em><span class="koboSpan" id="kobo.23.1"> by default. </span><span class="koboSpan" id="kobo.23.2">The following is a quick reference table for these lifestyles:</span></p>
<table>
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.24.1">Lifestyle</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.25.1">Description</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.26.1">Disposal</span></strong></td>
</tr>
<tr>
<td>
<p class="mce-root"><span class="koboSpan" id="kobo.27.1">Transient (</span><span><span class="_Yht"><span class="koboSpan" id="kobo.28.1">temporary or</span></span><span class="koboSpan" id="kobo.29.1"> </span></span><span><span class="_Yht"><span class="koboSpan" id="kobo.30.1">short-lived</span></span></span><span class="koboSpan" id="kobo.31.1">)</span></p>
</td>
<td><span class="koboSpan" id="kobo.32.1">A new instance will be created each time the service is requested.</span></td>
<td><span class="koboSpan" id="kobo.33.1">Never</span></td>
</tr>
<tr>
<td>
<p class="mce-root"><span class="koboSpan" id="kobo.34.1">Scoped (extent or ranged)</span></p>
</td>
<td><span class="koboSpan" id="kobo.35.1">An instance will be created for a defined scope. </span><span class="koboSpan" id="kobo.35.2">When </span><span class="packt_screen"><span class="koboSpan" id="kobo.36.1">out of scope</span></span><span class="koboSpan" id="kobo.37.1"> is reached, another instance will be created, if requested. </span><span class="koboSpan" id="kobo.37.2">A simple scope can be stated as one </span><kbd><span class="koboSpan" id="kobo.38.1">Web Request</span></kbd><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Any resource, requesting the instance in a particular </span><kbd><span class="koboSpan" id="kobo.40.1">Web Request</span></kbd><span class="koboSpan" id="kobo.41.1"> will be served the same from the container.</span></td>
<td><span class="koboSpan" id="kobo.42.1">Disposed when the scope ends</span></td>
</tr>
<tr>
<td>
<p class="mce-root"><span class="koboSpan" id="kobo.43.1">Singleton (single or individual)</span></p>
</td>
<td><span class="koboSpan" id="kobo.44.1">One instance created by the container which will be used/shared throughout the app for every request.</span></td>
<td><span class="koboSpan" id="kobo.45.1">Disposed when the container is disposed</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.46.1"> </span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.47.1">We will look at each concept in detail now. </span><span class="koboSpan" id="kobo.47.2">Don't worry, if you are confused after reading this. </span><span class="koboSpan" id="kobo.47.3">After a well-designed example, you will definitely get the concept.</span></p>
<p><span class="koboSpan" id="kobo.48.1">First of all, let's design our ASP.NET MVC Core app to use all these kinds of lifetimes. </span><span class="koboSpan" id="kobo.48.2">This example is similar to that given in the official documentation, which can be found at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection"><span class="koboSpan" id="kobo.49.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</span></a><span class="koboSpan" id="kobo.50.1">.</span></p>
<p><span class="koboSpan" id="kobo.51.1">The main goal here is to understand how the instances stay during the incoming requests. </span><span class="koboSpan" id="kobo.51.2">We will investigate the instances from two places: one from a controller and another from a class. </span><span class="koboSpan" id="kobo.51.3">Both these guys will use the same interfaces as dependencies injected to their constructors. </span><span class="koboSpan" id="kobo.51.4">Let's go through things step by step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Designing the interfaces</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First code an interface </span><kbd><span class="koboSpan" id="kobo.3.1">IExampleService</span></kbd><span class="koboSpan" id="kobo.4.1"> with a </span><kbd><span class="koboSpan" id="kobo.5.1">Guid</span></kbd><span class="koboSpan" id="kobo.6.1"> type property </span><kbd><span class="koboSpan" id="kobo.7.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Then write four interfaces implementing this interface. </span><span class="koboSpan" id="kobo.8.3">We have named them according to a different type of lifetimes so that we can easily recognize them afterward:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    public interface IExampleService
    {
      Guid ExampleId { get; }
    }

    public interface IExampleTransient : IExampleService
    {
    }
    public interface IExampleScoped : IExampleService
    {
    }
    public interface IExampleSingleton : IExampleService
    {
    }
    public interface IExampleSingletonInstance : IExampleService
    {
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Concrete class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Abstract which means something which can be conceptualized whereas concrete means something which exists in reality and not abstract. </span><span class="koboSpan" id="kobo.2.2">Suppose we consider three Shapes like a circle, a rectangle, and a square. </span><span class="koboSpan" id="kobo.2.3">The shape seems like a concept, doesn't it? </span><span class="koboSpan" id="kobo.2.4">On the other hand</span><span><span class="koboSpan" id="kobo.3.1"> a circle, a rectangle, and a square</span></span><span class="koboSpan" id="kobo.4.1"> actually have the behavior of shape to represent a concrete idea. </span><span class="koboSpan" id="kobo.4.2">An Abstract class is incomplete in nature and when a class takes (or inherits) its behavior, it becomes complete which is denoted as </span><strong><span class="koboSpan" id="kobo.5.1">Concrete</span></strong><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Thus, Abstract (or incomplete) concept is meant to be completed by other classes inheriting it, forming </span><em><span class="koboSpan" id="kobo.8.1">Concrete Classes</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">An Abstract class is incomplete and just a concept, so instantiating it becomes meaningless. </span><span class="koboSpan" id="kobo.9.3">Shape, for instance, is not meant to be instantiated, rather it's meant to be inherited by actual shape classes. </span><span class="koboSpan" id="kobo.9.4">The following diagram shows the relationship:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img height="163" width="233" src="assets/36b8337a-1d81-4ff2-9ace-c1d5a66d9050.png"/></span></div>
<p><span class="koboSpan" id="kobo.11.1">A single </span><kbd><span class="koboSpan" id="kobo.12.1">Example</span></kbd><span class="koboSpan" id="kobo.13.1"> class implements all these interfaces and defines the </span><kbd><span class="koboSpan" id="kobo.14.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.15.1"> guid. </span><span class="koboSpan" id="kobo.15.2">Two constructors are there: one which takes the </span><kbd><span class="koboSpan" id="kobo.16.1">Guid</span></kbd><span class="koboSpan" id="kobo.17.1"> as a param and the other one is the default which initializes a new guid. </span><span class="koboSpan" id="kobo.17.2">All those interfaces will be resolved as this class in </span><em><span class="koboSpan" id="kobo.18.1">Startup</span></em><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">We are approaching that code soon:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    using LifetimesExample.Interfaces;</span><br/><span class="koboSpan" id="kobo.21.1">    using System;

    namespace LifetimesExample.Models
   {
      public class Example : IExampleScoped, IExampleSingleton, </span><br/><span class="koboSpan" id="kobo.22.1">         IExampleTransient, IExampleSingletonInstance
      {
        public Guid ExampleId { get; set; }
        public Example()
        {
          ExampleId = Guid.NewGuid();
        }
        public Example(Guid exampleId)
        {
          ExampleId = exampleId;
        }
      }
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Service class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we said to have a simple class using these interfaces, here is that class called as </span><kbd><span class="koboSpan" id="kobo.3.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We have a constructor here, which is waiting for the interfaces to be injected and assigned to local interface type variables.</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    using LifetimesExample.Interfaces;</span><br/><span class="koboSpan" id="kobo.6.1">    namespace LifetimesExample.Services
    {
    public class ExampleService
    {
        public IExampleTransient TransientExample { get; }
        public IExampleScoped ScopedExample { get; }
        public IExampleSingleton SingletonExample { get; }
        public IExampleSingletonInstance SingletonInstanceExample { get; }

        public ExampleService(IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample,
            IExampleSingletonInstance instanceExample)
        {
            TransientExample = transientExample;
            ScopedExample = scopedExample;
            SingletonExample = singletonExample;
            SingletonInstanceExample = instanceExample;
        }
      }
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The controller</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The controller is almost the same as the service class with an additional reference of </span><kbd><span class="koboSpan" id="kobo.3.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">It has a constructor to initialize them. </span><span class="koboSpan" id="kobo.4.3">The properties of </span><kbd><span class="koboSpan" id="kobo.5.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.6.1"> will be printed on a view, that's why we are referring to that class:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    using Microsoft.AspNetCore.Mvc;</span><br/><span class="koboSpan" id="kobo.8.1">    using LifetimesExample.Services;</span><br/><span class="koboSpan" id="kobo.9.1">    using LifetimesExample.Interfaces;

    namespace LifetimesExample.Controllers
    {
      public class ExampleController : Controller
      {
        private readonly ExampleService _exampleService;
        private readonly IExampleTransient _transientExample;
        private readonly IExampleScoped _scopedExample;
        private readonly IExampleSingleton _singletonExample;
        private readonly IExampleSingletonInstance _singletonInstanceExample;

        public ExampleController(ExampleService ExampleService,
            IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample,
            IExampleSingletonInstance singletonInstanceExample)
        {
            _exampleService = ExampleService;
            _transientExample = transientExample;
            _scopedExample = scopedExample;
            _singletonExample = singletonExample;
            _singletonInstanceExample = singletonInstanceExample;
        }

        public IActionResult Index()
        {
            // viewbag contains controller-requested services
            ViewBag.Transient = _transientExample;
            ViewBag.Scoped = _scopedExample;
            ViewBag.Singleton = _singletonExample;
            ViewBag.SingletonInstance = _singletonInstanceExample;

            // Example service has its own requested services
            ViewBag.Service = _exampleService;

            return View();
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.10.1">Inside </span><kbd><span class="koboSpan" id="kobo.11.1">Index()</span></kbd><span class="koboSpan" id="kobo.12.1"> action, we are returning all these values in </span><kbd><span class="koboSpan" id="kobo.13.1">ViewBag</span></kbd><span class="koboSpan" id="kobo.14.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">View</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Last, but not least, we will simply design a view which can show all these values so that we can start our observation. </span><span class="koboSpan" id="kobo.2.2">This would be </span><kbd><span class="koboSpan" id="kobo.3.1">Index.cshtml</span></kbd><span class="koboSpan" id="kobo.4.1"> inside </span><kbd><span class="koboSpan" id="kobo.5.1">Views/Example</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.7.1">    @using LifetimesExample.Interfaces</span><br/><span class="koboSpan" id="kobo.8.1">    @using LifetimesExample.Services</span><br/><br/><span class="koboSpan" id="kobo.9.1">    @{</span><br/><span class="koboSpan" id="kobo.10.1">      ViewData["Title"] = "Index";</span><br/><span class="koboSpan" id="kobo.11.1">     }</span><br/><br/><span class="koboSpan" id="kobo.12.1">    @{</span><br/><span class="koboSpan" id="kobo.13.1">      IExampleTransient transient = (IExampleTransient)ViewData["Transient"];</span><br/><span class="koboSpan" id="kobo.14.1">      IExampleTransient scoped = (IExampleTransient)ViewData["Scoped"];</span><br/><span class="koboSpan" id="kobo.15.1">      IExampleTransient singleton = (IExampleTransient)ViewData["Singleton"];</span><br/><span class="koboSpan" id="kobo.16.1">      IExampleTransient singletonInstance = (IExampleTransient)ViewData["SingletonInstance"];</span><br/><span class="koboSpan" id="kobo.17.1">      ExampleService service = (ExampleService)ViewBag.Service;</span><br/><span class="koboSpan" id="kobo.18.1">    }</span><br/><br/><span class="koboSpan" id="kobo.19.1">    &lt;h2&gt;Lifetimes&lt;/h2&gt;</span><br/><br/><span class="koboSpan" id="kobo.20.1">    &lt;h3&gt;ExampleController Dependencies&lt;/h3&gt;</span><br/><span class="koboSpan" id="kobo.21.1">    &lt;table&gt;</span><br/><span class="koboSpan" id="kobo.22.1">     &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.23.1">        &lt;th&gt;Lifestyle&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.24.1">        &lt;th&gt;Guid Value&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.25.1">     &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.26.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.27.1">        &lt;td&gt;Transient&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.28.1">        &lt;td&gt;@transient.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.29.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.30.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.31.1">        &lt;td&gt;Scoped&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.32.1">        &lt;td&gt;@scoped.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.33.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.34.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.35.1">        &lt;td&gt;Singleton&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.36.1">        &lt;td&gt;@singleton.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.37.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.38.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.39.1">        &lt;td&gt;Instance&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.40.1">        &lt;td&gt;@singletonInstance.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.41.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.42.1">   &lt;/table&gt;</span><br/><br/><span class="koboSpan" id="kobo.43.1">   &lt;h3&gt;ExampleService Dependencies&lt;/h3&gt;</span><br/><span class="koboSpan" id="kobo.44.1">   &lt;table&gt;</span><br/><span class="koboSpan" id="kobo.45.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.46.1">        &lt;th&gt;Lifestyle&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.47.1">        &lt;th&gt;Guid Value&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.48.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.49.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.50.1">        &lt;td&gt;Transient&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.51.1">        &lt;td&gt;@service.TransientExample.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.52.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.53.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.54.1">        &lt;td&gt;Scoped&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.55.1">        &lt;td&gt;@service.ScopedExample.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.56.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.57.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.58.1">        &lt;td&gt;Singleton&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.59.1">        &lt;td&gt;@service.SingletonExample.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.60.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.61.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.62.1">        &lt;td&gt;Instance&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.63.1">        &lt;td&gt;@service.SingletonInstanceExample.ExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.64.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.65.1">  &lt;/table&gt;</span></pre>
<p><span class="koboSpan" id="kobo.66.1">Finally, we completed the codes. </span><span class="koboSpan" id="kobo.66.2">Are you sure? </span><span class="koboSpan" id="kobo.66.3">We forgot the main entry point. </span><span class="koboSpan" id="kobo.66.4">The one which decides what class will be resolved against which interface.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Startup ConfigureServices</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now each type of lifestyle is added to the container resolved using </span><kbd><span class="koboSpan" id="kobo.3.1">Example</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">The class </span><kbd><span class="koboSpan" id="kobo.5.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.6.1"> is resolved for itself. </span><span class="koboSpan" id="kobo.6.2">That means, whenever we need </span><kbd><span class="koboSpan" id="kobo.7.1">ExampleService</span></kbd><span class="koboSpan" id="kobo.8.1"> anywhere in the app, to be injected, it will automatically assign an object of that class with all its properties:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    public void ConfigureServices(IServiceCollection services)
    {
        // Add framework services.
        </span><span class="koboSpan" id="kobo.9.2">services.AddMvc();

        services.AddTransient&lt;IExampleTransient, Example&gt;();
        services.AddScoped&lt;IExampleScoped, Example&gt;();
        services.AddSingleton&lt;IExampleSingleton, Example&gt;();</span><br/><span class="koboSpan" id="kobo.10.1">        services.AddSingleton&lt;IExampleSingletonInstance, Example&gt;();
        services.AddSingleton(new Example(Guid.Empty));
        services.AddTransient&lt;ExampleService, ExampleService&gt;();
    }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.11.1">Add***</span></kbd><span class="koboSpan" id="kobo.12.1"> methods (with different lifestyles) make sure that the objects are created according to the desired behavior expected from them. </span><span class="koboSpan" id="kobo.12.2">Once these objects are initialized, they can be injected where ever required.</span></p>
<p><span class="koboSpan" id="kobo.13.1">If we run the app now, for the first request, we will get the following output:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="470" width="352" src="assets/9a77645f-5f93-4b86-9e98-17f9d68cf2aa.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">I opened the page in another tab (or you can just refresh the tab). </span><span class="koboSpan" id="kobo.15.2">I saw the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img height="439" width="356" src="assets/eed82ac7-6517-4824-90c6-44afd3b3ed53.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object lifetimes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's examine all the lifetimes one by one according to the values we see in these screenshots. </span><span class="koboSpan" id="kobo.2.2">The values help us recognize the objects.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Singleton</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Looking at the screenshots and diagrams, the first thing which is clearly seen is the </span><kbd><span class="koboSpan" id="kobo.3.1">Singleton</span></kbd><span class="koboSpan" id="kobo.4.1"> one. </span><span class="koboSpan" id="kobo.4.2">No matter how many requests you do after running the app, the object will be the same. </span><span class="koboSpan" id="kobo.4.3">It does not depend upon the Controller or the </span><kbd><span class="koboSpan" id="kobo.5.1">Service</span></kbd><span class="koboSpan" id="kobo.6.1"> class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Scoped</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For a particular request, the object is same throughout the scope. </span><span class="koboSpan" id="kobo.2.2">Notice how the object's guid value is different in the second request. </span><span class="koboSpan" id="kobo.2.3">However, the values are same for Controller and </span><kbd><span class="koboSpan" id="kobo.3.1">Service</span></kbd><span class="koboSpan" id="kobo.4.1"> class in both the requests. </span><span class="koboSpan" id="kobo.4.2">Here the scope is the web request. </span><span class="koboSpan" id="kobo.4.3">When one more request is served, the object is recreated.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Creating a scope in code is possible though. </span><span class="koboSpan" id="kobo.5.2">There is an interface called </span><kbd><span class="koboSpan" id="kobo.6.1">IServiceScopeFactory</span></kbd><span class="koboSpan" id="kobo.7.1"> which exposes the method </span><kbd><span class="koboSpan" id="kobo.8.1">CreateScope</span></kbd><span class="koboSpan" id="kobo.9.1">. </span><kbd><span class="koboSpan" id="kobo.10.1">CreateScope</span></kbd><span class="koboSpan" id="kobo.11.1"> is of the type </span><kbd><span class="koboSpan" id="kobo.12.1">IServiceScope</span></kbd><span class="koboSpan" id="kobo.13.1">, which implements </span><kbd><span class="koboSpan" id="kobo.14.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">Here the </span><kbd><span class="koboSpan" id="kobo.16.1">using</span></kbd><span class="koboSpan" id="kobo.17.1"> block comes to our rescue for disposal of the scoped instance:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">    var serviceProvider = services.BuildServiceProvider();
    var serviceScopeFactory = serviceProvider.GetRequiredService&lt;</span><br/><span class="koboSpan" id="kobo.19.1">          IServiceScopeFactory&gt;();

    IExampleScoped scopedOne;
    IExampleScoped scopedTwo;

    using (var scope = serviceScopeFactory.CreateScope())
    {
      scopedOne = scope.ServiceProvider.GetService&lt;IExampleScoped&gt;();
    }
    using (var scope = serviceScopeFactory.CreateScope())
    {
     scopedTwo = scope.ServiceProvider.GetService&lt;IExampleScoped&gt;();
    }</span></pre>
<p><span class="koboSpan" id="kobo.20.1">We created two scoped instances in the preceding code using </span><kbd><span class="koboSpan" id="kobo.21.1">CreateScope</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Both are independent of each other and are not shared within a request like a normal scoped instance. </span><span class="koboSpan" id="kobo.22.3">That is because we manually assigned the scope instead of the default Web Request scope.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Transient</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Simple! </span><span class="koboSpan" id="kobo.2.2">A new object is always created whenever requested from the container. </span><span class="koboSpan" id="kobo.2.3">In the screenshot, you can see the guid values are different in the Controller and the </span><kbd><span class="koboSpan" id="kobo.3.1">Service</span></kbd><span class="koboSpan" id="kobo.4.1"> class even for a single request.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Instance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last one is a special case of Singleton, where the user creates the object and provides that to the </span><kbd><span class="koboSpan" id="kobo.3.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.4.1"> method. </span><span class="koboSpan" id="kobo.4.2">So, we are explicitly creating the object of the </span><kbd><span class="koboSpan" id="kobo.5.1">Example</span></kbd><span class="koboSpan" id="kobo.6.1"> class ( </span><kbd><span class="koboSpan" id="kobo.7.1">services.AddSingleton(new Example(Guid.Empty))</span></kbd><span class="koboSpan" id="kobo.8.1">) and asking DI framework to register it as a Singleton. </span><span class="koboSpan" id="kobo.8.2">In this case, we are sending </span><kbd><span class="koboSpan" id="kobo.9.1">Guid.Empty</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">Thus, an empty guid is assigned which stays unchanged for all requests.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Object disposal</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When we register a service directly with the </span><kbd><span class="koboSpan" id="kobo.3.1">Add***</span></kbd><span class="koboSpan" id="kobo.4.1"> method, the container is responsible for creating the object and managing the lifetime. </span><span class="koboSpan" id="kobo.4.2">Essentially, it calls </span><kbd><span class="koboSpan" id="kobo.5.1">Dispose</span></kbd><span class="koboSpan" id="kobo.6.1"> for the objects, which implement </span><kbd><span class="koboSpan" id="kobo.7.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.8.1"> according to the lifetime.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Consider the following example where </span><kbd><span class="koboSpan" id="kobo.10.1">ServiceDisposable</span></kbd><span class="koboSpan" id="kobo.11.1"> implements </span><kbd><span class="koboSpan" id="kobo.12.1">IDisposable</span></kbd><span class="koboSpan" id="kobo.13.1"> and we told services to manage its lifetime as </span><kbd><span class="koboSpan" id="kobo.14.1">Scoped</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">Therefore, it will create the instance, then make it available across all resources in the app for a single request. </span><span class="koboSpan" id="kobo.15.3">At last, it disposes of it when the request ends:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    public class ServiceDisposable : IDisposable {}
    public void ConfigureServices(IServiceCollection services)
    {
      services.AddScoped(ServiceDisposable);
    }</span></pre>
<p><span class="koboSpan" id="kobo.17.1">However, when we create the object explicitly and provide that to the DI, we need to handle it's disposal our self. </span><span class="koboSpan" id="kobo.17.2">In the following case, we have to manually call </span><kbd><span class="koboSpan" id="kobo.18.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.19.1"> somewhere to dispose the instance:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    public class ServiceDisposable : IDisposable {}
    public void ConfigureServices(IServiceCollection services)
    {
      services.AddScoped(new ServiceDisposable());
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">When to choose what?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's important how we deal with different objects in our application so that they consume limited memory space and resources, yet optimize the performance.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Objects which require more space and utilize large server resources should not be recreated, rather they should be reused. </span><span class="koboSpan" id="kobo.3.2">Database objects, for instance, should be reused for all the requests which follow a </span><kbd><span class="koboSpan" id="kobo.4.1">Singleton</span></kbd><span class="koboSpan" id="kobo.5.1"> pattern.</span></li>
<li><span class="koboSpan" id="kobo.6.1">Operations which runs in a batch or a loop can be reused in a particular request but should be recreated for another. </span><span class="koboSpan" id="kobo.6.2">That indicates a Scoped lifetime.</span></li>
<li><span class="koboSpan" id="kobo.7.1">The </span><kbd><span class="koboSpan" id="kobo.8.1">Model</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">View Model</span></kbd><span class="koboSpan" id="kobo.11.1"> classes should be instantiated every time we try to form them. </span><span class="koboSpan" id="kobo.11.2">We can't reuse a Model class object while doing a CRUD operation, else we might end up with the wrong values going into the database. </span><span class="koboSpan" id="kobo.11.3">Of course, that is </span><kbd><span class="koboSpan" id="kobo.12.1">Transient</span></kbd><span class="koboSpan" id="kobo.13.1"> as it lives for a short period of time.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Relationship and dependencies among lifetimes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we will dig more to find out the relation between the lifetimes. </span><span class="koboSpan" id="kobo.2.2">The reason is pretty clear. </span><span class="koboSpan" id="kobo.2.3">While instantiating our classes with a different type of lifestyle, we might face situations where we need dependency of one class in another class. </span><span class="koboSpan" id="kobo.2.4">But the catch here is that they may not be following a similar lifestyle. </span><span class="koboSpan" id="kobo.2.5">So, what happens to the instance which is following a scoped lifestyle referred inside a </span><kbd><span class="koboSpan" id="kobo.3.1">Singleton</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">Does that behave as Scoped?</span></p>
<p><span class="koboSpan" id="kobo.5.1">Let's get our hands dirty and do some code modifications to inject dependencies into one another.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Singleton depending on Scoped and Transient</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First, we need to add two new properties to the existing </span><kbd><span class="koboSpan" id="kobo.3.1">IExampleSingleton</span></kbd><span class="koboSpan" id="kobo.4.1"> interface:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    public interface IExampleSingleton : IExampleService
    {
        Guid ScopedExampleId { get; }
        Guid TransientExampleId { get; }
   }</span></pre>
<p><span class="koboSpan" id="kobo.6.1">Next, we want to design a new class explicitly for all lifestyles. </span><span class="koboSpan" id="kobo.6.2">As we have planned, let's inject Transient and Scoped dependencies into this </span><kbd><span class="koboSpan" id="kobo.7.1">Singleton</span></kbd><span class="koboSpan" id="kobo.8.1"> class through the constructor. </span><span class="koboSpan" id="kobo.8.2">The properties defined for dependent lifestyles are assigned values accordingly from the arguments.</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    using System;
    namespace LifetimesExample
    {
      public class ExampleSingleton : IExampleSingleton
      {
        public Guid ExampleId { get; set; }
        public Guid ScopedExampleId { get; set; }
        public Guid TransientExampleId { get; set; }

        public ExampleSingleton(IExampleTransient transient, IExampleScoped scoped)
        {
            ExampleId = Guid.NewGuid();
            ScopedExampleId = scoped.ExampleId;
            TransientExampleId = transient.ExampleId;
        }
      }
      public class ExampleScoped : IExampleScoped
      {
        public Guid ExampleId { get; set; }

        public ExampleScoped()
        {
            ExampleId = Guid.NewGuid();
        }
      }
      public class ExampleTransient : IExampleTransient
      {
        public Guid ExampleId { get; set; }

        public ExampleTransient()
        {
            ExampleId = Guid.NewGuid();
        }
       }
     }</span></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.10.1">I have</span><span><span class="koboSpan" id="kobo.11.1"> defined</span></span><span class="koboSpan" id="kobo.12.1"> all classes in a single place just for the readability purposes of this book. </span><span class="koboSpan" id="kobo.12.2">You should ideally add them in different files every time.</span></div>
<p><span class="koboSpan" id="kobo.13.1">The controller is the next place where we need to have an action which will return the view where we will show the values.</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    using Microsoft.AspNetCore.Mvc;
    namespace LifetimesExample.Controllers
    {
      public class ExampleController : Controller
      {
        private readonly ExampleService _exampleService;
        private readonly IExampleTransient _transientExample;
        private readonly IExampleScoped _scopedExample;
        private readonly IExampleSingleton _singletonExample;

        public ExampleController(ExampleService ExampleService,
            IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample)
        {
            _exampleService = ExampleService;
            _transientExample = transientExample;
            _scopedExample = scopedExample;
            _singletonExample = singletonExample;
        }

        public IActionResult SingletonDependencies()
        {
            ViewBag.Singleton = _singletonExample;

            ViewBag.Service = _exampleService;

            return View("Singleton");
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.15.1">It's similar to what we have done with the </span><kbd><span class="koboSpan" id="kobo.16.1">Index</span></kbd><span class="koboSpan" id="kobo.17.1"> action. </span><span class="koboSpan" id="kobo.17.2">The difference is that we have removed the </span><kbd><span class="koboSpan" id="kobo.18.1">SingletonInstance</span></kbd><span class="koboSpan" id="kobo.19.1"> reference and returned a view called as </span><kbd><span class="koboSpan" id="kobo.20.1">Singleton</span></kbd><span class="koboSpan" id="kobo.21.1">.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The view would look something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">  @{</span><br/><span class="koboSpan" id="kobo.24.1">    ViewData["Title"] = "Index";</span><br/><span class="koboSpan" id="kobo.25.1">  }</span><br/><br/><span class="koboSpan" id="kobo.26.1">  @{</span><br/><span class="koboSpan" id="kobo.27.1">    IExampleSingleton singleton = (IExampleSingleton)ViewData["Singleton"];</span><br/><span class="koboSpan" id="kobo.28.1">    ExampleService service = (ExampleService)ViewBag.Service;</span><br/><span class="koboSpan" id="kobo.29.1">  }</span><br/><span class="koboSpan" id="kobo.30.1">  &lt;h2&gt;Singleton Lifetime Dependencies&lt;/h2&gt;</span><br/><br/><span class="koboSpan" id="kobo.31.1">  &lt;h3&gt;ExampleController&lt;/h3&gt;</span><br/><br/><span class="koboSpan" id="kobo.32.1">  &lt;h5&gt;&lt;u&gt;Singleton ExampleId: @singleton.ExampleId&lt;/u&gt;&lt;/h5&gt;</span><br/><br/><span class="koboSpan" id="kobo.33.1">  &lt;table&gt;</span><br/><span class="koboSpan" id="kobo.34.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.35.1">        &lt;th&gt;Dependencies&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.36.1">        &lt;th&gt;Guid Value&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.37.1">    &lt;/tr&gt;</span><br/><br/><span class="koboSpan" id="kobo.38.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.39.1">        &lt;td&gt;Scoped Dependency&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.40.1">        &lt;td&gt;@singleton.ScopedExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.41.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.42.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.43.1">        &lt;td&gt;Transient Dependency&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.44.1">        &lt;td&gt;@singleton.TransientExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.45.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.46.1">  &lt;/table&gt;</span><br/><br/><span class="koboSpan" id="kobo.47.1">  &lt;h3&gt;ExampleService&lt;/h3&gt;</span><br/><br/><span class="koboSpan" id="kobo.48.1">  &lt;h5&gt;&lt;u&gt;Singleton ExampleId: @service.SingletonExample.ExampleId&lt;/u&gt;&lt;/h5&gt;</span><br/><br/><span class="koboSpan" id="kobo.49.1">  &lt;table&gt;</span><br/><span class="koboSpan" id="kobo.50.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.51.1">        &lt;th&gt;Dependencies&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.52.1">        &lt;th&gt;Guid Value&lt;/th&gt;</span><br/><span class="koboSpan" id="kobo.53.1">    &lt;/tr&gt;</span><br/><br/><span class="koboSpan" id="kobo.54.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.55.1">        &lt;td&gt;Scoped Dependency&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.56.1">        &lt;td&gt;@service.SingletonExample.ScopedExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.57.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.58.1">    &lt;tr&gt;</span><br/><span class="koboSpan" id="kobo.59.1">        &lt;td&gt;Transient Dependency&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.60.1">        &lt;td&gt;@service.SingletonExample.TransientExampleId&lt;/td&gt;</span><br/><span class="koboSpan" id="kobo.61.1">    &lt;/tr&gt;</span><br/><span class="koboSpan" id="kobo.62.1">  &lt;/table&gt;</span></pre>
<p><span class="koboSpan" id="kobo.63.1">So, I am trying to print the </span><kbd><span class="koboSpan" id="kobo.64.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.65.1"> of </span><kbd><span class="koboSpan" id="kobo.66.1">Singleton</span></kbd><span class="koboSpan" id="kobo.67.1"> object and properties related to the dependent objects (</span><kbd><span class="koboSpan" id="kobo.68.1">Transient</span></kbd><span class="koboSpan" id="kobo.69.1"> and </span><kbd><span class="koboSpan" id="kobo.70.1">Scoped</span></kbd><span class="koboSpan" id="kobo.71.1">). </span><span class="koboSpan" id="kobo.71.2">I have omitted the styles from this code which is just to make the table look cool.</span></p>
<p><span class="koboSpan" id="kobo.72.1">It's time to tell the </span><kbd><span class="koboSpan" id="kobo.73.1">Startup</span></kbd> <kbd><span class="koboSpan" id="kobo.74.1">ConfigureService</span></kbd><span class="koboSpan" id="kobo.75.1"> to register the classes with the appropriate lifestyle:</span></p>
<pre><span class="koboSpan" id="kobo.76.1">public void ConfigureServices(IServiceCollection services)
{
        // Add framework services.
        </span><span class="koboSpan" id="kobo.76.2">services.AddMvc();

        services.AddSingleton&lt;IExampleSingleton, ExampleSingleton&gt;();
        services.AddScoped&lt;IExampleScoped, ExampleScoped&gt;();
        services.AddTransient&lt;IExampleTransient, ExampleTransient&gt;();

        services.AddTransient&lt;ExampleService, ExampleService&gt;();
}</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.77.1">Voila! </span><span class="koboSpan" id="kobo.77.2">We are done. </span><span class="koboSpan" id="kobo.77.3">Let's check the output. </span><span class="koboSpan" id="kobo.77.4">I have pasted the screenshots of two requests done to the controller side by side so that we can easily mark the findings:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.78.1"><img src="assets/f98f9b19-cec3-4dbe-b7ec-7aa5d7e9b4a7.png"/></span></div>
<p><strong><span class="koboSpan" id="kobo.79.1">Observation</span></strong><span class="koboSpan" id="kobo.80.1">: The </span><kbd><span class="koboSpan" id="kobo.81.1">Singleton</span></kbd><span class="koboSpan" id="kobo.82.1"> object is shared across two requests as the underlined </span><kbd><span class="koboSpan" id="kobo.83.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.84.1"> value is same.</span></p>
<p><span class="koboSpan" id="kobo.85.1">Hold on! </span><span class="koboSpan" id="kobo.85.2">There is something weird. </span><span class="koboSpan" id="kobo.85.3">Dependent objects' values are also the same across request. </span><span class="koboSpan" id="kobo.85.4">Notice the values in red blocks. </span><span class="koboSpan" id="kobo.85.5">Even though those classes are registered as </span><kbd><span class="koboSpan" id="kobo.86.1">Scoped</span></kbd><span class="koboSpan" id="kobo.87.1"> and </span><kbd><span class="koboSpan" id="kobo.88.1">Transient</span></kbd><span class="koboSpan" id="kobo.89.1">, they are behaving like a </span><kbd><span class="koboSpan" id="kobo.90.1">Singleton</span></kbd><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">That means the normal lifestyle of these objects is tampered.</span></p>
<p><strong><span class="koboSpan" id="kobo.92.1">Inference</span></strong><span class="koboSpan" id="kobo.93.1">: It's not recommended to refer </span><kbd><span class="koboSpan" id="kobo.94.1">Scoped</span></kbd><span class="koboSpan" id="kobo.95.1"> and </span><kbd><span class="koboSpan" id="kobo.96.1">Transient</span></kbd><span class="koboSpan" id="kobo.97.1"> lifestyle classes inside a </span><kbd><span class="koboSpan" id="kobo.98.1">Singleton</span></kbd><span class="koboSpan" id="kobo.99.1"> class as they will lose their usual behavior and become Singletons.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.100.1">Obviously, a </span><kbd><span class="koboSpan" id="kobo.101.1">Singleton</span></kbd><span class="koboSpan" id="kobo.102.1"> class can depend on another a </span><kbd><span class="koboSpan" id="kobo.103.1">Singleton</span></kbd><span class="koboSpan" id="kobo.104.1"> class. </span><span class="koboSpan" id="kobo.104.2">Likewise, other lifestyles follow the same rule. </span><span class="koboSpan" id="kobo.104.3">So, a </span><kbd><span class="koboSpan" id="kobo.105.1">Scoped</span></kbd><span class="koboSpan" id="kobo.106.1"> class can refer another </span><kbd><span class="koboSpan" id="kobo.107.1">Scoped</span></kbd><span class="koboSpan" id="kobo.108.1"> class and a </span><kbd><span class="koboSpan" id="kobo.109.1">Transient</span></kbd><span class="koboSpan" id="kobo.110.1"> can refer another </span><kbd><span class="koboSpan" id="kobo.111.1">Transient</span></kbd><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">They all will behave as expected when executed.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Scoped depending on Singleton and Transient</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Similarly, we can test for dependencies inside a </span><kbd><span class="koboSpan" id="kobo.3.1">Scoped</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">We will start by adding two properties to the interface </span><kbd><span class="koboSpan" id="kobo.5.1">IExampleScoped</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">public interface IExampleScoped : IExampleService
{
        Guid SingletonExampleId { get; }
        Guid TransientExampleId { get; }
}</span></pre>
<p><kbd><span class="koboSpan" id="kobo.8.1">ExampleScoped</span></kbd><span class="koboSpan" id="kobo.9.1"> should now implement these two properties. </span><span class="koboSpan" id="kobo.9.2">Also, the interfaces related to </span><kbd><span class="koboSpan" id="kobo.10.1">Transient</span></kbd><span class="koboSpan" id="kobo.11.1"> and </span><kbd><span class="koboSpan" id="kobo.12.1">Singleton</span></kbd><span class="koboSpan" id="kobo.13.1"> need to be injected into the </span><kbd><span class="koboSpan" id="kobo.14.1">constructor</span></kbd><span class="koboSpan" id="kobo.15.1">:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    public class ExampleScoped : IExampleScoped
    {
        public Guid ExampleId { get; set; }
        public Guid SingletonExampleId { get; set; }
        public Guid TransientExampleId { get; set; }

        public ExampleScoped(IExampleTransient transient, IExampleSingleton singleton)
        {
          ExampleId = Guid.NewGuid();
          SingletonExampleId = singleton.ExampleId;
          TransientExampleId = transient.ExampleId;
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.17.1">A new action is added which will return the view named as </span><kbd><span class="koboSpan" id="kobo.18.1">Scoped</span></kbd><span class="koboSpan" id="kobo.19.1">:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    public IActionResult ScopedDependencies()
    {
        ViewBag.Scoped = _scopedExample;

        ViewBag.Service = _exampleService;

        return View("Scoped");
    }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Looks like we are done. </span><span class="koboSpan" id="kobo.21.2">Let's run the app:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img src="assets/ded12cfc-42d1-41fa-a62f-a1699b3d40d5.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">Oops! </span><span class="koboSpan" id="kobo.23.2">We see an exception screen which says a Circular Dependency was detected.</span></p>
<div class="packt_infobox"><strong><span class="koboSpan" id="kobo.24.1">Circular Dependency</span></strong><span class="koboSpan" id="kobo.25.1">, as the name suggests, is a class which depends on another, which in turn, depends on the first class. </span><span class="koboSpan" id="kobo.25.2">We designed everything to test the dependencies of other lifestyles in Scoped lifestyle, but we forgot one thing before doing that. </span><span class="koboSpan" id="kobo.25.3">Previously, we added a dependency of </span><kbd><span class="koboSpan" id="kobo.26.1">Scoped</span></kbd><span class="koboSpan" id="kobo.27.1"> class inside a </span><kbd><span class="koboSpan" id="kobo.28.1">Singleton</span></kbd><span class="koboSpan" id="kobo.29.1"> class and now, if you see the preceding </span><kbd><span class="koboSpan" id="kobo.30.1">ExampleScoped</span></kbd><span class="koboSpan" id="kobo.31.1"> constructor, we now inject </span><kbd><span class="koboSpan" id="kobo.32.1">IExampleSingleton</span></kbd><span class="koboSpan" id="kobo.33.1">, which is resolved as the </span><kbd><span class="koboSpan" id="kobo.34.1">Singleton</span></kbd><span class="koboSpan" id="kobo.35.1"> class </span><kbd><span class="koboSpan" id="kobo.36.1">ExampleSingleton</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">That's how it became circular.</span></div>
<p><span class="koboSpan" id="kobo.38.1">Therefore, we need to remove the dependencies from the </span><kbd><span class="koboSpan" id="kobo.39.1">Singleton</span></kbd><span class="koboSpan" id="kobo.40.1"> class to test. </span><span class="koboSpan" id="kobo.40.2">We can also test by doing another interface and class for </span><kbd><span class="koboSpan" id="kobo.41.1">Singleton</span></kbd><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">So, when you fix the code, we will get the following output. </span><span class="koboSpan" id="kobo.42.3">I am not going to write the codes of the </span><kbd><span class="koboSpan" id="kobo.43.1">View</span></kbd><span class="koboSpan" id="kobo.44.1"> here. </span><span class="koboSpan" id="kobo.44.2">It's pretty much the same as we done in </span><kbd><span class="koboSpan" id="kobo.45.1">Singleton</span></kbd><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">We just need to print </span><kbd><span class="koboSpan" id="kobo.47.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.48.1">, </span><kbd><span class="koboSpan" id="kobo.49.1">SingletonExampleId</span></kbd><span class="koboSpan" id="kobo.50.1"> and </span><kbd><span class="koboSpan" id="kobo.51.1">TransientExampleId</span></kbd><span class="koboSpan" id="kobo.52.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.53.1"><img src="assets/157c30df-1f4d-4d51-817f-978969316d74.png"/></span></div>
<p><strong><span class="koboSpan" id="kobo.54.1">Observation:</span></strong><span class="koboSpan" id="kobo.55.1"> In the red boxes, we have transient object values. </span><span class="koboSpan" id="kobo.55.2">That is because they are not </span><kbd><span class="koboSpan" id="kobo.56.1">Transient</span></kbd><span class="koboSpan" id="kobo.57.1"> anymore and behave like </span><kbd><span class="koboSpan" id="kobo.58.1">Scoped</span></kbd><span class="koboSpan" id="kobo.59.1">, as the values are the same in a request, which is not what </span><kbd><span class="koboSpan" id="kobo.60.1">Transient</span></kbd><span class="koboSpan" id="kobo.61.1"> looks like. </span><span class="koboSpan" id="kobo.61.2">It should be different every time it is requested. </span><span class="koboSpan" id="kobo.61.3">But in the case of </span><kbd><span class="koboSpan" id="kobo.62.1">Singleton</span></kbd><span class="koboSpan" id="kobo.63.1"> dependency, it is the same across requests, which not only satisfies the </span><kbd><span class="koboSpan" id="kobo.64.1">Singleto</span></kbd><span class="koboSpan" id="kobo.65.1">n paradigm but also behaves like scoped in a particular request.</span></p>
<p><strong><span class="koboSpan" id="kobo.66.1">Inference:</span></strong><span class="koboSpan" id="kobo.67.1"> That's why it is recommended to use </span><kbd><span class="koboSpan" id="kobo.68.1">Scoped</span></kbd><span class="koboSpan" id="kobo.69.1"> and </span><kbd><span class="koboSpan" id="kobo.70.1">Singleton</span></kbd><span class="koboSpan" id="kobo.71.1"> dependencies inside a </span><kbd><span class="koboSpan" id="kobo.72.1">Scoped</span></kbd><span class="koboSpan" id="kobo.73.1"> class, but not Transient.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Transient depending on Singleton and Scoped</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following the same pattern for </span><kbd><span class="koboSpan" id="kobo.3.1">Transient</span></kbd><span class="koboSpan" id="kobo.4.1">, we will design the interface and class as required. </span><span class="koboSpan" id="kobo.4.2">The interface will look like the following:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">public interface IExampleTransient : IExampleService
{
        Guid SingletonExampleId { get; }
        Guid ScopedExampleId { get; }
}</span></pre>
<p><span class="koboSpan" id="kobo.6.1">Next is the </span><kbd><span class="koboSpan" id="kobo.7.1">Transient</span></kbd><span class="koboSpan" id="kobo.8.1"> class depending on </span><kbd><span class="koboSpan" id="kobo.9.1">Singleton</span></kbd><span class="koboSpan" id="kobo.10.1"> and </span><kbd><span class="koboSpan" id="kobo.11.1">Scoped</span></kbd><span class="koboSpan" id="kobo.12.1">.</span></p>
<pre><span class="koboSpan" id="kobo.13.1">public class ExampleTransient : IExampleTransient
{
        public Guid ExampleId { get; set; }
        public Guid SingletonExampleId { get; set; }
        public Guid ScopedExampleId { get; set; }

        public ExampleTransient(IExampleSingleton singleton, IExampleScoped scoped)
        {
                ExampleId = Guid.NewGuid();
                SingletonExampleId = singleton.ExampleId;
                ScopedExampleId = scoped.ExampleId;
        }
}</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Last, but not the least, a new action to render the view </span><kbd><span class="koboSpan" id="kobo.15.1">Transient</span></kbd><span class="koboSpan" id="kobo.16.1">:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    public IActionResult TransientDependencies()
   {
        ViewBag.Transient = _transientExample;

        ViewBag.Service = _exampleService;

        return View("Transient");
   }</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Running this after designing the view will end up with something like the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1"><img src="assets/964da5d3-1efd-41bf-a166-cb3cd8aa5334.png"/></span></div>
<p><span class="koboSpan" id="kobo.20.1">You can see how the </span><kbd><span class="koboSpan" id="kobo.21.1">Transient</span></kbd> <kbd><span class="koboSpan" id="kobo.22.1">ExampleId</span></kbd><span class="koboSpan" id="kobo.23.1"> differs in inside and outside the request.</span></p>
<p><strong><span class="koboSpan" id="kobo.24.1">Observation:</span></strong><span class="koboSpan" id="kobo.25.1"> You must be wondering why I don't have red boxes in this picture. </span><span class="koboSpan" id="kobo.25.2">That is because everything looks perfect. </span><kbd><span class="koboSpan" id="kobo.26.1">Singleton</span></kbd><span class="koboSpan" id="kobo.27.1"> is the same everywhere and </span><kbd><span class="koboSpan" id="kobo.28.1">Scoped</span></kbd><span class="koboSpan" id="kobo.29.1"> is the same in a particular request, however, changes in the next request.</span></p>
<p><strong><span class="koboSpan" id="kobo.30.1">Inference:</span></strong><span class="koboSpan" id="kobo.31.1"> That means, both these dependencies carry their usual characteristics when injected inside a </span><em><span class="koboSpan" id="kobo.32.1">Transient</span></em><span class="koboSpan" id="kobo.33.1"> class. </span><span class="koboSpan" id="kobo.33.2">Also, another </span><em><span class="koboSpan" id="kobo.34.1">Transient</span></em><span class="koboSpan" id="kobo.35.1"> dependency will definitely work if injected to a </span><em><span class="koboSpan" id="kobo.36.1">Transient</span></em><span class="koboSpan" id="kobo.37.1"> class.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.38.1">Saying all this, I would say these are the recommended patterns to follow while injecting one lifestyle into another. </span><span class="koboSpan" id="kobo.38.2">We should be careful while designing the classes and their lifestyle. </span><span class="koboSpan" id="kobo.38.3">Either we will end up in a Circular Dependency or lose the appropriate behavior of the lifestyle injected as we saw in the preceding examples. </span><span><span class="koboSpan" id="kobo.39.1">We can still mix it up as long as we are aware of the consequences.</span></span></div>
<p><span class="koboSpan" id="kobo.40.1">With just a simple table, I can represent the whole point:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.41.1"><img height="233" width="273" src="assets/99131700-c1b9-4a79-a682-50d2c5038a10.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned about how objects are created and destroyed by .NET Framework. </span><span class="koboSpan" id="kobo.2.2">Creation and destruction mechanism were discussed. </span><em><span class="koboSpan" id="kobo.3.1">Garbage Collector</span></em><span class="koboSpan" id="kobo.4.1"> plays an important role in the automatic disposal through Finalizers, which we analyzed through examples.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Most importantly, we saw a step-by-step walkthrough to manually dispose of objects as soon as we are done by implementing the </span><kbd><span class="koboSpan" id="kobo.6.1">IDisposal</span></kbd><span class="koboSpan" id="kobo.7.1"> interface.</span></p>
<p><span class="koboSpan" id="kobo.8.1">After that, we explored the different lifetimes maintained by objects in .NET Core. </span><span class="koboSpan" id="kobo.8.2">We saw examples using the controller and service classes. </span><span class="koboSpan" id="kobo.8.3">We learned how the objects are created and disposed of. </span><span class="koboSpan" id="kobo.8.4">Most importantly, we experimented with the adaptability of different lifestyles with each other.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Interception, another pillar of DI, will be covered in </span><a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></a><span class="koboSpan" id="kobo.11.1">, </span><em><span class="koboSpan" id="kobo.12.1">Interception</span></em><span class="koboSpan" id="kobo.13.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>