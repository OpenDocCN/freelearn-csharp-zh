<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Working with Textures, Models, and 2D"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Working with Textures, Models, and 2D</h1></div></div></div><p>Most game engines today orient their feature set towards the creation of 3D games rather than 2D in a general sense. This often, ironically, makes 3D tasks and workflows simpler than 2D ones, at least to pick up and get started with initially. In this chapter, we'll explore a variety of 2D<a id="id656" class="indexterm"/> issues with some provisos. Since the release of Unity 4.3, a wide range of 2D features have been added to the editor: initially, a native sprite system and then, a new GUI system. While these are both useful in their respective ways, the main focus of this chapter will not be on these features specifically. The first reason is that a lot of tutorials already explain them in considerable detail, but the second and most important <a id="id657" class="indexterm"/>reason is that even with the added 2D features, there are still more fundamental questions that arise about working in 2D, in a looser sense. These include questions such as how to manipulate geometry such as the vertices and edges of 2D planes, how to adjust and animate texture coordinates, how to edit textures and also how to texture paint onto textures in real time using a brush-like system to create decals and blood splats, and so on. These questions are more 2D than 3D insofar as they pertain to geometry and textures in the 2D plane, but their relevance is to both 2D and 3D games generally. Their importance is highly significant today, though their coverage is somewhat under-represented in the tutorials available, so I have covered them here. Consequently, I'll restrict this chapter mostly to the unconventional side of 2D.</p><div class="section" title="Skybox"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec90"/>Skybox</h1></div></div></div><p>The Skybox might seem<a id="id658" class="indexterm"/> a strange place to begin an analysis of 2D, but it demonstrates an important feature set for cameras, specifically layering. The Skybox is essentially a cube-based background that's attached to a camera to show clouds, skies, and other distant details that should always act as the backdrop to a scene, but it never represents anything that the player can move close to. It is always distant, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_01.jpg" alt="Skybox"/><div class="caption"><p>Skybox assets display a sky background for cameras</p></div></div><p>The main problem with the default Skyboxes native to Unity is that they remain static and motionless by default. Most developers, however, want their skies and clouds to gently rotate, even when<a id="id659" class="indexterm"/> the camera is standing motionless, to portray the procession of a day or of time passing. Now, let's create an improved Skybox prefab using the Unity Skybox assets, two layered cameras, and a C# script file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip61"/>Tip</h3><p>The final project for a rotating Skybox can be found in the book's companion files.</p></div></div><p>For the sample project created here, let's import the <span class="strong"><strong>Character Controllers</strong></span> package for a first-person controller asset, the <span class="strong"><strong>Terrain Assets</strong></span> package for terrain textures that we can paint onto a sample terrain, and the <span class="strong"><strong>Skyboxes</strong></span> package for the Skybox textures, as shown in the following screenshot.</p><p>All these will be useful in building a sample project with a rotating Skybox.</p><div class="mediaobject"><img src="graphics/0655OT_09_02.jpg" alt="Skybox"/><div class="caption"><p>Importing Character Controllers, Skyboxes, and Terrain Assets</p></div></div><p>Next, let's begin by creating the rotating Skybox prefab to make a reusable object. This object consists of three main parts or subobjects: a first-person controller that allows player movement and renders most scene objects, a second camera (the Skybox camera) that is rendered below<a id="id660" class="indexterm"/> the first-person camera and shows only the Skybox, and a cube object with inverted normals that surrounds the Skybox camera and shows each Skybox texture on each face.</p><p>To start, create a new empty object at the scene origin (named <code class="literal">SkyBoxCamera</code>) and add a first-person controller object as a child. Then, create six <span class="strong"><strong>Quad</strong></span> objects from the main menu (by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Quad</strong></span>), aligning each object to the corners of the other, with the vertex snapping to form an inverted cube, that is, a cube whose faces are turned inwards, as shown in the following screenshot. This represents the mesh for the manual Skybox.</p><div class="mediaobject"><img src="graphics/0655OT_09_03.jpg" alt="Skybox"/><div class="caption"><p>Create a manual Skybox from six Quad objects</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip62"/>Tip</h3><p>Scale the Quads if required and make sure that they contain and enclose the first-person controller, which should be at the center of the Skybox.</p></div></div><p>Assign the Skybox faces<a id="id661" class="indexterm"/> to a new layer, <code class="literal">SkyBoxLayer</code>, select the first-person controller camera, and then change the <span class="strong"><strong>Culling Mask</strong></span> field to exclude the <code class="literal">SkyBoxLayer</code> layer. The first-person camera should render only foreground objects and not background ones. To achieve this, change the <span class="strong"><strong>Clear Flags</strong></span> field to <span class="strong"><strong>Depth only</strong></span> in the Object Inspector, as shown in the following screenshot. This renders the camera background to transparent, which allows lower-order cameras to show through, if any.</p><div class="mediaobject"><img src="graphics/0655OT_09_04.jpg" alt="Skybox"/><div class="caption"><p>Making the camera background transparent</p></div></div><p>Now, create a new and additional <code class="literal">Camera</code> object as a direct child object of the first-person camera and match its position, rotation, and scale. This allows the camera to inherit all the transformations from the first-person camera. The purpose of the secondary camera is to render only<a id="id662" class="indexterm"/> the Skybox object as a layer beneath the first-person camera while matching the first-person position and rotation.</p><p>To this end, change the <span class="strong"><strong>Depth</strong></span> value of the new camera to any value less than the depth of the first-person camera; such as <code class="literal">-1</code>. Remove any audio listener components where required.</p><div class="mediaobject"><img src="graphics/0655OT_09_05.jpg" alt="Skybox"/><div class="caption"><p>Creating a second camera for Skybox rendering</p></div></div><p>Assign a unique Skybox texture to each cube face and take care to align them seamlessly by rotating or adjusting<a id="id663" class="indexterm"/> the Quad alignment as needed. Then, change the material <span class="strong"><strong>Shader</strong></span> type for the Skybox textures to <span class="strong"><strong>Unlit/Texture</strong></span>, making the Skybox immune to scene lighting. The Skybox mesh should start taking shape, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_06.jpg" alt="Skybox"/><div class="caption"><p>Adding Skybox textures to the Quads</p></div></div><p>Finally, apply the following code sample 9-1 to the Skybox parent object to create its rotation behavior and to <a id="id664" class="indexterm"/>align it continuously to the camera position. This ensures that the Skybox is always centered on the camera wherever it travels in the scene:</p><div class="informalexample"><pre class="programlisting">01 //--------------------------------------------------
02 using UnityEngine;
03 using System.Collections;
04 //--------------------------------------------------
05 public class SkyBox : MonoBehaviour 
06 {
07 //--------------------------------------------------
08 //Camera to follow
09 public Camera FollowCam = null;
10 
11 //Rotate Speed (Degrees per second)
12 public float RotateSpeed = 10.0f;
13 
14 //Transform
15 private Transform ThisTransform = null;
16 //--------------------------------------------------
17 // Use this for initialization
18 void Awake () {
19       ThisTransform = transform;
20 }
21 //--------------------------------------------------
22 // Update is called once per frame
23 void Update () {
24        //Update position
25        ThisTransform.position = FollowCam.transform.position;
26 
27        //Update rotation
28 ThisTransform.Rotate(new Vector3(0,RotateSpeed * Time.deltaTime,0));
29 }
30 //--------------------------------------------------
31 }
32 //--------------------------------------------------</pre></div><p>From this, you now have a completed and enhanced Skybox, one that surrounds the camera and rotates to produce<a id="id665" class="indexterm"/> greater realism and life in your scenes. You can even go further by adding multiple stacked skyboxes within each other, each with transparency, to create additional effects such as fog, mist, and so on:</p><div class="mediaobject"><img src="graphics/0655OT_09_07.jpg" alt="Skybox"/><div class="caption"><p>Completing a manual Skybox prefab</p></div></div></div></div>
<div class="section" title="Procedural meshes"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec91"/>Procedural meshes</h1></div></div></div><p>Although Unity now<a id="id666" class="indexterm"/> offers a Quad primitive from the application menu, which you can access by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Quad</strong></span>, it's still useful to know how to create geometry <a id="id667" class="indexterm"/>manually, such as Quads. There are several reasons for this. First, you'll frequently need to edit vertices in the script to move, animate, or distort meshes for various effects to create, for example, a jelly-like surface in a platform game that bends and wobbles<a id="id668" class="indexterm"/> whenever characters<a id="id669" class="indexterm"/> step on it. Second, you'll need to edit the UV coordinates of a mesh, perhaps, to create animated or scrolling-texture effects, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_08.jpg" alt="Procedural meshes"/><div class="caption"><p>Generating meshes from script</p></div></div><p>Consider the following code sample 9-2, which should be included inside the <code class="literal">Editor</code> folder of a project. It creates an editor add-on that generates a Quad in script with full customization over the location of the mesh pivot point. As we'll see in the code comments, this sample features many useful tips:</p><div class="informalexample"><pre class="programlisting">001 //EDITOR CLASS TO CREATE QUAD MESH WITH SPECIFIED ANCHOR
002 //------------------------------------------------
003 using UnityEngine;
004 using UnityEditor;
005 using System.IO;
006 //------------------------------------------------
007 //Run from unity editor
008 public class CreateQuad : ScriptableWizard
009 {
010       //Anchor point for created quad
011       public enum AnchorPoint
012     {
013         TopLeft,
014         TopMiddle,
015         TopRight,
016         RightMiddle,
017         BottomRight,
018         BottomMiddle,
019         BottomLeft,
020         LeftMiddle,
021         Center,
022             Custom
023     }
024 
025      //Name of Quad Asset
026      public string MeshName = "Quad";
027 
028      //Game Object Name
029      public string GameObjectName = "Plane_Object";
030 
031      //Name of asset folder
032      public string AssetFolder = "Assets";
033 
034      //Width of quad in world units (pixels)
035      public float Width = 1.0f;
036 
037      //Height of quad in world units (pixels)
038      public float Height = 1.0f;
039 
040      //Position of Anchor
041      public AnchorPoint Anchor = AnchorPoint.Center;
042 
043      //Horz Position of Anchor on Plane
044      public float AnchorX = 0.5f;
045 
046     //Vert Position of Anchor on Plane
047      public float AnchorY = 0.5f;
048      //------------------------------------------------
049      [MenuItem("GameObject/Create Other/Custom Plane")]
050     static void CreateWizard()
051     {
052         ScriptableWizard.DisplayWizard("Create Plane",typeof(CreateQuad));
053     }
054 
055      //------------------------------------------------
056      //Function called when window is created
057      void OnEnable()
058      {
059             //Call selection change
060             OnSelectionChange();
061       }
062       //------------------------------------------------
063       //Called 10 times per second
064       void OnInspectorUpdate()
065       {
066             switch(Anchor)
067             {
068                   //Anchor is set to top-left
069                   case AnchorPoint.TopLeft:
070                         AnchorX = 0.0f * Width;
071                         AnchorY = 1.0f * Height;
072                   break;
073 
074                   //Anchor is set to top-middle
075                   case AnchorPoint.TopMiddle:
076                          AnchorX = 0.5f * Width;
077                          AnchorY = 1.0f * Height;
078                   break;
079 
080                   //Anchor is set to top-right
081                   case AnchorPoint.TopRight:
082                          AnchorX = 1.0f * Width;
083                          AnchorY = 1.0f * Height;
084                   break;
085 
086                   //Anchor is set to right-middle
087                   case AnchorPoint.RightMiddle:
088                         AnchorX = 1.0f * Width;
089                         AnchorY = 0.5f * Height;
090                   break;
091 
092                   //Anchor is set to Bottom-Right
093                   case AnchorPoint.BottomRight:
094                         AnchorX = 1.0f * Width;
095                         AnchorY = 0.0f * Height;
096                   break;
097 
098                   //Anchor is set to Bottom-Middle
099                   case AnchorPoint.BottomMiddle:
100                         AnchorX = 0.5f * Width;
101                         AnchorY = 0.0f * Height;
102                   break;
103 
104                   //Anchor is set to Bottom-Left
105                   case AnchorPoint.BottomLeft:
106                         AnchorX = 0.0f * Width;
107                         AnchorY = 0.0f * Height;
108                   break;
109 
110                   //Anchor is set to Left-Middle
111                   case AnchorPoint.LeftMiddle:
112                         AnchorX = 0.0f * Width;
113                         AnchorY = 0.5f * Height;
114                   break;
115 
116                   //Anchor is set to center
117                   case AnchorPoint.Center:
118                         AnchorX = 0.5f * Width;
119                         AnchorY = 0.5f * Height;
120                   break;
121 
122                   case AnchorPoint.Custom:
123                   default:
124                   break;
125            }
126      }
127       //------------------------------------------------
128       //Function called when window is updated
129       void OnSelectionChange()
130      {
131             //Check user selection in editor 
132      if (Selection.objects != null &amp;&amp; Selection.objects.Length == 1)
133             {
134             //Get path from selected asset
<span class="strong"><strong>135       AssetFolder = Path.GetDirectoryName(AssetDatabase.GetAssetPath(Selection.objects[0]));</strong></span>

136             }
137      }
138      //------------------------------------------------
139      //Function to create quad mesh
140      void OnWizardCreate()
141      {
142             //Create Vertices
143             Vector3[] Vertices = new Vector3[4];
144 
145             //Create UVs
146             Vector2[] UVs = new Vector2[4];
147 
148             //Two triangles of quad
149             int[] Triangles = new int[6];
150 
151             //Assign vertices based on pivot
152 
153             //Bottom-left
154             Vertices[0].x = -AnchorX;
155             Vertices[0].y = -AnchorY;
156 
157             //Bottom-right
158             Vertices[1].x = Vertices[0].x+Width;
159             Vertices[1].y = Vertices[0].y;
160
161             //Top-left
162             Vertices[2].x = Vertices[0].x;
163             Vertices[2].y = Vertices[0].y+Height;
164 
165             //Top-right
166             Vertices[3].x = Vertices[0].x+Width;
167             Vertices[3].y = Vertices[0].y+Height;
168             
169             //Assign UVs
170             //Bottom-left
171             UVs[0].x=0.0f;
172             UVs[0].y=0.0f;
173
174             //Bottom-right
175             UVs[1].x=1.0f;
176             UVs[1].y=0.0f;
177
178             //Top-left
179             UVs[2].x=0.0f;
180             UVs[2].y=1.0f;
181 
182             //Top-right
183             UVs[3].x=1.0f;
184             UVs[3].y=1.0f;
185 
186             //Assign triangles
187             Triangles[0]=3;
188             Triangles[1]=1;
189             Triangles[2]=2;
190 
191             Triangles[3]=2;
192             Triangles[4]=1;
193             Triangles[5]=0;
194 
195             //Generate mesh
196             Mesh mesh = new Mesh();
197             mesh.name = MeshName;
198             mesh.vertices = Vertices;
199             mesh.uv = UVs;
200             mesh.triangles = Triangles;
201             mesh.RecalculateNormals();
202 
203             //Create asset in database
<span class="strong"><strong>204      AssetDatabase.CreateAsset(mesh, AssetDatabase.GenerateUniqueAssetPath(AssetFolder + "/" + MeshName) + ".asset");</strong></span>

<span class="strong"><strong>205            AssetDatabase.SaveAssets();</strong></span>
206 
207             //Create plane game object
208             GameObject plane = new GameObject(GameObjectName);

209       MeshFilter meshFilter = (MeshFilter)plane.AddComponent(typeof(MeshFilter);

210             plane.AddComponent(typeof(MeshRenderer));
211 
212             //Assign mesh to mesh filter
213             meshFilter.sharedMesh = mesh;
214             mesh.RecalculateBounds();
215 
216             //Add a box collider component
217             plane.AddComponent(typeof(BoxCollider));
218      }
219 
220       //------------------------------------------------
221 }</pre></div><p>The following are the<a id="id670" class="indexterm"/> comments for code sample 9-2:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 004</strong></span>: This sample is coded as an editor plugin. As a result, the <code class="literal">UnityEditor</code> namespace is included. For more information on creating editor plugins, refer to <a class="link" href="ch08.html" title="Chapter 8. Customizing the Unity Editor">Chapter 8</a>, <span class="emphasis"><em>Customizing the Unity Editor</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 135</strong></span>: The <code class="literal">OnSelectionChanged</code> event is called when the user changes their selection, with the mouse or keyboard, in the Unity Editor. Here, the <code class="literal">GetAssetPath</code> method is called to retrieve the currently open folder in the <span class="strong"><strong>Project</strong></span> panel.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 140</strong></span>: The <code class="literal">OnWizardCreate</code> function is called to generate a Quad mesh in script. This is created by filling a vertex and UV array and then populating that inside a <code class="literal">Mesh</code> object created in line 196.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 204</strong></span>: Critically, the mesh itself is saved, not as an object in a specific scene, but as a general asset of the project from which many instances can be made as prefab objects. This is achieved with the <code class="literal">AssetDatabase</code> class. This is important to allow the mesh to be reusable across multiple scenes, if required, and also to allow<a id="id671" class="indexterm"/> its changes and details to be persistent across scenes.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip63"/>Tip</h3><p>More information on the <a id="id672" class="indexterm"/>
<code class="literal">AssetDatabase</code> class can be found online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/AssetDatabase.html">http://docs.unity3d.com/ScriptReference/AssetDatabase.html</a>.</p></div></div></li></ul></div></div>
<div class="section" title="Animating UVs &#x2013; scrolling textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec92"/>Animating UVs – scrolling textures</h1></div></div></div><p>Scrolling textures<a id="id673" class="indexterm"/> are a general purpose requirement for lots of games, and yet, they are not natively supported by<a id="id674" class="indexterm"/> Unity; that is, they require you to "get coding" for their implementation. Scrolling textures are useful for parallax effects; to move clouds, surfaces, and water; or to express motion or movement in the game. Typically, scrolling textures are seamless images whose pixels tile vertically and horizontally. This allows infinite scrolling and repetition, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_09.jpg" alt="Animating UVs – scrolling textures"/><div class="caption"><p>Scrolling texture on a Quad</p></div></div><p>When <a id="id675" class="indexterm"/>attached to a Quad, the following code sample 9-3 will animate its texture according to the<a id="id676" class="indexterm"/> horizontal and vertical speed:</p><div class="informalexample"><pre class="programlisting">01 //CLASS TO SCROLL TEXTURE ON PLANE. CAN BE USED FOR MOVING SKY
02 //------------------------------------------------
03 using UnityEngine;
04 using System.Collections;
05 //------------------------------------------------
06 [RequireComponent (typeof (MeshRenderer))] 
07 public class MatScroller : MonoBehaviour
08 {
09 //Public variables
10 //------------------------------------------------
11 //Reference to Horizontal Scroll Speed
12 public float HorizSpeed = 1.0f;
13 
14 //Reference to Vertical Scroll Speed
15 public float VertSpeed = 1.0f;
16 
17 //Reference to Min and Max Horiz and vert
18 public float HorizUVMin = 1.0f;
19 public float HorizUVMax = 2.0f;
20 
21 public float VertUVMin = 1.0f;
22 public float VertUVMax = 2.0f;
23 
24 //Private variables
25 //------------------------------------------------
26 //Reference to Mesh Renderer Component
27 private MeshRenderer MeshR = null;
28 
29 //Methods
30 //------------------------------------------------
31 // Use this for initialization
32 void Awake ()
33 {
34        //Get Mesh Renderer Component
35        MeshR = GetComponent&lt;MeshRenderer&gt;();
36 }
37 //------------------------------------------------
38 // Update is called once per frame
39 void Update () 
40 {
41        //Scrolls texture between min and max
42 Vector2 Offset = new Vector2((MeshR.material.mainTextureOffset.x &gt; HorizUVMax) ? HorizUVMin : MeshR.material.mainTextureOffset.x + Time.deltaTime * HorizSpeed,
43 (MeshR.material.mainTextureOffset.y &gt; VertUVMax) ? VertUVMin : MeshR.material.mainTextureOffset.y + Time.deltaTime * VertSpeed);

44 
45       //Update UV coordinates
46       MeshR.material.mainTextureOffset = Offset;
47 }
48 //------------------------------------------------
49 }
50 //------------------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/>Tip</h3><p>The <code class="literal">MatScroller</code> class works with any <code class="literal">MeshRenderer</code> component and Quad object. A complete scrolling-texture project can be found in the book's companion files (code bundle).</p></div></div><p>Attach this script to your Quad object and tweak its scrolling<a id="id677" class="indexterm"/> speed to produce the results you need, as shown<a id="id678" class="indexterm"/> in the following screenshot. This will be useful to create animated sky backgrounds and backgrounds for side-scrolling shooter or platform games. It can also be useful to create flowing waterfalls and volumetric lighting when combined with transparency!</p><div class="mediaobject"><img src="graphics/0655OT_09_10.jpg" alt="Animating UVs – scrolling textures"/><div class="caption"><p>Tweaking texture-scrolling fields from the Object Inspector</p></div></div></div>
<div class="section" title="Texture painting"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec93"/>Texture painting</h1></div></div></div><p>There are many practical scenarios where it's necessary to paint pixels onto textures at runtime. Sometimes, the <a id="id679" class="indexterm"/>need itself will be trivial, such as displaying a decal texture (such as a foot print or written message) in front of another surface using alpha transparency. In these cases, you can simply workaround the issue with an alpha cut out plane positioned in front of another plane as the background. However, there are times when your needs are more complex, and you actually need to resort to true texture painting. For example, in a street-fighting game, blood splatters from punches and other attacks will fall to the ground and surrounding scenery, and you want to it remain as part of the environment texture. Another example might be a casual make-up artist game where the gamer must paint blusher or eye shadow onto a face mesh.</p><p>Here, you don't simply want to paint textured quads in front of the mesh as separate objects to create the appearance of textured decals. Instead, you really need to paint a source texture (such as a brush) onto a destination texture as applied to a mesh. Here, the painting does not just happen between two independent textures but with a mesh and its UV mapping intervening between them. In other words, a source texture must be applied or projected onto a mesh surface in the scene, and then, the brush pixels must be unprojected back onto the destination texture through the mesh UV mapping. This ensures that the brush pixels are painted to the correct place within the destination texture, as shown in the following screenshot. This method, therefore, allows any source texture of any size to be painted onto any 3D surface and its destination texture of any size via UV mapping.</p><p>In this section, we'll explore<a id="id680" class="indexterm"/> how this is achieved practically and effectively. Before getting started, however, it should be mentioned that texture painting in this way should be pursued as a last resort when alternative methods (such as cut out quads) are not adequate. This is because true texture painting is computationally expensive.</p><div class="mediaobject"><img src="graphics/0655OT_09_11.jpg" alt="Texture painting"/><div class="caption"><p>Real-time painting of textured brushes onto other textures via a mesh and its UV mapping</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/>Tip</h3><p>A complete texture painting project can be found in the book's companion files (code bundle).</p></div></div><div class="section" title="Step 1 – creating a texture blending shader"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec55"/>Step 1 – creating a texture blending shader</h2></div></div></div><p>First, let's<a id="id681" class="indexterm"/> recognize the two-layer approach<a id="id682" class="indexterm"/> that's ideal here. First, we have the brush source texture itself, which will be painted onto a destination texture when the user clicks on a mesh in the scene, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_12.jpg" alt="Step 1 – creating a texture blending shader"/><div class="caption"><p>The brush texture, where black is transparent (alpha)</p></div></div><p>Then, we have the destination texture applied to the mesh onto which the brush strokes should be overlaid <a id="id683" class="indexterm"/>when painted, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_09_13.jpg" alt="Step 1 – creating a texture blending shader"/><div class="caption"><p>Destination texture onto which brushes should be painted</p></div></div><p>However, we don't usually want the painted brush strokes overwriting or changing the original destination texture during the paint operation. This is because the destination texture could be applied to multiple objects in the scene (at least in theory), and overwriting or changing the pixels of the original will result in its effects being propagated to all objects using the texture.</p><p>Instead, it'd be better to separate the paint effects onto a separate texture with a transparent background, which is layered over the destination texture via a custom material. This creates a true separation between the destination texture and the paint effects, even though in appearance, it appears as one consolidated texture. To achieve this effect, a custom shader must be written, as shown in the following code sample 9-4. This shader blends a top<a id="id684" class="indexterm"/> texture (with alpha transparency) on top of a background texture:</p><div class="informalexample"><pre class="programlisting">01 Shader "TextureBlender"
02 {
03     Properties
04     {
05     _Color ("Main Color", Color) = (1,1,1,1)
06     _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
07     _BlendTex ("Blend (RGB)", 2D) = "white"
08     }
09     
10     SubShader
11     {
12 Tags { "Queue"="Geometry-9" "IgnoreProjector"="True" "RenderType"="Transparent" }

13     Lighting Off
14     LOD 200
15     Blend SrcAlpha OneMinusSrcAlpha
16     
17     CGPROGRAM
18            #pragma surface surf Lambert
19            uniform fixed4 _Color;
20            uniform sampler2D _MainTex;
21            uniform sampler2D _BlendTex;
22 
23            struct Input 
24            {
25              float2 uv_MainTex;
26            };
27 
28            void surf (Input IN, inout SurfaceOutput o) 
29            {
30                  fixed4 c1 = tex2D( _MainTex, IN.uv_MainTex );
31                  fixed4 c2 = tex2D( _BlendTex, IN.uv_MainTex );
32 
33                  fixed4 main = c1.rgba * (1.0 - c2.a);
34                  fixed4 blendedoutput = c2.rgba * c2.a;
35 
36 o.Albedo = (main.rgb + blendedoutput.rgb) * _Color;

37                  o.Alpha = main.a + blendedoutput.a;
38            }
39     ENDCG
40     }
41     Fallback "Transparent/VertexLit"
42 }</pre></div><p>Once the shader is coded and saved, it appears as a selectable shader type for any material you create via the <span class="strong"><strong>Material</strong></span> panel in the Object Inspector. This shader should be used for any object onto which details must be painted, as shown in the following screenshot. The <code class="literal">_MainTex</code> slot refers to the background texture onto which details must be overlaid but which must also be preserved from any true edits. The <code class="literal">_BlendTex</code> slot refers to the texture<a id="id685" class="indexterm"/> to be overlaid onto <code class="literal">_MainTex</code>, which preserves its alpha transparency. Typically, this slot will be populated at runtime from script by generating an alpha transparent texture to receive brush strokes, as we'll soon see.</p><div class="mediaobject"><img src="graphics/0655OT_09_14.jpg" alt="Step 1 – creating a texture blending shader"/><div class="caption"><p>A custom shader is created to blend the top-most texture onto the bottom-most texture</p></div></div></div><div class="section" title="Step 2 – creating a texture painting script"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec56"/>Step 2 – creating a texture painting script</h2></div></div></div><p>We've<a id="id686" class="indexterm"/> now created a<a id="id687" class="indexterm"/> shader that accepts two textures as input (the top and bottom textures) and blends the top over the bottom; this allows alpha transparency. This results in a Photoshop-layer style effect. This allows us to separate texture painting onto a top texture while preserving the pixels of the original background below it, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_15.jpg" alt="Step 2 – creating a texture painting script"/><div class="caption"><p>Creating a texture painting script</p></div></div><p>Before moving further, however, we must first edit the brush texture asset we plan on using via Object<a id="id688" class="indexterm"/> Inspector. Specifically, select the brush texture from the <span class="strong"><strong>Project</strong></span> panel in the Unity Editor <a id="id689" class="indexterm"/>and change <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Advanced</strong></span>. Enable the checkbox for <span class="strong"><strong>Read/Write Enabled</strong></span>; this allows the texture to be accessed using texture-editing functions.</p><p>In addition, enable <span class="strong"><strong>Alpha is Transparency</strong></span> and disable <span class="strong"><strong>Generate Mip Maps</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_09_16.jpg" alt="Step 2 – creating a texture painting script"/><div class="caption"><p>Configuring textures for texture painting</p></div></div><p>Now, we'll need to create a texture-painting script that allows us to paint the brush texture, using the <a id="id690" class="indexterm"/>mouse, onto a 3D object in the scene via its UV <a id="id691" class="indexterm"/>coordinates. The script is shown in the following code sample 9-5:</p><div class="informalexample"><pre class="programlisting">001 //-----------------------------------------------------------
002 using UnityEngine;
003 using System.Collections;
004 //-----------------------------------------------------------
005 public class TexturePainter : MonoBehaviour 
006 {
007       //Square texture with alpha
<span class="strong"><strong>008        public Texture2D BrushTexture = null;</strong></span>
009 
010       //Width and height of destination texture
011       public int SurfaceTextureWidth = 512;
012       public int SurfaceTextureHeight = 512;
013 
014      //Reference to painting surface texture
<span class="strong"><strong>015       public Texture2D SurfaceTexture = null;</strong></span>
016 
017      //Reference to material for destination texture 
<span class="strong"><strong>018      public Material DestMat = null;</strong></span>
019      //-------------------------------------------------
020      // Use this for initialization
021      void Start () 
022      {
023            //Create destination texture
024       SurfaceTexture = new Texture2D(SurfaceTextureWidth, SurfaceTextureHeight, TextureFormat.RGBA32, false);

025 
<span class="strong"><strong>026             //Fill with black pixels (transparent; alpha=0)</strong></span>
<span class="strong"><strong>027             Color[] Pixels = SurfaceTexture.GetPixels();</strong></span>
<span class="strong"><strong>028             for(int i=0; i&lt;Pixels.Length; i++)</strong></span>
<span class="strong"><strong>029                    Pixels[i] = new Color(0,0,0,0);</strong></span>
<span class="strong"><strong>030             SurfaceTexture.SetPixels(Pixels);</strong></span>
<span class="strong"><strong>031             SurfaceTexture.Apply();</strong></span>
032 
033            //Set as renderer main texture
034            renderer.material.mainTexture = SurfaceTexture;
035 
036            //If destination material, set blend texture 
037           //Used with custom shader
<span class="strong"><strong>038              if(DestMat)</strong></span>
<span class="strong"><strong>039       DestMat.SetTexture("_BlendTex", SurfaceTexture);</strong></span>
040       }
041       //--------------------------------------------------
042       // Update is called once per frame
043       void Update () 
044       {
045            //If mouse button down, then start painting
046            if(Input.GetMouseButtonDown(0))
047            {
048                   //Get hit of mouse cursor
049                   RaycastHit hit;
050 
051                   //Convert screen point to ray in scene
052      if (!Physics.Raycast(<span class="strong"><strong>Camera.main.ScreenPointToRay</strong></span>(Input.mousePosition), out hit))
053                          return;
054 
055                   //Get hit collider
056                   Renderer renderer = hit.collider.renderer;
057        MeshCollider Collide = hit.collider as MeshCollider;

058       if (renderer == null || renderer.sharedMaterial == null || renderer.sharedMaterial.mainTexture == null || Collide == null)
059                         return;
060 
061                   //Get UV Coords of hit surface
062                   Vector2 pixelUV = <span class="strong"><strong>hit.textureCoord;</strong></span>
063       pixelUV.x *= renderer.material.mainTexture.width;
064       pixelUV.y *= renderer.material.mainTexture.height;
065 
066       //Update coords to texture middle (align brush texture center to cursor)
067                   pixelUV.x -= BrushTexture.width/2;
068                   pixelUV.y -= BrushTexture.height/2;
069 
070             //Clamp pixel values between 0 and width
071      pixelUV.x = Mathf.Clamp(pixelUV.x, 0, renderer.material.mainTexture.width);

072      pixelUV.y = Mathf.Clamp(pixelUV.y, 0, renderer.material.mainTexture.height);
073 
074             //Paint onto destination texture
075      <span class="strong"><strong>PaintSourceToDestTexture</strong></span>(BrushTexture, renderer.material.mainTexture as Texture2D, (int)pixelUV.x, (int)pixelUV.y);
076             }
077      }
078      //--------------------------------------------------
079      //Paint source text to destination
080      //Will paint a brush texture onto a destination texture 
081      public static void PaintSourceToDestTexture(Texture2D Source, Texture2D Dest, int Left, int Top)
082       {
083             //Get source pixels
084             Color[] SourcePixels = Source.GetPixels();
085 
086             //Get dest pixels
087             Color[] DestPixels = Dest.GetPixels();
088 
089             for(int x=0; x&lt;Source.width; x++)
090             {
091                     for(int y=0; y&lt;Source.height; y++)
092                    {
093                         //Get source pixel
094      Color Pixel = GetPixelFromArray(SourcePixels, x, y, Source.width);

095 
096                          //Get offset in destination
097                          int DestOffsetX = Left + x;
098                          int DestOffsetY = Top + y;
099 
100      if(DestOffsetX &lt; Dest.width &amp;&amp; DestOffsetY &lt; Dest.height)

101      SetPixelInArray(DestPixels, DestOffsetX, DestOffsetY, Dest.width, Pixel, true);
102                    }
103            }
104 
105            //Update destination texture
106            Dest.SetPixels(DestPixels);
107            Dest.Apply();
108      }
109      //-------------------------------------------------------
110       //Reads color from pixel array
111       public static Color GetPixelFromArray(Color[] Pixels, int X, int Y, int Width)
112       {
113             <span class="strong"><strong>return Pixels[X+Y*Width];</strong></span>
114       }
115       //------------------------------------------------
116       //Sets color in pixel array
117        public static void SetPixelInArray(Color[] Pixels, int X, int Y, int Width, Color NewColor, bool Blending=false)
118       {
119             if(!Blending)
120                   <span class="strong"><strong>Pixels[X+Y*Width]</strong></span> = NewColor; 
121             else
122             {
123      //Here we blend the color onto existing surface, preserving alpha transparency

124      Color C = <span class="strong"><strong>Pixels[X+Y*Width]</strong></span> * (1.0f - NewColor.a);

125                   Color Blend = NewColor * NewColor.a;
126 
127                   Color Result = C + Blend;
128                    float Alpha = C.a + Blend.a;
129 
130       Pixels[X+Y*Width] = new Color(Result.r, Result.g, Result.b, Alpha);

131             }
132      }
133      //-------------------------------------------------
134 }
135 //-----------------------------------------------------------</pre></div><p>The following are the<a id="id692" class="indexterm"/> comments for code sample 9-5:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 008</strong></span>: The public variable in this line maintains a reference to a valid texture asset to be used as the brush graphic during paint operations. For each mouse click, this texture <a id="id693" class="indexterm"/>will be "laid down" or painted onto the variable <code class="literal">SurfaceTexture</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 015</strong></span>: <code class="literal">SurfaceTexture</code> will reference a dynamically generated texture filled, by default, with transparent pixels, which will reveal any texture layered beneath. This texture will accept all brush strokes during a paint operation. In short, this texture will be fed into the <code class="literal">TextureBlender</code> shader as the <code class="literal">_BlendTex</code> variable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 026-031</strong></span>: A new texture is generated during the <a id="id694" class="indexterm"/><code class="literal">Start</code> function. The texture is in the RGBA32 format, which supports an alpha channel. The <code class="literal">SetPixels</code> function<a id="id695" class="indexterm"/> is used to batch fill (flood fill) the texture with pixels of the same color. More information on the <code class="literal">GetPixels</code> and <code class="literal">SetPixels</code> functions are considered later.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 046</strong></span>: In the<a id="id696" class="indexterm"/> <code class="literal">Update</code> function, mouse clicks are detected to initiate the texture-painting functionality.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 048-059</strong></span>: If a mouse button is pressed, the function should paint the brush texture onto the destination. <code class="literal">Physics.Raycast</code> is called in line 52 to determine several<a id="id697" class="indexterm"/> things, such as to see whether a mesh object in the scene was hit by the ray. For this to work properly, the object should feature a <code class="literal">Collider</code> component.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 062-072</strong></span>: If a collision was detected, the UV coordinates of the hit location should be<a id="id698" class="indexterm"/> retrieved through the <code class="literal">textureCoord</code> variable of the <code class="literal">RaycastHit</code> structure. More information on this variable can be found online in the <a id="id699" class="indexterm"/>Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html">http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html</a>. This member, is only valid if the intersected mesh has <code class="literal">MeshCollider</code>, as opposed to other collider types, such as <code class="literal">BoxCollider</code> or <code class="literal">CapsuleCollider</code>. However, this means that any object used as a texture-painting destination should feature a <code class="literal">MeshCollider</code> component, since it contains UV data. Lines 63–72 then convert the UV coordinates into absolute pixel positions, centering the brush source texture at the position of the cursor. The result of this code is to clearly identify a position on the source brush texture that should be the pivot or origin point, and to establish a pixel <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinate location at which the source texture should be painted into the destination texture.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 075</strong></span>: Finally, the <code class="literal">PaintSourceToDestTexture</code> function is called to perform the paint operation itself.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 081</strong></span>: The <a id="id700" class="indexterm"/><code class="literal">PaintSourceToDestTexture</code> function accepts four arguments: <code class="literal">Source</code>, <code class="literal">Dest</code>, <code class="literal">Left</code>, and <code class="literal">Top</code>. On the basis of these, the <code class="literal">Source</code> texture is painted onto the <code class="literal">Dest</code> at the positions <code class="literal">Left</code> and <code class="literal">Top</code>. This function is declared as static, which means that no instance of this class needs to be declared.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 084-087</strong></span>: The first step in the texture-painting process is to retrieve all pixels in both the <code class="literal">Source</code> and <code class="literal">Dest</code> textures. This is achieved using the <code class="literal">GetPixels</code> function. More information on <a id="id701" class="indexterm"/><code class="literal">GetPixels</code> can be found online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html">http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html</a>. Now, although each image is visually a two-dimensional array of pixels, the returned array from <code class="literal">GetPixels</code> is in fact linear (one-dimensional). This is the reason for both the <code class="literal">GetPixelFromArray</code> and <code class="literal">SetPixelFromArray</code> functions, which convert pixel <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> positions into linear array indices.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 89-101</strong></span>: Here, each pixel is retrieved from the <code class="literal">Source</code> texture and painted onto the destination. This checks to ensure that the brush texture is painted with the destination bounds and allows clipping, if required. This is necessary because a brush mark could, in principle, be made close to the texture edge; in this case, only a part of the brush would actually be painted onto the destination, as some pixels would be "cut off". Pixels are retrieved from the <code class="literal">Source</code> texture with <code class="literal">GetPixelFromArray</code>, and destination pixels are set with <code class="literal">SetPixelInArray</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 106-107</strong></span>: Finally, the destination pixels are pushed back to the destination texture buffer, and the <code class="literal">Apply</code> function is called to confirm the operation. Unity also<a id="id702" class="indexterm"/> supports a <a id="id703" class="indexterm"/><code class="literal">SetPixel</code> function (singular) as opposed to <code class="literal">SetPixels</code> (plural). However, <code class="literal">SetPixels</code> results in better performance as it repeats the calling of <code class="literal">SetPixel</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 111-114</strong></span>: The<a id="id704" class="indexterm"/> <code class="literal">GetPixelFromArray</code> function accepts an array of pixel data as well as the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of a pixel and the pixel width of the texture data. On the basis of this, it returns a linear index into the pixel array where you can find the pixel color value.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 117-131</strong></span>: The<a id="id705" class="indexterm"/> <code class="literal">SetPixelInArray</code> function changes the color of a pixel in a linear array. The method of <a id="id706" class="indexterm"/>change is determined by the argument <code class="literal">Blending</code>. If <code class="literal">Blending</code> is set to <code class="literal">false</code>, the source pixel would simply replace the destination pixel. If <code class="literal">Blending</code> is <code class="literal">true</code>, the source pixel would be blended or layered onto the destination pixel that preserves the alpha transparency. <code class="literal">Blending</code> should be set to <code class="literal">true</code> when painting alpha-transparent brushes onto the target texture to allow for the accumulation and blending of color values.</li></ul></div></div><div class="section" title="Step 3 – setting up texture painting"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Step 3 – setting up texture painting</h2></div></div></div><p>Now that we have a<a id="id707" class="indexterm"/> working shader, texture-painting script, and configured textures, we'll take a step-by-step run-through of configuring texture painting in Unity. Start from an empty project, including only our shader, texture painting script, and two configured textures: a background texture and a brush texture, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_17.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Starting a texture-painting project</p></div></div><p>Configure the brush texture from the <span class="strong"><strong>Project</strong></span> panel to a small size (such as <code class="literal">32 x 32</code>) and set its <span class="strong"><strong>Format</strong></span> to <span class="strong"><strong>RGBA 32 bit</strong></span> for alpha<a id="id708" class="indexterm"/> transparency, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_09_18.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Configuring a brush texture</p></div></div><p>Create a new material using the <span class="strong"><strong>TextureBlender</strong></span> shader and assign the background texture to the <code class="literal">MainTexture</code> slot, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_19.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Creating a new material from our TextureBlender shader</p></div></div><p>Add a new <span class="strong"><strong>Quad</strong></span>, <span class="strong"><strong>Plane</strong></span>, or <span class="strong"><strong>Mesh</strong></span> to the scene and remove its collider, if any. This object will receive the final painted output, although the click detection will occur on a duplicate mesh. I am keeping the final <a id="id709" class="indexterm"/>output mesh and the click-detection mesh separate to allow the destination mesh to have other collider types or components if required.</p><p>Once the Quad has been added, assign the custom material to it with the <span class="strong"><strong>TextureBlender</strong></span> shader, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_20.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Adding a new Quad</p></div></div><p>Duplicate <span class="strong"><strong>Quad</strong></span>, add <span class="strong"><strong>Mesh Collider</strong></span>, disable <span class="strong"><strong>Mesh Renderer</strong></span>, and assign an empty diffuse material to it. This mesh will not render, but will detect mouse clicks and perform the paint operation.</p><p>In <a id="id710" class="indexterm"/>addition, add the <code class="literal">TexturePainter</code> script to the object and assign the <span class="strong"><strong>Brush Texture</strong></span> field to the brush texture itself and the <span class="strong"><strong>Dest Mat</strong></span> field to the <span class="strong"><strong>Custom_Mat</strong></span> material from the <span class="strong"><strong>Project</strong></span> panel, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_09_21.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Creating a click detection quad</p></div></div><p>Now, run the application<a id="id711" class="indexterm"/> and start clicking on your mesh. When you do, paint strokes will be applied to the texture and display on the viewport, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0655OT_09_22.jpg" alt="Step 3 – setting up texture painting"/><div class="caption"><p>Texture painting completed</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec94"/>Summary</h1></div></div></div><p>This chapter covered extensive ground under a general remit of "2D-ness". 2D was defined here not so much in the conventional sense of 2D games, but with a texture-based understanding that's critical to both 2D and 3D games more generally. The topics included the operations and ideas that pertain to the 2D plane and within the 2D space. Specifically, it explored how to create rotating Skybox backgrounds by building a manual Skybox, combined with the camera depth settings to create a layered render. Then, it explored how to generate procedural geometry such as planes. With the addition of Unity Quads as primitives, the generation of planes is more limited when taken alone, but the methods and concepts deployed to generate the Quad are more useful, allowing us to edit and tweak any mesh, whether it is a Quad or not. The real-time editing of meshes is important to create a wide range of effects, from shockwave explosions to jelly-based trampolines. Moving forward, we examined the animation of mesh UVs. They allowed us to scroll indefinitely across a 2D background Quad, with a tile-able texture, which is useful for parallax effects as well as for water and other motion-based illusions. Finally, we considered dynamic texture painting on a mesh, where, using the mouse, we can click on a mesh to paint a source texture onto the mesh texture that allows its UV coordinates and the alpha transparency to blend. This feature set is especially powerful and has wide applicability to create real-time decals, such as bullet holes, blood splatters, and player-based drawing. In the next chapter, we will consider a range of tips and techniques to work better with Unity projects.</p></div></body></html>