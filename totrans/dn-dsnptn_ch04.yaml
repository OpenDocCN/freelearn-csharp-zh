- en: Chapter 4. Targeting Multiple Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to create a library which will help application
    developers target their applications against SQL Server, SQLite, MySQL, and Oracle.
    As a result of creating this library, we will be able to write the application
    code without worrying about the underlying persistence technology. Even though
    ADO.NET does a wonderful job of abstracting away the nitty-gritties of a **relational
    database management system** (**RDBMS**), we need more than what is available
    as a stock feature within ADO.NET to write a database-agnostic persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, as a reader, you will learn to leverage
    the abstract factory pattern, factory pattern, and the adapter pattern to be able
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with various ADO.NET providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing persistence-store agnostic logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to an SQL Server database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to an ODBC data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirement statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we write business applications, our application should be able to persist
    to relational database engines from different database vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should be able to support SQL Server, SQLite, Oracle, or any database engine
    which supports ADO.net. Adding a new DB engine should be a breeze. Likewise, changing
    the database technology should be seamless for the application developer.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of ORM technologies like ADO.NET **Entity Framework** (**EF**)
    and **NHibernate**, writing an application which targets multiple database offerings
    has become easier. The authors believe that ADO.NET EF works in tandem with the
    Visual Studio environment and its tools, and would be difficult to deal with in
    a book meant for pattern oriented software development. For people from the Java
    world, who are accustomed to the Hibernate library, NHibernate flattens the learning
    curve. Despite its dwindling usage and popularity (reasons unknown) amidst .NET
    professionals, the authors feel that NHibernate is a viable option to write enterprise
    grade applications in. In this book, for the sake of simplicity, we will be using
    the ADO.NET programming model to isolate the database specificities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ADO.NET library is based on the following set of interfaces defined in
    the `System.Data` assembly from Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| `IDbConnection` | Interface for managing database connection specifics. |'
  prefs: []
  type: TYPE_TB
- en: '| `IDbCommand` | Interface for issuing SQL commands and queries. |'
  prefs: []
  type: TYPE_TB
- en: '| `IDbDataAdapter` | Interface for disconnected data access. |'
  prefs: []
  type: TYPE_TB
- en: '| `IDataReader` | Interface for cursor-based access to the database. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other interfaces which deal with the management of transactions, stored
    procedures, and associated parameter handling. We will ignore them in this book
    for the sake of shortening our code listings. Those can be incorporated into our
    library without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the aforementioned Interfaces is implemented by a provider written
    by the respective database vendor. Microsoft encourages independent vendors to
    write ADO.NET providers. The SQL Server implementation (`System.Data.SqlClient`)
    of these interfaces are named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlConnection` | Implementation of `IDbConnection` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlCommand` | Implementation of `IDbCommand` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlDataAdapter` | Implementation of `IDbAdapter` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlDataReader` | Implementation of `IDataReader` interface. |'
  prefs: []
  type: TYPE_TB
- en: 'In the case of `System.Data.SQLite`, the scheme is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| `SQLiteConnection` | Implementation of `IDbConnection` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SQLiteCommand` | Implementation of `IDbCommand` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SQLitelDataAdapter` | Implementation of `IDbAdapter` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `SQLiteDataReader` | Implementation of `IDataReader` interface. |'
  prefs: []
  type: TYPE_TB
- en: Similar provider classes are implemented by Oracle and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be using the GoF catalog's abstract factory methods to instantiate standard
    ADO.NET-library-specific interfaces for connection, command, data adapter, and
    reader. The abstract factory pattern is a creational pattern which provides an
    interface for creating families of related or dependent objects without specifying
    their concrete classes.
  prefs: []
  type: TYPE_NORMAL
- en: A quick primer on ADO.net
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are using ADO.net API for accessing databases, a couple of code snippets
    will be of help to comprehend the following sections. There are two ways to write
    code using the ADO.net API. We can directly use the concrete classes to access
    the database content. The following code snippet shows how one can write code
    against SQLite using `SQliteConnection`, `SQliteCommand` and `SQliteDataReader` and
    so on. Similar code can be written for SQL Server, MySQL and Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code snippet leverages the concrete classes provided. If we want
    to write code in a generic manner, we can program against the interfaces like
    `IDbConnection`, `IDbCommand` and `IDbDataReader` etc. The following code snippet
    demonstrates the technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The abstract factory pattern and object instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our case, the abstract factory pattern is pertinent, as we are supposed
    to create a set of related classes based on the ADO.NET defined interfaces. For
    this very purpose, we will define an abstract class with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![The abstract factory pattern and object instantiation](img/B05691_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding interface, we have methods to create connection object, command
    object, data adapter object, and data reader object. These classes are related,
    and concrete classes are for each of the database offerings. The concrete classes
    make calls to the corresponding ADO.NET driver.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL server implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SQL Server implementation of abstract factory uses the default provider
    given by Microsoft Corporation. We need to include the `System.Data.SqlClient`
    namespace in our projects to utilize the objects in the provider namespace. Though
    the code given warrants more robust and defensive programming practices mandated
    for an industrial strength implementation, it provides clarity and is a good template
    for such an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The SQLite implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQLite implementation uses the ADO.NET provider maintained by the SQLite
    implementation team. To include that, we need to download assemblies from the
    [https://system.data.sqlite.org](https://system.data.sqlite.org/) site. We need
    to also include `sqlite3.dll` available on the SQLite site.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use nuget to install it via the Package Manager Console as `PM>
    Install-Package System.Data.SQLite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Oracle and ODBC implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Microsoft has deprecated the `System.Data.OracleClient` interface, we
    need to download ADO.NET providers from the Oracle Corporation site. Incorporating
    Oracle into the mix is similar to the way we did for SQL Server and SQLite. Since
    Oracle supports ODBC, we use an ODBC ADO.NET provider through the `System.Data.Oledb`
    namespace to interact with the other databases. The implementation is available
    as part of the source code downloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the abstract factories in action (though
    only one has been labeled):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Oracle and ODBC implementation](img/B05691_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The adapter pattern powered API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GOF Adapter pattern is useful for us in this context to provide a unified
    programming model for the consumers of the sub system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Adapter pattern is a structural pattern which works as a bridge between
    different interfaces or different implementations of an interface. In our case,
    we will use the adapter pattern as a bridge between application developers and
    various implementations of `DbAstractFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create an **Application Program Interface** (**API**) for the application
    software developer to leverage different implementations based on a configuration
    entry. We will create a C# interface, which an adapter class needs to implement,
    to act as an API. At this point in time, we have only one instance of the adapter
    class. In future, we can have adapters for different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The adapter class Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement an adapter class which will help us to seamlessly integrate
    multiple database engines with our application. For implementing the adapter class,
    we will leverage the object factory (`ObjectFactory`) implementation from the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We leverage the factory method infrastructure created in [Chapter 3](dn-dsnptn_ch03.html
    "Chapter 3. A Logging Library"), *A Logging Library* to help instantiate the proper
    concrete implementation of `DbAstractFactory`. The `DbDrivers.xml` configuration
    file contains the necessary information to instantiate the concrete classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes two parameters, that is, connection string and driver
    name. Using the driver name as the key, the appropriate implementation of ADO.NET
    will be instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Open` method creates the connection object through the abstract factory
    concrete implementation. Once the connection object has been created, the ADO.NET
    connection is opened. The application developer should then make a call to `Open`
    method of the current class before calling any other method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Execute` method helps one to dispatch an SQL string to the selected database
    engine, and returns a dataset. This method is also used for disconnected access
    where an application wants to retrieve a small set of data to be populated in
    a user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExecuteQuery` method helps one to dispatch an SQL query to a database,
    and retrieve a data reader object which will help one to navigate one record at
    a time. This is called cursor-based access, and is suitable for queries which
    return a large dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExecuteNonQuery` method is meant to insert, update, or delete records
    from the table. It does not return any value. In other words, the method is called
    for mutable operations on a relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Close` method, as indicated, closes the database connection. The adapter
    class can be instantiated inside the application code using the following schema.
    All we need is a connection string and a driver name (`SQLITE`, `SQLSERVER`, and
    so on) to instantiate the object. Once we have instantiated the object, we can
    dispatch an arbitrary query against the chosen database engine as indicated in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The adapter configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The drivers for the respective database engines are configured via an XML file
    (`DbDrivers.xml`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we want to target a new database, we need to create a concrete class which
    implements the abstract factory interface, and add an entry to this configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The client program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can write a client program to test this logic. The code for inserting an
    entry to a database of your choice is given next. We have chosen SQLite initially
    for the sake of simplicity. Since SQLite is a server-less database engine, we
    can embed an SQLite DB as part of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve data from a table, we can use either the disconnected recordset
    model or cursor model. When we are dealing with large datasets, especially for
    reports, using the cursor model is preferred. For scenarios where we need to edit
    a small set of data through some control, a disconnected set is preferred. The
    following code demonstrates how one can use the disconnected recordset for retrieving
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataReader` interface of ADO.NET is meant for cursor-based access to the
    database. This helps one to iterate through the data which satisfies some criteria.
    Reporting applications are a typical use case for cursor-based access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` program which invokes these helper routines is given next. The initial
    code snippet shows how to use SQLite as a target database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the SQL Server, one needs to make changes to the connection string.
    Since the connection string is specific to the SQL Server installation (which
    a reader will have), the general scheme of invoking the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following UML diagram illustrates the key set of patterns in action for
    the **Database Access Library** (**DAL**) API that we have built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The client program](img/B05691_04_03-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a reusable DAL to target different relational database
    offerings available for persistence. The library leverages the Microsoft ADO.NET
    programming model to implement database-agnostic persistence. In the process,
    you learned about the abstract factory pattern, adapter pattern, and revisited
    factory method pattern. You also understood the difference between the factory
    method and the abstract factory pattern. In the next chapter, we will write a
    document object library which will help one save data contents to different formats
    like PDF, SVG, and HTML. In that process, you will learn about the composite design
    pattern and visitor pattern.
  prefs: []
  type: TYPE_NORMAL
