- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Effective Game Data Handling and Management with C# in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Unity 中使用 C# 进行有效的游戏数据处理和管理
- en: Welcome to [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), where we’ll delve
    into effective game data handling and management using C# in Unity. Through practical
    exploration, you’ll learn how to organize, store, and retrieve game data seamlessly.
    From understanding data organization and serialization to implementing save and
    load systems, you’ll be able to empower players to preserve their progress and
    craft dynamic, data-driven gameplay experiences. By the end of this chapter, you’ll
    have mastered the art of wielding C# for efficient game data management, unlocking
    endless possibilities for immersive gameplay. Let’s embark on this journey together,
    where mastery of game data opens doors to boundless creativity in game development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [*第 6 章*](B22017_06.xhtml#_idTextAnchor098)，我们将深入探讨在 Unity 中使用 C# 进行有效的游戏数据处理和管理。通过实际探索，您将学习如何无缝地组织、存储和检索游戏数据。从理解数据组织和序列化到实现保存和加载系统，您将能够赋予玩家保存进度并构建动态、数据驱动的游戏体验的能力。到本章结束时，您将掌握使用
    C# 进行高效游戏数据管理的艺术，解锁沉浸式游戏的无尽可能性。让我们共同踏上这段旅程，掌握游戏数据管理将开启游戏开发中无限创造力的门户。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Data organization and serialization with C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 进行数据组织和序列化
- en: Creating save and load systems using C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 创建保存和加载系统
- en: Data-driven gameplay with C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 的数据驱动游戏玩法
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you must have the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您必须具备以下条件：
- en: '**Unity version 2022.3.13**: Download and install Unity, choosing version **2022.3.13**
    for optimal compatibility with the provided content.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 版本 2022.3.13**：下载并安装 Unity，选择 **2022.3.13** 版本以获得与提供内容的最优兼容性。'
- en: '**Primary IDE – Visual Studio 2022**: The tutorials and code samples in this
    chapter have been crafted using Visual Studio 2022\. Ensure it’s installed so
    that you can follow along seamlessly. Feel free to explore Rider or other IDEs
    if you prefer, though note that the instructions that have been provided are tailored
    for Visual Studio.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要 IDE – Visual Studio 2022**：本章中的教程和代码示例都是使用 Visual Studio 2022 制作的。请确保已安装，以便您可以无缝地跟随。如果您更喜欢
    Rider 或其他 IDE，请随意探索，但请注意，提供的说明是为 Visual Studio 定制的。'
- en: '**GitHub repository for code samples**: You can access the code samples and
    project files for this chapter via this book’s dedicated GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006).
    Clone or download the repository so that you have easy access to the code provided
    in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码示例的 GitHub 仓库**：您可以通过本书的专用 GitHub 仓库访问本章的代码示例和项目文件：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006)。克隆或下载仓库，以便您可以轻松访问本章提供的代码。'
- en: Data organization and serialization with C#
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 进行数据组织和序列化
- en: In this section, we’ll dive into data organization and serialization with C#
    in Unity. Here, we’ll learn how to manage game data efficiently. First, we’ll
    talk about picking the right data structures, such as arrays and lists, and how
    to make your own. Then, we’ll cover serialization, which helps save and load game
    data. Then, we’ll explore Unity’s options, such as **JavaScript Object Notation**
    (**JSON**) and **eXtensible Markup Language** (**XML**). By covering some simple
    examples, we’ll show you how to organize and save game data neatly using C#. Let’s
    start learning how to master game data management!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨 Unity 中使用 C# 进行数据组织和序列化。在这里，我们将学习如何高效地管理游戏数据。首先，我们将讨论选择合适的数据结构，例如数组和列表，以及如何创建自己的数据结构。然后，我们将介绍序列化，它有助于保存和加载游戏数据。接着，我们将探索
    Unity 的选项，例如 **JavaScript 对象表示法**（**JSON**）和 **可扩展标记语言**（**XML**）。通过一些简单的示例，我们将向您展示如何使用
    C# 整洁地组织和保存游戏数据。让我们开始学习如何掌握游戏数据管理吧！
- en: Understanding data structures
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据结构
- en: 'Selecting the appropriate data structure for storing information in your game
    involves considering factors such as the type of data, how frequently it will
    be accessed, and the operations you need to perform on that data. Here are some
    examples to illustrate how you can choose the right method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合你在游戏中存储信息的数据结构需要考虑诸如数据类型、访问频率以及你需要对该数据进行哪些操作等因素。以下是一些示例，说明你可以如何选择正确的方法：
- en: '**Arrays**: Use arrays when you have a fixed-size collection of elements of
    the same type.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：当你有一个固定大小的相同类型元素集合时，请使用数组。'
- en: 'For instance, if you have a game with a set number of levels, as shown in the
    following code, you might use an array to store level data, such as scores or
    the completion status for each level:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比如，如果你有一个具有固定等级数量的游戏，如下面的代码所示，你可能使用数组来存储等级数据，例如每个等级的分数或完成状态：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Lists**: Lists are dynamic arrays that can grow or shrink in size at runtime.
    They are suitable when you need to add or remove elements frequently.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：列表是动态数组，可以在运行时增长或缩小。当你需要频繁地添加或删除元素时，它们是合适的。'
- en: 'For example, if you have a game with an inventory system where items can be
    added or removed dynamically, a list would be more appropriate. Take a look at
    the following code for an example:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你有一个具有动态添加或删除物品的库存系统的游戏，列表会更合适。看看以下代码的例子：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Dictionaries**: Dictionaries are useful when you need to associate keys with
    values. They are ideal for situations where you need to quickly look up values
    based on specific keys.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：当你需要将键与值关联时，字典很有用。它们在需要根据特定键快速查找值的情况下非常理想。'
- en: 'For instance, if you have a game with a leaderboard, you might use a dictionary
    to map player names to their scores, as shown here:'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比如，如果你有一个排行榜的游戏，你可能使用字典将玩家名字映射到他们的分数，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Custom data structures**: Sometimes, none of the built-in data structures
    are the perfect fit for your needs. In such cases, you can create custom data
    structures tailored to your specific requirements.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义数据结构**：有时，内置的数据结构都不完全适合你的需求。在这种情况下，你可以创建定制的、符合你特定要求的数据结构。'
- en: 'For example, if you’re developing a complex RPG game, you might create a custom
    data structure to represent character attributes and abilities. The **Character**
    class is one such custom data structure:'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果你正在开发一个复杂的角色扮演游戏（RPG），你可能创建一个自定义数据结构来表示角色属性和能力。**Character**类就是这样一种自定义数据结构：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By carefully considering the nature of your data and the operations you need
    to perform, you can choose the most appropriate data structure for your game,
    ensuring optimal performance and efficient data management.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细考虑你的数据和你需要执行的操作，你可以为你的游戏选择最合适的数据结构，确保最佳性能和高效的数据管理。
- en: Enhancing game performance with proper data structure selection
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过适当选择数据结构来增强游戏性能
- en: In the world of game creation, where speed and efficiency matter most, picking
    the right data structures is crucial. It helps game makers achieve smoother and
    faster gameplay, making their games more enjoyable for players.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏制作的世界里，速度和效率最为重要，选择合适的数据结构至关重要。这有助于游戏制作者实现更流畅、更快的游戏体验，使他们的游戏对玩家来说更加有趣。
- en: 'Choosing the appropriate data structure can significantly benefit game performance
    in several ways:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的数据结构可以从几个方面显著提高游戏性能：
- en: '**Optimized memory usage**: Using the right data structure helps minimize memory
    usage, which is crucial for performance, especially in resource-intensive games.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化内存使用**：使用正确的数据结构有助于最小化内存使用，这对于性能至关重要，尤其是在资源密集型游戏中。'
- en: For example, if your game only needs to store a fixed number of elements of
    the same type, using an array instead of a list can save memory because arrays
    have a fixed size.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果你的游戏只需要存储固定数量的相同类型元素，使用数组而不是列表可以节省内存，因为数组具有固定的大小。
- en: '**Faster access and retrieval**: Certain data structures offer faster access
    and retrieval times, which can improve overall game responsiveness.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的访问和检索**：某些数据结构提供了更快的访问和检索时间，这可以提高整体游戏响应速度。'
- en: For instance, dictionaries provide constant-time lookups, making them ideal
    for scenarios where you need to quickly retrieve values based on keys, such as
    accessing player data in a leaderboard.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比如，字典提供了常数时间的查找，这使得它们在需要根据键快速检索值的情况下非常理想，例如在排行榜中访问玩家数据。
- en: '**Efficient data manipulation**: Choosing the appropriate data structure can
    streamline data manipulation operations, leading to smoother gameplay experiences.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效的数据操作**：选择合适的数据结构可以简化数据操作，从而带来更流畅的游戏体验。'
- en: Lists, for example, allow for efficient insertion and removal of elements, making
    them suitable for dynamic scenarios such as managing an inventory where items
    are frequently added or removed.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，列表允许高效地插入和删除元素，这使得它们适合动态场景，如管理经常添加或删除物品的库存。
- en: '**Enhanced code readability and maintainability**: Using the right data structure
    can make your code more readable and maintainable, leading to easier debugging
    and future updates. Custom data structures tailored to your game’s specific needs
    can improve code organization and clarity, making it easier for you and other
    developers to understand and modify the code base.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强代码可读性和可维护性**：使用合适的数据结构可以使你的代码更易于阅读和维护，从而简化调试和未来的更新。针对游戏特定需求定制的自定义数据结构可以改善代码组织性和清晰度，使你和其他开发者更容易理解和修改代码库。'
- en: For instance, if your game includes challenges, you can design a custom class
    specifically for managing these challenges. Within this class, you can incorporate
    attributes such as a list of rewards and a unique identifier for each challenge.
    This approach enhances the readability of your code base.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果你的游戏包含挑战，你可以设计一个专门用于管理这些挑战的自定义类。在这个类中，你可以包含诸如奖励列表和每个挑战的唯一标识符等属性。这种方法增强了代码库的可读性。
- en: '**Reduced processing overhead**: Optimal data structures help reduce processing
    overhead, contributing to smoother gameplay and better overall performance.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少处理开销**：最佳数据结构有助于减少处理开销，从而带来更流畅的游戏体验和更好的整体性能。'
- en: For example, if your game needs to iterate through a collection of elements
    in a specific order, using a list instead of a dictionary can eliminate unnecessary
    key-value pair lookups, resulting in faster iteration times.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果你的游戏需要按特定顺序遍历元素集合，使用列表而不是字典可以消除不必要的键值对查找，从而缩短迭代时间。
- en: In summary, selecting the appropriate data structure is critical for optimizing
    game performance as it helps minimize memory usage, improve access times, streamline
    data manipulation, enhance code readability, and reduce processing overhead. By
    understanding the characteristics and advantages of different data structures,
    game developers can design more efficient and responsive gameplay experiences
    for players.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，选择合适的数据结构对于优化游戏性能至关重要，因为它有助于最小化内存使用，提高访问时间，简化数据操作，增强代码可读性，并减少处理开销。通过了解不同数据结构的特性和优势，游戏开发者可以为玩家设计更高效和响应迅速的游戏体验。
- en: In the upcoming subsection, we’ll delve deeper into Unity’s serialization, exploring
    its role in efficiently saving and loading data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将更深入地探讨Unity的序列化，探讨其在高效保存和加载数据中的作用。
- en: Serialization in Unity
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中的序列化
- en: '**Serialization** is the process of converting complex objects or data structures
    into a format that can be easily stored or transmitted and then reconstructed
    later. In the context of Unity game development, serialization plays a crucial
    role in saving and loading game data. By serializing game objects and their properties,
    Unity can store them in a format that can be saved to disk or transferred over
    the network, allowing for persistence between sessions and enabling features such
    as saving games and networked multiplayer.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将复杂对象或数据结构转换为易于存储或传输的格式，并在以后重新构造的过程。在Unity游戏开发中，序列化在保存和加载游戏数据方面发挥着关键作用。通过序列化游戏对象及其属性，Unity可以将它们存储为可以保存到磁盘或通过网络传输的格式，从而实现会话间的持久性，并启用保存游戏和网络多人游戏等功能。'
- en: 'Serialization is a fundamental aspect of game development for several reasons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是游戏开发的一个基本方面，原因有以下几点：
- en: '**Persistence between sessions**: Serialization allows game state and player
    progress to be saved and loaded between gameplay sessions. This enables features
    such as saving and loading game progress, maintaining player inventories, and
    preserving game settings.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话间的持久性**：序列化允许游戏状态和玩家进度在游戏会话之间保存和加载。这使得保存和加载游戏进度、维护玩家库存和保留游戏设置等功能成为可能。'
- en: '**Network communication**: Serialization facilitates transmitting game data
    over the network, which is essential for multiplayer games, client-server architectures,
    and online features. By serializing game objects and messages, Unity can send
    data between clients and servers efficiently.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络通信**：序列化有助于在网络中传输游戏数据，这对于多人游戏、客户端-服务器架构和在线功能至关重要。通过序列化游戏对象和消息，Unity可以高效地在客户端和服务器之间发送数据。'
- en: '**Data interchange**: Serialization allows data to be exchanged between different
    systems and platforms. For example, game data can be serialized into a standardized
    format such as JSON or XML, allowing it to be shared with other applications or
    integrated with web services.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据交换**：序列化允许数据在不同系统和平台之间交换。例如，游戏数据可以序列化为标准化的格式，如JSON或XML，使其能够与其他应用程序共享或与网络服务集成。'
- en: '**Data persistence**: Serialization allows data to be stored in a structured
    format, such as files or databases, ensuring that it persists even when the game
    isn’t running. This is crucial for features such as saving and loading user preferences,
    high scores, and game configurations.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据持久性**：序列化允许数据以结构化格式（如文件或数据库）存储，确保即使在游戏不运行时数据也能持久存在。这对于保存和加载用户偏好、高分和游戏配置等功能至关重要。'
- en: By understanding the principles of serialization and mastering Unity’s serialization
    options, we can implement robust and flexible data management systems, enabling
    features such as save games, networked multiplayer, and data-driven gameplay mechanics.
    Serialization is a fundamental tool in our toolkit, empowering us to create immersive
    and dynamic gaming experiences across platforms and genres.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解序列化的原理并掌握Unity的序列化选项，我们可以实现强大且灵活的数据管理系统，实现如保存游戏、网络多人游戏和数据驱动游戏机制等功能。序列化是我们工具箱中的基本工具，使我们能够创建跨平台和类型的沉浸式和动态游戏体验。序列化是我们工具箱中的基本工具，赋予我们创建跨平台和类型的沉浸式和动态游戏体验的能力。
- en: In Unity, serialization is seamlessly integrated into the engine’s workflow,
    allowing us to easily save and load game data using built-in APIs and utilities.
    Unity provides various serialization options, including JSON, XML, and binary
    serialization, each suited to different use cases and requirements. As we can
    see in this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，序列化无缝集成到引擎的工作流程中，使我们能够轻松地使用内置的API和实用工具保存和加载游戏数据。Unity提供了各种序列化选项，包括JSON、XML和二进制序列化，每个都适合不同的用例和需求。正如我们在这个部分所看到的。
- en: Let’s explore the options that are available in Unity so that we can integrate
    them into our game. We’ll begin by defining each option and providing an example
    for better understanding. We’ll delve into each one and illustrate their usage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索Unity中可用的选项，以便我们将它们集成到我们的游戏中。我们将从定义每个选项并提供示例以更好地理解开始。我们将深入探讨每一个，并展示它们的用法。
- en: JSON serialization and deserialization
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON序列化和反序列化
- en: JSON is a lightweight data-interchange format that is commonly used for transmitting
    data between a server and a web application. In Unity, JSON serialization and
    deserialization are useful for scenarios where you need to exchange data with
    external systems or web services.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种轻量级的数据交换格式，常用于在服务器和Web应用程序之间传输数据。在Unity中，JSON序列化和反序列化对于需要与外部系统或网络服务交换数据的场景非常有用。
- en: '*Example*: In the following code block, we’re utilizing Unity’s built-in system
    to serialize and deserialize data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：在下面的代码块中，我们正在使用Unity内置的系统来序列化和反序列化数据：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: XML serialization and deserialization
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML序列化和反序列化
- en: XML is a versatile format that is used for data exchange and configuration settings.
    Unity supports XML serialization and deserialization, making it suitable for scenarios
    where you need to work with legacy systems or integrate with platforms that use
    XML as the data interchange format.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: XML是一种多用途的格式，用于数据交换和配置设置。Unity支持XML序列化和反序列化，使其适用于需要与遗留系统或使用XML作为数据交换格式的平台集成的场景。
- en: '*Example*: The following code block demonstrates how to serialize and deserialize
    data to and from XML.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：以下代码块演示了如何将数据序列化和反序列化到XML。'
- en: 'To utilize this type of serialization, you must include the `using System.IO;`
    and `using System.Xml.Serialization;` namespaces, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种类型的序列化，您必须包含`using System.IO;`和`using System.Xml.Serialization;`命名空间，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s take a closer look at the XML serialization and deserialization provided
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这里提供的XML序列化和反序列化：
- en: '**Serialization process**:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化过程**：'
- en: Serialization is the process of converting an object into a format that can
    be easily stored or transmitted and reconstructed later
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化是将对象转换为易于存储或传输的格式，并在以后重建的过程。
- en: '**XmlSerializer** is a class provided by the .NET framework for serializing
    and deserializing objects to and from XML format'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XmlSerializer** 是 .NET 框架提供的一个类，用于将对象序列化和反序列化为 XML 格式。'
- en: '**XmlSerializer serializer = new XmlSerializer(typeof(MyClass));**: This line
    creates an instance of the **XmlSerializer** class that specifies the type of
    object (**MyClass**) to be serialized'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XmlSerializer serializer = new XmlSerializer(typeof(MyClass));**: 这行代码创建一个
    **XmlSerializer** 类的实例，指定要序列化的对象类型（**MyClass**）。'
- en: '**StringWriter writer = new StringWriter();**: This line creates a **StringWriter**
    object, which is used to write XML content as a string'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StringWriter writer = new StringWriter();**: 这行代码创建一个 **StringWriter** 对象，用于将
    XML 内容作为字符串写入。'
- en: '**serializer.Serialize(writer, myObject);**: This line serializes the **myObject**
    instance of **MyClass** into XML format and writes it to **StringWriter**'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**serializer.Serialize(writer, myObject);**: 这行代码将 **MyClass** 类型的 **myObject**
    实例序列化为 XML 格式，并将其写入 **StringWriter**。'
- en: '**string xmlString = writer.ToString();**: This line converts the XML content
    written to **StringWriter** into a string representation and stores it in the
    **xmlString** variable'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**string xmlString = writer.ToString();**: 这行代码将写入到 **StringWriter** 的 XML
    内容转换为字符串表示形式，并存储在 **xmlString** 变量中。'
- en: '**Deserialization process**:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化过程**：'
- en: Deserialization is the process of reconstructing an object from its serialized
    XML representation.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化是从其序列化的 XML 表示形式重建对象的过程。
- en: '**StringReader reader = new StringReader(xmlString);**: This line creates a
    **StringReader** object, which is used to read XML content from a string.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StringReader reader = new StringReader(xmlString);**: 这行代码创建一个 **StringReader**
    对象，用于从字符串中读取 XML 内容。'
- en: '**(MyClass)serializer.Deserialize(reader);**: This line deserializes the XML
    content from **StringReader** back into an object of the **MyClass** type. The
    **Deserialize** method of the **XmlSerializer** class is used for this purpose.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(MyClass)serializer.Deserialize(reader);**: 这行代码将 **StringReader** 中的 XML
    内容反序列化为 **MyClass** 类型的对象。此操作使用 **XmlSerializer** 类的 **Deserialize** 方法完成。'
- en: The deserialized object is then assigned to the **deserializedObject** variable,
    ready for use in the program.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化的对象随后被分配给 **deserializedObject** 变量，以便在程序中使用。
- en: In summary, the provided code block demonstrates how to serialize an object
    of the `MyClass` type as an XML string and then deserialize the XML string back
    into an object of the same type using the `XmlSerializer` class in C#. This process
    allows objects to be easily persisted to storage or transmitted over a network
    in XML format and reconstructed later for use in the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，提供的代码块演示了如何使用 C# 中的 `XmlSerializer` 类将 `MyClass` 类型的对象序列化为 XML 字符串，然后使用
    `XmlSerializer` 类将 XML 字符串反序列化为相同类型的对象。这个过程允许对象以 XML 格式轻松持久化到存储或通过网络传输，并在以后重建以供应用程序使用。
- en: Binary serialization and deserialization
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制序列化和反序列化
- en: Binary serialization and deserialization are ideal for scenarios where you need
    to save and load game data efficiently, such as implementing save games or storing
    configuration settings locally on the user’s device. Binary serialization provides
    a compact representation of data and faster read/write times compared to text-based
    formats such as JSON or XML.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制序列化和反序列化非常适合需要高效保存和加载游戏数据的场景，例如实现游戏保存或在本机设备上存储配置设置。与基于文本的格式（如 JSON 或 XML）相比，二进制序列化提供了数据紧凑的表示形式，并且读写速度更快。
- en: '*Example*: The following code block shows how to serialize and deserialize
    data to and from binary format.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：以下代码块展示了如何将数据序列化和反序列化为二进制格式。'
- en: 'To utilize this type of serialization, you must include the `using System.IO;`
    and `using System.Runtime.Serialization.Formatters.Binary;` namespaces, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此类序列化，必须包含 `using System.IO;` 和 `using System.Runtime.Serialization.Formatters.Binary;`
    命名空间，如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s take a closer look at this code block:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个代码块：
- en: '**Serialization process**:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化过程**：'
- en: Serialization is the process of converting an object into a format that can
    be easily stored or transmitted and reconstructed later
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化是将对象转换为易于存储或传输的格式，并在以后重建的过程。
- en: '**BinaryFormatter** is a class provided by the .NET framework for serializing
    and deserializing objects to and from binary format'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BinaryFormatter** 是 .NET 框架提供的一个类，用于将对象序列化和反序列化为二进制格式。'
- en: '**BinaryFormatter formatter = new BinaryFormatter();**: This line creates an
    instance of the **BinaryFormatter** class, which is used for binary serialization'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BinaryFormatter formatter = new BinaryFormatter();**: 这行代码创建了一个 **BinaryFormatter**
    类的实例，用于二进制序列化'
- en: '**MemoryStream stream = new MemoryStream();**: This line creates a **MemoryStream**
    object, which is used to store binary data in memory'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MemoryStream stream = new MemoryStream();**: 这行代码创建了一个 **MemoryStream** 对象，用于在内存中存储二进制数据'
- en: '**formatter.Serialize(stream, myObject);**: This line serializes the **myObject**
    instance into binary format and writes it to **MemoryStream**'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**formatter.Serialize(stream, myObject);**: 这行代码将 **myObject** 实例序列化为二进制格式并写入
    **MemoryStream**'
- en: '**byte[] binaryData = stream.ToArray();**: This line converts the binary data
    written to **MemoryStream** into a byte array, which can be easily stored or transmitted'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**byte[] binaryData = stream.ToArray();**: 这行代码将写入到 **MemoryStream** 的二进制数据转换为字节数组，可以轻松存储或传输'
- en: '**Deserialization process**:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化过程**:'
- en: Deserialization is the process of reconstructing an object from its serialized
    binary representation.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化是从其序列化的二进制表示中重建对象的过程。
- en: '**stream = new MemoryStream(binaryData);**: This line creates a new **MemoryStream**
    object, initialized with the binary data stored in the **binaryData** byte array.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stream = new MemoryStream(binaryData);**: 这行代码创建了一个新的 **MemoryStream** 对象，初始化时使用存储在
    **binaryData** 字节数组中的二进制数据。'
- en: '**(MyClass)formatter.Deserialize(stream);**: This line deserializes the binary
    data from the **MemoryStream** back into an object of the **MyClass** type. The
    **Deserialize** method of the **BinaryFormatter** class is used for this purpose.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(MyClass)formatter.Deserialize(stream);**: 这行代码将 **MemoryStream** 中的二进制数据反序列化为
    **MyClass** 类型的对象。这里使用 **BinaryFormatter** 类的 **Deserialize** 方法。'
- en: The deserialized object is then assigned to the **deserializedObject** variable,
    ready for use in the program.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化的对象随后被分配给 **deserializedObject** 变量，以便在程序中使用。
- en: In summary, the preceding code block demonstrates how to serialize an object
    of the `MyClass` type to binary format and then deserialize the binary data back
    into an object of the same type using the `BinaryFormatter` class in C#. This
    process allows objects to be easily persisted to storage or transmitted over a
    network in binary format and reconstructed later for use in the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，前面的代码块展示了如何使用 C# 中的 `BinaryFormatter` 类将 `MyClass` 类型的对象序列化为二进制格式，然后将二进制数据反序列化为同一类型的对象。这个过程允许对象以二进制格式轻松持久化到存储或通过网络传输，并在稍后重建以供应用程序使用。
- en: ScriptableObject serialization
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ScriptableObject 序列化
- en: '**ScriptableObjects** are Unity assets that allow you to store data in a serialized
    format and create custom editor interfaces for modifying that data in Unity Editor.
    They are useful for managing configuration settings, defining game parameters,
    and creating reusable components that can be shared across multiple game objects.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScriptableObjects** 是 Unity 资产，允许你在序列化格式中存储数据，并在 Unity 编辑器中创建用于修改该数据的自定义编辑器界面。它们对于管理配置设置、定义游戏参数以及创建可在多个游戏对象之间共享的可重用组件非常有用。'
- en: '*Example*: In the following code blocks, we will explore an example of scriptable
    object data. Then, we’ll demonstrate how to utilize serialization and deserialization
    with scriptable objects.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*: 在下面的代码块中，我们将探索脚本对象数据的示例。然后，我们将演示如何使用脚本对象进行序列化和反序列化。'
- en: 'The first code block contains a ScriptableObject that’s designed for game settings,
    encapsulating essential data relevant to the game’s operation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码块包含一个用于游戏设置的 ScriptableObject，封装了与游戏操作相关的必要数据：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the second code block, the `SettingsManager` class contains a reference
    to the `GameSettings` data and includes functions for saving and loading settings:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个代码块，`SettingsManager` 类包含对 `GameSettings` 数据的引用，并包括保存和加载设置的函数：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s take a closer look at the `SettingsManager` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `SettingsManager` 类：
- en: 'The **SaveSettings()** method:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaveSettings()** 方法:'
- en: '**public void** **SaveSettings() { ... }**: This method is responsible for
    saving the game settings to a file'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void** **SaveSettings() { ... }**: 这个方法负责将游戏设置保存到文件'
- en: '**JsonUtility.ToJson(gameSettings)**: This method serializes the **gameSettings**
    object to JSON format'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JsonUtility.ToJson(gameSettings)**: 这个方法将 **gameSettings** 对象序列化为 JSON 格式'
- en: '**System.IO.File.WriteAllText(...)**: This method writes the serialized JSON
    data to a file named **settings.json** in the persistent data path of the application'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System.IO.File.WriteAllText(...)**: 这个方法将序列化的 JSON 数据写入应用程序持久数据路径中名为 **settings.json**
    的文件'
- en: 'The **LoadSettings()** method:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadSettings()** 方法：'
- en: '**public void LoadSettings() { ... }**: This method is responsible for loading
    the game settings from a file'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void LoadSettings() { ... }**：此方法负责从文件中加载游戏设置'
- en: '**System.IO.File.Exists(...)**: This method checks if the **settings.json**
    file exists in the persistent data path'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System.IO.File.Exists(...)**：此方法检查持久数据路径中是否存在 **settings.json** 文件'
- en: '**System.IO.File.ReadAllText(...)**: This method reads the JSON data from the
    **settings.json** file'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System.IO.File.ReadAllText(...)**：此方法从 **settings.json** 文件中读取 JSON 数据'
- en: '**JsonUtility.FromJson<GameSettings>(jsonSettings)**: This method deserializes
    the JSON data back into a **GameSettings** object and assigns it to the **gameSettings**
    variable'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JsonUtility.FromJson<GameSettings>(jsonSettings)**：此方法将 JSON 数据反序列化回 **GameSettings**
    对象，并将其分配给 **gameSettings** 变量'
- en: Overall, the `SettingsManager` class provides functionality to save and load
    game settings using JSON serialization and deserialization. It demonstrates basic
    file I/O operations in Unity for handling persistent data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`SettingsManager` 类提供了使用 JSON 序列化和反序列化来保存和加载游戏设置的函数。它展示了在 Unity 中处理持久数据的文件
    I/O 操作的基本方法。
- en: Regarding ScriptableObjects, we have the flexibility to save them using XML
    or binary formats, and we can treat them as custom classes that encapsulate specific
    data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ScriptableObjects，我们有使用 XML 或二进制格式保存它们的灵活性，并将它们视为封装特定数据的自定义类。
- en: To summarize, choosing the appropriate serialization and deserialization options
    in Unity depends on factors such as data interchange requirements, performance
    considerations, and integration with external systems. Understanding the strengths
    and limitations of each option allows developers to make informed decisions and
    implement efficient data management solutions in their Unity projects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在 Unity 中选择合适的序列化和反序列化选项取决于数据交换需求、性能考虑以及与外部系统的集成。了解每个选项的优势和局限性，使开发者能够做出明智的决定，并在他们的
    Unity 项目中实施高效的数据管理解决方案。
- en: Having understood the importance of data organization, let’s consider the role
    save and load systems can play in a game’s management.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解数据组织的重要性之后，让我们考虑保存和加载系统在游戏管理中的作用。
- en: Creating save and load systems using C#
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 创建保存和加载系统
- en: Save and load systems play a pivotal role in managing game progress and ensuring
    seamless player experiences. In this section, we’ll delve into various methods,
    from basic **PlayerPrefs** to more robust file-based save systems, enabling us,
    as developers, to preserve and retrieve player data within Unity efficiently.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和加载系统在管理游戏进度和确保无缝玩家体验方面发挥着关键作用。在本节中，我们将深入探讨各种方法，从基本的 **PlayerPrefs** 到更健壮的基于文件的保存系统，使我们作为开发者能够高效地保存和检索
    Unity 中的玩家数据。
- en: PlayerPrefs
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PlayerPrefs
- en: PlayerPrefs in Unity serve as a straightforward solution for storing key-value
    pairs, which is crucial for preserving simple game data. Understanding PlayerPrefs
    is fundamental for efficiently managing basic player preferences and progress
    within Unity projects. Operating as a key-value store, PlayerPrefs is specifically
    designed for storing player preferences and small data amounts between game sessions.
    Its simple interface facilitates setting and retrieving data, making it ideal
    for managing settings, user preferences, and basic game progress.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的 PlayerPrefs 作为存储键值对的简单解决方案，这对于保存简单的游戏数据至关重要。理解 PlayerPrefs 对于在 Unity
    项目中高效管理基本玩家偏好和进度是基本的。作为键值存储，PlayerPrefs 特别设计用于在游戏会话之间存储玩家偏好和小量数据。其简单的界面简化了数据的设置和检索，使其非常适合管理设置、用户偏好和基本游戏进度。
- en: Usage tips
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用技巧
- en: 'Let’s explore essential usage tips for maximizing the benefits of PlayerPrefs
    in Unity game development, including insights into data serialization, encryption,
    and security measures, as well as performance optimization techniques:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索在 Unity 游戏开发中最大化 PlayerPrefs 优势的必要使用技巧，包括数据序列化、加密和安全措施，以及性能优化技术：
- en: '**Data serialization**: While PlayerPrefs natively supports storing basic data
    types, such as integers, floats, and strings, more complex data structures require
    serialization. We can serialize custom data structures into a format that’s compatible
    with PlayerPrefs, enabling us to store and retrieve complex game data.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据序列化**：虽然 PlayerPrefs 本地支持存储基本数据类型，如整数、浮点数和字符串，但更复杂的数据结构需要序列化。我们可以将自定义数据结构序列化成与
    PlayerPrefs 兼容的格式，从而实现存储和检索复杂游戏数据。'
- en: '**Encryption and security**: You can protect sensitive player data by implementing
    encryption mechanisms before storing them in PlayerPrefs. By encrypting PlayerPrefs
    data, we can safeguard against unauthorized access and protect player privacy.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密和安全**：在将敏感玩家数据存储在**PlayerPrefs**之前，可以通过实现加密机制来保护它们。通过加密**PlayerPrefs**数据，我们可以防止未经授权的访问并保护玩家隐私。'
- en: '**Optimizing performance**: PlayerPrefs access involves disk I/O operations,
    which can impact performance, especially in resource-intensive games. To mitigate
    performance overhead, batch PlayerPrefs operations where possible and minimize
    frequent read/write operations during gameplay.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化性能**：**PlayerPrefs**访问涉及磁盘I/O操作，这可能会影响性能，尤其是在资源密集型游戏中。为了减轻性能开销，尽可能批量执行**PlayerPrefs**操作，并在游戏过程中最小化频繁的读写操作。'
- en: Incorporating these usage tips will help us optimize PlayerPrefs usage, ensuring
    data security, performance efficiency, and effective handling of complex game
    data in Unity projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些使用技巧将帮助我们优化**PlayerPrefs**的使用，确保数据安全、性能高效，并在Unity项目中有效处理复杂游戏数据。
- en: Now, let’s look at an example demonstrating how to utilize PlayerPrefs for saving
    and loading data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个示例，演示如何利用**PlayerPrefs**保存和加载数据。
- en: 'In this first code block, the `GameData` class is a custom class containing
    game data fields that must be saved and loaded:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个代码块中，**GameData**类是一个自定义类，包含必须保存和加载的游戏数据字段：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second code block contains the save and load functions, which use PlayerPrefs
    with the `GameData` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码块包含保存和加载函数，它们使用**GameData**类和**PlayerPrefs**：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s take a closer look at the saving and loading functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看保存和加载函数：
- en: '**SaveGame()**:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaveGame()**:'
- en: This function is responsible for saving the game data.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数负责保存游戏数据。
- en: It initializes a new instance of the **GameData** class, which likely contains
    fields representing various aspects of the game state.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它初始化**GameData**类的新实例，该实例可能包含表示游戏状态各个方面的字段。
- en: The current game state is then captured and stored in the **GameData** instance.
    In this example, it appears to be capturing the player’s level and experience
    from a **PlayerController** singleton instance.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前游戏状态随后被捕获并存储在**GameData**实例中。在这个例子中，它似乎是从**PlayerController**单例实例中捕获玩家的等级和经验。
- en: Next, the game data is serialized to JSON format using **JsonUtility.ToJson()**.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用**JsonUtility.ToJson()**将游戏数据序列化为JSON格式。
- en: Finally, the serialized JSON data is stored in **PlayerPrefs** using **PlayerPrefs.SetString()**
    with the **GameData** key, and **PlayerPrefs.Save()** is called to persist the
    changes.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用**PlayerPrefs.SetString()**和**GameData**键将序列化的JSON数据存储在**PlayerPrefs**中，并调用**PlayerPrefs.Save()**以持久化更改。
- en: '**LoadGame()**:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadGame()**:'
- en: This function loads the saved game data.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数加载保存的游戏数据。
- en: First, it checks if existing game data is stored in **PlayerPrefs** by using
    the **GameData** key alongside **PlayerPrefs.HasKey()**.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它检查是否通过使用**GameData**键和**PlayerPrefs.HasKey()**在**PlayerPrefs**中存储了现有的游戏数据。
- en: If there is saved data, it retrieves the serialized JSON string from **PlayerPrefs**
    using **PlayerPrefs.GetString("GameData")**.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有保存的数据，它将使用**PlayerPrefs.GetString("GameData")**从**PlayerPrefs**中检索序列化的JSON字符串。
- en: The JSON data is then deserialized back into a **GameData** object using **JsonUtility.FromJson<GameData>()**.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用**JsonUtility.FromJson<GameData>()**将JSON数据反序列化回**GameData**对象。
- en: Finally, the loaded game data is applied to the game state. In this example,
    it seems to be setting the player’s level and experience back to their saved values.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，加载的游戏数据应用于游戏状态。在这个例子中，它似乎是将玩家的等级和经验恢复到保存的值。
- en: Overall, these functions provide a simple mechanism for saving and loading game
    data using PlayerPrefs, allowing for basic persistence of game state between sessions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些函数提供了一个简单的机制，用于使用**PlayerPrefs**保存和加载数据，允许在会话之间基本持久化游戏状态。
- en: Now that we’ve discussed the significant benefits of PlayerPrefs, let’s examine
    situations where it may not be the optimal choice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了**PlayerPrefs**的显著好处，让我们看看它可能不是最佳选择的情况。
- en: Exploring the limitations and alternatives to PlayerPrefs
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索**PlayerPrefs**的限制和替代方案
- en: 'While PlayerPrefs offers convenience and simplicity for storing small amounts
    of data in Unity games, it also has several limitations and disadvantages that
    may prompt us to explore alternative solutions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**PlayerPrefs**为Unity游戏存储少量数据提供了便利和简单性，但它也有几个限制和缺点，这可能会促使我们探索替代解决方案：
- en: '**Limited storage capacity**: PlayerPrefs has a limited storage capacity, making
    it unsuitable for storing large amounts of data or complex data structures. Attempting
    to store excessive data in PlayerPrefs can lead to performance issues and memory
    constraints.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储容量有限**：PlayerPrefs的存储容量有限，这使得它不适合存储大量数据或复杂数据结构。尝试在PlayerPrefs中存储过多数据可能导致性能问题和内存限制。'
- en: '**Security concerns**: PlayerPrefs data is stored in plain text in the player’s
    registry (on Windows) or a **plist** file (on macOS and iOS), making it susceptible
    to tampering and unauthorized access. For applications that require enhanced security
    measures or compliance with data protection regulations, PlayerPrefs may not provide
    adequate protection for sensitive data.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全担忧**：PlayerPrefs数据以纯文本形式存储在玩家的注册表中（在Windows上）或**plist**文件中（在macOS和iOS上），这使得它容易受到篡改和未经授权的访问。对于需要增强安全措施或符合数据保护法规的应用程序，PlayerPrefs可能无法为敏感数据提供充分保护。'
- en: '**Platform dependencies**: PlayerPrefs storage locations and behavior may vary
    across different platforms and devices. This platform dependency can introduce
    inconsistencies and compatibility issues when deploying games to multiple platforms,
    requiring developers to implement platform-specific handling or alternative storage
    solutions.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台依赖性**：PlayerPrefs的存储位置和行为可能因不同平台和设备而异。这种平台依赖性在将游戏部署到多个平台时可能会引入不一致性和兼容性问题，需要开发者实现特定平台的处理或替代存储解决方案。'
- en: '**Limited data types**: PlayerPrefs supports a limited set of data types, including
    integers, floats, and strings. Complex data structures, arrays, or custom objects
    cannot be directly stored in PlayerPrefs without serialization and conversion,
    leading to additional complexity and potential performance overhead.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型有限**：PlayerPrefs支持有限的数据类型，包括整数、浮点数和字符串。复杂数据结构、数组或自定义对象不能直接存储在PlayerPrefs中，除非进行序列化和转换，这会导致额外的复杂性和潜在的性能开销。'
- en: '**Persistence challenges**: PlayerPrefs data is persisted across game sessions,
    but it may not persist across different devices or installations. Uninstalling
    or reinstalling the game, clearing application data, or switching devices can
    result in the loss of PlayerPrefs data, affecting player progress and preferences.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性挑战**：PlayerPrefs数据在游戏会话之间持续存在，但它可能不会在不同的设备或安装之间持续存在。卸载或重新安装游戏、清除应用程序数据或切换设备可能导致PlayerPrefs数据丢失，影响玩家进度和偏好。'
- en: '**Performance overhead**: Accessing PlayerPrefs involves disk I/O operations,
    which can introduce performance overhead, especially when reading or writing large
    amounts of data frequently. For applications that require high-performance data
    storage or real-time data access, PlayerPrefs may not meet performance requirements.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：访问PlayerPrefs涉及磁盘I/O操作，这可能会引入性能开销，尤其是在频繁读取或写入大量数据时。对于需要高性能数据存储或实时数据访问的应用程序，PlayerPrefs可能无法满足性能要求。'
- en: Due to these limitations and considerations, we may opt for alternative data
    storage solutions, such as binary serialization, JSON serialization, database
    systems, or cloud-based storage services. These solutions offer greater flexibility,
    scalability, security, and performance for managing game data, especially in scenarios
    involving large datasets, complex data structures, or stringent security requirements.
    While PlayerPrefs remains a convenient option for simple data storage needs, we
    should carefully evaluate our requirements and consider alternative solutions
    when designing data management systems for Unity games.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制和考虑，我们可能会选择替代的数据存储解决方案，例如二进制序列化、JSON序列化、数据库系统或基于云的存储服务。这些解决方案为管理游戏数据提供了更大的灵活性、可伸缩性、安全性和性能，尤其是在涉及大量数据集、复杂数据结构或严格安全要求的情况下。虽然PlayerPrefs对于简单的数据存储需求来说是一个方便的选项，但在为Unity游戏设计数据管理系统时，我们应该仔细评估我们的需求并考虑替代方案。
- en: Custom Save System
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义保存系统
- en: In the constantly changing world of game creation, the need for strong and flexible
    save systems becomes more and more clear. Enter the Custom Save System – a smart
    solution that’s designed to handle the complexities of data management with skill
    and effectiveness. Unlike usual methods, such as PlayerPrefs, the **Custom Save
    System** gives us a versatile set of tools, including encryption, options for
    saving to the cloud, and smooth integration with scriptable objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏制作不断变化的世界中，对强大且灵活的保存系统的需求越来越明显。现在，请进入自定义保存系统——这是一个旨在以技能和效率处理数据管理复杂性的智能解决方案。与通常的方法，如
    PlayerPrefs 不同，**自定义保存系统**为我们提供了一套多功能工具，包括加密、云保存选项以及与可脚本化对象的平滑集成。
- en: Custom Save System features
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义保存系统功能
- en: 'Let’s explore what features we can use in our custom save system:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们可以在自定义保存系统中使用哪些功能：
- en: '**Generic functionality**: The custom save system boasts generic functions
    for saving and loading data, allowing for seamless integration with various scriptable
    objects. With dynamic parameters and return values tailored to the specific needs
    of each data type, it ensures adaptability and versatility in data management.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用功能**：自定义保存系统具有用于保存和加载数据的通用功能，允许与各种可脚本化对象无缝集成。通过针对每种数据类型的特定需求定制的动态参数和返回值，它确保了数据管理中的适应性和多功能性。'
- en: '**Encryption and decryption**: Security is paramount in the world of game development.
    Leveraging encryption and decryption mechanisms, the Custom Save System ensures
    the confidentiality and integrity of sensitive player data. Through robust cryptographic
    algorithms, it guards against unauthorized access and tampering, fostering player
    trust and confidence.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密和解密**：在游戏开发的世界中，安全性至关重要。利用加密和解密机制，自定义保存系统确保敏感玩家数据的机密性和完整性。通过强大的加密算法，它保护免受未经授权的访问和篡改，培养玩家的信任和信心。'
- en: 'We’ll kick things off by crafting ScriptableObjects to manage the system’s
    data. I’ll draft the `PlayerData` script, which will store essential player information,
    as demonstrated in the subsequent code block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过创建可脚本化对象来管理系统的数据来开始。我将草拟 `PlayerData` 脚本，该脚本将存储关键玩家信息，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Additionally, I’ll craft a script for `GameSettings`, which will store relevant
    game data, as exemplified in the subsequent code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还会为 `GameSettings` 创建一个脚本，该脚本将存储相关游戏数据，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After creating these scripts, you can right-click, select `Data` and placing
    the instances inside it. Once you’ve done this, they’ll be structured similarly
    to the settings instance shown in *Figure 6**.1*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些脚本后，您可以右键单击，选择 `Data` 并将实例放入其中。一旦完成，它们的结构将与 *图 6.1* 中显示的设置实例类似：
- en: '![Figure 6.1 – Game Settings ScriptableObject instance](img/B22017_06_1.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 游戏设置 ScriptableObject 实例](img/B22017_06_1.jpg)'
- en: Figure 6.1 – Game Settings ScriptableObject instance
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 游戏设置 ScriptableObject 实例
- en: These data files have been provided for demonstration purposes only, allowing
    you to adjust them according to your project requirements.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据文件仅用于演示目的，允许您根据项目需求进行调整。
- en: 'Next, we’ll proceed by creating a save manager script. However, before diving
    into that, we must integrate `2022.3.13`. Follow these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个保存管理脚本。但在深入之前，我们必须集成 `2022.3.13`。请按照以下步骤操作：
- en: 'Navigate to the top bar and open the **Window** menu, then select **Package
    Manager**. Click on the **Add** button located in the top-left corner. This action
    will prompt a menu to appear, as shown in *Figure 6**.2*:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到顶部栏并打开 **Window** 菜单，然后选择 **Package Manager**。点击位于左上角的 **Add** 按钮。此操作将弹出一个菜单，如图
    *图 6.2* 所示：
- en: '![Figure 6.2 – Adding the package from the git URL in the Package Manager panel](img/B22017_06_2.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 在包管理器面板中添加来自 git URL 的包](img/B22017_06_2.jpg)'
- en: Figure 6.2 – Adding the package from the git URL in the Package Manager panel
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 在包管理器面板中添加来自 git URL 的包
- en: 'Paste [com.unity.nuget.newtonsoft-json](https://com.unity.nuget.newtonsoft-json)
    into the provided panel, then click **Add**, as depicted in *Figure 6**.3*:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 [com.unity.nuget.newtonsoft-json](https://com.unity.nuget.newtonsoft-json)
    粘贴到提供的面板中，然后点击 **Add**，如图 *图 6.3* 所示：
- en: '![Figure 6.3 – Adding the link for the git URL in the Package Manager panel](img/B22017_06_3.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 在包管理器面板中添加 git URL 的链接](img/B22017_06_3.jpg)'
- en: Figure 6.3 – Adding the link for the git URL in the Package Manager panel
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 在包管理器面板中添加 git URL 的链接
- en: Wait for the installation to finish and for Unity Editor to compile before creating
    the `SaveManager` script.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`SaveManager`脚本之前，等待安装完成并让Unity编辑器编译。
- en: The SaveManager script
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SaveManager`脚本'
- en: 'This script is the fundamental component that’s responsible for saving and
    loading data in our game. As mentioned earlier, this approach is not standard,
    but rather one method we’ll utilize for our game. Feel free to adopt this method
    or implement your own approach according to your needs. The following code block
    contains the `SaveManager` script:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是我们游戏中负责保存和加载数据的基本组件。如前所述，这种方法不是标准的，而是我们将用于我们游戏的一种方法。请随意采用这种方法或根据您的需求实现自己的方法。以下代码块包含`SaveManager`脚本：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take a closer look at the save and load methods that will be used from
    other scripts:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看其他脚本将使用的保存和加载方法：
- en: '**SaveData**:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaveData**:'
- en: Saves a key-value pair to a file
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将键值对保存到文件中
- en: Loads existing data, updates or adds new data based on the key, and serializes
    the dictionary to JSON
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据密钥加载现有数据，更新或添加新数据，并将字典序列化为JSON
- en: Encrypts the JSON data and writes it to the file
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JSON数据加密并写入文件
- en: '**LoadData**:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadData**:'
- en: Loads data from the save file based on the provided key
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据提供的密钥从保存文件中加载数据
- en: Checks if the key exists in the dictionary and returns the corresponding value
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查密钥是否存在于字典中，并返回相应的值
- en: Logs a warning and returns **null** if the key doesn’t exist
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果密钥不存在，记录警告并返回**null**
- en: 'The following code block contains static methods that handle input/output operations
    to load and save game data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含处理输入/输出操作的静态方法，用于加载和保存游戏数据：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s take a closer look at the previous code block:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看之前的代码块：
- en: '**LoadSavedData**:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadSavedData**:'
- en: Loads saved data from the file and returns it as a dictionary
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中加载保存的数据，并将其作为字典返回
- en: Reads encrypted data, decrypts it, deserializes JSON into a dictionary, and
    returns it
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取加密数据，解密它，将JSON反序列化为字典，并返回它
- en: '**DeleteSaveData**: Deletes the save data file if it exists'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DeleteSaveData**：如果存在，则删除保存数据文件'
- en: 'In the following code block, we’re dealing with encryption and decryption to
    secure the data:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们处理加密和解密以保护数据：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s consider the encryption methods (`EncryptData` and `DecryptData`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑加密方法（`EncryptData`和`DecryptData`）：
- en: Encrypts and decrypts data using the **AES** encryption algorithm
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**AES**加密算法加密和解密数据
- en: Encrypts input data using the encryption key and **IV** (**EncryptData**)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密密钥和**IV**（**EncryptData**）对输入数据进行加密
- en: Decrypts encrypted data using the same key and **IV** (**DecryptData**)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的密钥和**IV**（**DecryptData**）解密加密数据
- en: In this script, there’s a method called `SaveData` for saving data. It requires
    the data to be in string format, along with its corresponding key. We have opted
    to store the data in a dictionary of string and string, enabling us to easily
    manage loading and saving data for various files.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，有一个名为`SaveData`的方法用于保存数据。它需要数据以字符串格式提供，以及相应的密钥。我们选择将数据存储在字符串和字符串的字典中，这样我们就可以轻松地管理各种文件的加载和保存数据。
- en: For loading, we’re decrypting the string data and then loading it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加载，我们解密字符串数据然后加载它。
- en: Additionally, I’ve implemented **AES encryption** methods to secure the data
    during encryption and decryption processes. While the details of AES encryption
    are beyond the scope of this book, you’re encouraged to explore it further if
    you’re interested in learning about encryption techniques.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还实现了**AES加密**方法来在加密和解密过程中保护数据。虽然AES加密的细节超出了本书的范围，但如果你对学习加密技术感兴趣，鼓励你进一步探索。
- en: To facilitate the generation of keys and IV, I’ve prepared a helper script.
    You can utilize this script by attaching it to a GameObject within your scene.
    This script will enable you to create the necessary key and IV for encryption
    purposes. You can find the generated keys in the `SaveManager` script; there’s
    no need to repeat the creation process as it only occurs once.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便生成密钥和IV，我准备了一个辅助脚本。您可以通过将此脚本附加到场景中的GameObject来使用此脚本。此脚本将使您能够为加密目的创建必要的密钥和IV。您可以在`SaveManager`脚本中找到生成的密钥；无需重复创建过程，因为它只发生一次。
- en: 'You can obtain the `KeyAndIVGenerator` script from the following code block:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下代码块中获取`KeyAndIVGenerator`脚本：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s an explanation of the `KeyAndIVGenerator` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`KeyAndIVGenerator`类的说明：
- en: The **KeyAndIVGenerator** class contains a method named **GenerateKeyAndIV**,
    which is responsible for generating encryption keys and **initialization** **vectors**
    (**IVs**).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KeyAndIVGenerator** 类包含一个名为 **GenerateKeyAndIV** 的方法，该方法负责生成加密密钥和 **初始化**
    **向量**（**IV**）。'
- en: Inside the **GenerateKeyAndIV** method, the **KeyAndIVGenerator** class creates
    an instance of the **Aes** class using the **Aes.Create()** method, which represents
    the AES algorithm.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **GenerateKeyAndIV** 方法内部，**KeyAndIVGenerator** 类使用 **Aes.Create()** 方法创建一个
    **Aes** 类的实例，它代表 AES 算法。
- en: Then, it calls the **GenerateKey()** and **GenerateIV()** methods on the **Aes**
    instance to generate a random encryption key and **IV**.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它调用 **Aes** 实例上的 **GenerateKey()** 和 **GenerateIV()** 方法来生成随机的加密密钥和 **IV**。
- en: After generating the key and **IV**, it converts them into base64 strings using
    the **Convert.ToBase64String()** method. **Base64** encoding is used for easy
    storage and usage of the key and **IV**.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成密钥和 **IV** 后，它使用 **Convert.ToBase64String()** 方法将它们转换为 base64 字符串。**Base64**
    编码用于方便地存储和使用密钥和 **IV**。
- en: Finally, it logs the generated key and **IV** to the console using **Debug.Log()**
    for debugging purposes.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它使用 **Debug.Log()** 将生成的密钥和 **IV** 记录到控制台，用于调试目的。
- en: The **Start** method is called when the **KeyAndIVGenerator** object is initialized,
    and it invokes the **GenerateKeyAndIV** method to generate the key and **IV**
    when the object starts.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 **KeyAndIVGenerator** 对象被初始化时，会调用 **Start** 方法，并调用 **GenerateKeyAndIV** 方法来生成密钥和
    **IV**。
- en: Overall, this code block demonstrates how to generate encryption keys and `IV`
    values using the AES algorithm and convert them into `base64` strings for storage
    and usage. This is commonly used in cryptography for securing data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此代码块展示了如何使用 AES 算法生成加密密钥和 `IV` 值，并将它们转换为 `base64` 字符串以进行存储和使用。这在密码学中常用于保护数据。
- en: 'The following code block provides an example of the `GameManager` script, which
    utilizes the save and load methods from `SaveManager` to manage the process of
    saving and loading `PlayerData` and `GameSettings`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块提供了一个 `GameManager` 脚本的示例，该脚本利用 `SaveManager` 中的保存和加载方法来管理保存和加载 `PlayerData`
    和 `GameSettings` 的过程：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s consider the Unity callback functions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 Unity 回调函数：
- en: In the **Start** method, it calls the **LoadGameData** function to load the
    player data and game settings when the game starts
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Start** 方法中，当游戏开始时，它会调用 **LoadGameData** 函数来加载玩家数据和游戏设置。
- en: The **OnApplicationQuit** method is invoked when the application is about to
    quit, and it calls the **SaveGameData** function to save the player data and game
    settings before exiting
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序即将退出时，会调用 **OnApplicationQuit** 方法，并在退出前调用 **SaveGameData** 函数来保存玩家数据和游戏设置。
- en: 'The following code block contains the logic for loading and saving data:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块包含了加载和保存数据的逻辑：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s take a closer look at the saving and loading functions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看保存和加载函数：
- en: The **LoadGameData** function loads the player data and game settings from the
    save files using the **SaveManager.LoadData** method. If the data is not found,
    it creates new instances of **PlayerData** and **GameSettings**.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadGameData** 函数使用 **SaveManager.LoadData** 方法从保存文件中加载玩家数据和游戏设置。如果找不到数据，它将创建新的
    **PlayerData** 和 **GameSettings** 实例。'
- en: The **SaveGameData** function saves the player data and game settings to the
    save files using the **SaveManager.SaveData** method. It converts the data objects
    into JSON format using **JsonUtility.ToJson** before saving.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaveGameData** 函数使用 **SaveManager.SaveData** 方法将玩家数据和游戏设置保存到保存文件中。在保存之前，它使用
    **JsonUtility.ToJson** 将数据对象转换为 JSON 格式。'
- en: Overall, this code block demonstrates a basic implementation of loading and
    saving game data using JSON serialization. It ensures that the player data and
    game settings are persisted across game sessions, allowing for a seamless gaming
    experience.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此代码块展示了使用 JSON 序列化加载和保存游戏数据的基本实现。它确保玩家数据和游戏设置在游戏会话之间持久化，从而实现无缝的游戏体验。
- en: In this section, we learned how to save and load scriptable objects, the techniques
    of saving and loading to a file, encrypting using AES to protect the data, and
    how to generate encryption keys. Finally, we’ve practiced using these concepts
    practically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何保存和加载可脚本化对象，保存和加载到文件的技巧，使用 AES 加密以保护数据，以及如何生成加密密钥。最后，我们实际练习了使用这些概念。
- en: Now, we need to understand the benefits of using a custom approach over PlayerPrefs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要了解使用自定义方法而不是 PlayerPrefs 的好处。
- en: Advantages over PlayerPrefs
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对于 PlayerPrefs 的优势
- en: While PlayerPrefs offers simplicity, the Custom Save System goes beyond its
    limitations, providing a variety of features and functionalities unmatched by
    traditional storage methods. By reducing performance overhead and improving data
    security, it marks a new era of data management in Unity game development.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PlayerPrefs 提供了简单性，但自定义保存系统超越了其限制，提供了传统存储方法所不具备的各种功能和特性。通过减少性能开销和提高数据安全性，它标志着
    Unity 游戏开发中数据管理新时代的到来。
- en: To summarize, the Custom Save System represents innovation and creativity –
    a testament to the ongoing pursuit of excellence in game development. With its
    capacity to streamline data management, enhance security measures, and improve
    player experiences, it has become the cornerstone of modern game development practices,
    reshaping the landscape with each save.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，自定义保存系统代表了创新和创造力——这是对游戏开发中持续追求卓越的证明。凭借其简化数据管理、增强安全措施和提高玩家体验的能力，它已成为现代游戏开发实践的基础，每次保存都在重塑这一领域。
- en: In the next section, we are going to implement ScriptableObjects with the player
    progress part of our game while saving and loading data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现游戏进度部分的 ScriptableObjects，同时保存和加载数据。
- en: Data-driven gameplay with C#
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 进行数据驱动游戏
- en: '**Data-driven design** is an approach to game development where game behavior,
    content, and configuration are defined and controlled by external data files rather
    than hardcoded into the game’s source code. This approach offers several benefits,
    including increased flexibility, easier content iteration, and enhanced maintainability.
    By separating game data from code, we can modify game behavior, tweak parameters,
    and add new content without requiring code changes, thus accelerating iteration
    cycles and empowering designers to experiment with gameplay mechanics.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据驱动设计**是一种游戏开发方法，其中游戏行为、内容和配置由外部数据文件定义和控制，而不是硬编码到游戏源代码中。这种方法提供了几个好处，包括提高灵活性、更容易的内容迭代和增强的可维护性。通过将游戏数据与代码分离，我们可以修改游戏行为、调整参数和添加新内容，而无需进行代码更改，从而加速迭代周期并赋予设计师在游戏机制方面进行实验的权力。'
- en: Let’s begin with one of the uses of ScriptableObjects for managing data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 ScriptableObjects 在管理数据方面的一个用途开始。
- en: Creating data for stats
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建统计数据的数据
- en: 'We have the `PlayerMovement` script in our project, as shown in the following
    code block, which handles the player’s movement:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目中有一个 `PlayerMovement` 脚本，如下面的代码块所示，它处理玩家的移动：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can create a ScriptableObject that will contain the parameters of player
    movement, such as speed and force. Then, we can obtain a reference to that ScriptableObject.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以创建一个 ScriptableObject，它将包含玩家移动的参数，例如速度和力量。然后，我们可以获取该 ScriptableObject
    的引用。
- en: 'The following code block contains a ScriptableObject named `PlayerStats` that
    will store movement data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含一个名为 `PlayerStats` 的 ScriptableObject，它将存储移动数据：
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can utilize the `PlayerStats` ScriptableObject as a variable within
    the player movement script and substitute any previous logic that used the movement
    variables with the player stats accordingly:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在玩家移动脚本中将 `PlayerStats` ScriptableObject 作为变量使用，并相应地替换掉任何之前使用移动变量的逻辑：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We did this because we require a single reference for all movement parameters,
    and it will be convenient later to apply or adjust the stats from other scripts,
    such as special power-ups, without altering the code within the player movement
    script. We can directly modify the ScriptableObject, and it will impact the player’s
    movement.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们需要一个对所有移动参数的单个引用，并且以后从其他脚本（如特殊增益）应用或调整统计数据时，将方便地不修改玩家移动脚本内的代码。我们可以直接修改
    ScriptableObject，这将影响玩家的移动。
- en: Moreover, if we include items in our game, consolidating all data into individual
    ScriptableObjects for each type of item would streamline usage and modifications
    across all objects. Without directly referencing those objects, we can alter the
    data file, and it will impact all objects utilizing that data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们游戏中包含物品，将所有数据合并到每个物品类型的单独 ScriptableObject 中将简化使用和修改所有对象的过程。在不直接引用这些对象的情况下，我们可以更改数据文件，这将影响使用该数据的所有对象。
- en: Let’s consider another use for ScriptableObjects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 ScriptableObjects 的另一种用途。
- en: Challenge system
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战系统
- en: We can utilize ScriptableObjects for player progression within challenges, allowing
    us to effectively track challenges and save the progress made.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 ScriptableObjects 来跟踪挑战中的玩家进度，从而有效地跟踪挑战并保存所取得的进度。
- en: 'We will commence by migrating `CommonChallengeData` into a ScriptableObject,
    as demonstrated in the following code block:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将`CommonChallengeData`迁移到ScriptableObject中，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, upon completion of the challenge, we can utilize the save manager we
    previously established to store the challenge statistics. This can be seen in
    the `CompleteChallenge` function within `EnemyWavesChallenge` in the following
    code block:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在完成挑战之后，我们可以利用之前建立的保存管理器来存储挑战统计数据。这可以在以下代码块中的`EnemyWavesChallenge`的`CompleteChallenge`函数中看到：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We included the last line in the `CompleteChallenge` method to save the challenge
    data within the completion function of the challenge. Thus, before commencing
    the challenge, we will verify its completion status in the challenge manager.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`CompleteChallenge`方法中包含了最后一行，以便在挑战的完成函数中保存挑战数据。因此，在开始挑战之前，我们将在挑战管理器中验证其完成状态。
- en: 'Additionally, we must utilize the data loading functionality from the `SaveManager`
    script within the `StartChallenge` function inside `ChallengeManager`, as illustrated
    in the following code block:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须在`ChallengeManager`中的`StartChallenge`函数内使用`SaveManager`脚本的加载数据功能，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a straightforward method to transition existing code for utilizing ScriptableObjects
    or an improved data management approach. Furthermore, it integrates saving and
    loading functionalities to monitor challenge progress. While designing the system
    from scratch would offer a better data handling strategy, this system was constructed
    differently. We had the opportunity to modify it in this chapter, emphasizing
    the importance of adapting existing code bases. We’ll delve deeper into refining
    these skills in [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的方法，可以将现有代码转换为使用ScriptableObjects或改进的数据管理方法。此外，它集成了保存和加载功能，以监控挑战进度。虽然从头开始设计系统将提供更好的数据处理策略，但这个系统是按照不同的方式构建的。我们有机会在本章中对其进行修改，强调了适应现有代码库的重要性。我们将在[*第7章*](B22017_07.xhtml#_idTextAnchor112)中深入探讨这些技能的细化。
- en: To summarize, data-driven gameplay with C# offers a powerful framework for creating
    dynamic, customizable, and immersive gaming experiences. By embracing data-driven
    design principles, and leveraging ScriptableObjects for modular gameplay elements,
    we can build flexible, extensible, and engaging games that captivate players and
    stand the test of time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用C#进行数据驱动游戏提供了创建动态、可定制和沉浸式游戏体验的强大框架。通过采用数据驱动设计原则，并利用ScriptableObjects来构建模块化游戏元素，我们可以构建灵活、可扩展且吸引玩家的游戏，这些游戏能够经受时间的考验。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into concepts and techniques that are vital for efficient
    game development. We began by exploring the importance of data structures and
    their impact on game performance, emphasizing the significance of choosing the
    appropriate data structure for optimal results. Serialization in Unity took center
    stage as we navigated Unity’s serialization options, including XML, JSON, and
    binary serialization methods. We discussed the nuances of each serialization method
    and its suitability for different scenarios, laying the groundwork for robust
    data management in Unity projects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了对于高效游戏开发至关重要的概念和技术。我们首先探讨了数据结构的重要性及其对游戏性能的影响，强调了选择适当的数据结构以获得最佳结果的重要性。在导航Unity的序列化选项时，Unity的序列化成为焦点，包括XML、JSON和二进制序列化方法。我们讨论了每种序列化方法的细微差别及其在不同场景中的适用性，为Unity项目中稳健的数据管理奠定了基础。
- en: We continued by doing a deep dive into PlayerPrefs and its limitations in Unity
    game development, paving the way for the Custom Save System. Through detailed
    discussions and practical examples, we unveiled the features and advantages of
    the Custom Save System over PlayerPrefs, highlighting its role in elevating data-driven
    gameplay experiences. The `SaveManager` Script emerged as a pivotal component,
    facilitating seamless data saving and loading operations with enhanced efficiency
    and flexibility. By leveraging C# and scriptableObjects, we are empowered to embrace
    data-driven gameplay mechanics and optimize the challenge system for enhanced
    user engagement and progression. Through meticulous exploration and hands-on learning,
    this chapter has equipped us with the knowledge and tools needed to master data
    organization and serialization in Unity with C#.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续深入探讨Unity游戏开发中PlayerPrefs及其局限性，为自定义存档系统铺平了道路。通过详细的讨论和实际案例，我们揭示了自定义存档系统相较于PlayerPrefs的优势和特点，强调了其在提升数据驱动游戏体验中的作用。《SaveManager》脚本成为了一个关键组件，它通过提高效率和灵活性，实现了无缝的数据保存和加载操作。通过利用C#和scriptableObjects，我们得以拥抱数据驱动的游戏机制，并优化挑战系统以增强用户参与度和进步。通过细致的探索和动手学习，本章为我们提供了掌握Unity中C#数据组织和序列化的知识和工具。
- en: In [*Chapter 7*](B22017_07.xhtml#_idTextAnchor112), we’ll dive into the realm
    of collaborative game development and version control systems. Building on our
    foundational knowledge, we’ll explore how to effectively contribute to existing
    code bases and collaborate within development teams using C#. From understanding
    version control systems to mastering code merging and conflict resolution techniques,
    we’ll equip ourselves with essential skills to navigate shared code repositories
    seamlessly. Through practical examples and step-by-step guidance, we’ll learn
    about the intricacies of collaborating with shared code repositories and maintaining
    code quality in a team environment. Join us as we delve deeper into the collaborative
    aspects of game development, paving the way for enhanced teamwork and code management
    practices.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B22017_07.xhtml#_idTextAnchor112)中，我们将进入协作游戏开发和版本控制系统领域。基于我们的基础知识，我们将探讨如何有效地为现有代码库做出贡献，并使用C#在开发团队中进行协作。从理解版本控制系统到掌握代码合并和冲突解决技术，我们将掌握在共享代码库中无缝导航的必要技能。通过实际案例和逐步指导，我们将了解与共享代码库协作的复杂性，以及在团队环境中维护代码质量。加入我们，深入了解游戏开发的协作方面，为增强团队合作和代码管理实践铺平道路。
