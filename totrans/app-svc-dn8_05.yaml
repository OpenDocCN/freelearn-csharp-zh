- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multitasking and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing access to shared resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `async` and `await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **process**, with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  prefs: []
  type: TYPE_NORMAL
- en: A **thread** executes your code statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  prefs: []
  type: TYPE_NORMAL
- en: Windows and most other modern operating systems use **preemptive multitasking**,
    which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  prefs: []
  type: TYPE_NORMAL
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Threads may have to compete for and wait for access to shared resources, such
    as variables, files, and database objects. There are types for managing this that
    you will see in action later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the task, doubling the number of threads (workers) to perform
    a task does not halve the number of seconds that it will take to complete that
    task. In fact, it can increase the duration of the task due to resource contention,
    as shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: A tweet about tasks in the real world'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how multiple tasks can be run **simultaneously** (at the same
    time), we will create a console app that needs to execute three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple actions synchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we make the tasks run simultaneously, we will run them **synchronously**,
    that is, one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter05`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithTasks`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `WorkingWithTasks` project, globally and statically import the `System.Console`
    class and treat warnings as errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `WorkingWithTasks` project, add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, delete any existing statements, and then define a
    partial `Program` class with methods to output a section title and a task title,
    and to output information about the current thread, each in different colors to
    make them easier to identify in output, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `WorkingWithTasks` project, add a new class file named `Program.Methods.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, delete any existing statements, and then add three
    methods that simulate work, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    call the helper method to output information about the thread, define and start
    a stopwatch, call the three simulated work methods, and then output the milliseconds
    elapsed, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, wait for all three methods to finish executing, and then review
    the result, noting that when there is only one unnamed foreground thread doing
    the work, the total time required is just over 6 seconds, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running multiple actions asynchronously using tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class has been available since the first version of .NET in 2002
    and can be used to create new threads and manage them, but it can be tricky to
    work with directly.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which represents an
    asynchronous operation. A task is a high-level abstraction around the operating
    system thread that performs the operation, and the `Task` class enables easier
    creation and management of any underlying threads. Managing multiple threads wrapped
    in tasks will allow our code to execute at the same time, aka **asynchronously**.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and it can be managed with the `TaskFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: Starting tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the previous statements that call methods A to
    C, and then add statements to create and start three tasks, one for each method,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of commenting out the previous statements, you could let them run, but
    then make sure to call the `timer.Restart()` method after outputting a new section
    title to reset the timings for each section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the **thread pool (TP)**,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is even likely that the console app will end before one or even all the tasks
    have a chance to start and write to the console!
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in *Table 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Task class Wait methods'
  prefs: []
  type: TYPE_NORMAL
- en: Using wait methods with tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how we can use these wait methods to fix the problem with our console
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, after creating the three tasks and before outputting the elapsed
    time, add statements to combine references to the three tasks into an array and
    pass them to the `WaitAll` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll`, waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB`, which takes 2 seconds, and finally, `MethodA`, because it takes
    3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with another task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often, a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create some methods to simulate a call to a web service that returns
    a monetary amount, which then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, add two methods that simulate calling a web service
    and a database-stored procedure, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the statements for the previous three tasks, and
    then add statements to start a task to call the web service and then pass its
    return value to a task that starts the database-stored procedure, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The currency symbol is culture-specific so on my computer it uses a £. On your
    computer it will use your culture. You will learn how to control cultures in *Chapter
    7*, *Handling Dates, Times, and Internationalization*.
  prefs: []
  type: TYPE_NORMAL
- en: You might see two different threads running the web service and stored procedure
    calls as in the output above (for example, threads 4 and 6), or the same thread
    might be reused since it is no longer busy.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and child tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how these types of tasks work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, add two methods, one of which starts a task to run
    the other, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although we wait for the outer task to finish, its inner task does not have
    to finish as well. In fact, the outer task might finish, and the console app could
    end before the inner task even starts, as shown in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To link these nested tasks as parent and child, we must use a special option.
    In `Program.Methods.cs`, modify the existing code to add a `TaskCreationOption`
    value of `AttachedToParent`, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the outer method could finish before the inner method starts,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OuterMethod` can finish its work before the `InnerMethod`, as shown by
    what it writes to the console, but its task must wait, as shown by the console
    not stopping until both the outer and inner tasks finish.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping tasks around other objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the `Task` static methods, as shown in *Table 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that’s completed
    with a specified exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that’s
    completed due to cancellation with a specified cancellation token. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: Methods to create a Task in various scenarios'
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are useful when you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an interface that has asynchronous methods, but your implementation
    is synchronous. This is common for websites and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock asynchronous implementations during unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine that you need to create a method to validate XML input and the method
    must conform to an interface that requires a `Task<T>` to be returned, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code in this section is for illustration only. You do not need to enter
    it in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use these helpful `FromX` methods to return the results wrapped in
    a task, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method), then you can return a predefined completed `Task` object,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When running tasks in parallel, the code will often need to access resources,
    and those resources are sometimes shared between tasks and threads. We, therefore,
    need to learn how to safely access those shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing access to shared resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe**.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  prefs: []
  type: TYPE_NORMAL
- en: In William Golding’s *Lord of the Flies*, Piggy and Ralph find a conch shell
    and use it to call a meeting. The boys impose a “rule of the conch” on themselves,
    deciding that no one can speak unless they’re holding the conch.
  prefs: []
  type: TYPE_NORMAL
- en: I like to name the object variable I use for implementing thread-safe code the
    “conch.” When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say *should*. Only code that
    respects the conch enables synchronized access. A conch is *not* a lock.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Monitor`: An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interlocked`: An object for manipulating simple numeric types at the CPU level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a resource from multiple threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a console app to explore sharing resources between multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `SynchronizingResourceAccess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Globally and statically import the `System.Console` class and treat warnings
    as errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `SharedObjects.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `SharedObjects.cs`, delete any existing statements and then define a static
    class with a field to store a message that is a shared resource, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file named `Program.Methods.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, delete any existing statements and then define two
    methods that both loop five times, waiting for a random interval of up to two
    seconds and appending either `A` or `B` to the shared message resource, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements. Add statements to import the
    namespace for diagnostic types like `Stopwatch`, and statements to execute both
    methods on separate threads using a pair of tasks, and wait for them to complete
    before outputting the elapsed milliseconds, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object, as well as adding code
    to the two methods to voluntarily check the conch before modifying the shared
    resource, which we will do in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a mutually exclusive lock to a conch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s use a conch to ensure that only one thread accesses the shared resource
    at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SharedObjects.cs`, declare and instantiate an `object` variable to act
    as a conch, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, in both `MethodA` and `MethodB`, add a `lock` statement
    for the conch around the `for` statements, as shown highlighted in the following
    code for `MethodB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch by calling `lock` on it before trying to use
    any shared resources.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the lock statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might wonder what the `lock` statement does when it “locks” an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The C# compiler changes the `lock` statement into a `try`-`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When a thread calls `Monitor.Enter` on a reference type, it checks to see if
    some other thread has already taken the conch. If it has, the thread waits. If
    it has not, the thread takes the conch and gets on with its work on the shared
    resource. Once the thread has finished its work, it calls `Monitor.Exit`, releasing
    the conch.
  prefs: []
  type: TYPE_NORMAL
- en: If another thread was waiting, it could now take the conch and do its work.
    This requires all threads to respect the conch by calling `Monitor.Enter` and
    `Monitor.Exit` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You cannot use value types (`struct` types) as a conch.
    `Monitor.Enter` requires a reference type because it locks the memory address.
    Any internal data structures for that object are *not* locked.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread X “locks” conch A and starts working on shared resource A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread Y “locks” conch B and starts working on shared resource B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to “lock” conch B but is blocked because thread Y already
    has conch B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to “lock” conch A but is blocked because thread X already
    has conch A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, modify your code to replace the `lock` statements
    with code that tries to enter the conch with a timeout, outputs an error, and
    then exits the monitor, allowing other threads to enter the monitor, as shown
    highlighted in the following code for `MethodB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Only use the `lock` keyword if you can write your code such
    that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then
    always use the `Monitor.TryEnter` method instead of `lock`, in combination with
    a `try`-`finally` statement, so that you can supply a timeout and one of the threads
    will back out of a deadlock if it occurs. You can read more about good threading
    practices at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices).'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET events are not thread-safe, so you should avoid using them in multi-threaded
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Is it good or bad that some developers use locks in event
    handling? Well, it is complicated. It depends on complex factors so I cannot give
    a value judgement. You can read more about events and thread safety at the following
    link: [https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful).
    But it is complicated, as explained by Stephen Cleary in the following blog post:
    [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Making CPU operations atomic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomic is from the Greek word **atomos**, which means *undividable*. It is important
    to understand which operations are atomic in multithreading because if they are
    not atomic, then they could be interrupted by another thread partway through their
    operation. Is the C# increment operator atomic, as shown in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*It is not atomic!* Incrementing an integer requires the following three CPU
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Load a value from an instance variable into a register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value in the instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a type named `Interlocked` that can perform atomic actions like `Add`,
    `Increment`, `Decrement`, `Exchange`, `CompareExchange`, `And`, `Or`, and `Read`
    on the integer types in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Int32` (`int`), `System.UInt32` (`uint`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Int64` (`long`), `System.UInt64` (`ulong`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interlocked` does not work on numeric types like `byte`, `sbyte`, `short`,
    `ushort`, and `decimal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Interlocked` can perform atomic operations like `Exchange` and `CompareExchange`
    that swap values in memory on the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Single` (`float`), `System.Double` (`double`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nint`, `nuint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Object` (`object`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, in both methods A and B, inside the `for` statement
    and after modifying the `string` value, add a statement to safely increment the
    counter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, before outputting the elapsed time, write the current value
    of the counter to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore,
    it is unnecessary to use `Interlocked` in this specific example. But if we had
    not already been protecting another shared resource like `Message`, then using
    `Interlocked` would be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Applying other types of synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in *Table 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ReaderWriterLock`, `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode**, one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode**, from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `Mutex` | Like `Monitor`, this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  prefs: []
  type: TYPE_TB
- en: '| `Semaphore`, `SemaphoreSlim` | These limit the number of threads that can
    access a resource or pool of resources concurrently by defining slots. This is
    known as **resource throttling** rather than **resource locking**. |'
  prefs: []
  type: TYPE_TB
- en: '| `AutoResetEvent`, `ManualResetEvent` | Event wait handles allow threads to
    synchronize activities by signaling each other and by waiting for each other’s
    signals. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.3: Synchronization types'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored the importance of synchronizing access to shared resources
    in multi-threaded applications, it’s time to delve into how some new keywords
    introduced in C# 5 make writing asynchronous code easier.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multitasking for a **graphical user interface** (**GUI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the scalability of web applications and web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 16*, *Building Mobile and Desktop Apps Using .NET MAUI*, we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: But for now, let’s learn the theory of why these two C# keywords were introduced,
    and then later, you will see them used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for console apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the limitations with console apps is that you can only use the `await`
    keyword inside methods that are marked as `async`, but C# 7 and earlier do not
    allow the `Main` method to be marked as `async`! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main`:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `AsyncConsole`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, statically import `Console`,
    and then add statements to create an `HttpClient` instance, make a request for
    Apple’s home page, and output how many bytes it has, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    the project template created an explicit `Program` class with a non-async `Main`
    method, so you would have seen an error message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task`. With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `<Main>$` method for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with async streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With .NET Core 3, Microsoft introduced the asynchronous processing of streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can complete a tutorial about async streams at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream).'
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8 and .NET Core 3, the `await` keyword only worked with tasks that
    return scalar values. Async stream support in .NET Standard 2.1 allows an `async`
    method to return one value after another asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a simulated example that returns three random integers as an async
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `AsyncEnumerable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Globally and statically import the `System.Console` class and treat warnings
    as errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new file named `Program.Methods.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, delete any existing statements and then define a method
    that uses the `yield` keyword to return a random sequence of three numbers asynchronously,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    enumerate the sequence of numbers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Improving responsiveness for GUI apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this book, we have only built console apps. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI**) thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two rules for working in GUIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not perform long-running tasks on the UI thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not access UI elements on any thread except the UI thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long-running tasks were executed by a non-UI thread, but once complete, the
    results of the task were safely passed to the UI thread to present to the user.
    It could quickly get messy!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with C# 5 and later, you have the use of `async` and `await`. They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It’s kind of magical!
    The combination of these two keywords makes the asynchronous method run on a worker
    thread and, when it’s complete, return the results on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example. We will build a Windows desktop app using **Windows Presentation
    Foundation** (**WPF**) that gets employees from the Northwind database in a SQL
    Server database using low-level types like `SqlConnection`, `SqlCommand`, and
    `SqlDataReader`.
  prefs: []
  type: TYPE_NORMAL
- en: The Northwind database has medium complexity and a decent number of sample records.
    You used it extensively in *Chapter 2*,*Managing Relational Data Using SQL Server*,
    where it was introduced and set up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** You will only be able to complete this task if you have Microsoft
    Windows and the Northwind database stored in Microsoft SQL Server. This is the
    only section in this book that is not cross-platform and modern (WPF is 17 years
    old!). You can use either Visual Studio 2022 or Visual Studio Code.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 16*, *Building Mobile
    and Desktop Apps Using .NET MAUI*. Since this book does not cover WPF elsewhere,
    I thought this task would be a good opportunity to at least see an example app
    built using WPF even if we do not look at it in detail. Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio 2022, add a new **WPF Application [C#]** project
    named `WpfResponsive` to the `Chapter05` solution. If you are using Visual Studio
    Code, use the following command: `dotnet new wpf`. If you are using JetBrains
    Rider, select **Desktop Application** and then select a **Type** of **WPF Application**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a package reference for `Microsoft.Data.SqlClient` to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, note the output type is a Windows EXE, the target framework
    is .NET for Windows (it will not run on other platforms, like macOS and Linux),
    and the project uses WPF, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WpfResponsive` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml`, in the `<Grid>` element, add elements to define two buttons,
    a text box and a list box, laid out vertically in a stack panel, as shown in the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visual Studio 2022 has good support for building WPF apps and will provide IntelliSense
    as you edit code and XAML markup. Visual Studio Code does not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml.cs`, import namespaces to work with ADO.NET and the stopwatch,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MainWindow` class, in the constructor, define two `string` fields for
    the database connection string and SQL statement, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SQL has two statements. The first waits for five seconds to simulate a long-running
    query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `MainWindow` class, in the constructor, after the call to `InitializeComponent`,
    use an `SqlConnectionStringBuilder` to set the database connection string, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create event handlers for clicking on the two buttons. They must use the `string`
    constants to open a connection to the Northwind database and then populate the
    list box with the IDs and names of all employees, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Defining an `async void` method is generally bad practice because it is “fire
    and forget.” You will not be notified when it is completed and there is no way
    to cancel it because it does not return a `Task` or `Task<T>` that can be used
    to control it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL statement uses the SQL Server `WAITFOR DELAY` command to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the WPF app without debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note that the GUI is responsive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Synchronously** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to click in the text box, and note the GUI is not responsive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for at least five seconds until the list box is filled with employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Asynchronously** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click in the text box, enter some text, and note that the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees, as shown in *Figure 5.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Loading employees into a WPF app synchronously and asynchronously'
  prefs: []
  type: TYPE_NORMAL
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the WPF app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving scalability for web applications and web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application’s point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client’s point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Common types that support multitasking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in *Table 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Methods** |'
  prefs: []
  type: TYPE_TB
- en: '| `DbContext<T>` | `AddAsync`, `AddRangeAsync`, `FindAsync`, and `SaveChangesAsync`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DbSet<T>` | `AddAsync`, `AddRangeAsync`, `ForEachAsync`, `SumAsync`, `ToListAsync
    ToDictionaryAsync`, `AverageAsync`, and `CountAsync` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpClient` | `GetAsync`, `PostAsync`, `PutAsync`, `DeleteAsync`, and `SendAsync`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamReader` | `ReadAsync`, `ReadLineAsync`, and `ReadToEndAsync` |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamWriter` | `WriteAsync`, `WriteLineAsync`, and `FlushAsync` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.4: Common types with asynchronous methods'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Any time you see a method that ends in the `Async` suffix,
    check to see whether it returns `Task` or `Task<T>`. If it does return `Task`
    or `Task<T>`, then you could use it instead of the synchronous non-`Async` suffixed
    method. Remember to call it using `await` and decorate your method with `async`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using await in catch blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What information can you find out about a process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How accurate is the `Stopwatch` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a child task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid the `lock` keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Interlocked` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using `async` and `await` in a website or web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you cancel a task? If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 5.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following web page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.3 – Read more about parallel programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packt has a book that goes deeper into the topics in this chapter, *Parallel
    Programming and Concurrency with C# 10 and .NET 6: A modern approach to building
    faster, more responsive, and asynchronous .NET applications using C#*, by Alvin
    Ashcroft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define and start a task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to wait for one or more tasks to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control task completion order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to synchronize access to shared resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magic behind `async` and `await`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use some popular third-party libraries.
  prefs: []
  type: TYPE_NORMAL
