["```cs\nusing UnityEngine;\n\npublic class PopulateArtFrames : MonoBehaviour\n{\n    public Texture[] images;\n\n    void Start()\n    {\n        int imageIndex = 0;\n        foreach (Transform artwork in transform)\n        {\n            GameObject art = artwork.Find(\"ArtFrame/Image\").gameObject;\n            Renderer rend = art.GetComponent<Renderer>();\n            Material material = rend.material;\n            material.mainTexture = images[imageIndex];\n            imageIndex++;\n            if (imageIndex == images.Length)\n                break;\n        }\n    }\n}\n```", "```cs\n public Texture[] images;\n public string[] titles;\n public string[] artists;\n public string[] descriptions;\n```", "```cs\n[System.Serializable]\npublic struct ArtInfo\n{\n    public Texture image;\n    public string title;\n    public string artist;\n    public string description;\n}\n\npublic class PopulateArtFrames : MonoBehaviour\n{\n    public List<ArtInfo> artInfos = new List<ArtInfo>();\nArtInfo defining our data fields. Then, in PopulateArtFrames we declare it as a List (which must be initialized with the new List<ArtInfo>() call). In the script, we'd then reference the textures as artInfos[i].image. Likewise, you'd get its size using artInfos.Count Â rather than Length. Also, we need to say it's System.Serializable so the list appears in the editor Inspector, as follows:\n```", "```cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = \"My Objects/Art Info\")]\npublic class ArtInfo : ScriptableObject\n{\n    public Texture image;\n    public string title;\n    public string artist;\n    [Multiline]\n    public string description;\n}\n```", "```cs\nusing UnityEngine;\n\npublic class ArtworkController : MonoBehaviour {\n    public GameObject image;\n\n    public void SetArtInfo(ArtInfo info)\n    {\n        Renderer rend = image.GetComponent<Renderer>();\n        Material material = rend.material;\n        material.mainTexture = info.image;\n    }\n}\n```", "```cs\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PopulateArtFrames : MonoBehaviour\n{\n    public List<ArtInfo> artInfos = new List<ArtInfo>();\n\n    void Start()\n    {\n        int index = 0;\n        foreach (Transform artwork in transform)\n        {\n            artwork.GetComponent<ArtworkController>().SetArtInfo(artInfos[index]);\n\n            index++;\n            if (index == artInfos.Count || artInfos[index]==null)\n                break;\n        }\n    }\n}\n```", "```cs\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class ArtworkController : MonoBehaviour {\n\n    public GameObject image;\n public Text title;\n\n    public void SetArtInfo(ArtInfo info)\n    {\n        Renderer rend = image.GetComponent<Renderer>();\n        Material material = rend.material;\n        material.mainTexture = info.image;\n\n title.text = info.title;\n    }\n}\n```", "```cs\n public Text artist;\n public Text description;\n public GameObject detailsCanvas;\n```", "```cs\n     artist.text = info.artist;\n     description.text = info.description;\n```", "```cs\n    void Start()\n    {\n        detailsCanvas.SetActive(false);\n    }\n\n    void Update()\n    {\n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            detailsCanvas.SetActive(true);\n        }\n        if (Input.GetButtonUp(\"Fire1\"))\n        {\n            detailsCanvas.SetActive(false);\n        }\n    }\n```", "```cs\n    private Vector3 TextureToScale(Texture texture, float depth)\n    {\n        Vector3 scale = Vector3.one;\n        scale.z = depth;\n        if (texture.width > texture.height)\n        {\n            scale.y = (float)texture.height / (float)texture.width;\n        } else\n        {\n            scale.x = (float)texture.width / (float)texture.height;\n        }\n        return scale;\n    }\n```", "```cs\npublic Transform frame;\n```", "```cs\nframe.localScale = TextureToScale(info.image, frame.localScale.z);\n```", "```cs\n public Transform playerRoot;\n public GameObject artWorks;\n public float startDelay = 3f;\n public float transitionTime = 5f;\n\n private AnimationCurve xCurve, zCurve, rCurve;\n```", "```cs\n    private void SetupCurves()\n    {\n        int count = artWorks.transform.childCount + 1;\n        Keyframe[] xKeys = new Keyframe[count];\n        Keyframe[] zKeys = new Keyframe[count];\n        Keyframe[] rKeys = new Keyframe[count];\n\n        int i = 0;\n        float time = startDelay;\n        xKeys[0] = new Keyframe(time, playerRoot.position.x);\n        zKeys[0] = new Keyframe(time, playerRoot.position.z);\n        rKeys[0] = new Keyframe(time, playerRoot.rotation.y);\n\n        foreach (Transform artwork in artWorks.transform)\n        {\n            i++;\n            time += transitionTime;\n            Transform pose = artwork.Find(\"ViewPose\");\n            xKeys[i] = new Keyframe(time, pose.position.x);\n            zKeys[i] = new Keyframe(time, pose.position.z);\n            rKeys[i] = new Keyframe(time, pose.rotation.y);\n        }\n        xCurve = new AnimationCurve(xKeys);\n        zCurve = new AnimationCurve(zKeys);\n        rCurve = new AnimationCurve(rKeys);\n    }\n```", "```cs\n    void OnEnable()\n    {\n        SetupCurves();\n    }\n```", "```cs\n    void Update()\n    {\n        playerRoot.position = new Vector3(\n                xCurve.Evaluate(Time.time), \n                playerRoot.position.y, \n                zCurve.Evaluate(Time.time));\n\n        Quaternion rot = playerRoot.rotation;\n        rot.y = rCurve.Evaluate(Time.time);\n        playerRoot.rotation = rot;\n\n        // done?\n        if (Time.time >= xCurve[xCurve.length - 1].time)\n            gameObject.SetActive(false);\n    }\n```"]