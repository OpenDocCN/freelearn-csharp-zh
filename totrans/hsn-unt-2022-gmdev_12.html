<html><head></head><body>
  <div id="_idContainer668" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-154" class="chapterTitle">Lighting Using the Universal Render Pipeline</h1>
    <p class="normal"><strong class="keyWord">Lighting</strong> is a complex topic and there<a id="_idIndexMarker758"/> are several possible ways to handle it, with each one having its pros and cons. In order to get the best possible quality and performance, you need to know exactly how your renderer handles lighting, and that is exactly what we are going to do in this chapter. We will discuss how lighting is handled in Unity’s <strong class="keyWord">Universal Render Pipeline</strong> (<strong class="keyWord">URP</strong>), as well as how to properly configure it to adapt our scene’s mood with proper lighting effects.</p>
    <p class="normal">In this chapter, we will examine the following lighting concepts: </p>
    <ul>
      <li class="bulletList">Applying lighting</li>
      <li class="bulletList">Applying shadows </li>
      <li class="bulletList">Optimizing lighting </li>
    </ul>
    <p class="normal">At the end of the chapter, we will have properly used the different Unity Illumination systems like Direct Lights and Lightmapping to reflect a cloudy and rainy night.</p>
    <h1 id="_idParaDest-155" class="heading-1">Applying lighting</h1>
    <p class="normal">When discussing<a id="_idIndexMarker759"/> ways to process lighting in a game, there are two main ways we can do so, known as <strong class="keyWord">Forward Rendering</strong> and <strong class="keyWord">Deferred Rendering</strong>. Both handle lighting<a id="_idIndexMarker760"/> in a different order, with<a id="_idIndexMarker761"/> different techniques, requirements, pros, and cons. Forward Rendering is usually recommended for performance, while Deferred Rendering<a id="_idIndexMarker762"/> is usually recommended for quality. The latter is used by the <strong class="keyWord">High Definition Render Pipeline</strong> of Unity, the renderer used for high-quality graphics in high-end devices. </p>
    <p class="normal">At the time of writing this book, Unity is developing a performant version for URP. Also, in Unity, the<a id="_idIndexMarker763"/> Forward Renderer comes with two modes: <strong class="keyWord">Multi-Pass Forward</strong>, which is used in the Built-In Renderer (the old Unity Renderer), and <strong class="keyWord">Single Pass Forward,</strong> which is used in URP. Again, both<a id="_idIndexMarker764"/> have their pros and cons. </p>
    <p class="normal">Choosing between<a id="_idIndexMarker765"/> them depends on the kind of game you are creating and the platform you need to run the game on. Your chosen option will change a lot due to the way you apply lighting to your scene, so it’s crucial you understand which system you are dealing with.</p>
    <p class="normal">In the next section, we will discuss the following real-time lighting concepts:</p>
    <ul>
      <li class="bulletList">Discussing lighting methods</li>
      <li class="bulletList">Configuring ambient lighting with skyboxes</li>
      <li class="bulletList">Configuring lighting in URP</li>
    </ul>
    <p class="normal">Let’s start by comparing the previously mentioned lighting methods.</p>
    <h2 id="_idParaDest-156" class="heading-2">Discussing lighting methods</h2>
    <p class="normal">To recap, we mentioned<a id="_idIndexMarker766"/> three main ways of processing lighting at the beginning of this chapter:</p>
    <ul>
      <li class="bulletList">Forward Rendering (Single Pass)</li>
      <li class="bulletList">Forward Rendering (Multi-Pass)</li>
      <li class="bulletList">Deferred Rendering</li>
    </ul>
    <p class="normal">Before we look at the differences between each, let’s talk about the things they have in common. Those three renderers start drawing the scene by determining which objects can be seen by the camera—that is, the ones that fall inside the camera’s frustum, and provide a giant pyramid that can be seen when you select the camera:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_01.png" alt="Image result for unity occlusion culling"/></figure>
    <p class="packt_figref">Figure 12.1: Camera’s frustum showing only the objects that can be seen by it</p>
    <p class="normal">After that, Unity <a id="_idIndexMarker767"/>will order them from the nearest to the camera to the farthest (transparent objects are handled a little bit differently, but let’s ignore that for now). It’s done like this because it’s more probable that objects nearer to the camera will cover most of the camera, so they will occlude others (will block other objects from being seen), preventing us from wasting resources calculating pixels for the occluded ones.</p>
    <p class="normal">Finally, Unity will try to render the objects in that order. This is where differences start to arise between lighting methods, so let’s start comparing the two Forward Rendering variants. For each object, Single Pass Forward Rendering will calculate the object’s appearance, including all the lights that are affecting the object, in one shot, or what we call a draw call. </p>
    <p class="normal">A <strong class="keyWord">draw call</strong> is the exact moment<a id="_idIndexMarker768"/> when Unity asks the video card to actually render the specified object. All the previous work was just preparation for this moment. In the case<a id="_idIndexMarker769"/> of the Multi-Pass Forward Renderer, by simplifying a little bit of the actual logic, Unity will render the object once per light that affects the object; so, if the object is being lit by three lights, Unity will render the object three times, meaning that three draw calls will be issued, and three calls to the GPU will be made to execute the rendering process:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.2: Left image, first draw call of a sphere affected by two lights in Multi-Pass; middle image, second draw call of the sphere; and right image, the combination of both draw calls</p>
    <p class="normal">Now is when you are probably thinking, <em class="italic">“Why should I use Multi-Pass? Single Pass is more performant!” </em>And yes, you are right! Single Pass<a id="_idIndexMarker770"/> is much more performant than Multi-Pass, meaning our game will run at higher frames per second, and here comes the great but. A draw call in a GPU has a limited amount of operations that can be executed, so you have a limit to the complexity of the draw call. Calculating the appearance of an object and all the lights that affect it is very complex, and in order to make it fit in just one draw call, Single Pass executes simplified versions of lighting calculations, meaning less lighting quality and fewer features. They also have a limit on how many lights can be handled in one shot, which, at the time of writing this book, is eight per object, although you can configure fewer if you want, but the default value is good for us. This sounds like a small number, but it’s usually just enough.</p>
    <p class="normal">On the other side, Multi-Pass can apply<a id="_idIndexMarker771"/> any number of lights you want and can execute different logic for each light. Let’s say our object has four lights that are affecting it, but there are two lights that are affecting it drastically because they are nearer or have higher intensity, while the remaining ones affecting the object are just enough to be noticeable. In this scenario, we can render the first two lights with higher quality and the remaining ones with cheap calculations—no one will be able<a id="_idIndexMarker772"/> to tell the difference. </p>
    <p class="normal">In this case, Multi-Pass can calculate the first two lights using <strong class="keyWord">Pixel Lighting</strong> and the remaining ones using <strong class="keyWord">Vertex Lighting</strong>. The difference is in their names; Pixel<a id="_idIndexMarker773"/> calculates light per object’s pixel, while Vertex calculates lighting per object vertex and fills the pixels between these vertexes, thereby interpolating information between vertexes. You can clearly see the difference in the following images:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_03.png" alt=""/> </figure>
    <p class="packt_figref">Figure 12.3: Left image, a sphere being rendered with Vertex Lighting; right image, a sphere being rendered with Pixel Lighting</p>
    <p class="normal">In Single Pass, calculating<a id="_idIndexMarker774"/> everything in a single draw call forces you to use Vertex Lighting or Pixel Lighting; you cannot combine them.</p>
    <p class="normal">So, to summarize the differences<a id="_idIndexMarker775"/> between Single and Multi-Pass, in Single, you have<a id="_idIndexMarker776"/> better performance because each object is just drawn once, but you are limited to the number of lights that can be applied, while in Multi-Pass, you need to render the object several times, but with no limits on the number of lights, and you can specify the exact quality you want for each light. There are other things to consider, such as the actual cost of a draw call (one draw call can be more expensive than two simple ones), and special lighting effects such as toon shading, but let’s keep things simple.</p>
    <p class="normal">Finally, let’s briefly discuss Deferred. Even though we are not<a id="_idIndexMarker777"/> going to use it, it’s interesting to know why we are not doing that. After determining which objects fall inside the frustum and ordering them, Deferred will render the objects without any<a id="_idIndexMarker778"/> lighting, generating what is called a <strong class="keyWord">G-Buffer</strong>. A G-Buffer is a set of several images that contain different information about the objects of the scene, such as the colors of their pixels (without lighting), the<a id="_idIndexMarker779"/> direction of each pixel (known as <strong class="keyWord">Normals</strong>), and how far from the camera the pixels are. </p>
    <p class="normal">You can see a typical example of a G-Buffer in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_04.png" alt=""/> </figure>
    <p class="packt_figref">Figure 12.4: Left image, plain colors of the object; middle image, depths of each pixel; and right image, normals of the pixels</p>
    <div class="note">
      <p class="normal">Normals are <a id="_idIndexMarker780"/>directions, and the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> components of the directions are encoded in the RGB components of the colors. </p>
    </div>
    <p class="normal">After rendering all the objects<a id="_idIndexMarker781"/> in the scene, Unity will iterate over all lights that can be seen in the camera, thus applying a layer of lighting over the G-Buffer, taking information from it to calculate that specific light. After all the lights have been processed, you will get the following result:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.5: Combination of the three lights that were applied to the G-Buffer shown in the previous image</p>
    <p class="normal">As you can see, the Deferred<a id="_idIndexMarker782"/> part of this method comes from the idea of calculating lighting as the last stage of the rendering process. This is better because you won’t waste resources calculating lighting from objects that can potentially be occluded. If the floor of the image is being rendered first in <strong class="screenText">Forward</strong> mode, the pixels that the rest of the objects are going to occlude were calculated in vain. Also, there’s the pro that Deferred just calculates lighting in the exact pixels that the light can reach. As an example, if you are using a flashlight, Unity will calculate lighting only in the pixels that fall inside the cone of the flashlight. The con here is that Deferred is not supported by some relatively old video cards and that you can’t calculate lighting with Vertex Lighting quality, so you will need to pay the price of Pixel Lighting, which is not recommended on low-end devices (or even necessary in simple graphics games).</p>
    <p class="normal">So, why are we using URP<a id="_idIndexMarker783"/> with Single Pass Forward? Because it offers the best balance between performance, quality, and simplicity. In this game, we won’t be using too many lights, so we won’t worry about the light number limitations of Single Pass. If you need more lights, you can use Deferred, but consider the extra hardware requirements and the performance cost of not having per-vertex lighting options. Now that we have a very basic notion of how URP handles lighting, let’s start using it!</p>
    <h2 id="_idParaDest-157" class="heading-2">Configuring ambient lighting with skyboxes</h2>
    <p class="normal">There are different light sources<a id="_idIndexMarker784"/> that can affect a scene, such<a id="_idIndexMarker785"/> as the sun, flashlights, light<a id="_idIndexMarker786"/> bulbs, and more. Those are known as <strong class="keyWord">Direct Lights</strong>—that is, objects that emit<a id="_idIndexMarker787"/> light rays. Then, we have <strong class="keyWord">Indirect Light</strong>, which represents how the Direct Light<a id="_idIndexMarker788"/> bounces on other objects, like walls. However, calculating all the bounces of all the rays emitted by all the lights is extremely costly in terms of performance and requires special hardware that supports ray tracing. The problem is that not having Indirect Light will generate unrealistic results, where you can observe places where the sunlight doesn’t reach being completely dark because no light is bouncing from other places where light hits. </p>
    <p class="normal">In the next image you can see an example of how this could look in a wrongly configured scene: </p>
    <figure class="mediaobject"><img src="../Images/B18585_12_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.6: Shadows projected on a mountain without ambient lighting</p>
    <p class="normal">If you ever experience<a id="_idIndexMarker789"/> this problem, the way to solve<a id="_idIndexMarker790"/> it performantly<a id="_idIndexMarker791"/> is using approximations of those bounces. These are what we call <strong class="keyWord">Ambient Light</strong>. This represents a base layer of lighting that usually applies a little bit of light based on the color of the sky, but you can choose whatever color you want. As an example, on a clear night, we can pick a dark blue color to represent the tint from the moonlight.</p>
    <p class="normal">If you create a new scene in Unity 2022, usually this is done automatically, but in cases where it isn’t, or the scene was created through other methods, it is convenient to know how to manually trigger this process by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Click on <strong class="screenText">Window </strong>|<strong class="screenText"> Rendering | Lighting</strong>. This will open the <strong class="screenText">Scene Lighting Settings</strong> window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.7: Lighting Settings location</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Click the <strong class="screenText">Generate Lighting</strong> button at the bottom of the window. If you haven’t saved the scene so far, a prompt will ask you to save it, which is necessary:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.8: Generate Lighting button</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">See the bottom-right<a id="_idIndexMarker792"/> part of the Unity window<a id="_idIndexMarker793"/> to check the progress calculation<a id="_idIndexMarker794"/> bar to check when the process has finished:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_11_091.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.9: Lighting generation progress bar</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">You can now see how completely dark areas are now lit by the light being emitted by the sky:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.10: Shadows with ambient lighting</p>
    <p class="normal">Now, by doing this, we have better lighting, but it still looks like a sunny day. Remember, we want to have rainy weather. In order to do that, we need to change the default sky too so that it’s cloudy. You can do that by downloading a <strong class="keyWord">skybox</strong>. The current sky you can see around the scene is just a big<a id="_idIndexMarker795"/> cube containing textures on each side, and those textures have a special projection<a id="_idIndexMarker796"/> to prevent us from detecting the edges<a id="_idIndexMarker797"/> of the cube. We can download six images for each side of the cube and apply them to have whatever sky you want, so let’s do that:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">You can download skybox textures from wherever you want, but here, I will choose the Asset Store. Open it by going to <strong class="screenText">Window | Asset Store</strong> and going to the Asset Store website.</li>
      <li class="numberedList">Look for <strong class="screenText">Categories | 2D | Textures &amp; Materials | Sky</strong> in the category list on the right. Remember that you need to make that window wider if you can’t see the category list:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.11: Textures &amp; Materials</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Remember to check the <strong class="screenText">Free Assets </strong>checkbox in the <strong class="screenText">Price</strong> options.</li>
      <li class="numberedList">Pick any skybox you like for a rainy day. Take into account that there are different formats for skyboxes. We are using the six-image format, so check that before downloading<a id="_idIndexMarker798"/> one. There’s another format called <strong class="screenText">Cubemap</strong>, which is essentially the same, but we will stick with the six-image format as it is the simplest one to use and modify. In my case, I have chosen the skybox pack shown in <em class="italic">Figure 12.12</em>. Download and import it, as we did in <em class="chapterRef">Chapter 5</em>, <em class="italic">Introduction to C# and Visual Scripting</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.12: Selected skybox set for this book</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Create a new<a id="_idIndexMarker799"/> material by using the <strong class="screenText">+</strong> icon<a id="_idIndexMarker800"/> in the <strong class="screenText">Project</strong> window<a id="_idIndexMarker801"/> and selecting <strong class="screenText">Material</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Shader</strong> option of that material to <strong class="screenText">Skybox/6 sided</strong>. Remember that the skybox is just a cube, so we can apply a material to change how it looks. The skybox shader is prepared to apply the six textures.</li>
      <li class="numberedList">Drag the six textures to the <strong class="screenText">Front</strong>, <strong class="screenText">Back</strong>, <strong class="screenText">Left</strong>, <strong class="screenText">Right</strong>, <strong class="screenText">Up</strong>, and <strong class="screenText">Down</strong> properties of the material. The six downloaded textures will have descriptive names so that you know which textures go where:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.13: Skybox material settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Drag the material directly<a id="_idIndexMarker802"/> into the sky in the Scene view. Be sure you don’t drag the material into an object because<a id="_idIndexMarker803"/> the material will be applied to it.</li>
      <li class="numberedList">Repeat <em class="italic">steps 1</em> to <em class="italic">4</em> of the ambient light<a id="_idIndexMarker804"/> calculation steps (<strong class="screenText">Lighting Settings</strong> | <strong class="screenText">Generate Lighting</strong>) to recalculate it based on the new skybox. In the following image, you can see the result of my project so far:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.14: Applied skybox</p>
    <p class="normal">Now that we have a good base layer of lighting, we can start adding light objects.</p>
    <h2 id="_idParaDest-158" class="heading-2">Configuring lighting in URP </h2>
    <p class="normal">We have three <a id="_idIndexMarker805"/>main types of Direct Lights<a id="_idIndexMarker806"/> we can add to our scene:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Directional Light</strong>: This is a light that<a id="_idIndexMarker807"/> represents the sun. This object emits light rays in the direction it is facing, regardless of its position; the sun moving 100 meters to the right won’t make a big difference. As an example, if you slowly rotate this object, you can generate a day/night cycle:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18585_12_15.png" alt=""/> </figure>
    <p class="packt_figref">Figure 12.15: Directional Light results</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Point Light</strong>: This light represents a light bulb, which<a id="_idIndexMarker808"/> emits rays in an omnidirectional way. The difference it has compared to Directional Lights is that its position matters because it’s closer to our objects. Also, because it’s a weaker light, the intensity of this light varies according to the distance, so its effect has a range—the further the object from the light, the weaker the received intensity:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18585_12_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.16: Point Light results</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Spotlight</strong>: This kind of light represents<a id="_idIndexMarker809"/> a light cone, such as the one emitted by a flashlight. It behaves<a id="_idIndexMarker810"/> similarly to point lights in that its position<a id="_idIndexMarker811"/> matters and the light intensity decays over a certain distance. But here the direction it points to (hence its rotation) is also important, given it will specify where to project the light:<p class="packt_figref"><img src="../Images/B18585_12_17.png" alt=""/></p>
        <p class="packt_figref">Figure 12.17: Spotlight results</p>
      </li>
    </ul>
    <p class="normal">So far, we have nice, rainy, ambient lighting, but the only Direct Light we have in the scene, the Directional Light, won’t look like this, so let’s change that:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <strong class="screenText">Directional Light</strong> object in the <strong class="screenText">Hierarchy</strong> window and then look at the <strong class="screenText">Inspector</strong> window.</li>
      <li class="numberedList">Click the <strong class="screenText">Color</strong> property in the <strong class="screenText">Emission</strong> section to open the Color Picker.</li>
      <li class="numberedList">Select a dark gray color to achieve sun rays partially occluded by clouds.</li>
      <li class="numberedList">Set <strong class="screenText">Shadow Type</strong> to <strong class="screenText">No Shadows</strong>. Now that we have a cloudy day, the sun does not project clear shadows, but we will talk more about shadows in a moment:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.18: Soft directional light with no shadows</p>
    <p class="normal">Now that the scene is darker, we can add some lights to light up the scene, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Spotlight by going to <strong class="screenText">GameObject | Light | Spotlight</strong>.</li>
      <li class="numberedList">Select it. Then, in the Inspector window, set <strong class="screenText">Inner/Output Spot Angle</strong> of the <strong class="screenText">Shape</strong> section to 90 and 120, which will increase the angle of the cone. </li>
      <li class="numberedList">Set <strong class="screenText">Range</strong> in the <strong class="screenText">Emission</strong> section to <code class="inlineCode">50</code>, meaning that the light can reach up to 50 meters, decaying along the way.</li>
      <li class="numberedList">Set <strong class="screenText">Intensity</strong> in the <strong class="screenText">Emission</strong> section to <code class="inlineCode">1000</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.19: Spotlight settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Position<a id="_idIndexMarker812"/> the light<a id="_idIndexMarker813"/> at one corner of your game’s base, pointing it at the center:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.20: Spotlight placement</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Duplicate that light by selecting it and pressing <em class="italic">Ctrl+D</em> (<em class="italic">Command+D</em> on a Mac).</li>
      <li class="numberedList">Put it in the opposite corner of the base:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.21: Two Spotlight results</p>
    <p class="normal">You can keep adding lights<a id="_idIndexMarker814"/> to the scene but take care that you don’t go too far—remember<a id="_idIndexMarker815"/> the light’s limits. Also, you can download some light posts to put in where the lights are located to visually justify the origin of the light. Now that we have achieved proper lighting, we can talk about shadows.</p>
    <h1 id="_idParaDest-159" class="heading-1">Applying shadows</h1>
    <p class="normal">Maybe you are thinking <a id="_idIndexMarker816"/>that we already have shadows in the scene, but actually, we don’t. The darker areas of the object, the ones that are not facing the lights, don’t have shadows—they are not being lit, and that’s quite different from a shadow. In this case, we<a id="_idIndexMarker817"/> are referring to the shadows that are projected from one object to another—for example, the shadow of the player being projected on the floor, or from the mountains to other objects. Shadows can increase the quality of our scene, but they also cost a lot to calculate, so we have two options: not using shadows (recommended for low-end devices such as mobiles) or finding a balance between performance and quality according to our game and the target device.</p>
    <p class="normal">In this section, we are going to discuss the following topics about shadows:</p>
    <ul>
      <li class="bulletList">Understanding shadow calculations</li>
      <li class="bulletList">Configuring performant shadows</li>
    </ul>
    <p class="normal">Let’s start by discussing how Unity calculates shadows.</p>
    <h2 id="_idParaDest-160" class="heading-2">Understanding shadow calculations</h2>
    <p class="normal">In game development, it is well-known<a id="_idIndexMarker818"/> that shadows are costly in terms of performance, but why? An object has a shadow when a light ray hits another object before reaching it. In that case, no lighting is applied to that pixel from that light. The problem here is the same problem we have with the light that ambient lighting simulates—it would be too costly to calculate all possible rays and its collisions. So, again, we need an approximation, and here is where Shadow Maps kick in.</p>
    <p class="normal">A <strong class="keyWord">Shadow Map</strong> is an image that’s rendered from the point<a id="_idIndexMarker819"/> of view of the light, but instead of drawing the full scene with all the color and lighting calculations, it will render all the objects in grayscale, where black means that the pixel is very far from the camera and whiter means that the pixel is nearer to the camera. If you think about it, each<a id="_idIndexMarker820"/> pixel contains information about where a <strong class="keyWord">ray</strong> of light hits. By knowing the position and orientation of the light, you can calculate the position where each “ray” hit using the Shadow Map. </p>
    <p class="normal">In the following image, you can see the shadow map of our Directional Light:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.22: Shadow Map generated by the Directional Light of our scene</p>
    <p class="normal">Each type of light calculates shadow<a id="_idIndexMarker821"/> maps slightly differently, especially the Point Light. Since it’s omnidirectional, it needs to render the scene several times in all its directions (Front, Back, Left, Right, Up, and Down) in order to gather information about all the rays it emits. We won’t talk about this in detail here, though, as we could talk about it all day.</p>
    <p class="normal">Now, something important to highlight here is that shadow maps are textures, and as such, they have a resolution. The higher the resolution, the more “rays” our shadow map calculates. You are probably wondering what a low-resolution shadow map looks like when it has only a few rays in it. Take a look at the following image to see one:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.23: Hard Shadows rendered with a low-resolution Shadow Map</p>
    <p class="normal">The problem here is that having fewer rays<a id="_idIndexMarker822"/> generates bigger shadow pixels, resulting in a pixelated shadow. Here, we have our first configuration to consider: what is the ideal resolution for our shadows? You will be tempted to just increase it until the shadows look smooth, but of course, that will increase how long it will take to calculate it, so it will impact the performance considerably unless your target platform can handle it (mobiles definitely can’t). Here, we can use the <strong class="keyWord">Soft Shadows</strong> trick, where we can apply a blurring<a id="_idIndexMarker823"/> effect over the shadows to hide the pixelated edges, as shown in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.24: Soft Shadows rendered with a low-resolution Shadow Map</p>
    <p class="normal">Of course, the blurry effect is not free, but combining it with low-resolution shadow maps, if you accept its blurry result, can generate a nice balance between quality and performance.</p>
    <p class="normal">Now, low-resolution shadow<a id="_idIndexMarker824"/> maps have another problem, which is called <strong class="keyWord">Shadow Acne</strong>. This is the lighting error you can see in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.25: Shadow Acne from a low-resolution Shadow Map</p>
    <p class="normal">A low-resolution shadow map generates<a id="_idIndexMarker825"/> false positives because it has fewer “rays” calculated. The pixels to be shaded between the rays need to interpolate information from the nearest ones. The lower the Shadow Map’s resolution, the larger the gap between the rays, which means less precision and more false positives. One solution would be to increase the resolution, but again, there will be performance issues (as always). We have some<a id="_idIndexMarker826"/> clever solutions to this, such as using <strong class="keyWord">depth bias</strong>. An example of this can be seen in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.26: A false positive between two far “rays.” The highlighted area thinks the ray hit an object before reaching it.</p>
    <p class="normal">The concept of <strong class="keyWord">depth bias</strong> is simple—so simple<a id="_idIndexMarker827"/> that it seems like a big cheat, and actually, it is, but game development is full of them! To prevent false positives, we “push” the rays a little bit further, just enough to make the interpolated rays reach the surface being lit:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.27: Rays with a depth bias to eliminate false positives</p>
    <p class="normal">Of course, as you are probably<a id="_idIndexMarker828"/> expecting, they don’t solve this problem easily without having a caveat. Pushing depth generates false negatives in other areas, as shown in the following image. It looks like the cube is floating, but actually, it is touching the ground—the false negatives generate the illusion that it is floating:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.28: False negatives due to a high depth bias</p>
    <p class="normal">Of course, we have a counter<a id="_idIndexMarker829"/> trick to this situation known as <strong class="keyWord">normal bias</strong>. This pushes the object’s mesh along the direction they are facing, not the rays. This one is a little bit tricky, so we won’t go into too much detail here, but the idea is that combining a little bit of depth bias and another bit of normal bias will reduce the false positives, but not completely eliminate them. Therefore, we need to learn how to live with that and hide these shadow discrepancies by cleverly positioning objects:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.29: Reduced false positives, which is the result of combining depth and normal bias</p>
    <p class="normal">There are several other aspects that affect how shadow maps work, with one of them being the light range. The smaller the light range, the less area the shadows will cover. The same shadow map resolution can add more detail to that area, so try to reduce the light ranges as much as you can, as we will do in the next section.</p>
    <p class="normal">I can imagine your face right<a id="_idIndexMarker830"/> now, and yes, lighting is complicated, and we’ve only just scratched the surface! But keep your spirits up! After a little trial and error fiddling with the settings, you will understand it better. We’ll do that in the next section.</p>
    <div class="note">
      <p class="normal">If you are really interested in learning more about the internals of the shadow system, I recommend<a id="_idIndexMarker831"/> that you look at the concept of <strong class="keyWord">Shadow Cascades</strong>, an advanced topic about Directional Lights and shadow map generation.</p>
    </div>
    <h2 id="_idParaDest-161" class="heading-2">Configuring performant shadows</h2>
    <p class="normal">Because we are targeting<a id="_idIndexMarker832"/> mid-end devices, we will try to achieve<a id="_idIndexMarker833"/> a good balance of quality and performance here, so let’s start enabling shadows just for the spotlights. The Directional Light shadow won’t be that noticeable, and actually, a rainy sky doesn’t generate clear shadows, so we will use that as an excuse to not calculate those shadows. In order to do this, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select both spotlights by clicking them in the Hierarchy while pressing <em class="italic">Ctrl</em> (<em class="italic">Command</em> on Mac). This will ensure that any changes made in the Inspector window will be applied to both:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.30: Selecting multiple objects</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">In the Inspector window, set <strong class="screenText">Shadow Type</strong> in<a id="_idIndexMarker834"/> the <strong class="screenText">Shadows</strong> section to <strong class="screenText">Soft Shadows</strong>. We will be using<a id="_idIndexMarker835"/> low-resolution shadow maps here and the soft mode can help to hide the pixelated resolution:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.31: Soft Shadows setting</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Select <strong class="screenText">Directional light</strong> and set <strong class="screenText">Shadow Type</strong> to <strong class="screenText">No Shadows</strong> to prevent it from casting shadows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.32: No Shadows setting</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create a cube (<strong class="screenText">GameObject</strong> | <strong class="screenText">3D Object</strong> | <strong class="screenText">Cube</strong>) and place it near one of the lights, just to have an object that we can cast shadows on for testing purposes.</li>
    </ol>
    <p class="normal">Now that we have a base test<a id="_idIndexMarker836"/> scenario, let’s fiddle with the shadow<a id="_idIndexMarker837"/> maps resolution settings, preventing shadow acne in the process:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit</strong> | <strong class="screenText">Project Settings</strong>.</li>
      <li class="numberedList">In the left-hand side list, look for <strong class="screenText">Graphics</strong> and click it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.33: Graphics settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the properties that appear after selecting this option, click in the box below <strong class="screenText">Scriptable Render Pipeline Settings</strong>—the one that contains a name. In my case, this is <strong class="screenText">URP-HighFidelity</strong>, but yours may be different if you have a different version of Unity:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.34: Current Render Pipeline setting</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Doing that will highlight an asset in the Project window, so be sure that the window is visible before selecting it. Select the highlighted asset:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.35: Current pipeline highlighted</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">This asset has several graphics<a id="_idIndexMarker838"/> settings related<a id="_idIndexMarker839"/> to how URP will handle its rendering, including lighting and shadows. Expand the <strong class="screenText">Lighting</strong> section to reveal its settings:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.36: Pipeline lighting settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">The <strong class="screenText">Shadow Resolution</strong> setting under the <strong class="screenText">Additional Lights</strong> subsection represents the shadow map resolution for all the lights that aren’t the Directional Light (since it’s the Main Light). Set it to <code class="inlineCode">1024</code> if it’s not already at that value.</li>
      <li class="numberedList">Under the <strong class="screenText">Shadows</strong> section, you can see the <strong class="screenText">Depth</strong> and <strong class="screenText">Normal Bias</strong> settings, but those will affect all lights. Even if right now our Directional Light doesn’t have shadows, we want only to affect Additional Lights bias values as they have a different Atlas Resolution compared to the Main one (Directional Light), so instead, select out spotlights and set <strong class="screenText">Bias</strong> to <strong class="screenText">Custom</strong> and <strong class="screenText">Depth</strong> and <strong class="screenText">Normal Bias</strong> to <code class="inlineCode">0.25</code> in order to reduce them as much as we can before we remove the shadow acne:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.37: Bias settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">This isn’t entirely related to shadows, but in the Univeral RP settings asset, you can change the <strong class="screenText">Per Object Light</strong> limit to increase or reduce the number of lights that can affect the object (no more than eight). For now, the default is good as is.</li>
      <li class="numberedList">In case you followed the shadow cascades tip presented earlier, you can play with the <strong class="screenText">Cascades</strong> value a little bit to enable shadows for Directional Light to note the effect. Remember that those shadow settings only work for Directional Light.</li>
      <li class="numberedList">We don’t have shadows in <strong class="screenText">Directional Light</strong>, but in any other case, consider reducing the <strong class="screenText">Max Distance </strong>value in the <strong class="screenText">Shadows</strong> section, which will affect the Directional Light shadows range.</li>
      <li class="numberedList">Select both lights in the Hierarchy and set them so that they have a 40-meter <strong class="screenText">Range</strong>. See how the shadows improve in quality before and after this change.</li>
    </ol>
    <p class="normal">Remember that those values only work in my case, so try to fiddle with the values a little bit to see how that changes the result—you may find a better setup for your scene if it was designed differently from mine. Also, remember that not having shadows is always an option, so consider that if your game is running low on<a id="_idIndexMarker840"/> frames per second, also known as FPS (and there isn’t another performance problem lurking).</p>
    <p class="normal">You probably think<a id="_idIndexMarker841"/> that that is all we can do about performance<a id="_idIndexMarker842"/> in terms of lighting, but luckily, that’s not the case! We have another resource we can use to improve it further known as static lighting.</p>
    <h1 id="_idParaDest-162" class="heading-1">Optimizing lighting</h1>
    <p class="normal">We mentioned previously<a id="_idIndexMarker843"/> that not calculating lighting is good for performance, but what about not calculating lights, but still having them? Yes, it sounds too good to be true, but it is actually possible (and, of course, tricky). We can use a technique called static lighting or baking, which allows us to calculate lighting once and use the cached result. </p>
    <p class="normal">In this section, we will cover the following concepts related to static lighting:</p>
    <ul>
      <li class="bulletList">Understanding static lighting</li>
      <li class="bulletList">Baking lightmaps</li>
      <li class="bulletList">Applying static lighting to dynamic objects</li>
    </ul>
    <h2 id="_idParaDest-163" class="heading-2">Understanding static lighting</h2>
    <p class="normal">The idea is pretty simple: just do the lighting<a id="_idIndexMarker844"/> calculations once, save the results, and then use those instead of calculating lighting all the time.</p>
    <p class="normal">You may be wondering why this isn’t the default technique to use. This is because it has some<a id="_idIndexMarker845"/> limitations, with the big one being dynamic objects. <strong class="keyWord">Precalculating shadows</strong> means that they can’t change once they’ve been calculated, but if an object that is casting a shadow is moved, the shadow will still be there, so the main thing to take into account here is that you can’t use this technique with moving<a id="_idIndexMarker846"/> objects. Instead, you<a id="_idIndexMarker847"/> will need to mix <strong class="keyWord">static</strong> or <strong class="keyWord">baked lighting</strong> for static objects and <strong class="keyWord">real-time lighting</strong> for dynamic (moving) objects. Also, consider<a id="_idIndexMarker848"/> that aside from this technique being only valid for static objects, it is also only valid for static lights. Again, if a light moves, the precalculated data becomes invalid.</p>
    <p class="normal">Another limitation you need to take into account is that precalculated data can have a huge impact on memory. That data occupies space in RAM, maybe hundreds of MB, so you need to consider if your target platform has enough space. Of course, you can reduce the precalculated lighting quality to reduce the size of that data, but you need to consider if the loss of quality deteriorates the look and feel of your game too much. As with all options regarding optimization, you need to balance two factors: performance and quality.</p>
    <p class="normal">We have several kinds of precalculated data in our process, but the most important one is what we call <strong class="keyWord">lightmaps</strong>. A lightmap is a texture<a id="_idIndexMarker849"/> that contains all the shadows and lighting for all the objects in the scene, so when Unity applies the precalculated or baked data, it will look at this texture to know which parts of the static objects are lit and which aren’t. </p>
    <p class="normal">You can see an example of a lightmap in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_38.png" alt="Image result for lightmap unity"/> </figure>
    <p class="packt_figref">Figure 12.38: Left, a scene with no lighting; middle, a lightmap holding precalculated data from that scene; and right, the lightmap being applied to the scene</p>
    <p class="normal">Having lightmaps<a id="_idIndexMarker850"/> has its own benefits. The baking process is executed in Unity, before the game is shipped to users, so you can spend plenty of time calculating stuff that you can’t do in runtime, such as improved accuracy, light bounces, light occlusion in corners, and light from emissive objects. However, that can also be a problem. Remember, dynamic objects still need to rely on real-time lighting, and that lighting will look very different compared to static lighting, so we need to tweak them a lot for the user to not notice the difference.</p>
    <p class="normal">Now that we have a basic notion of what static lighting is, let’s dive into how to use it.</p>
    <h2 id="_idParaDest-164" class="heading-2">Baking lightmaps</h2>
    <p class="normal">To use lightmaps, we need<a id="_idIndexMarker851"/> to make some preparations regarding the 3D<a id="_idIndexMarker852"/> models. Remember that meshes have <strong class="keyWord">UVs</strong>, which contain information about which part of the texture needs to be applied to each part of the model. Sometimes, to save texture memory you can apply the same piece of texture to different parts. For example, in a car’s texture, you wouldn’t have four wheels; you’d just have one, and you can apply that same piece of texture to all the wheels. The problem here is that static lighting uses textures the same way, but here, it will apply the lightmaps to light the object. In the wheel scenario, the problem would be that if one wheel receives shadows, all of them will have it, because all the wheels are sharing the same texture space. The usual solution is to have a second set of UVs in the model with no texture space being shared, just for use with lightmapping.</p>
    <p class="normal">Sometimes, downloaded models are already prepared for lightmapping, and sometimes, they aren’t, but luckily, Unity<a id="_idIndexMarker853"/> has us covered in those scenarios. To be sure a model will calculate lightmapping properly, let’s make Unity<a id="_idIndexMarker854"/> automatically generate the <strong class="keyWord">Lightmapping UVs</strong> by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the mesh asset (FBX) in the <strong class="screenText">Project</strong> window.</li>
      <li class="numberedList">In the <strong class="screenText">Model</strong> tab, look for the <strong class="screenText">Generate Lightmap UVs </strong>checkbox at the bottom and check it.</li>
      <li class="numberedList">Click the <strong class="screenText">Apply</strong> button at the bottom:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.39: Generate Lightmap setting</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Repeat this process for every model. Technically, you can only do this in the models where you get artifacts and weird results after baking lightmaps, but for now, let’s do this in all the models just in case.</li>
    </ol>
    <p class="normal">After preparing the models for being lightmapped, the next step is to tell Unity which objects are not going to move. To do so, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the object that won’t move.</li>
      <li class="numberedList">Check the <strong class="screenText">Static</strong> checkbox in the top-right of the Inspector window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.40: Static checkbox</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Repeat this for every static object (this isn’t necessary for lights; we will deal with those later).</li>
      <li class="numberedList">You can also select a container of several objects, check the <strong class="screenText">Static</strong> checkbox, and click the <strong class="screenText">Yes, All Children</strong> button in the prompt to apply the checkbox to all child objects. </li>
    </ol>
    <p class="normal">Consider that you may not want every object, even if it’s static, to be lightmapped, because the more objects<a id="_idIndexMarker855"/> you lightmap, the more texture size you will require. As an example, the terrain could be too large and would consume most of the lightmapping’s size. Usually, this is necessary, but in our case, the spotlights are barely touching the terrain. Here, we have two options: leave the terrain as dynamic, or better, directly tell the spotlights to not affect the terrain since one is only lit by ambient lighting and the Directional Light (which is not casting shadows). Remember that this is something we can do because of our type of scene; however, you may need to use other settings in other scenarios. You can exclude an object from both real-time and static lighting calculations by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the object to exclude.</li>
      <li class="numberedList">In the Inspector window, click the <strong class="screenText">Layer</strong> dropdown and click on <strong class="screenText">Add Layer…</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.41: Layer creation button</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Here, you can create a layer, which is a group of objects that are used to identify which objects are not going to be affected by lighting. In the <strong class="screenText">Layers</strong> list, look for an empty space and type in any name for those kinds of objects. In my case, I will only exclude the terrain, so I have just named it <strong class="screenText">Terrain</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.42: Layers list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Once again, select<a id="_idIndexMarker856"/> the terrain, go to the <strong class="screenText">Layer</strong> dropdown, and select the layer you created in the previous step. This way, you can specify that this object belongs to that group of objects:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.43: Changing a GameObject’s layer</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Select all the spotlights lights, look for the <strong class="screenText">Culling Mask</strong> in the <strong class="screenText">Rendering</strong> section in the Inspector window, click it, and uncheck the layer you created previously. This way, you can specify that those lights won’t affect that group of objects:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.44: Light Culling Mask</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Now, you can see how those selected lights are not illuminating or applying shadows to the terrain.</li>
    </ol>
    <p class="normal">Now, it’s time for the lights<a id="_idIndexMarker857"/> since the <strong class="screenText">Static</strong> checkbox won’t work for them. For them, we have the following three modes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Realtime</strong>: A light in Realtime mode will affect all<a id="_idIndexMarker858"/> objects, both static and dynamic, using real-time lighting, meaning there’s no pre-calculation. This is useful for lights that are not static, such as the player’s flashlight, a lamp that is moving due to the wind, and so on.</li>
      <li class="bulletList"><strong class="keyWord">Baked</strong>: The opposite of Realtime, this kind<a id="_idIndexMarker859"/> of light will only affect static objects with lightmaps. This means that if the player (dynamic) moves under a baked light on the street (static), the street will look lit, but the player will still be dark and won’t cast any shadows on the street. The idea is to use this on lights that won’t affect any dynamic object, or on lights that are barely noticeable on them, so that we can increase performance by not calculating them.</li>
      <li class="bulletList"><strong class="keyWord">Mixed</strong>: This is the preferred mode in case<a id="_idIndexMarker860"/> you are not sure which one to use. This kind of light will calculate lightmaps for static objects, but will also affect dynamic objects, combining its Realtime lighting with the baked one (like Realtime lights also do).</li>
    </ul>
    <p class="normal">In our case, our Directional Light will only affect the terrain, and because we don’t have shadows, applying lighting to it is relatively cheap in URP, so we can leave the Directional Light in Realtime so that it won’t take up any lightmap texture area. </p>
    <p class="normal">Our spotlights are affecting the base, but actually, they are only applying lighting to them—we have no shadows because our base is empty. In this case, it is preferable to not calculate lightmapping whatsoever, but for learning purposes, I will add a few objects as obstacles to the base to cast some shadows and justify the use of lightmapping, as shown in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.45: Adding objects to project light</p>
    <p class="normal">Here, you can see how the original design<a id="_idIndexMarker861"/> of our level changes constantly during the development of the game, and that’s something you can’t avoid—bigger parts of the game will change over time. Now, we are ready to set up the Light Modes and execute the baking process, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <strong class="screenText">Directional Light</strong> in the <strong class="screenText">Hierarchy</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Mode</strong> property of the <strong class="screenText">General</strong> section in the Inspector window to <strong class="screenText">Realtime</strong> (if it’s not already in that mode).</li>
      <li class="numberedList">Select both Spotlights.</li>
      <li class="numberedList">Set their <strong class="screenText">Render Mode</strong> to <strong class="screenText">Mixed</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.46: Mixed lighting setting for Spotlights, the mode will be Realtime for the Directional Light</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Open the <strong class="screenText">Lighting Settings</strong> window (<strong class="screenText">Window </strong>| <strong class="screenText">Rendering</strong> | <strong class="screenText">Lighting</strong>).</li>
      <li class="numberedList">We want to change<a id="_idIndexMarker862"/> some of the settings of the baking process. In order to enable the controls for this, click the <strong class="screenText">New Lighting Settings</strong> button. This will create an asset with lightmapping settings that can be applied to several scenes in case we want to share the same settings multiple times:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.47: Creating lighting settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Reduce the quality of lightmapping, just to make the process go faster. Just to iterate, the lighting can easily be reduced by using settings such as <strong class="screenText">Lightmap Resolution</strong>, <strong class="screenText">Direct Samples</strong>, <strong class="screenText">Indirect Samples</strong>, and <strong class="screenText">Environment Samples</strong>, all of them located under the <strong class="screenText">Lightmapping Settings</strong> category. In my case, I have those settings applied, as shown in the following image. Note that even reducing those will take time; we have too many objects in the scene due to the modular level design:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.48: Scene lighting settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Click <strong class="screenText">Generate Lighting</strong>, which<a id="_idIndexMarker863"/> is the same button we used previously to generate ambient lighting.</li>
      <li class="numberedList">Wait for the process to complete. You can do this by checking the progress bar at the bottom-right of the Unity editor. Note that this process could take even hours in large scenes, so be patient:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_49.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.49: Baking progress bar</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">After the process has completed, you can check the bottom part of the <strong class="screenText">Lighting settings</strong> window, where you can see how many lightmaps need to be generated. We have a maximum lightmap resolution, so we probably need several of them to cover the entire scene. Also, it informs us of their size so that we can consider their impact in terms of RAM. Finally, you can check out the <strong class="screenText">Baked Lightmaps</strong> section to see them:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_50.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.50: Generated lightmaps</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Now, based on the results, you<a id="_idIndexMarker864"/> can move objects, modify light intensities, or make whatever correction you would need in order to make the scene look the way you want and recalculate the lighting every time you need to. In my case, those settings gave me good enough results, which you can see in the following image:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_51.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.51: Lightmap result</p>
    <p class="normal">We still have plenty of small settings<a id="_idIndexMarker865"/> to touch on, but I will leave you to discover those through trial and error or by reading the Unity documentation<a id="_idIndexMarker866"/> about lightmapping over at: <a href="https://docs.unity3d.com/Manual/Lightmappers.html"><span class="url">https://docs.unity3d.com/Manual/Lightmappers.html</span></a>. Reading the Unity manual is a good source of knowledge and I recommend that you start using it—any good developer, no matter how experienced, should read the manual. </p>
    <h2 id="_idParaDest-165" class="heading-2">Applying static lighting to static objects</h2>
    <p class="normal">When marking objects as static<a id="_idIndexMarker867"/> in your scene, you probably figured out that all the objects in the scene won’t move, so you probably checked the static checkbox for everyone. That’s ok, but you should always put a dynamic object into the scene to really be sure that everything works ok—no games have totally static scenes. Try adding a capsule and moving it around to simulate our player, as shown in the following image. If you pay attention to it, you will notice something odd—the shadows being generated by the lightmapping process are not being applied to our dynamic object:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_52.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.52: Dynamic object under a lightmap’s precalculated shadow</p>
    <p class="normal">You may be thinking that Mixed Light Mode<a id="_idIndexMarker868"/> was supposed to affect both dynamic and static objects, and that is exactly what it’s doing. The problem here is that everything related to static objects is pre-calculated into those lightmap textures, including the shadows they cast, and because our capsule is dynamic, it wasn’t there when the pre-calculation process was executed. So, in this case, because the object that cast the shadow was static, its shadow won’t affect any dynamic object.</p>
    <p class="normal">Here, we have several solutions. The first would be to change the Static and Realtime mixing algorithm to make everything near the camera use Realtime lighting and prevent this problem (at least near the focus of attention of the player), which will have a big impact<a id="_idIndexMarker869"/> on performance. The alternative is to use <strong class="keyWord">Light Probes</strong>. When we baked information, we only did that on lightmaps, meaning that we have information on lighting just over surfaces, not in empty spaces. Because our player is traversing the empty spaces between those surfaces, we don’t know exactly how the lighting would look in those spaces, such as the middle of a corridor. Light Probes are a set of points in those empty spaces where Unity also pre-calculates information, so when some dynamic object passes through the Light Probes, it will sample information from them. In the following image, you can see some Light Probes that have been applied to our scene. You will notice that the ones that are inside shadows are going to be dark, while the ones exposed to light will have a greater intensity. </p>
    <p class="normal">This effect will be applied to our dynamic objects:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_53.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.53: Spheres representing Light Probes</p>
    <p class="normal">If you move your object through<a id="_idIndexMarker870"/> the scene now, it will react to the shadows, as shown in the following two images, where you can see a dynamic object being lit outside a baked shadow and being dark inside:</p>
    <figure class="mediaobject"><img src="../Images/B18585_12_54.png" alt=""/> </figure>
    <p class="packt_figref">Figure 12.54: Dynamic object receiving baked lighting from Light Probes</p>
    <p class="normal">In order to create Light Probes, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a group of <strong class="screenText">Light</strong> <strong class="screenText">Probes</strong> by going to <strong class="screenText">GameObject | Light | Light Probe Group</strong>.</li>
      <li class="numberedList">Fortunately, we have some guidelines on how to locate them. It is recommended to place<a id="_idIndexMarker871"/> them where the lighting changes, such as inside and outside shadow borders. However, that is complicated. The simplest and recommended approach is to just drop a grid of Light Probes all over your playable area. To do that, you can simply copy and paste the Light Grid Group several times to cover the entire base:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_55.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.55: Light Probe grid</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Another approach would be to select one group and click the <strong class="screenText">Edit Light Probes</strong> button to enter Light Probe edit mode:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_12_56.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.56: Light Probe Group edit button</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Click the <strong class="screenText">Select All</strong> button and then <strong class="screenText">Duplicate Selected</strong> to duplicate all the previously existing probes.</li>
      <li class="numberedList">Using the translate gizmo, move them next to the previous ones, extending the grid in the process. Consider that the nearer the probes are, you more you will need to cover the terrain, which will generate more data. However, Light Probes data is relatively cheap in terms of performance, so you can have lots of them, as seen in <em class="italic">Figure 12.55</em>.</li>
      <li class="numberedList">Repeat <em class="italic">steps 4</em> and <em class="italic">5</em> until you’ve covered the entire area.</li>
      <li class="numberedList">Regenerate lighting with the <strong class="screenText">Generate Lighting</strong> button in <strong class="screenText">Lighting Settings</strong>.</li>
    </ol>
    <p class="normal">With that, you have pre-calculated lighting<a id="_idIndexMarker872"/> on the Light Probes affecting our dynamic objects, combining both worlds to get cohesive lighting.</p>
    <h1 id="_idParaDest-166" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed several lighting topics, such as how Unity calculates lights and shadows, how to deal with different light sources such as direct and indirect lighting, how to configure shadows, how to bake lighting to optimize performance, and how to combine dynamic and static lighting so that the lights aren’t disconnected from the world they affect. This was a long chapter, but lighting deserves that. It is a complex subject that can improve the look and feel of your scene drastically, as well as reduce your performance dramatically. It requires a lot of practice and here, we tried to summarize all the important knowledge you will need to start experimenting with it. Be patient with this topic; it is easy to get incorrect results, but you are probably just one checkbox away from solving it.</p>
    <p class="normal">Now that we have improved all we can in the scene settings, in the next chapter, we will apply a final layer of graphic effects using the Unity Post-Processing Stack, which will apply full-screen image effects—the ones that will give us that cinematic look and feel that all games have nowadays.</p>
    <h1 class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. </p>
    <p class="normal">Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. </p>
    <p class="normal">Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><img src="../Images/Nicolas_QR_Code.png" alt=""/></p>
    <p class="normal"><a href="Chapter_12.xhtml"><span class="url">https://packt.link/handsonunity22</span></a></p>
  </div>
</body></html>