- en: '*Chapter 9*: Creating a 2D Shop Interface and In-Game HUD'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：创建 2D 商店界面和游戏内 HUD'
- en: In this chapter, we will be paying attention to our shop interface and how we
    can improve it visually, as well as its functionality. The current shop works
    well, but we could make it support multiple screen ratios. We could also introduce
    Unity's Event system and Button components, as well as a few other new functionalities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注我们的商店界面以及我们如何从视觉和功能上改进它。当前的商店运行良好，但我们可以使它支持多种屏幕比例。我们还可以引入 Unity 的
    Event 系统和 Button 组件，以及一些其他新功能。
- en: 'The other area we will be visiting in this chapter is the in-game **Heads-Up
    Display** (**HUD**). This is fairly common in games where we have the game''s
    information displayed at a particular location on the screen. We will be displaying
    our player''s lives and score and a mini-map to show where our enemies are. This
    can be seen in the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将访问的另一个区域是游戏内的**抬头显示**（**HUD**）。这在游戏中很常见，我们在屏幕的特定位置显示游戏信息。我们将显示玩家的生命值和得分以及迷你地图来显示敌人的位置。这可以在以下截图中看到：
- en: '![Figure 9.1 – Our in-game HUD'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 我们游戏内的 HUD'
- en: '](img/Figure_9.01_B18381.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B18381.jpg)'
- en: Figure 9.1 – Our in-game HUD
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 我们游戏内的 HUD
- en: 'The other half of this chapter will be about improving the 2D visuals of our
    shop scene so that there are choices in terms of the upgrades we can buy and so
    that we can also expand the size of the shop dynamically. Also, your shop scene
    will support any landscape ratio, unlike what it did previously. The following
    screenshot shows what our shop looks like in different ratio sizes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一部分将关于改进我们的商店场景的 2D 视觉，以便在我们可以购买升级方面有选择，并且我们还可以动态地扩展商店的大小。此外，您的商店场景将支持任何横幅比例，与之前不同。以下截图显示了我们的商店在不同比例大小下的样子：
- en: '![Figure 9.2 – The left side displays all buttons; the right side cuts off
    the button edges'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 左侧显示所有按钮；右侧裁剪了按钮边缘'
- en: '](img/Figure_9.02_B18381.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B18381.jpg)'
- en: Figure 9.2 – The left side displays all buttons; the right side cuts off the
    button edges
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 左侧显示所有按钮；右侧裁剪了按钮边缘
- en: 'In the previous screenshot, notice that the **3:2** screen ratio cuts off some
    of the screen (you will especially notice this from each screen''s selection grid
    spacing) compared to our **1920 x 1080 (16:9)** screen ratio. By the end of this
    chapter, our shop scene will look like the one shown in the following screenshot,
    no matter what landscape ratio our game is in:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，请注意，**3:2** 的屏幕比例相对于我们的 **1920 x 1080 (16:9)** 屏幕比例会裁剪掉一些屏幕（您将特别注意到每个屏幕的选择网格间距）。到本章结束时，我们的商店场景将看起来像以下截图所示，无论我们的游戏处于何种横幅比例：
- en: '![Figure 9.3 – Our in-game shop with a flexible UI display (no cutoff)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 我们游戏内的商店具有灵活的 UI 显示（无裁剪）'
- en: '](img/Figure_9.03_B18381.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B18381.jpg)'
- en: Figure 9.3 – Our in-game shop with a flexible UI display (no cutoff)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 我们游戏内的商店具有灵活的 UI 显示（无裁剪）
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up our HUD
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的 HUD
- en: Making our `shop` scene support alternative screen ratios
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的 `shop` 场景支持替代屏幕比例
- en: Applying and modifying our `shop` scripts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用和修改我们的 `shop` 脚本
- en: Let's start by reviewing the core exam skills that will be covered in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾本章将涵盖的核心考试技能开始。
- en: Core exam skills covered in this chapter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: 'The following are the core exam skills that will be covered in this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将涵盖的核心考试技能：
- en: '*Working in the art pipeline*:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作*：'
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与 Unity 渲染 API 交互的脚本。
- en: '*Developing application systems*:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发应用程序系统*：'
- en: Interpret scripts for application interface flow such as menu systems, UI navigation,
    and application settings.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释应用程序界面流程的脚本，例如菜单系统、UI 导航和应用设置。
- en: Interpret scripts for user-controlled customization such as character creators,
    inventories, storefronts, and in-app purchases.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释用户控制的定制脚本，如角色创建器、库存、店面和在应用内购买。
- en: Analyze scripts for user progression features such as scoring, leveling, and
    in-game economies utilizing technologies such as Unity Analytics and PlayerPrefs.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析使用 Unity Analytics 和 PlayerPrefs 等技术实现的用户进度功能，如评分、等级和游戏内经济。
- en: Analyze scripts for 2D overlays, such as HUDs, minimaps, and advertisements.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 2D 悬浮层脚本，如 HUD、小地图和广告。
- en: Identify scripts for saving and retrieving application and user data.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于保存和检索应用程序和用户数据的脚本。
- en: '*Programming for scene and environment design*:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为场景和环境设计编程*：'
- en: Identify methods for implementing Game Object instantiation, destruction, and
    management.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现游戏对象实例化、销毁和管理的方案。
- en: '*Optimizing for performance and platforms*:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*针对性能和平台进行优化*：'
- en: Identify optimizations to address requirements for specific build platforms
    and/or hardware configurations.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别针对特定构建平台和/或硬件配置的要求的优化。
- en: Determine common UI affordances and optimizations for XR platforms.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定适用于XR平台的常见UI功能和优化。
- en: '*Working in professional software development teams*:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在专业软件开发团队中工作*：'
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于构建模块化、可读性和可重用性的脚本结构技术。
- en: Technical requirements
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09)找到
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的全部内容，在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All the content for this chapter is held in this chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in this
    chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都包含在本章的`unitypackage`文件中，包括一个包含本章我们将执行的所有工作的`Complete`文件夹。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3LsxDWC](https://bit.ly/3LsxDWC).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码执行情况*：[https://bit.ly/3LsxDWC](https://bit.ly/3LsxDWC)。
- en: Setting up our HUD
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的HUD
- en: With side-scrolling shooter games, it is common for us to have some form of
    recording of how many lives the player has, what their score is, a time limit,
    power-ups, and more. We are going to apply a typical HUD to show a similar set
    of information. Knowing about HUDs is a requirement of the Unity Programmer Exam.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧滚动射击游戏中，我们通常会有一些形式的记录，比如玩家有多少生命值，他们的分数是多少，时间限制，升级等。我们将应用一个典型的HUD来显示一组类似的信息。了解HUD是Unity程序员考试的要求之一。
- en: 'By the end of this section, we will have created a HUD for our game that will
    consist of the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将为我们的游戏创建一个包含以下内容的HUD：
- en: Lives
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值
- en: Mini-map
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小地图
- en: Score
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: Before we add our HUD, we need to decide where it will sit on top of our game
    screen. As an example, we will pick a game so that we can briefly study how its
    HUD information is displayed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加我们的HUD之前，我们需要决定它将位于我们的游戏屏幕的哪个位置。作为一个例子，我们将选择一个游戏，这样我们可以简要研究其HUD信息是如何显示的。
- en: 'We will be looking at a game called **Super R-Type**, which can be found at
    [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg).
    Here, at the bottom of the screen, we can see that its HUD is made up of four
    parts, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个名为**Super R-Type**的游戏，可以在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg)找到。在这里，屏幕底部我们可以看到其HUD由以下四个部分组成：
- en: Skill level
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技能水平
- en: Lives
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值
- en: Power bar
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力量条
- en: Score
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: Behind these details is a black background so that the scene doesn't interfere
    when it comes to reading the HUD.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些细节的后面是一个黑色背景，这样在读取HUD时场景就不会干扰。
- en: 'So, in this section, we''ll start by declaring the HUD space and giving it
    a dark background. To do this, follow these instructions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们将首先声明HUD空间并为其设置深色背景。为此，请按照以下说明操作：
- en: In the Unity Editor, navigate to `Assets/Scene` in the **Project** window.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，导航到**项目**窗口中的`Assets/Scene`。
- en: Open the `level1` scene.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`level1`场景。
- en: With `level1` loaded, go to the `Canvas` game object, and select **UI** | **Image**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`level1`后，转到`Canvas`游戏对象，并选择**UI** | **Image**。
- en: A game object called `Image` will appear in the `Canvas` game object.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`游戏对象中会出现一个名为`Image`的游戏对象。
- en: From the previous chapter, we should know that a game object containing an `Canvas`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们应该知道包含`Canvas`的游戏对象。
- en: Right-click the `Image` game object and select `background`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Image`游戏对象并选择`background`。
- en: So far, we have created a game object that holds an **Image** component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个包含**图像**组件的游戏对象。
- en: 'Now, let''s move on and scale this game object into its correct placeplace
    so that it can be used as a background for our HUD. Follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并缩放这个游戏对象到正确的位置，使其可以作为HUD的背景使用。按照以下步骤操作：
- en: 'With our `background` game object still selected, alter the **Rect Transform**
    settings in the **Inspector** window to the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`background`游戏对象仍然被选中时，在**检查器**窗口中更改**矩形变换**设置如下：
- en: t
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: t
- en: '![Figure 9.4 – background Rect Transform property settings'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 背景矩形变换属性设置'
- en: '](img/Figure_9.04_B18381.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B18381.jpg)'
- en: Figure 9.4 – background Rect Transform property settings
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 背景矩形变换属性设置
- en: 'Our `background` game object should be scaled to the same proportions and centered
    as a white bar at the bottom of the screen, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`background`游戏对象应该缩放到与屏幕底部白色条相同的比例并居中，如下面的截图所示：
- en: '![Figure 9.5 – Game window showing the placement of our background game object'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – 显示我们背景游戏对象位置的游戏窗口'
- en: '](img/Figure_9.05_B18381.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B18381.jpg)'
- en: Figure 9.5 – Game window showing the placement of our background game object
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 显示我们背景游戏对象位置的游戏窗口
- en: Now, let's darken this `background` game object so that it blends in with our
    game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个`background`游戏对象变暗，使其与我们的游戏融合。
- en: 'With the `background` game object still selected, in the `12`, `13`, `13`,
    `210`, as shown in the following screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`background`游戏对象仍然被选中时，在`12`，`13`，`13`，`210`，如下面的截图所示：
- en: '![Figure 9.6 – background color and alpha values'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 背景颜色和alpha值'
- en: '](img/Figure_9.06_B18381.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.06_B18381.jpg)'
- en: Figure 9.6 – background color and alpha values
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 背景颜色和alpha值
- en: The `background` game object has changed color from its default white to a dark,
    slightly transparent color.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`background`游戏对象的颜色已从默认的白色变为深色，略带透明。'
- en: 'The area for our HUD has been set. The following subsections will go through
    each segment of our HUD and explain how to create the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: HUD的区域已经设置。以下小节将逐一介绍我们的HUD的每个部分，并解释如何创建以下内容：
- en: '`GameManager` script. Each life will be grouped neatly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager`脚本。每个生命值将被整齐地分组。'
- en: '**Display score**: The script already keeps track of the player''s score, so
    all we need to do is use a **Text** component to keep the information up to date.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示分数**：脚本已经跟踪了玩家的分数，所以我们只需要使用一个**文本**组件来保持信息更新。'
- en: '**Mini-map**: The mini-map will work visually similar to a radar, where the
    player will be able to see the wave of enemy opponents approaching them. This
    mini-map will be made using a second camera at a wider angle and will only display
    colored dots instead of the actual ships themselves.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迷你地图**：迷你地图将视觉上类似于雷达，玩家将能够看到接近他们的敌人对手的波浪。这个迷你地图将使用一个更宽角度的第二个摄像头，并且只显示彩色点而不是实际的船只本身。'
- en: Now, we can begin filling the HUD with data that we have already made in our
    script, starting with the player's lives.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始用我们在脚本中已经制作的数据填充HUD，从玩家的生命值开始。
- en: Displaying the player's lives
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家的生命值
- en: The player starts the game with three lives. The two typical ways of displaying
    the number of lives to the player are by displaying a number count or showing
    a little icon for each life they have. Let's go for the latter as we can use a
    couple of Unity components we haven't used before.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家开始游戏时有三个生命值。向玩家显示生命值有两种典型方式：显示数字计数或显示每个生命值的小图标。让我们选择后者，因为我们可以使用一些我们之前没有使用过的Unity组件。
- en: This section will also include some extra code that will be put into our `GameManager`
    script. This code will run a check to see how many lives the player has. With
    each life that's found, a game object will be created that holds an image.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将包括一些额外的代码，这些代码将被放入我们的`GameManager`脚本中。此代码将运行检查以查看玩家有多少生命值。对于找到的每个生命值，将创建一个包含图像的游戏对象。
- en: Adding a Horizontal Layout Group component to our game object
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向我们的游戏对象添加水平布局组组件
- en: 'All game object lives that will be created will be stored in a game object
    called `lives`. Let''s continue working on the HUD and add the `lives` game object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建的所有游戏对象生命值将存储在一个名为`lives`的游戏对象中。让我们继续工作在HUD上并添加`lives`游戏对象：
- en: In the `Canvas` game object and select **Create empty** from the drop-down list.
    A new empty game object will be created.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图9.7 – lives Rect Transform属性设置'
- en: Right-click the new game object and select `lives`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新游戏对象并选择`lives`。
- en: 'Next, position the `lives` game object by adding the **Rect Transform** properties
    shown in the following screenshot:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过添加以下截图所示的**矩形变换**属性来定位`lives`游戏对象：
- en: '![Figure 9.7 – lives Rect Transform property settings'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.09_B18381.jpg)'
- en: '](img/Figure_9.07_B18381.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个游戏对象，该对象将包含一个**图像**组件，它将成为玩家飞船的象征。我们还将专门调整其大小，使其与其他生命值保持一致。
- en: Figure 9.7 – lives Rect Transform property settings
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.08_B18381.jpg)'
- en: The last thing we need to do to the `lives` game object is to give it a **Horizontal
    Layout Group** component. This component will make it so that when we create an
    image to represent each life the player has, we'll display a spaceship image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – lives Rect Transform属性设置
- en: 'The **Horizontal Layout Group** component will put each spaceship image in
    a stacked order. To add this component, follow these steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表示生命值的图像
- en: With the `lives` game object still selected, click the **Add Component** button
    in the **Inspector** window.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`lives`游戏对象的情况下，点击**检查器**窗口中的**添加组件**按钮。
- en: The `Horizontal Layout Group` until you see it on the list. When you do, select
    it.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`游戏对象中，选择**UI**然后从下拉列表中选择**图像**。
- en: '*Figure 9.8* shows the `lives` game object. We will need to alter some values
    of each `life` image so that they aren''t too large.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.8*显示了`lives`游戏对象。我们需要调整每个`life`图像的一些值，以便它们不要太大了。'
- en: 'Change the **Horizontal Layout Group** property values to the ones shown in
    the following screenshot (you may need to click the arrow next to **Padding**
    to expand its content):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**水平布局组**属性值更改为以下截图所示（您可能需要单击**填充**旁边的箭头以展开其内容）：
- en: '![Figure 9.8 – Horizontal Layout Group property values'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表示生命值的图像
- en: '](img/Figure_9.08_B18381.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 选择游戏对象，右键单击它，然后从下拉列表中选择**重命名**。
- en: Figure 9.8 – Horizontal Layout Group property values
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – Horizontal Layout Group属性值
- en: So far, we have created a game object called `lives` that will store and automatically
    order each player's ship image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个名为`lives`的游戏对象，用于存储和自动排序每个玩家的飞船图像。
- en: 'In the next section, we are going to create a game object that will house each
    player''s ship image. As an example of what''s to come in the next two sections,
    the following screenshot demonstrates our `lives` game object holding each `life`
    game object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个游戏对象，用于存放每个玩家的飞船图像。作为下一两节将要介绍内容的示例，以下截图展示了我们的`lives`游戏对象如何存放每个`life`游戏对象：
- en: '![Figure 9.9 – Three lives spaced and in correct proportion'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.09 – 三条生命值均匀分布且比例正确'
- en: '](img/Figure_9.09_B18381.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.09 – lives Rect Transform属性设置'
- en: Figure 9.9 – Three lives spaced and in correct proportion
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.07 – 三条生命值均匀分布且比例正确'
- en: Now, let's move on to making a game object called `life` that will store a spaceship
    icon.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续制作一个名为`life`的游戏对象，用于存储飞船图标。
- en: Creating images to represent our life count
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**水平布局组**组件将把每个飞船图像按堆叠顺序排列。要添加此组件，请按照以下步骤操作：'
- en: In this section, we are going to create a game object that will hold an **Image**
    component that will be a symbol of the player ship. We will also be sizing it
    specifically so that it's uniform with the other lives it sits with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 找到**水平布局组**，直到它在列表中。找到后，选择它。
- en: 'Let''s start by creating a game object that holds an **Image** component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个包含**图像**组件的游戏对象：
- en: In the `Canvas` game object and select **UI** and then **Image** from the drop-down
    list.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对`lives`游戏对象做的最后一件事是给它添加一个**水平布局组**组件。此组件将确保当我们创建代表玩家生命的图像时，我们将显示飞船图像。
- en: Select the game object, right-click it, and select **Rename** from the drop-down
    list.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图9.08 – Horizontal Layout Group属性值'
- en: Rename the newly created game object `life`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的游戏对象重命名为`life`。
- en: 'Add an image and color to the **Image** component, as shown in the following
    screenshot:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图像**组件中添加图像和颜色，如图下截图所示：
- en: '![Figure 9.10 – Click the remote button to access which source image is used
    for the Image component'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10 – 点击远程按钮以访问用于图像组件的源图像'
- en: '](img/Figure_9.10_B18381.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.08 – Horizontal Layout Group属性值'
- en: Figure 9.10 – Click the remote button to access which source image is used for
    the Image component
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 点击远程按钮以访问用于图像组件的源图像
- en: To add a source image to the `life` game object, click the **remote** button
    to the side of **Source Image** (denoted by an arrow in the previous screenshot).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将源图像添加到`life`游戏对象中，请点击**远程**按钮，该按钮位于**源图像**旁边（如前一张截图中的箭头所示）。
- en: In the drop-down list, start typing `life` until you see it appear, and then
    click it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中开始输入`life`，直到您看到它出现，然后点击它。
- en: 'Our ship icon should look like the one shown in the following screenshot. If
    it doesn''t, it may have a **Default** texture type and will need to be changed
    to a **Sprite**. We covered how to change this in [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107),
    *Creating a Shop Scene for Our Game*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们飞船图标应该看起来像下面截图所示的那样。如果它不是这样，它可能有一个**默认**纹理类型，需要将其更改为**精灵**。我们已经在[*第5章*](B18381_05_Epub.xhtml#_idTextAnchor107)，*为我们的游戏创建商店场景*中介绍了如何更改这一点：
- en: '![Figure 9.11 – Our ship sprite life'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.11 – Our ship sprite life](img/Figure_9.11_B18381.jpg)'
- en: '](img/Figure_9.11_B18381.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.11 – Our ship sprite life](img/Figure_9.11_B18381.jpg)'
- en: Figure 9.11 – Our ship sprite life
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.11 – Our ship sprite life
- en: I'm going to change the color of the icon slightly as it's possibly a bit too
    distracting for the player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我将稍微改变图标的颜色，因为它可能对玩家来说有点分散注意力。
- en: With the `life` game object still selected, click the `153`, `177`, `177`, `255`).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`life`游戏对象的情况下，点击`153`、`177`、`177`、`255`。
- en: Make sure to tick the **Preserve Aspect** box in the **Image** component so
    our life doesn't lose its proportions.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**图像**组件中勾选**保留纵横比**框，以便我们的生命值不会失去其比例。
- en: That's our `life` game object created. The final thing we need to do to it is
    to turn it into a prefab. As a reminder, the benefits of a prefab are that we
    have a game object with its components, preferences, and settings all stored.
    The prefab will allow us to create as many clones as required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`life`游戏对象创建完成。我们需要对它做的最后一件事是将它转换成一个预制体。作为提醒，预制体的好处是我们可以创建一个包含其组件、首选项和设置的完整游戏对象。预制体将允许我们创建所需数量的克隆。
- en: 'To turn this `life` game object into a prefab, do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此`life`游戏对象转换为预制体，请执行以下操作：
- en: In the `Assets/Resources`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Resources`文件夹中。
- en: Click and drag the `life` game object from the `Prefab` folder. That's our prefab
    created.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Prefab`文件夹中拖动`life`游戏对象到场景中。这就是我们创建的预制体。
- en: We can now delete the `life` game object in the **Hierarchy** window as we will
    be creating this game object with code in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在**层次结构**窗口中删除`life`游戏对象，因为我们将在下一节中用代码创建这个游戏对象。
- en: Coding our UI life counter
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写我们的UI生命计数器代码
- en: In this section, we are going to revisit the `GameManager` script, taking the
    information about the player's life count and displaying it in the form of our
    UI system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新访问`GameManager`脚本，获取玩家的生命计数信息，并以我们的UI系统形式显示。
- en: 'The following screenshot shows a section of the `level1` scene''s `Canvas`
    game object. Within `Canvas` is the HUD `background` game object at the top, followed
    by the `lives` game object. Finally, with our code (which we will write shortly),
    we have created three `life` game objects within our `lives` game object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`level1`场景的`Canvas`游戏对象的一部分。在`Canvas`中，顶部是HUD的`background`游戏对象，然后是`lives`游戏对象。最后，通过我们的代码（我们将在下面编写），我们在`lives`游戏对象内部创建了三个`life`游戏对象：
- en: '![Figure 9.12 – Our Hierarchy containing a lives game object and its life children'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.12 – Our Hierarchy containing a lives game object and its life children](img/Figure_9.12_B18381.jpg)'
- en: '](img/Figure_9.12_B18381.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.12 – Our Hierarchy containing a lives game object and its life children](img/Figure_9.12_B18381.jpg)'
- en: Figure 9.12 – Our Hierarchy containing a lives game object and its life children
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.12 – Our Hierarchy containing a lives game object and its life children
- en: 'To instantiate the `life` game objects so that they show the same amount as
    our player''s lives, do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化`life`游戏对象，使它们显示与玩家生命值相同数量的对象，请执行以下操作：
- en: In the `Assets/Script` folder.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中。
- en: Double-click the file to open `GameManager`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件以打开`GameManager`。
- en: The `GameManager` script already has an `Awake()` function, which is the first
    thing the script tries to activate once the script becomes active. What we don't
    currently have is a `Start()` function that gets called after `Awake()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager`脚本已经有一个`Awake()`函数，这是脚本一旦激活就会尝试激活的第一个函数。我们目前没有的是在`Awake()`之后被调用的`Start()`函数。'
- en: We can create a `Start()` function in `GameManager` and make it call a method
    that we are going to make shortly, called `SetLivesDisplay`, and send it our `playerLives`
    variable, which is the count of the player's lives.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`GameManager`中创建一个`Start()`函数，并让它调用我们即将创建的方法，即`SetLivesDisplay`，并将我们的`playerLives`变量发送给它，这是玩家生命值的计数。
- en: Like any function, we can place it anywhere within the class, as long as it's
    not inside another method/function. I typically keep my `Awake()` and `Start()`
    functions near the top of the `GameManager` class. To call the custom method in
    the `Start()` function, do the following.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何函数一样，我们可以在类内的任何位置放置它，只要它不在另一个方法/函数内部。我通常将 `Awake()` 和 `Start()` 方法放在 `GameManager`
    类的顶部附近。要在 `Start()` 方法中调用自定义方法，请执行以下操作。
- en: 'Enter the following code in the `GameManager` script:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameManager` 脚本中输入以下代码：
- en: '[PRE0]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we'll fill in the content for the `SetLivesDisplay` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将填充 `SetLivesDisplay` 方法的具体内容。
- en: I have put my `SetLivesDisplay` near the bottom of the `GameManager` script,
    but like the `Start` and `Awake` functions, you can put them wherever you wish
    in the `GameManager` script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将 `SetLivesDisplay` 方法放置在 `GameManager` 脚本的底部附近，但就像 `Start` 和 `Awake` 方法一样，您可以在
    `GameManager` 脚本中的任何位置放置它们。
- en: 'Enter the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE1]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method is set to `public` because our `ScenesManager` script will need
    to access it to load whatever level the player is on. We have our `SetLivesDisplay`
    method set to `void` as we aren't returning anything while in the method. As I
    mentioned previously, we take in the `playerLives` integer but we will refer to
    it as `players` while in the method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法设置为 `public`，因为我们的 `ScenesManager` 脚本将需要访问它来加载玩家所在的任何关卡。我们将 `SetLivesDisplay`
    方法设置为 `void`，因为我们在这个方法中不返回任何内容。如我之前所述，我们接受 `playerLives` 整数，但在方法中我们将将其称为 `players`。
- en: Let's continue by adding some code inside the `SetLivesDisplay` method. This
    is where we will be checking, adding, and visually removing lives if the player
    dies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，在 `SetLivesDisplay` 方法内部添加一些代码。这里我们将检查、添加，并在玩家死亡时视觉上移除生命值。
- en: 'Enter the following code inside the `SetLivesDisplay` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SetLivesDisplay` 方法内部输入以下代码：
- en: '[PRE2]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, we ran a check to find a game object called `lives`. If
    we find the game object, we store its reference in a game object called `lives`.
    We then ran a check to see `if` our `lives` game object is holding any game objects.
    If `lives` isn't holding any game objects, we are assuming this is the beginning
    of the level and that we need to create some lives. Inside the `if` statement,
    we ran a `for` loop with a limit of `5` counts. Inside this `for` loop, we `instantiate`
    our `life` prefab and let it sit inside the `lives` game object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们运行了一个检查以找到名为 `lives` 的游戏对象。如果我们找到游戏对象，我们将将其引用存储在名为 `lives` 的游戏对象中。然后我们运行了一个检查以查看我们的
    `lives` 游戏对象是否持有任何游戏对象。如果 `lives` 没有持有任何游戏对象，我们假设这是关卡开始，并且我们需要创建一些生命值。在 `if` 语句内部，我们运行了一个限制为
    `5` 次数的 `for` 循环。在这个 `for` 循环内部，我们实例化我们的 `life` 预制件，并让它位于 `lives` 游戏对象内部。
- en: 'Continue writing inside the `SetLivesDisplay` method, which is where we manage
    the count of each `life` prefab, and make it show the actual amount of lives the
    player has:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在 `SetLivesDisplay` 方法内部编写，这是管理每个 `life` 预制件计数的部分，并显示玩家实际拥有的生命值数量：
- en: '[PRE3]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are two main parts to the code we just wrote. The first `for` loop is
    set by the count of how many game objects sit under the `lives` game object. Each
    game object under `lives` gets scaled to `1`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的代码有两个主要部分。第一个 `for` 循环是根据 `lives` 游戏对象下的游戏对象数量设置的。每个在 `lives` 下的游戏对象都会缩放到
    `1`。
- en: The second `for` loop takes the count of game objects under `lives` and subtracts
    it against the player's `int` variable that is brought into the parameters of
    this method. Inside this second `for` loop – depending on how big the player's
    `int` variable is – each `life` prefab is shrunk to 0\. Scaling the `life` prefab
    to 0 doesn't affect the `lives` counter to not fluctuate based on the number of
    lives shown.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `for` 循环从 `lives` 下的游戏对象计数中减去，与传入此方法参数的玩家的 `int` 变量相减。在这个第二个 `for` 循环中——根据玩家
    `int` 变量的大小——每个 `life` 预制件都会缩小到 0。将 `life` 预制件缩放到 0 不会影响生命值计数，使其不会根据显示的生命值数量波动。
- en: Save the script.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: '`GameManager` is now capable of creating a life meter at the bottom of the
    `level1` scene. We now need to add some functionality so that `ScenesManager`
    loads the number of lives when the level is loaded.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager` 现在能够在 `level1` 场景的底部创建生命计。我们现在需要添加一些功能，以便 `ScenesManager` 在加载关卡时加载生命值数量。'
- en: 'To get the `ScenesManager` script to load the player''s lives when a level
    starts or when the player dies, do the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要在关卡开始或玩家死亡时加载玩家的生命值，请执行以下操作：
- en: In the `ScenesManager` script, `Assets/Script`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ScenesManager` 脚本中，`Assets/Script`。
- en: Double-click the `ScenesManager` script to be able to start coding.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `ScenesManager` 脚本以开始编码。
- en: In the `ScenesManager` script, we will add a `Start()` function that will contain
    a known Unity delegate, `sceneLoaded`, which is called from Unity's own `SceneManager`.
    This delegate will subscribe to when our game scene changes. For more information
    about the `sceneLoaded` delegate, go to [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本中，我们将添加一个`Start()`函数，该函数将包含一个已知的Unity委托`sceneLoaded`，它由Unity的`SceneManager`调用。此委托将订阅我们的游戏场景变化时的情况。有关`sceneLoaded`委托的更多信息，请访问[https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html)。
- en: 'Within the `ScenesManager` script, enter the `Start` function, along with the
    name of the function we are hooking into the delegate:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本中，输入`Start`函数，以及我们要挂钩到委托的函数名称：
- en: '[PRE4]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Still in the `ScenesManager` script, we will add the Unity-recognized function,
    which will automatically take `Scene` and `LoadSceneMode` types, even if we aren't
    going to do anything with them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`ScenesManager`脚本中，我们将添加Unity识别的函数，即使我们不会对`Scene`和`LoadSceneMode`类型做任何事情，它也会自动获取这些类型。
- en: Inside the function, we are calling the `GameManager` script's `SetLivesDisplay`,
    along with the number of lives the player has.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们调用`GameManager`脚本的`SetLivesDisplay`，以及玩家拥有的生命值数量。
- en: 'Enter the following code we just discussed inside `ScenesManager`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`中输入我们刚才讨论的以下代码：
- en: '[PRE5]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the script.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Let''s check what we have made:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们做了什么：
- en: Go back into the Unity Editor while still being in the scene we are working
    on (`level1`).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然处于我们正在工作的场景（`level1`）的同时，返回Unity编辑器。
- en: Press **Play** – three lives should be displayed. If the player dies, the life
    count will drop to two.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**Play** – 应该显示三个生命值。如果玩家死亡，生命值计数将降至两个。
- en: 'The following screenshot shows the game being played, alongside the player''s
    lives in the bottom left:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了正在进行的游戏，以及玩家生命值位于左下角：
- en: '![Figure 9.13 – Screenshot of our game currently with its lives counter'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.13 – Screenshot of our game currently with its lives counter]'
- en: '](img/Figure_9.13_B18381.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.13_B18381.jpg]'
- en: Figure 9.13 – Screenshot of our game currently with its lives counter
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.13 – Screenshot of our game currently with its lives counter
- en: In this section, we have hooked up the player's lives so that they can be displayed
    in the bottom-left corner of the HUD. We have applied components such as **Horizontal
    Layout Group** and **Layout Element** to set the player's lives images in uniform
    order and size. We also made the code apply and update the player's lives whenever
    the scene loads up.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经将玩家的生命值连接起来，以便它们可以在HUD的左下角显示。我们已应用了如**Horizontal Layout Group**和**Layout
    Element**等组件，以设置玩家生命图像的均匀顺序和大小。我们还确保代码在场景加载时应用并更新玩家的生命值。
- en: Next, we will focus on the other side of the HUD and display the player's score.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注HUD的另一侧并显示玩家的分数。
- en: Displaying the player's score
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家的分数
- en: In this section, we will be applying the player's score on the right-hand side
    of the HUD, which we are currently filling up with information about the player.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把玩家的分数应用到HUD的右侧，我们目前正在用有关玩家的信息填充HUD。
- en: 'We will continue to work in the `Canvas` game object and add another game object
    called `score`. Here, we will add a `ScenesManager` code to load the score display.
    Let''s get started:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在`Canvas`游戏对象中工作，并添加另一个名为`score`的游戏对象。在这里，我们将添加`ScenesManager`代码以加载分数显示。让我们开始吧：
- en: While still in the `level1` scene, right-click the `Canvas` game object in the
    **Hierarchy** window.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然处于`level1`场景的情况下，在**Hierarchy**窗口中右击`Canvas`游戏对象。
- en: From the drop-down list, select **UI** | **Text**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择**UI** | **Text**。
- en: Right-click the new `Text` game object and select **Rename** from the drop-down
    list.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右击新的`Text`游戏对象，从下拉列表中选择**Rename**。
- en: Rename the game object `score`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名游戏对象`score`。
- en: With the `score` game object renamed and located inside the `Canvas` game object,
    the next thing we need to do is to size and move the `score` game object into
    position.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将`score`游戏对象重命名并放置在`Canvas`游戏对象内部后，接下来我们需要做的是调整`score`游戏对象的大小并将其移动到合适的位置。
- en: 'With the `score` game object still selected, alter its **Rect Transform** properties
    in the **Inspector** window so that they look like the ones shown in the following
    screenshot:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择`score`游戏对象的情况下，在**Inspector**窗口中修改其**Rect Transform**属性，使其看起来像以下截图所示：
- en: '![Figure 9.14 – score Rect Transform property settings'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.14 – score Rect Transform property settings]'
- en: '](img/Figure_9.14_B18381.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B18381.jpg)'
- en: Figure 9.14 – score Rect Transform property settings
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 分数矩形变换属性设置
- en: With the `score` game object in the correct position and scale, we can now customize
    its **Text** component settings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当`score`游戏对象处于正确的位置和缩放时，我们现在可以自定义其**文本**组件设置。
- en: 'With the `score` game object still selected, make the following changes to
    its **Text** component in the **Inspector** window:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当`score`游戏对象仍然被选中时，在**检查器**窗口中对其**文本**组件进行以下更改：
- en: Change the `00000000`. The number of zeros in the **Text** field will help us
    specify the size of the board.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`00000000`。**文本**字段中的零的数量将帮助我们指定板的大小。
- en: As shown in the following screenshot, we have selected the same custom text
    we used for the game's level scene titles. Click the **remote** button to the
    right of the **Font** field and select **ethnocentric rg it** from the drop-down
    list.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们选择了与游戏关卡场景标题相同的自定义文本。点击**字体**字段右侧的**远程**按钮，从下拉列表中选择**ethnocentric
    rg it**。
- en: Set the **Alignment** buttons to **Align Right** and **Middle Center**. This
    will position the text and minimize any space on its right-hand side.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐**按钮设置为**右对齐**和**居中**。这将定位文本并最小化其右侧的空间。
- en: Have `score` text font size will set itself.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`score`文本字体大小将自动设置。'
- en: Change the `0` and `60`. This will set the limits for the **Best Fit** text.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`和`60`更改。这将设置**最佳拟合**文本的界限。
- en: The last property to change is the **Color** property of the text. We will set
    this to the same color as our player's lives.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要更改的属性是文本的**颜色**属性。我们将将其设置为与玩家的生命值相同的颜色。
- en: Click the `153`, `177`, `178`, `255`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`153`、`177`、`178`、`255`。
- en: 'The following screenshot shows what our **Text** component properties have
    been set to:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的**文本**组件属性已被设置为何：
- en: '![Figure 9.15 – score Text Component property settings'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 – 分数文本组件属性设置'
- en: '](img/Figure_9.15_B18381.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.15_B18381.jpg)'
- en: Figure 9.15 – score Text Component property settings
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 分数文本组件属性设置
- en: 'If we check the **Game** window, we should see that the score in the right-hand
    corner is a good size, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查**游戏**窗口，我们应该看到右上角的分数大小合适，如下面的截图所示：
- en: '![Figure 9.16 – Our In-Game HUD now holding the score'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 – 我们的游戏内HUD现在显示分数'
- en: '](img/Figure_9.16_B18381.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.16_B18381.jpg)'
- en: Figure 9.16 – Our In-Game HUD now holding the score
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 我们的游戏内HUD现在显示分数
- en: The final phase for our `score` game object is to update our `ScenesManager`
    script by adding an `if` statement to check whether the `score` game object is
    in the scene.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`score`游戏对象的最终阶段是更新我们的`ScenesManager`脚本，通过添加一个`if`语句来检查`score`游戏对象是否在场景中。
- en: 'To update the `ScenesManager` script so that it supports our new score game
    object, do the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`ScenesManager`脚本以支持我们新的分数游戏对象，请执行以下操作：
- en: In the `Assets` folder.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中。
- en: Double-click the `ScenesManager` script and scroll down to where we entered
    the `OnSceneLoaded` function.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`ScenesManager`脚本并向下滚动到我们输入了`OnSceneLoaded`函数的位置。
- en: 'Inside the `OnSceneLoaded` function, enter the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnSceneLoaded`函数内部，输入以下代码：
- en: '[PRE6]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As briefly mentioned in the newly added piece of code, we are checking whether
    the `score` game object is in the scene. If `score` is present in the scene, then
    we grab its `Text` component and apply the player's score integer to it from the
    `ScoreManager` script. Also make sure you have the `using UnityEngine.UI` at the
    top of the script to access the `Text` component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如新添加的代码简要提到的，我们正在检查`score`游戏对象是否在场景中。如果`score`存在于场景中，那么我们获取其`Text`组件，并从`ScoreManager`脚本中将玩家的分数整数应用到它上。同时确保你在脚本顶部有`using
    UnityEngine.UI`以访问`Text`组件。
- en: Save the script.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Speaking of the `ScoreManager` script, we need to load this script back up
    so that its `ResetMethod` resets the `score` UI at the start/end of each game.
    Follow these steps to do so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`ScoreManager`脚本，我们需要重新加载此脚本，以便其`ResetMethod`可以在每场比赛的开始/结束时重置`score` UI。按照以下步骤操作：
- en: In the `ScoreManager` script located in `Assets/Script` and open the file.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`中找到`ScoreManager`脚本并打开文件。
- en: Inside the script, we need to bring in the `UnityEngine.UI` library so that
    we can make changes to our game's visual score.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本内部，我们需要引入`UnityEngine.UI`库，以便我们可以更改游戏的可视分数。
- en: 'At the very top of the `ScoreManager` script, enter the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreManager`脚本的最顶部输入以下代码：
- en: '[PRE7]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within the `ResetScore` method, add an `if` statement that checks that the
    `score` UI game object is in the scene and updates. The following code shows the
    complete `ResetScore` method in the `ScoreManager` script:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ResetScore`方法中，添加一个`if`语句，检查`score` UI游戏对象是否在场景中并更新。以下代码显示了`ScoreManager`脚本中的完整`ResetScore`方法：
- en: '[PRE8]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also need to apply the `UpdateScore` method to our `SetScore` function.
    Go ahead and apply it as shown in the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将`UpdateScore`方法应用到我们的`SetScore`函数上。按照以下代码进行应用：
- en: '[PRE9]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now need to move our `UpdateScore` method within the `ScoreManager` script.
    To do that, add the following new method to update our score whenever it is set
    or reset:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将`ScoreManager`脚本中的`UpdateScore`方法移动到`UpdateScore`方法内。为此，添加以下新方法以在得分设置或重置时更新我们的得分：
- en: '[PRE10]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the script.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Go back into the Unity Editor and click the `level1`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity编辑器并点击`level1`。
- en: 'Our `score` game object will now update when we destroy the enemies, as shown
    in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们摧毁敌人时，我们的`score`游戏对象将更新，如下面的截图所示：
- en: '![Figure 9.17 – Screen of our game with the score totaling up'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17 – 游戏得分总计的屏幕截图'
- en: '](img/Figure_9.17_B18381.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.17_B18381.jpg)'
- en: Figure 9.17 – Screen of our game with the score totaling up
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 游戏得分总计的屏幕截图
- en: In this section, we took the existing `ScoreManager` code that was originally
    displaying the player's score and made it into a `score` variable to the new HUD
    score in the `level1` scene, which will update when an enemy is destroyed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将原本显示玩家得分的现有`ScoreManager`代码改造成一个`score`变量，用于`level1`场景中的新HUD得分，当敌人被摧毁时，得分将更新。
- en: The final piece we need to create for the HUD is the mini-map, which will give
    us a visual of the enemies in our level.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为HUD创建的最后一件东西是迷你地图，这将给我们一个在我们关卡中敌人的视觉。
- en: Creating a mini-map
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建迷你地图
- en: 'In this section, we are going to fit a mini-map inside the HUD display to show
    a larger scope of the level. This will display the player, along with the enemies
    nearby, in a radar style. The following screenshot shows a radar in the middle
    of the HUD that represents the player, along with the enemies around them and
    other enemies that are due to enter the player''s screen:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在HUD显示中嵌入一个迷你地图，以显示更大范围的关卡。这将以雷达风格显示玩家以及附近的敌人。以下截图显示了HUD中间的雷达，代表玩家及其周围的敌人以及其他即将进入玩家屏幕的敌人：
- en: '![Figure 9.18 – Screenshot of our game displaying a mini-map'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 – 显示迷你地图的游戏截图'
- en: '](img/Figure_9.18_B18381.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.18_B18381.jpg)'
- en: Figure 9.18 – Screenshot of our game displaying a mini-map
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 显示迷你地图的游戏截图
- en: 'We will break down the mini-map into three sections:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迷你地图分为三个部分：
- en: '**Radar Camera**: The second camera in the scene.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**雷达相机**：场景中的第二个相机。'
- en: '**Layers**: This makes the second camera recognize only a particular set of
    game objects.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**：这使得第二个相机只能识别特定的一组游戏对象。'
- en: '**Render Texture**: This displays the final results in an animated image on
    the HUD.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染纹理**：在HUD上以动画图像的形式显示最终结果。'
- en: Let's start by creating an extra layer so that we can expose certain game objects
    to our radar camera.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个额外的层，以便我们可以将某些游戏对象暴露给我们的雷达相机。
- en: Creating and adding layers to our player and enemy game objects
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建并添加层到我们的玩家和敌人游戏对象
- en: In this section, we will add an extra game object to our player and enemy game
    objects so that our second camera will only see the attached sprites. These will
    look like blips on a radar.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向玩家和敌人游戏对象添加一个额外的游戏对象，以便我们的第二个相机只能看到附加的精灵。这些将看起来像雷达上的亮点。
- en: 'To add our radar blips to the game objects, do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要将雷达亮点添加到游戏对象中，请执行以下操作：
- en: 'At the top right of the Unity Editor, click the **Layers** button, followed
    by **Edit Layers...**, as shown in the following screenshot:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的右上角，点击**层**按钮，然后点击**编辑层...**，如下面的截图所示：
- en: '![Figure 9.19 – Edit Layers… will allow us to add another layer to our game'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19 – 编辑层…将允许我们为游戏添加另一个层'
- en: '](img/Figure_9.19_B18381.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.19_B18381.jpg)'
- en: Figure 9.19 – Edit Layers… will allow us to add another layer to our game
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 编辑层…将允许我们为游戏添加另一个层
- en: The **Inspector** window will change and show the **Tags & Layers** properties.
    From here, we can click to expand the **Layers** tab.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查器**窗口将改变并显示**标签和层**属性。从这里，我们可以点击展开**层**选项卡。'
- en: Click on one of the available layers near the top and enter `Radar`, as shown
    in the following screenshot:![Figure 9.20 – Expanding our Layers list and adding
    a new layer
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部附近的一个可用图层，输入`Radar`，如下截图所示：![Figure 9.20 – 扩展我们的图层列表并添加一个新图层
- en: '](img/Figure_9.20_B18381.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 9.20_B18381.jpg]'
- en: Figure 9.20 – Expanding our Layers list and adding a new layer
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.20 – 扩展我们的图层列表并添加一个新图层
- en: 'Now, we can add a radar point to the player and enemies. Let''s make a start
    by bringing the player into the scene and updating its prefab so that it will
    be recognized by the radar camera. To do this, follow these instructions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向玩家和敌人添加雷达点。让我们先从将玩家带入场景并更新其预制开始，使其能被雷达摄像机识别。为此，请按照以下说明操作：
- en: In the `Assets/Prefab/Player` folder.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab/Player`文件夹中。
- en: Drag and drop `player_ship` into the **Hierarchy** window at the bottom, in
    an open space.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`player_ship`拖放到**层次结构**窗口底部的空白区域。
- en: In the `player_ship`, select **Create Empty**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`player_ship`中，选择**创建空对象**。
- en: Right-click the game object and select **Rename** from the dropdown.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击游戏对象，从下拉菜单中选择**重命名**。
- en: Rename the game object to `radarPoint`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为`radarPoint`。
- en: 'With `radarPoint` still selected, click the `Sprite Renderer` until it appears
    in the component drop down. Next,click its layer on top of the **Inspector** window
    and select **Radar** from the drop-down list, as shown in the following screenshot.
    We can also set our **Transform** property to match the ones in the following
    image:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`radarPoint`的情况下，点击`Sprite Renderer`直到它在组件下拉菜单中显示。接下来，点击其位于**检查器**窗口顶部的图层，并从下拉列表中选择**雷达**，如下截图所示。我们还可以将我们的**变换**属性设置为与以下图像中的相同：
- en: '![Figure 9.21 – radarPoint game object with its Radar layer'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.21 – radarPoint游戏对象及其雷达图层'
- en: '](img/Figure_9.21_B18381.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.21_B18381.jpg]'
- en: Figure 9.21 – radarPoint game object with its Radar layer
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.21 – radarPoint游戏对象及其雷达图层
- en: 'With the **Transform** properties set, we can now drop the radar dot sprite
    into the **Sprite** field and change its color:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了**变换**属性后，我们现在可以将雷达点精灵拖入**精灵**字段并更改其颜色：
- en: Click the **remote** button to the right of the **Sprite** field in the **Sprite
    Renderer** component.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Sprite Renderer**组件中**精灵**字段右侧的**远程**按钮。
- en: 'Start typing `knob` in the drop-down list until you can see it and select it,
    as shown in the following screenshot:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中开始输入`knob`，直到你可以看到它并选择它，如下截图所示：
- en: '![Figure 9.22 – Accessing and selecting the default knob sprite'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.22 – 访问和选择默认旋钮精灵'
- en: '](img/Figure_9.22_B18381.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.22_B18381.jpg]'
- en: Figure 9.22 – Accessing and selecting the default knob sprite
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.22 – 访问和选择默认旋钮精灵
- en: We can now change the color of the sprite by clicking the `0`, `245`, `255`,
    `255`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过点击`0`，`245`，`255`，`255`来更改精灵的颜色。
- en: Select `player_ship` in the `player_ship` game object's prefab settings.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`player_ship`游戏对象的预制设置中选择`player_ship`。
- en: Select the `player_ship` game object in the **Hierarchy** window and press *Delete*
    on your keyboard.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`player_ship`游戏对象，并在键盘上按**Delete**键。
- en: We have now set the player ship so that it's ready to be detected by the radar
    camera.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已设置玩家飞船，使其准备好被雷达摄像机检测。
- en: The next thing to do is repeat the same methodology for the enemies, which are
    located in `Assets/Prefab/Enemies`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重复相同的步骤为敌人操作，敌人位于`Assets/Prefab/Enemies`。
- en: 'Without going through the same instructions, the following screenshot shows
    our enemies'' `radarPoint` game object with a bright red color value (`255`, `0`,
    `0`, `0`). If you get stuck, just follow the same steps as for the player ship''s
    `radarPoint`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不经过相同的说明，以下截图显示了我们的敌人`radarPoint`游戏对象具有明亮的红色颜色值（`255`，`0`，`0`，`0`）。如果你遇到困难，只需遵循与玩家飞船的`radarPoint`相同的步骤：
- en: '![Figure 9.23 – radarPoint properties setup'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.23 – radarPoint属性设置'
- en: '](img/Figure_9.23_B18381.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.23_B18381.jpg]'
- en: Figure 9.23 – radarPoint properties setup
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.23 – radarPoint属性设置
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In the **Inspector** window, click on **Overrides | Apply All** once you have
    finished making changes to your prefab.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在你完成对预制更改后，点击**覆盖 | 应用全部**。
- en: Once we have finished making our changes and applied them to the prefab, we
    no longer need the `enemy_wave` game object as we have saved its details in the
    prefab.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成更改并将它们应用到预制中，我们就不再需要`enemy_wave`游戏对象，因为我们已经将其详细信息保存在预制中。
- en: Delete `enemy_wave` from the **Hierarchy** window.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中删除`enemy_wave`。
- en: We have effectively created a tracker (`radarPoint`) and attached it to the
    player and enemies for our level.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有效地创建了一个追踪器（`radarPoint`），并将其附加到我们的关卡中的玩家和敌人上。
- en: The next step is to add a **Render** **Texture**, which will work with a second
    camera in our scene. The feed from the second camera will be fed into a **Render
    Texture**. This **Render Texture** will then be placed at the bottom middle of
    the screen and display our player and enemy location.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一个**渲染****纹理**，它将与场景中的第二个摄像头一起工作。第二个摄像头的信号将被输入到一个**渲染纹理**中。然后，这个**渲染纹理**将被放置在屏幕的底部中间，并显示玩家和敌人的位置。
- en: Adding and customizing our Render Texture
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和自定义我们的渲染纹理
- en: '**Render Texture** is typically used to hold moving images while in **Play
    Mode** (at runtime). We are going to use this **Render Texture** to hold the second
    camera''s feed. This will work like a little TV screen in the center of our HUD.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染纹理**通常用于在**播放模式**（运行时）中保持移动图像。我们将使用这个**渲染纹理**来存储第二个摄像头的信号。这将像我们HUD中央的小电视屏幕一样工作。'
- en: 'To create and customize **Render Texture**, we will do the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和自定义**渲染纹理**，我们将执行以下操作：
- en: In the `Texture` folder, that is, `Assets/Texture`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Texture`文件夹中，即`Assets/Texture`。
- en: 'Right-click in an open space area and from the drop-down list, select **Create**,
    then **Render Texture**, as shown in the following screenshot:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空白区域右键点击，从下拉列表中选择**创建**，然后选择**渲染纹理**，如图所示：
- en: '![Figure 9.24 – Creating a Render Texture'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.24 – Creating a Render Texture'
- en: '](img/Figure_9.24_B18381.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.24_B18381.jpg]'
- en: Figure 9.24 – Creating a Render Texture
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – 创建渲染纹理
- en: Tip
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you don't have an open space to right-click, as *step 2* suggests, you can
    change the size of the icons to gain space.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有空白区域可以右键点击，如*步骤2*建议的，你可以通过调整图标大小来获得空间。
- en: Change your icon size with the slider in the bottom-right corner of the **Project**
    window.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**项目**窗口右下角的滑块调整你的图标大小。
- en: Click the name of the file slowly twice and rename it `radar`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 慢慢点击文件名两次，将其重命名为`雷达`。
- en: With the `radar` **Render Texture** selected, we will need to change its size
    to one that will fit the HUD and, ideally, make it less blurry.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`雷达`**渲染纹理**后，我们需要将其大小调整为适合HUD的大小，并理想情况下使其更清晰。
- en: In the `256`, `256` to `236`, `46`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`256`，`256`到`236`，`46`。
- en: Change **Filter Mode** from **Bilinear** to **Point**.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**滤波模式**从**双线性**更改为**点**。
- en: 'The last part of setting up **Render Texture** is to place it into the HUD.
    Follow these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 设置**渲染纹理**的最后一步是将它放置到HUD中。按照以下步骤操作：
- en: Still in the `level1` scene, right-click the `Canvas` game object in the **Hierarchy**
    window and select **Create Empty**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`level1`场景中，在**层次结构**窗口中右键点击`Canvas`游戏对象，并选择**创建空对象**。
- en: Select the new empty game object in the **Hierarchy** window, right-click it,
    and select **Rename** from the drop-down list.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择新的空游戏对象，右键点击它，并从下拉列表中选择**重命名**。
- en: Rename the game object `radar`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为`雷达`。
- en: The `radar` game object will work as housing for anything related to the game
    object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`雷达`游戏对象将作为任何与游戏对象相关内容的容器。'
- en: 'This game object will now need to be positioned and sized in the HUD. To do
    that, change the `radar` game object''s **Rect Transform** properties in the **Inspector**
    window to the ones shown in the following screenshot:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此游戏对象现在需要在HUD中定位和调整大小。为此，在**检查器**窗口中更改`雷达`游戏对象的**矩形变换**属性，如图所示：
- en: '![Figure 9.25 – radar Rect Transform property settings'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.25 – radar Rect Transform property settings'
- en: '](img/Figure_9.25_B18381.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.25_B18381.jpg]'
- en: Figure 9.25 – radar Rect Transform property settings
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – radar Rect Transform property settings
- en: 'Moving and resizing the `radar` game object will give us a letterbox window
    for **Render Texture** to sit inside, as shown in the following screenshot:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 移动和调整`雷达`游戏对象的大小将为我们提供一个信封窗口，以便**渲染纹理**可以放置其中，如图所示：
- en: '![Figure 9.26 – The placement of our radar game object in the Game window'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.26 – Our radar game object''s placement in the Game window'
- en: '](img/Figure_9.26_B18381.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.26_B18381.jpg]'
- en: Figure 9.26 – The placement of our radar game object in the Game window
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 – 我们雷达游戏对象在游戏窗口中的位置
- en: 'We can now add another game object that will be a child of the `radar` game
    object we''ve just made. This game object will store **Render Texture**:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加另一个游戏对象，它将成为我们刚才创建的`雷达`游戏对象的子对象。此游戏对象将存储**渲染纹理**：
- en: Right-click the `radar` game object in the **Hierarchy** window. From the drop-down
    list, select **UI** and then **Raw Image**.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键点击`雷达`游戏对象。从下拉列表中选择**UI**，然后选择**原始图像**。
- en: Right-click the new game object called `radarImage`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击名为 `radarImage` 的新游戏对象。
- en: 'With the `radarImage` game object still selected, change its **Rect Transform**
    settings to the ones shown in the **Inspector** window in the following screenshot:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择 `radarImage` 游戏对象的情况下，将其 **矩形变换** 设置更改为以下截图所示的 **检查器** 窗口中的设置：
- en: '![Figure 9.27 – radarImage Rect Transform property settings'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.27 – radarImage 矩形变换属性设置'
- en: '](img/Figure_9.27_B18381.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.27 – radarImage 矩形变换属性设置](img/Figure_9.27_B18381.jpg)'
- en: Figure 9.27 – radarImage Rect Transform property settings
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – radarImage 矩形变换属性设置
- en: 'Next, we need to apply **radar Render Texture** to the **Raw Image** **Texture**
    field:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 **雷达渲染纹理** 应用到 **Raw Image** 的 **纹理** 字段：
- en: With `radarImage` still selected in the **Hierarchy** window, click the **remote**
    button next to the **Texture** field in the **Raw Image** component.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择 `radarImage` 游戏对象的情况下，在 **层次** 窗口中，点击 **Raw Image** 组件中 **纹理** 字段旁边的 **远程**
    按钮。
- en: Start typing `radar` in the search bar at the top of the new window until **radar**
    **Render Texture** appears and select it.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口顶部的搜索栏中开始输入 `radar`，直到出现 **radar** **渲染纹理** 并选择它。
- en: That's our **Render Texture** made and set. Now, we can pass this into the second
    camera. But before we do that, we need to add the camera!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的 **渲染纹理** 就制作并设置了。现在，我们可以将其传递到第二个相机。但在我们这样做之前，我们需要添加相机！
- en: Adding and customizing our second camera
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和自定义第二个相机
- en: In this section, we will be adding a second camera so that we can only see the
    `radarPoint` game objects.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加第二个相机，这样我们就只能看到 `radarPoint` 游戏对象。
- en: 'Let''s start by setting up a second camera in our `level1` scene:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `level1` 场景中设置第二个相机开始：
- en: In the **Hierarchy** window, right-click in an open space and from the dropdown,
    select **Camera**.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次** 窗口中，在空白区域右键点击，从下拉菜单中选择 **相机**。
- en: Right-click the newly created `RadarCam`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击新创建的 `RadarCam`。
- en: 'With `RadarCam` still selected, change its **Transform** settings in the **Inspector**
    window to the ones shown in the following screenshot:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择 `RadarCam` 的情况下，在 **检查器** 窗口中将其 **变换** 设置更改为以下截图所示：
- en: '![Figure 9.28 – radarCam Transform property settings'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.28 – radarCam 变换属性设置'
- en: '](img/Figure_9.28_B18381.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.28 – radarImage 矩形变换属性设置](img/Figure_9.28_B18381.jpg)'
- en: Figure 9.28 – radarCam Transform property settings
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28 – radarCam 变换属性设置
- en: 'Still in the `RadarCam` selected, we need to change its **Camera** component
    settings to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `RadarCam` 选择的情况下，我们需要将其 **相机** 组件设置更改为以下：
- en: '**Clear Flags**: **Solid Color**. We don''t require anything in the background
    for the second camera, so something basic such as a solid color would work fine.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除标志**：**纯色**。对于第二个相机，我们不需要背景中的任何东西，因此像纯色这样的基本设置就足够了。'
- en: '`255`, `0`, `0`, `50`. This will give our radar a red tint.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255`，`0`，`0`，`50`。这将给我们的雷达一个红色调。'
- en: '**Culling Mask**: Click the parameter field labeled **Everything**. Do the
    following:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剔除遮罩**：点击标有 **一切** 的参数字段。执行以下操作：'
- en: Select **Nothing** from the drop-down list to remove all layers.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 **无** 以删除所有层。
- en: 'Select the field again and select **Radar** (shown in the following screenshot).
    By doing this, all our camera will see is the game objects that relate to that
    layer:'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次选择该字段，并选择 **雷达**（如图 9.27 所示的截图）。通过这样做，我们的相机将只能看到与该层相关的游戏对象：
- en: '![Figure 9.29 – Select Radar from Culling Mask'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.29 – 从剔除遮罩中选择雷达'
- en: '](img/Figure_9.29_B18381.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.29 – Select Radar from Culling Mask](img/Figure_9.29_B18381.jpg)'
- en: Figure 9.29 – Select Radar from Culling Mask
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29 – 从剔除遮罩中选择雷达
- en: '**Projection**: **Orthographic**. The radar camera is 2D, so there is no need
    to have a perspective view.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**：**正交投影**。雷达相机是 2D 的，因此不需要透视视图。'
- en: '`150`. The size of our camera view will be larger than the main view the player
    is in.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`150`。我们的相机视图大小将大于玩家所在的主视图。'
- en: '`RadarCam` to the radar''s **Render Texture**.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `RadarCam` 添加到雷达的 **渲染纹理**。
- en: Our `RadarCam`) won't need to see the **Radar** layer. Select **Main Camera**
    from the **Hierarchy** window and deselect the **Radar** layer from its **Culling
    Mask**.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `RadarCam` 不需要看到 **雷达** 层。从 **层次** 窗口中选择 **主相机**，并从其 **剔除遮罩** 中取消选择 **雷达**
    层。
- en: Also, with `RadarCam` still selected, click the three dots next to its **Audio
    Listener** component and remove it. We already have one camera that listens for
    audio in our scene.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在仍然选择 `RadarCam` 的情况下，点击其 **音频监听器** 组件旁边的三个点，并删除它。我们已经在场景中有一个监听音频的相机了。
- en: Finally, we need to make it so that `RadarCam` is a child of `RadarCam` into
    **Main Camera** in the **Hierarchy** window.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要确保 `RadarCam` 是 `RadarCam` 在 **层次** 窗口中的子项。
- en: Click **Overrides | Apply All** in the **Inspector** window to update the **Main
    Camera** prefab and save the scene.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中点击**覆盖 | 应用全部**以更新**主摄像机**预设并保存场景。
- en: 'Now, if we click **Play** in the Unity Editor, we will see the radar in the
    HUD with its red tint showing red dots for enemies and a neon blue for the player,
    as shown in the following screenshot:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击Unity编辑器中的**播放**，我们将看到HUD中的雷达，其红色色调显示红色点表示敌人，霓虹蓝色表示玩家，如下面的截图所示：
- en: '![Figure 9.30 – Our mini-map detecting the player and its enemies'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.30 – Our mini-map detecting the player and its enemies'
- en: '](img/Figure_9.30_B18381.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.30_B18381.jpg]'
- en: Figure 9.30 – Our mini-map detecting the player and its enemies
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 – 我们的小地图检测玩家及其敌人
- en: 'This mini-map was created without any code and made use of two new components:
    **Render Texture**, which will hold the second camera''s feed, and a **Raw Image**
    component, which will display the final output.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小地图没有使用任何代码创建，并使用了两个新组件：**渲染纹理**，它将保存第二摄像机的输入，以及一个**原始图像**组件，它将显示最终输出。
- en: 'In this section, we created a functioning HUD that has three main segments:
    the player''s lives, a mini-map, and the player''s score. We used the two fundamental
    UI tools that Unity offers to create a UI display. However, we also introduced
    three new components, as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个功能齐全的HUD，它包含三个主要部分：玩家的生命值、小地图和玩家的得分。我们使用了Unity提供的两个基本UI工具来创建UI显示。然而，我们还引入了三个新组件，如下所示：
- en: '**Horizontal Group Layout**: Spaces the player''s lives equally'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分组布局**：平均分配玩家的生命值'
- en: '**Render Texture**: Transfers the second camera''s feed'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染纹理**：传输第二摄像机的输入'
- en: '**Raw Image**: Displays the feed from the render texture'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始图像**：显示渲染纹理的输入'
- en: 'The following screenshot shows the final HUD:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的HUD：
- en: '![Figure 9.31 – Our HUD is complete'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.31 – Our HUD is complete'
- en: '](img/Figure_9.31_B18381.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.31_B18381.jpg]'
- en: Figure 9.31 – Our HUD is complete
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 – 我们的HUD已完整
- en: Because we have updated our `level1` scene, we need to update `level2` and `level3`.
    The quickest way to do this would be to delete `level2` and `level3` and duplicate
    `level1`, as we did before, which leaves us with updating the level number in
    the `Text` component. We did this in the previous chapter, right at the end, so
    please check that if you need some guidance.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已更新了`level1`场景，我们需要更新`level2`和`level3`。最快的方法是删除`level2`和`level3`并复制`level1`，就像我们之前做的那样，这将使我们只需更新`Text`组件中的级别数字。我们在上一章的结尾做了这件事，所以如果你需要一些指导，请查看。
- en: Now, we will move on and improve the existing `shop` scene by removing the pre-made
    polygons for UI components. This will also introduce us to using UI event triggers
    and making our code smaller and more efficient.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续改进现有的`shop`场景，通过移除UI组件的预制多边形。这将使我们接触到使用UI事件触发器，并使我们的代码更小、更高效。
- en: Making our shop scene support alternative screen ratios
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的商店场景支持替代屏幕比率
- en: In this section, we are going to take our current `shop` scene and make it compatible
    with various screen ratios. Currently, our shop visuals are made out of polygons,
    which look fine, but, for example, our selection grid of buttons at the bottom
    of the screen has the risk of being clipped off at the edges. We can also change
    the way we select our buttons by using Unity's **Button** component, which works
    within the **Canvas**.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对我们的当前`shop`场景进行修改，使其兼容各种屏幕比率。目前，我们的商店视觉效果由多边形组成，看起来不错，但例如，屏幕底部的按钮选择网格有被边缘裁剪的风险。我们还可以通过使用Unity的**按钮**组件来改变选择按钮的方式，该组件在**画布**中工作。
- en: '![Figure 9.32 – There is a wide range of ratios in what a game is displayed
    in'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.32 – There is a wide range of ratios in what a game is displayed
    in'
- en: '](img/Figure_9.32_B18381.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.32_B18381.jpg]'
- en: Figure 9.32 – There is a wide range of ratios in what a game is displayed in
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 – 游戏显示的比率范围很广
- en: Because of these UI changes, this will cut our code down and make it more efficient
    as we will be relying on click events. We will cover these later in this section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些UI更改，这将减少我们的代码并使其更高效，因为我们将会依赖点击事件。我们将在本节后面讨论这些内容。
- en: Let's make a start by replacing the selection grid at the bottom of our `shop`
    scene.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从替换`shop`场景底部的选择网格开始。
- en: Upgrading our shop selection
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级我们的商店选择
- en: In this section, we are going to remove all of the shop buttons and replace
    them with a `button` that has its own raycast system. This raycast system will
    give us an easier way of adding and customizing our buttons when it comes to adding
    or extracting buttons to/from the selection grid.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将移除所有的商店按钮，并用一个具有自己射线投射系统的`button`替换它们。这个射线投射系统将为我们添加和自定义按钮提供更简单的方法，尤其是在添加或从选择网格中提取按钮时。
- en: In the next section, we will support this change by removing our 3D assets so
    that we can replace them with Unity's own 2D buttons.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过移除我们的3D资产来支持这一变化，以便我们可以用Unity自带的2D按钮替换它们。
- en: Preparing our shop scene to go 2D
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备我们的商店场景进入2D模式
- en: 'Let''s start by removing the old selection grid at the bottom and our `BUY
    ?` button as that follows the same suit from our `shop` scene:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先移除底部的旧选择网格和我们的`BUY ?`按钮，因为它们与我们的`shop`场景中的样式相同：
- en: If you haven't loaded the `shop` scene already, locate it in the `Assets/Scene`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有加载`shop`场景，请定位到`Assets/Scene`。
- en: Double-click `shop` scene.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`shop`场景。
- en: 'In the **Hierarchy** window, hold *Ctrl* (*command* on Mac) on the keyboard
    and select all of the game objects shown in the following screenshot:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，按住键盘上的*Ctrl*（在Mac上为*command*）并选择以下截图所示的所示所有游戏对象：
- en: '![Figure 9.33 – Select these game objects from the shop scene Hierarchy'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33 – 从商店场景层次结构中选择这些游戏对象'
- en: '](img/Figure_9.33_B18381.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.33_B18381.jpg)'
- en: Figure 9.33 – Select these game objects from the shop scene Hierarchy
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 – 从商店场景层次结构中选择这些游戏对象
- en: Press *Delete* on the keyboard if you are presented with a window to open the
    prefab. Open it and repeat the process. Once deleted, press the back button in
    the top left corner of the `Canvas`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现打开预制件的窗口，请按键盘上的*Delete*键。打开它并重复此过程。一旦删除，请按`Canvas`左上角的返回按钮。
- en: 'To create a `Canvas` with its own background, do the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有自己背景的`Canvas`，请执行以下操作：
- en: In the lower part of the **Hierarchy** window, right-click and from the drop-down
    list, select **UI**, followed by **Canvas**.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口的下半部分，右键单击，然后从下拉列表中选择**UI**，接着选择**Canvas**。
- en: Right-click the `Canvas` game object in the **Hierarchy** window and from the
    drop-down list, select **UI**, followed by **Image**.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击`Canvas`游戏对象，然后从下拉列表中选择**UI**，接着选择**图像**。
- en: Right-click the new game object called `Image` and select **Rename** from the
    drop-down list.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击名为`Image`的新游戏对象，并从下拉列表中选择**重命名**。
- en: Rename `Image` to `backGround`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image`重命名为`backGround`。
- en: 'With the `backGround` game object still selected, change its **Rect Transform**
    properties to the ones shown in the following screenshot:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择`backGround`游戏对象的情况下，将其**矩形变换**属性更改为以下截图所示：
- en: '![Figure 9.34 – backGround Rect Transform property settings'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.34 – `backGround`矩形变换属性设置'
- en: '](img/Figure_9.34_B18381.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.34_B18381.jpg)'
- en: Figure 9.34 – backGround Rect Transform property settings
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34 – `backGround`矩形变换属性设置
- en: We can now give `backGround` some color. With the `backGround` game object still
    selected, click the `255`, `0`, `0`, `63`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以给`backGround`添加一些颜色。在仍然选择`backGround`游戏对象的情况下，点击`255`，`0`，`0`，`63`。
- en: 'The following screenshot shows the `backGround` game object positioned and
    scaled with a red tint:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有红色色调的`backGround`游戏对象的位置和缩放：
- en: '![Figure 9.35 – backGround in our Game window'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.35 – 游戏窗口中的`backGround`'
- en: '](img/Figure_9.35_B18381.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.35_B18381.jpg)'
- en: Figure 9.35 – backGround in our Game window
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35 – 游戏窗口中的`backGround`
- en: We can now move on to the next section, where we will add three game objects
    that will control the position and scale of the button game objects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一节，我们将添加三个游戏对象，它们将控制按钮游戏对象的位置和缩放。
- en: Adding layout group components
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加布局组组件
- en: 'In this section, we will add game objects that will support the spacing of
    the buttons we add to the grid. The benefit of this is that we can control the
    properties of each section of the buttons, as shown in the following figure:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加支持我们添加到网格中的按钮间隔的游戏对象。这样做的好处是我们可以控制每个按钮部分的属性，如下面的图所示：
- en: '![Figure 9.36 – Our shop scene button layout as planned'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.36 – 按照计划设计的我们的商店场景按钮布局'
- en: '](img/Figure_9.36_B18381.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.36_B18381.jpg)'
- en: Figure 9.36 – Our shop scene button layout as planned
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36 – 按照计划设计的我们的商店场景按钮布局
- en: 'Next, we will make an empty game object and add a **Horizontal Layout Group**
    to it, which will keep our top row buttons in order:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个空的游戏对象，并向其添加一个**水平布局组**，这将保持我们的顶部按钮行顺序：
- en: Right-click the `Canvas` game object and from the drop-down list, select **Create
    Empty**.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Canvas`游戏对象，从下拉列表中选择**Create Empty**。
- en: Rename the new game object `gridTop`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新游戏对象重命名为`gridTop`。
- en: 'With `gridTop` still selected, change its **Rect Transform** settings to the
    ones shown in the following screenshot:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gridTop`仍然被选中的情况下，将其**Rect Transform**属性更改为以下截图所示的设置：
- en: '![Figure 9.37 – gridTop Rect Transform property settings'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.37 – gridTop Rect Transform属性设置'
- en: '](img/Figure_9.37_B18381.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.37_B18381.jpg]'
- en: Figure 9.37 – gridTop Rect Transform property settings
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.37 – gridTop Rect Transform属性设置
- en: 'Now that our `gridTop` is positioned correctly, we can add a **Horizontal Layout
    Group** to it:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于我们的`gridTop`已经正确定位，我们可以向其添加一个**Horizontal Layout Group**：
- en: With the `gridTop` game object still selected, click the `Horizontal Layout
    Group` into the search bar at the top of the drop-down list until you see **Horizontal
    Layout Group**. When this group appears in the list, select it.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gridTop`游戏对象仍然被选中的情况下，点击下拉列表顶部的搜索栏中的`Horizontal Layout Group`，直到你看到**Horizontal
    Layout Group**。当这个组出现在列表中时，选择它。
- en: 'Give **Horizontal Layout Group** the following settings:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给**Horizontal Layout Group**以下设置：
- en: '![Figure 9.38 – Horizontal Layout Group property values'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.38 – Horizontal Layout Group属性值'
- en: '](img/Figure_9.38_B18381.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.38_B18381.jpg]'
- en: Figure 9.38 – Horizontal Layout Group property values
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38 – 水平布局组属性值
- en: '`gridTop` will now automatically order the top row of upgrade buttons.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`gridTop`现在将自动排列升级按钮的顶部行。'
- en: 'We now need to repeat the process for the bottom row, without repeating the
    entire procedure. Follow the same steps for `gridTop` but make the following changes:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要重复这个过程，但不需要重复整个程序。按照`gridTop`的相同步骤进行，但进行以下更改：
- en: Name the next game object in `gridBottom`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下一个游戏对象命名为`gridBottom`。
- en: 'Give the game object the following **Rect Transform** settings:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给游戏对象设置以下**Rect Transform**属性：
- en: '![Figure 9.39 – gridBottom Rect Transform property settings'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.39 – gridBottom Rect Transform属性设置'
- en: '](img/Figure_9.39_B18381.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.39_B18381.jpg]'
- en: Figure 9.39 – gridBottom Rect Transform property settings
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.39 – gridBottom Rect Transform属性设置
- en: Then, like before, we need to add a `gridTop`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像之前一样，我们需要添加一个`gridTop`。
- en: We then repeat this process but this time, for our "AD" and "START" buttons,
    we will be adding a **Vertical Layout Group** component.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后重复此过程，但这次，对于我们的"AD"和"START"按钮，我们将添加一个**Vertical Layout Group**组件。
- en: Like before, create an empty game object and store it in the `Canvas` game object.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，创建一个空的游戏对象并将其存储在`Canvas`游戏对象中。
- en: Name a new game object called `gridOther`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个新的游戏对象为`gridOther`。
- en: 'Give `gridOther`''s **Rect Transform** the following settings:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`gridOther`的**Rect Transform**以下设置：
- en: '![Figure 9.40 – gridOther Rect Transform property settings'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.40 – gridOther Rect Transform属性设置'
- en: '](img/Figure_9.40_B18381.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.40_B18381.jpg]'
- en: Figure 9.40 – gridOther Rect Transform property settings
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.40 – gridOther Rect Transform属性设置
- en: 'As mentioned previously, we will add a `gridOther` game object and give it
    the following settings:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们将添加一个`gridOther`游戏对象并给它以下设置：
- en: '![Figure 9.41 – Vertical Layout Group property values'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.41 – 垂直布局组属性值'
- en: '](img/Figure_9.41_B18381.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.41_B18381.jpg]'
- en: Figure 9.41 – Vertical Layout Group property values
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.41 – 垂直布局组属性值
- en: Our new, reworked selection grid now supports the creation of multiple self-scaling
    buttons. In the next section, we will demonstrate how to create multiple buttons
    that scale themselves to fit in the selection grid.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的、重新设计的选择网格现在支持创建多个自缩放按钮。在下一节中，我们将演示如何创建多个按钮，这些按钮会自动缩放以适应选择网格。
- en: Adding UI buttons
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加UI按钮
- en: In this section, we are going to create a button that won't need any sizing
    changes to be made to it as the layout groups we placed in the previous section
    will take care of this.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个不需要进行任何尺寸更改的按钮，因为我们之前放置的布局组将处理这个问题。
- en: 'To create a `gridTop` game object in the **Hierarchy** window and do the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**Hierarchy**窗口中创建一个`gridTop`游戏对象并执行以下操作：
- en: From the drop-down list, select **UI** and then **Button**.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择**UI**然后**Button**。
- en: Right-click the newly created `Button` game object and name it `00`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击新创建的`Button`游戏对象，并将其命名为`00`。
- en: We will get a button that will be stretched and out of place, but don't worry
    – this is normal. Later, when we add more buttons to this and the other rows,
    the buttons will snap into place and scale in size automatically.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个将被拉伸并放置不正确的按钮，但不用担心 – 这是正常的。稍后，当我们向这一行和其他行添加更多按钮时，按钮将自动对齐并缩放大小。
- en: By default, the button comes with an **Image** component with rounded-off edges.
    For cosmetic purposes, this doesn't suit our scene. We can remove this by doing
    the following:.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，按钮附带一个**图像**组件，边缘为圆角。出于美观目的，这不符合我们的场景。我们可以通过以下步骤移除它：
- en: Click the three-dots icon to the top right of the **Image** component.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**图像**组件右上角的三个点图标。
- en: From the drop-down list, select **Remove Component**.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择**移除组件**。
- en: The button no longer has any color.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮不再有任何颜色。
- en: 'Next, we are going to fill this game object with five game objects. In brief,
    their names and properties are as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在这个游戏对象中填充五个游戏对象。简要来说，它们的名称和属性如下：
- en: '`outline`: Adds a border to the button'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`轮廓`：为按钮添加边框'
- en: '`backPanel`: The color of the button when it''s not selected'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backPanel`：按钮未选中时的颜色'
- en: '`selection`: The color of the button when it is selected'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`：按钮选中时的颜色'
- en: '`powerUpimage`: The picture on the button'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powerUpimage`：按钮上的图片'
- en: '`itemText`: The cost or sold out message'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemText`：成本或售罄信息'
- en: 'The following screenshot shows all of these game objects combined to create
    our new shop button:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了所有这些游戏对象组合在一起创建我们的新商店按钮：
- en: '![Figure 9.42 – A shop button'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.42 – 一个商店按钮'
- en: '](img/Figure_9.42_B18381.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.42_B18381.jpg)'
- en: Figure 9.42 – A shop button
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.42 – 一个商店按钮
- en: Tip
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The other way of changing a button's condition is by using Unity's `Button`
    script, check out [https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html](https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种改变按钮状态的方法是使用Unity的`Button`脚本，请参阅[https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html](https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html)。
- en: Adding the outline game object
  id: totrans-463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加轮廓游戏对象
- en: 'Let''s start by adding an `outline` game object for our new shop button:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的新商店按钮添加一个`轮廓`游戏对象：
- en: Right-click the `00` game object in the **Hierarchy** window and from the dropdown,
    select **UI** | **Image**.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击`00`游戏对象，并从下拉菜单中选择**UI** | **图像**。
- en: Select the `Image` game object, right-click it in the `outline`.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Image`游戏对象，在`outline`中右键单击它。
- en: 'With `outline` still selected in the **Hierarchy** window, update its **Rect
    Transform** and **Image** **Color** fields to the following:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`outline`，并更新其**矩形变换**和**图像****颜色**字段到以下：
- en: '![Figure 9.43 – outline Rect Transform property settings and Image component
    color and alpha values'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.43 – 轮廓矩形变换属性设置和图像组件颜色和透明度值'
- en: '](img/Figure_9.43_B18381.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.43_B18381.jpg)'
- en: Figure 9.43 – outline Rect Transform property settings and Image component color
    and alpha values
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.43 – 轮廓矩形变换属性设置和图像组件颜色和透明度值
- en: The shop button will now have a colored `outline`. Now, let's move on and look
    at the button's `backPanel`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 商店按钮现在将有一个彩色的`轮廓`。现在，让我们继续并看看按钮的`backPanel`。
- en: Adding the backPanel game object
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加backPanel游戏对象
- en: 'Let''s add `backPanel` to the `00` game object:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`backPanel`添加到`00`游戏对象中：
- en: In the `00` game object and from the dropdown, select **UI** | **Image**.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`00`游戏对象中，从下拉菜单中选择**UI** | **图像**。
- en: Right-click the newly created `Image` game object and name it `backPanel`.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的`Image`游戏对象，并将其命名为`backPanel`。
- en: 'With `backPanel` still selected, in the **Inspector** window, change its **Rect
    Transform** so that it has the following values:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`backPanel`的情况下，在**检查器**窗口中更改其**矩形变换**，使其具有以下值：
- en: '![Figure 9.44 – backPanel Rect Transform property settings'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.44 – backPanel 矩形变换属性设置'
- en: '](img/Figure_9.44_B18381.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.44_B18381.jpg)'
- en: Figure 9.44 – backPanel Rect Transform property settings
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.44 – backPanel 矩形变换属性设置
- en: With the `backPanel` game object still selected, we can change the `backPanel`
    game object's settings to `40`, `39`, `36`, `255`. That's the second game object
    that we've applied that gives us our default color.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择`backPanel`游戏对象的情况下，我们可以将`backPanel`游戏对象的设置更改为`40`，`39`，`36`，`255`。这是我们应用的第二个游戏对象，它给出了我们的默认颜色。
- en: We'll add the `selection` game object to the `00` game object next.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个步骤中将`selection`游戏对象添加到`00`游戏对象中。
- en: Adding the selection game object
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加选择游戏对象
- en: 'To create the `selection` button, follow the same steps provided in the previous
    section. However, note that there are three differences:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`选择`按钮，遵循上一节中提供的相同步骤。然而，请注意有三个不同之处：
- en: Name this game object `selection`.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此游戏对象命名为`选择`。
- en: Give the `144`, `0`, `0`, `255`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出`144`，`0`，`0`，`255`。
- en: Create and apply a `Selection`.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并应用一个`Selection`。
- en: Information
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: We covered creating and applying tags back in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 [*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048) 中介绍了创建和应用标签，*添加和操作对象*。
- en: 'The following screenshot shows our `selection` game object''s **Tag** and **Rect
    Transform** property values:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `selection` 游戏对象的 **Tag** 和 **Rect Transform** 属性值：
- en: '![Figure 9.45 – selection Rect Transform property settings'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.45 – 选择 Rect Transform 属性设置'
- en: '](img/Figure_9.45_B18381.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.45_B18381.jpg)'
- en: Figure 9.45 – selection Rect Transform property settings
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.45 – selection Rect Transform 属性设置
- en: That's the third game object that we've applied to our `00` game object. Our
    buttons will light up and stay red until a purchase is made or a different button
    is pressed. We'll add the `powerUpImage` game object to our `00` game object next.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们应用到 `00` 游戏对象上的第三个游戏对象。我们的按钮将在购买或按下不同按钮之前保持红色并亮起。我们将在下一个步骤中将 `powerUpImage`
    游戏对象添加到 `00` 游戏对象中。
- en: Adding the powerUpImage game object
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 powerUpImage 游戏对象
- en: 'To create the `powerUpImage` button, follow the same steps provided in the
    previous section, but make three changes:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `powerUpImage` 按钮，按照上一节中提供的相同步骤操作，但需要进行以下三个更改：
- en: Name this game object `powerUpImage`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此游戏对象命名为 `powerUpImage`。
- en: Drag and drop the `powerup` sprite into the **Source Image** field of the **Image**
    component.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `powerup` 精灵拖放到 **Image** 组件的 **Source Image** 字段中。
- en: Tick the **Preserve Aspect** box.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打勾 **Preserve Aspect** 复选框。
- en: That's our fourth game object that displays each button's icon.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们用于显示每个按钮图标的第四个游戏对象。
- en: We'll add the `itemText` game object to the `00` game object next.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个步骤中将 `itemText` 游戏对象添加到 `00` 游戏对象中。
- en: Adding the itemText game object
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 itemText 游戏对象
- en: 'To add the `itemText` game object to our `00` game object, do the following:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `itemText` 游戏对象添加到我们的 `00` 游戏对象中，请按照以下步骤操作：
- en: In the `00` game object and from the drop-down list, select **UI**, followed
    by **Text**.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `00` 游戏对象中，从下拉列表中选择 **UI**，然后选择 **Text**。
- en: Right-click the newly created `Text` game object and name it `itemText`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的 `Text` 游戏对象，并将其命名为 `itemText`。
- en: 'With `itemText` still selected, in the `Inspector` window, change its **Rect
    Transform** and **Text** components so that they have the following properties:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `itemText` 仍然被选中的情况下，在 `Inspector` 窗口中更改其 **Rect Transform** 和 **Text** 组件，使其具有以下属性：
- en: '![Figure 9.46 – itemText Rect Transform property settings and Text Component
    values'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.46 – itemText Rect Transform 属性设置和 Text 组件值'
- en: '](img/Figure_9.46_B18381.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.46_B18381.jpg)'
- en: Figure 9.46 – itemText Rect Transform property settings and Text Component values
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.46 – itemText Rect Transform 属性设置和 Text 组件值
- en: That's the fifth and final game object we need to add to our weapon upgrade
    button.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们需要添加到武器升级按钮中的第五个也是最后一个游戏对象。
- en: 'In the `00` game object should be in the order shown in the following screenshot.
    If the order isn''t the same, simply click and drag either one into position:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `00` 游戏对象中，应按照以下截图中的顺序排列。如果顺序不同，只需单击并拖动其中一个到正确位置：
- en: '![Figure 9.47 – 00 game object and its children in the Hierarchy window'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.47 – 00 游戏对象及其在 Hierarchy 窗口中的子对象'
- en: '](img/Figure_9.47_B18381.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.47_B18381.jpg)'
- en: Figure 9.47 – 00 game object and its children in the Hierarchy window
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.47 – 00 游戏对象及其在 Hierarchy 窗口中的子对象
- en: In this section, we stripped out the old `shop` scene setup where we were selecting
    items in the shop with a raycast system. We replaced the old selection grid with
    a 2D interface with **Button** components. These buttons were grouped with Unity's
    Horizontal and **Vertical Layout Group** components. The benefit of these two
    groups is that if we add more or fewer buttons to the grid, the buttons will reorganize
    their position and scale automatically.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们移除了旧的 `shop` 场景设置，其中我们使用射线投射系统在商店中选择物品。我们用带有 **Button** 组件的 2D 界面替换了旧的选择网格。这些按钮与
    Unity 的水平 **Vertical Layout Group** 组件分组。这两个组的好处是，如果我们向网格中添加更多或更少的按钮，按钮将自动重新组织其位置和缩放。
- en: We need to make a slight modification to the `ShopPiece` script that was originally
    attached to each game object button.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对原本附加到每个游戏对象按钮上的 `ShopPiece` 脚本进行一些细微的修改。
- en: Once we have applied and modified the script, we will check what the buttons
    look like in the new selection grid.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用并修改了脚本，我们将检查按钮在新选择网格中的外观。
- en: Applying and modifying our shop script
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用和修改我们的商店脚本
- en: Let's briefly recall the purpose of the `ShopPiece` script. Each button in the
    selection grid will be given information from a scriptable object that will customize
    the button's name, description, value, and image. Because the buttons have changed
    from being 3D assets to 2D ones, we need to alter and add some more code to make
    this work.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下`ShopPiece`脚本的目的。选择网格中的每个按钮都将从脚本化对象中获取信息，以自定义按钮的名称、描述、价值和图像。由于按钮已从3D资产变为2D，我们需要修改和添加一些代码以使其工作。
- en: 'To modify `ShopPiece` so that it''s compatible with our new 2D button, do the
    following:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改`ShopPiece`以使其与我们的新2D按钮兼容，请执行以下操作：
- en: In the `Assets/Script` folder.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中。
- en: Double-click the `ShopPiece` script to open the file.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`ShopPiece`脚本以打开文件。
- en: The first line of code will allow our new code support to grab references from
    the `00` game object.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码将允许我们的新代码从`00`游戏对象中获取引用。
- en: 'Enter the following piece of code at the top of the `ShopPiece` script:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShopPiece`脚本的顶部输入以下代码块：
- en: '[PRE11]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second modification to make will be to replace the content of the `Awake`
    function. The original code accessed `SpriteRenderer`, which was used for accessing
    the sprite on each polygon button. The other piece of code we are replacing applied
    changes to the `TextMesh` component, which displays 3D text.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的第二次修改是替换`Awake`函数的内容。原始代码访问`SpriteRenderer`，用于访问每个多边形按钮上的精灵。我们正在替换的另一段代码应用于`TextMesh`组件，该组件用于显示3D文本。
- en: 'To update our `Awake` function, select the code within the `Awake()` function
    and delete it. Our `Awake()` function should look as follows:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新我们的`Awake`函数，选择`Awake()`函数内的代码并将其删除。我们的`Awake()`函数应如下所示：
- en: '[PRE12]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now enter the first `if` statement, which applies our scriptable object
    icon image to our button's image.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进入第一个`if`语句，该语句将我们的可脚本化对象图标图像应用到按钮的图像上。
- en: 'Within the `Awake()` function, add the following `if` statement:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake()`函数中，添加以下`if`语句：
- en: '[PRE13]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `if` statement grabs a reference from the second child in the `00` button
    and checks to see whether it has an **Image** component. If it does (and it should),
    we apply the scriptable object icon to it.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句从`00`按钮的第二个子对象中获取引用，并检查它是否具有**Image**组件。如果它有（应该是有的），我们将脚本化对象图标应用到它上。'
- en: 'The other `if` statement updates the text of the button. Within the `Awake()`
    function, just after the first `if` statement, add the following piece of code:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个`if`语句更新了按钮的文本。在`Awake()`函数中，紧接第一个`if`语句之后，添加以下代码块：
- en: '[PRE14]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `if` statement makes sure the `00` button has `itemText` (it should). When
    the `itemText` game object is found, its **Text** component receives the scriptable
    object price of the weapon.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保`00`按钮有`itemText`（应该是有的）。当找到`itemText`游戏对象时，其**Text**组件将接收武器脚本化对象的价格。'
- en: Save the script.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Back in the Unity Editor, select the `00` game object in the **Hierarchy** and
    click the **Add Component** button.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，选择**层次结构**中的`00`游戏对象，并点击**添加组件**按钮。
- en: Start typing `ShopPiece` in the drop-down list until you see it. When you do,
    select it.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中开始键入`ShopPiece`，直到你看到它。当你看到它时，选择它。
- en: With the `00` game object still selected, in the `ShopPiece` component.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShopPiece`组件中，仍然选择`00`游戏对象。
- en: Select any weapon upgrade scriptable object from the list.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择任何武器升级脚本化对象。
- en: 'The following screenshot shows the `ShopPiece` script with a scriptable object
    applied to it:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了脚本化对象的`ShopPiece`脚本：
- en: '![Figure 9.48 – ShopPiece script, holding in its Shop Selection field the Shot_PowerUp
    Scriptable Object'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.48 – ShopPiece脚本，在其Shop Selection字段中持有Shot_PowerUp可脚本化对象'
- en: '](img/Figure_9.48_B18381.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.48_B18381.jpg](img/Figure_9.48_B18381.jpg)'
- en: Figure 9.48 – ShopPiece script, holding in its Shop Selection field the Shot_PowerUp
    Scriptable Object
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48 – ShopPiece脚本，在其Shop Selection字段中持有Shot_PowerUp可脚本化对象
- en: We are now in a position to check what our button looks like with the four game
    objects we've applied and with its modified `ShopPiece` script.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查我们的按钮在应用了四个游戏对象及其修改后的`ShopPiece`脚本后的样子。
- en: In the next few sections, we are going to duplicate a series of the new shop
    buttons. These shop buttons will automatically fit in the allocated game object
    space we have put them in. Then, we will clear up any of the old UI and replace
    it with our new interface. Finally, we will comment out the old raycast system
    from our code and add our new interface code.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将复制一系列新的商店按钮。这些商店按钮将自动适应我们放置的分配的游戏对象空间。然后，我们将清理任何旧的 UI 并用我们的新界面替换它。最后，我们将从代码中注释掉旧的射线投射系统并添加我们的新界面代码。
- en: Reviewing the button's results
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查按钮的结果
- en: 'In this section, we will be reviewing the new `00` button in the `gridTop`
    game object. The button is too big and spreads across the majority of the **Canvas**,
    as shown in the following screenshot:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将审查 `gridTop` 游戏对象中的新 `00` 按钮。按钮太大，横跨了大多数 **Canvas**，如下面的截图所示：
- en: '![Figure 9.49 – 00 game object currently sitting in the gridTop game object'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.49 – 00 游戏对象目前位于 gridTop 游戏对象中'
- en: '](img/Figure_9.49_B18381.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.49_B18381.jpg)'
- en: Figure 9.49 – 00 game object currently sitting in the gridTop game object
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.49 – 00 游戏对象目前位于 gridTop 游戏对象中
- en: 'But if I select the `00` game object in the **Hierarchy** window and press
    *Ctrl* (*command* on Mac) and *D* to duplicate the game object a few times, the
    button will divide equally, as shown in the following screenshot:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果在 **层次结构** 窗口中选择 `00` 游戏对象并按 *Ctrl* (*Mac上的*command*) 和 *D* 几次复制游戏对象，按钮将平均分割，如下面的截图所示：
- en: '![Figure 9.50 – Three 00 game objects looking less stretched'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.50 – 三个 00 游戏对象看起来不那么拉伸'
- en: '](img/Figure_9.50_B18381.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.50_B18381.jpg)'
- en: Figure 9.50 – Three 00 game objects looking less stretched
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.50 – 三个 00 游戏对象看起来不那么拉伸
- en: 'The button divides well and can be duplicated several times (not in **Play
    Mode**) to fill the top and bottom grids. To fill up and name the grids, do the
    following:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮可以很好地分割，并且可以在（**Play Mode**）之外重复多次以填充顶部和底部网格。要填充并命名网格，请执行以下操作：
- en: In the `00` game object and press *Ctrl* (*command* on a Mac) and *D* three
    times.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `00` 游戏对象中，按 *Ctrl* (*Mac上的*command*) 和 *D* 三次。
- en: Rename the three new duplicate game objects `01`, `02`, and `03` respectively.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别将三个新复制的游戏对象重命名为 `01`、`02` 和 `03`。
- en: Select `01` in the `ShopPiece` component in the **Inspector** window.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，选择 `01`。
- en: Select a different scriptable object from the list to change the weapon upgrade.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择不同的可脚本对象来更改武器升级。
- en: Select game object `02` and select a different weapon in the `ShopPiece` component.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ShopPiece` 组件中，选择游戏对象 `02` 并选择不同的武器。
- en: 'Now, we need to fill up the bottom row with buttons. To do that, follow these
    steps:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要用按钮填充底部行。为此，请按照以下步骤操作：
- en: Click and drag the `03` game object from the `gridBottom` game object.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `gridBottom` 游戏对象中点击并拖动 `03` 游戏对象。
- en: With `03` still selected, press *Ctrl* (*command* on a Mac) and *D* twice.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `03` 的情况下，按 *Ctrl* (*Mac上的*command*) 和 *D* 两次。
- en: Rename our newly created game objects `04` and `05`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们新创建的游戏对象重命名为 `04` 和 `05`。
- en: 'The following screenshot shows the top and bottom rows filled up:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了填充了顶部和底部的行：
- en: '![Figure 9.51 – Six shop buttons'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.51 – 六个商店按钮'
- en: '](img/Figure_9.51_B18381.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.51_B18381.jpg)'
- en: Figure 9.51 – Six shop buttons
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.51 – 六个商店按钮
- en: Because we don't have any more items to sell in our shop, the bottom three buttons
    look odd, so let's replace these with some sold-out signs. This can easily be
    achieved with our scriptable object assets.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们商店中再也没有可售物品，所以底部三个按钮看起来很奇怪，因此让我们用一些售罄标志来替换这些按钮。这可以通过我们的可脚本对象资源轻松实现。
- en: 'To create a sold-out sign for our bottom row in our shop, we need to do the
    following:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 要为商店底部的行创建一个售罄标志，我们需要执行以下操作：
- en: In the `Assets/ScriptableObject`, right-click in an open space, and select **Create**
    | **Create Shop Piece**.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/ScriptableObject` 中，在空白区域右键单击，然后选择 **创建** | **创建商店物品**。
- en: Rename the `Create Shop Piece` file `SoldOut`.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Create Shop Piece` 文件重命名为 `SoldOut`。
- en: 'Select `SoldOut` and give it the following property values:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `SoldOut` 并赋予以下属性值：
- en: '![Figure 9.52 – SoldOut Scriptable Object and its values entered along with
    a soldOut sprite'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.52 – SoldOut 可脚本对象及其输入的值以及售罄精灵'
- en: '](img/Figure_9.52_B18381.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.52_B18381.jpg)'
- en: Figure 9.52 – SoldOut Scriptable Object and its values entered along with a
    soldOut sprite
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.52 – SoldOut 可脚本对象及其输入的值以及售罄精灵
- en: Lastly, apply the `SoldOut` file to game objects `03`, `04`, and `05` in the
    `Shop Piece` component field's **Shop Selection** in the **Inspector** window.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**检查器**窗口的`Shop Piece`组件字段的**Shop Selection**中应用`SoldOut`文件到游戏对象`03`、`04`和`05`。
- en: Now, we need to repeat a similar process for our advert and start buttons.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的广告和开始按钮重复执行类似的过程。
- en: Creating the advert and start buttons
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建广告和开始按钮
- en: 'To recreate the advert button, select either one of the buttons we duplicated
    in the **Hierarchy** window and do the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新创建广告按钮，在**层次结构**窗口中选择我们复制的任一按钮，并执行以下操作：
- en: Press *Ctrl* (*command* on a Mac) and *D* to duplicate another button and drag
    it into the `gridOther` game object in the **Hierarchy** window.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* (*Mac 上的 command*) 和 *D* 复制另一个按钮，并将其拖动到**层次结构**窗口中的`gridOther`游戏对象中。
- en: Rename the duplicate game object `AD`.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的游戏对象重命名为`AD`。
- en: Because the `AD` game object doesn't need `powerUpImage`, we can delete it.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`AD`游戏对象不需要`powerUpImage`，我们可以删除它。
- en: Expand the `AD` game object by clicking the arrow to the left of its name in
    the `itemText` button.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击`itemText`按钮名称左侧的箭头展开`AD`游戏对象。
- en: 'Apply the following settings to the **Text** component in the **Inspector**
    window:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中将以下设置应用于**文本**组件：
- en: '![Figure 9.53 – itemText Rect Transform property settings and Text component
    values'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.53 – itemText 矩形变换属性设置和文本组件值'
- en: '](img/Figure_9.53_B18381.jpg)'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.53](img/Figure_9.53_B18381.jpg)'
- en: Figure 9.53 – itemText Rect Transform property settings and Text component values
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.53 – itemText 矩形变换属性设置和文本组件值
- en: 'Repeat a similar process for the `itemText` and `selection` game object components
    (`selection` hex color: `FFC300FF`), as shown in the following figure:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行类似的过程，为`itemText`和`selection`游戏对象组件（`selection`十六进制颜色：`FFC300FF`）执行以下操作，如图所示：
- en: '![Figure 9.54 – itemText Text component values and selection Image component
    property values'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.54 – itemText 文本组件值和选择图像组件属性值'
- en: '](img/Figure_9.54_B18381.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.54](img/Figure_9.54_B18381.jpg)'
- en: Figure 9.54 – itemText Text component values and selection Image component property
    values
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.54 – itemText 文本组件值和选择图像组件属性值
- en: 'The following screenshot shows the `gridOther` game object and its content,
    including the two buttons:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`gridOther`游戏对象及其内容，包括两个按钮：
- en: '![Figure 9.55 – gridOther game object holding AD and START buttons with their
    children in the Hierarchy window'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.55 – 在层次结构窗口中包含 AD 和 START 按钮及其子对象的 gridOther 游戏对象'
- en: '](img/Figure_9.55_B18381.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.55](img/Figure_9.55_B18381.jpg)'
- en: Figure 9.55 – gridOther game object holding AD and START buttons with their
    children in the Hierarchy window
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.55 – 在层次结构窗口中包含 AD 和 START 按钮及其子对象的 gridOther 游戏对象
- en: Now that our selection grid visuals are completed, we can move on to the description
    panel and partially convert it from 3D into 2D.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了选择网格视觉效果，我们可以继续到描述面板，并将其部分从 3D 转换为 2D。
- en: Adding the BUY? button
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 BUY? 按钮
- en: 'To add the 2D `BUY?` button to the description panel, do the following:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 2D `BUY?` 按钮添加到描述面板，请执行以下操作：
- en: Right-click the `Canvas` game object in the **Hierarchy** panel and select **UI**,
    followed by **Button**, from the drop-down list.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中右键单击`Canvas`游戏对象，然后从下拉列表中选择**UI**，接着选择**按钮**。
- en: Right-click the newly created `Button` game object and select **Rename** from
    the drop-down list.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的`Button`游戏对象，并从下拉列表中选择**重命名**。
- en: Rename the `Button` game object `BUY?`.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Button`游戏对象重命名为`BUY?`。
- en: 'With the `BUY?` button still selected in the **Hierarchy** window, set its
    **Rect Transform** properties to the ones shown in the following screenshot:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仍然选中`BUY?`按钮，将其**矩形变换**属性设置为以下截图所示：
- en: '![Figure 9.56 – BUY? Rect Transform property settings'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.56 – BUY? 矩形变换属性设置'
- en: '](img/Figure_9.56_B18381.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.56](img/Figure_9.56_B18381.jpg)'
- en: Figure 9.56 – BUY? Rect Transform property settings
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.56 – BUY? 矩形变换属性设置
- en: Now that the `BUY?` button is in place and scaled correctly, we can alter the
    aesthetics for the **Image** and **Button** components. In the **Image** component,
    select the **remote** button for the **Source Image** field and select **None**
    from the list to remove the curved edges for the button.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`BUY?`按钮已经就位并且缩放正确，我们可以改变**图像**和**按钮**组件的美观。在**图像**组件中，选择**远程**按钮作为**源图像**字段，并从列表中选择**无**以移除按钮的曲线边缘。
- en: 'Next, we will make it so that the `BUY?` button changes colors when it''s highlighted
    and pressed in the **Button** component. Follow these steps to do so:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使`BUY?`按钮在**按钮**组件中高亮显示和按下时改变颜色。按照以下步骤操作：
- en: In the `255`, `0`, `0`, `255`.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `255`, `0`, `0`, `255`。
- en: Select the `255`, `195`, `0`, `255`.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `255`, `195`, `0`, `255`。
- en: When the cursor moves over the `BUY?` button, it will turn yellow and when pressed,
    it will turn red.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当光标移到 `BUY?` 按钮上时，它将变成黄色，按下时将变成红色。
- en: 'Finally, for the `BUY?` button, we need to alter its **Text** component, as
    follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `BUY?` 按钮，我们需要修改其 **Text** 组件，如下所示：
- en: In the `BUY?` button to expand it.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BUY?` 按钮中展开它。
- en: Then, select the `BUY?` game object's child, called `Text`.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 `BUY?` 游戏对象的子对象，称为 `Text`。
- en: 'Enter the following values for the `Text` game object''s **Text** component
    in the **Inspector** window:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 窗口中，为 `Text` 游戏对象的 **Text** 组件输入以下值：
- en: '![Figure 9.57 – BUY? game object''s Text component property values'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.57 – BUY? 游戏对象的 Text 组件属性值'
- en: '](img/Figure_9.57_B18381.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.57_B18381.jpg)'
- en: Figure 9.57 – BUY? game object's Text component property values
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.57 – BUY? 游戏对象的 Text 组件属性值
- en: 'The following screenshot shows our **BUY ?** button positioned and styled:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的 **BUY ?** 按钮的位置和样式：
- en: '![Figure 9.58 – The BUY? game object should now look like the one in this screenshot'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.58 – 现在，BUY? 游戏对象应该看起来像这个截图中的样子'
- en: '](img/Figure_9.58_B18381.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.58_B18381.jpg)'
- en: Figure 9.58 – The BUY? game object should now look like the one in this screenshot
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.58 – 现在，BUY? 游戏对象应该看起来像这个截图中的样子
- en: In this section, we applied Unity's different state settings for our button
    without adding any extra code. Next, we will add a simple rectangle image to replace
    the polygon quad.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为我们的按钮应用了 Unity 的不同状态设置，而没有添加任何额外的代码。接下来，我们将添加一个简单的矩形图像来替换多边形四边形。
- en: Replacing our textBoxPanel game object
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换我们的 textBoxPanel 游戏对象
- en: 'In the previous section, we changed our `BUY ?` button so that it is 2D and
    part of the `BUY ?` button will now be moved, scaled, and adjusted to the ratio
    of the screen instead of remaining static. Because of this, we have the risk of
    our `BUY ?` button moving outside of the static `textBoxPanel` it sits in, as
    shown in the following screenshot:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将我们的 `BUY ?` 按钮改为 2D，并且 `BUY ?` 按钮的一部分现在将被移动、缩放并调整到屏幕的比率，而不是保持静态。因此，我们面临的风险是
    `BUY ?` 按钮可能会移动到它所在的静态 `textBoxPanel` 之外，如下面的截图所示：
- en: '![Figure 9.59 – Fixing the issue with the textBoxPanel game object alignment
    with the BUY ? button'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.59 – 解决 textBoxPanel 游戏对象与 BUY ? 按钮对齐的问题'
- en: '](img/Figure_9.59_B18381.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.59_B18381.jpg)'
- en: Figure 9.59 – Fixing the issue with the textBoxPanel game object alignment with
    the BUY ? button
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.59 – 解决 textBoxPanel 游戏对象与 BUY ? 按钮对齐的问题
- en: Also, the `PlayerShipBuild` script has a reference to `textBoxPanel`, so we
    can't delete the game object without altering our code. To fix this dilemma, we
    can remove the 3D components of `textBoxPanel`, leaving it as an empty game object
    to house other game objects within it.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`PlayerShipBuild` 脚本有一个对 `textBoxPanel` 的引用，因此我们不能在不更改代码的情况下删除游戏对象。为了解决这个困境，我们可以移除
    `textBoxPanel` 的 3D 组件，使其成为一个空的游戏对象，以容纳其中的其他游戏对象。
- en: 'To remove the components from the `textBoxPanel` game object, do the following:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `textBoxPanel` 游戏对象中移除组件，请执行以下操作：
- en: In the `textBoxPanel` in the search bar until it appears.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中的 `textBoxPanel` 中搜索，直到它出现。
- en: Select `textBoxPanel` and remove the two components in the **Inspector** window
    for **Quad (Mesh Filter)** and **Mesh Renderer** by selecting and clicking the
    three dots and selecting **Remove Component**.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `textBoxPanel` 并在 **Inspector** 窗口中通过选择并点击三个点，选择 **移除组件** 来移除 **Quad (Mesh
    Filter)** 和 **Mesh Renderer** 这两个组件。
- en: To bring back our full game object content in the **Hierarchy** window, click
    the cross at the top of its window, to the right of the search bar.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 **Hierarchy** 窗口中恢复完整游戏对象的内容，请点击其窗口顶部的十字，位于搜索栏的右侧。
- en: 'The following screenshot shows the locations of both three-dot icons:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了两个三点图标的位置：
- en: '![Figure 9.60 – Remote button locations for the Quad and Mesh Renderer components'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.60 – Quad 和 Mesh Renderer 组件的远程按钮位置'
- en: '](img/Figure_9.60_B18381.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.60_B18381.jpg)'
- en: Figure 9.60 – Remote button locations for the Quad and Mesh Renderer components
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.60 – Quad 和 Mesh Renderer 组件的远程按钮位置
- en: 'Now, we can create the 2D panel game object to replace the `textBoxPanel` game
    object''s visuals, as follows:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 2D 面板游戏对象来替换 `textBoxPanel` 游戏对象的视觉效果，如下所示：
- en: In the `Canvas` game object and select **UI**, followed by **Image**, from the
    drop-down list.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Canvas` 游戏对象中，选择 **UI**，然后从下拉列表中选择 **Image**。
- en: Select the newly created game object, right-click it, and select **Rename**
    from the drop-down list.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的游戏对象，右键单击它，并从下拉列表中选择**重命名**。
- en: Rename the game object `panel`.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为 `panel`。
- en: 'Move the `BUY?` game object below the panel game object in the `BUY?` button
    sits on top of `panel` in the **Scene** window. The following screenshot shows
    the order of the two game objects:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BUY?` 游戏对象移至面板游戏对象下方，在 **Scene** 窗口中，`BUY?` 按钮位于 `panel` 顶部。以下截图显示了两个游戏对象的顺序：
- en: '![Figure 9.61 – BUY? game object placement in the Hierarchy window'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.61 – 在 Hierarchy 窗口中放置 BUY? 游戏对象'
- en: '](img/Figure_9.61_B18381.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.61_B18381.jpg)'
- en: Figure 9.61 – BUY? game object placement in the Hierarchy window
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.61 – 在 Hierarchy 窗口中放置 BUY? 游戏对象
- en: 'With the `panel` game object still selected, give its **Rect Transform** the
    following values in the **Inspector** window:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `panel` 游戏对象的情况下，在 **Inspector** 窗口中为其 **Rect Transform** 设置以下值：
- en: '![Figure 9.62 – panel Rect Transform property settings'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.62 – 面板 Rect Transform 属性设置'
- en: '](img/Figure_9.62_B18381.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.62_B18381.jpg)'
- en: Figure 9.62 – panel Rect Transform property settings
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.62 – 面板 Rect Transform 属性设置
- en: 'We can change the color of our `panel` game object by clicking its **Color**
    field within its **Image** component in the **Inspector** window and giving it
    the values highlighted in the following screenshot:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 **Inspector** 窗口中点击 `panel` 游戏对象的 **Image** 组件内的 **颜色** 字段，并给出以下截图中的突出显示值来更改
    `panel` 游戏对象的颜色：
- en: '![Figure 9.63 – Change the panel game object Image component color values to
    those in this screenshot'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.63 – 将面板游戏对象 Image 组件颜色值更改为此截图中的值'
- en: '](img/Figure_9.63_B18381.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.63_B18381.jpg)'
- en: Figure 9.63 – Change the panel game object Image component color values to those
    in this screenshot
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.63 – 将面板游戏对象 Image 组件颜色值更改为此截图中的值
- en: Finally, we can amend our `textBoxPanel` and `bank` balance fonts so that they
    fit in with the shop buttons.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以修改我们的 `textBoxPanel` 和 `bank` 余额字体，使它们与商店按钮相匹配。
- en: 'To amend our bank balance, we need to do the following:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改我们的银行余额，我们需要执行以下操作：
- en: In the `bankText` game object.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bankText` 游戏对象中。
- en: With `bankText` selected, update its **Text Mesh** component in the **Inspector**
    window so that the **Font** field takes our new **ethnocentric rg it** font.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `bankText`，在 **Inspector** 窗口中更新其 **Text Mesh** 组件，使 **字体** 字段采用我们新的 **ethnocentric
    rg it** 字体。
- en: Change the `255`, `0`, `0`, `255`).
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `255`, `0`, `0`, `255` 更改为）。
- en: 'Add a few digits in the **Text** field to check the results, as shown in the
    following screenshot:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文本**字段中添加几个数字以检查结果，如图下截图所示：
- en: '![Figure 9.64 – bank game object font updated'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.64 – bank 游戏对象字体更新'
- en: '](img/Figure_9.64_B18381.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.64_B18381.jpg)'
- en: Figure 9.64 – bank game object font updated
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.64 – bank 游戏对象字体更新
- en: 'To change our `textBoxPanel`, we need to do something similar. Here, we will
    select its two child game objects in the `name` and `desc`, and update their **Text
    Mesh** components to the following:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改我们的 `textBoxPanel`，我们需要做类似的事情。在这里，我们将选择其 `name` 和 `desc` 下的两个子游戏对象，并更新它们的
    **Text Mesh** 组件如下：
- en: Add the `name` and `desc` game object's **Text Mesh** **Font** fields.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `name` 和 `desc` 游戏对象的 **Text Mesh** **字体**字段。
- en: Give them a white **Color**.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它们一个白色 **颜色**。
- en: 'In the `name` game object''s **Text Mesh** **Text** field, add the following:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `name` 游戏对象的 **Text Mesh** **Text** 字段中添加以下内容：
- en: '[PRE15]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Apply the same changes to the `desc` game object but add the following text
    to the **Text** field:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的更改应用到 `desc` 游戏对象，但在 **Text** 字段中添加以下文本：
- en: '[PRE16]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot shows a section of the **Game** window and its updated
    font:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **Game** 窗口及其更新的字体：
- en: '![Figure 9.65 – Our textBoxPanel game object and its content updated'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.65 – 我们的 textBoxPanel 游戏对象及其内容更新'
- en: '](img/Figure_9.65_B18381.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.65_B18381.jpg)'
- en: Figure 9.65 – Our textBoxPanel game object and its content updated
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.65 – 我们的 textBoxPanel 游戏对象及其内容更新
- en: Now, all of our shop's visuals have been amended and will support various screen
    ratios. By doing this, we also introduced Unity's own **Button** component.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们商店的所有视觉元素都已更新，并将支持各种屏幕比例。通过这样做，我们还引入了 Unity 自带的 **Button** 组件。
- en: We have now reached the point where we can open a template script of `PlayerShipBuild`
    from our chapter's project files folder. This script will be a replica of the
    current `PlayerShipBuild` script we have been making but with highlighted code
    we will add to the project to support our `shop` scene's functionality.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了可以打开 `PlayerShipBuild` 模板脚本的程度，该脚本位于我们章节的项目文件文件夹中。这个脚本将是当前我们一直在制作的
    `PlayerShipBuild` 脚本的复制品，但我们将添加突出显示的代码以支持我们的 `shop` 场景的功能。
- en: Upgrading the PlayerShipBuild script
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级 PlayerShipBuild 脚本
- en: In this section, we are going to replace the current `PlayerShipBuild` script
    with the one from this chapter's project files folder. The replacement script
    will contain the same code as your current script but with code to show what we
    will be adding and removing step by step.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将用本章项目文件文件夹中的脚本替换当前的`PlayerShipBuild`脚本。替换脚本将包含与当前脚本相同的代码，但会包含逐步添加和删除的代码。
- en: 'Let''s rename our current `PlayerShipBuild` script to something else before
    we begin working on our new replacement script. To rename the current `PlayerShipBuild`
    script, do the following:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写新的替换脚本之前，让我们将当前的`PlayerShipBuild`脚本重命名为其他名称。要重命名当前的`PlayerShipBuild`脚本，请执行以下操作：
- en: In the `Assets/Script` folder.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Script`文件夹中。
- en: Double-click the `PlayerShipBuild` script.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`PlayerShipBuild`脚本。
- en: With the `PlayerShipBuild` script open, rename the class name near the top of
    the script from `PlayerShipBuild` to `PlayerShipBuild_OLD`.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开`PlayerShipBuild`脚本的情况下，将脚本顶部附近的名字从`PlayerShipBuild`重命名为`PlayerShipBuild_OLD`。
- en: Save the script and return to the `Assets/Script` folder in the **Project**
    window.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到**项目**窗口中的`Assets/Script`文件夹。
- en: Click the `PlayerShipBuild` script slowly twice so that you're provided with
    the option to rename the filename.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 慢慢点击两次`PlayerShipBuild`脚本，以便提供重命名文件名的选项。
- en: Change the filename to `PlayerShipBuild_OLD`.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名更改为`PlayerShipBuild_OLD`。
- en: Now, we need to disconnect the `PlayerShipBuild_OLD` script from the `shop`
    game object.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`PlayerShipBuild_OLD`脚本从`shop`游戏对象中断开连接。
- en: In the `shop` into the search bar until you see the `shop` game object. When
    you do, select it.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中输入`shop`，直到你看到`shop`游戏对象。当你看到时，选择它。
- en: With the `shop` game object selected, click the three dots in the `PlayerShipBuild_OLD`
    component (not **Transform**).
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`shop`游戏对象的情况下，点击`PlayerShipBuild_OLD`组件（不是**变换**）中的三个点。
- en: Select **Remove Component** from the drop-down list.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择**移除组件**。
- en: With that, we have renamed and detached the script from the scene. Now, we can
    bring in the new replica `PlayerShipBuild` script from this chapter's project
    files folder.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已重命名并从场景中断开了脚本。现在，我们可以从本章的项目文件文件夹中引入新的副本`PlayerShipBuild`脚本。
- en: 'To hook up the new replica `PlayerShipBuild` script from our project files
    folder, do the following:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 要将项目文件文件夹中的新副本`PlayerShipBuild`脚本连接起来，请执行以下操作：
- en: In the `Assets/` folder.
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/`文件夹中。
- en: 'Select the `PlayerShipBuild_NEW.txt` script inside the folder and drag it to
    the `Assets/Script` folder. Rename it and its file format from `.txt` to `.cs`.
    This will replace some of our old raycast scripts with the same name, `PlayerShipBuild.cs`,
    as shown in the following screenshot:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件夹中选择`PlayerShipBuild_NEW.txt`脚本并将其拖到`Assets/Script`文件夹中。重命名它及其文件格式从`.txt`到`.cs`。这将用以下截图所示的`PlayerShipBuild.cs`替换一些我们旧的具有相同名称的射线脚本：
- en: '![Figure 9.66 – Update the PlayerShipBuild script from the Chapter 9 folder'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.66 – 从第 9 章文件夹更新 PlayerShipBuild 脚本'
- en: '](img/Figure_9.66_B18381.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.66_B18381.jpg)'
- en: Figure 9.66 – Rename and move PlayerShipBuild_NEW to the project's Assets/Script
    folder
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.66 – 将 PlayerShipBuild_NEW 重命名为项目 Assets/Script 文件夹
- en: 'We can now apply this replica script to the `shop` game object in the scene.
    Let''s get started:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个副本脚本应用到场景中的`shop`游戏对象上。让我们开始吧：
- en: Select the `shop` game object in the **Hierarchy** window, as we did before.
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`shop`游戏对象，就像我们之前做的那样。
- en: Click the `PlayerShipBuild`. When you see the `PlayerShipBuild` script, select
    it from the drop-down list.
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`PlayerShipBuild`。当你看到`PlayerShipBuild`脚本时，从下拉列表中选择它。
- en: With the `shop` game object still selected, we can now configure the attached
    `PlayerShipBuild` script.
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shop`游戏对象仍然被选中的情况下，我们现在可以配置附加的`PlayerShipBuild`脚本。
- en: 'To configure the script, set `3`, click each **remote** button to the right
    of each field, and add the following highlighted, from the **Hierarchy** window:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置脚本，设置`3`，点击每个字段右侧的每个**远程**按钮，并从**层次结构**窗口中添加以下高亮显示的内容：
- en: '![Figure 9.67 – Add the following three game objects to the PlayerShipBuild
    script''s fields'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.67 – 将以下三个游戏对象添加到 PlayerShipBuild 脚本的字段'
- en: '](img/Figure_9.67_B18381.jpg)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.67_B18381.jpg)'
- en: Figure 9.67 – Add the following three game objects to the PlayerShipBuild script's
    fields
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.67 – 将以下三个游戏对象添加到 PlayerShipBuild 脚本的字段
- en: Our new `PlayerShipBuild` script is now in place. This means we can now open
    the script and check through and reveal new sections of the code while explaining
    the fundamental parts of the old code's removal.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 `PlayerShipBuild` 脚本现在已经就位。这意味着我们现在可以打开脚本，检查并揭示代码的新部分，同时解释旧代码移除的基本部分。
- en: 'Each of the following **Removing the old…** subsections will do the following:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以下 **移除旧…** 子部分将执行以下操作：
- en: '**//REMOVE(number)**: Refer to what part of the code we are talking about.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**//REMOVE(number)**：指代我们正在讨论的代码部分。'
- en: '`PlayerShipBuild` script its code has been removed.'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShipBuild` 脚本及其代码已被移除。'
- en: '**Replacement**: What the previous code has been replaced with.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换**：之前代码被替换的内容。'
- en: Removing the old shop scene's code
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除旧商店场景的代码
- en: In this section, we are going to go through the newly installed `PlayerShipBuild`
    script and review parts of the code I have commented out so that it won't be acknowledged
    when it's compiled and executed in Unity.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遍历新安装的 `PlayerShipBuild` 脚本，并审查我已注释掉的部分代码，这样在Unity编译和执行时就不会被认可。
- en: We will be turning off the ability to raycast a 3D object, which we coded in
    [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107), *Creating a Shop Scene for
    Our Game*. Because we have swapped the interactable game objects from 3D to 2D,
    we are no longer required to shoot and identify game objects as Unity will take
    care of this with its own **Button** component.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关闭射线投射3D对象的能力，这是我们在 [*第5章*](B18381_05_Epub.xhtml#_idTextAnchor107) 中编写的，*为我们的游戏创建商店场景*。因为我们已经将可交互的游戏对象从3D转换为2D，所以我们不再需要射击和识别游戏对象，因为Unity将使用其自己的
    **按钮** 组件来处理这一点。
- en: To review the code we have commented out, go to the `PlayerShipBuild` script
    located where we left it (`Assets/Script`).
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 要审查我们已注释的代码，请转到位于我们离开位置的 `PlayerShipBuild` 脚本（`Assets/Script`）。
- en: Information
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '`Commenting`, `Comments`, and `UnComment` are words that refer to when a piece
    of code has two forward slashes in front of it. These will be ignored when our
    code is read by the compiler (when we run our code).'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '`注释`、`注释`和 `取消注释` 是指代码前有两条斜杠的情况。当我们的代码被编译器读取时（当我们运行代码时），这些将被忽略。'
- en: We are going to review each piece of code in separate sections so that it's
    clear when the changes we are going to make in `PlayerShipBuild` will be applied.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分部分审查每段代码，以便清楚地知道我们将在 `PlayerShipBuild` 中应用哪些更改。
- en: Reviewing code – REMOVED 01
  id: totrans-716
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查代码 – REMOVED 01
- en: 'Each main chunk of code begins with `//REMOVED`, followed by a number. Here
    are the reasons why we have removed the particular piece of code for `//REMOVED
    01`:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主要代码块都以 `//REMOVED` 开头，后跟一个数字。以下是为什么我们移除了 `//REMOVED 01` 的特定代码块的原因：
- en: '`//REMOVED 01`: This piece of code creates a raycast and returns a game object
    called `target`.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//REMOVED 01`: 这段代码创建了一个射线投射并返回一个名为 `target` 的游戏对象。'
- en: '**Reason for removal**: We no longer need to rely on getting references for
    each game object we shoot a ray at.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除原因**：我们不再需要为每个我们射出射线的目标游戏对象获取引用。'
- en: '`OnClick` event, which is typically used to load a method when it''s selected.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClick` 事件，通常用于在选中时加载一个方法。'
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    02`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向下滚动 `PlayerShipBuild` 脚本，直到我们到达 `//REMOVED 02`。
- en: Reviewing code – REMOVED 02
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查代码 – REMOVED 02
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    02`:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将审查在 `//REMOVED 02` 中注释掉的内容：
- en: '`//REMOVED 02`: This piece of code will take a reference from a raycast-selected
    game object and turn on that `selection` game object to show that a selection
    has been made.'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//REMOVED 02`: 这段代码将从射线投射选定的游戏对象中获取引用，并打开该 `selection` 游戏对象以显示已进行选择。'
- en: '**Reason for removal**: The game object served no benefit apart from serving
    a cosmetic purpose.'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除原因**：该游戏对象除了起到装饰作用外，没有其他任何好处。'
- en: '`selection` game object.'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection` 游戏对象。'
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    03`.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向下滚动 `PlayerShipBuild` 脚本，直到我们到达 `//REMOVED 03`。
- en: Reviewing code – REMOVED 03
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查代码 – REMOVED 03
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    03`:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将审查在 `//REMOVED 03` 中注释掉的内容：
- en: '`//REMOVED 03`: This part of the code checks for the player pressing the fire
    button; if they do, the code will shoot out a raycast to check whether it made
    contact with a collider.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//REMOVED 03`: 这部分代码检查玩家是否按下了射击按钮；如果是，代码将射出射线投射以检查是否与碰撞器接触。'
- en: '`if` statement.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句。'
- en: '`OnClick` event system holds a reference to what game object is selected.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClick` 事件系统保存对所选游戏对象的引用。'
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    04`.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向下滚动 `PlayerShipBuild` 脚本，直到我们到达 `//REMOVED 04`。
- en: Reviewing code – REMOVED 04
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查代码 – REMOVED 04
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    04`:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾我们在 `//REMOVED 04` 中注释掉的内容：
- en: '`//REMOVED 04`: This script checks what the name of the raycast game object
    is. Once it''s identified through a series of `if` statements, it runs the method
    applicable to it.'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//REMOVED 04`: 此脚本检查射线投射游戏对象的名称。一旦通过一系列 `if` 语句识别，它就会运行适用于它的方法。'
- en: '**Reason for removal**: This section of the code would have checked for specific
    names our raycast would have made contact with. We no longer use the raycast system
    now.'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除原因**：这段代码会检查我们的射线投射与哪些特定名称接触。现在我们不再使用射线投射系统。'
- en: '**Replacement**: Each button has its own event trigger that runs its own method.'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换方案**：每个按钮都有自己的事件触发器，运行它自己的方法。'
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    05`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向下滚动 `PlayerShipBuild` 脚本，直到我们到达 `//REMOVED 05`。
- en: Reviewing code – REMOVED 05
  id: totrans-740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查代码 – REMOVED 05
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    05`:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾我们在 `//REMOVED 05` 中注释掉的内容：
- en: '`//REMOVED 05`: At every frame, it checks whether the player has made a selection
    in the shop.'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//REMOVED 05`: 在每一帧，它会检查玩家是否在商店中做出了选择。'
- en: '`Update` method.'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update` 方法。'
- en: '**Replacement**: The event trigger system.'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换方案**：事件触发系统。'
- en: In the previous sections, we reviewed and amended the way we interacted with
    the old shop scene's raycast system.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们回顾并修改了与旧商店场景的射线投射系统交互的方式。
- en: The next phase is to apply methods that can be called directly via an event
    when a button is pressed in the `shop` scene.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是将可以在按下“商店”场景中的按钮时通过事件直接调用的方法应用到我们的脚本中。
- en: Adding methods to our PlayerShipBuild script
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向我们的 `PlayerShipBuild` 脚本添加方法
- en: In this section, we are going to build two main parts so that we can set up
    our script for 2D UI selection. Thankfully, we have done most of the work for
    this chapter and all that remains is to make parts of the script `public` so that
    our code can be accessed from other sources, that is, our event trigger (`OnClick()`).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建两个主要部分，以便我们可以为 2D UI 选择设置我们的脚本。幸运的是，我们已经为这一章做了大部分工作，剩下的只是将脚本的部分设置为
    `public`，以便我们的代码可以从其他来源访问，即我们的事件触发器（`OnClick()`）。
- en: The second thing we are going to do is make our `AttemptSelection` method receive
    the game object button so that it will replace the previous `target` game object.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第二件事是让我们的 `AttemptSelection` 方法接收游戏对象按钮，以便它将替换之前的 `target` 游戏对象。
- en: To confirm this, the `target` game object was originally used to store ray hits
    from our raycast system. If you would like to know more about raycast systems,
    check out [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107), *Creating a Shop
    Scene for Our Game*, if this sounds hazy.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这一点，`target` 游戏对象最初被用来存储来自我们的射线投射系统的射线击中。如果您想了解更多关于射线投射系统，请查看[*第5章*](B18381_05_Epub.xhtml#_idTextAnchor107)，*为我们的游戏创建商店场景*，如果这听起来有些模糊。
- en: 'Let''s start by making the `PlayerShipBuild` script''s methods accessible to
    other classes:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们让 `PlayerShipBuild` 脚本的方法对其他类可访问：
- en: Information
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'By default, the accessibility levels for our methods/functions and classes
    are set to private unless stated otherwise. For more information about accessibility
    levels, check out the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels).'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的方法/函数和类的可访问级别设置为私有，除非另有说明。有关可访问级别的更多信息，请参阅以下链接：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels)。
- en: 'Open the `PlayerShipBuild` script and add `public` to the following methods:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PlayerShipBuild` 脚本，并将以下方法的 `public` 添加到其中：
- en: '`void WatchAdvert()`'
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void WatchAdvert()`'
- en: '`void BuyItem()`'
  id: totrans-756
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void BuyItem()`'
- en: '`void StartGame()`'
  id: totrans-757
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void StartGame()`'
- en: These methods are now open to other scripts and the Unity Editor via the `AttemptSelection`
    method.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法现在可以通过 `AttemptSelection` 方法对其他脚本和 Unity 编辑器开放。
- en: '`AttemptSelection` will be given the same treatment with regard to being a
    `public` method, but it will now also take a game object in parameters, which
    will be the button our script is attached to.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttemptSelection` 方法将像 `public` 方法一样被处理，但它现在还将接受一个游戏对象作为参数，这将是我们脚本附加到的按钮。'
- en: 'Scroll to the `AttemptSelection` method and add a `public` accessibility level,
    including a game object with the reference name `buttonName`:'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `AttemptSelection` 方法并添加一个 `public` 可访问级别，包括一个具有引用名称 `buttonName` 的游戏对象：
- en: '[PRE17]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside this `AttemptSelection` method, we check `buttonName` instead of what
    we did before by checking `target`. We then follow the same procedure of turning
    off any buttons highlighted, then apply the `buttonName` game object reference
    to another game object called `tmpSelection`, which was originally set in the
    `Select` method.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `AttemptSelection` 方法内部，我们检查 `buttonName` 而不是之前通过检查 `target` 来做，然后我们遵循相同的程序关闭任何突出显示的按钮，然后将
    `buttonName` 游戏对象引用应用到另一个名为 `tmpSelection` 的游戏对象上，该对象最初是在 `Select` 方法中设置的。
- en: 'Update `AttemptSelection` with the following code:'
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `AttemptSelection`：
- en: '[PRE18]'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Continuing with the next line of code inside our method, we set the button''s
    child `selection` game object to active (switch it on). The following screenshot
    shows the child number of the `selection` game object in the **Hierarchy** window:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中继续下一行代码，我们将按钮的子 `selection` 游戏对象设置为活动状态（打开它）。以下截图显示了 **Hierarchy** 窗口中
    `selection` 游戏对象的子编号：
- en: '![Figure 9.68 – Hierarchy order of game object 00''s children'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.68 – 游戏对象 00 的层次结构顺序'
- en: '](img/Figure_9.68_B18381.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.68_B18381.jpg)'
- en: Figure 9.68 – Hierarchy order of game object 00's children
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.68 – 游戏对象 00 的层次结构顺序'
- en: 'Enter the following code:'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE19]'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the `AttemptSelection` method, we now need to change the old `target`
    game object''s name to the new `buttonName` game object. The code in bold in the
    following snippet shows where you need to change the names:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AttemptSelection` 方法内部，我们现在需要将旧的 `target` 游戏对象的名称更改为新的 `buttonName` 游戏对象。以下代码片段中加粗的部分显示了你需要更改名称的地方：
- en: '[PRE20]'
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Save the script and re-enter your Game IDs in the **Inspector** window for the
    shop game object. (**Edit | Project Settings | Services | Ads** )
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并在 **Inspector** 窗口中为商店游戏对象重新输入你的 Game IDs。（**编辑 | 项目设置 | 服务 | 广告**）
- en: Remember that if you get stuck with this part, you can always check the `Complete`
    folder for this chapter, where you'll have access to the completed files.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在这个部分遇到困难，你总是可以检查本章的“完整”文件夹，在那里你可以访问已完成的文件。
- en: So far, we have removed multiple chunks of code and replaced them with a minimal
    amount that now supports the event triggers from the Unity Editor. This will help
    with performance and improve the readability of our code. In the next section,
    we are going to let each of the UI buttons know what methods to run when a selection
    is made.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经删除了多个代码块，并用现在支持从 Unity 编辑器的事件触发器的最小代码量替换了它们。这将有助于提高性能并改善我们代码的可读性。在下一节中，我们将让每个
    UI 按钮知道在做出选择时要运行哪些方法。
- en: Applying trigger events to call methods
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用触发事件以调用方法
- en: In this final section, we are going to make it so that when the player presses
    a button in the shop, they will get access to it immediately, instead of our script
    shooting a ray and checking whether and what collider it has made contact with
    to get access to its method. We will be doing this using Unity's Event system
    to run methods directly.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将使玩家按下商店中的按钮时能够立即访问它，而不是我们的脚本发射射线并检查是否以及与哪个碰撞器接触以获取访问其方法。我们将使用 Unity
    的 Event 系统直接运行方法。
- en: 'To make a button run a method directly, follow these steps:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 要使按钮直接运行一个方法，请按照以下步骤操作：
- en: 'In the Unity Editor, select the first `shop` scene button in the selection
    grid called `00` in the **Hierarchy** window, as shown in the following screenshot:'
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中，选择 **Hierarchy** 窗口中的第一个 `shop` 场景按钮，在选择网格中称为 `00`，如下截图所示：
- en: '![Figure 9.69 – Select the 00 game object in the Hierarchy window'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.69 – 在 Hierarchy 窗口中选择 00 游戏对象'
- en: '](img/Figure_9.69_B18381.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.69_B18381.jpg)'
- en: Figure 9.69 – Select the 00 game object in the Hierarchy window
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.69 – 在 Hierarchy 窗口中选择 00 游戏对象'
- en: 'With `00` selected, scroll down the **Inspector** window until you come across
    the **Button** component. Within the **On Click ()** panel, click the **+** icon,
    as shown in the following screenshot:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `00` 后，在 **Inspector** 窗口中向下滚动，直到你遇到 **Button** 组件。在 **On Click ()** 面板中，点击以下截图所示的
    **+** 图标：
- en: '![Figure 9.70 – In the Button component click the + button to add an On Click
    () event'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.70 – 在按钮组件中点击 + 按钮以添加 On Click () 事件]'
- en: '](img/Figure_9.70_B18381.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.70_B18381.jpg)'
- en: Figure 9.70 – In the Button component click the + button to add an On Click
    () event
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.70 – 在按钮组件中点击 + 按钮以添加 On Click () 事件
- en: The `shop` game object to the field that currently says **None (Object)**.
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`shop`游戏对象应用到当前显示为**None (Object**)的字段。
- en: 'Click and drag the `shop` game object from the **Hierarchy** window into the
    **None (Object)** field, as shown in the following screenshot:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`shop`游戏对象从**层次结构**窗口拖动到**None (Object**)字段，如图下截图所示：
- en: '![Figure 9.71 – Drag the shop game object from the Hierarchy into the 00 game
    object Button''s On Click () field'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.71 – 将 shop 游戏对象从层次结构拖动到 00 游戏对象按钮的 On Click () 字段]'
- en: '](img/Figure_9.71_B18381.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.71 – 将 shop 游戏对象从层次结构拖动到 00 游戏对象按钮的 On Click () 字段]'
- en: Figure 9.71 – Drag the shop game object from the Hierarchy into the 00 game
    object Button's On Click () field
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.71 – 将 shop 游戏对象从层次结构拖动到 00 游戏对象按钮的 On Click () 字段
- en: The `00` game object. Now, we need to direct what function from `00` it should
    load.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`00`游戏对象。现在，我们需要指定从`00`加载哪个函数。'
- en: We will call the `AttemptSelection` method by making a request when we tap/click
    one of the `shop` scene's buttons.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们轻触/点击`shop`场景中的任一按钮时，我们将通过发出请求来调用`AttemptSelection`方法。
- en: 'To make our `00` button load the `AttemptSelection` method, do the following:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`00`按钮加载`AttemptSelection`方法，请执行以下操作：
- en: 'Click the `PlayerShipBuild` script and the `AttemptSelection(GameObject)` public
    method, as shown in the following screenshot:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`PlayerShipBuild`脚本和`AttemptSelection(GameObject)`公共方法，如图下截图所示：
- en: '![Figure 9.72 – With the shop game object in the field, select the PlayerShipBuild
    script and then the AttemptSelection function'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.72 – 在字段中有 shop 游戏对象时，选择 PlayerShipBuild 脚本然后选择 AttemptSelection 函数]'
- en: '](img/Figure_9.72_B18381.jpg)'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.72_B18381.jpg)'
- en: Figure 9.72 – With the shop game object in the field, select the PlayerShipBuild
    script and then the AttemptSelection function
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.72 – 在字段中有 shop 游戏对象时，选择 PlayerShipBuild 脚本然后选择 AttemptSelection 函数
- en: The last field to add within the `AttemptSelection`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AttemptSelection`中添加的最后一个字段。
- en: Click the remote button on the far right and type the game object we have selected,
    that is, `00`. When you see it in the list, click it.
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击最右侧的遥控按钮，并输入我们已选择的游戏对象，即`00`。当你在列表中看到它时，点击它。
- en: So, when the player presses the `00` button, our `PlayerShipBuild` script from
    the `shop` game object. Then, it will run the `AttemptSelection` method, taking
    the `00` game object as a reference in parameters.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当玩家按下`00`按钮时，我们的`PlayerShipBuild`脚本将从`shop`游戏对象中运行。然后，它将运行`AttemptSelection`方法，并将`00`游戏对象作为参数的引用。
- en: 'Set up the `01` and `02`. Once completed, each **On Click()** panel will look
    as follows for all three game objects:'
  id: totrans-802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`01`和`02`。完成后，所有三个游戏对象的**On Click()**面板将如下所示：
- en: '![Figure 9.73 – Each game object (00, 01, 02) and their Button component On
    Click () event property settings'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.73 – 每个游戏对象（00、01、02）及其按钮组件的 On Click () 事件属性设置]'
- en: '](img/Figure_9.73_B18381.jpg)'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.73_B18381.jpg)'
- en: Figure 9.73 – Each game object (00, 01, 02) and their Button component On Click
    () event property settings
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.73 – 每个游戏对象（00、01、02）及其按钮组件的 On Click () 事件属性设置
- en: Things are slightly different for our `START` and `AD` game object buttons (sat
    in the **Hierarchy** window).
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`START`和`AD`游戏对象按钮（位于**层次结构**窗口中），情况略有不同。
- en: 'To make our `AD` and `START` game object buttons work in the game, do the following:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`AD`和`START`游戏对象按钮在游戏中工作，请执行以下操作：
- en: Apply the `shop` game object to the `AD` game object's `OnClick` event in the
    **Inspector** window, as we did with the last few game object buttons.
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，将`shop`游戏对象应用到`AD`游戏对象的`OnClick`事件，就像我们对最后几个游戏对象按钮所做的那样。
- en: Do the same for the `START` game object button.
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`START`游戏对象按钮执行相同的操作。
- en: 'Update each of the `START` and `AD` game object''s `OnClick` events, as follows:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`START`和`AD`游戏对象的`OnClick`事件：
- en: '`PlayerShipBuild`, followed by the `WatchAdvert` method.'
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShipBuild`，然后是`WatchAdvert`方法。'
- en: '`PlayerShipBuild`, followed by the `StartGame` method. Remember, if you can''t
    see it in the list, make sure it is made `public` in the `PlayerShipBuild` script.
    You know how to do this now. If not, check the `Complete` folder.'
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShipBuild`，然后是`StartGame`方法。记住，如果你在列表中看不到它，请确保在`PlayerShipBuild`脚本中将其设置为`public`。你现在知道如何做了。如果不是，请检查`Complete`文件夹。'
- en: '![Figure 9.74 – AD and START game object Button On Click () event property
    values'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.74 – AD 和 START 游戏对象按钮的 On Click () 事件属性值]'
- en: '](img/Figure_9.74_B18381.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.74_B18381.jpg)'
- en: Figure 9.74 – AD and START game object Button On Click () event property values
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.74 – AD和START游戏对象按钮的On Click()事件属性值
- en: 'The very last button to change is the `BUY?` game object button in the **Hierarchy**
    window:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要更改的按钮是**层次结构**窗口中的`BUY?`游戏对象按钮：
- en: Apply the usual `shop` game object to its **On Click()** panel.
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通常的`shop`游戏对象应用到其**On Click()**面板上。
- en: Set the script to `PlayerShipBuild`, followed by `BuyItem`.
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本设置为`PlayerShipBuild`，然后是`BuyItem`。
- en: Note that we don't apply event listeners to our bottom row of buttons (Sold
    Out) as there is no reason to press these buttons.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不会将事件监听器应用到我们的底部按钮行（已售罄），因为没有理由按下这些按钮。
- en: Our shop scene is now ready to test. Save the scene and press **Play** in the
    Unity Editor to try out our new shop buttons. It would also be worth testing different
    landscape views in the **Game** window to see the UI buttons pop into shape when
    a landscape ratio is selected.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试商店场景了。保存场景，并在Unity编辑器中按下**播放**来尝试我们的新商店按钮。还值得在**游戏**窗口中测试不同的横向视图，以查看在选择了横向比率时UI按钮如何弹出形状。
- en: 'The following screenshot shows the steps you have to follow to change the ratio.
    Do this by clicking the **Game** tab in the Unity Editor, followed by making a
    selection from two fairly common ratios:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了您必须遵循的更改比率的步骤。通过在Unity编辑器中点击**游戏**选项卡，然后从两个相当常见的比率中进行选择来完成此操作：
- en: '![Figure 9.75 – This screenshot shows two common ratios marked'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.75 – This screenshot shows two common ratios marked'
- en: '](img/Figure_9.75_B18381.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.75_B18381.jpg](img/Figure_9.75_B18381.jpg)'
- en: Figure 9.75 – This screenshot shows two common ratios marked
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.75 – 此截图显示了两个常见的比率标记
- en: In this section, we reevaluated our code and took out the old raycast system,
    which involved selecting 3D game objects to run methods. We replaced this with
    Unity's Event System, complete with **Button** components that were dynamically
    organized with the **Horizontal and Vertical Layout Group** components.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们重新评估了我们的代码，并移除了旧的射线投射系统，该系统涉及选择3D游戏对象来运行方法。我们用Unity的事件系统替换了它，包括动态组织了**水平和垂直布局组**组件的**按钮**组件。
- en: Now, the UI is more robust since it supports different screen ratios. This will
    make our game more compatible with a variety of mobile and tablet screens that
    are old and current, as well as portable devices that haven't been released yet.
    This helps future-proof our application without any embarrassing ratio issues
    occurring.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于它支持不同的屏幕比率，UI更加健壮。这将使我们的游戏与各种旧的和当前的移动和平板电脑屏幕以及尚未发布的便携式设备更加兼容。这有助于使我们的应用程序面向未来，避免出现任何令人尴尬的比率问题。
- en: Summary
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked into two different parts of our game: the in-game
    HUD and rebuilding our shop scene. Both of these used Unity''s UI components but
    in different ways.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了游戏中的两个不同部分：游戏内HUD和重建我们的商店场景。这两个部分都使用了Unity的UI组件，但方式不同。
- en: In the in-game HUD section, we read up about what a HUD is and how we can incorporate
    one into our game. By doing this, we learned how to use **Horizontal Layout Group**
    to order images correctly, **Render Texture** to take a feed from a second camera,
    and **Raw Image** to display a feed from **Render Texture**.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏内HUD部分，我们研究了什么是HUD以及如何将其整合到我们的游戏中。通过这样做，我们学习了如何使用**水平布局组**正确排列图像，使用**渲染纹理**从第二个摄像头获取数据，以及使用**原始图像**显示从**渲染纹理**获取的数据。
- en: Most importantly, as required by the Unity Programmer Exam, you need to understand
    what a HUD is and how to build elements into it, such as a mini-map.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，根据Unity程序员考试的要求，你需要了解什么是HUD以及如何将其中的元素构建进去，例如小地图。
- en: In the second part of this chapter, we reviewed our current shop scene's interface
    and code. We took it apart and rebuilt its interface as a Unity Event system that
    ran methods directly instead of casting a ray to call a method. We also made the
    interface support multiple ratios.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们回顾了当前商店场景的界面和代码。我们将其拆解并重新构建了其界面，作为一个Unity事件系统，它直接运行方法而不是投射射线来调用方法。我们还使界面支持多个比率。
- en: With the skills covered in this chapter, you should feel more confident in reviewing
    and understanding code that could be made more efficient.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章涵盖的技能，你应该在审查和理解可以更高效地编写的代码时更有信心。
- en: In the next chapter, we will continue working on our in-game level so that we
    can pause the game, add and change the volume of our music and sound effects manually,
    and more.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的游戏内关卡制作，以便我们可以暂停游戏，手动添加和更改音乐和音效的音量，等等。
