- en: Layouts and Panels
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和面板
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Building a UI layout using a Grid
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Grid 构建UI布局
- en: Placing elements in uniform cells
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在均匀的单元格中放置元素
- en: Automatically repositioning controls using a `WrapPanel`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WrapPanel` 自动重新定位控件
- en: Placing controls in a Stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆叠中放置控件
- en: Positioning controls inside a Canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Canvas 内部定位控件
- en: Wrapping UI elements using a Border
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Border 包装UI元素
- en: Creating a scrollable panel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可滚动的面板
- en: Docking controls using a DockPanel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DockPanel 锚定控件
- en: Rescaling UI elements using a `ViewBox`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewBox` 缩放UI元素
- en: Creating a tabbed layout
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标签布局
- en: Dynamically adding/removing elements in a panel
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面板中动态添加/删除元素
- en: Implementing the drag and drop feature
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现拖放功能
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: WPF provides a proper layout and positioning to provide interactive, user-friendly
    applications with a suitable container element that helps you to position the
    child UI elements. The parent container is usually the contents of a window. You
    can place child level containers and elements with proper margins, paddings, and
    alignments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 提供了适当的布局和定位，以提供具有适当容器元素的交互式、用户友好的应用程序，该容器元素可以帮助您定位子 UI 元素。父容器通常是窗口的内容。您可以使用适当的边距、填充和对齐方式放置子级容器和元素。
- en: In WPF, `Panel` is the base class that provides layout support. There are plenty
    of derived panels in WPF that help you to create simple to complex layouts and
    all of them are defined in the `System.Windows.Controls` namespace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中，`Panel` 是提供布局支持的基类。WPF 中有许多派生面板，可以帮助您创建简单到复杂的布局，并且所有这些都在 `System.Windows.Controls`
    命名空间中定义。
- en: 'All `Panel` elements support sizing and positioning defined by the `FrameworkElement`.
    You can set the `Height`, `Width`, `Margin`, `Padding`, `HorizontalAlignment`,
    and `VerticalAlignment` properties to design your UI. The following diagram describes
    these important properties, which you will use everywhere:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Panel` 元素都支持由 `FrameworkElement` 定义的尺寸和定位。您可以通过设置 `Height`、`Width`、`Margin`、`Padding`、`HorizontalAlignment`
    和 `VerticalAlignment` 属性来设计您的 UI。以下图表描述了您将在每个地方使用的重要属性：
- en: '![](img/f8802f6b-9d70-42ba-b124-6dd86ceb6af1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8802f6b-9d70-42ba-b124-6dd86ceb6af1.png)'
- en: A panel also exposes other properties such as `Background`, `Children`, `ZIndex`,
    and more. Since a window can contain only one child, a panel is often used to
    divide the space to hold another control or a panel. Picking the right panel is
    important to create the layout. In this chapter, we will learn various recipes
    to design your application layout using various panels.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面板还公开了其他属性，例如 `Background`、`Children`、`ZIndex` 等。由于窗口只能包含一个子元素，因此面板通常用于划分空间以容纳另一个控件或面板。选择正确的面板对于创建布局非常重要。在本章中，我们将学习各种配方，使用各种面板来设计应用程序布局。
- en: Building a UI layout using a Grid
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Grid 构建UI布局
- en: A `Grid` panel enables you to arrange child elements in tabular format, represented
    by cells in rows and columns. This is the default panel that you will see when
    you create a new WPF project and navigate to the `MainWindow.xaml` file. Visual
    Studio automatically adds this as the first container inside every window.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid` 面板使您能够以表格格式排列子元素，这些元素由行和列中的单元格表示。这是您在创建新的 WPF 项目并导航到 `MainWindow.xaml`
    文件时将看到的默认面板。Visual Studio 会自动将其添加到每个窗口的第一个容器中。'
- en: It is often useful when you want to represent data in a tabular or matrix form.
    It is also useful when creating a form layout.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想以表格或矩阵形式表示数据时，这通常很有用。在创建表单布局时也很有用。
- en: In this recipe, we will discuss the `Grid` panel in detail, so that you can
    properly use it while designing your application layout.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将详细讨论 `Grid` 面板，以便你在设计应用程序布局时能够正确使用它。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with `Grid` as a layout panel, by creating a new project. Open Visual
    Studio and create a new project named `CH03.GridDemo`, by selecting the WPF application
    template.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `Grid` 作为布局面板开始，通过创建一个新的项目。打开 Visual Studio 并创建一个名为 `CH03.GridDemo` 的新项目，选择
    WPF 应用程序模板。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create a sample `Grid` layout to host a few
    rectangles in each cell:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建一个示例 `Grid` 布局，用于在每个单元格中托管几个矩形：
- en: Inside Solution Explorer, open your `MainWindow.xaml` page.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，打开你的 `MainWindow.xaml` 页面。
- en: 'Create a few rows and columns inside the default `Grid` panel, as shown in
    the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的 `Grid` 面板内创建几行和列，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add six rectangles inside the `Grid`, and place them properly by using the
    `Grid.Row` and `Grid.Column` attached properties. You can refer to the following
    sample code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`内添加六个矩形，并使用`Grid.Row`和`Grid.Column`附加属性正确放置它们。您可以参考以下示例代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now run the application and you will see the following UI on the screen:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您将在屏幕上看到以下UI：
- en: '![](img/a3dd41a5-1f08-41b6-8c66-9b6afe6ebf4e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3dd41a5-1f08-41b6-8c66-9b6afe6ebf4e.png)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Grid` works in cells, by creating the rows and columns. `<Grid.RowDefinitions>`
    and `<Grid.ColumnDefinitions>` define the structure of the `Grid`. It contains
    a collection of rows and columns, respectively. Here we have created two rows
    and three columns (`2x3` matrix) using `RowDefinition` and `ColumnDefinition`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`通过创建行和列在单元格中工作。`<Grid.RowDefinitions>`和`<Grid.ColumnDefinitions>`定义了`Grid`的结构。它包含行和列的集合。在这里，我们使用`RowDefinition`和`ColumnDefinition`创建了两个行和三个列（`2x3`矩阵）。'
- en: When we placed the rectangles inside the `Grid`, we positioned them in cells
    by specifying the row and column number by using the attached properties, `Grid.Row`
    and `Grid.Column`. As the index position starts at `0` (zero), the first rectangle
    placed in the first cell has row index = `0` and column index = `0`. Similarly,
    the sixth/last rectangle has the position `Row=1` and `Column=2`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将矩形放置在`Grid`内时，我们通过指定行号和列号来定位它们，使用附加属性`Grid.Row`和`Grid.Column`。由于索引位置从`0`（零）开始，第一个放置在第一个单元格中的矩形具有行索引
    = `0` 和列索引 = `0`。同样，第六个/最后一个矩形的定位为`Row=1`和`Column=2`。
- en: You can set the `Height` of a `RowDefinition` and the `Width` of a `ColumnDefinition`
    by specifying an absolute value, a percentage value (star sizing), or an automatic
    sizing. In the preceding example, we used star sizing to define the row and column
    dimensions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定绝对值、百分比值（星号大小）或自动大小来设置`RowDefinition`的`Height`和`ColumnDefinition`的`Width`。在上面的例子中，我们使用了星号大小来定义行和列的维度。
- en: An absolute value takes an integer to define fixed height/width. Star sizing
    is a relative based factor, that works like percentage value. When you mark the
    height/width as `*`, it takes as much space as possible after filling all other
    fixed and auto sized rows/columns. When you specify `Auto`, it takes as much space
    as required by the contained control.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对值使用整数来定义固定的高度/宽度。星号大小是一个基于相对的因子，类似于百分比值。当您将高度/宽度标记为`*`时，它将在填充所有其他固定和自动大小的行/列之后尽可能多地占用空间。当您指定`Auto`时，它将占用包含的控件所需的空间。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's more to know about the star sized value. When there are two rows or
    two columns having height/width defined as `*`, they will occupy the available
    space by dividing it proportionally. Thus, in the preceding example, each of the
    two rows occupied 50% of the available space. Similarly, the three columns equally
    occupied a total of 100% of the available space.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于星号大小值还有更多要了解的。当有两行或两列的高度/宽度定义为`*`时，它们将通过按比例分配来占用可用空间。因此，在上面的例子中，两个行中的每一个都占用了50%的可用空间。同样，三个列平均占用了总共100%的可用空间。
- en: You can also define them using `n*`. For example, if a `Grid` contains two rows,
    and among them, one of the rows has a height defined as `2*` and the other as
    `8*`, they will occupy 20% and 80% of the available space. Let's see this with
    a simple example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`n*`来定义它们。例如，如果一个`Grid`包含两行，其中一行的高度定义为`2*`，另一行定义为`8*`，它们将分别占用20%和80%的可用空间。让我们用一个简单的例子来看看。
- en: 'Create a `Grid` inside a window and set its `ShowGridLines` property to `True`,
    so that the grid lines are visible on screen. By default, it is set to `False`.
    Now divide the entire `Grid` into five columns. Consider the following XAML code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口内创建一个`Grid`，并将其`ShowGridLines`属性设置为`True`，以便在屏幕上显示网格线。默认情况下，它设置为`False`。现在将整个`Grid`分为五个列。考虑以下XAML代码：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The width of the second column is set to `Auto`, which means it will take as
    much space as the width of the containing element. When the said column does not
    contain any element inside it, this will have `0` (zero) width. You can specify
    `MinWidth` to provide a minimum value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列的宽度设置为`Auto`，这意味着它将占用与包含元素宽度相同的空间。当所述列内部不包含任何元素时，这将具有`0`（零）宽度。您可以指定`MinWidth`来提供最小值。
- en: The fifth column has a fixed width of `40`. Both the second column and fourth
    column width will be calculated first, as they contain auto width and fixed width,
    respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第五列具有固定的宽度为`40`。第二列和第四列的宽度将首先计算，因为它们分别包含自动宽度和固定宽度。
- en: The other three columns, in the preceding example, will be calculated now based
    on the available space and will be calculated in the ratio of `2:1:3`. The third
    column in the example will take one-sixth of the space. The first and fourth columns
    will take `2x` and `3x` width, based on the width of the third column.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，其他三个列现在将基于可用空间进行计算，并按`2:1:3`的比例计算。示例中的第三列将占据六分之一的空间。第一列和第四列将根据第三列的宽度占据`2x`和`3x`的宽度。
- en: 'Once you run this UI, you will see the following output. Now resize the window
    to see how the resizing happens dynamically based on the given inputs:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此UI，你将看到以下输出。现在调整窗口大小以查看如何根据给定的输入动态调整大小：
- en: '![](img/0acaa53b-2f8d-4a0b-ba57-999fe4ad9ddd.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0acaa53b-2f8d-4a0b-ba57-999fe4ad9ddd.png)'
- en: Creating a resizable Grid
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建可调整大小的网格
- en: 'It is possible to create a resizable `Grid` in WPF. You can use the `<GridSplitter/>`
    tag to create a `splitter` control, which can be used by the user to resize a
    specific column. Let''s consider the following XAML code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中创建可调整大小的`Grid`是可能的。你可以使用`<GridSplitter/>`标签创建一个`splitter`控件，用户可以使用它来调整特定列的大小。让我们考虑以下XAML代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the `GridSplitter` control has been placed in the second column.
    When you run the application, you will see a vertical line inside the second column
    that you can drag to resize the grid column, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GridSplitter`控件被放置在第二列。当你运行应用程序时，你将在第二列中看到一个垂直线，你可以拖动它来调整网格列的大小，如下面的截图所示：
- en: '![](img/b73206bc-99f9-42fb-8f4e-b8f6492c52dc.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b73206bc-99f9-42fb-8f4e-b8f6492c52dc.png)'
- en: Spanning elements across multiple rows and/or columns
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多行和多/或列中跨越元素
- en: It's not mandatory to place an item in a single cell only. You can span it across
    multiple rows and/or columns. The attached property `Grid.RowSpan` allows you
    to span the element across two or more grid row cells. Similarly, `Grid.ColumnSpan`
    allows you to span the element across two or more grid columns. You can use either
    or both.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并非必须将一个项目放置在单个单元格中。你可以将它跨越多个行和/或列。附加属性`Grid.RowSpan`允许你将元素跨越两个或多个网格行单元格。同样，`Grid.ColumnSpan`允许你将元素跨越两个或多个网格列。你可以使用其中一个或两个。
- en: 'Consider the following code snippet, where the rectangle is spanned across
    two rows and two columns, starting at the (`0,0`) cell position:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中矩形跨越两个行和两个列，从（`0,0`）单元格位置开始：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run this, you will see the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你将看到以下输出：
- en: '![](img/789cd6df-57ac-4702-9d4d-0524e281899c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/789cd6df-57ac-4702-9d4d-0524e281899c.png)'
- en: Placing elements in uniform cells
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在均匀单元格中放置元素
- en: Just like the `Grid` layout system in Windows Presentation Foundation, the `UniformGrid`
    control also provides the similar layout system, but only with a difference that
    the rows and columns are of same size. It equally divides the layout into cells,
    of the same size, based on the number of rows and columns. Thus, you will not
    have the choice to modify the height and width of the rows and columns explicitly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Windows Presentation Foundation中的`Grid`布局系统一样，`UniformGrid`控件也提供了类似的布局系统，但只有一点不同，即行和列的大小相同。它根据行和列的数量，将布局平均分成相同大小的单元格。
- en: In this recipe, we will learn about the `UniformGrid` layout with a simple example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过一个简单的例子来学习`UniformGrid`布局。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a sample application to demonstrate the `UniformGrid` control.
    Open your Visual Studio IDE and create a new WPF application project named `CH03.UniformGridDemo`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例应用程序来演示`UniformGrid`控件。打开你的Visual Studio IDE，创建一个名为`CH03.UniformGridDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下步骤：
- en: From Solution Explorer, open the `MainWindow.xaml` page.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，打开`MainWindow.xaml`页面。
- en: 'Replace the existing `Grid` panel with the following XAML code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下XAML代码替换现有的`Grid`面板：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build the project and run the application. You will see the following output
    on the screen:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行应用程序。你将在屏幕上看到以下输出：
- en: '![](img/6d119589-b749-454d-a5ad-efbd4230cbb7.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d119589-b749-454d-a5ad-efbd4230cbb7.png)'
- en: 'Now close the application and add a few more `Label` controls in the same `UniformGrid`
    as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关闭应用程序，并在相同的`UniformGrid`中添加几个更多的`Label`控件，如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the application once again and you will see that the row and column count
    automatically changed to accommodate the new elements, as seen in the following
    screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序，你会看到行和列的数量会自动改变以适应新的元素，如下面的截图所示：
- en: '![](img/29bb33aa-4a75-4b69-8f5b-a2f1eacaaec2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29bb33aa-4a75-4b69-8f5b-a2f1eacaaec2.png)'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you start placing controls inside an `UniformGrid` control, it automatically
    calculates the number of cells required to accommodate placing of the added controls.
    Based on that, it divides the available space into rows and columns to position
    the child elements sequentially.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在 `UniformGrid` 控件内放置控件时，它会自动计算所需的单元格数量以容纳添加的控件。基于此，它将可用空间划分为行和列，以顺序定位子元素。
- en: When there is a need to place more controls, it again breaks the space into
    an additional number of equal rows and columns, as shown in the second example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要放置更多控件时，它再次将空间划分为额外的相等行和列，如第二个示例所示。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many properties that `UniformGrid` provides us with, to customize
    the UI. We are now going to discuss some of the most important properties.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniformGrid` 为我们提供了许多属性，以自定义 UI。我们现在将讨论一些最重要的属性。'
- en: Setting the row and column count
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置行和列数
- en: '`UniformGrid` does not have any restriction on setting the number of rows and
    columns. You can set the numbers by assigning the `Rows` and `Columns` properties.
    For example, the following XAML will render the elements in a single row only,
    as we assigned `Rows="1"`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniformGrid` 在设置行数和列数上没有限制。你可以通过分配 `Rows` 和 `Columns` 属性来设置数字。例如，以下 XAML 只会将元素渲染为单行，因为我们分配了
    `Rows="1"`：'
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding example will have the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将产生以下输出：
- en: '![](img/bf9498e7-e1db-4c1a-b1e9-3d4f0c6951f5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf9498e7-e1db-4c1a-b1e9-3d4f0c6951f5.png)'
- en: If you set `Columns="2"`, all the elements will reposition themselves into two
    columns, but in multiple rows. You can also combine both the properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置 `Columns="2"`，所有元素都将重新定位到两列，但跨越多行。你还可以组合这两个属性。
- en: Defining the first cell of the UniformGrid
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 UniformGrid 的第一个单元格
- en: It's a default nature of the `UniformGrid` panel to place the first element
    at the first cell (Row=`0`, Column=`0`), but it also offers to set the cell position
    explicitly. The first cell location must be in the first row, starting the index
    at `0` (zero).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniformGrid` 面板默认将第一个元素放置在第一个单元格中（行=0，列=0），但它也允许显式设置单元格位置。第一个单元格的位置必须在第一行，索引从
    `0`（零）开始。'
- en: 'The following example demonstrates how you can set the first element position
    by assigning the `FirstColumn` property:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何通过分配 `FirstColumn` 属性来设置第一个元素的位置：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you run the preceding example, you will see the following output on the
    screen, where the Cell 1 label is positioned at the third column (index position
    is `2`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的示例时，你将在屏幕上看到以下输出，其中单元格 1 标签位于第三列（索引位置是 `2`）：
- en: '![](img/98108e82-9c82-4133-a5da-f7505e833213.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98108e82-9c82-4133-a5da-f7505e833213.png)'
- en: Filling elements from right to left
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从右到左填充元素
- en: 'The default behavior of filling elements in `UniformGrid` is *left to right*.
    But you can fill them in *right to left* fashion. To do this, set the `FlowDirection`
    property to `RightToLeft` (the default is `LeftToRight`), as shown in the following
    snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniformGrid` 中填充元素的默认行为是 *从左到右*。但你可以以 *从右到左* 的方式填充它们。为此，将 `FlowDirection`
    属性设置为 `RightToLeft`（默认为 `LeftToRight`），如以下代码片段所示：'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run the preceding code, you will see a UI similar to the following
    screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，你将看到一个类似于以下截图的 UI：
- en: '![](img/f95a1b11-7f8c-43b3-9139-538464936562.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f95a1b11-7f8c-43b3-9139-538464936562.png)'
- en: Automatically repositioning controls using WrapPanel
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WrapPanel 自动重新定位控件
- en: '`WrapPanel` in WPF is similar to `StackPanel`, but it does not stack the items
    in a single line; rather it wraps the items to a new line based on the available
    space. It also looks like a `UniformGrid` control, but it has odd cell size depending
    on the item dimension.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 中的 `WrapPanel` 与 `StackPanel` 类似，但它不会将项目堆叠成单行；而是根据可用空间将项目换行。它看起来也像 `UniformGrid`
    控件，但它具有根据项目尺寸的奇数单元格大小。
- en: In this recipe, we will cover more about `WrapPanel` and how to reposition controls
    using it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将更详细地介绍 `WrapPanel` 以及如何使用它重新定位控件。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open Visual Studio IDE and create a new project named `CH03.WrapPanelDemo`.
    Make sure to select the WPF app template while creating the project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开 Visual Studio IDE 并创建一个名为 `CH03.WrapPanelDemo` 的新项目。确保在创建项目时选择 WPF 应用程序模板。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at a simple example to add a few buttons in `WrapPanel`. Perform
    the following steps to design the UI:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来在`WrapPanel`中添加几个按钮。按照以下步骤设计UI：
- en: From the Visual Studio Solution Explorer, open the `MainWindow.xaml` page.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Visual Studio解决方案资源管理器中打开`MainWindow.xaml`页面。
- en: Replace the existing `Grid` panel with a `WrapPanel` control and set its `Orientation`
    property to `Horizontal`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`Grid`面板替换为`WrapPanel`控件，并将其`Orientation`属性设置为`Horizontal`。
- en: 'Add a few button controls of diverse sizes. The entire XAML inside the window
    will look like the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些不同大小的按钮控件。窗口中的整个XAML将类似于以下代码：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now build the project and run the application. You will see the following output
    on the screen:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建项目并运行应用程序。您将在屏幕上看到以下输出：
- en: '![](img/6ca7843f-6fdd-4bb3-a0b0-4db1d7612e6d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ca7843f-6fdd-4bb3-a0b0-4db1d7612e6d.png)'
- en: Resize the application UI to see how the buttons are placed within the screen.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整应用程序UI的大小，看看按钮如何在屏幕内放置。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`WrapPanel` works by stacking child elements in a line. Once the line is full
    and can''t hold to add more elements, it wraps there, and adds the new element
    in the next line and continues. Unlike `UniformGrid`, the `WrapPanel` does not
    have any fixed width for columns. So, items can be placed based on the available
    space.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrapPanel`通过在一条线上堆叠子元素来工作。一旦这一行满了，不能再添加更多元素，它就会在那里换行，并在下一行添加新元素并继续。与`UniformGrid`不同，`WrapPanel`没有固定列宽。因此，可以根据可用空间放置项目。'
- en: The button controls, which we added as child elements of the `WrapPanel`, get
    added in stack in the first row. When it's unable to accommodate within the same
    line, it wraps to the next line to give room for the next elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为`WrapPanel`子元素添加的按钮控件将堆叠在第一行。当它无法在同一行容纳时，它会换行以给下一个元素留出空间。
- en: The `Orientation` property of the `WrapPanel` decides whether you want to stack
    them horizontally or vertically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrapPanel`的`Orientation`属性决定了您是想水平还是垂直堆叠它们。'
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the preceding example, we have seen that the items inside the `WrapPanel`
    have their individual size mentioned along with them. You can also set the size
    for all the items to a specific value by setting the `ItemWidth` and `ItemHeight`
    properties, as shown in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经看到`WrapPanel`内的项目都有它们各自的大小提及。您也可以通过设置`ItemWidth`和`ItemHeight`属性来为所有项目设置一个特定值，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, you won''t need to specify the size individually to each child
    element. When you run the preceding code, you will see the output similar to the
    following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您不需要为每个子元素单独指定大小。当您运行前面的代码时，您将看到类似于以下输出的输出：
- en: '![](img/e1efc6d5-a819-41ac-a7c4-d492fdf6949d.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1efc6d5-a819-41ac-a7c4-d492fdf6949d.png)'
- en: Placing controls in a Stack
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在堆叠中放置控件
- en: Another simple and useful layout panel in WPF is a `StackPanel`. It works almost
    like a `WrapPanel`, but with a difference that it can't wrap the child elements
    to a new line. All items added inside it either get placed in horizontal or vertical
    stacks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中另一个简单且有用的布局面板是`StackPanel`。它几乎与`WrapPanel`一样工作，但有一个区别，它不能将子元素换行。所有添加到其中的项目要么水平堆叠，要么垂直堆叠。
- en: The `StackPanel` measures its children using either native or relative sizing,
    keeping the arrangement pass simple by laying out the items in order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel`使用原生或相对大小来测量其子元素，通过按顺序布局项目来简化布局过程。'
- en: However, the `Grid` uses complex combinations of child elements when proportional
    sizing or auto sizing is used. Thus, it makes the `Grid` layout have a slow to
    medium performance for the measure pass and the arrangement pass to execute.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用比例大小或自动大小的时候，`Grid`会使用复杂的子元素组合。因此，它使得`Grid`布局在测量过程和布局过程执行时速度较慢到中等。
- en: Therefore, wherever possible, the `StackPanel` preferable to over the `Grid`
    panel to reduce the rendering overhead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可能的情况下，`StackPanel`比`Grid`面板更可取，以减少渲染开销。
- en: In this recipe, we will learn how the `StackPanel` works, by using a very simple
    example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过一个非常简单的例子来学习`StackPanel`的工作原理。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let's open Visual Studio and create a new WPF application project
    named `CH03.StackPanelDemo`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们打开Visual Studio并创建一个名为`CH03.StackPanelDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Inside Solution Explorer, navigate to the project and perform the following
    steps to create the sample UI with `StackPanel` containing a few button controls:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，导航到项目并执行以下步骤以创建包含几个按钮控件的 `StackPanel` 示例 UI：
- en: First, open the `MainWindow.xaml` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `MainWindow.xaml` 文件。
- en: 'Inside the `Window` tag, replace the default `Grid` with the following XAML
    code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Window` 标签内，将默认的 `Grid` 替换为以下 XAML 代码：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s build and run the application. You will see the following output:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。你将看到以下输出：
- en: '![](img/ae4d9d3d-f585-448a-bf85-810c5200049e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae4d9d3d-f585-448a-bf85-810c5200049e.png)'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first `StackPanel` is used to hold the multiple inner `StackPanel`, stacked
    vertically by default. The first inner `StackPanel` control holds Button 1 - Button
    4\. These will be stacked horizontally, as we set the `Orientation` property of
    the panel to `Horizontal`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `StackPanel` 用于容纳多个内嵌 `StackPanel`，默认垂直堆叠。第一个内嵌 `StackPanel` 控件包含按钮 1 -
    按钮四。这些按钮将水平堆叠，因为我们设置了面板的 `Orientation` 属性为 `Horizontal`。
- en: The second inner `StackPanel` holds Button 5 - Button 8, stacked vertically,
    as we set the `Orientation` property to `Vertical`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个内嵌 `StackPanel` 包含按钮 5 - 按钮八，垂直堆叠，因为我们设置了 `Orientation` 属性为 `Vertical`。
- en: Unlike `WrapPanel`, where the default orientation is `Horizontal`, `StackPanel`
    has its default orientation set to `Vertical`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认方向为 `Horizontal` 的 `WrapPanel` 不同，`StackPanel` 的默认方向设置为 `Vertical`。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: '`StackPanel` stretches its child elements by default, but you can take control
    of how it will stretch. On a vertically oriented `StackPanel`, you can assign
    the `HorizontalAlignment` property of the child elements to `Left`, `Center`,
    `Right`, or `Stretch`, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel` 默认拉伸其子元素，但你也可以控制其拉伸方式。在垂直方向的 `StackPanel` 中，你可以将子元素的 `HorizontalAlignment`
    属性设置为 `Left`、`Center`、`Right` 或 `Stretch`，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code example will give you the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例将给出以下输出：
- en: '![](img/fb5e1fbf-9f38-42c3-bae7-9874149398c1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb5e1fbf-9f38-42c3-bae7-9874149398c1.png)'
- en: Similarly, you can assign the `VerticalAlignment` property of the child elements,
    placed in a horizontally oriented `StackPanel`. This property contains the following
    values—`Top`, `Center`, `Bottom`, and `Stretch`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以为放置在水平方向的 `StackPanel` 中的子元素分配 `VerticalAlignment` 属性。此属性包含以下值——`Top`、`Center`、`Bottom`
    和 `Stretch`。
- en: Positioning controls inside a Canvas
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Canvas 中定位控件
- en: 'A `Canvas` is another simple panel in WPF, which allows you to place child
    elements at a specific coordinate position relative to the `Canvas`. It exposes
    four attached properties: `Left`, `Right`, `Top`, and `Bottom`, to handle the
    positioning of controls.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 是 WPF 中的另一个简单面板，它允许你将子元素放置在相对于 `Canvas` 的特定坐标位置。它公开了四个附加属性：`Left`、`Right`、`Top`
    和 `Bottom`，用于处理控件的位置。'
- en: This recipe will help you to understand the positioning of child elements in
    a `Canvas` panel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将帮助你理解 `Canvas` 面板中子元素的位置。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Let's open the Visual Studio instance and create a new WPF application project
    named `CH03.CanvasDemo`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 Visual Studio 实例，创建一个名为 `CH03.CanvasDemo` 的新 WPF 应用程序项目。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to create a simple `Canvas` panel with a few label
    controls in it and position them to specific coordinate positions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建一个简单的 `Canvas` 面板，其中包含一些标签控件，并将它们定位到特定的坐标位置：
- en: Open Solution Explorer and navigate to the project.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器并导航到项目。
- en: 'Open the `MainWindow.xaml` file and replace the default `Grid` with the following
    lines:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件，并用以下行替换默认的 `Grid`：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Build and run the application. It will show the following screen:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。它将显示以下屏幕：
- en: '![](img/d46eeb27-e86e-4134-88a3-63e280ab2e8a.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d46eeb27-e86e-4134-88a3-63e280ab2e8a.png)'
- en: Now resize the window and observe the positioning of the labels.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调整窗口大小并观察标签的位置。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Canvas.Left` property allows you to assign a value indicating the distance
    of the child element from the left edge of the `Canvas`. The `Canvas.Top` property
    allows you to assign a value indicating the distance of the child element from
    the top.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas.Left` 属性允许你指定子元素与 `Canvas` 左边缘的距离。`Canvas.Top` 属性允许你指定子元素与 `Canvas`
    顶部的距离。'
- en: Similarly, the `Canvas.Right` and `Canvas.Bottom` properties allow you to assign
    the relative position from right and bottom, respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Canvas.Right` 和 `Canvas.Bottom` 属性允许你分别指定相对于右边缘和底部的相对位置。
- en: As you can see in the preceding example, the first label is placed at the coordinate
    position (`70, 40`), whereas the second element is placed at the coordinate position
    (`220, 90`). If you resize the window, the position of the child elements will
    not change.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，第一个标签放置在坐标位置（`70, 40`），而第二个元素放置在坐标位置（`220, 90`）。如果您调整窗口大小，子元素的位置不会改变。
- en: Points to note are that the vertical and horizontal alignments on child elements
    do not work. Also, if you set the `Left` property, the `Right` property does not
    work. Similarly, if you set the `Top` property, the `Bottom` property does not
    work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，子元素上的垂直和水平对齐方式不起作用。此外，如果您设置了`Left`属性，则`Right`属性不起作用。同样，如果您设置了`Top`属性，则`Bottom`属性不起作用。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The *Z*-order of a control, placed in a `Canvas` panel, determines whether the
    control is in front of or behind another overlapping control. You can use the
    `Canvas.ZIndex` property to play with the positioning of the *Z*-order.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`Canvas`面板中放置的控件的`Z`-顺序决定了该控件是在另一个重叠控件的上方还是下方。您可以使用`Canvas.ZIndex`属性来调整`Z`-顺序的位置。
- en: By default, the `ZIndex` of the first element starts with `0` (zero) and gradually
    increases by `1` whenever you add a new element on the canvas. But in special
    cases, when you want to bring an overlapped control to the top, set its `ZIndex`
    higher than the `ZIndex` of the last element that is overlapping it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，画布上第一个元素的`ZIndex`从`0`（零）开始，并且每次您在画布上添加一个新元素时，它都会逐渐增加`1`。但在特殊情况下，当您想将一个重叠的控件置于顶部时，请将其`ZIndex`设置得高于与之重叠的最后一个元素的`ZIndex`。
- en: Wrapping UI elements using a Border
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Border包裹UI元素
- en: The `Border` control in WPF is used as a `Decorator`, which you can use to draw
    a border around another control. As the WPF panels do not support adding a border
    around its edges, the `Border` control is used to achieve the same.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的`Border`控件用作`Decorator`，您可以使用它来围绕另一个控件绘制边框。由于WPF面板不支持在其边缘添加边框，因此使用`Border`控件来实现相同的效果。
- en: This recipe will guide you to add a border to a control. You can also use the
    same concept to decorate a group of controls placed inside a panel, by wrapping
    the panel with a `Border`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导您如何为一个控件添加边框。您也可以使用相同的概念来装饰放置在面板内部的多个控件，通过将面板包裹在一个`Border`中来实现。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin with an example, let's first create a new project. Open Visual Studio
    and create a WPF application project named `CH03.BorderDemo`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个示例开始，让我们首先创建一个新的项目。打开Visual Studio并创建一个名为`CH03.BorderDemo`的WPF应用程序项目。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following simple steps to add a border around `TextBlock`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下简单步骤以在`TextBlock`周围添加边框：
- en: Open the `MainWindow.xaml` file of your WPF project.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的WPF项目的`MainWindow.xaml`文件。
- en: Now replace the default `Grid` with a `StackPanel`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将默认的`Grid`替换为`StackPanel`。
- en: 'Add a few TextBlocks inside it, wrapped by a Border. Here''s the complete XAML
    code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加几个由Border包裹的TextBlock。以下是完整的XAML代码：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run the application. You will see the following output:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。您将看到以下输出：
- en: '![](img/ca3cfdbe-b597-41ef-a460-3e298795d48f.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca3cfdbe-b597-41ef-a460-3e298795d48f.png)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `BorderThickness` property accepts an integer value to draw a border around
    the control. The property `BorderBrush` adds a color to it. You can use `SolidColorBrush`,
    `GradientColorBrush`, or any other brush type. The first `Border` control adds
    a thin `2px` border around the text.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorderThickness`属性接受一个整数值来绘制控件周围的边框。`BorderBrush`属性为其添加颜色。您可以使用`SolidColorBrush`、`GradientColorBrush`或任何其他画笔类型。第一个`Border`控件为文本添加了一个细的`2px`边框。'
- en: In the second example, the `CornerRadius` property has been set to `20` to add
    a 20-degree curve around the corners of the `Border` control.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，`CornerRadius`属性已设置为`20`，以在`Border`控件的角落周围添加20度的曲线。
- en: The third example has a border with a background brush to wrap the `TextBlock`
    control. You can club both the `BorderThickness`, `BorderBrush`, and `Background`
    properties together to give such a look. Notice the small corner radius of `5`
    degrees!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例有一个带有背景画笔的边框来包裹`TextBlock`控件。您可以将`BorderThickness`、`BorderBrush`和`Background`属性结合起来以实现这种外观。注意小角落半径为`5`度！
- en: In the fourth example, we have provided a border to two sides of the text. The
    value of `BorderThickness` can have `1`, `2`, or `4` double values. The four doubles
    (`BorderThickness="5, 3, 5, 4"` or `BorderThickness="5 3 5 4"`) describes the
    `Left`, `Top`, `Right`, and `Bottom` sides in the same order.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个示例中，我们为文本的两边提供了一个边框。`BorderThickness` 的值可以是 `1`、`2` 或 `4` 个双精度值。四个双精度值（`BorderThickness="5,
    3, 5, 4"` 或 `BorderThickness="5 3 5 4"`）按顺序描述了 `Left`、`Top`、`Right` 和 `Bottom`
    边。
- en: When you provide two double values (`BorderThickness="5, 3"` or `BorderThickness="5
    3"`), the first value describes `Left` and `Right`; the second value describes
    `Top` and `Bottom`, respectively. To provide thickness of the same amount in all
    the sides, assign only one double to the property (`BorderThickness="5"`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供两个双精度值（`BorderThickness="5, 3"` 或 `BorderThickness="5 3"`）时，第一个值描述 `Left`
    和 `Right`；第二个值分别描述 `Top` 和 `Bottom`。为了在所有边上提供相同厚度的厚度，只需将一个双精度值分配给属性（`BorderThickness="5"`）。
- en: Creating a scrollable panel
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可滚动面板
- en: The `ScrollViewer` controls enable scrolling functionality in a WPF application
    and help you to host other controls. When there are more contents available to
    show, but the viewable area is smaller than that, `ScrollViewer` is used to help
    the user to scroll through the content.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollViewer` 控件在 WPF 应用程序中启用滚动功能，并帮助您托管其他控件。当有更多内容可供显示，但可视区域小于该内容时，使用 `ScrollViewer`
    帮助用户滚动内容。'
- en: In this recipe, we will learn how to use a `ScrollViewer` inside a WPF application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在 WPF 应用程序中使用 `ScrollViewer`。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Let's open Visual Studio and create a project named `CH03.ScrollViewerDemo`.
    Be sure to create the project based on the WPF application template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 Visual Studio 并创建一个名为 `CH03.ScrollViewerDemo` 的项目。请确保基于 WPF 应用程序模板创建项目。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'It''s a quick step to surround a panel or control using the `ScrollViewer`.
    Perform the following steps to add a scrolling functionality to an `image` control:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ScrollViewer` 包围面板或控件是一个快速步骤。执行以下步骤以向 `image` 控件添加滚动功能：
- en: Inside the project, add an image named `demoImage.jpg`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为 `demoImage.jpg` 的图片。
- en: Open the `MainWindow.xaml` file from Solution Explorer.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器打开 `MainWindow.xaml` 文件。
- en: Now replace the existing `Grid` with a `ScrollViewer`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将现有的 `Grid` 替换为 `ScrollViewer`。
- en: 'Add an image pointing to the `demoImage.jpg` file, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个指向 `demoImage.jpg` 文件的图片，如下所示：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the application and you will see the following window with an image inside
    a `ScrollViewer`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到以下窗口，其中包含一个位于 `ScrollViewer` 内的图片：
- en: '![](img/76ee6fd0-f232-488f-8bc9-a263dfb40e82.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76ee6fd0-f232-488f-8bc9-a263dfb40e82.png)'
- en: Use the scroll bars to scroll left-right and/or up-down to see the entire image.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滚动条左右和/或上下滚动以查看整个图像。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`ScrollViewer` exposes two major properties—`HorizontalScrollBarVisibility`
    and `VerticalScrollBarVisibility`. Both represent an enumeration named `ScrollBarVisibility`,
    having four values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollViewer` 暴露了两个主要属性—`HorizontalScrollBarVisibility` 和 `VerticalScrollBarVisibility`。两者都代表一个名为
    `ScrollBarVisibility` 的枚举，有四个值：'
- en: '**Visible**: When the property is set to `ScrollBarVisibility.Visible`, the
    scroll bar will be visible all the time.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见**: 当属性设置为 `ScrollBarVisibility.Visible` 时，滚动条将始终可见。'
- en: '**Hidden**: When the property is set to `ScrollBarVisibility.Hidden`, the scrollbar
    will not be visible on screen and the user will not be able to scroll to see the
    complete content.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏**: 当属性设置为 `ScrollBarVisibility.Hidden` 时，滚动条将不会在屏幕上可见，用户将无法滚动以查看完整内容。'
- en: '**Disabled**: When it is set to `ScrollBarVisibility.Disabled`, the scrollbars
    will be disabled.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用**: 当设置为 `ScrollBarVisibility.Disabled` 时，滚动条将被禁用。'
- en: '**Auto**: This is often used to make the scrolling thumbs visible only when
    they are needed. For this, set the property to `ScrollBarVisibility.Auto`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动**: 这通常用于仅在需要时使滚动滑块可见。为此，将属性设置为 `ScrollBarVisibility.Auto`。'
- en: Docking controls using the DockPanel
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DockPanel 垂直控件
- en: '`DockPanel` makes it easier to dock UI elements in the left, right, top, or
    bottom of the screen. This is often useful, mainly when you want to divide the
    window into specific areas. For example, a status bar is always kept at the bottom
    of the window, whereas a menu or a toolbar resides at the topmost position of
    the window.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`DockPanel` 使在屏幕的左侧、右侧、顶部或底部停靠 UI 元素变得更容易。这通常很有用，尤其是在你想将窗口分成特定区域时。例如，状态栏始终保持在窗口底部，而菜单或工具栏位于窗口的最顶部。'
- en: This recipe will help you to learn how to dock child elements in an application
    window.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将帮助您学习如何在应用程序窗口中停靠子元素。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with a new project. Open Visual Studio and create a project named
    `CH03.DockPanelDemo`, based on the available WPF application template.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的项目开始。打开 Visual Studio 并创建一个基于可用 WPF 应用程序模板的项目，命名为 `CH03.DockPanelDemo`。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to add a `DockPanel` with a few labels docked into
    it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以添加一个带有几个标签停靠的 `DockPanel`：
- en: From Solution Explorer, navigate to the project and open `MainWindow.xaml`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器导航到项目并打开 `MainWindow.xaml`。
- en: Replace the existing `Grid` panel with a `DockPanel` control.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 面板替换为 `DockPanel` 控件。
- en: Now add five labels inside it and dock them in various sides of the window.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向其中添加五个标签并将它们停靠在窗口的各个侧面。
- en: 'Here''s the complete XAML code for reference:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是完整的 XAML 代码供参考：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s run the application. You will see that the labels are positioned in
    different sides of the window, as shown in the following screenshot:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。您将看到标签位于窗口的不同侧面，如下面的截图所示：
- en: '![](img/48aef2dc-b808-4a7c-b163-6952a4cf25f7.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48aef2dc-b808-4a7c-b163-6952a4cf25f7.png)'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `DockPanel.Dock` property determines the position of the element, based
    on the relative order. The property is of type `Dock` enumeration and it accepts
    the following values—`Dock.Left`, `Dock.Right`, `Dock.Top`, and `Dock.Bottom`.
    If you don't specify the property, by default, the first element will be docked
    to the left and the other elements will take the remaining space.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`DockPanel.Dock` 属性根据相对顺序确定元素的位置。该属性是 `Dock` 枚举类型，并接受以下值——`Dock.Left`、`Dock.Right`、`Dock.Top`
    和 `Dock.Bottom`。如果您不指定该属性，则默认情况下，第一个元素将停靠在左侧，其他元素将占用剩余空间。'
- en: In the preceding example, the labels are added inside the `DockPanel` in the
    following order, having the `DockPanel.Dock` property set to `Right`, `Top`, `Bottom`,
    and `Left`, respectively. The last label does not specify any `Dock` property
    and hence it takes the remaining space to accommodate itself inside it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，标签按照以下顺序添加到 `DockPanel` 中，分别具有 `DockPanel.Dock` 属性设置为 `Right`、`Top`、`Bottom`
    和 `Left`。最后一个标签没有指定任何 `Dock` 属性，因此它占用剩余空间以适应其内部。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In a `DockPanel`, ordering of dock matters most. If you change the order of
    the example that we have created previously, you will notice how the `DockPanel`
    changes the position of the added labels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DockPanel` 中，停靠顺序最为重要。如果您更改我们之前创建的示例的顺序，您将注意到 `DockPanel` 如何更改添加的标签的位置。
- en: Rescaling UI elements using a ViewBox
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ViewBox 缩放 UI 元素
- en: When you are building an application, you don't know the screen resolution of
    the system where the application will be running. If you design the UI considering
    small or standard resolution in mind, the UI controls will look very small in
    a high-resolution monitor. If you do the reverse, with big screens in mind, the
    user won't see the parts of the screen, if executed on a low-resolution monitor.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建应用程序时，您不知道应用程序将运行的系统的屏幕分辨率。如果您在设计 UI 时考虑到小或标准分辨率，则 UI 控件在高分辨率显示器上看起来会非常小。如果您反过来，考虑到大屏幕，则在低分辨率显示器上执行时，用户将看不到屏幕的部分。
- en: Hence, there is a need to create an auto-scaling mechanism, which will take
    care of different screen resolutions. `ViewBox` is a very popular control in WPF,
    which helps you to scale the content to fit the available space based on the size.
    When you resize the parent, it automatically transforms the content to scale in
    proportion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要创建一个自动缩放机制，该机制将处理不同的屏幕分辨率。`ViewBox` 是 WPF 中一个非常流行的控件，它可以帮助您根据大小缩放内容以适应可用空间。当您调整父元素的大小时，它将自动转换内容以按比例缩放。
- en: Let's learn how it works, with a simple example, in this recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来了解它是如何工作的。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE and create a new WPF application project named `CH03.ViewBoxDemo`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 Visual Studio IDE 并创建一个名为 `CH03.ViewBoxDemo` 的新 WPF 应用程序项目。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Please perform the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请执行以下步骤：
- en: Open the `MainWindow.xaml` file from Solution Explorer.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器打开 `MainWindow.xaml` 文件。
- en: Set a smaller size of the `Window`. Let's set its height to `120` and width
    to `400`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `Window` 的较小尺寸。让我们将其高度设置为 `120`，宽度设置为 `400`。
- en: Replace the existing `Grid` panel with a `ViewBox`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 面板替换为 `ViewBox`。
- en: 'Add text inside it, using the `TextBlock` control as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式在内部添加文本，使用 `TextBlock` 控件：
- en: '[PRE18]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the application. You will see the following output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你会看到以下输出：
- en: '![](img/305ea6a9-d82d-4433-98c9-38a4b91de736.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/305ea6a9-d82d-4433-98c9-38a4b91de736.png)'
- en: 'Now resize the window and you will see that the text is automatically scaled
    based on the size of the window:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调整窗口大小，你会看到文本会根据窗口的大小自动缩放：
- en: '![](img/885a9906-7323-411e-9373-76f0a27d5dbc.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/885a9906-7323-411e-9373-76f0a27d5dbc.png)'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ViewBox` provides you with a way to adjust the content of a window automatically,
    based on the resolution of the screen. When you resize the `ViewBox`, it automatically
    adjusts the size and the relative position of the contents to fit on the screen.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBox`为你提供了一种根据屏幕分辨率自动调整窗口内容的方式。当你调整`ViewBox`大小时，它会自动调整内容的大小和相对位置，以适应屏幕。'
- en: In the preceding example, the size of the window is set to `400x120`. The window
    has a `TextBlock` control with a text string, wrapped in a `ViewBox`. When you
    resize the window, the content also resizes by applying scale transform.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，窗口的大小设置为`400x120`。窗口有一个包含文本字符串的`TextBlock`控件，被包裹在一个`ViewBox`中。当你调整窗口大小时，内容也会通过应用缩放变换来调整大小。
- en: But if the aspect ratio of the `ViewBox` window does not fit in proportion,
    you will see a white space either at the left and right or top and bottom of the
    content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果`ViewBox`窗口的宽高比不合适，你会在内容的左侧和右侧或顶部和底部看到空白区域。
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ViewBox` control provides two properties to stretch the content. Those
    are `Stretch` and `StretchDirection`. When you don't specify the `Stretch` property
    to a `ViewBox`, it uses the default value for `Stretch`, which is `Uniform`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBox`控件提供了两个属性来拉伸内容。这些是`Stretch`和`StretchDirection`。当你没有指定`ViewBox`的`Stretch`属性时，它使用`Stretch`的默认值，即`Uniform`。'
- en: 'When the `Stretch` property is set to `Uniform`, and the `ViewBox` does not
    match the aspect ratio of the content, it adds a white margin to it. It can be
    either at the top and bottom or at the left and right sides:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Stretch`属性设置为`Uniform`，且`ViewBox`不匹配内容的宽高比时，它会在其顶部和底部或左侧和右侧添加白色边框。它可以是顶部和底部或左侧和右侧：
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When it is set to `Fill`, it causes the content to completely fill the space
    without obeying the aspect ratio. Thus, you may see a distortion in the UI:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为`Fill`时，它会导致内容完全填充空间而不遵守宽高比。因此，你可能会在UI中看到扭曲：
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you set the `Stretch` property to `UniformToFill`, it maintains the original
    aspect ratio and fills the window completely. You will not see any distortion
    in the UI:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`Stretch`属性设置为`UniformToFill`时，它保持原始的宽高比并完全填充窗口。你不会在UI中看到任何扭曲：
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you don''t want to resize the content, set the `Stretch` property to `None`.
    When you set it as `None`, and resize the window to enlarge, the content will
    not scale and will remain in its original state surrounded by white space:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想调整内容的大小，将`Stretch`属性设置为`None`。当你将其设置为`None`，并调整窗口以放大时，内容不会缩放，并将保持其原始状态，周围有空白：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `StretchDirection` property of the `ViewBox` is used to tell the `ViewBox`
    to stretch the content based on the `Stretch` property. When the `Stretch` property
    is set to `None`, the `StretchDirection` property has no effect.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBox`的`StretchDirection`属性用于告诉`ViewBox`根据`Stretch`属性拉伸内容。当`Stretch`属性设置为`None`时，`StretchDirection`属性没有效果。'
- en: When `StretchDirection` is set to `UpOnly` or `DownOnly`, the content will be
    resized upward or downward, based on the `ViewBox` size. When it is set to `Both`,
    the content will be resized in both directions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当`StretchDirection`设置为`UpOnly`或`DownOnly`时，内容将根据`ViewBox`的大小向上或向下调整大小。当设置为`Both`时，内容将在两个方向上调整大小。
- en: Creating a tabbed layout
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签布局
- en: To accommodate more content in a window layout, tabbed user interfaces are mostly
    used. They allow users to open multiple pages in a single window. For example,
    most of the recent internet browsers use tabbed interface to let the user open
    multiple web pages simultaneously in a single window.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在窗口布局中容纳更多内容，通常使用标签式用户界面。它们允许用户在一个窗口中打开多个页面。例如，大多数最近的网络浏览器使用标签界面，允许用户在一个窗口中同时打开多个网页。
- en: WPF provides `TabControl` to create the tabbed layout. In this recipe, we will
    learn the basics of tab interfaces, with a simple example to let you understand
    how it works.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: WPF提供了`TabControl`来创建标签布局。在这个菜谱中，我们将学习标签界面的基础知识，通过一个简单的示例让你了解它是如何工作的。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: To get started, make sure that you have opened Visual Studio IDE. Now create
    a new project named `CH03.TabControlDemo`, based on the available WPF application
    project template.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请确保你已经打开了 Visual Studio IDE。现在创建一个基于可用 WPF 应用程序项目模板的新项目，命名为 `CH03.TabControlDemo`。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create the UI interface to host a very basic tab control with a few
    tab items inside it. Perform the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 UI 接口以托管一个包含几个标签项的非常基本的标签控制。执行以下步骤：
- en: From the Solution Explorer window, open the `MainWindow.xaml` file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器窗口中，打开 `MainWindow.xaml` 文件。
- en: 'Inside the default `Grid` panel, add the `TabControl` with two `TabItem` controls
    as shown in the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的 `Grid` 面板内，添加一个 `TabControl`，其中包含两个 `TabItem` 控件，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now run this application and you will see the following UI, which contains two
    tabs inside it:![](img/d186bf82-0091-458c-a8c8-98f2b96f7640.png)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行此应用程序，你将看到以下 UI，其中包含两个标签页：![图片](img/d186bf82-0091-458c-a8c8-98f2b96f7640.png)
- en: 'Close the application and return to the XAML editor to add another `TabItem`
    inside the `TabControl`. Let''s change the template of the header to contain UI
    elements other than the plain text. Copy the following XAML after the second tab:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序并返回到 XAML 编辑器，在 `TabControl` 内添加另一个 `TabItem`。让我们更改标题的模板以包含除纯文本之外的 UI
    元素。在第二个标签之后复制以下 XAML：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now run the application once again and navigate to the third tab. You will see
    the following UI in the screen:![](img/43db2427-acaf-4df5-92fc-5a7ac4af14ea.png)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行应用程序，并导航到第三个标签页。你将在屏幕上看到以下 UI：![图片](img/43db2427-acaf-4df5-92fc-5a7ac4af14ea.png)
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TabControl` derives from `Selector` to provide you an `ItemsControl` to
    host elements inside it. You can host only `TabItem` controls, which are actually
    `HeaderedContentControl` to provide a `Header` to each of the items.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabControl` 从 `Selector` 继承，为你提供了一个 `ItemsControl` 来托管它内部的元素。你只能托管 `TabItem`
    控件，实际上它们是 `HeaderedContentControl`，为每个项目提供了一个 `Header`。'
- en: The `Header` property is of type object, which will allow you to put any content
    inside it, be it a plain text or a different UI element.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header` 属性是对象类型，这将允许你在其中放置任何内容，无论是纯文本还是不同的 UI 元素。'
- en: In the preceding example, the first two `TabItem` controls contain plain text
    as headers, whereas the third `TabItem` contains many different `UIElement` to
    give its header a customized look. When you switch from one tab to another, you
    will see its associated content, which you can programmatically access through
    its `Content` property.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，前两个 `TabItem` 控件包含作为标题的纯文本，而第三个 `TabItem` 包含许多不同的 `UIElement` 以给其标题一个定制的样式。当你从一个标签页切换到另一个标签页时，你会看到其关联的内容，你可以通过其
    `Content` 属性以编程方式访问。
- en: Dynamically adding/removing elements in a panel
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面板中动态添加/删除元素
- en: So far, we have seen how to add static elements/contents in a `Panel` control.
    But it's not always useful, mainly when you are retrieving data from the backend
    and populating in the UI or dynamically based on the user interaction.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在 `Panel` 控件中添加静态元素/内容。但这并不总是有用的，尤其是在你从后端检索数据并在 UI 中填充，或者根据用户交互动态填充时。
- en: This recipe will discuss this topic. As all the panels perform similarly to
    add/remove elements, with a slight difference on the positioning, we will be demonstrating
    it with a simple `Canvas`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将讨论这个主题。由于所有面板在添加/删除元素时表现相似，只是在定位上略有不同，我们将通过一个简单的 `Canvas` 来演示。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin with the coding, let's create a WPF application project first. Open
    Visual Studio and create a new project named `CH03.DynamicPanelDemo`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编码之前，让我们首先创建一个 WPF 应用程序项目。打开 Visual Studio 并创建一个名为 `CH03.DynamicPanelDemo`
    的新项目。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s add a `Canvas` panel inside the window, and dynamically add squares
    at the current cursor position when the user clicks the `Canvas` panel. Perform
    the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在窗口内添加一个 `Canvas` 面板，并在用户点击 `Canvas` 面板时在当前光标位置动态添加正方形。执行以下步骤：
- en: Open the `MainWindow.xaml` page and replace the default `Grid` panel with a
    `Canvas`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，并将默认的 `Grid` 面板替换为 `Canvas`。
- en: Give it a name. In our example, let's give the name as `canvasPanel`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它起个名字。在我们的例子中，让我们将其命名为 `canvasPanel`。
- en: 'Set a background to the canvas panel and register a `MouseLeftButtonDown` event
    to it. Here''s the complete XAML code, for reference:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为画布面板设置背景并为其注册一个 `MouseLeftButtonDown` 事件。以下是完整的 XAML 代码，仅供参考：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now open its associated code-behind file `MainWindow.xaml.cs` and implement
    the event. Alternatively, you can place the cursor on top of the event name and
    press *F12* to generate the event and navigate to it directly.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开其关联的代码后置文件 `MainWindow.xaml.cs` 并实现该事件。或者，你可以将光标放在事件名称上方并按 *F12* 生成事件并直接导航到它。
- en: 'Inside the `OnMouseLeftButtonDown` event implementation, retrieve the current
    cursor position and place the element at the same position on the canvas, where
    the user clicked. Here''s the code implementation:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnMouseLeftButtonDown` 事件实现内部，获取当前光标位置并将元素放置在画布上用户点击的相同位置。以下是代码实现：
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's run the application. You will see a blank window with the same background
    color that we have set on the `Canvas`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用程序。你会看到一个空白窗口，其背景颜色与我们在 `Canvas` 上设置的相同。
- en: Randomly click on the `Canvas` area and you will see the squares popping up
    on the screen, at the same place where you are left-clicking on the `Canvas`.
    The UI will look as follows:![](img/2e7e78d9-50c9-4c44-a724-31a49809c12f.png)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机点击 `Canvas` 区域，你会在屏幕上看到正方形弹出，位置与你左键点击 `Canvas` 的位置相同。UI 将如下所示：![](img/2e7e78d9-50c9-4c44-a724-31a49809c12f.png)
- en: 'To remove the elements from the square, let''s register a `MouseRightButtonDown`
    event in the `Canvas` panel present in the XAML. Close the running application
    and replace the entire content of the `MainWindow.xaml` page with the following
    one:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从正方形中删除元素，让我们在 XAML 中的 `Canvas` 面板中注册一个 `MouseRightButtonDown` 事件。关闭正在运行的应用程序，并将
    `MainWindow.xaml` 页面的全部内容替换为以下内容：
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now navigate to the `MainWindow.xaml.cs` file to add the associated event implementation.
    Add the following snippet inside the class:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到 `MainWindow.xaml.cs` 文件以添加相关事件实现。在类内部添加以下代码片段：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the application once again and randomly click inside the `Canvas` to add
    the squares inside it.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序，并在 `Canvas` 内随机点击以添加正方形。
- en: Once the squares are in place, right-click on them to see the clicked ones disappear
    from the panel.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦正方形放置到位，右键点击它们以查看被点击的正方形从面板中消失。
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every panel exposes a property named `Children` to hold a collection of `UIElement`
    as `UIElementCollection`. To dynamically add an element to `UIElementCollection`,
    use its `Add` method; and to remove an element, pass the element to its `Remove`
    method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个面板都暴露一个名为 `Children` 的属性，用于存储 `UIElement` 集合作为 `UIElementCollection`。要动态地向
    `UIElementCollection` 添加一个元素，请使用其 `Add` 方法；要删除一个元素，请将其传递给其 `Remove` 方法。
- en: In the preceding example, when the user left-clicks on the `Canvas`, the `e.GetPosition`
    method provides the coordinate position (`X`, `Y`) of the click, relative to the
    panel where it was clicked. The `Canvas.SetLeft` and `Canvas.SetTop` methods are
    used to position the created element relative to the panel and then are added
    to it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当用户在 `Canvas` 上左键点击时，`e.GetPosition` 方法提供了相对于点击面板的点击坐标位置（`X`、`Y`）。`Canvas.SetLeft`
    和 `Canvas.SetTop` 方法用于将创建的元素相对于面板定位，然后将其添加到面板中。
- en: Similarly, to delete the element from the panel, the `e.Source` property is
    used to retrieve the element where the user right-clicked. If it is not `null`,
    remove it from the `Canvas` by calling the `Remove` method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要删除面板中的元素，请使用 `e.Source` 属性来检索用户右键点击的元素。如果它不是 `null`，则通过调用 `Remove` 方法将其从
    `Canvas` 中删除。
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The coordinate positions are used to place elements in a `Canvas` panel. When
    you want to place an item in a `Grid`, set the `Row` and `Column` while placing
    it. For `StackPanel`, `WrapPanel`, and `UniformGrid` panels, you won't need to
    specify any other property as those will be stacked automatically.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标位置用于在 `Canvas` 面板中放置元素。当你想要在 `Grid` 中放置一个项目时，放置它时设置 `Row` 和 `Column`。对于 `StackPanel`、`WrapPanel`
    和 `UniformGrid` 面板，你不需要指定任何其他属性，因为它们将自动堆叠。
- en: 'The following example shows you how to dynamically add an element in a `Grid`,
    at a specific cell position, specified by the `Row` and `Column` index:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在 `Grid` 中动态添加一个元素，在由 `Row` 和 `Column` 索引指定的特定单元格位置：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to span the element to multiple rows and multiple columns, you
    can do so by calling the `Grid.SetRowSpan` and `Grid.SetColumnSpan` methods, as
    shown in the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将元素跨越多行和多列，你可以通过调用 `Grid.SetRowSpan` 和 `Grid.SetColumnSpan` 方法来实现，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implementing the drag and drop feature
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现拖放功能
- en: When you want to provide a rich experience to the user, you may want to use
    the dragging and dropping feature. You may also want to add a drag and drop feature
    in your application to access a local resource to upload it to the server.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为用户提供丰富的体验时，你可能想使用拖拽和放置功能。你也许还希望在应用程序中添加拖拽功能以访问本地资源并将其上传到服务器。
- en: In this recipe, we will learn the basics of drag and drop implementation in
    WPF by using a simple example.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将通过一个简单的示例学习 WPF 中拖拽实现的 basics。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open Visual Studio and create a new WPF application named `CH03.DragAndDropDemo`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个名为 `CH03.DragAndDropDemo` 的新 WPF 应用程序。
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s perform the following steps to create a few elements inside a window
    and provide the option to drag and drop from one panel to the other:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，在窗口内创建一些元素，并从其中一个面板拖拽到另一个面板：
- en: First, open `MainWindow.xaml` and replace the existing `Grid` with a `StackPanel`.
    Set its `Orientation` property to `Horizontal`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `MainWindow.xaml` 并将现有的 `Grid` 替换为 `StackPanel`。设置其 `Orientation` 属性为
    `Horizontal`。
- en: Add two `WrapPanel` inside it and set their `Width`, `Margin`, `ItemHeight`,
    and `ItemWidth` properties.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加两个 `WrapPanel` 并设置它们的 `Width`、`Margin`、`ItemHeight` 和 `ItemWidth` 属性。
- en: Give a name to both panels. Let's name the first wrap panel `sourcePanel` and
    the second wrap panel `targetPanel`. We will be using these name later from the
    code, while accessing them.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给这两个面板起个名字。让我们将第一个 wrap panel 命名为 `sourcePanel`，第二个 wrap panel 命名为 `targetPanel`。我们将在代码中使用这些名称来访问它们。
- en: 'Add a few labels to the first wrap panel. Set their `Content`, `Background`,
    and other text formatting properties. Here''s the complete markup code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个 wrap panel 中添加一些标签。设置它们的 `Content`、`Background` 和其他文本格式化属性。以下是完整的标记代码：
- en: '[PRE31]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you run this application, you will see two panels on the screen. As shown
    in the following screenshot, one of them will have five labels (Item 1 - Item
    5) and the other will be empty:![](img/ea19316b-0c08-4765-8c26-05fc2d86e577.png)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行此应用程序，你将在屏幕上看到两个面板。如下面的截图所示，其中一个面板将包含五个标签（项目 1 - 项目 5），另一个将为空：![截图](img/ea19316b-0c08-4765-8c26-05fc2d86e577.png)
- en: If you now drag any element from the left panel and try to drop it to the right
    panel, you will see that it won't work. We have not yet added the drag and drop
    support.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在从左侧面板拖拽任何元素并尝试将其放置到右侧面板，你会发现它不起作用。我们还没有添加拖拽支持。
- en: 'To add the dragging support to the first wrap panel (`sourcePanel`), register
    its `MouseLeftButtonDown` event property in the XAML as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将拖拽支持添加到第一个 wrap panel (`sourcePanel`)，在 XAML 中注册其 `MouseLeftButtonDown` 事件属性，如下所示：
- en: '[PRE32]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An `OnDrag` event, registered in XAML, needs to be implemented in the code
    behind the file. Open `MainWindow.xaml.cs` and add the following event implementation,
    which will add the dragging support to the `sourcePanel`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XAML 中注册的 `OnDrag` 事件需要在文件的代码后端实现。打开 `MainWindow.xaml.cs` 并添加以下事件实现，这将向 `sourcePanel`
    添加拖拽支持：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we need to enable the second wrap panel (`targetPanel`) as a droppable target
    and set its `AllowDrop` property to `True`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要启用第二个 wrap panel (`targetPanel`) 作为可放置的目标，并将其 `AllowDrop` 属性设置为 `True`。
- en: 'Also register its `Drop` event property, so that we can perform the `drop`
    operation. Here''s the entire mark-up for the second panel:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时注册其 `Drop` 事件属性，以便我们可以执行 `drop` 操作。以下是第二个面板的完整标记：
- en: '[PRE34]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we need to implement the body of the `OnDrop` event to perform the desired
    `drop` operation. Navigate to `MainWindow.xaml.cs` once again and add the following
    code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要实现 `OnDrop` 事件体以执行所需的 `drop` 操作。再次导航到 `MainWindow.xaml.cs` 并添加以下代码：
- en: '[PRE35]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s run the application now. The same screen will appear with two panels.
    The first panel (left) will have a few elements in it. Position your cursor on
    one of them, click it to drag it to the other panel (right), and release it there.
    You will see that the item will be removed from the first and added to the right
    panel, as shown in the following screenshot:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行应用程序。屏幕上会出现相同的界面，有两个面板。第一个面板（左侧）将包含一些元素。将光标置于其中一个元素上，点击它将其拖拽到另一个面板（右侧），并在那里释放。你会看到该元素将从第一个面板移除并添加到右侧面板，如下面的截图所示：
- en: '![](img/9f443bef-960e-452f-8cac-74c8cbce75c0.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9f443bef-960e-452f-8cac-74c8cbce75c0.png)'
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `AllowDrop="True"` property prepares the panel as drop enabled. When you
    start a drag by clicking on the element, the `DragDrop.DoDragDrop` method written
    in the `OnDrag` event initiates the drag and drop operation. It takes the first
    parameter as a reference to the dependency object, that is, the source of the
    data being dragged. The second parameter is the data object that contains the
    data being dragged. And the last parameter is a value that specifies the final
    effect (`DragDropEffects`) of the operation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllowDrop="True"`属性将面板准备为启用拖放。当您通过点击元素开始拖动时，`OnDrag`事件中编写的`DragDrop.DoDragDrop`方法将启动拖放操作。它将第一个参数作为依赖对象的引用，即正在拖动的数据源。第二个参数是包含正在拖动数据的对象。最后一个参数是一个值，用于指定操作的最终效果（`DragDropEffects`）。'
- en: In the preceding example, when the element is dropped to the drop target, the
    dragged data retrieved from the `DragEventArgs` parameter value is first removed
    from the source and then added to the drop target.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当元素被拖放到目标时，从`DragEventArgs`参数值检索到的拖动数据首先从源中移除，然后添加到目标。
- en: There's more...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Based on your drag-and-drop requirement, you can change the effects by specifying
    the proper enum value of the `DragDropEffects`. The effects can be of six types:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的拖放需求，您可以通过指定`DragDropEffects`枚举值的正确值来更改效果。效果可以分为六种类型：
- en: '**None**: When specified, the drop target will not accept any data and the
    cursor will change to an unavailable icon:![](img/5f7bfa5a-264d-49f6-b391-8298c304bfd9.png)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**: 当指定时，目标将不接受任何数据，光标将变为不可用图标![图片](img/5f7bfa5a-264d-49f6-b391-8298c304bfd9.png)'
- en: '**Copy**: When specified, the data is copied to the drop target and during
    the `drop` operation on the target, the cursor will look as follows:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**: 当指定时，数据将被复制到目标，并且在目标上的`drop`操作期间，光标将看起来如下所示：'
- en: '![](img/30eaf1fe-8751-4564-9f16-88719032c8de.png)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/30eaf1fe-8751-4564-9f16-88719032c8de.png)'
- en: '**Move**: When specified, the data from the source is moved to the drop target.
    During the `drop` operation, the cursor will change to the following:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**: 当指定时，源数据将被移动到目标。在`drop`操作期间，光标将变为以下样式：'
- en: '![](img/51a204dc-58fa-4089-a752-ea568d19e36a.png)'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/51a204dc-58fa-4089-a752-ea568d19e36a.png)'
- en: '**Link**: When specified, the data from the source is linked to the drop target.
    During the `drop` operation on the target, the cursor will change to the following:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**: 当指定时，源数据将与目标链接。在目标上的`drop`操作期间，光标将变为以下样式：'
- en: '![](img/087a2a06-f58f-4c4a-9922-45f4e19b25d2.png)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/087a2a06-f58f-4c4a-9922-45f4e19b25d2.png)'
- en: '**Scroll**: When specified, it defines whether the scrolling is about to start
    or currently happening on the drop target.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动**: 当指定时，它定义了滚动是否即将在目标元素上开始或当前正在发生。'
- en: '**All**: When specified, the data is copied and scrolled to the drop target
    after being removed from the source.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全部**: 当指定时，数据在从源移除后将被复制并滚动到目标。'
