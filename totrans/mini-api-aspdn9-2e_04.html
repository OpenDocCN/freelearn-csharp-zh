<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-53">
    <a id="_idTextAnchor081">
    </a>
    
     4
    
   </h1>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor082">
    </a>
    
     Handling HTTP Methods and Routing
    
   </h1>
   <p>
    
     In
    
    <a href="B20968_02.xhtml#_idTextAnchor033">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     , we discussed ways that you can define endpoints and use routing within a minimal API.
    
    
     That was from a
    
    
     
      high level.
     
    
   </p>
   <p>
    
     However, in this chapter, we will discuss in more detail how routes and endpoints can be configured for the handling of incoming requests.
    
    
     We will go into more detail about how you can use route parameters to be more specific about the required parameters received by each endpoint, and we will also explore examples of request validation, wherein we ensure that the request is properly formed, issuing the relevant response
    
    
     
      as necessary.
     
    
   </p>
   <p>
    
     Finally, no API can be deemed reliable if its endpoints do not adequately recover from receiving invalid data so we will also explore ways in which validation errors can be
    
    
     
      handled gracefully.
     
    
   </p>
   <p>
    
     To gain a better understanding of these topics, we will use an example application for managing tasks.
    
    
     The application is part of a productivity suite, which has an API for managing to-do lists and projects.
    
    
     By building elements of this API, you will gain a more in-depth understanding of how requests are received by minimal APIs and how they
    
    
     
      are handled.
     
    
   </p>
   <p>
    
     In summary, this chapter will cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      
       Handling requests
      
     
    </li>
    <li>
     
      Defining endpoints in the
     
     
      
       Todo API
      
     
    </li>
    <li>
     
      Managing
     
     
      
       route parameters
      
     
    </li>
    <li>
     
      Request validation and
     
     
      
       error handling
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor083">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code for this chapter is available in the GitHub repository
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     You can of course follow along and write the code yourself as you read the chapter if you have Visual Studio 2022 / Visual Studio Code installed with .
    
    
     
      NET 9.
     
    
   </p>
   <h1 id="_idParaDest-56">
    <a id="_idTextAnchor084">
    </a>
    
     Handling requests
    
   </h1>
   <p>
    
     To handle incoming
    
    <a id="_idIndexMarker088">
    </a>
    
     requests, we first need a set of minimal API endpoints for those requests to be sent to.
    
    
     Let’s recap what we explored in
    
    <a href="B20968_02.xhtml#_idTextAnchor033">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     , around creating minimal API endpoints with varying HTTP methods (
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     ).
    
    
     We can refresh our memories by creating some static
    
    <em class="italic">
     
      mock
     
    </em>
    
     data that will represent the task entities our API is handling.
    
    
     Then, we can define some simple endpoints that manipulate or query
    
    
     
      that data.
     
    
   </p>
   <p>
    
     Let’s create the mock data first.
    
    
     We’ll do this by creating a simple
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     class, and a static list for instances of this class to
    
    
     
      reside in:
     
    
   </p>
   <pre class="source-code">
public class TodoItem
{
    public int Id { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime DueDate { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public string Assignee { get; set; }
    public int Priority { get; set; }
    public bool IsComplete { get; set; }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     class can stay quite simple for the time being.
    
    
     It can be expanded upon later with more specific properties as we understand our needs further.
    
    
     The same approach can be taken with the next piece of code, which for now will be a list of
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , simply called
    
    <strong class="source-inline">
     
      ToDoItems
     
    </strong>
    
     .
    
    
     In this list, we store instances of
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     to be handled by endpoints
    
    <a id="_idIndexMarker089">
    </a>
    
     during requests.
    
    
     Let’s place this list
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
List&lt;TodoItem&gt; ToDoItems = new List&lt;TodoItem&gt;();</pre>
   <p>
    
     Now that we have our temporary data storage solution in the form of a list, we can focus on creating endpoints for handling requests and managing
    
    
     
      todo items.
     
    
   </p>
   <h1 id="_idParaDest-57">
    <a id="_idTextAnchor085">
    </a>
    
     Defining endpoints in the Todo API
    
   </h1>
   <p>
    
     It’s advisable to start as simple as
    
    <a id="_idIndexMarker090">
    </a>
    
     possible in creating a minimal API.
    
    
     After all, the
    
    <a id="_idIndexMarker091">
    </a>
    
     name
    
    <em class="italic">
     
      minimal API
     
    </em>
    
     connotes simplicity.
    
    
     This isn’t just simplicity for simplicity’s sake though.
    
    
     For now, our API only needs to cover one area: todo items.
    
    
     Sure, the scope might expand further in the future, and minimal APIs can still be crafted in such a way that they are expandable and therefore somewhat future-proofed, but until more requirements become apparent (for example, assigning to-do items to users, adding to-do items to specific projects, etc.), the aim is minimalism.
    
    
     With this in mind, we will, for now, keep our endpoints
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We should now ask ourselves a simple question:
    
    <em class="italic">
     
      What do I want to do in
     
    </em>
    
     <em class="italic">
      
       this API?
      
     </em>
    
   </p>
   <p>
    
     By this, I mean the actions that the API will need to facilitate.
    
    
     For example, fetching todo items, updating todo items, deleting todo items, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     In understanding the
    
    <em class="italic">
     
      verbs
     
    </em>
    
     that are part of the actions of your API, we can identify the required HTTP methods.
    
    
     Consider the basic actions required for todo items.
    
    
     We will certainly want to
    
    <em class="italic">
     
      retrieve
     
    </em>
    
     todo items.
    
    
     That will require an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method.
    
    
     Moreover, we will also want to
    
    <em class="italic">
     
      create
     
    </em>
    
     a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     object.
    
    
     This will require an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method.
    
    
     Let’s start with the first example, retrieving some todo items, and then build up
    
    
     
      from there.
     
    
   </p>
   <h2 id="_idParaDest-58">
    <a id="_idTextAnchor086">
    </a>
    
     Getting todo items
    
   </h2>
   <p>
    
     If you’ve read through
    
    <a href="B20968_02.xhtml#_idTextAnchor033">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     , you
    
    <a id="_idIndexMarker092">
    </a>
    
     will have already seen examples of how an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method can be created as an endpoint in minimal APIs.
    
    
     For this project, we will first create an endpoint that simply retrieves the contents of
    
    <strong class="source-inline">
     
      List&lt;TodoItem&gt;
     
    </strong>
    
     , which we
    
    
     
      created previously.
     
    
   </p>
   <p>
    
     To achieve this, we need to
    
    <em class="italic">
     
      map
     
    </em>
    
     an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method onto the instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     on which our minimal API is running.
    
    
     There are several functions within
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     that achieve this.
    
    
     Each of them is prefixed with the word
    
    <strong class="source-inline">
     
      Map
     
    </strong>
    
     and followed by the relevant method verb.
    
    
     In this example, we’ll
    
    
     
      use
     
    
    
     <strong class="source-inline">
      
       MapGet()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoitems", () =&gt;
{
});</pre>
   <p>
    
     In this code, an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method has been mapped to the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route, meaning that should a user request the API’s base URL, followed by
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     , this endpoint would
    
    
     
      be reached.
     
    
   </p>
   <p>
    
     For example, if our URL is hosted at
    
    <a href="https://example.org/reallysimpletodoapi">
     
      https://example.org/reallysimpletodoapi
     
    </a>
    
     , accessing
    
    <a href="https://example.org/reallysimpletodoapi/todoitems">
     
      https://example.org/reallysimpletodoapi/todoitems
     
    </a>
    
     will reach
    
    
     
      this endpoint.
     
    
   </p>
   <p>
    
     Now we can get to the handling of the request, which happens in the function body.
    
    
     Notice that the endpoint we’ve created has a lambda expression after the route definition.
    
    
     The expression body is currently empty.
    
    
     It is within this expression body that we will handle the request by retrieving the requested data and responding to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     In this case, because we are simply returning the contents of the
    
    <strong class="source-inline">
     
      ToDoItems
     
    </strong>
    
     list, the data is readily available, but how do we get that data back to the client?
    
    
     ASP.NET provides us with a helper object in the form of
    
    <strong class="source-inline">
     
      IResult
     
    </strong>
    
     , whose
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     object exposes various methods for responding to requests.
    
    
     This takes care of the fundamental aspects of returning a response, such as the status code, response body, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     For this simple HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method, we can return an HTTP
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     response along with the requested data by simply returning the result of
    
    <strong class="source-inline">
     
      Results.OK(ToDoItems)
     
    </strong>
    
     .
    
    
     This function generates the relevant status code and takes an argument of type
    
    <strong class="source-inline">
     
      object
     
    </strong>
    
     , representing the data that should be returned to the client.
    
    
     Once added, the endpoint should look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoitems", () =&gt;
{
    return Results.Ok(ToDoItems);
});</pre>
   <p>
    
     So far, the focus has been on
    
    <a id="_idIndexMarker093">
    </a>
    
     routing requests into the API for the purposes of retrieving data.
    
    
     We will also need to create new data in the system; so, let us turn our attention to the creation of
    
    
     
      todo items.
     
    
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor087">
    </a>
    
     Creating Todo items
    
   </h2>
   <p>
    
     Let’s now look at
    
    <a id="_idIndexMarker094">
    </a>
    
     another critical operation for APIs: creating an entity.
    
    
     To create a new
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , we would use an HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     The mapping of an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method is similar to the code we’ve just written for mapping a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method.
    
    
     Once again, we use a method prefixed with the word
    
    <strong class="source-inline">
     
      Map
     
    </strong>
    
     .
    
    
     This method is
    
    <strong class="source-inline">
     
      MapPost()
     
    </strong>
    
     .
    
    
     However, there is a slight difference in the syntax compared to our
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method, as we now need to receive a data structure.
    
    
     In the case of creating a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , we will require the client to send an object of type
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , represented in JSON format on the client-side.
    
    
     ASP.NET will then take care of parsing the JSON into a strongly typed instance of
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , which we can use whilst handling
    
    
     
      the request.
     
    
   </p>
   <p>
    
     To allow the method to receive an object as part of the incoming request, we can take the parentheses at the beginning of the lambda expression within the endpoint’s body and add the object to it.
    
    
     For example, notice how the previous endpoint we created, which retrieves a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , has these
    
    
     
      empty parentheses:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoitems", () =&gt;</pre>
   <p>
    
     The handling of our minimal API endpoints is represented by a lambda expression.
    
    
     Lambda expressions open with an input in the form of parameters, which are passed in through these empty parentheses, as shown in the following code.
    
    
     This means that for our HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint, we can add a parameter of type
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      MapPost()
     
    </strong>
    
     method we are adding,
    
    
     
      like so:
     
    
   </p>
   <pre class="source-code">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
});</pre>
   <p>
    
     Now, we have an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint, sitting on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route, just like our HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint.
    
    
     The difference is that not only does it respond to a different HTTP verb, but it also requires the client to send a JSON payload mirroring the structure
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We don’t yet have anything inside the lambda expression within the endpoint, meaning that nothing will happen when a client sends a request.
    
    
     Let’s finally handle the request by adding the
    
    <a id="_idIndexMarker095">
    </a>
    
     incoming
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     to the list and then returning the
    
    
     
      relevant response:
     
    
   </p>
   <pre class="source-code">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    ToDoItems.Add(item);
    return Results.Created();
});</pre>
   <p>
    
     Just like in the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     example, we are using
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     to form a response and send it back to the client.
    
    
     However, we have opted for a slightly different response in this case.
    
    
     As the request is intended to create an entity, it is appropriate to return an
    
    <strong class="source-inline">
     
      HTTP 201 CREATED
     
    </strong>
    
     status code on successful creation, hence the use
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       Results.Created();
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor088">
    </a>
    
     Updating existing Todo items
    
   </h2>
   <p>
    
     When it comes to
    
    <a id="_idIndexMarker096">
    </a>
    
     updating a
    
    <strong class="source-inline">
     
      Todoitem
     
    </strong>
    
     , we have a couple of HTTP methods at our disposal.
    
    
     Let’s start with an HTTP
    
    
     <strong class="source-inline">
      
       PUT
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     An HTTP
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     requires the client to send a full copy of the entity being updated.
    
    
     It will then replace the entity with the copy.
    
    
     It is a
    
    <em class="italic">
     
      full update
     
    </em>
    
     .
    
    
     Therefore, we need to create an endpoint that receives a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     as part of the request, before finding the relevant item in our list and then replacing it with the incoming
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     .
    
    
     First, we’ll create an empty
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     endpoint sitting on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route that expects the item as an
    
    
     
      object parameter:
     
    
   </p>
   <pre class="source-code">
app.MapPut("/todoitems", (TodoItem item) =&gt;
{
});</pre>
   <p>
    
     Next, the request
    
    <a id="_idIndexMarker097">
    </a>
    
     should be handled by finding the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     that we intend to update.
    
    
     We can do this using a
    
    <strong class="bold">
     
      Language Integrated Query
     
    </strong>
    
     (
    
    <strong class="bold">
     
      LINQ
     
    </strong>
    
     ) query
    
    <a id="_idIndexMarker098">
    </a>
    
     to find the item by its unique ID,
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       FindIndex();
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     LINQ queries
    
   </p>
   <p class="callout">
    
     A LINQ query with lambda expressions in C# lets you easily search and manipulate data in collections such as lists.
    
    
     You start by defining your data source, then use methods such as
    
    <strong class="source-inline">
     
      Where
     
    </strong>
    
     to filter the data and
    
    <strong class="source-inline">
     
      Select
     
    </strong>
    
     ” to choose what you want from the data.
    
    
     Each method takes a lambda expression, which is a simple function that defines your criteria.
    
    
     In our example, we’re using a LINQ query to find the index of an item in a list that shares the same ID as a
    
    
     
      given item.
     
    
   </p>
   <p>
    
     Once found,
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     can be replaced with the
    
    
     
      incoming item:
     
    
   </p>
   <pre class="source-code">
app.MapPut("/todoitems", (TodoItem item) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == item.Id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index] = item;
    return Results.NoContent();
});</pre>
   <p>
    
     Notice how we did not return
    
    <strong class="source-inline">
     
      Results.OK
     
    </strong>
    
     again in this example.
    
    
     Because we’re simply updating a resource, the client is not expecting content to be returned; so, we indicate success by returning an
    
    <strong class="source-inline">
     
      HTTP 204 NO CONTENT
     
    </strong>
    
     status code
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       Results.NoContent();
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Updating
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     via HTTP
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     is handled slightly differently.
    
    
     Unlike
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     , we handle the request by once again finding the relevant item, but this time, we only change specific properties of the item, as dictated by the request parameters.
    
    
     This is usually used in scenarios where you want to create an endpoint on a route that is for a specific update.
    
    
     So, in this case, we will no longer create the endpoint on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route.
    
    
     Instead, we
    
    <a id="_idIndexMarker099">
    </a>
    
     will be specific about what we want to change by mapping the
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      /updateTodoItemDueDate
     
    </strong>
    
     route.
    
    
     In this example, we are creating an endpoint intended for a single purpose – to change the due date on the
    
    
     
      target
     
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapPatch("/updateTodoItemDueDate/{id}",
    (int id, DateTime newDueDate) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</pre>
   <p>
    
     The code looks like the
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     method we created, but you can see that the parameters are quite different.
    
    
     Instead of requiring the full
    
    <strong class="source-inline">
     
      ToDoItems
     
    </strong>
    
     object to be sent in by the client, we instead ask for two parameters, an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     parameter (to find the target item by ID) and a
    
    <strong class="source-inline">
     
      DateTime
     
    </strong>
    
     parameter containing the new due date.
    
    
     It is then possible to find the target item with another
    
    <a id="_idIndexMarker100">
    </a>
    
     LINQ query, and then only update its
    
    
     <strong class="source-inline">
      
       DueDate
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <p>
    
     So far, we’ve handled scenarios wherein we need to get all items, create an item, and update items.
    
    
     We will next look at scenarios in which we intend to get single items and delete items.
    
    
     However, to do this, we first need to explore the concept of
    
    
     
      route parameters.
     
    
   </p>
   <h1 id="_idParaDest-61">
    <a id="_idTextAnchor089">
    </a>
    
     Managing route parameters
    
   </h1>
   <p>
    <strong class="bold">
     
      Route parameters
     
    </strong>
    
     give us
    
    <a id="_idIndexMarker101">
    </a>
    
     the ability to capture values from the URL of an API endpoint.
    
    
     This is useful in many scenarios where we need to target specific entities, such as when requesting a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     by
    
    
     
      its ID.
     
    
   </p>
   <p>
    
     Route parameters are quite simple to add, and work using curly braces to define the parameters to be captured from
    
    
     
      the URL.
     
    
   </p>
   <p>
    
     Let’s use a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request
    
    <a id="_idIndexMarker102">
    </a>
    
     as an example.
    
    
     In this request, the client requests a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     with
    
    
     
      the ID:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoitems/{id}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    return Results.Ok(ToDoItems[index]);
});</pre>
   <p>
    
     Like the generic
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request we created to fetch all todo items, this endpoint is sitting on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route.
    
    
     However, it has an extra section appended to this route in the URL.
    
    
     The client is expected to also add an ID value as an extra URL section.
    
    
     This is shown by the presence of
    
    <strong class="source-inline">
     
      {id}
     
    </strong>
    
     in
    
    
     
      the route.
     
    
   </p>
   <p>
    
     This use of parameters within curly braces is how ASP.NET handles dynamic content in the route URL.
    
    
     Using a form of templating, it can replace the section of the URL where we added
    
    <strong class="source-inline">
     
      {id}
     
    </strong>
    
     with the value specified by
    
    
     
      the client.
     
    
   </p>
   <p>
    
     Another example of this can be seen in an HTTP
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     endpoint.
    
    
     Again, when deleting
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , we want to delete a specific item so we will once again need to pass in an ID for the target to be deleted.
    
    
     Let’s write the code for this in which we will map a new HTTP
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route.
    
    
     On the route, we’ll add a route parameter to pass
    
    <a id="_idIndexMarker103">
    </a>
    
     the ID for the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     to
    
    
     
      be deleted:
     
    
   </p>
   <pre class="source-code">
app.MapDelete("/todoitems/{id}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</pre>
   <p>
    
     On receiving a
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     request on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     route, if an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     has been appended to the URL, it will be stripped out and used within the request as a parameter.
    
    
     The subject of parameter data type is an important one.
    
    
     In the
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     example, we passed an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     as an ID parameter because that is the data type used on the ID property of the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     class (
    
    
     
      our model).
     
    
   </p>
   <p>
    
     What if someone sends a different data type as the parameter, such as a string?
    
    
     We would need to handle this of course, but we shouldn’t have to ensure that the incoming ID is an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     within the code.
    
    
     There is a better way of ensuring that the request only hits the route if the parameters being sent are of the
    
    <a id="_idIndexMarker104">
    </a>
    
     correct data type:
    
    <strong class="bold">
     
      route
     
    </strong>
    
     <strong class="bold">
      
       parameter constraints
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Adding a constraint to a route parameter makes it so that the incoming parameter must be formed in a particular way for the route to be found and the request received.
    
    
     In our
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     endpoint, we can use a parameter constraint to dictate that the parameter must be
    
    
     
      an integer.
     
    
   </p>
   <p>
    
     Adding a constraint to the
    
    <a id="_idIndexMarker105">
    </a>
    
     parameter is very simple.
    
    
     We just append a
    
    <strong class="source-inline">
     
      :
     
    </strong>
    
     character to the parameter, followed by the constraint.
    
    
     Let’s add a constraint to our
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     endpoint to ensure the route is only used when the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     parameter is of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       int
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapDelete("/todoitems/{id:int}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</pre>
   <p>
    
     Now that we have the constraint in place, if a request was received that could not be treated as an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     , the API would return a
    
    <strong class="source-inline">
     
      404 NOT FOUND
     
    </strong>
    
     response.
    
    
     It does this because the constraint stops ASP.NET from attempting to use the parameter as an ID, because it has already evaluated the data type thanks to the constraint.
    
    
     The result is that no other suitable route is found.
    
    
     (Unless there is a route on the
    
    <strong class="source-inline">
     
      /todoitems
     
    </strong>
    
     URL that can receive a string and is also an HTTP
    
    
     <strong class="source-inline">
      
       DELETE
      
     </strong>
    
    
     
      method.)
     
    
   </p>
   <p>
    
     Parameter constraints are not limited to data types.
    
    
     Parameters can be constrained by string length, numerical ranges, regex patterns; the list
    
    
     
      goes on.
     
    
   </p>
   <p>
    
     Let’s constrain the
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     range even further by adding a range constraint.
    
    
     We’ll make it so that the route can only delete the first 100 IDs.
    
    
     We can add multiple constraints to a single route
    
    
     
      like so:
     
    
   </p>
   <pre class="source-code">
app.MapDelete("/todoitems/{id:int:range(1,100)}",
    (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</pre>
   <p>
    
     By chaining another
    
    <a id="_idIndexMarker106">
    </a>
    
     constraint onto the existing one, we have now enforced that the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     parameter must be an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     and that its value must be between
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       100
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    <em class="italic">
     
      Table 4.1
     
    </em>
    
     shows some
    
    <a id="_idIndexMarker107">
    </a>
    
     other
    
    
     
      constraint examples:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Constraint Type
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Route Example
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Constraint Detail
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Length
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          /
         
        </strong>
        
         <strong class="source-inline">
          
           users/{username:length(3,20)}
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The username string must be between three and twenty
        
        
         
          characters long
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Length
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          /
         
        </strong>
        
         <strong class="source-inline">
          
           users/{username:length(8)}
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The username string must be exactly eight
        
        
         
          characters long
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Min Length
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          /
         
        </strong>
        
         <strong class="source-inline">
          
           users/{username:minlength(5)}
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The username string must be at least five
        
        
         
          characters long
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Max Length
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          /
         
        </strong>
        
         <strong class="source-inline">
          
           users/{username:maxlength(30)}
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The username string must be no more than thirty
        
        
         
          characters long
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Regular
        
        
         
          Expression
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          /
         
        </strong>
        
         <strong class="source-inline">
          
           addNewCreditCard/{cardNumber:regex(^3[47][0-9]{{13}}$)}
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The credit card number must conform to the pattern of an American Express
        
        
         
          card number
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 4.1: Examples of parameter constraints in minimal APIs
    
   </p>
   <p>
    
     Now that we are more
    
    <a id="_idIndexMarker108">
    </a>
    
     focused on how parameters are passed into our requests, we can focus our attention on the request body, in which we do the main handling of the request.
    
    
     A major part of handling any request is validation.
    
    
     Minimal APIs, like any other API, will receive data within requests, which must suit the conditions needed to handle the request.
    
    
     Let’s look at some validation techniques we can use to manage the request flow and handle any errors that may arise as a result of any violations of
    
    
     
      validation rules.
     
    
   </p>
   <h1 id="_idParaDest-62">
    <a id="_idTextAnchor090">
    </a>
    
     Request validation and error handling
    
   </h1>
   <p>
    
     There are several different methods of validation at our disposal.
    
    
     We’re going to look at two of them in this section:
    
    <strong class="bold">
     
      manual validation
     
    </strong>
    
     and
    
    <strong class="bold">
     
      data annotation
     
    </strong>
    
     and
    
    <strong class="bold">
     
      model
     
    </strong>
    
     <strong class="bold">
      
       binding validation
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor091">
    </a>
    
     Manual validation
    
   </h2>
   <p>
    
     This kind of validation is the
    
    <a id="_idIndexMarker109">
    </a>
    
     simplest, as you are writing code inside the route handler (the body of the lambda expression within an endpoint) that validates the request and decides on the
    
    
     
      appropriate response.
     
    
   </p>
   <p>
    
     We’ve already applied manual validation in some parts of the todo items API.
    
    
     For example, the
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method we created to update the due date on items first checks for the
    
    <strong class="source-inline">
     
      Todo
     
    </strong>
    
     item with the target ID.
    
    
     It
    
    <em class="italic">
     
      could
     
    </em>
    
     just assume that
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     exists in the list, but instead, we check first to see if it exists and then return a
    
    <strong class="source-inline">
     
      404 NOT FOUND
     
    </strong>
    
     status code if this is
    
    
     
      the case:
     
    
   </p>
   <pre class="source-code">
app.MapPatch("/updateTodoItemDueDate/{id}",
    (int id, DateTime newDueDate) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</pre>
   <p>
    
     By adding this
    
    <a id="_idIndexMarker110">
    </a>
    
     manual check, we are actively validating and handling an exceptional scenario.
    
    
     Having validation in an API endpoint is not just best practice, it is critical.
    
    
     Manual validation is the most basic form of validation.
    
    
     The problem is it relies on the intuition of a human; the developer writing the code.
    
    
     This is a subject of some debate because a lot of validation methods have gaps, but relying solely on manual validation can result in
    
    
     
      fragile APIs.
     
    
   </p>
   <p>
    
     To mitigate this, we can also adopt a more standardized framework for validation, one provided by ASP.NET: validation with
    
    
     
      data annotations.
     
    
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor092">
    </a>
    
     Validation with data annotations and model binding
    
   </h2>
   <p>
    
     As
    
    <a id="_idIndexMarker111">
    </a>
    
     demonstrated by the simple API example we’ve built in this chapter, models are an important aspect of minimal APIs.
    
    
     They allow us to
    
    <a id="_idIndexMarker112">
    </a>
    
     represent the entities that incoming requests retrieve, move, and transform.
    
    
     In the todo items API, we created a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     class as a model, and then stored the entities
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       List&lt;TodoItem&gt;
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     It is possible to validate a request’s data by the way it binds to specific models.
    
    
     For example, in the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     model, it is reasonable to expect that the
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     field should be populated when
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     
      is created.
     
    
   </p>
   <p>
    
     We can specify a field’s requirements by annotating it with an attribute.
    
    
     Attributes are handy pieces of metadata that allow us to apply constraints to code.
    
    
     One of the most common uses of attributes in this case is the
    
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       Required]
      
     </strong>
    
    
     
      attribute.
     
    
   </p>
   <p>
    
     The attributes we need are part of the
    
    
     <strong class="source-inline">
      
       System.ComponentModel.DataAnnotations
      
     </strong>
    
    
     
      namespace.
     
    
   </p>
   <p class="callout-heading">
    
     Required namespace for validation
    
   </p>
   <p class="callout">
    
     As in the
    
    <strong class="source-inline">
     
      Todo
     
    </strong>
    
     class,
    
    <strong class="source-inline">
     
      System.ComponentModel.DataAnnotations
     
    </strong>
    
     must also be added to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     for validation to
    
    
     
      be performed.
     
    
   </p>
   <p>
    
     Add this
    
    <a id="_idIndexMarker113">
    </a>
    
     namespace to the top of the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     class, followed
    
    <a id="_idIndexMarker114">
    </a>
    
     by the
    
    <strong class="source-inline">
     
      [Required]
     
    </strong>
    
     attribute above the
    
    
     <strong class="source-inline">
      
       Title
      
     </strong>
    
    
     
      field:
     
    
   </p>
   <pre class="source-code">
using System.ComponentModel.DataAnnotations;
namespace TodoApi
{
    public class TodoItem
    {
        public int Id { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime DueDate { get; set; }
        [Required]
        public string Title { get; set; }
        public string Description { get; set; }
        public string Assignee { get; set; }
        public int Priority { get; set; }
        public bool IsComplete { get; set; }
    }
}</pre>
   <p>
    
     Adding a
    
    <strong class="source-inline">
     
      [Required]
     
    </strong>
    
     attribute is not enough on its own to trigger validation.
    
    
     We still need to invoke validation within our requests.
    
    
     However, we can do this once within the request, and then all items requiring validation will be validated, according to the attributes we applied.
    
    
     Here’s how we can
    
    <a id="_idIndexMarker115">
    </a>
    
     invoke validation of our model from the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request we
    
    <a id="_idIndexMarker116">
    </a>
    
     
      created earlier:
     
    
   </p>
   <pre class="source-code">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    var validationResults = new List&lt;ValidationResult&gt;();
    var validationContext = new ValidationContext(item);
    bool isValid = Validator.TryValidateObject(
        item, validationContext, validationResults, true);
    if (!isValid)
    {
        return Results.BadRequest(validationResults);
    }
    ToDoItems.Add(item);
    return Results.Created();
});</pre>
   <p>
    
     In this example, we have initialized a new collection, a list of
    
    <strong class="source-inline">
     
      ValidationResult
     
    </strong>
    
     .
    
    
     This will contain information about the success or failure of validation.
    
    
     We will return this collection to the client if
    
    
     
      validation fails.
     
    
   </p>
   <p>
    
     We also create a new
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     , passing in the item that is to be validated.
    
    
     Because we want to validate the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     instance that is sent as a payload, we pass this
    
    
     
      into
     
    
    
     <strong class="source-inline">
      
       ValidationContext
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We can then invoke validation by calling
    
    <strong class="source-inline">
     
      Validator.TryValidateObject()
     
    </strong>
    
     , passing in the item as the validation target, the context we created that will be validated against, and the collection into which results will be saved, followed by a Boolean value of
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , to state that all properties should
    
    
     
      be validated.
     
    
   </p>
   <p>
    
     Now, when a
    
    <a id="_idIndexMarker117">
    </a>
    
     request is sent that omits a
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     field from the
    
    <a id="_idIndexMarker118">
    </a>
    
     payload, the following error JSON is automatically generated and sent back to
    
    
     
      the client:
     
    
   </p>
   <pre class="source-code">
[
    {
        "memberNames": [
            "Title"
        ],
        "errorMessage": "The Title field is required."
    }
]</pre>
   <p>
    
     This validation and error handling all happen automatically, thanks to the use of attributes and the
    
    
     
      built-in validator.
     
    
   </p>
   <p>
    
     The error message shown is automatically generated because of the
    
    <strong class="source-inline">
     
      [Required]
     
    </strong>
    
     attribute.
    
    
     This can be overridden by adding a parameter to
    
    
     
      the attribute.
     
    
   </p>
   <p>
    
     Here is the updated code on the
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     model, with a custom
    
    
     
      error message:
     
    
   </p>
   <pre class="source-code">
    public class TodoItem
    {
        public int Id { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime DueDate { get; set; }
        [Required(ErrorMessage =
            "You need to add a title my dude!")]
        public string Title { get; set; }
        public string Description { get; set; }
        public string Assignee { get; set; }
        public int Priority { get; set; }
        public bool IsComplete { get; set; }
    }</pre>
   <p>
    
     Now, we can see the custom error message in the generated error
    
    
     
      response JSON:
     
    
   </p>
   <pre class="source-code">
[
    {
        "memberNames": [
            "Title"
        ],
        "errorMessage": "You need to add a title my dude!"
    }
]</pre>
   <p>
    <strong class="source-inline">
     
      [Required]
     
    </strong>
    
     is
    
    <a id="_idIndexMarker119">
    </a>
    
     just one of many validation attributes that
    
    <a id="_idIndexMarker120">
    </a>
    
     data annotations have to offer.
    
    
     There are many other constraints you can add.
    
    
     Some examples of these include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       [EmailAddress]
      
     </strong>
     
      : This ensures the value conforms to the format of an
     
     
      
       email address.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       [AllowedValues]
      
     </strong>
     
      : This forces the use of
     
     
      
       specific values.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       [DeniedValues]
      
     </strong>
     
      : This is the opposite of
     
     <strong class="source-inline">
      
       [AllowedValues]
      
     </strong>
     
      , denying the use of
     
     
      
       specific values.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       [StringLength(x)]
      
     </strong>
     
      : This requires that a string value be of a
     
     
      
       certain length.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       [CreditCard]
      
     </strong>
     
      : The annotated value must be a valid credit
     
     
      
       card format.
      
     
    </li>
   </ul>
   <p>
    
     These are just a few of the many attributes that can be used to validate incoming responses, returning appropriate errors
    
    
     
      as needed.
     
    
   </p>
   <p>
    
     Managing
    
    <a id="_idIndexMarker121">
    </a>
    
     HTTP methods and handling requests are critical
    
    <a id="_idIndexMarker122">
    </a>
    
     aspects of minimal APIs, as it is in any
    
    
     
      API implementation.
     
    
   </p>
   <h3>
    
     Validation with filters
    
   </h3>
   <p>
    
     You can also apply more
    
    <a id="_idIndexMarker123">
    </a>
    
     specific validation rules with filters.
    
    <strong class="source-inline">
     
      IEndpointFilter
     
    </strong>
    
     is an interface that can be implemented to perform validation of the incoming request information before it hits the logic within
    
    
     
      an endpoint.
     
    
   </p>
   <p>
    
     There is a handy extension method,
    
    <strong class="source-inline">
     
      AddEndPointFilter&lt;T&gt;
     
    </strong>
    
     , which allows you to attach a class implementing
    
    <strong class="source-inline">
     
      IEndpointFilter
     
    </strong>
    
     to
    
    
     
      an endpoint.
     
    
   </p>
   <p>
    
     Let’s explore an example of this against a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint on our todo API.
    
    
     We’ll create a rule where a todo item cannot be assigned to anyone named
    
    
     
      Joe Bloggs:
     
    
   </p>
   <ol>
    <li>
     
      Create a class that implements
     
     <strong class="source-inline">
      
       IEndpointFilter
      
     </strong>
     
      .
     
     
      This class will be required to define a function called
     
     <strong class="source-inline">
      
       Invoke
      
     </strong>
     
      , returning
     
     <strong class="source-inline">
      
       ValueTask&lt;object?&gt;
      
     </strong>
     
      .
     
     
      The function takes
     
     <strong class="source-inline">
      
       EndPointFilterInvocationContext
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       EndpointFilterDelegate
      
     </strong>
     
      as parameters in order to carry out the
     
     
      
       validation logic:
      
     
     <pre class="source-code">
public class CreateTodoFilter : IEndpointFilter
{
    public async ValueTask&lt;object?&gt; InvokeAsync(
        EndpointFilterInvocationContext context,
        EndpointFilterDelegate next)
    {
    }
}</pre>
    </li>
    <li>
     <strong class="source-inline">
      
       EndPointFilterInvocationContext
      
     </strong>
     
      will contain the incoming
     
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
     
      , as it represents the context of the endpoint we are validating.
     
     
      Inside
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      , define logic to gain access to the incoming
     
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
     
      from the endpoint’s context and then validate that we are not attempting to assign it to Joe Bloggs.
     
     
      If we are, return the appropriate response so that
     
     
      
       validation
      
     
     
      <a id="_idIndexMarker124">
      </a>
     
     
      
       fails:
      
     
     <pre class="source-code">
  var todoItem = context.GetArgument&lt;TodoItem&gt;(0);
  if(todoItem.Assignee == "Joe Bloggs")
  {
      return Results.Problem(
          "Joe Bloggs cannot be assigned a todoitem");
  }</pre>
    </li>
    <li>
     
      Finally, for validation that passes, we want to pass the flow of execution back to the original endpoint (or any other chained logic attached to it, a bit like we do for a middleware pipeline).
     
     
      Do this by returning a call to
     
     <strong class="source-inline">
      
       EndpointFilterDelegate
      
     </strong>
     
      , which we received as a parameter, passing in the
     
     
      
       endpoint context:
      
     
     <pre class="source-code">
return await next(context);</pre>
    </li>
    <li>
     
      Finally, add the filter validation to the endpoint
     
     
      
       as shown:
      
     
     <pre class="source-code">
      app.MapPost("/todoitems", (TodoItem item) =&gt;
      {
          ToDoItems.Add(item);
          return Results.Created();
      }).AddEndpointFilter&lt;CreateTodoFilter&gt;();</pre>
    </li>
    <li>
     
      Alternatively, if you want to define the endpoint filter inline, you can do so by passing in an
     
     <a id="_idIndexMarker125">
     </a>
     
      anonymous function instead of a type
     
     
      
       after
      
     
     
      <strong class="source-inline">
       
        AddEndpointFilter
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
    app.MapPost("/todoitems", (TodoItem item) =&gt;
    {
        ToDoItems.Add(item);
        return Results.Created();
    }).AddEndpointFilter(async (context, next) =&gt;
    {
        var toDoItem =
            context.GetArgument&lt;TodoItem&gt;(0);
        if (toDoItem.Assignee == "Joe Bloggs")
        {
            return Results.Problem(
                "Joe Bloggs cannot be assigned todo
                items");
        }
        return await next(context);
    });</pre>
    </li>
   </ol>
   <p>
    
     Now that you’ve gained some insight into the various ways we can achieve validation for different API endpoints, let’s recap the things we’ve learned in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor093">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we took a high-level view of HTTP methods and how they are handled.
    
    
     We explored in further detail the way in which requests can be routed, allowing essential parameters to be lifted out of route definitions with
    
    
     
      routing parameters.
     
    
   </p>
   <p>
    
     We also delved into the basics of validation, firstly by placing constraints on our API routes to ensure that the data received is formatted in an appropriate manner.
    
    
     Following this, we learned how to handle validation in different ways, including manual validation, and the use of data annotations in models to invoke validation in a centralized fashion within the
    
    
     
      endpoint body.
     
    
   </p>
   <p>
    
     Throughout the chapter, we saw examples of how errors can be captured through validation techniques, and how informative error responses should be handed back to clients to inform their
    
    
     
      debugging strategies.
     
    
   </p>
   <p>
    
     By now, you should be capable of putting together a basic yet functional minimal API project.
    
    
     In the next chapter, we will learn how to introduce custom functionalities to our application pipelines in the form
    
    
     
      of middleware.
     
    
   </p>
  </div>
 </body></html>