<html><head></head><body>
<div id="_idContainer090">
<h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.2.1">Tracing Your Code</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we talked about instrumentation libraries and learned how to use auto-collected telemetry to monitor and debug distributed systems. </span><span class="koboSpan" id="kobo.3.2">Auto-instrumentations, when available, provide necessary and reasonable coverage for network calls, but you may want to trace additional logical operations, I/Os, sockets, or other calls that don’t have shared </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">instrumentation available.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter provides an in-depth guide to manual tracing using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">System.Diagnostics</span></strong><span class="koboSpan" id="kobo.7.1"> primitives or the OpenTelemetry API and explains the mechanism behind auto-instrumentation. </span><span class="koboSpan" id="kobo.7.2">We will cover the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">Activity</span></strong><span class="koboSpan" id="kobo.9.1"> properties and how to populate them and show you how to record events. </span><span class="koboSpan" id="kobo.9.2">We’ll then learn how to use links to represent complex relationships between spans. </span><span class="koboSpan" id="kobo.9.3">Finally, we’ll cover the testing aspects </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">You’ll learn how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Create activities using the .NET API or with the OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">API shim</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Use ambient context propagation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.17.1"> and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">its limitations</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">ActivityEvent</span></strong><span class="koboSpan" id="kobo.21.1"> and understand when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">logs instead</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Represent complex relationships between traces </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">with links</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Validate </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">your instrumentations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.27.1">By the end of this chapter, you should be able to cover your application needs with </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">manual tracing.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">The code for this chapter can be found in this book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter6"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">We’ll need the following tools </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">for it:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">or newer</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Visual Studio or Visual Studio Code with C# development setup is recommended, but any text editor </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">will work</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.40.1">Docker</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">If you want to explore traces from sample applications in Jaeger, you can run it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.43.1">
$ docker run -d --name jaeger -p 6831:6831/udp -p
  16686:16686 jaegertracing/all-in-one:latest</span></pre>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.44.1">Tracing with System.Diagnostics or the OpenTelemetry API shim</span></h1>
<p><span class="koboSpan" id="kobo.45.1">As we saw in the previous</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.46.1"> chapters, distributed tracing in .NET</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.47.1"> relies on primitives in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">System.Diagnostics</span></strong><span class="koboSpan" id="kobo.49.1"> namespace: </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">Activity</span></strong><span class="koboSpan" id="kobo.51.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">They’re used by HTTP Client and ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Core instrumentations.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The terminology used by .NET and OpenTelemetry is different: </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">Activity</span></strong><span class="koboSpan" id="kobo.57.1"> represents the OpenTelemetry span, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.59.1"> maps to the tracer, and tags map </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">to attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">OpenTelemetry.Api</span></strong><span class="koboSpan" id="kobo.63.1"> NuGet package also provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">TelemetrySpan</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">Tracer</span></strong><span class="koboSpan" id="kobo.67.1">, and several more auxiliary classes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">OpenTelemetry.Trace</span></strong><span class="koboSpan" id="kobo.69.1"> namespace. </span><span class="koboSpan" id="kobo.69.2">These APIs are a </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">shim</span></strong><span class="koboSpan" id="kobo.71.1"> over .NET tracing APIs – a thin wrapper that does not provide any additional functionality on top of .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">tracing APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">You are probably wondering which one you should use. </span><span class="koboSpan" id="kobo.73.2">The rule of thumb is to use .NET APIs unless you want to stick to OpenTelemetry terminology. </span><span class="koboSpan" id="kobo.73.3">Shim</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.74.1"> is just an additional layer, which brings</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.75.1"> a small </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">performance overhead.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.77.1">Tracing with System.Diagnostics</span></h2>
<p><span class="koboSpan" id="kobo.78.1">Let’s say we want to instrument</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.79.1"> an operation – for example, a method that processes a work item. </span><span class="koboSpan" id="kobo.79.2">It might break down into smaller, potentially auto-instrumented operations such as HTTP requests. </span><span class="koboSpan" id="kobo.79.3">In this case, spans describing individual requests won’t show us the overall duration and result of processing, so we need to create a new logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">Activity</span></strong><span class="koboSpan" id="kobo.81.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">describe it.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Activities</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.84.1"> should be created from </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.86.1">, which notifies OpenTelemetry and other potential listeners about them. </span><span class="koboSpan" id="kobo.86.2">Using this approach, we can instrument our work processing operation with the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.88.1">Worker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
private static readonly ActivitySource Source =
  new ("Worker");
...
</span><span class="koboSpan" id="kobo.89.2">using var activity = Source.StartActivity("DoWork");
activity?.SetTag("work_item.id", workItemId);
try
{
  await DoWorkImpl(workItemId);
}
catch (Exception ex)
{
  activity?.SetStatus(ActivityStatusCode.Error,
    ex.Message);
  throw;
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs"><span class="koboSpan" id="kobo.90.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs</span></a></p>
<p><span class="koboSpan" id="kobo.91.1">In this example, the actual processing happens in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">DoWorkImpl</span></strong><span class="koboSpan" id="kobo.93.1"> method. </span><span class="koboSpan" id="kobo.93.2">We created a new activity before calling into this method and implicitly ended it. </span><span class="koboSpan" id="kobo.93.3">If the method throws an exception, we set the status of the activity to </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Error</span></strong><span class="koboSpan" id="kobo.95.1"> while providing an exception message in the description. </span><span class="koboSpan" id="kobo.95.2">The activity is disposed of (and ended) when control leaves the scope, but we could also call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">Activity.Stop</span></strong><span class="koboSpan" id="kobo.97.1"> method to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">it explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">We created </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.101.1"> as a static singleton here since we’re assuming we need it for the application’s lifetime. </span><span class="koboSpan" id="kobo.101.2">If you decide to make it an instance variable and tie its lifetime to some long-living client or service in your application, make sure to dispose </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">The only thing we configured</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.104.1"> in this example is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Activity</span></strong><span class="koboSpan" id="kobo.106.1"> name – we passed </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">DoWork</span></strong><span class="koboSpan" id="kobo.108.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">ActivitySource.StartActivity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1"> method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.112.1">The activity returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">ActivitySource.StartActivity</span></strong><span class="koboSpan" id="kobo.114.1"> is nullable. </span><span class="koboSpan" id="kobo.114.2">It can be null if there are no listeners for this source, or if the listener sampled out this activity in a specific way by </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">returning </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">ActivitySamplingResult.None</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">We’ll learn more about APIs in a moment, but first, let’s learn how to export </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">generated activities.</span></span></p>
<h3><span class="koboSpan" id="kobo.120.1">Exporting activities with OpenTelemetry</span></h3>
<p><span class="koboSpan" id="kobo.121.1">So far, we have</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.122.1"> used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">OpenTelemetry.Extensions.Hosting</span></strong><span class="koboSpan" id="kobo.124.1"> NuGet package</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.125.1"> to configure OpenTelemetry in ASP.NET Core applications. </span><span class="koboSpan" id="kobo.125.2">Here, we’re going to use plain OpenTelemetry SDK configuration, which still looks quite similar to what we saw in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.126.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.127.1">, </span><em class="italic"><span class="koboSpan" id="kobo.128.1">Configuration and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Control Plane</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.131.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
using var provider = Sdk.CreateTracerProviderBuilder()
  .ConfigureResource(b =&gt; b.AddService("activity-sample"))
</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">  .AddSource("Worker")</span></strong><span class="koboSpan" id="kobo.134.1">
  .AddJaegerExporter()
  .AddConsoleExporter()
  .Build()!;</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs"><span class="koboSpan" id="kobo.135.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.136.1">In this example, we’re building the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">TracerProvider</span></strong><span class="koboSpan" id="kobo.138.1"> instance by setting the service name to </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">activity-sample</span></strong><span class="koboSpan" id="kobo.140.1"> and enabling </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.142.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Worker</span></strong><span class="koboSpan" id="kobo.144.1"> – the one we used to create the activity in the previous example. </span><span class="koboSpan" id="kobo.144.2">We are also using the console exporter along with Jaeger – spans will be exported </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">to both.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">OpenTelemetry needs</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.147.1"> explicit configuration</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.148.1"> to listen to </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.150.1">, but you can enable a group of them with wildcards, as we saw in </span><a href="B19423_03.xhtml#_idTextAnchor052"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.151.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.152.1">,</span><em class="italic"><span class="koboSpan" id="kobo.153.1"> The .NET </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.154.1">Observability Ecosystem</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Let’s run these examples using the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.158.1">
tracing-with-net$ dotnet run open-telemetry –scenario basic</span></pre>
<p><span class="koboSpan" id="kobo.159.1">We should see </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Activity</span></strong><span class="koboSpan" id="kobo.161.1"> exported to </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the console:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.163.1">Activity.TraceId:         9c45e1b454e28bf1edbba296c3315c51</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.164.1">Activity.SpanId:          bcd47a4fc7d92063</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.165.1">Activity.TraceFlags:         Recorded</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.166.1">Activity.ActivitySourceName: Worker</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.167.1">Activity.DisplayName:        </span></strong><strong class="bold"><span class="koboSpan" id="kobo.168.1">DoWork</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.169.1">Activity.Kind:               Internal</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.170.1">Activity.StartTime:          2022-12-07T23:10:49.1998081Z</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.171.1">Activity.Duration:           00:00:00.1163745</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.172.1">Resource associated with Activity:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.173.1">    service.name: activity-sample</span></strong></pre>
<p><span class="koboSpan" id="kobo.174.1">When we configure OpenTelemetry to listen to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Worker</span></strong><span class="koboSpan" id="kobo.176.1"> source, it leverages the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">System.Diagnostics.ActivityListener</span></strong><span class="koboSpan" id="kobo.178.1"> primitive. </span><span class="koboSpan" id="kobo.178.2">If you use OpenTelemetry, you probably</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.179.1"> won’t need to use the listener</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.180.1"> directly, but you may still find it useful for testing purposes or when debugging instrumentation issues. </span><span class="koboSpan" id="kobo.180.2">Let’s see how </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">it works.</span></span></p>
<h3><span class="koboSpan" id="kobo.182.1">Listening to activities with ActivityListener</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">ActivityListener</span></strong><span class="koboSpan" id="kobo.184.1"> allows us to subscribe</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.185.1"> to any </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.187.1"> instance using its name and get notifications when activities created by one of the enabled sources start or end. </span><span class="koboSpan" id="kobo.187.2">The following example shows how to write </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">a listener:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
ActivitySource.AddActivityListener(new ActivityListener()
{
  ActivityStopped = PrintActivity
  ShouldListenTo = source =&gt; source.Name == "Worker",
  Sample = (ref ActivityCreationOptions&lt;ActivityContext&gt; _)
    =&gt; ActivitySamplingResult.AllDataAndRecorded
});</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs"><span class="koboSpan" id="kobo.191.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.192.1">Here, we’re subscribing to </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.194.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Worker</span></strong><span class="koboSpan" id="kobo.196.1"> and specifying that we sample in all activities. </span><span class="koboSpan" id="kobo.196.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Activity</span></strong><span class="koboSpan" id="kobo.198.1"> ends, we call our </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">PrintActivity</span></strong><span class="koboSpan" id="kobo.200.1"> method. </span><span class="koboSpan" id="kobo.200.2">We could also provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">ActivityStarted</span></strong><span class="koboSpan" id="kobo.202.1"> callback </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">when needed.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">So, let’s go ahead and run this sample with </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.206.1">
tracing-with-net$ dotnet run activity-listener</span></pre>
<p><span class="koboSpan" id="kobo.207.1">You should</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.208.1"> see something </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.210.1">DoWork: Id = 00-7720a4aca8472f92c36079b0bee3afd9-</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.211.1">0d0c62b5cfb15876-01, Duration=110.3466, Status = Unset</span></strong></pre>
<p><span class="koboSpan" id="kobo.212.1">Now that you know how OpenTelemetry and </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.214.1"> work together, it’s time to explore other </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">tracing APIs.</span></span></p>
<h3><span class="koboSpan" id="kobo.216.1">Starting activities</span></h3>
<p><span class="koboSpan" id="kobo.217.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.219.1"> class</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.220.1"> defines</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.221.1"> several </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">CreateActivity</span></strong><span class="koboSpan" id="kobo.223.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">StartActivity</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.225.1">method</span></span><span class="No-Break"><a id="_idIndexMarker362"/></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1"> overloads.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Calling into </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">StartActivity</span></strong><span class="koboSpan" id="kobo.229.1"> is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">CreateActivity</span></strong><span class="koboSpan" id="kobo.231.1"> and then starting it later with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Activity.Start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
Source.CreateActivity("foo", ActivityKind.Client)?.Start()</span></pre>
<p><span class="koboSpan" id="kobo.235.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Start</span></strong><span class="koboSpan" id="kobo.237.1"> methods generate a new span ID, capture the start time, and populate the ambient context via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.239.1"> property. </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Activity</span></strong><span class="koboSpan" id="kobo.241.1"> can’t be used until it’s started. </span><span class="koboSpan" id="kobo.241.2">So, in most cases, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">StartActivity</span></strong><span class="koboSpan" id="kobo.243.1"> method is the easiest choice and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">CreateActivity</span></strong><span class="koboSpan" id="kobo.245.1"> might only be useful if you want to construct an activity instance but start </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">it later.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.247.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.248.1">Sampling callback happens during activity creation, so you must pass all properties that affect the sampling decision to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">StartActivity</span></strong><span class="koboSpan" id="kobo.250.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">CreateActivity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Here are the start </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">time properties:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Activity kind enumeration</span></strong><span class="koboSpan" id="kobo.256.1">: This is the same as the OpenTelemetry span</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.257.1"> kind. </span><span class="koboSpan" id="kobo.257.2">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Internal</span></strong><span class="koboSpan" id="kobo.259.1">, indicating local or logical operation. </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Client</span></strong><span class="koboSpan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Server</span></strong><span class="koboSpan" id="kobo.263.1"> spans describe the client and server side of synchronous remote calls such as HTTP requests. </span><span class="koboSpan" id="kobo.263.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Producer</span></strong><span class="koboSpan" id="kobo.265.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Consumer</span></strong><span class="koboSpan" id="kobo.267.1"> spans describe corresponding sides of asynchronous operations, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">asynchronous messaging.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.269.1">Observability backends rely on span kinds for visualizations such as service maps and semi-automated </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">performance analysis.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.271.1">Parent</span></strong><span class="koboSpan" id="kobo.272.1">: When instrumenting server or consumer</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.273.1"> calls, we extract parent trace context from headers into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.275.1"> struct. </span><span class="koboSpan" id="kobo.275.2">This is usually based on the W3C Trace Context standard for HTTP and might be different for other protocols. </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.277.1"> contains the trace ID, span ID, trace flags, and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">trace state.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.279.1">Another option is to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">traceparent</span></strong><span class="koboSpan" id="kobo.281.1"> value in W3C Trace Context format to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">StartActivity</span></strong><span class="koboSpan" id="kobo.283.1"> method as a string. </span><span class="koboSpan" id="kobo.283.2">You can set </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">tracestate</span></strong><span class="koboSpan" id="kobo.285.1"> later after the activity starts, but then, of course, you won’t be able to use it to make </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">sampling decisions.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">If the parent context is not provided, </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Activity.Current</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.289.1">is used.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">Tags</span></strong><span class="koboSpan" id="kobo.291.1">: These are the attributes that are available</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.292.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Activity</span></strong><span class="koboSpan" id="kobo.294.1"> starts and should affect sampling decisions. </span><span class="koboSpan" id="kobo.294.2">If you don’t use attributes to make head-based sampling decisions, it’s best not to populate them and minimize the performance overhead for </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">sampled-out activities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">Links</span></strong><span class="koboSpan" id="kobo.297.1">: Links can correlate different traces</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.298.1"> and represent relationships between spans other than parent-child ones. </span><span class="koboSpan" id="kobo.298.2">We’ll learn more about them later in </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">this chapter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.300.1">Start time</span></strong><span class="koboSpan" id="kobo.301.1">: In some cases, we need to trace operations</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.302.1"> that happened in the past – for example, if we receive an event stating that something has ended and we want to convert it into an activity. </span><span class="koboSpan" id="kobo.302.2">Here, we can just fake the start time for this activity. </span><span class="koboSpan" id="kobo.302.3">We can also update it after </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Activity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> starts.</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Activity</span></strong><span class="koboSpan" id="kobo.306.1"> also supports custom trace context formats – for example, legacy </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">hierarchical ones.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">After </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Activity</span></strong><span class="koboSpan" id="kobo.310.1"> starts, we can always add more attributes, change the start and end times, update the sampling decision, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">tracestate</span></strong><span class="koboSpan" id="kobo.312.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">record events.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Before adding new events or attribute, make sure to check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">IsAllDataRequested</span></strong><span class="koboSpan" id="kobo.316.1"> flag, which specifies whether the activity has been sampled. </span><span class="koboSpan" id="kobo.316.2">We can use it to minimize the performance impact of the instrumentation by guarding any </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">expensive operations:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">StartSamples.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
if (activity?.IsAllDataRequested == true)
    activity?.SetTag("foo", GetValue());</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs</span></p>
<p><span class="koboSpan" id="kobo.321.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Activity</span></strong><span class="koboSpan" id="kobo.323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.325.1"> APIs are the foundation</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.326.1"> for any instrumentation. </span><span class="koboSpan" id="kobo.326.2">We’ll cover additional APIs allowing to populate events and links later in this chapter and see more examples throughout the rest of this book. </span><span class="koboSpan" id="kobo.326.3">For now, let’s take a quick look at how we can use the OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">API shim.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.328.1">Tracing with the OpenTelemetry API shim</span></h2>
<p><span class="koboSpan" id="kobo.329.1">The OpenTelemetry API shim</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.330.1"> does not provide any additional features on top of .NET APIs; it only aligns terminology with OpenTelemetry. </span><span class="koboSpan" id="kobo.330.2">If you use OpenTelemetry in other languages, then it might be more appealing to you. </span><span class="koboSpan" id="kobo.330.3">If you decide to go down this path, keep in mind that the behavior of </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Tracer</span></strong><span class="koboSpan" id="kobo.332.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Span</span></strong><span class="koboSpan" id="kobo.334.1"> matches </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Activity</span></strong><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">For example, this means that you still have to enable each tracer when </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">configuring OpenTelemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Let’s repeat our processing instrumentation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Tracer</span></strong><span class="koboSpan" id="kobo.342.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">TelemetrySpan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> classes:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Worker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
private static readonly Tracer Tracer = TracerProvider
  .Default.GetTracer("Worker");
...
</span><span class="koboSpan" id="kobo.346.2">using var workSpan = Tracer.StartActiveSpan("DoWork"));
  workSpan.SetAttribute("work_item.id", workItemId);
  try
  {
    await DoWorkImpl(workItemId);
  }
  catch (Exception ex)
  {
    workSpan.SetStatus(Status.Error.WithDescription(
      ex.Message));
    throw;
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-shim/Worker.cs"><span class="koboSpan" id="kobo.347.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-shim/Worker.cs</span></a></p>
<p><span class="koboSpan" id="kobo.348.1">The overall flow is the same: we create</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.349.1"> an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Tracer</span></strong><span class="koboSpan" id="kobo.351.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.353.1">, then use it to create a span. </span><span class="koboSpan" id="kobo.353.2">Adding attributes and setting the status is done similarly to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">ActivitySource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> example.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">If we were to look under the hood of </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Tracer</span></strong><span class="koboSpan" id="kobo.358.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">TelemetrySpan</span></strong><span class="koboSpan" id="kobo.360.1">, we’d see that they fully rely on </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.362.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Activity</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">As a result, enabling this instrumentation and enriching and customizing it is the same as enabling an </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.366.1">-based one – it’s done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">AddSource</span></strong><span class="koboSpan" id="kobo.368.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">TracerProviderBuilder</span></strong><span class="koboSpan" id="kobo.370.1"> (the source name matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">tracer name).</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Even though the APIs look similar, there are a few </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">important differences:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.374.1">Spans are not nullable. </span><span class="koboSpan" id="kobo.374.2">You always get an instance of a span, even if there is no listener to the underlying </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.376.1"> (but then it’s an optimized, </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">inoperative instance).</span></span></li>
<li><span class="koboSpan" id="kobo.378.1">All operations on spans are internally guarded with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">TelemetrySpan.IsRecording</span></strong><span class="koboSpan" id="kobo.380.1"> flag, which is equivalent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">activity?.IsAllDataRequested == true</span></strong><span class="koboSpan" id="kobo.382.1"> check. </span><span class="koboSpan" id="kobo.382.2">However, it could still be useful to guard expensive operations to calculate attribute values and other span properties behind the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">IsRecording</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> flag.</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">Spans are not active (that is, current) by default. </span><span class="koboSpan" id="kobo.385.2">While you can’t start an activity without making it current, that’s not the case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">TelemetrySpan</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">You probably noticed that we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Tracer.StartActiveSpan</span></strong><span class="koboSpan" id="kobo.389.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">DoWork</span></strong><span class="koboSpan" id="kobo.391.1"> span, which </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">populates </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Activity.Current</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">If we were to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Tracer.StartSpan</span></strong><span class="koboSpan" id="kobo.397.1"> method, we’d get a started activity, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.399.1"> would not point to it. </span><span class="koboSpan" id="kobo.399.2">To make it current, we could call into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Tracer.WithSpan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">If we run the previous OpenTelemetry API example with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">tracing-with-otel-api$ dotnet run</span></strong><span class="koboSpan" id="kobo.404.1"> command, we’ll see the same trace</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.405.1"> as before with plain .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">tracing APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Now, let’s see how we can create hierarchies of activities and enrich them using </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">ambient context.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.409.1">Using ambient context</span></h1>
<p><span class="koboSpan" id="kobo.410.1">In complex applications, we usually have multiple layers</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.411.1"> of spans in each trace. </span><span class="koboSpan" id="kobo.411.2">These spans are emitted by different libraries that are not aware of each other. </span><span class="koboSpan" id="kobo.411.3">Still, they are correlated because of the ambient context propagated in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">Activity.Current</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Let’s create two layers of activities – we’ll make processing more resilient by retrying failed operations and instrumenting tries and the logical </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">DoWork</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1"> operation:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.417.1">Worker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
public static async Task DoWork(int workItemId) {
  using var workActivity = Source.StartActivity();
  workActivity?.AddTag("work_item.id",  workItemId);
  await DoWithRetry(async tryCount =&gt; {
    using var tryActivity = Source.StartActivity("Try");
    try
    {
      await DoWorkImpl(work.Id, tryCount);
      tryActivity?.SetTag("try_count", tryCount);
    }
    catch (Exception ex)
    {
      tryActivity?.RecordException(ex);
      tryActivity?.SetStatus(ActivityStatusCode.Error);
      throw;
    }
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.419.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs</span></p>
<p><span class="koboSpan" id="kobo.420.1">In this example, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">workActivity</span></strong><span class="koboSpan" id="kobo.422.1">, which describes the logical</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.423.1"> operation, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">tryActivity</span></strong><span class="koboSpan" id="kobo.425.1">, which describes a try. </span><span class="koboSpan" id="kobo.425.2">Let’s run it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.427.1">
tracing-with-net$ dotnet run open-telemetry –scenario with-
retries</span></pre>
<p><span class="koboSpan" id="kobo.428.1">Check out the trace in Jaeger at </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">http://localhost:16686</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">You should see something similar to the trace shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.431.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.434.1"><img alt="Figure 6.1 – Work item processing" src="image/B19423_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.435.1">Figure 6.1 – Work item processing</span></p>
<p><span class="koboSpan" id="kobo.436.1">Here, we can see that there were two attempts</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.437.1"> to process a work item – the first one failed with an exception and then the operation succeeded after the second try. </span><span class="koboSpan" id="kobo.437.2">By looking at this trace, it’s clear why the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">DoWork</span></strong><span class="koboSpan" id="kobo.439.1"> operation took this much time – it was spent </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">between tries.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Note that we didn’t do anything special to correlate </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">workActivity</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">tryActivity</span></strong><span class="koboSpan" id="kobo.445.1">. </span><span class="koboSpan" id="kobo.445.2">This happened because </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">workActivity</span></strong><span class="koboSpan" id="kobo.447.1"> was current when </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">tryActivity</span></strong><span class="koboSpan" id="kobo.449.1"> started – since we didn’t provide any parent, it defaulted to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Activity.Current</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">To troubleshoot instrumentation issues, we can always check the parent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Activity</span></strong><span class="koboSpan" id="kobo.454.1"> on the started activity by looking at its properties. </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Activity.Parent</span></strong><span class="koboSpan" id="kobo.456.1"> represents an implicit parent. </span><span class="koboSpan" id="kobo.456.2">When we start an activity, we can also provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">traceparent</span></strong><span class="koboSpan" id="kobo.458.1"> as a string or a parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.460.1"> explicitly – in these cases, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Parent</span></strong><span class="koboSpan" id="kobo.462.1"> property will be null. </span><span class="koboSpan" id="kobo.462.2">You can find some examples of this at </span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs"><span class="koboSpan" id="kobo.463.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs</span></a><span class="koboSpan" id="kobo.464.1"> and we’ll see more examples of context propagation in </span><a href="B19423_10.xhtml#_idTextAnchor161"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.466.1">, Tracing </span><em class="italic"><span class="koboSpan" id="kobo.467.1">Network Calls</span></em><span class="koboSpan" id="kobo.468.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Activity.ParentId</span></strong><span class="koboSpan" id="kobo.470.1"> is the equivalent of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">traceparent</span></strong><span class="koboSpan" id="kobo.472.1"> header and </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Activity.ParentSpanId</span></strong><span class="koboSpan" id="kobo.474.1"> represents the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">span-id</span></strong><span class="koboSpan" id="kobo.476.1"> portion of it. </span><span class="koboSpan" id="kobo.476.2">These properties are populated if </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Activity</span></strong><span class="koboSpan" id="kobo.478.1"> has any parent </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">Getting back to our example, what happens if all the tries fail? </span><span class="koboSpan" id="kobo.480.2">Should we set an error on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">DoWork</span></strong><span class="koboSpan" id="kobo.482.1"> activity? </span><span class="koboSpan" id="kobo.482.2">Well, we can do this inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">DoWithRetry</span></strong><span class="koboSpan" id="kobo.484.1"> method with </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Activity.Current?.SetStatus(ActivityStatusCode.Error)</span></strong><span class="koboSpan" id="kobo.486.1">. </span><span class="koboSpan" id="kobo.486.2">We can use the current activity here because we control when and how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">DoWithRetry</span></strong><span class="koboSpan" id="kobo.488.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">As a rule of thumb, avoid adding attributes, events, or setting a status on </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.492.1"> unless you know for sure it’s the right one. </span><span class="koboSpan" id="kobo.492.2">With suppression, filtering, or some new activities created in between, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">Current</span></strong><span class="koboSpan" id="kobo.494.1"> can point to some other activity. </span><span class="koboSpan" id="kobo.494.2">So, make sure to pass instances of activities within your </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">instrumentations explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">If you want to enrich an auto-collected </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Activity</span></strong><span class="koboSpan" id="kobo.498.1">, accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Current</span></strong><span class="koboSpan" id="kobo.500.1"> property in one of the enrichment callbacks provided when enabling instrumentation should </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">be safe.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">Some instrumentations may also provide access to the created </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Activity</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">For example, ASP.NET Core does so with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">IHttpActivityFeature</span></strong><span class="koboSpan" id="kobo.506.1"> interface. </span><span class="koboSpan" id="kobo.506.2">It’s also possible to walk up the activity tree using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Parent</span></strong><span class="koboSpan" id="kobo.508.1"> property to find the one you want to enrich. </span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.510.1"> works on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.512.1">, so the .NET runtime propagates it through asynchronous calls. </span><span class="koboSpan" id="kobo.512.2">This does not work with background</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.513.1"> processing or manual manipulations with threads, but you can always pass activities explicitly and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.515.1"> value manually </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">Now, we know how to create hierarchies of activities and use attributes to describe our scenarios. </span><span class="koboSpan" id="kobo.517.2">But sometimes, we need something more lightweight, such as events – let’s take a closer look </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">at them.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.519.1">Recording events</span></h1>
<p><span class="koboSpan" id="kobo.520.1">Spans</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.521.1"> describe operations</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.522.1"> that have a duration and a result, but sometimes, creating a span could be too verbose and expensive – for example, for busy socket-level communication. </span><span class="koboSpan" id="kobo.522.2">Common use cases for events include recording exceptions or individual messages in gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">streaming calls.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">To represent something that happened at a certain point in time, we should use events or logs. </span><span class="koboSpan" id="kobo.524.2">In OpenTelemetry, the difference between logs and events is semantical – it’s the same data structure with the same over-the-wire format but different attributes. </span><span class="koboSpan" id="kobo.524.3">For example, logs have mandatory severity, which does not apply to events. </span><span class="koboSpan" id="kobo.524.4">Events, on the other hand, have </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">mandatory names.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">They are also different in terms of their API and implementation (at least with .NET 7.0 and prior versions). </span><span class="koboSpan" id="kobo.526.2">In this section, we will explore Activity’s events API; we will look at logs in </span><a href="B19423_08.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.527.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.528.1">, </span><em class="italic"><span class="koboSpan" id="kobo.529.1">Writing Structured and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.530.1">Correlated Logs</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.532.1">When to use events</span></h2>
<p><span class="koboSpan" id="kobo.533.1">To create an activity event, we need an instance</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.534.1"> of an activity, which is not the case, for example, at </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">startup time.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">Activity events depend on sampling – we can add them to a sampled-out </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Activity</span></strong><span class="koboSpan" id="kobo.538.1">, but in general, they’ll be dropped along </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">An event’s lifetime is tightly coupled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Activity</span></strong><span class="koboSpan" id="kobo.542.1"> instance, so it’ll stay in memory until it’s garbage-collected. </span><span class="koboSpan" id="kobo.542.2">There is no limit regarding how many events you can have on the .NET side, but OpenTelemetry exporters limit the number of exported events. </span><span class="koboSpan" id="kobo.542.3">It is set to 128 by default and can be controlled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.544.1">environment variable.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.545.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.546.1">Activity events should be used to express operations that don’t deserve a span, don’t have a duration or are too short, and have a predictable outcome. </span><span class="koboSpan" id="kobo.546.2">Events must happen in the scope of some </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Activity</span></strong><span class="koboSpan" id="kobo.548.1"> and should only be exported if </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">Activity</span></strong><span class="koboSpan" id="kobo.550.1"> is sampled in. </span><span class="koboSpan" id="kobo.550.2">There should also be a reasonable number of them under a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">Activity</span></strong><span class="koboSpan" id="kobo.552.1"> instance. </span><span class="koboSpan" id="kobo.552.2">Given these limitations, logs are usually a better choice, as long as your observability backend </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">supports them.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Now that we know these limitations, we’re finally ready to play </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">with events.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.556.1">The ActivityEvent API</span></h2>
<p><span class="koboSpan" id="kobo.557.1">An event</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.558.1"> is represented with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">ActivityEvent</span></strong><span class="koboSpan" id="kobo.560.1"> class. </span><span class="koboSpan" id="kobo.560.2">To create one, we must provide</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.561.1"> an event name, and can optionally specify a timestamp (that defaults to the time the event was constructed), as well as a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">of attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">The event’s name is a low-cardinality string that implies the event’s structure: events with the same name are expected to describe occurrences of the same thing and should use the same set </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">of attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Let’s enrich HTTP client instrumentation with events. </span><span class="koboSpan" id="kobo.565.2">Imagine that we have read a long stream over HTTP and want to control </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">content buffering.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">To achieve this, we can pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">HttpCompletionOption.ResponseHeadersRead</span></strong><span class="koboSpan" id="kobo.569.1"> flag to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">HttpClient.SendAsync</span></strong><span class="koboSpan" id="kobo.571.1"> method. </span><span class="koboSpan" id="kobo.571.2">The HTTP client will then return a response before reading the response body. </span><span class="koboSpan" id="kobo.571.3">It’s useful to know the point in time when we got the response so that we know how long it took to read </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">a response.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">The following example </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">demonstrates this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.575.1">Worker.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
public static async Task DoWork(int workItemId) {
  using var work = Source.StartActivity();
  try
  {
    work?.AddTag("work_item.id", workItemId);
    var res = await Client.GetAsync(
      "https://www.bing.com/search?q=tracing",
      HttpCompletionOption.ResponseHeadersRead);
    res.EnsureSuccessStatusCode();
    </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">work?.AddEvent(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.578.1">      new ActivityEvent("received_response_headers"));</span></strong><span class="koboSpan" id="kobo.579.1">
    ...
</span><span class="koboSpan" id="kobo.579.2">  }
  catch (Exception ex)
  {
    work?.SetStatus(ActivityStatusCode.Error,
      ex.Message);
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.580.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/Worker.cs</span></p>
<p><span class="koboSpan" id="kobo.581.1">In this example, we start </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Activity</span></strong><span class="koboSpan" id="kobo.583.1"> to track overall logical request processing through the HTTP client pipeline and then record the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">response_headers</span></strong><span class="koboSpan" id="kobo.585.1"> event. </span><span class="koboSpan" id="kobo.585.2">This event does not have any attributes – its sole purpose is to record the timestamp when we got a response from </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Let’s add more events! </span><span class="koboSpan" id="kobo.587.2">Assuming</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.588.1"> we use throttling or circuit-breaking</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.589.1"> in our HTTP pipeline, we won’t have any physical HTTP requests and no spans reported by auto-instrumentation. </span><span class="koboSpan" id="kobo.589.2">Events can provide observability </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">into it.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">We’ll implement client-side throttling using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">RateLimiter</span></strong><span class="koboSpan" id="kobo.593.1"> class, which is available in .NET 7 and included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">System.Threading.RateLimiting</span></strong><span class="koboSpan" id="kobo.595.1"> NuGet package. </span><span class="koboSpan" id="kobo.595.2">We’ll do so in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">DelegatingHandler</span></strong><span class="koboSpan" id="kobo.597.1"> class, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">this example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.599.1">RateLimitingHandler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
private readonly TokenBucketRateLimiter _rateLimiter =
  new (Options);
protected override async Task&lt;HttpResponseMessage&gt;
  SendAsync(HttpRequestMessage req, CancellationToken ct)
{
  using var lease = _rateLimiter.AttemptAcquire();
  if (lease.IsAcquired)
    return await base.SendAsync(req, ct);
  return Throttle(lease);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs"><span class="koboSpan" id="kobo.601.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs</span></a></p>
<p><span class="koboSpan" id="kobo.602.1">Here, we are trying to acquire a lease</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.603.1"> from the rate limiter. </span><span class="koboSpan" id="kobo.603.2">If it’s successfully</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.604.1"> acquired, we call into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">base.SendAsync</span></strong><span class="koboSpan" id="kobo.606.1"> method, letting this request process further. </span><span class="koboSpan" id="kobo.606.2">Otherwise, we must throttle the request, as demonstrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">code snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.608.1">RateLimitingHandler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
private HttpResponseMessage Throttle(RateLimitLease lease)
{
  var res = new HttpResponseMessage(
    HttpStatusCode.TooManyRequests);
  if (lease.TryGetMetadata(MetadataName.RetryAfter,
    out var retryAfter))
  {
    var work = Activity.Current;
</span><strong class="bold"><span class="koboSpan" id="kobo.610.1">    if (work?.IsAllDataRequested == true)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.611.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.612.1">      var tags = new ActivityTagsCollection();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.613.1">      </span></strong><strong class="bold"><span class="koboSpan" id="kobo.614.1">tags.Add("exception.type", "rate_is_limited");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.615.1">      tags.Add("retry_after_ms",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.616.1">        retryAfter.TotalMilliseconds);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.617.1">      work?.AddEvent(new ActivityEvent("exception",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.618.1">        tags: tags));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.619.1">    }</span></strong><span class="koboSpan" id="kobo.620.1">
    res.Headers.Add("Retry-After",
      ((int)retryAfter.TotalSeconds).ToString());
  }
  return res;
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs"><span class="koboSpan" id="kobo.621.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs</span></a></p>
<p><span class="koboSpan" id="kobo.622.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Throttle</span></strong><span class="koboSpan" id="kobo.624.1"> method, we emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">exception</span></strong><span class="koboSpan" id="kobo.626.1"> event and provide</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.627.1"> a message alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">retry_after</span></strong><span class="koboSpan" id="kobo.629.1"> attribute. </span><span class="koboSpan" id="kobo.629.2">We got a value of this attribute</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.630.1"> from the rate limiter; it provides a hint regarding when it will make sense to retry </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">this request.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">The example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">events</span></strong><span class="koboSpan" id="kobo.634.1"> folder demonstrates a full rate-limiting solution – it configures the rate limiter to allow one request every 5 seconds but sends two requests in parallel so that the first one comes through and the second one </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">is throttled.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Go ahead and run the sample with </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">events$ dotnet run</span></strong><span class="koboSpan" id="kobo.638.1"> and then switch to Jaeger to see two traces from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">events-sample</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.640.1"> service.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">One trace has two spans and represents a successful operation, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.642.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.643.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.645.1"><img alt="Figure 6.2 – A trace with logical and physical HTTP spans and the response_headers event" src="image/B19423_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.646.1">Figure 6.2 – A trace with logical and physical HTTP spans and the response_headers event</span></p>
<p><span class="koboSpan" id="kobo.647.1">Here, we can see that the time to first byte was around 110 milliseconds. </span><span class="koboSpan" id="kobo.647.2">Then, we got the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">response_headers</span></strong><span class="koboSpan" id="kobo.649.1"> event; the rest of the logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">DoWork</span></strong><span class="koboSpan" id="kobo.651.1"> operation was spent on reading </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">stream contents.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">The other trace has just one span and represents a failed operation; it’s shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.654.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.655.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.657.1"><img alt="Figure 6.3 – A trace with a logical call and the rate_is_limited exception event" src="image/B19423_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.658.1">Figure 6.3 – A trace with a logical call and the rate_is_limited exception event</span></p>
<p><span class="koboSpan" id="kobo.659.1">Here, we can see a logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">DoWork</span></strong><span class="koboSpan" id="kobo.661.1"> span, which ended with an error. </span><span class="koboSpan" id="kobo.661.2">If we expand the attributes, we’ll see a status description stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Response status code does not indicate success: 429 (Too Many Requests)</span></strong><span class="koboSpan" id="kobo.663.1">. </span><span class="koboSpan" id="kobo.663.2">This could give us an idea of what happened, even if we didn’t have an event. </span><span class="koboSpan" id="kobo.663.3">There is no physical HTTP span here and it could be confusing and unclear where the response </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">came from.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">rate_is_limited</span></strong><span class="koboSpan" id="kobo.667.1"> event, we</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.668.1"> can populate</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.669.1"> additional attributes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">retry_after_ms</span></strong><span class="koboSpan" id="kobo.671.1">, but most importantly, we can easily understand the root cause of the problem and find the place in our code where the event is </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">sent from.</span></span></p>
<h3><span class="koboSpan" id="kobo.673.1">Recording exceptions</span></h3>
<p><span class="koboSpan" id="kobo.674.1">In the previous example, we created</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.675.1"> an event that represents an error, which is a special event defined in OpenTelemetry. </span><span class="koboSpan" id="kobo.675.2">It has </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">exception</span></strong><span class="koboSpan" id="kobo.677.1"> as its name and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">exception.type</span></strong><span class="koboSpan" id="kobo.679.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">exception.message</span></strong><span class="koboSpan" id="kobo.681.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">exception.stacktrace</span></strong><span class="koboSpan" id="kobo.683.1"> attributes. </span><span class="koboSpan" id="kobo.683.2">Either </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">type</span></strong><span class="koboSpan" id="kobo.685.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">message</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.687.1">is required.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">If we had an exception object, we could have used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">RecordException</span></strong><span class="koboSpan" id="kobo.690.1"> extension method declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">OpenTelemetry.Trace.ActivityExtensions</span></strong><span class="koboSpan" id="kobo.692.1"> class. </span><span class="koboSpan" id="kobo.692.2">We could record exceptions using </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">activity?.RecordException(ex)</span></strong><span class="koboSpan" id="kobo.694.1"> and then pass custom tag collection to add to </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">the event.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">This method calls into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Activity.AddEvent</span></strong><span class="koboSpan" id="kobo.698.1"> method under the hood, filling in all the exception attributes, including the stack trace. </span><span class="koboSpan" id="kobo.698.2">Since stack traces can be huge, it’s a good idea to record them for unhandled exceptions and </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">only once.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.700.1">Correlating spans with links</span></h1>
<p><span class="koboSpan" id="kobo.701.1">So far, we have talked about parent-child relationships</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.702.1"> between spans. </span><span class="koboSpan" id="kobo.702.2">They cover request-response</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.703.1"> scenarios well and allow us to describe distributed call stacks as a tree, where each span has at most one parent and as many children </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">But what if our scenarios are more complicated? </span><span class="koboSpan" id="kobo.705.2">For example, how do we express receiving temperature data from multiple sensors and aggregating it on the backend, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.706.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.707.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.709.1"><img alt="Figure 6.4 – Batch processing" src="image/B19423_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.710.1">Figure 6.4 – Batch processing</span></p>
<p><span class="koboSpan" id="kobo.711.1">In this example, sensors send data to the aggregator in the scope of different traces. </span><span class="koboSpan" id="kobo.711.2">The aggregator must start a third one – it shouldn’t continue one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">sensor’s traces.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">We can use links to connect </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">trace3</span></strong><span class="koboSpan" id="kobo.715.1"> to both </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">trace1</span></strong><span class="koboSpan" id="kobo.717.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">trace2</span></strong><span class="koboSpan" id="kobo.719.1">, allowing us to correlate all of them. </span><span class="koboSpan" id="kobo.719.2">Links don’t specify exact relationships between spans, but in the scope of this example, we can think about them as multiple parents for a </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">single span.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">Links are mostly used in messaging scenarios where messages are sent and received in batches to optimize network usage, or could be also </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">processed together.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">Links have two properties: a linked trace context and a collection of attributes. </span><span class="koboSpan" id="kobo.723.2">Currently, they can only be provided to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">StartActivity</span></strong><span class="koboSpan" id="kobo.725.1"> method and may be used to make sampling decisions. </span><span class="koboSpan" id="kobo.725.2">This is an OpenTelemetry specification limitation</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.726.1"> that might</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.727.1"> be removed in </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">the future.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.729.1">Using links</span></h2>
<p><span class="koboSpan" id="kobo.730.1">Let’s see how we can use links</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.731.1"> to instrument batch processing scenarios with an in-memory queue. </span><span class="koboSpan" id="kobo.731.2">With background processing, we can’t rely on </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.733.1"> to flow from the enqueue operation to processing. </span><span class="koboSpan" id="kobo.733.2">So, we’ll pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.735.1"> along with the work item through </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">But first, we need to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">Activity</span></strong><span class="koboSpan" id="kobo.739.1"> for the enqueue operation so that we have some context to capture and </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">pass around:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.741.1">Producer.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
public void Enqueue(int id)
{
  using var enqueue = Source
    .StartActivity(ActivityKind.Producer)?
</span><span class="koboSpan" id="kobo.742.2">    .SetTag("work_item.id", id);
  _queue.Enqueue(new WorkItem(id, enqueue?.Context));
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/Producer.cs"><span class="koboSpan" id="kobo.743.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/Producer.cs</span></a></p>
<p><span class="koboSpan" id="kobo.744.1">While it’s important to instrument publish calls for remote queues, it’s not essential in this example. </span><span class="koboSpan" id="kobo.744.2">We only did it here to have some valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.746.1"> captured. </span><span class="koboSpan" id="kobo.746.2">If we had any other activity, we could use its </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">context instead.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">Now, we’re ready to instrument the work </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">item processor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.750.1">BatchProcessor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
async Task ProcessBatch(List&lt;WorkItem&gt; items)
{
</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">  using var activity = Source.StartActivity(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.753.1">      ActivityKind.Consumer,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.754.1">      links: items</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.755.1">        .Select(i =&gt; new ActivityLink(i.Context)));</span></strong><span class="koboSpan" id="kobo.756.1">
  activity?.SetTag("work_items.id",
       items.Select(i =&gt; i.Id).ToArray());
  ...
</span><span class="koboSpan" id="kobo.756.2">}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/BatchProcessor.cs"><span class="koboSpan" id="kobo.757.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/BatchProcessor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.758.1">Here, we iterated over work</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.759.1"> items and created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">ActivityLink</span></strong><span class="koboSpan" id="kobo.761.1"> for each of them by using the trace context passed alongside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">WorkItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Then, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">work_item.id</span></strong><span class="koboSpan" id="kobo.766.1"> attribute with an array containing all received IDs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">BatchProcessing</span></strong><span class="koboSpan" id="kobo.768.1"> activity. </span><span class="koboSpan" id="kobo.768.2">Ideally, we’d put attributes on the links themselves via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">ActivityLink</span></strong><span class="koboSpan" id="kobo.770.1"> constructor, but I’m not aware of any observability backend that supports it now. </span><span class="koboSpan" id="kobo.770.2">As an alternative, we can also create an event for each work item and populate attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">on them.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">Let’s run the sample with </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">links$ dotnet run</span></strong><span class="koboSpan" id="kobo.774.1">. </span><span class="koboSpan" id="kobo.774.2">It will enqueue three work items and then process them all in one batch. </span><span class="koboSpan" id="kobo.774.3">In Jaeger, we should see four independent traces – one for each enqueue operation and one for batch processing. </span><span class="koboSpan" id="kobo.774.4">An example of the latter is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.775.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.776.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.778.1"><img alt="Figure 6.5 – Processing span with links" src="image/B19423_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.779.1">Figure 6.5 – Processing span with links</span></p>
<p><span class="koboSpan" id="kobo.780.1">We can see that it has three</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.781.1"> references (links in Jaeger terminology), which we can click on and land on the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Enqueue</span></strong><span class="koboSpan" id="kobo.783.1"> operation, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.784.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.785.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.787.1"><img alt="Figure 6.6 – Enqueue span" src="image/B19423_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.788.1">Figure 6.6 – Enqueue span</span></p>
<p><span class="koboSpan" id="kobo.789.1">In Jaeger, it’s not possible to navigate from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">Enqueue</span></strong><span class="koboSpan" id="kobo.791.1"> span to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">ProcessBatch</span></strong><span class="koboSpan" id="kobo.793.1"> span. </span><span class="koboSpan" id="kobo.793.2">But some of the observability backends support navigation in both directions. </span><span class="koboSpan" id="kobo.793.3">For example, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.794.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.795.1">.7</span></em><span class="koboSpan" id="kobo.796.1"> shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">Enqueue</span></strong><span class="koboSpan" id="kobo.798.1"> operation linked to processing in </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">Azure Monitor:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.800.1"><img alt="Figure 6.7 – Two linked traces visualized in Azure Monitor " src="image/B19423_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.801.1">Figure 6.7 – Two linked traces visualized in Azure Monitor</span></p>
<p><span class="koboSpan" id="kobo.802.1">Note that there are two different</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.803.1"> operations IDs (trace IDs) that have been correlated using a link. </span><span class="koboSpan" id="kobo.803.2">We’ll see more examples of links in messaging scenarios in </span><a href="B19423_11.xhtml#_idTextAnchor174"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.804.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.805.1">, </span><em class="italic"><span class="koboSpan" id="kobo.806.1">Instrumenting Messaging Scenarios</span></em><span class="koboSpan" id="kobo.807.1">. </span><span class="koboSpan" id="kobo.807.2">For now, let’s learn how to test </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">our instrumentations.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.809.1">Testing your instrumentation</span></h1>
<p><span class="koboSpan" id="kobo.810.1">The idea of testing logs</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.811.1"> might look wild – logs are not intended to stay in one place or retain a specific structure. </span><span class="koboSpan" id="kobo.811.2">It’s not the case </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">for traces.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">Instrumentation directly affects your ability to evaluate production health and usage. </span><span class="koboSpan" id="kobo.813.2">Testing auto-instrumentation could be limited to basic happy case validation – we only need to check that it’s enabled and emits some data in the right format. </span><span class="koboSpan" id="kobo.813.3">This would help us detect potential problems with dependency updates. </span><span class="koboSpan" id="kobo.813.4">Manual instrumentation needs </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">more attention.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">Let’s see how we can test any instrumentation in ASP.NET Core applications. </span><span class="koboSpan" id="kobo.815.2">We’re going to rely on the integration testing capabilities provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">Microsoft.AspNetCore.Mvc.Testing</span></strong><span class="koboSpan" id="kobo.817.1"> NuGet package. </span><span class="koboSpan" id="kobo.817.2">You can find more details about it in the ASP.NET Core</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.818.1"> testing documentation available at https://learn.microsoft.com/aspnet/core/test/integration-tests. </span><span class="koboSpan" id="kobo.818.2">It allows us to modify the ASP.NET Core application’s configuration for test purposes. </span><span class="koboSpan" id="kobo.818.3">In this section, we’ll use it to change the OpenTelemetry pipeline and </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">intercept activities.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.820.1">Intercepting activities</span></h2>
<p><span class="koboSpan" id="kobo.821.1">There are a few different</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.822.1"> ways to intercept activities; let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">list them:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.824.1">We can add a span processor, similar to how we enriched activities in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.825.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.826.1">, </span><em class="italic"><span class="koboSpan" id="kobo.827.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.828.1">. </span><span class="koboSpan" id="kobo.828.2">Since processors run synchronously, we can validate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Activity</span></strong><span class="koboSpan" id="kobo.830.1"> attributes against the ambient context – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Baggage.Current</span></strong><span class="koboSpan" id="kobo.832.1">. </span><span class="koboSpan" id="kobo.832.2">We can also check (when needed) that attributes are provided at start time in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">OnStart</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.834.1"> callback.</span></span></li>
<li><span class="koboSpan" id="kobo.835.1">We can implement a test exporter. </span><span class="koboSpan" id="kobo.835.2">The downside of this approach is that we’ll only see completed activities. </span><span class="koboSpan" id="kobo.835.3">Also, exporters run asynchronously and there will be no ambient context to </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">validate against.</span></span></li>
<li><span class="koboSpan" id="kobo.837.1">We can write a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">ActivityListener</span></strong><span class="koboSpan" id="kobo.839.1"> implementation. </span><span class="koboSpan" id="kobo.839.2">This approach would not allow us to test the customization and configurations we’ve done with OpenTelemetry. </span><span class="koboSpan" id="kobo.839.3">We won’t even be able to validate whether OpenTelemetry is configured to listen to specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.841.1"> instances or check whether sampling works </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">as expected.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.843.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">ActivityListener</span></strong><span class="koboSpan" id="kobo.845.1"> could be a great choice for unit testing, and the processor gives the most flexibility in terms of integration testing, which we’re going to focus on here. </span><span class="koboSpan" id="kobo.845.2">Let’s see how we</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.846.1"> can inject a processor into the OpenTelemetry pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">in tests.</span></span></p>
<p><span class="koboSpan" id="kobo.848.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">OpenTelemetry.Extensions.Hosting</span></strong><span class="koboSpan" id="kobo.850.1"> NuGet package allows us to customize the pipeline with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">ConfigureOpenTelemetryTracerProvider</span></strong><span class="koboSpan" id="kobo.852.1"> extension method. </span><span class="koboSpan" id="kobo.852.2">It’s called after the OpenTelemetry pipeline is configured, right before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">TracerProvider</span></strong><span class="koboSpan" id="kobo.854.1"> instance is built. </span><span class="koboSpan" id="kobo.854.2">If you are using vanilla OpenTelemetry, you will have to implement a callback for tests to alter </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">the pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">Here’s an example of adding a </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">test processor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.858.1">TestFactory.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.859.1">
public class TestFactory : WebApplicationFactory&lt;Program&gt;
{
  public readonly </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">TestActivityProcessor</span></strong><span class="koboSpan" id="kobo.861.1"> Processor = new ();
  protected override void ConfigureWebHost(
    IWebHostBuilder b)
  {
    b.ConfigureServices(s =&gt; {
      s.ConfigureOpenTelemetryTracerProvider(
        (_, traceProviderBuilder) =&gt;
          traceProviderBuilder.AddProcessor(Processor));
      ...
</span><span class="koboSpan" id="kobo.861.2">    });
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestFactory.cs"><span class="koboSpan" id="kobo.862.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestFactory.cs</span></a></p>
<p><span class="koboSpan" id="kobo.863.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">TestFactory</span></strong><span class="koboSpan" id="kobo.865.1"> class allows us to set up an ASP.NET Core application for testing, which we’re doing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">ConfigureWebHost</span></strong><span class="koboSpan" id="kobo.867.1"> method. </span><span class="koboSpan" id="kobo.867.2">There, we call into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">ConfigureOpenTelemetryTracerProvider</span></strong><span class="koboSpan" id="kobo.869.1"> method, where we change the OpenTelemetry pipeline and inject</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.870.1"> our test processor. </span><span class="koboSpan" id="kobo.870.2">Here’s the minimalistic </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">processor implementation:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.872.1">TestActivityProcessor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.873.1">
public class TestActivityProcessor :BaseProcessor&lt;Activity&gt;
{
  ConcurrentQueue&lt;Activity&gt; _processed = new ();
  public override void OnEnd(Activity activity) =&gt;
    _processed.Enqueue(activity);
  ...
</span><span class="koboSpan" id="kobo.873.2">}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestActivityProcessor.cs"><span class="koboSpan" id="kobo.874.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestActivityProcessor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.875.1">We’re almost ready to write some tests, but there is another challenge – how do we filter activities related to a </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">specific test?</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.877.1">Filtering relevant activities</span></h2>
<p><span class="koboSpan" id="kobo.878.1">When we run tests</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.879.1"> in parallel, we effectively register multiple OpenTelemetry pipelines that listen to the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.881.1"> instances. </span><span class="koboSpan" id="kobo.881.2">With unit tests covering our instrumentations, we can control this better, but in the case of integration tests, </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.883.1"> and its listeners are de facto static and global – if we run tests in parallel, we’ll see activities from all of them in the processor. </span><span class="koboSpan" id="kobo.883.2">We need to filter relevant activities that belong to our test, which we can do using </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">distributed tracing.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">We’ll start a new activity for each test and propagate the context to the service under test. </span><span class="koboSpan" id="kobo.885.2">Then, we can filter processed activities based on their trace IDs. </span><span class="koboSpan" id="kobo.885.3">This approach is implemented in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">TracingTests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.887.1"> (</span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs"><span class="No-Break"><span class="koboSpan" id="kobo.888.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.889.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.890.1">Validation</span></h3>
<p><span class="koboSpan" id="kobo.891.1">Once we can filter all the activities</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.892.1"> related to this test execution, we’re ready to do some checks on them. </span><span class="koboSpan" id="kobo.892.2">It’s useful to check all the properties you rely upon in your monitoring and debugging tasks. </span><span class="koboSpan" id="kobo.892.3">For example, the following code validates a few properties of ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">Core’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">Activity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.896.1">TracingTests.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.897.1">
Assert.Equal("/document/foo",
  httpIn.GetTagItem("http.target"));
Assert.Equal(404, httpIn.GetTagItem("http.status_code"));
Assert.Equal(ActivityStatusCode.Unset, httpIn.Status);
Assert.Empty(httpIn.Events);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs"><span class="koboSpan" id="kobo.898.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs</span></a></p>
<p><span class="koboSpan" id="kobo.899.1">Now, you’re ready to write and test your instrumentations! </span><span class="koboSpan" id="kobo.899.2">You may also find it useful to use distributed tracing for your general integration testing needs – relying on it to validate intended test behavior and investigate flaky tests or unstable service behavior. </span><span class="koboSpan" id="kobo.899.3">You could also use traces as one of the inputs to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">service behavior.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.901.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.902.1">In this chapter, we explored manual distributed tracing instrumentation using .NET diagnostics primitives. </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">Activity</span></strong><span class="koboSpan" id="kobo.904.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.906.1"> are the default ways to instrument your code – create, start, end, and enrich activities with attributes and events. </span><span class="koboSpan" id="kobo.906.2">You can achieve the same functionality with </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Tracer</span></strong><span class="koboSpan" id="kobo.908.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">TelemetrySpan</span></strong><span class="koboSpan" id="kobo.910.1">, from the OpenTelemetry API package. </span><span class="koboSpan" id="kobo.910.2">They provide a thin wrapper over .NET diagnostics APIs while using </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">OpenTelemetry terminology.</span></span></p>
<p><span class="koboSpan" id="kobo.912.1">We also looked into the ambient context propagation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.914.1"> and how it makes multiple instrumentation layers work together. </span><span class="koboSpan" id="kobo.914.2">Then, we learned about events and their limitations and used links to correlate </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">different traces.</span></span></p>
<p><span class="koboSpan" id="kobo.916.1">Finally, we covered testing – since instrumentation can be critical for monitoring, we should validate it as any other feature. </span><span class="koboSpan" id="kobo.916.2">We learned how to reliably do this in ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">Core applications.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">With this, you should be able to write rich tracing instrumentations and troubleshoot and validate custom tracing code. </span><span class="koboSpan" id="kobo.918.2">To achieve better observability, we can combine multiple signals with minimal duplication, so in the next chapter, we’re going to look at manual metrics instrumentation and see how it can work along </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">with tracing.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.920.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.921.1">Let’s say you started </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Activity</span></strong><span class="koboSpan" id="kobo.923.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.925.1">. </span><span class="koboSpan" id="kobo.925.2">How do you configure OpenTelemetry to listen to it? </span><span class="koboSpan" id="kobo.925.3">How does </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">it work?</span></span></li>
<li><span class="koboSpan" id="kobo.927.1">When should you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Activity</span></strong><span class="koboSpan" id="kobo.929.1"> events? </span><span class="koboSpan" id="kobo.929.2">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">the alternatives?</span></span></li>
<li><span class="koboSpan" id="kobo.931.1">What do we need links for? </span><span class="koboSpan" id="kobo.931.2">How can we </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">use them?</span></span></li>
</ol>
</div>
</body></html>