["```cs\nint x; // Cannot add a breakpoint\nint j = 0; // Can add a breakpoint\n```", "```cs\nint sum = 0;\nfor (int i = 1; i <= 10; i++)\n{\n    sum += i;\n}\n$\"The sum of the numbers from 0 to 9 is {sum}\".Dump(ConsoleColor.Cyan);\n```", "```cs\nThreadPool.QueueUserWorkItem(_ =>\n{\n    int inThreadCounter = 0;\n    while (true)\n    {\n        $\"In the thread with counter {inThreadCounter++}\".Dump(ConsoleColor.Yellow);\n        Thread.Sleep(100);\n    }\n});\nint outThreadCounter = 0;\nwhile (true)\n{\n    $\"In the main thread with counter {outThreadCounter++}\".Dump(ConsoleColor.Cyan);\n    await Task.Delay(200);\n}\n```", "```cs\nvar inThreadCounter = 0;\nvar timer = new Timer(100);\ntimer.Elapsed +=\n    (_, _) =>\n    {\n        $\"In the timer call with counter {inThreadCounter++}\".Dump(ConsoleColor.Yellow);\n    };\ntimer.Start();\n```", "```cs\ninternal class MyClass\n{\n    public int Counter { get; set; }\n}\n```", "```cs\n1: MyClass myClass = new MyClass();\n2: int myNumber = 0;\n3: while (true)\n4: {\n5:     myClass.Counter++;\n6:     Console.WriteLine($\"Counter {myClass.Counter++}\");\n7: }\n```", "```cs\nvar memoryBlock = new Dictionary<int, byte[]>();\nvar passCounter = 0;\nwhile (true)\n{\n    passCounter++;\n    var newBlock = new byte[1024 * 1024];\n    memoryBlock.Add(passCounter, newBlock);\n}\n```", "```cs\npassCounter % 100 == 0\n```", "```cs\nvar rnd = new Random();\nfor (int i = 0; i < 10; i++)\n{\n    int threadNumber = i;\n    ThreadPool.QueueUserWorkItem(_ =>\n    {\n        var counter = 0;\n        while (true)\n        {\n            $\"Thread {threadNumber} with counter {counter++}\".Dump(ConsoleColor.Yellow);\n            Task.Delay(rnd.Next(1000)).Wait();\n        }\n    });\n}\n```", "```cs\n\"Starting the threads\".Dump(ConsoleColor.Cyan);\nvar lockA = new object();\nvar lockB = new object();\nThreadPool.QueueUserWorkItem(_ =>\n{\n    lock (lockA)\n    {\n        \"Thread 1 acquired lock A\".Dump(ConsoleColor.Yellow);\n        Thread.Sleep(1000);\n        lock (lockB)\n        {\n            \"Thread 1 acquired lock B\".Dump(ConsoleColor.Yellow);\n        }\n    }\n});\nThreadPool.QueueUserWorkItem(_ =>\n{\n    lock (lockB)\n    {\n        \"Thread 2 acquired lock B\".Dump(ConsoleColor.Blue);\n        Thread.Sleep(1000);\n        lock (lockA)\n        {\n            \"Thread 2 acquired lock A\".Dump(ConsoleColor.Blue);\n        }\n    }\n});\n\"Waiting for all threads to finish\".Dump(ConsoleColor.Cyan);\nConsole.ReadLine();\n```", "```cs\npublic void Run()\n{\n    var limit = 100000;\n    var stopwatch = Stopwatch.StartNew();\n    var sum = SumOfPrimes(limit);\n    stopwatch.Stop();\n    $\"Sum of primes up to {limit}: {sum}\".Dump();\n    $\"Time taken: {stopwatch.ElapsedMilliseconds} ms\".Dump();\n}\n```", "```cs\nprivate long SumOfPrimes(int limit)\n{\n    long sum = 0;\n    for (var i = 2; i <= limit; i++)\n        if (IsPrime(i))\n            sum += i;\n    return sum;\n}\n```", "```cs\nprivate bool IsPrime(int number)\n{\n    if (number < 2) return false;\n    for (var i = 2; i <= Math.Sqrt(number); i++)\n        if (number % i == 0)\n            return false;\n    return true;\n}\n```", "```cs\n[Benchmark]\npublic void TestModulo()\n{\n    var numberOfMatches = 0;\n    for (var i = 3; i < numberOfLoopCount; i++)\n        if (testNumber % i == 0)\n            numberOfMatches++;\n}\n```", "```cs\nvar summary = BenchmarkRunner.Run<ModuloTesters>();\n```", "```cs\nBenchmark]\npublic void TestMultiplicationAndDivision()\n{\n    var numberOfMatches = 0;\n    for (var i = 3; i < numberOfLoopCount; i++)\n        if (testNumber - i * (testNumber / i) == 0)\n            numberOfMatches++;\n}\n```", "```cs\n[Benchmark]\npublic void TestMultiplicationAndDivisionInParallel()\n{\n    var numberOfMatches = 0;\n    var localNumberOfLoopCount = numberOfLoopCount;\n    var localTestNumber = testNumber;\n    var lockObj = new object();\n    Parallel.For(3, localNumberOfLoopCount, i =>\n    {\n        var div = localTestNumber / i;\n        if (localTestNumber == i * div)\n            lock (lockObj)\n            {\n                numberOfMatches++;\n            }\n    });\n}\n```"]