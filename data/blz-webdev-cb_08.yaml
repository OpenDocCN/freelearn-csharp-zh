- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Keeping the Application Secure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持应用程序安全
- en: In this chapter, we focus on essential security practices for Blazor applications,
    as protecting user data and maintaining trust is crucial for any commercial success.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点关注Blazor应用程序的基本安全实践，因为保护用户数据和维持信任对于任何商业成功至关重要。
- en: We will start by scaffolding identity – setting up the necessary infrastructure
    for user authentication and management by leveraging the template provided by
    the .NET team. We will look at strategies to prevent unauthorized access and protect
    your component from unwanted actors. Additionally, we will cover a more granular
    approach and secure markup areas to customize the component behavior and ensure
    that sensitive information is only accessible to authorized users. We will explore
    how to define and enforce **roles** and **policies** to centralize and encapsulate
    access levels that align with your security requirements. Next, we will learn
    how to determine users’ **authentication state** and their current access context,
    allowing us to secure and enhance backend logic. We will also discuss how to update
    user identity safely and securely.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先搭建身份框架——利用.NET团队提供的模板设置用户身份验证和管理所需的基础设施。我们将探讨防止未经授权的访问并保护您的组件免受不受欢迎的参与者的影响的策略。此外，我们将介绍一种更细粒度的方法，并保护标记区域以自定义组件行为并确保敏感信息仅对授权用户可访问。我们将探讨如何定义和执行**角色**和**策略**以集中和封装与您的安全要求相一致的操作级别。接下来，我们将学习如何确定用户的**身份验证状态**和他们的当前访问上下文，这将使我们能够保护和增强后端逻辑。我们还将讨论如何安全地更新用户身份。
- en: By the end of this chapter, you will understand various security mechanisms
    in Blazor and have the best security practices in your skillset.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解Blazor中的各种安全机制，并将掌握最佳安全实践。
- en: 'Here’s a list of the recipes we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要涵盖的食谱列表：
- en: Scaffolding identity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建身份框架
- en: Securing pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护页面
- en: Securing markup areas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护标记区域
- en: Creating roles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建角色
- en: Modifying a user’s identity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改用户的身份
- en: Supporting roles’ and policies’ authorization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持角色和政策授权
- en: Resolving authentication state in procedural logic
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过程逻辑中解析身份验证状态
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, recipes build on one another, resulting in a guide through
    the most often required identity features. For clarity, at the beginning of each
    recipe, you will find instructions on how to set up a working directory and where
    to get the sample objects from. On top of that, this chapter requires that you
    have a working **Structured Query Language** ( **SQL** ) database, a connection
    string to the database instance, and a SQL IDE as you will need to run a few custom
    migrations. Most of the tables will be scaffolded for you, so don’t stress if
    you don’t have much experience with SQL itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，食谱相互关联，最终形成了一本指南，介绍了最常需要的身份功能。为了清晰起见，在每个食谱的开头，您将找到如何设置工作目录以及从哪里获取示例对象的说明。此外，本章要求您拥有一个工作**结构化查询语言**（**SQL**）数据库、数据库实例的连接字符串以及一个SQL
    IDE，因为您需要运行一些自定义迁移。大多数表都将为您搭建，所以如果您对SQL本身没有太多经验，请不要担心。
- en: 'All the code samples are available on GitHub at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例均可在GitHub上找到：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth)
- en: Scaffolding identity
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建身份框架
- en: The .NET team provides a template that enables adding authentication to your
    Blazor application rapidly. This template is not only quick to set up but also
    highly customizable. You can streamline the implementation of user authentication,
    registration, and profile management, ensuring that your application is secure
    from the get-go. You get essential features such as login and logout functionality,
    password recovery, and user data management – all crucial for any authentication
    system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET团队提供了一个模板，可以快速将身份验证添加到Blazor应用程序中。这个模板不仅设置快速，而且高度可定制。您可以简化用户身份验证、注册和配置文件管理的实现，确保您的应用程序从一开始就是安全的。您将获得基本功能，如登录和注销功能、密码恢复和用户数据管理——所有这些都是任何身份验证系统所必需的。
- en: Let’s scaffold a new Blazor project with authentication enabled and explore
    the features it offers out of the box. By the end of this recipe, you will have
    a solid foundation and understanding of the identity system. Whether you’re building
    a simple app or a complex enterprise solution, this approach will save you time
    and effort while ensuring your application meets modern security standards.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用启用身份验证的Blazor项目模板来生成一个新的Blazor项目，并探索它提供的功能。到食谱结束时，你将拥有一个坚实的基础和对身份系统的理解。无论你是构建一个简单的应用程序还是一个复杂的企业解决方案，这种方法都将节省你的时间和精力，同时确保你的应用程序符合现代安全标准。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will showcase initializing the project with identity, leveraging the GUI
    provided as part of Visual Studio, so the only pre-requirement in this recipe
    is that you start your IDE. Let’s dive in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示使用身份初始化项目，利用Visual Studio提供的GUI，因此本食谱的唯一先决条件是启动你的IDE。让我们开始吧。
- en: If you’re using the .NET CLI in your environment, you can refer to the *There’s
    more…* section at the end of the recipe, where I’ll provide equivalent commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在环境中使用.NET CLI，可以参考食谱末尾的*更多内容…*部分，在那里我将提供等效的命令。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to scaffold a new Blazor project with identity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建一个新的具有身份的Blazor项目：
- en: 'Select **Create a new project** from the welcome window:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从欢迎窗口中选择**创建新项目**：
- en: '![Figure 8.1: Starting the creation of a new project from the welcome window](img/Figure_8.1_B22020.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：从欢迎窗口开始创建新项目](img/Figure_8.1_B22020.jpg)'
- en: 'Figure 8.1: Starting the creation of a new project from the welcome window'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：从欢迎窗口开始创建新项目
- en: 'Use the search bar at the top of the panel to find the **Blazor Web App** position
    and confirm by clicking the **Next** button:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用面板顶部的搜索栏找到**Blazor Web App**位置，并通过点击**下一步**按钮进行确认：
- en: '![Figure 8.2: Selecting Blazor Web App from available project templates](img/Figure_8.2_B22020.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：从可用的项目模板中选择Blazor Web App](img/Figure_8.2_B22020.jpg)'
- en: 'Figure 8.2: Selecting Blazor Web App from available project templates'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：从可用的项目模板中选择Blazor Web App
- en: 'Define a project location and name and confirm by clicking the **Next** button:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义项目位置和名称，并通过点击**下一步**按钮进行确认：
- en: '![Figure 8.3: Setting a project location and name](img/Figure_8.3_B22020.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：设置项目位置和名称](img/Figure_8.3_B22020.jpg)'
- en: 'Figure 8.3: Setting a project location and name'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：设置项目位置和名称
- en: 'Choose **.NET 9.0 (Standard Term Support)** as the target framework, and in
    the **Authentication type** section, select **Individual Accounts** . Make sure
    to check the **Configure for HTTPS** and **Include sample pages** checkboxes,
    and select **Auto (Server and WebAssembly)** and **Per page/component** from the
    interactivity configuration dropdowns. Confirm by clicking the **Create** button:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标框架选择为**.NET 9.0（标准条款支持**），在**身份验证类型**部分，选择**个人账户**。确保勾选**配置HTTPS**和**包含示例页面**复选框，并从交互性配置下拉菜单中选择**自动（服务器和WebAssembly**）和**按页面/组件**。通过点击**创建**按钮进行确认：
- en: '![Figure 8.4: Configuring the project’s framework, interactivity, and authentication](img/Figure_8.4_B22020.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：配置项目的框架、交互性和身份验证](img/Figure_8.4_B22020.jpg)'
- en: 'Figure 8.4: Configuring the project’s framework, interactivity, and authentication'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：配置项目的框架、交互性和身份验证
- en: 'You will arrive at a similar project setup, which may vary depending on the
    name of your project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你将到达一个类似的项目设置，这可能会根据你的项目名称而有所不同：
- en: '![Figure 8.5: Initial solution structure](img/Figure_8.5_B22020.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：初始解决方案结构](img/Figure_8.5_B22020.jpg)'
- en: 'Figure 8.5: Initial solution structure'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：初始解决方案结构
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The entire process is almost the same as we explored in the *Initializing a
    project* recipe in [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020) . Navigate
    there for the first three steps. Here, we focus on *step 4* .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程几乎与我们探索的*初始化项目*食谱中的相同[*第1章*](B22020_01.xhtml#_idTextAnchor020)。前往那里进行前三步。在这里，我们专注于*第4步*。
- en: In *step 4* , we land on the project configuration panel. First, we select **.NET
    9 (Standard Term Support)** as our target framework. Then, we have an **Authentication
    type** section. Here, we opt for the **Individual Accounts** option, instructing
    Visual Studio to scaffold the code supporting identity in our application. We
    also enable HTTPS and generate sample pages by checking the respective checkboxes.
    Lastly, to complete the configuration setup, we define the interactivity of our
    application – we will use a per-page/component interactivity location and a mix
    of Server and WebAssembly rendering. Next, we see the result of the scaffolding
    – a solution with two projects for the server and client side, respectively. It
    looks nothing different from the standard Blazor template scaffold, so let’s dive
    into each project to understand how it supports identity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们进入项目配置面板。首先，我们将目标框架选为**.NET 9 (标准术语支持)**。然后，我们有一个**身份验证类型**部分。在这里，我们选择**个人账户**选项，指示Visual
    Studio为我们的应用程序生成支持身份的代码。我们还启用HTTPS并通过勾选相应的复选框生成示例页面。最后，为了完成配置设置，我们定义了应用程序的交互性——我们将使用每页/组件的交互位置和服务器与WebAssembly渲染的混合。接下来，我们看到分层的结果——一个包含两个项目的解决方案，分别用于服务器和客户端。它看起来与标准的Blazor模板分层没有太大区别，所以让我们深入了解每个项目，了解它是如何支持身份验证的。
- en: 'Here’s what the scaffolded projects’ structures look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分层项目结构的示例：
- en: '![Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication](img/Figure_8.6_B22020.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：带有启用身份验证的服务器和客户端项目](img/Figure_8.6_B22020.jpg)'
- en: 'Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：带有启用身份验证的服务器和客户端项目
- en: Let’s first unpack the client-side project (on the right side in *Figure 8*
    *.6* ), as it’s significantly smaller. On the components’ side, we’re getting
    just one relevant to manage identity – **RedirectToLogin** . As the name implies,
    **RedirectToLogin** safely redirects a user to the login page, persisting the
    initial URL so that Blazor can return there. We’re also getting a **UserInfo**
    class – a model containing the user identity details we want to share between
    server- and client-side communication, and one we can easily extend. The backbone
    of sharing the authentication state across render mode boundaries is the **PersistentAuthenticationStateProvider**
    service, which we will explore in the *Supporting roles’ and policies’ authorization*
    recipe. Lastly, we’re getting a minimal setup in the **Program.cs** file. The
    **PersistentAuthenticationStateProvider** service is registered as a singleton
    in the **dependency injection container** ( **DI** ), and with the **AddAuthorizationCore()**
    extension method, all services required to enable authorization in our app are
    registered for us. We also get an invocation of the **AddCascadingAuthenticationState()**
    extension method to add an authentication state as a root-level cascading value
    and make it interceptable in the entire WebAssembly application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解开客户端项目（如图8.6右侧所示），因为它显著更小。在组件方面，我们只得到一个与身份管理相关的组件——**RedirectToLogin**。正如其名所示，**RedirectToLogin**安全地将用户重定向到登录页面，并保留初始URL，以便Blazor可以返回那里。我们还得到一个**UserInfo**类——一个包含我们希望在服务器和客户端通信之间共享的用户身份详细信息的模型，并且可以轻松扩展。在渲染模式边界之间共享身份验证状态的骨干是**PersistentAuthenticationStateProvider**服务，我们将在*支持角色和策略授权*配方中对其进行探讨。最后，我们在**Program.cs**文件中得到了一个最小设置。**PersistentAuthenticationStateProvider**服务在**依赖注入容器**（**DI**）中注册为单例，并且通过**AddAuthorizationCore()**扩展方法，所有用于在我们的应用程序中启用授权所需的服务都为我们注册了。我们还得到对**AddCascadingAuthenticationState()**扩展方法的调用，以将身份验证状态作为根级级联值添加，并使其在整个WebAssembly应用程序中可拦截。
- en: 'The server-side project (on the left side in *Figure 8* *.6* ) contains the
    **Data** directory, with an **ApplicationDbContext** class, an **ApplicationUser**
    class, and a **Migrations** subdirectory, indicating that the server-side project
    is responsible for persisting and managing users and their identities. That means
    you must provide a valid connection string to the database where you want to store
    identity data. You’ll find a placeholder **DefaultConnection** node generated
    in the **appSettings.json** file, which you must replace with the connection details
    of your database resource. Next to the **Data** directory, we get a chunk of generated
    components, including an **Account** area, with pages and UI, handling all actions
    required to manage identity in our application. There are components for logging
    in, logging out, managing accounts, and even enabling **two-factor authentication**
    ( **2FA** ), and they’re all Razor-native components. You’ll notice that regardless
    of the interactivity declared when configuring, all the identity components are
    rendered in **server-side rendering** ( **SSR** ) mode by default. As is currently
    an industry standard for applications with a server-side to leverage cookies for
    identity management, we’re also getting a custom **IdentityRedirectManager** wrapper,
    which leverages the default Blazor **NavigationManager** class, extending it with
    identity status cookies and a few redirection resolvers. The **IdentityRedirectManager**
    class is also designed to throw an **InvalidOperationException** exception when
    used outside of the static SSR. In SSR, contrary to other rendering modes, we
    can access an **HttpContext** instance of each request. The **IdentityUserAccessor**
    class is another wrapper class, allowing us to resolve the current user identity
    from the **HttpContext** instance. In the **IdentityComponentsEndpointRouteBuilderExtensions**
    class, we get a mapping for three additional identity endpoints for logging in
    with an external **identity provider** ( **IdP** ), downloading personal user
    data, and logging out. These are missing in the default identity API implementation,
    as they’re native for applications with a UI. The **IdentityNoOpEmailSender**
    class is a placeholder service for sending identity-related emails: confirming
    user email or resetting passwords. You have to implement your own **IEmailSender**
    client before going live. We also get a **PersistingRevalidatingAuthenticationStateProvider**
    class that Blazor uses to share the authentication state across render boundaries
    between server and client code – we will explore that in the *Supporting roles’
    and policies’ authorization* recipe too. The **Program.cs** file gets a bit more
    complex. We will find here the default setup of interactive server and WebAssembly
    components and a default middleware pipeline. However, on top of that, we’re setting
    up the server-side identity features. We register the custom identity services
    (discussed earlier in this section) and invoke the **AddCascadingAuthenticationState()**
    extension method to enable the cascading of the authentication state at a root
    level. We configure the authentication leveraging the **AddAuthentication()**
    extension method. Here’s also where we inform Blazor to use cookies for identity
    persistence with the help of the **AddIdentityCookies()** extension method. In
    **Program.cs** , we also configure the database access for our **ApplicationDbContext**
    class. Lastly, and most importantly, we leverage the **AddIdentityCore()** method
    and the **IdentityBuilder** API to configure the required identity services.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端项目（在*图8* *.6* 的左侧）包含**数据**目录，其中有一个**ApplicationDbContext**类，一个**ApplicationUser**类，以及一个**迁移**子目录，这表明服务器端项目负责持久化和管理用户及其身份。这意味着你必须提供一个有效的连接字符串，指向你想要存储身份数据的数据库。你会在**appSettings.json**文件中找到一个生成的占位符**DefaultConnection**节点，你必须将其替换为你的数据库资源的连接详情。在**数据**目录旁边，我们得到了一大块生成的组件，包括一个**账户**区域，包含页面和UI，处理管理我们应用程序中身份所需的所有操作。这里有用于登录、登出、管理账户甚至启用**双因素认证**（**2FA**）的组件，它们都是Razor原生组件。你会注意到，无论在配置时声明了什么交互性，所有身份组件默认都以**服务器端渲染**（**SSR**）模式渲染。由于目前行业标准是服务器端应用程序利用cookie进行身份管理，我们还得到了一个自定义的**IdentityRedirectManager**包装器，它利用默认的Blazor
    **NavigationManager**类，通过身份状态cookie和一些重定向解析器对其进行扩展。**IdentityRedirectManager**类还设计为在静态SSR之外使用时抛出**InvalidOperationException**异常。在SSR中，与其它渲染模式不同，我们可以访问每个请求的**HttpContext**实例。**IdentityUserAccessor**类是另一个包装类，允许我们从**HttpContext**实例中解析当前用户身份。在**IdentityComponentsEndpointRouteBuilderExtensions**类中，我们得到了三个额外的身份端点的映射，用于使用外部**身份提供者**（**IdP**）登录、下载个人用户数据和登出。这些在默认身份API实现中是缺失的，因为它们对于具有UI的应用程序来说是本地的。**IdentityNoOpEmailSender**类是一个用于发送与身份相关的电子邮件的占位符服务：确认用户电子邮件或重置密码。在上线之前，你必须实现自己的**IEmailSender**客户端。我们还得到了一个**PersistingRevalidatingAuthenticationStateProvider**类，Blazor使用它来在服务器和客户端代码之间的渲染边界之间共享身份验证状态——我们也会在*支持角色和策略的授权*配方中探讨这一点。**Program.cs**文件变得更加复杂。在这里，我们会找到交互式服务器和WebAssembly组件的默认设置以及默认的中间件管道。然而，在此基础上，我们还在设置服务器端身份功能。我们注册了自定义的身份服务（在本节前面讨论过）并调用**AddCascadingAuthenticationState()**扩展方法来在根级别启用身份验证状态的级联。我们利用**AddAuthentication()**扩展方法配置身份验证。这里也是我们通过**AddIdentityCookies()**扩展方法通知Blazor使用cookie进行身份持久化的地方。在**Program.cs**中，我们还为我们的**ApplicationDbContext**类配置数据库访问。最后，并且最重要的是，我们利用**AddIdentityCore()**方法和**IdentityBuilder**
    API来配置所需的身份服务。
- en: 'Now that you understand the structure of each of the projects, let’s visualize
    how the authentication workflow works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了每个项目的结构，让我们可视化一下身份验证工作流程是如何工作的：
- en: '![Figure 8.7: Authentication workflow between server and client sides of the
    Blazor web app](img/Figure_8.7_B22020.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：Blazor Web应用的客户端和服务器端之间的身份验证工作流程](img/Figure_8.7_B22020.jpg)'
- en: 'Figure 8.7: Authentication workflow between server and client sides of the
    Blazor web app'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Blazor Web应用的客户端和服务器端之间的身份验证工作流程
- en: When a user tries to access the application, their identity is checked. The
    authentication state provider service validates the available authentication cookie
    or lack thereof. If validation is successful, the user gets redirected to the
    page they intended to visit; otherwise, the user lands on the login page. After
    submitting the login form and receiving a successful authentication response from
    the IdP, Blazor persists the user’s identity in the authentication cookie. That
    cookie gets attached to every request between the server and client side, allowing
    **PersistingRevalidatingAuthenticationStateProvider** and **PersistentAuthenticationStateProvider**
    to effectively monitor and recognize the current user and their permissions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试访问应用程序时，他们的身份将被检查。身份验证状态提供者服务验证可用的身份验证cookie或其缺失。如果验证成功，用户将被重定向到他们打算访问的页面；否则，用户将落在登录页面上。在提交登录表单并从身份提供者（IdP）收到成功的身份验证响应后，Blazor将在身份验证cookie中持久化用户的身份。这个cookie将被附加到服务器和客户端之间的每个请求上，允许**PersistingRevalidatingAuthenticationStateProvider**和**PersistentAuthenticationStateProvider**有效地监控和识别当前用户及其权限。
- en: 'When you run the application for the first time and try to create an account,
    your application will fail. But in a developer-friendly way, you will see an exception
    page, informing you that you didn’t run the initial migration yet, so your backing
    database can’t support identity features:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行应用程序并尝试创建账户时，你的应用程序将失败。但以开发者友好的方式，你会看到一个异常页面，告诉你你还没有运行初始迁移，因此你的后端数据库无法支持身份功能：
- en: '![Figure 8.8: Exception page when you try to create an account without the
    initial migration](img/Figure_8.8_B22020.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：尝试在没有初始迁移的情况下创建账户时的异常页面](img/Figure_8.8_B22020.jpg)'
- en: 'Figure 8.8: Exception page when you try to create an account without the initial
    migration'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：尝试在没有初始迁移的情况下创建账户时的异常页面
- en: You will also get a simple **Apply Migrations** button allowing you to apply
    the migrations immediately!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会得到一个简单的**应用迁移**按钮，允许你立即应用迁移！
- en: All that code and functionality are ready to use, and you haven’t written a
    single line of your own code yet. Leveraging solution templates and scaffolding
    increases the velocity of the delivery of your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码和功能都准备好了，而你还没有编写一行自己的代码。利用解决方案模板和脚手架可以加快你应用程序交付的速度。
- en: There’s more…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'In case you’re not using a GUI or Visual Studio, you can leverage the cross-platform
    .NET CLI and scaffold the same template with a single command line. Navigate to
    your working directory and run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用GUI或Visual Studio，你可以利用跨平台的.NET CLI，通过单条命令行来生成相同的模板。导航到你的工作目录，并运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will get the same format of a project that we did through the Visual Studio
    walk-through, with one difference. The project scaffolded with the .NET CLI utilizes
    the SQLite database rather than SQL Server. You can quickly adjust that by navigating
    to the **Program.cs** file of the server-side project and updating the **ApplicationDbContext**
    registration options to use SQL Server:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到与我们在Visual Studio演练中创建的项目相同的格式，只有一个区别。使用.NET CLI生成的项目使用SQLite数据库而不是SQL Server。你可以通过导航到服务器端项目的**Program.cs**文件并更新**ApplicationDbContext**注册选项来使用SQL
    Server：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Securing pages
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护页面
- en: Protecting unauthorized routing is crucial as malicious actors can attempt to
    scrape your application, bypassing the navigation paths enforced by your UI. Ensuring
    that only authorized users can access specific routes helps safeguard sensitive
    data and functionality. Blazor comes with a built-in **Authorize** attribute to
    check access permissions when a user navigates to a page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保护未经授权的路由至关重要，因为恶意行为者可能会尝试抓取你的应用程序，绕过你的UI强制执行的导航路径。确保只有授权用户可以访问特定路由有助于保护敏感数据和功能。Blazor内置了**Authorize**属性，用于在用户导航到页面时检查访问权限。
- en: Let’s add a routable component that only an authenticated user can navigate
    to by applying the **Authorize** attribute in the right place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个可路由的组件，只有通过在正确位置应用 **Authorize** 属性，认证用户才能导航到它。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we add a secure component to the server-side project, create a **Components**
    / **Recipes** / **Recipe02** directory – this will be your working directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将安全组件添加到服务器端项目之前，创建一个 **Components** / **Recipes** / **Recipe02** 目录——这将是你的工作目录。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to protect a component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明保护组件：
- en: 'Create a routable **Settings** component with a **/** **ch08r02** path:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 **/** **ch08r02** 路径的可路由 **Settings** 组件：
- en: '[PRE2]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reference the **Microsoft.AspNetCore.Authorization** assembly and attach an
    **Authorize** attribute to the **Settings** component:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引用 **Microsoft.AspNetCore.Authorization** 程序集并将 **Authorize** 属性附加到 **Settings**
    组件：
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add placeholder markup to the **Settings** component, informing the user that
    they are authorized to see this content:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 **Settings** 组件添加占位符标记，告知用户他们有权查看此内容：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we execute a routine step and create a new routable **Settings**
    component, leveraging **@page** . Next, in *step 2* , we reference the **Microsoft.AspNetCore.Authorization**
    assembly with the help of the **@using** directive right below the **@page** declaration.
    Then, we use **@attribute** to attach the **Authorize** attribute. Now, only authenticated
    users can access the **Settings** page. However, it’s important to note that Blazor
    performs a verification of the **Authorize** attribute only as part of the routing
    process and does not apply it to child components’ rendering flow. Lastly, in
    *step 3* , we add some placeholder content to inform users that they are authorized
    to view this page. In the **Settings** markup, we render the page header and a
    **You’re authorized to see** **settings.** message.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们执行一个常规步骤并创建一个新的可路由 **Settings** 组件，利用 **@page**。接下来，在 *步骤 2* 中，我们使用
    **@using** 指令在 **@page** 声明下方引用 **Microsoft.AspNetCore.Authorization** 程序集。然后，我们使用
    **@attribute** 将 **Authorize** 属性附加到组件上。现在，只有认证用户可以访问 **Settings** 页面。然而，重要的是要注意，Blazor
    只在路由过程中验证 **Authorize** 属性，并不将其应用于子组件的渲染流程。最后，在 *步骤 3* 中，我们添加一些占位符内容来告知用户他们有权查看此页面。在
    **Settings** 标记中，我们渲染页面标题和 **您有权查看** **设置** 的消息。
- en: There’s more…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If you’re building a markup-less component or simply working in a code-behind
    fashion, you can still leverage the **Authorize** attribute. Here’s how we would
    implement a markup-less version of the **Settings** component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建无标记的组件或以代码后方式工作，你仍然可以利用 **Authorize** 属性。以下是实现无标记版本的 **Settings** 组件的方法：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we’re no longer in a Razor file, we’re using the syntax of C# attributes.
    By decorating the **Settings** class with a **[Route]** attribute, we enable navigation
    to the **/ch08r02** path. Additionally, by adding the **[Authorize]** attribute,
    we ensure that Blazor only allows routing to this component for authenticated
    users. We effectively achieve the same logical behavior as in the initial implementation.
    As a side note, when you’re working in Razor files, the Razor compiler translates
    all the dedicated **@directive** declarations to attributes – similar to what
    we did with the markup-less component.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再处于 Razor 文件中，我们使用 C# 属性的语法。通过用 **[Route]** 属性装饰 **Settings** 类，我们启用对 **/ch08r02**
    路径的导航。此外，通过添加 **[Authorize]** 属性，我们确保 Blazor 只允许认证用户导航到该组件。我们有效地实现了与初始实现相同的逻辑行为。作为旁注，当你以
    Razor 文件工作的时候，Razor 编译器将所有的专用 **@directive** 声明转换为属性——类似于我们在无标记组件中所做的。
- en: Securing markup areas
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护标记区域
- en: Sometimes, restricting access to an entire page can be too limiting. You might
    want to expose your landing page to everyone while fine-tuning the elements users
    see in the navigation menu. For example, authenticated users might have access
    to a back office feature that standard users cannot see despite viewing the same
    page. Blazor supports protecting specific markup areas with an **AuthorizeView**
    component. The **AuthorizeView** component allows you to control the visibility
    of content based on the user’s authentication state. It supports various states
    and works seamlessly with **RenderFragment** objects, making it highly flexible
    and versatile.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，限制对整个页面的访问可能过于限制。您可能希望向所有人公开着陆页，同时微调用户在导航菜单中看到的元素。例如，经过身份验证的用户可能可以访问标准用户看不到的后台办公功能，尽管他们查看的是同一页面。Blazor支持使用**AuthorizeView**组件保护特定的标记区域。**AuthorizeView**组件允许您根据用户的身份验证状态控制内容的可见性。它支持各种状态，并与**RenderFragment**对象无缝协作，使其非常灵活和多功能。
- en: Let’s leverage the **AuthorizeView** component and add a status message visible
    only to authenticated users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用**AuthorizeView**组件并添加一个仅对经过身份验证的用户可见的状态消息。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we add a protected status message to a component, do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向组件添加受保护状态消息之前，请执行以下操作：
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe03**
    directory – this will be your working directory
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端项目中，创建一个**组件**/**配方**/**Recipe03**目录——这将是你的工作目录。
- en: Copy the **Settings** component from the *Securing pages* recipe or from the
    **Components** / **Recipes** / **Recipe02** directory in the GitHub repository
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*页面安全*配方或从GitHub仓库中的**组件**/**配方**/**Recipe02**目录复制**设置**组件。
- en: How to do it…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add a protected markup area in a component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在组件中添加受保护的标记区域：
- en: Navigate to the **Settings** component and remove the **Authorize** attribute
    and the existing **@** **using** directive.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**设置**组件，并移除**授权**属性以及现有的**@using**指令。
- en: 'Locate the authorization status message in the **Settings** markup and wrap
    it in **AuthorizeView** component tags:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**标记中定位授权状态消息，并用**AuthorizeView**组件标签包裹它：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we remove the existing **Authorize** attribute and the **@using**
    directive, required to reference the attribute, from the **Settings** component,
    allowing all users to access the page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们从**设置**组件中移除现有的**授权**属性和引用该属性的**@using**指令，允许所有用户访问页面。
- en: In *step 2* , we locate the **You’re authorized to see settings.** authorization
    status message in the **Settings** markup. We then wrap this message inside **AuthorizeView**
    component tags. The **AuthorizeView** component manages content visibility based
    on the user authentication state and accepts **ChildContent** , meaning Blazor
    will render the status message only for authenticated users. This approach ensures
    that only users with the proper credentials see certain content, enhancing the
    security and user experience of your application. You can find more details on
    the **ChildContent** pattern in the *Creating components with customizable content*
    recipe of [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020) .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们在**设置**标记中定位**您有权查看设置**的授权状态消息。然后我们将此消息包裹在**AuthorizeView**组件标签内。**AuthorizeView**组件根据用户身份验证状态管理内容可见性，并接受**ChildContent**，这意味着Blazor只为经过身份验证的用户渲染状态消息。这种方法确保只有具有适当凭证的用户才能看到某些内容，从而增强应用程序的安全性和用户体验。您可以在[*第1章*](B22020_01.xhtml#_idTextAnchor020)的*创建具有可定制内容的组件*配方中找到有关**ChildContent**模式的更多详细信息。
- en: Blazor will effectively obscure everything inside the **AuthorizeView** component
    from unauthorized users. That means markup, as well as any event handlers or method
    calls. Consequently, you can secure your UI and entire features and functionalities,
    preventing unauthorized users from even knowing they exist.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor将有效地隐藏**AuthorizeView**组件内部的所有内容，对未经授权的用户不可见。这意味着标记以及任何事件处理程序或方法调用。因此，您可以保护您的UI以及整个功能和功能，防止未经授权的用户知道它们的存在。
- en: There’s more…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Apart from **ChildContent** , **AuthorizeView** supports providing the **Authorized**
    , **Authorizing** , and **NotAuthorized** fragments explicitly. With that, you
    can define distinct content for authenticated and unauthenticated users within
    the same component. You would leverage the **Authorizing** fragment to display
    a temporary message indicating that resolving of user’s identity is in progress,
    as you might need to execute some asynchronous and long-running logic. In our
    case, we could opt for the following markup in the **Settings** component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **ChildContent** 外，**AuthorizeView** 支持显式提供 **Authorized**、**Authorizing**
    和 **NotAuthorized** 片段。有了这个，你可以在同一组件内为认证用户和非认证用户定义不同的内容。你可以利用 **Authorizing**
    片段来显示一个临时消息，表明正在解决用户的身份，因为你可能需要执行一些异步和长时间运行的逻辑。在我们的案例中，我们可以在 **Settings** 组件中采用以下标记：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The **AuthorizeView** component will evaluate the user’s authentication state
    normally, but this time give the user a feeling of each stage of the process.
    When authenticating the user, Blazor will render the content in **Authorizing**
    tags – a **Give us a few moments…** message. When authentication is complete,
    for the authenticated user, Blazor will render the markup in the **Authorized**
    section and display the expected **You’re authorized to see settings.** message.
    However, contrary to the **Authorized** attribute, an anonymous user will also
    see some content – one within **NotAuthorized** tags, saying **You can’t be here,
    sorry.** , offering meaningful feedback to unauthenticated users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**AuthorizeView** 组件将正常评估用户的认证状态，但这次会给用户一种感受到每个阶段的感觉。在认证用户时，Blazor 将在 **Authorizing**
    标签中渲染内容 – 一个 **给我们一点时间…** 消息。认证完成后，对于认证用户，Blazor 将在 **Authorized** 部分渲染标记并显示预期的
    **您有权查看设置。** 消息。然而，与 **Authorized** 属性相反，匿名用户也会看到一些内容 – 一个在 **NotAuthorized**
    标签内，说 **您不能在这里，抱歉。** ，向未认证用户提供有意义的反馈。'
- en: Creating roles
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建角色
- en: Roles in web applications are predefined categories assigned to users that determine
    their access permissions and functionalities within the application. By categorizing
    users into roles, you can manage and control what each user can view and do, enhancing
    security and user experience. Roles provide a clear and structured way to enforce
    access control. Instead of managing permissions for each user, you can assign
    roles and define access rules based on these roles. This approach simplifies the
    administration of user permissions and ensures consistent security policies across
    the application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，角色是预定义的类别，分配给用户，以确定他们在应用程序中的访问权限和功能。通过将用户分类到角色中，你可以管理和控制每个用户可以查看和执行的操作，从而增强安全和用户体验。角色提供了一种清晰和结构化的方式来执行访问控制。你不需要为每个用户管理权限，而是可以分配角色并根据这些角色定义访问规则。这种方法简化了用户权限的管理，并确保了应用程序中安全策略的一致性。
- en: Let’s add a small form where authenticated users can create new roles in the
    application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个小表单，让认证用户可以在应用程序中创建新的角色。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we implement the role creation form, do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现角色创建表单之前，执行以下操作：
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe04**
    directory – this will be your working directory
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端项目中，创建一个 **Components** / **Recipes** / **Recipe04** 目录 – 这将是你的工作目录
- en: Copy the **Settings** component from the *Securing markup areas* recipe or from
    the **Components** / **Recipes** / **Recipe03** directory in the GitHub repository
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Securing markup areas* 菜单或从 GitHub 仓库中的 **Components** / **Recipes** / **Recipe03**
    目录复制 **Settings** 组件
- en: If you haven’t scaffolded your project, copy the **StatusMessage** component
    from the **Components** / **Account** / **Shared** directory of the GitHub repository
    to the same path in your server-side project
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有搭建项目，请将 GitHub 仓库中 **Components** / **Account** / **Shared** 目录下的 **StatusMessage**
    组件复制到服务器端项目的相同路径
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these instructions to set up roles’ support and management:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置角色的支持和管理：
- en: Navigate to the server-side project’s **Program.cs** file. Find the section
    where we register identity services, starting with the **AddIdentityCore()** method.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到服务器端项目的 **Program.cs** 文件。找到我们注册身份服务部分的区域，从 **AddIdentityCore()** 方法开始。
- en: 'After the **AddIdentityCore()** method, invoke the **AddRoles()** method and
    leverage the default **IdentityRole** model to declare the application role model.
    Below the **AddEntityFrameworkStores()** method, register a role manager with
    the help of an **AddRoleManager()** builder method with the default **RoleManager**
    service for the **IdentityRole** model:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**AddIdentityCore()**方法之后，调用**AddRoles()**方法，并利用默认的**IdentityRole**模型声明应用程序的角色模型。在**AddEntityFrameworkStores()**方法下方，使用**AddRoleManager()**构建方法并借助默认的**RoleManager**服务为**IdentityRole**模型注册一个角色管理器：
- en: '[PRE8]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the **Settings** component, and below the **@page** directive, add a set
    of **@using** directives referencing the necessary assemblies:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**设置**组件，在**@page**指令下方，添加一组**@using**指令，引用必要的程序集：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Below the section with **@using** , inject **RoleManager** and **Navigation**
    services:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**@using**部分下方，注入**RoleManager**和**Navigation**服务：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the **Settings** component, initialize the **@code** block and construct
    an **InputModel** class with a single **RoleName** property:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**组件中，初始化**@code**块，并构建一个具有单个**RoleName**属性的**InputModel**类：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Below the service injections, intercept a cascading value of **HttpContext**
    :'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务注入下方，拦截**HttpContext**的级联值：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Below **HttpContext** , declare an **Input** parameter supplied from a form
    and override the **OnInitialized()** lifecycle method to complete the form initialization
    pattern:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**HttpContext**下方，声明一个由表单提供的**Input**参数，并覆盖**OnInitialized()**生命周期方法来完成表单初始化模式：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Complete the **@code** block with the implementation of a **SaveAsync()** method,
    where you initialize a new **IdentityRole** object and leverage the **RoleManager**
    service to save the new role. Use the **Navigation** service to perform a self-redirect
    and display the operation status:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个**SaveAsync()**方法来完善**@code**块，在该方法中初始化一个新的**IdentityRole**对象，并利用**RoleManager**服务来保存新的角色。使用**Navigation**服务执行自我重定向并显示操作状态：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the **Settings** component markup, locate the **AuthorizeView** tags and
    declare a custom name for the **Context** parameter. Also, replace the authentication
    status message with a **StatusMessage** component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**组件的标记中，找到**AuthorizeView**标签，并为**Context**参数声明一个自定义名称。同时，将身份验证状态消息替换为**StatusMessage**组件：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Below **StatusMessage** , initialize an **EditForm** component, attaching the
    **Input** model and the **SaveAsync()** method to the **Model** and **OnValidSubmit**
    parameters. Remember to declare a unique **EditForm** name as well:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**StatusMessage**下方，初始化一个**EditForm**组件，将**Input**模型和**SaveAsync()**方法绑定到**Model**和**OnValidSubmit**参数。记住也要声明一个唯一的**EditForm**名称：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the **EditForm** component, add a paragraph with an editable input box
    binding to the **Input.RoleName** property:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EditForm**组件内部，添加一个段落，并将可编辑的输入框绑定到**Input.RoleName**属性：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Complete the **EditForm** component by adding a form submit button below the
    role name input:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在角色名称输入下方添加一个表单提交按钮来完善**EditForm**组件：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **Program.cs** file of the server-side project
    and locate the section where we register identity services. It’s a section starting
    with an **AddIdentityCore()** method and producing an **IdentityBuilder** object.
    In *step 2* , we invoke the **AddRoles()** method to add role management capabilities
    to the identity system. The **AddRoles()** method is a generic method requiring
    an identity role model class. We leverage the default **IdentityRole** model,
    provided with an identity package. The **IdentityRole** model is enough for our
    needs. Next, below the **AddEntityFrameworkStores()** method, we register the
    role manager using the **AddRoleManager()** builder method with the default **RoleManager**
    service for the **IdentityRole** model. We’ve effectively enabled roles’ support
    and roles’ management in the app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们导航到服务器端项目的**Program.cs**文件，并找到注册身份服务的那部分。这是一个以**AddIdentityCore()**方法开始的段落，并生成一个**IdentityBuilder**对象。在*步骤
    2*中，我们调用**AddRoles()**方法向身份系统添加角色管理功能。**AddRoles()**方法是一个泛型方法，需要一个身份角色模型类。我们利用随身份包提供的默认**IdentityRole**模型，这个模型足以满足我们的需求。接下来，在**AddEntityFrameworkStores()**方法下方，我们使用**AddRoleManager()**构建方法注册角色管理器，使用默认的**RoleManager**服务为**IdentityRole**模型。我们有效地在应用程序中启用了角色支持和角色管理。
- en: In *step 3* , we move to the **Settings** component. First, we add a set of
    **@using** directives below **@page** to reference the necessary assemblies, allowing
    access to the scaffolded **Account** area and built-in identity services. In *step
    4* , we inject the **RoleManager** and **Navigation** services, handling role
    management and navigation, respectively. In *step 5* , we initialize the **@code**
    block in the **Settings** component. Within the **@code** block, we construct
    an **InputModel** class with a single **RoleName** property. The **InputModel**
    class will hold the details of the new role when a user fills out the form. In
    *step 6* , we intercept a cascading value of **HttpContext** to access the current
    HTTP context – necessary for communicating role creation status later. The **HttpContext**
    object didn’t appear magically – when Blazor renders in SSR mode, it exposes the
    **HttpContext** instance cascadingly by default. In *step 7* , below **HttpContext**
    , we declare an **Input** parameter supplied from a form and override the **OnInitialized()**
    lifecycle method to complete the form initialization pattern. You can learn more
    about building forms in [*Chapter 6*](B22020_06.xhtml#_idTextAnchor203) . In *step
    8* , we complete the **@code** block by implementing a **SaveAsync()** method.
    In **SaveAsync()** , we initialize a new **IdentityRole** object and leverage
    **RoleManager** to save the new role to a database. We use the **Navigation**
    service and **HttpContext** to perform a self-redirect and send an operation status
    back to the user.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们移动到**设置**组件。首先，我们在**@page**下方添加一组**@using**指令来引用必要的程序集，以便访问生成的**Account**区域和内置的身份服务。在*步骤
    4*中，我们注入**RoleManager**和**Navigation**服务，分别处理角色管理和导航。在*步骤 5*中，我们在**设置**组件中初始化**@code**块。在**@code**块内部，我们构建了一个具有单个**RoleName**属性的**InputModel**类。当用户填写表单时，**InputModel**类将保存新角色的详细信息。在*步骤
    6*中，我们拦截**HttpContext**的级联值以访问当前的HTTP上下文——这对于稍后通信角色创建状态是必要的。**HttpContext**对象并非神奇地出现——当Blazor以SSR模式渲染时，它默认级联暴露**HttpContext**实例。在*步骤
    7*中，在**HttpContext**下方，我们声明了一个由表单提供的**Input**参数，并覆盖了**OnInitialized()**生命周期方法以完成表单初始化模式。您可以在[*第
    6 章*](B22020_06.xhtml#_idTextAnchor203)中了解更多关于构建表单的信息。在*步骤 8*中，我们通过实现**SaveAsync()**方法来完成**@code**块。在**SaveAsync()**中，我们初始化一个新的**IdentityRole**对象，并利用**RoleManager**将新角色保存到数据库。我们使用**Navigation**服务和**HttpContext**执行自我重定向并向用户发送操作状态。
- en: In *step 9* , we switch to the **Settings** markup. First, we locate the **AuthorizeView**
    tags. The **AuthorizeView** component is a generic component, so it exposes a
    **Context** property. Likewise, **EditForm** , which we will use for our form,
    is also a generic component having a **Context** property. We will have a conflict,
    and the app will not compile! To resolve that issue, we give a custom name to
    the **Context** property of **AuthorizeView** . We also replace the existing authentication
    status message with a **StatusMessage** component. The **StatusMessage** component
    intercepts **HttpContext** and resolves the status message from a designated cookie.
    That’s why we needed **HttpContext** in the **@code** block – to attach that status
    cookie correctly. In *step 10* , we initialize an **EditForm** component below
    **StatusMessage** , attaching the **Input** model and the **SaveAsync()** method
    to the **Model** and **OnValidSubmit** parameters, respectively. We also declare
    a unique **FormName** class for **EditForm** . Within **EditForm** , in *step
    11* , we add a paragraph with an editable input box binding to the **Input.RoleName**
    property, allowing the user to enter the new role name. Finally, in *step 12*
    , we complete the **EditForm** component by adding a form submit button below
    the role name input.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 9*中，我们切换到**设置**标记。首先，我们定位到**AuthorizeView**标签。**AuthorizeView**组件是一个通用组件，因此它暴露了一个**Context**属性。同样，我们将用于我们的表单的**EditForm**也是一个具有**Context**属性的通用组件。我们将遇到冲突，并且应用程序将无法编译！为了解决这个问题，我们给**AuthorizeView**的**Context**属性赋予一个自定义名称。我们还用**StatusMessage**组件替换了现有的身份验证状态消息。**StatusMessage**组件拦截**HttpContext**并从指定的cookie中解析状态消息。这就是为什么我们需要在**@code**块中包含**HttpContext**的原因——以便正确地附加状态cookie。在*步骤
    10*中，我们在**StatusMessage**下方初始化一个**EditForm**组件，将**Input**模型和**SaveAsync()**方法分别附加到**Model**和**OnValidSubmit**参数上。我们还为**EditForm**声明了一个唯一的**FormName**类。在**EditForm**内部，在*步骤
    11*中，我们添加了一个段落，其中包含一个可编辑的输入框绑定到**Input.RoleName**属性，允许用户输入新的角色名称。最后，在*步骤 12*中，我们通过在角色名称输入下方添加一个表单提交按钮来完成**EditForm**组件。
- en: Modifying a user’s identity
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改用户身份
- en: Modifying a user’s identity can be crucial for tailoring your application’s
    functionality and improving user experience. Having additional identity properties,
    you can enable more personalized interactions and better manage user-specific
    information. In many applications, a username is equivalent to a user’s email,
    and that’s not enough details for displaying personalized greetings, sending customized
    notifications, or generating reports. But worry not. In Blazor, identity is highly
    flexible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 修改用户的身份对于定制应用程序的功能和提升用户体验至关重要。拥有额外的身份属性，你可以启用更多个性化的交互并更好地管理特定于用户的信息。在许多应用程序中，用户名等同于用户的电子邮件，但这不足以显示个性化的问候、发送定制的通知或生成报告。但不用担心。在Blazor中，身份非常灵活。
- en: Let’s allow a user to fill in their first and last name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户填写他们的名字和姓氏。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before extending the user’s identity, do the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展用户的身份之前，执行以下操作：
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe05**
    directory – this will be your working directory
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端项目中创建一个**Components** / **Recipes** / **Recipe05**目录——这将是你的工作目录
- en: Copy the **Settings** component from the *Creating roles* recipe or from the
    **Components** / **Recipes** / **Recipe03** directory in the GitHub repository
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*Creating roles*配方或从GitHub仓库中的**Components** / **Recipes** / **Recipe03**目录复制**Settings**组件
- en: Find the **seed-work.sql** script in the **Samples** directory of the server-side
    project in the GitHub repository and run it on your database
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitHub仓库中服务器端项目的**Samples**目录中找到**seed-work.sql**脚本并在你的数据库上运行它
- en: If you haven’t scaffolded your project, copy the **StatusMessage** component
    from the **Components** / **Account** / **Shared** directory of the GitHub repository
    to the same path in your server-side project
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有生成项目，从GitHub仓库的**Components** / **Account** / **Shared**目录复制**StatusMessage**组件到服务器端项目的相同路径
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to extend the default user identity model:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤扩展默认的用户身份模型：
- en: 'Navigate to the **ApplicationUser** class in the **Data** directory of the
    server-side project and extend it with **FirstName** and **LastName** properties:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到服务器端项目**Data**目录中的**ApplicationUser**类，并扩展它以包含**FirstName**和**LastName**属性：
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the **Package Manager Console** , call an Entity Framework command to
    generate a new **AddedUserFullName** database migration:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Package Manager Console**，调用Entity Framework命令生成新的**AddedUserFullName**数据库迁移：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, if you’re using the .NET CLI, generate the same migration using
    the following command:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果你使用.NET CLI，使用以下命令生成相同的迁移：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will get a few new files in the **Data** / **Migrations** directory:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在**Data** / **Migrations**目录中获得一些新的文件：
- en: '![Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser
    in database](img/Figure_8.9_B22020.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：向数据库中的ApplicationUser添加FirstName和LastName属性的迁移文件](img/Figure_8.9_B22020.jpg)'
- en: 'Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser
    in database'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：向数据库中的ApplicationUser添加FirstName和LastName属性的迁移文件
- en: 'Apply the **AddedUserFullName** migration to the database by calling another
    command in the **Package** **Manager Console** :'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**Package Manager Console**中调用另一个命令将**AddedUserFullName**迁移应用到数据库：
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, if you’re using the .NET CLI, update the database using the
    following command:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果你使用.NET CLI，使用以下命令更新数据库：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the **Settings** component and add one more **@using** directive, next
    to the existing ones:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Settings**组件，并在现有指令旁边添加一个额外的**@using**指令：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Below, in the section with injections, replace the **RoleManager** service
    with **IdentityUserAccessor** , **UserManager** , and **SignInManager** services.
    Keep the already available **Navigation** service:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的注入部分，将**RoleManager**服务替换为**IdentityUserAccessor**、**UserManager**和**SignInManager**服务。保留已可用的**Navigation**服务：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the **@code** block, update the **InputModel** class by replacing the existing
    properties with **FirstName** and **LastName** :'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**@code**块中，通过用**FirstName**和**LastName**替换现有属性来更新**InputModel**类：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Above the existing **SaveAsync()** method, declare a private **ApplicationUser**
    field:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的**SaveAsync()**方法上方，声明一个私有的**ApplicationUser**字段：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Below the **_user** declaration, override the **OnInitializedAsync()** lifecycle
    method. Leverage the **UserAccessor** instance to get the user details from the
    database and hydrate the **Input** model:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**_user**声明下方，重写**OnInitializedAsync()**生命周期方法。利用**UserAccessor**实例从数据库获取用户详情并填充**Input**模型：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To complete the **@code** block, update the **SaveAsync()** method so that
    it updates **_user** details from the filled **Input** model, persist changes
    with the help of **UserManager** , and refresh the user context using **SignInManager**
    . Lastly, update the status message returned to the user:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成**@code**块，更新**SaveAsync()**方法，使其从填充的**Input**模型更新**_user**详细信息，借助**UserManager**持久化更改，并使用**SignInManager**刷新用户上下文。最后，更新返回给用户的提示信息：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Jump to the **Settings** markup area and locate the content area of the existing
    **EditForm** component.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**设置**标记区域，找到现有**EditForm**组件的内容区域。
- en: 'Update the existing input label to **First Name** and fix the binding to the
    **Input.FirstName** property:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新现有的输入标签为**First Name**，并将绑定修复到**Input.FirstName**属性：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Below the first name, add a paragraph displaying another editable input binding
    to the **Input.LastName** property:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在姓名下方添加一个段落，显示另一个可编辑的输入绑定到**Input.LastName**属性：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **ApplicationUser** class in the **Data** directory
    of the server-side project. The **ApplicationUser** class represents the user
    of our application and currently inherits from the default **IdentityUser** class
    to be compatible with the identity schema. Now, we extend our user identity details
    with **FirstName** and **LastName** properties. In *step 2* , we extend the identity
    database using a database migration. Database migrations are a way to manage and
    apply incremental changes to the database schema over time. They allow developers
    to define changes to the database structure, such as adding or modifying tables
    and columns, in code, ensuring that the database is in sync with the application.
    We open the **Package Manager Console** , available in Visual Studio, and generate
    a new **AddedUserFullName** database migration. The Entity Framework tool will
    generate two new files in the **Data** / **Migrations** directory. In *step 3*
    , we apply the **AddedUserFullName** migration to the database using the **Package
    Manager Console** again. We will not explore generated migrations or migration
    commands as they’re not in the scope of this book, but you can find additional
    resources in the *See also* section at the end of the recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们导航到服务器端项目的**Data**目录中的**ApplicationUser**类。**ApplicationUser**类代表我们应用程序的用户，目前从默认的**IdentityUser**类继承以兼容身份架构。现在，我们通过**FirstName**和**LastName**属性扩展我们的用户身份详细信息。在**步骤
    2**中，我们使用数据库迁移扩展了身份数据库。数据库迁移是一种管理并随时间应用数据库模式增量更改的方法。它们允许开发者在代码中定义对数据库结构的更改，例如添加或修改表和列，确保数据库与应用程序保持同步。我们打开Visual
    Studio中可用的**包管理器控制台**，并生成一个新的**AddedUserFullName**数据库迁移。Entity Framework工具将在**Data**/**Migrations**目录中生成两个新的文件。在**步骤
    3**中，我们再次使用**包管理器控制台**将**AddedUserFullName**迁移应用到数据库中。我们不会探索生成的迁移或迁移命令，因为它们不在本书的范围内，但你可以在食谱末尾的**参见**部分找到更多资源。
- en: Next, in *step 4* , we open the **Settings** component and extend the set of
    already existing **@using** directives with a reference to a **BlazorCookbook.Auth.Data**
    assembly, where we have the **ApplicationUser** class. In *step 5* , we remove
    the **RoleManager** service injection, as we won’t work with roles. Instead, we’re
    adding a few other identity services. We need **IdentityUserAccessor** to resolve
    the user context from the application **HttpContext** instance. With the help
    of **UserManager** and **SignInManager** , we can safely manipulate and refresh
    user details. In *step 6* , we update the **InputModel** class to support our
    new requirements and replace all existing properties with **FirstName** and **LastName**
    properties, matching the details we want to see on the new form later. At this
    point, you will see some IDE errors, as the existing form is no longer compatible
    with the updated **InputModel** class. We will fix that shortly. In *step 7* ,
    we declare a backing field – a private **ApplicationUser** variable to store a
    reference to the database object representing the currently logged-in user. We
    will use it to persist the first and last name the user provides. In *step 8*
    , we override the **OnInitializedAsync()** lifecycle method. We leverage the injected
    **UserAccessor** service to resolve the **ApplicationUser** object from **HttpContext**
    into the **_user** instance and hydrate the **Input** model with the found details.
    That way, we ensure the form is pre-populated with the current user’s details
    before the UI renders. To complete the **@code** block, in *step 9* , we update
    the **SaveAsync()** method so that it supports the updated **Input** model and
    saves user identity details. We update the persisted **_user** object with data
    coming from the form, filled by the user, and save those changes to the database
    with the help of **UserManager** . After updating, we refresh the user context
    using **SignInManager** and perform a self-redirect to display a **Your profile
    has been updated** message on the UI.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*步骤 4*中，我们打开**设置**组件，并将现有的**@using**指令集扩展到对**BlazorCookbook.Auth.Data**程序集的引用，其中包含**ApplicationUser**类。在*步骤
    5*中，我们移除了**RoleManager**服务注入，因为我们不会使用角色。相反，我们添加了一些其他的身份服务。我们需要**IdentityUserAccessor**来从应用程序的**HttpContext**实例中解析用户上下文。借助**UserManager**和**SignInManager**，我们可以安全地操作和刷新用户详情。在*步骤
    6*中，我们更新**InputModel**类以支持我们的新要求，并用**FirstName**和**LastName**属性替换所有现有属性，以匹配我们希望在新的表单中看到的详细信息。此时，你会看到一些
    IDE 错误，因为现有的表单不再与更新的**InputModel**类兼容。我们将很快解决这个问题。在*步骤 7*中，我们声明一个后置字段——一个私有的**ApplicationUser**变量，用于存储表示当前登录用户的数据库对象的引用。我们将使用它来持久化用户提供的第一个和最后一个名字。在*步骤
    8*中，我们重写**OnInitializedAsync()**生命周期方法。我们利用注入的**UserAccessor**服务从**HttpContext**解析**ApplicationUser**对象到**_user**实例，并用找到的详细信息填充**Input**模型。这样，我们确保在
    UI 渲染之前，表单已经预先填充了当前用户的详细信息。为了完成**@code**块，在*步骤 9*中，我们更新**SaveAsync()**方法，使其支持更新的**Input**模型并保存用户身份详情。我们使用来自表单的数据更新持久化的**_user**对象，并借助**UserManager**将这些更改保存到数据库。更新后，我们使用**SignInManager**刷新用户上下文，并执行自我重定向以在
    UI 上显示**您的个人资料已更新**的消息。
- en: Next, in *step 10* , we jump to the **Settings** markup area and locate the
    existing **EditForm** component. We will adjust the form to support filling in
    the user’s first and last names. In *step 11* , we fix the no longer compatible
    input box by binding it to the **Input.FirstName** property. We also update the
    label to **First name** , to make it clear which field the user is updating. Similarly,
    in *step 12* , we add a paragraph with another editable input box with a **Last
    name** label and binding to the **Input.LastName** property.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*步骤 10*中，我们跳转到**设置**标记区域并定位现有的**EditForm**组件。我们将调整表单以支持填写用户的第一个和最后一个名字。在*步骤
    11*中，我们通过将其绑定到**Input.FirstName**属性来修复不再兼容的输入框。我们还更新了标签为**First name**，以清楚地表明用户正在更新哪个字段。同样，在*步骤
    12*中，我们添加了一个段落，包含另一个可编辑的输入框，带有**Last name**标签并将其绑定到**Input.LastName**属性。
- en: 'With the form in place, you can run the app and update the first and last name
    of the account you’ll be using. When you fill the inputs and save the changes,
    you’ll receive a friendly confirmation message:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单就绪后，你可以运行应用程序并更新你将使用的账户的第一个和最后一个名字。当你填写输入并保存更改时，你会收到一个友好的确认消息：
- en: '![Figure 8.10: Status message confirming that changes were successfully applied](img/Figure_8.10_B22020.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10：确认更改成功应用的状态消息](img/Figure_8.10_B22020.jpg)'
- en: 'Figure 8.10: Status message confirming that changes were successfully applied'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：确认更改成功应用的状态消息
- en: 'You can also check changes in the database by displaying the records in the
    **AspNetUsers** table:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过显示**AspNetUsers**表中的记录来检查数据库中的更改：
- en: '![Figure 8.11: Reviewing first and last name updates in the database](img/Figure_8.11_B22020.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：在数据库中查看姓名更新](img/Figure_8.11_B22020.jpg)'
- en: 'Figure 8.11: Reviewing first and last name updates in the database'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：在数据库中查看姓名更新
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this recipe, we’ve touched on the concept of database migrations. It’s a
    topic deserving a book of its own, but if you’d like to learn more, go to the
    learning resources prepared by the Microsoft team: [https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations)
    .'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们提到了数据库迁移的概念。这是一个值得单独成书的话题，但如果你想了解更多，请访问微软团队准备的学习资源：[https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations)。
- en: Supporting roles’ and policies’ authorization
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持角色和策略的授权
- en: Securing your application might not be just about having an authenticated user;
    it often requires more granular control. You may need to grant access to specific
    features or pages based on the user’s role. Blazor’s native authorization APIs
    – the **Authorize** attribute and the **AuthorizeView** component – support both
    roles and policies that you will find familiar from MVC applications or REST APIs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的应用程序可能不仅仅是关于拥有一个经过身份验证的用户；它通常需要更细粒度的控制。你可能需要根据用户的角色授予对特定功能或页面的访问权限。Blazor的本地授权API
    – **Authorize**属性和**AuthorizeView**组件 – 支持从MVC应用程序或REST API中熟悉的角色和策略。
- en: Let’s implement roles and policies, fine-tuning a settings page to display different
    content for administrators and standard users.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现角色和策略，微调设置页面以显示管理员和标准用户的不同内容。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we put policies and roles in place, do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实施策略和角色之前，请执行以下操作：
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe06**
    directory – this will be your working directory.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端项目中，创建**Components** / **Recipes** / **Recipe06**目录 – 这将是你的工作目录。
- en: Copy the **Settings** component from the *Modifying a user’s identity* recipe
    or from the **Components** / **Recipes** / **Recipe05** directory in the GitHub
    repository.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*修改用户身份*菜谱或从GitHub仓库中的**Components** / **Recipes** / **Recipe05**目录复制**Settings**组件。
- en: If you haven’t run migrations yet, find the **seed-work.sql** script in the
    **Samples** directory of the server-side project and run it on your database.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有运行迁移，请在服务器端项目的**Samples**目录中找到**seed-work.sql**脚本，并在你的数据库上运行它。
- en: If you’re not following along, make sure you have roles’ support enabled in
    your server-side project; you must leverage the **AddRoles()** builder API method,
    which we discussed in the *Creating* *roles* recipe.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有跟随操作，请确保你的服务器端项目中启用了角色支持；你必须利用我们在*创建* *角色*菜谱中讨论的**AddRoles()**构建器API方法。
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To add roles’ and policies’ support, both on the server and client side, follow
    these steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器和客户端都添加角色和策略支持，请按照以下步骤操作：
- en: Navigate to the **Program.cs** file in the **BlazorCookbook.Auth.Client** project
    – the client-side application.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**BlazorCookbook.Auth.Client**项目中的**Program.cs**文件 – 客户端应用程序。
- en: 'In the **Program.cs** file, find the **AddAuthorizationCore()** method call
    and overload it with **options** to configure the **InternalEmployee** policy
    that checks if a user’s email belongs to the **@** **packt.com** domain:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Program.cs**文件中，找到**AddAuthorizationCore()**方法调用，并使用**options**对其进行重载以配置检查用户电子邮件是否属于**@**
    **packt.com**域的**InternalEmployee**策略：
- en: '[PRE32]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Still on the client side, open the **UserInfo** class and extend it with a
    **Role** property:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在客户端，打开**UserInfo**类，并扩展它以包含**Role**属性：
- en: '[PRE33]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, navigate to the **PersistentAuthenticationStateProvider** class, and
    in the constructor, extend the **claims** array to include the newly added **Role**
    value:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到**PersistentAuthenticationStateProvider**类，并在构造函数中扩展**claims**数组以包括新添加的**Role**值：
- en: '[PRE34]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Switch to the server-side application and open the **Program.cs** file of the
    **BlazorCookbook.Auth** project.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到服务器端应用程序，并打开**BlazorCookbook.Auth**项目的**Program.cs**文件。
- en: 'Locate where the app is built, and just before that, use the authorization
    builder to add the same **InternalEmployee** policy as on the client side:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到应用程序构建的位置，并在那里之前，使用授权构建器添加与客户端相同的**InternalEmployee**策略：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Navigate to an **OnPersistingAsync** method of a **PersistingRevalidatingAuthenticationStateProvider**
    class and extend the logic executed for the authenticated user to append the role
    to the **UserInfo** class that Blazor will send over to the client side:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **PersistingRevalidatingAuthenticationStateProvider** 类的 **OnPersistingAsync**
    方法，并扩展为认证用户执行的逻辑，以便将角色追加到 Blazor 将发送到客户端的 **UserInfo** 类：
- en: '[PRE36]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Open the **Settings** component, and below the **@page** directive, add the
    **Authorize** attribute overloaded with the **InternalEmployee** policy:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Settings** 组件，在 **@page** 指令下方，添加一个使用 **InternalEmployee** 策略的 **Authorize**
    属性重载：
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the **Settings** markup, find the existing **AuthorizeView** opening tag
    and set the **Roles** parameter to allow **Support** and **Admin** roles:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Settings** 标记中，找到现有的 **AuthorizeView** 开启标签，并将 **Roles** 参数设置为允许 **Support**
    和 **Admin** 角色：
- en: '[PRE38]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Below the **EditForm** protected area, construct another **AuthorizeView**
    section, protecting a **Shut down the app** button and rendering the content only
    for users in the **Admin** role:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EditForm** 受保护区域下方，构建另一个 **AuthorizeView** 部分，保护一个 **关闭应用程序** 按钮，并且只为 **Admin**
    角色的用户渲染内容：
- en: '[PRE39]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We’re starting with the client-side application, so in *step 1* , we navigate
    to the **Program.cs** file in the **BlazorCookbook.Auth.Client** project. In *step
    2* , we extend the authorization registration by finding the **AddAuthorizationCore()**
    method call and overloading it with options to configure the **InternalEmployee**
    policy. We leverage the **AuthorizationPolicyBuilder** class, which we call **policy**
    , to check if a currently logged-in user’s email belongs to the **@packt.com**
    domain. The **AuthorizationPolicyBuilder** class supports custom assertions (which
    we used) as well as checking claims, usernames, or .NET native **IAuthorizationRequirement**
    objects. In *step 3* , we open the **UserInfo** class and extend it with a **Role**
    property. The **UserInfo** class is a model that Blazor uses to share user identity
    details across render mode boundaries. As we need the WebAssembly side to resolve
    user roles correctly, we must pass them there explicitly. In *step 4* , we complete
    the client-side configuration by extending the constructor of the **PersistentAuthenticationStateProvider**
    class. Blazor uses **PersistentAuthenticationStateProvider** to determine the
    user’s authentication state that arrives from the server side. In the constructor,
    we deserialize the state into a **UserInfo** object and extend the **claims**
    array to include the value of the newly added **Role** property. Now, whenever
    our application runs locally in the browser, the user’s role will still be available
    to verify against.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从客户端应用程序开始，因此在第 *1* 步中，我们导航到 **BlazorCookbook.Auth.Client** 项目的 **Program.cs**
    文件。在第 *2* 步中，我们通过找到 **AddAuthorizationCore()** 方法调用并使用配置 **InternalEmployee**
    策略的选项来扩展授权注册。我们利用 **AuthorizationPolicyBuilder** 类（我们称之为 **policy**），来检查当前登录用户的电子邮件是否属于
    **@packt.com** 域。**AuthorizationPolicyBuilder** 类支持自定义断言（我们使用了）以及检查声明、用户名或 .NET
    原生的 **IAuthorizationRequirement** 对象。在第 *3* 步中，我们打开 **UserInfo** 类，并扩展它以包含一个 **Role**
    属性。**UserInfo** 类是 Blazor 用于在渲染模式边界之间共享用户身份细节的模型。由于我们需要 WebAssembly 端正确解析用户角色，我们必须明确地将它们传递到那里。在第
    *4* 步中，我们通过扩展 **PersistentAuthenticationStateProvider** 类的构造函数来完成客户端配置。Blazor
    使用 **PersistentAuthenticationStateProvider** 来确定从服务器端到达的用户认证状态。在构造函数中，我们将状态反序列化为
    **UserInfo** 对象，并将 **claims** 数组扩展以包含新添加的 **Role** 属性的值。现在，无论我们的应用程序在浏览器中以本地方式运行，用户的角色都将仍然可用以进行验证。
- en: In *step 5* , we switch to the server-side application and open the **Program.cs**
    file of the **BlazorCookbook.Auth** project. In *step 6* , we locate where we
    invoke the **builder.Build()** method to build the app. Right before that, we
    add the same **InternalEmployee** policy as on the client side with the help of
    the authorization builder. As the policy assertion is indeed the same, the server
    API for configuring authorization is slightly different. We invoke the **AddAuthorizationBuilder()**
    method to access the **AuthorizationBuilder** instance as it exposes the **AddPolicy()**
    builder method. In *step 7* , we complete the server-side implementation by navigating
    to the **OnPersistingAsync** method of the **PersistingRevalidatingAuthenticationStateProvider**
    class. That’s the service Blazor uses when passing the user’s identity to the
    browser. We locate the logic for the authenticated user. It already contains the
    sharing of the user’s ID and email. We follow the same implementation pattern
    by grabbing the value of **RoleClaimType** from the current **principal** value
    and passing it on to the **UserRole** object that Blazor will persist as JSON
    inside the outgoing response.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们切换到服务器端应用程序并打开**BlazorCookbook.Auth**项目的**Program.cs**文件。在*步骤6*中，我们定位到调用**builder.Build()**方法以构建应用程序的位置。在那之前，我们使用授权构建器添加与客户端相同的**InternalEmployee**策略。由于策略断言确实相同，因此配置授权的服务器API略有不同。我们调用**AddAuthorizationBuilder()**方法来访问**AuthorizationBuilder**实例，因为它公开了**AddPolicy()**构建方法。在*步骤7*中，我们通过导航到**PersistingRevalidatingAuthenticationStateProvider**类的**OnPersistingAsync**方法来完成服务器端实现。这是Blazor在将用户的身份传递到浏览器时使用的服务。我们定位到认证用户的逻辑。它已经包含了共享用户的ID和电子邮件。我们通过从当前的**principal**值中获取**RoleClaimType**的值并将其传递给Blazor将作为JSON持久化到输出响应中的**UserRole**对象，遵循相同的实现模式。
- en: Now, we put all that authorization implementation to the test. In *step 8* ,
    we open the **Settings** component and add the **Authorize** attribute. It requires
    a reference to the **Microsoft.AspNetCore.Authorization** assembly, so we grant
    that with the **@using** directive. Then, we leverage the overloading of the **Authorize**
    attribute. We can set the **Policy** property so that the user must meet it to
    access the **Settings** page. That’s where we finally use the **InternalEmployee**
    policy. In *step 9* , we continue to the **Settings** markup. We find the existing
    **AuthorizeView** opening tag, wrapping the form where users can fill in their
    first and last names. We set the **Roles** parameter to **Support** and **Admin**
    values, ensuring that the form renders only when the current user is in any of
    the expected roles. The **Roles** parameter accepts a **string** object, so you
    can provide one or multiple comma-separated roles. You can also have as many protected
    markup areas as you need within the same component. In *step 10* , we construct
    another **AuthorizeView** area below the one already existing. Inside, we construct
    an idle **Shut down the app** button, but we ensure it renders only for users
    in the **Admin** role.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将所有这些授权实现付诸实践。在*步骤8*中，我们打开**Settings**组件并添加**Authorize**属性。它需要一个对**Microsoft.AspNetCore.Authorization**程序集的引用，所以我们使用**@using**指令授予它。然后，我们利用**Authorize**属性的过载功能。我们可以设置**Policy**属性，以便用户必须满足它才能访问**Settings**页面。这就是我们最终使用**InternalEmployee**策略的地方。在*步骤9*中，我们继续到**Settings**标记。我们找到现有的**AuthorizeView**打开标签，它包裹着用户可以填写他们的名字和姓氏的表单。我们将**Roles**参数设置为**Support**和**Admin**值，确保只有当前用户处于预期的任何角色时，表单才会渲染。**Roles**参数接受一个**string**对象，因此您可以提供一个或多个以逗号分隔的角色。您也可以在同一个组件中拥有所需数量的受保护标记区域。在*步骤10*中，我们在已存在的**AuthorizeView**区域下方构建另一个区域。在内部，我们构建一个空闲的**关闭应用程序**按钮，但我们确保它只为**Admin**角色的用户渲染。
- en: We arrive at a fully functional, secure view that adjusts dynamically to whoever
    is viewing it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个完全功能、安全的视图，它可以动态地调整给任何查看它的人。
- en: '*Figure 8* *.12* shows the store settings to the user with the **Admin** role:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.12*显示了具有**Admin**角色的用户看到的存储设置：'
- en: '![Figure 8.12: Store settings that an admin@packt.com user sees](img/Figure_8.12_B22020.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：显示给admin@packt.com用户的存储设置](img/Figure_8.12_B22020.jpg)'
- en: 'Figure 8.12: Store settings that an admin@packt.com user sees'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：显示给admin@packt.com用户的存储设置
- en: '*Figure 8* *.13* shows the store settings to the user with the **Support**
    role:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.13*显示了具有**Support**角色的用户看到的存储设置：'
- en: '![Figure 8.13: Store settings that a support@packt.com user sees](img/Figure_8.13_B22020.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：显示给support@packt.com用户的存储设置](img/Figure_8.13_B22020.jpg)'
- en: 'Figure 8.13: Store settings that a support@packt.com user sees'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：支持@packt.com用户看到的存储设置
- en: As you can see, when I log in as **admin@packt.com** , which has the **Admin**
    role, I can see both the edit form and the most restricted **Shut down the app**
    button. But the moment I change to **support@packt.com** , the **Shut down the
    app** button is gone! I encourage you to check how the UI changes when you log
    in as **user@packt.com** .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我以**admin@packt.com**登录，该账户具有**管理员**角色，我可以看到编辑表单和最受限的**关闭应用程序**按钮。但当我切换到**support@packt.com**时，**关闭应用程序**按钮消失了！我鼓励您检查以**user@packt.com**登录时UI如何变化。
- en: There’s more…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The **Authorize** attribute supports the same authorization APIs that **AuthorizeView**
    does. Both can use **Roles** and **Policy** to verify the user’s identity against
    specific criteria. You can even use both **Roles** and **Policy** at the same
    time!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Authorize**属性支持与**AuthorizeView**相同的授权API。两者都可以使用**Roles**和**Policy**来验证用户的身份是否符合特定标准。您甚至可以同时使用**Roles**和**Policy**！'
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the **Authorize** attribute, we now verify whether the logged-in user
    has any of the three allowed roles: **User** , **Support** , or **Admin** . Additionally,
    we’ve updated the rendering of the user details edit form. Now, **AuthorizeView**
    displays the form to anyone meeting the **InternalEmployee** policy and having
    any of the available roles. We’ve also updated the restrictions on the **Shut
    down the app** button – the user has to have the **Admin** role and belong to
    the **@packt.com** domain, enforced by the **InternalEmployee** policy.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Authorize**属性，我们现在验证登录用户是否有以下三个允许的角色之一：**用户**、**支持**或**管理员**。此外，我们还更新了用户详细信息编辑表单的渲染。现在，**AuthorizeView**将表单显示给任何符合**内部员工**策略并且拥有任何可用角色的用户。我们还更新了**关闭应用程序**按钮的限制——用户必须拥有**管理员**角色并且属于**@packt.com**域，这是由**内部员工**策略强制执行的。
- en: The parameters of **Authorize** and **AuthorizeView** work similarly but are
    applied at different levels. The question remains when to use the attribute and
    when the component suits best. Use **Authorize** when protecting navigation to
    a given resource or page, ensuring that only authorized users can access it. On
    the other hand, use **AuthorizeView** when you need to restrict access to certain
    areas of the markup without affecting the overall routing. This approach provides
    a comprehensive way to secure your Blazor application, ensuring that only authorized
    users can access specific features and content.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**Authorize**和**AuthorizeView**的参数工作方式类似，但应用在不同的级别。问题仍然是何时使用属性，何时使用组件最为合适。当需要保护对给定资源或页面的导航，确保只有授权用户可以访问时，使用**Authorize**。另一方面，当您需要限制对标记中某些区域的访问而不影响整体路由时，使用**AuthorizeView**。这种方法为保护Blazor应用程序提供了一种全面的方式，确保只有授权用户可以访问特定的功能和内容。'
- en: Resolving authentication state in procedural logic
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在程序逻辑中解析认证状态
- en: Incorporating authentication and authorization into the procedural logic of
    your application is often necessary. Simply manipulating markup visibility may
    not suffice in these scenarios; you need to resolve the current authentication
    state to make informed decisions within your code. That’s where a cascading **AuthenticationState**
    class comes in. The **AuthenticationState** class is a built-in Blazor feature
    that provides information about the user’s authentication status and claims.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将身份验证和授权集成到应用程序的过程逻辑中通常是必要的。在这些场景中，仅仅操作标记可见性可能不够；您需要在代码中根据当前的认证状态做出明智的决定。这就是级联**AuthenticationState**类的作用所在。**AuthenticationState**类是一个内置的Blazor功能，它提供了有关用户认证状态和声明的信息。
- en: Let’s add a button that redirects internal employees to different areas of a
    ticketing system based on their roles.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个按钮，根据内部员工的角色将他们重定向到票务系统的不同区域。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we leverage authentication state in procedural logic, do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们利用程序逻辑中的认证状态之前，请执行以下操作：
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe07**
    directory – this will be your working directory
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端项目中，创建一个**Components** / **Recipes** / **Recipe07**目录——这将成为您的工作目录
- en: Copy the **FakePages** directory from the **Components** / **Recipes** / **Recipe07**
    directory in the GitHub repository
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库的**Components** / **Recipes** / **Recipe07**目录复制**FakePages**目录
- en: If you haven’t run migrations yet, find the **seed-work.sql** script in the
    **Samples** directory of the server-side project and run it on your database
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您还没有运行迁移，请在服务器端项目的**Samples**目录中找到**seed-work.sql**脚本，并在您的数据库上运行它
- en: As we will need to enable interactivity, we can’t use any of the existing **Settings**
    components anymore, so we will create a totally new one
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们需要启用交互性，我们不能再使用任何现有的**设置**组件，因此我们将创建一个全新的组件
- en: How to do it…
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these instructions to leverage authentication state in procedural logic:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明在过程逻辑中利用身份验证状态：
- en: 'Create a new routable **Settings** component with server-side interactivity
    and an injected **Navigation** service:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的具有服务器端交互和注入的**导航**服务的可路由**设置**组件：
- en: '[PRE41]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a **@code** block to intercept the cascading authentication state:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**@code**块来拦截级联身份验证状态：
- en: '[PRE42]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Below the **AuthState** parameter, initialize a **GoToTicketsAsync()** method
    and resolve the **user** context:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**AuthState**参数下方，初始化一个**GoToTicketsAsync()**方法并解析**用户**上下文：
- en: '[PRE43]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Below the **user** context, check if the user’s **Identity** property has a
    value and redirect to the login page if it’s missing:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**用户**上下文下方，检查用户的**身份**属性是否有值，如果缺失则重定向到登录页面：
- en: '[PRE44]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Below the **Identity** verification, check if the user is correctly authenticated
    and redirect to the login page if not:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**身份**验证之后，检查用户是否正确认证，如果没有则重定向到登录页面：
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After authentication verification, check if the value of the user’s **Name**
    property belongs to the **@packt.com** domain and, if not, redirect them to the
    landing page of the ticketing system:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在身份验证验证之后，检查用户**名称**属性的值是否属于**@packt.com**域名，如果不是，则将他们重定向到票务系统的着陆页：
- en: '[PRE46]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After the user’s domain check, check if the user is in the **Support** or **Admin**
    role and redirect them to the admin panel of the ticketing system:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户域检查之后，检查用户是否在**支持**或**管理员**角色中，并将他们重定向到票务系统的管理员面板：
- en: '[PRE47]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, if the user’s identity doesn’t fit any of the handled cases, redirect
    them to the access denied page:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果用户的身份不匹配任何已处理的案例，则将他们重定向到访问拒绝页面：
- en: '[PRE48]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Jump to the markup of the **Settings** component and add a button to navigate
    to the ticketing system:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**设置**组件的标记并添加一个按钮以导航到票务系统：
- en: '[PRE49]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a new routable **Settings** component, rendering in
    an **InteractiveServer** mode as we want our users to navigate to the ticketing
    system with a button click.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建一个新的可路由**设置**组件，以**交互式服务器**模式渲染，因为我们希望用户通过点击按钮导航到票务系统。
- en: If you follow along the entire chapter or have scaffolded your project, you
    will already have a cascading authentication state registered. But to give you
    a comprehensive overview, in both server- and client-side projects, in their **Program.cs**
    files, you will find (or add, if it’s missing) the **builder.Services.AddCascadingAuthenticationState()**
    command that explicitly enables cascading authentication state in your application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟完了整个章节或者已经搭建了你的项目，那么你将已经注册了级联身份验证状态。但为了给你一个全面的概述，在服务器端和客户端项目中，在它们的**Program.cs**文件中，你将找到（或者如果缺失则添加）**builder.Services.AddCascadingAuthenticationState()**命令，该命令明确启用了应用程序中的级联身份验证状态。
- en: In *step 2* , we initialize the **@code** block in the **Settings** component.
    Firstly, we intercept the authentication state. Blazor shares **AuthenticationState**
    as a **Task** parameter – in line with modern web development, where all operations
    are inherently asynchronous and as the **AuthenticationStateProvider** implementation
    might contain asynchronous logic constructing the authentication state. We also
    inject a **NavigationManager** service to help us redirect the user to the intended
    destination. For the next couple of steps, still inside the **@code** block, we
    implement a **GoToTicketsAsync()** method to resolve the redirection destination
    based on the user’s identity context. In *step 3* , we resolve the **user** object
    by awaiting **AuthState** and grabbing the **User** property from the result.
    In *step 4* , we check if the current user has an **Identity** value set, which
    can be **null** if the user hasn’t logged in yet. If the **Identity** value is
    missing, we immediately redirect the user to the login page. In *step 5* , we
    perform an additional check on the **Identity** value using the **IsAuthenticated**
    property to verify if the user is logged in and correctly authenticated. If that
    check fails, we redirect the user to the login page to revalidate their authentication
    state. Now that we are sure the current user has a valid identity, in *step 6*
    , we check if the user is actually an internal employee. We leverage the **Name**
    property of the **user** object, representing the user’s login in the application.
    As, in our case, the **Name** property is equivalent to the user’s email, we verify
    if the user account of the current user we check belongs to the **@packt.com**
    domain. If that check fails, we redirect the user to the **/tickets** page, where
    they can create new support tickets as standard application users. In *step 7*
    , knowing that an internal employee is using the application, we check if they
    have an **Admin** or **Support** role. If they do, we redirect them to the **/tickets/admin**
    page, where they can access the admin panel of the ticketing system. In *step
    8* , we close the implementation of the **GoToTicketsAsync()** method. When all
    the previous authentication and authorization checks fail, we assume the user’s
    account is incomplete and redirect them to the **/tickets/denied** page, indicating
    they can’t access the ticketing system.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们在**设置**组件中初始化**@code**块。首先，我们拦截身份验证状态。Blazor将**AuthenticationState**作为一个**Task**参数共享——与现代网络开发一致，所有操作本质上都是异步的，因为**AuthenticationStateProvider**实现可能包含构建身份验证状态的异步逻辑。我们还注入了一个**NavigationManager**服务来帮助我们重定向用户到目标位置。在接下来的几个步骤中，仍然在**@code**块内部，我们实现了一个**GoToTicketsAsync()**方法，根据用户的身份上下文解决重定向目标。在*步骤
    3*中，我们通过等待**AuthState**并从结果中获取**User**属性来解析**用户**对象。在*步骤 4*中，我们检查当前用户是否设置了**Identity**值，如果用户尚未登录，该值可以是**null**。如果**Identity**值缺失，我们立即将用户重定向到登录页面。在*步骤
    5*中，我们使用**IsAuthenticated**属性对**Identity**值进行额外检查，以验证用户是否已登录并正确认证。如果该检查失败，我们将用户重定向到登录页面以重新验证其身份验证状态。现在我们确信当前用户有一个有效的身份，在*步骤
    6*中，我们检查用户是否实际上是内部员工。我们利用**user**对象的**Name**属性，代表用户在应用程序中的登录。由于在我们的案例中，**Name**属性等同于用户的电子邮件，我们验证当前检查的用户账户是否属于**@packt.com**域名。如果该检查失败，我们将用户重定向到**/tickets**页面，在那里他们可以作为标准应用程序用户创建新的支持票证。在*步骤
    7*中，知道是内部员工在使用应用程序，我们检查他们是否有**Admin**或**Support**角色。如果有，我们将他们重定向到**/tickets/admin**页面，在那里他们可以访问票务系统的管理面板。在*步骤
    8*中，我们关闭**GoToTicketsAsync()**方法的实现。当所有之前的身份验证和授权检查都失败时，我们假设用户的账户不完整，并将他们重定向到**/tickets/denied**页面，表明他们无法访问票务系统。
- en: In *step 9* , we extend the **Settings** component markup. Below the existing
    **h3** header, we add a paragraph with a **button** property that invokes the
    **GoToTicketsAsync()** method upon click, allowing the user to navigate to the
    ticketing system. Effective redirection depends on the result of the procedural
    logic we added and the user’s identity.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 9*中，我们扩展了**设置**组件的标记。在现有的**h3**标题下方，我们添加了一个具有**按钮**属性的段落，该属性在点击时调用**GoToTicketsAsync()**方法，使用户能够导航到票务系统。有效的重定向取决于我们添加的程序逻辑的结果和用户的身份。
