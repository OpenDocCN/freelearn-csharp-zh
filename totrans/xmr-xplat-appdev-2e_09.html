<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Third-party Libraries</h1></div></div></div><p class="calibre8">Xamarin<a id="id584" class="calibre1"/> supports a subset of the .NET framework, but for the most part, it includes all the standard APIs you would expect in the .NET base class libraries. Because of this, a large portion of C#'s open source libraries can be used directly in Xamarin projects. Additionally, if an open source project doesn't have a Xamarin or portable class library version, porting the code to be used in a Xamarin project can often be very straightforward. Xamarin also supports calling native Objective-C and Java libraries, so we will explore these as additional means of reusing existing code.</p><p class="calibre8">In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem">The Xamarin Component Store</li><li class="listitem">NuGet</li><li class="listitem">Porting existing C# libraries</li><li class="listitem">Objective-C bindings</li><li class="listitem">Java bindings</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec64" class="calibre1"/>The Xamarin Component Store</h1></div></div></div><p class="calibre8">The<a id="id585" class="calibre1"/> primary and obvious way to add third-party components to your project is via the Xamarin Component Store. The Component Store is<a id="id586" class="calibre1"/> fairly similar to <strong class="calibre2">NuGet</strong>, which we will cover later, except that the Component Store also contains premium components that are not free. All Xamarin components are required to include full sample projects and a getting started guide, while NuGet does not inherently provide documentation in its packages.</p><p class="calibre8">All the <code class="literal">Xamarin.iOS</code> and <code class="literal">Xamarin.Android</code> projects come with a <code class="literal">Components</code> folder. To get started, simply right-click on the folder and select <strong class="calibre2">Get More Components</strong> to launch the store dialog, as shown in the following screenshot:</p><div><img src="img/00070.jpeg" alt="The Xamarin Component Store" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">At the <a id="id587" class="calibre1"/>time of writing this book, there are well over 200 components available to enhance your iOS and Android applications. This is a great place to find the most common components to use within your Xamarin applications. Each component is complete with artwork. You might possibly need a demonstration video, reviews, and other information before purchasing a premium component.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec38" class="calibre1"/>The most common components</h2></div></div></div><p class="calibre8">The most <a id="id588" class="calibre1"/>well-known and useful components are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Json.NET</strong>: This<a id="id589" class="calibre1"/> is the de facto <a id="id590" class="calibre1"/>standard for parsing and serializing JSON with C#</li><li class="listitem"><strong class="calibre2">RestSharp</strong>: This <a id="id591" class="calibre1"/>is a commonly <a id="id592" class="calibre1"/>used simple REST client for .NET</li><li class="listitem"><strong class="calibre2">SQLite.NET</strong>: This <a id="id593" class="calibre1"/>is a simple <a id="id594" class="calibre1"/><strong class="calibre2">Object</strong><a id="id595" class="calibre1"/><strong class="calibre2"> Relational Mapping</strong> (<strong class="calibre2">ORM</strong>) to use when working with local SQLite databases in your mobile applications</li><li class="listitem"><strong class="calibre2">Facebook SDK</strong>: This<a id="id596" class="calibre1"/> is the <a id="id597" class="calibre1"/>standard SDK provided by Facebook to integrate its services into your apps</li><li class="listitem"><strong class="calibre2">Xamarin.Mobile</strong>: This is a cross-platform library<a id="id598" class="calibre1"/> to access your device's contacts, GPS, photo library, and camera with a common API</li><li class="listitem"><strong class="calibre2">ActionBarSherlock</strong>: This<a id="id599" class="calibre1"/> is <a id="id600" class="calibre1"/>a powerful <code class="literal">ActionBar</code> replacement for Android</li></ul></div><p class="calibre8">Note that some of these libraries are native Java or Objective-C libraries, while some are plain C#. Xamarin is built from the ground up to support calling native libraries, so the Component Store offers many of the common libraries that Objective-C or Java developers would leverage when developing mobile applications.</p><p class="calibre8">You can also submit your own components to the Component Store. If you have a useful open source project or just want to earn some extra cash, creating a component is simple. We won't be covering it in this book, but you can navigate to <a class="calibre1" href="http://components.xamarin.com/submit">http://components.xamarin.com/submit</a> for full documentation on the subject, as shown in the following screenshot:</p><div><img src="img/00071.jpeg" alt="The most common components" class="calibre9"/></div><p class="calibre10"> </p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec65" class="calibre1"/>Porting existing C# libraries</h1></div></div></div><p class="calibre8">Even <a id="id601" class="calibre1"/>though Xamarin is becoming a popular platform, many open source .NET libraries are simply not up to speed with supporting <code class="literal">Xamarin.iOS</code> and <code class="literal">Xamarin.Android</code>. However, in these cases, you are definitely not out of luck. Often, if there is a Silverlight or Windows Phone version of the library, you can simply create an iOS or Android class library and add the files with no code changes.</p><p class="calibre8">To help with this process, Xamarin has created an online service tool to scan your existing code and determine how far off a library is from being portable. Navigate to <a class="calibre1" href="http://scan.xamarin.com">http://scan.xamarin.com</a> and upload any <code class="literal">*.exe</code> or <code class="literal">*.dll</code> file to have its methods analyzed for cross-platform development. After the scanning process, you'll get a report of the porting percentage (how much your component / application is portable to all platforms: Android, iOS, Windows Phone, and Windows Store).</p><p class="calibre8">The following screenshot is a sample report of the <strong class="calibre2">Lucene</strong> .NET client library:</p><div><img src="img/00072.jpeg" alt="Porting existing C# libraries" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If the library is running a high percentage on portability, you should have a relatively easy time porting it to Android or iOS. In most cases, it can even be easier to port the library to Xamarin than Windows Phone or WinRT.</p><p class="calibre8">To illustrate this process, let's port an open source project that doesn't have Xamarin or a portable class library support. I have selected a dependency injection library called <strong class="calibre2">Ninject</strong> due<a id="id602" class="calibre1"/> to<a id="id603" class="calibre1"/> its usefulness and relationship to ninjas. You can find out more about the library at <a class="calibre1" href="http://www.ninject.org">http://www.ninject.org</a>.</p><p class="calibre8">Let's begin <a id="id604" class="calibre1"/>setting up the library to work with Xamarin projects as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, download the source code for Ninject from <a class="calibre1" href="https://github.com/ninject/Ninject">https://github.com/ninject/Ninject</a>.</li><li class="listitem" value="2">Open <code class="literal">Ninject.sln</code> in Xamarin Studio.</li><li class="listitem" value="3">Add a new <strong class="calibre2">iOS Library Project</strong> named <code class="literal">Ninject.iOS</code>.</li><li class="listitem" value="4">Link all the files from the <code class="literal">Ninject</code> main project. Make sure you use the <strong class="calibre2">Add Existing Folder</strong> dialog to speed up this process.</li></ol><div></div><div><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre8">If you aren't familiar with GitHub, I recommend that you download the desktop client for Mac found at <a class="calibre1" href="http://mac.github.com">http://mac.github.com</a>.</p></div><p class="calibre8">Now try to build the <code class="literal">Ninject.iOS</code> project; you will get several compiler errors in a file named <code class="literal">DynamicMethodFactory.cs</code>, as shown in the following screenshot:</p><div><img src="img/00073.jpeg" alt="Porting existing C# libraries" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Open <code class="literal">DynamicMethodFactory.cs</code> and notice the following code at the top of the file:</p><div><pre class="programlisting">#if !NO_LCG
#region Using Directivesusing System;
  using System.Reflection;
  using System.Reflection.Emit;
  using Ninject.Components;
#endregion

/// *** File contents here ***

#endif</pre></div><p class="calibre8">It is not possible to use <code class="literal">System.Reflection.Emit</code> on iOS due to Apple's platform restrictions. Luckily, the library writers have created a preprocessor directive called <code class="literal">NO_LCG</code> (which stands for <strong class="calibre2">Lightweight Code Generation</strong>) to allow the library to run on platforms <a id="id605" class="calibre1"/>that <a id="id606" class="calibre1"/>do not support <code class="literal">System.Reflection.Emit</code>.</p><p class="calibre8">To fix our iOS project, open the project options and navigate to the <strong class="calibre2">Build</strong> | <strong class="calibre2">Compiler</strong> section. Add <code class="literal">NO_LCG</code> to the <strong class="calibre2">Define Symbols</strong> field for both <strong class="calibre2">Debug</strong> and <strong class="calibre2">Release</strong> in the <strong class="calibre2">Configuration</strong> drop-down menu. Click on <strong class="calibre2">OK</strong> to save your changes. Notice how the entire file is now highlighted with a light gray color in Xamarin Studio, as shown in the following screenshot. This means that the code will be omitted from being compiled.</p><div><img src="img/00074.jpeg" alt="Porting existing C# libraries" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If you compile the project now, it will be completed successfully and a <code class="literal">Ninject.iOS.dll</code> file will be created, which you can reference from any <code class="literal">Xamarin.iOS</code> project. You can also reference the <code class="literal">Ninject.iOS</code> project directly instead of using the <code class="literal">*.dll</code> file.</p><p class="calibre8">At this<a id="id607" class="calibre1"/> point, you might wish to repeat the process to create a <code class="literal">Xamarin.Android</code> class library project. Luckily, <code class="literal">Xamarin.Android</code> supports <code class="literal">System.Reflection.Emit</code>, so you can skip adding the additional preprocessor directive if you wish.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec66" class="calibre1"/>Objective-C bindings</h1></div></div></div><p class="calibre8">Xamarin<a id="id608" class="calibre1"/> has developed a sophisticated system to call native Objective-C libraries from C# in iOS projects. The core of <code class="literal">Xamarin.iOS</code> uses the <a id="id609" class="calibre1"/>same technology to call native Apple APIs in <strong class="calibre2">UIKit</strong>, <strong class="calibre2">CoreGraphics</strong>, and <a id="id610" class="calibre1"/>other iOS frameworks. Developers can create iOS binding projects to expose the Objective-C classes and methods to C# using simple interfaces and attributes.</p><p class="calibre8">To aid in creating Objective-C bindings, Xamarin has created a small tool named <strong class="calibre2">Objective Sharpie</strong> that <a id="id611" class="calibre1"/>can process Objective-C header files for you and export the valid C# definitions to add to a binding project. This tool is a great starting point for most bindings that will get your binding three-fourths of the way complete, and you will want to hand-edit and fine-tune things to be more C#-friendly in a lot of cases.</p><p class="calibre8">As an example, we will write a binding for the Google Analytics library for iOS. It is a simple and useful library that can track the user activities in your iOS or Android applications. At the time of writing, the version of the Google Analytics SDK was 3.10, so some of these instructions might change as new versions are released.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec39" class="calibre1"/>Working with Objective Sharpie</h2></div></div></div><p class="calibre8">First, download<a id="id612" class="calibre1"/> and install Objective Sharpie<a id="id613" class="calibre1"/> from <a class="calibre1" href="http://tinyurl.com/ObjectiveSharpie">http://tinyurl.com/ObjectiveSharpie</a>, then perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Download<a id="id614" class="calibre1"/> the latest Google Analytics SDK for iOS available at <a class="calibre1" href="https://tinyurl.com/GoogleAnalyticsForiOS">https://tinyurl.com/GoogleAnalyticsForiOS</a>.</li><li class="listitem" value="2">Create a new <strong class="calibre2">iOS Binding Project</strong> named <code class="literal">GoogleAnalytics.iOS</code>.</li><li class="listitem" value="3">Run <strong class="calibre2">Objective Sharpie</strong>.</li><li class="listitem" value="4">Select <strong class="calibre2">iOS 7.1</strong> as <strong class="calibre2">Target SDK</strong> and click on <strong class="calibre2">Next</strong>.</li><li class="listitem" value="5">Add all of the header (<code class="literal">*.h</code>) files included with the Google Analytics SDK; you can find these in the <code class="literal">Library</code> folder of the download. Click on <strong class="calibre2">Next</strong>.</li><li class="listitem" value="6">Pick a suitable namespace such as <code class="literal">GoogleAnalytics</code> and click on <strong class="calibre2">Generate</strong>.</li><li class="listitem" value="7">Copy the resulting <code class="literal">ApiDefinition.cs</code> file that was generated into your iOS binding project.</li><li class="listitem" value="8">After<a id="id615" class="calibre1"/> a few seconds, your C# file will be generated. Click on <strong class="calibre2">Quit</strong>.</li></ol><div></div><p class="calibre8">You should have not received any error messages from Objective Sharpie during the process, and when finished, your screen should look like the following screenshot:</p><div><img src="img/00075.jpeg" alt="Working with Objective Sharpie" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre8">At the time of writing this book, Objective Sharpie does not work properly with Xcode 6.0 and higher. I recommend that you download Xcode 5.1.1 if you run into this issue. You can install two versions of Xcode side by side by renaming an<a id="id616" class="calibre1"/> existing one in Finder and installing a second one. You can find older Xcode downloads at <a class="calibre1" href="https://developer.apple.com/downloads/index.action">https://developer.apple.com/downloads/index.action</a>.</p></div><p class="calibre8">Now if you return to your binding project, you'll notice that Objective Sharpie has generated an interface definition for every class discovered in the header files of the library. It has also generated many <code class="literal">enum</code> values that the library uses and changed casing and naming conventions to follow C# more closely where possible.</p><p class="calibre8">As you read through the binding, you'll notice several C# attributes that define different aspects about the Objective-C library such as the following:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">BaseType</code>: This <a id="id617" class="calibre1"/>declares an interface as an Objective-C class. The base class (also called superclass) is passed in to the attribute. If it has no base class, <code class="literal">NSObject</code> should be used.</li><li class="listitem"><code class="literal">Export</code>: This <a id="id618" class="calibre1"/>declares a method or property on an Objective-C class. A string that maps the Objective-C name to the C# name is passed in. Objective-C method names are generally in the following form: <code class="literal">myMethod:someParam:someOtherParam</code>.</li><li class="listitem"><code class="literal">Static</code>: This <a id="id619" class="calibre1"/>marks a method or property as <code class="literal">static</code> in C#.</li><li class="listitem"><code class="literal">Bind</code>: This <a id="id620" class="calibre1"/>is used on properties to map a getter or setter to a different Objective-C method. Objective-C properties can rename a getter or setter for a property.</li><li class="listitem"><code class="literal">NullAllowed</code>: This<a id="id621" class="calibre1"/> allows <code class="literal">null</code> to be passed to a method or property. By default, an exception is thrown if this occurs.</li><li class="listitem"><code class="literal">Field</code>: This <a id="id622" class="calibre1"/>declares an Objective-C field that is exposed as a public variable in C#.</li><li class="listitem"><code class="literal">Model</code>: This <a id="id623" class="calibre1"/>identifies a class to <code class="literal">Xamarin.iOS</code> to have methods that can be optionally overridden. This is generally used on Objective-C delegates.</li><li class="listitem"><code class="literal">Internal</code>: This <a id="id624" class="calibre1"/>flags the generated member with the C# internal keyword. It can be used to hide certain members that you don't want to expose to the outside world.</li><li class="listitem"><code class="literal">Abstract</code>: This<a id="id625" class="calibre1"/> identifies an Objective-C method as required, which goes hand in hand with <code class="literal">Model</code>. In C#, it will generate an abstract method.</li></ul></div><p class="calibre8">The only <a id="id626" class="calibre1"/>other rule to know is how to<a id="id627" class="calibre1"/> define constructors. Xamarin had to invent a convention for this since C# interfaces do not support constructors.</p><p class="calibre8">To define a constructor besides the default one, use the following code:</p><div><pre class="programlisting">[Export("initWithFrame:")]
IntPtr Constructor(RectangleF frame);</pre></div><p class="calibre8">This would define a constructor on the class that takes in <code class="literal">RectangleF</code> as a parameter. The method name <code class="literal">Constructor</code> and the return type <code class="literal">IntPtr</code> signal the Xamarin compiler to generate a constructor.</p><p class="calibre8">Now, let's return to our binding project to finish setting up everything. If you compile the project at this point, you'll get a few compiler errors. Let's fix them one by one as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Change the default namespace of the project to <code class="literal">GoogleAnalytics</code>. This setting is found in the project options by navigating to <strong class="calibre2">General</strong> | <strong class="calibre2">Main Settings</strong>.</li><li class="listitem" value="2">Add <code class="literal">libGoogleAnalyticsServices.a</code> from the SDK download to the project.</li><li class="listitem" value="3">Add <code class="literal">using</code> statements for <code class="literal">MonoTouch.Foundation</code>, <code class="literal">MonoTouch.UIKit</code>, and <code class="literal">MonoTouch.ObjCRuntime</code> at the top of the <code class="literal">ApiDefinition.cs</code> file.</li><li class="listitem" value="4">Remove<a id="id628" class="calibre1"/> the multiple <a id="id629" class="calibre1"/>duplicate declarations of <code class="literal">GAILogLevel</code>. You might also wish to move enumerations to the <code class="literal">StructsAndEnums.cs</code> file.</li><li class="listitem" value="5">Remove the declaration for <code class="literal">GAIErrorCode</code>.</li><li class="listitem" value="6">In the <code class="literal">SetAll</code> method of <code class="literal">GAIDictionaryBuilder</code>, rename the <code class="literal">params</code> parameter to <code class="literal">parameters</code>, as <code class="literal">params</code> is a reserved word in C#.</li><li class="listitem" value="7">Remove the duplicate declarations for <code class="literal">GAILogger</code>, <code class="literal">GAITracker</code>, <code class="literal">GAITrackedViewController</code>, and any other duplicate classes you find.</li><li class="listitem" value="8">Go through any <code class="literal">Field</code> declarations and change <code class="literal">[Field("Foobar")]</code> to <code class="literal">[Field("Foobar", "__Internal")]</code>. This tells the compiler where the field resides; in this case, it will be included internally in our binding project.</li><li class="listitem" value="9">Remove all the <code class="literal">Verify</code> attributes. These are spots where Objective Sharpie was unsure of the operation it performed. In our example, all of them are fine so it is safe to remove them.</li></ol><div></div><p class="calibre8">One more error remains regarding Objective Sharpie not being able to generate C# delegates for methods that have callbacks. Navigate to the GAI interface and change the following method:</p><div><pre class="programlisting">[Export ("dispatchWithCompletionHandler:")]void DispatchWithCompletionHandler (
    GAIDispatchResultHandler completionHandler);</pre></div><p class="calibre8">You <a id="id630" class="calibre1"/>will also need to define the <a id="id631" class="calibre1"/>following delegate at the top of this file:</p><div><pre class="programlisting">public delegate void GAIDispatchResultHandler(
    GAIDispatchResult result);</pre></div><p class="calibre8">After going through these issues, you should be able to compile the binding and get no errors. You could have read the Objective-C header files and written the definitions yourself by hand; however, using Objective Sharpie generally means a lot less work.</p><p class="calibre8">At this point, if you try to use the library in an iOS project, you would get an error such as the following:</p><div><pre class="programlisting">Error MT5210: Native linking failed, undefined symbol: 
    _FooBar. Please verify that all the necessary frameworks 
    have been referenced and native libraries are properly 
    linked in.</pre></div><p class="calibre8">We need to define the other frameworks and libraries that the Objective-C library uses. This is very similar to how references work in C#. If we review the Google Analytics documentation, it says that you must add <code class="literal">CoreData</code>, <code class="literal">SystemConfiguration</code>, and <code class="literal">libz.dylib</code>. Additionally, you must add a weak reference to <code class="literal">AdSupport</code>.</p><p class="calibre8">Open <code class="literal">libGoogleAnalyticsServices.linkwith.cs</code> that was created automatically nested underneath the <code class="literal">*.a</code> file and make the following changes:</p><div><pre class="programlisting">[assembly: LinkWith ("libGoogleAnalyticsServices.a",
  LinkTarget.ArmV7 | LinkTarget.ArmV7s | LinkTarget.Simulator,
  LinkerFlags = "-lz",
  Frameworks = "CoreData SystemConfiguration",
  WeakFrameworks = "AdSupport",
  ForceLoad = true)]
</pre></div><p class="calibre8">We added references to frameworks in the following ways:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Frameworks</strong>: Add <a id="id632" class="calibre1"/>them to the <code class="literal">Frameworks</code> value on the <code class="literal">LinkWith</code> attribute, delimited by spaces.</li><li class="listitem"><strong class="calibre2">Weak Frameworks</strong>: Add them to the <code class="literal">WeakFrameworks</code> property on the <code class="literal">LinkWith</code> attribute in the same manner. Weak frameworks are libraries that can be <a id="id633" class="calibre1"/>ignored if they are not found. In this case, <code class="literal">AdSupport</code> was added in iOS 6; however, this library will still work on older versions of iOS.</li><li class="listitem"><strong class="calibre2">Dynamic Libraries</strong>: Libraries such as <code class="literal">libz.dylib</code> can be declared in <code class="literal">LinkerFlags</code>. Generally, you drop the <code class="literal">.dylib</code> extension <a id="id634" class="calibre1"/>and replace <code class="literal">lib</code> with <code class="literal">–l</code>.</li></ul></div><p class="calibre8">After <a id="id635" class="calibre1"/>these changes are implemented, you <a id="id636" class="calibre1"/>will be able to successfully use the <a id="id637" class="calibre1"/>library from iOS projects. For complete documentation on Objective-C bindings, visit the Xamarin documentation site at <a class="calibre1" href="http://docs.xamarin.com/ios">http://docs.xamarin.com/ios</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>Java bindings</h1></div></div></div><p class="calibre8">In the same<a id="id638" class="calibre1"/> manner as iOS, Xamarin has provided full support for calling into Java libraries from C# with <code class="literal">Xamarin.Android</code>. The native Android SDKs function in this way and developers can leverage the <code class="literal">Android Java Bindings</code> project to take advantage of other native Java libraries in C#. The main difference here is that not a lot has to be done by hand in comparison to Objective-C bindings. The Java syntax is very similar to that of C#, so many mappings are exactly one-to-one. In addition, Java has metadata information included with its libraries, which Xamarin uses to automatically generate the C# code required for calling into Java.</p><p class="calibre8">As an example, let's make a binding for the Android version of the Google Analytics SDK. Before we <a id="id639" class="calibre1"/>begin, download the SDK from <a class="calibre1" href="http://tinyurl.com/GoogleAnalyticsForAndroid">http://tinyurl.com/GoogleAnalyticsForAndroid</a>. At the time of writing, the version of the Android SDK 3.01, so some of these instructions might change over time.</p><p class="calibre8">Let's begin <a id="id640" class="calibre1"/>creating a Java binding as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Start a new <code class="literal">Android Java Bindings Library</code> project in Xamarin Studio. You can use the same solution as we did for iOS if you wish.</li><li class="listitem" value="2">Name the project <code class="literal">GoogleAnalytics.Droid</code>.</li><li class="listitem" value="3">Add <code class="literal">libGoogleAnalyticsServices.jar</code> from the Android SDK to the project under the <code class="literal">Jars</code> folder. By default, the build action for the file will be <code class="literal">EmbeddedJar</code>. This packs the jar file into the DLL, which is the best option for ease of use.</li><li class="listitem" value="4">Build the project. You will get a few errors, which we'll address in a moment.</li></ol><div></div><p class="calibre8">Most of the time you spend working on Java bindings will be to fix small issues that prevent the generated C# code from compiling. Don't fret; a lot of libraries will work on the first try without having to make any changes at all. Generally, the larger the Java library is, the <a id="id641" class="calibre1"/>more work you have to do to get it working from <a id="id642" class="calibre1"/>C#.</p><p class="calibre8">The following <a id="id643" class="calibre1"/>are the types of issues you might run into:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Java obfuscation</strong>: If the library is run through an obfuscation tool such as <strong class="calibre2">ProGuard</strong>, the class and method names might not be valid C# names.</li><li class="listitem"><strong class="calibre2">Covariant return types</strong>: Java has different rules for return types in overridden virtual methods than C# does. For this reason, you might need to modify the return type for the generated C# code to compile.</li><li class="listitem"><strong class="calibre2">Visibility</strong>: The rules that Java has for accessibility are different from those of C#; the visibility of methods in subclasses can be changed. Sometimes, you will have to change visibility in C# to get it to compile.</li><li class="listitem"><strong class="calibre2">Naming collisions</strong>: Sometimes, the C# code generator can get things a bit wrong and generate two members or classes with the same name.</li><li class="listitem"><strong class="calibre2">Java generics</strong>: The use of generic classes in Java can often cause issues in C#.</li></ul></div><p class="calibre8">So before we get started on solving these issues in our Java binding, let's first clean up the namespaces in the project. Java namespaces are of the form <code class="literal">com.mycompany.mylibrary</code> by default, so let's change the definition to match C# more closely. In the <code class="literal">Transforms</code> directory of the project, open <code class="literal">Metadata.xml</code> and add the following XML tag inside the root metadata node:</p><div><pre class="programlisting">&lt;attr path="/api/package[@name='com.google.analytics.tracking
  .android']" name="managedName"&gt;GoogleAnalytics.Tracking&lt;/attr&gt;</pre></div><p class="calibre8">The <code class="literal">attr</code> node tells the Xamarin compiler what needs to be replaced in the Java definition with another value. In this case, we are replacing <code class="literal">managedName</code> of the package with <code class="literal">GoogleAnalytics.Tracking</code> because it will make much more sense in C#. The path value might look a bit strange, which is because it uses an XML matching query language named <strong class="calibre2">XPath</strong>. In general, just think of it as a pattern matching query for XML. For full <a id="id644" class="calibre1"/>documentation on <a id="id645" class="calibre1"/>XPath syntax, check out some of the many resources online such as <a class="calibre1" href="http://w3schools.com/xpath">http://w3schools.com/xpath</a>.</p><p class="calibre8">You might be asking yourself at this point, what is the XPath expression matching against? Return to Xamarin Studio and right-click on the solution at the top. Navigate to <strong class="calibre2">Display Options</strong> | <strong class="calibre2">Show All Files</strong>. Open <code class="literal">api.xml</code> under the <code class="literal">obj/Debug</code> folder. This is the Java definition file that describes all the types and methods within the Java library. If you notice, the XML here directly correlates to the XPath expressions we'll be writing.</p><p class="calibre8">In our next step, let's remove all the packages (or namespaces) we don't plan on using in this library. This is generally a good idea for large libraries since you don't want to waste time fixing issues with parts of the library you won't even be calling from C#. Note that it doesn't actually remove the Java code; it just prevents the generation of any C# declarations for calling it from C#.</p><p class="calibre8">Add the <a id="id646" class="calibre1"/>following declarations in <code class="literal">Metadata.xml</code>:</p><div><pre class="programlisting">&lt;remove-node
  path="/api/package[@name='com.google.analytics
  .containertag.common']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.analytics
  .containertag.proto']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.analytics
  .midtier.proto.containertag']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.android
  .gms.analytics.internal']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.android
  .gms.common.util']" /&gt;
&lt;remove-nodepath="/api/package[@name='com.google.tagmanager']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.tagmanager.proto']" /&gt;
&lt;remove-node
  path="/api/package[@name='com.google.tagmanager.protobuf.nano']" /&gt;
</pre></div><p class="calibre8">Now when you build the library, we can start resolving issues. The first error you will receive will be something like the following:</p><div><pre class="programlisting">GoogleAnalytics.Tracking.GoogleAnalytics.cs(74,74): 
    Error CS0234: The type or namespace name 'TrackerHandler' 
    does not exist in the namespace 'GoogleAnalytics.Tracking'. 
    Are you missing an assembly reference?</pre></div><p class="calibre8">If we locate <code class="literal">TrackerHandler</code> within the <code class="literal">api.xml</code> file, we'll see the following class declaration:</p><div><pre class="programlisting">&lt;class
  abstract="true" deprecated="not deprecated"
  extends="java.lang.Object"
  extends-generic-aware="java.lang.Object"
  final="false" name="TrackerHandler"
  static="false" visibility=""/&gt;</pre></div><p class="calibre8">So, can<a id="id647" class="calibre1"/> you spot the problem? We need to fill out the <code class="literal">visibility</code> XML attribute, which for some reason is blank. Add the following line to <code class="literal">Metadata.xml</code>:</p><div><pre class="programlisting">&lt;attr
  path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='TrackerHandler']"
  name="visibility"&gt;public&lt;/attr&gt;</pre></div><p class="calibre8">This XPath expression will locate the <code class="literal">TrackerHandler</code> class inside the <code class="literal">com.google.analytics.tracking.android</code> package and change <code class="literal">visibility</code> to <code class="literal">public</code>.</p><p class="calibre8">If you build the project now, it will complete successfully with one warning. In Java binding projects, it is a good idea to fix warnings since they generally indicate that a class or method is being omitted from the binding. Notice the following warning:</p><div><pre class="programlisting">GoogleAnalytics.Droid: Warning BG8102: 
    Class GoogleAnalytics.Tracking.CampaignTrackingService has   
    unknown base type android.app.IntentService (BG8102)  
    (GoogleAnalytics.Droid)</pre></div><p class="calibre8">To fix this issue, locate the type definition for <code class="literal">CampaignTrackingService</code> in <code class="literal">api.xml</code>, which is as follows:</p><div><pre class="programlisting">&lt;class
  abstract="false" deprecated="not deprecated"
  extends="android.app.IntentService"
  extends-generic-aware="android.app.IntentService"
  final="false" name="CampaignTrackingService"
  static="false" visibility="public"&gt;</pre></div><p class="calibre8">The way to fix the issue here is to change the base class to the <code class="literal">Xamarin.Android</code> definition for <code class="literal">IntentService</code>. Add the following code to <code class="literal">Metadata.xml</code>:</p><div><pre class="programlisting">&lt;attr
  path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='CampaignTrackingService']"
  name="extends"&gt;mono.android.app.IntentService&lt;/attr&gt;</pre></div><p class="calibre8">This changes the <code class="literal">extends</code> attribute to use the <code class="literal">IntentService</code> found in <code class="literal">Mono.Android.dll</code>. I located the Java name for this class by opening <code class="literal">Mono.Android.dll</code> in Xamarin Studio's <strong class="calibre2">Assembly Browser</strong>. Let's take a look at the <code class="literal">Register</code> attribute, as shown in the following screenshot:</p><div><img src="img/00076.jpeg" alt="Java bindings" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">To inspect the <code class="literal">*.dll</code> files in Xamarin Studio, you merely have to open them. You can also double-click on any assembly in the <code class="literal">References</code> folder in your project.</p><p class="calibre8">If you build <a id="id648" class="calibre1"/>the binding project now, we're left with one last error, which is as follows:</p><div><pre class="programlisting">GoogleAnalytics.Tracking.CampaignTrackingService.cs(24,24): 
    Error CS0507: 
    'CampaignTrackingService.OnHandleIntent(Intent)': 
    cannot change access modifiers when overriding 'protected'    
    inherited member 
    'IntentService.OnHandleIntent(Android.Content.Intent)' 
    (CS0507) (GoogleAnalytics.Droid)</pre></div><p class="calibre8">If you navigate to the <code class="literal">api.xml</code> file, you can see the definition for <code class="literal">OnHandleIntent</code> as follows:</p><div><pre class="programlisting">&lt;method
  abstract="false" deprecated="not deprecated" final="false"
  name="onHandleIntent" native="false" return="void"
  static="false" synchronized="false" visibility="public"&gt;</pre></div><p class="calibre8">We can see here that the Java method for this class is <code class="literal">public</code>, but the base class is <code class="literal">protected</code>. So, the best way to fix this is to change the C# version to <code class="literal">protected</code> as well. Writing an XPath expression to match this is a bit more complicated, but luckily Xamarin has an easy way to retrieve it. If you double-click on the error message in the <strong class="calibre2">Errors</strong> pad of Xamarin Studio, you'll see the following comment in the generated C# code:</p><div><pre class="programlisting">// Metadata.xml XPath method reference:
  path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='CampaignTrackingService']
  /method[@name='onHandleIntent' and count(parameter)=1 and
  parameter[1][@type='android.content.Intent']]"
</pre></div><p class="calibre8">Copy this value to <code class="literal">path</code> and add the following to <code class="literal">Metadata.xml</code>:</p><div><pre class="programlisting">&lt;attr path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='CampaignTrackingService']
  /method[@name='onHandleIntent' and count(parameter)=1 and
  parameter[1][@type='android.content.Intent']]"
  name="visibility"&gt;protected&lt;/attr&gt;</pre></div><p class="calibre8">Now, we can build the project and get zero errors and zero warnings. The library is now ready for use within your <code class="literal">Xamarin.Android</code> projects.</p><p class="calibre8">However, if <a id="id649" class="calibre1"/>you start working with the library, notice how the parameter names for the methods are <code class="literal">p0</code>, <code class="literal">p1</code>, <code class="literal">p2</code>, and so on. Here are a few method definitions of the <code class="literal">EasyTracker</code> class:</p><div><pre class="programlisting">public static EasyTracker GetInstance(Context p0);
public static void SetResourcePackageName(string p0);
public virtual void ActivityStart(Activity p0);
public virtual void ActivityStop(Activity p0);</pre></div><p class="calibre8">You can imagine how difficult it would be to consume a Java library without knowing the proper parameter names. The reason the parameters are named this way is because the Java metadata for its libraries does not include the information to set the correct name for each parameter. So, <code class="literal">Xamarin.Android</code> does the best thing it can and autonames each parameter sequentially.</p><p class="calibre8">To rename the parameters in this class, we can add the following to <code class="literal">Metadata.xml</code>:</p><div><pre class="programlisting">&lt;attr path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='EasyTracker']
  /method[@name='getInstance']/parameter[@name='p0']"
  name="name"&gt;context&lt;/attr&gt;
&lt;attr path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='EasyTracker']
  /method[@name='setResourcePackageName']/parameter[@name='p0']"
  name="name"&gt;packageName&lt;/attr&gt;
&lt;attr path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='EasyTracker']
  /method[@name='activityStart']/parameter[@name='p0']"
  name="name"&gt;activity&lt;/attr&gt;
&lt;attr path="/api/package[@name='com.google.analytics
  .tracking.android']/class[@name='EasyTracker']
  /method[@name='activityStop']/parameter[@name='p0']"
  name="name"&gt;activity&lt;/attr&gt;</pre></div><p class="calibre8">On rebuilding the binding project, this will effectively rename the parameters for these four methods in the <code class="literal">EasyTracker</code> class. At this time, I would recommend that you go through the classes you plan on using in your application and rename the parameters so that it will make more sense to you. You might need to refer to the Google Analytics documentation to get the naming correct. Luckily, there is a <code class="literal">javadocs.zip</code> file included in the SDK that provides HTML reference for the library.</p><p class="calibre8">For a full <a id="id650" class="calibre1"/>reference on implementing Java bindings, make sure you check <a id="id651" class="calibre1"/>out Xamarin's documentation site at <a class="calibre1" href="http://docs.xamarin.com/android">http://docs.xamarin.com/android</a>. There are certainly more complicated scenarios than what we ran into when creating a binding for the Google Analytics library.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we added libraries from the Xamarin Component Store to Xamarin projects and ported an existing C# library, Ninject, to both <code class="literal">Xamarin.iOS</code> and <code class="literal">Xamarin.Android</code>. Next, we installed Objective Sharpie and explored its usage to generate Objective-C bindings. Finally, we wrote a functional Objective-C binding for the Google Analytics SDK for iOS and a Java binding for the Google Analytics SDK for Android. We also wrote several XPath expressions to clean up the Java binding.</p><p class="calibre8">There are several available options to use the existing third-party libraries from your <code class="literal">Xamarin.iOS</code> and <code class="literal">Xamarin.Android</code> applications. We looked at everything from using the Xamarin Component Store, porting existing code and setting up Java and Objective-C libraries to be used from C#. In the next chapter, we will cover the <code class="literal">Xamarin.Mobile</code> library as a way to access a user's contacts, camera, and GPS location.</p></div></body></html>