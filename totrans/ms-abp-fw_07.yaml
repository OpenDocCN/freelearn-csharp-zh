- en: '*Chapter 5*: Exploring the ASP.NET Core and ABP Infrastructure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both ASP.NET Core and ABP Framework provide many building blocks and features
    for modern application development. This chapter will explore the most basic building
    blocks so that you can understand how an application is configured and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the ASP.NET Core `Startup` class to understand why we need
    a modular system and how ABP provides a modular way to configure and initialize
    an application. Then we will explore the ASP.NET Core dependency injection system
    and ABP's way of automating dependency injection registration with predefined
    rules. We will continue by looking at configuration and the options pattern to
    learn ASP.NET Core's way of configuring the options of ASP.NET Core and other
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the topics we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the dependency injection system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the options pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow and try the examples, you need to have installed an IDE/editor
    (such as Visual Studio) to build the ASP.NET Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Modularity** is a design technique for breaking down the functionalities
    of a large software into smaller parts and allowing each part to communicate with
    the others through standardized interfaces as needed. Modularity has the following
    main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces complexity when every module is designed to be isolated from the
    other modules, and inter-module communications are well defined and limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides flexibility when you design modules to be loosely coupled. You can
    refactor or even replace a module in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows re-using modules across applications when you design them to be application-independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most enterprise software systems are designed to be modular. However, implementing
    modularity is not easy, and the plain ASP.NET Core doesn't help much. One of ABP
    Framework's main goals is to provide infrastructure and tooling to develop truly
    modular systems. We will cover modular application development in [*Chapter 15*](B17287_15_Epub_AM.xhtml#_idTextAnchor443)*,
    Working with Modularity*, but this section introduces the basics of ABP modules.
  prefs: []
  type: TYPE_NORMAL
- en: The Startup class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before defining a module class, it is best to remember the `Startup` class
    in ASP.NET Core to understand the need for module classes. The following code
    block shows a `Startup` class in a simple ASP.NET Core application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ConfigureServices` method is used to configure other services and register
    new services to the dependency injection system. The `Configure` method, on the
    other hand, is used to configure the **ASP.NET Core request pipeline** that processes
    the HTTP requests through middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the `Startup` class, you typically register it in the `Program.cs`
    file while configuring the host builder so that it works on application startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These code parts are already included in ASP.NET Core's startup templates, so
    you normally don't write them manually.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the `Startup` class is that it is unique. That means you have
    only a single point to configure and initialize all your application services.
    However, in a modular application, you expect that every module configures and
    initializes the services related to that particular module. Also, it is typical
    that a module uses or depends on other modules, so the modules should be configured
    and initialized in the correct order. That is where ABP's module definition class
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ABP module is a group of types (such as classes or interfaces) developed
    and shipped together. It is an assembly (a *project* in Visual Studio) with a
    module class derived from `AbpModule`. The module class is responsible for configuring
    and initializing that module and configures any dependent modules if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple module definition class for an SMS sending module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every module can override the `ConfigureServices` method in order to register
    its services to the dependency injection system and configure the other modules.
    The module in this example registers `SmsService` to a dependency injection system
    with a transient lifetime. I've written this example to show the same registration
    code done in the `Startup` class in the previous section. However, most of the
    time, you don't need to register your services manually, thanks to ABP Framework's
    conventional registration system explained in the *Using the dependency injection
    system* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AbpModule` class defines the `OnApplicationInitialization` method that
    is executed after the service registration phase is complete and the application
    is ready to run. With this method, you can execute any operation you need to perform
    on application startup. For example, you can initialize a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we are using `context.ServiceProvider` to request a service
    from the dependency injection system and initialize the service. We can request
    services because the dependency injection system is ready at this point.
  prefs: []
  type: TYPE_NORMAL
- en: You can also think of the `OnApplicationInitialization` method as the `Configure`
    method of the `Startup` class. So, you can build the ASP.NET Core request pipeline
    here. However, you typically configure the request pipeline in the startup module,
    as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Module dependencies and the startup module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A business application generally consists of more than one module, and ABP Framework
    allows you to declare dependencies between modules. An application should always
    have a **startup module**. The startup module can have dependencies on some modules,
    and these modules can have dependencies on some other modules, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a simple module dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Example module dependency graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Example module dependency graph
  prefs: []
  type: TYPE_NORMAL
- en: ABP respects module dependencies and initializes modules based on the dependency
    graph. If module A depends on module B, then module B is always initialized before
    module A. That allows module A to use, set, change, or override configurations
    and services defined by module B.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example graph in *Figure 5.1*, the module initialization will be in
    the following order: G, F, E, D, B, C, A. You don''t have to know the exact initialization
    order; only know that if your module depends on module *X*, then module *X* is
    initialized before your module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a module dependency is declared with the `[DependsOn]` attribute of
    a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, `ModuleA` depends on `ModuleB` and `ModuleC` by
    declaring the `[DependsOn]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an ASP.NET Core application, the startup module (`ModuleA` in this example)
    is responsible for setting up the ASP.NET Core request pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this code block, we've built the same ASP.NET Core request pipeline built
    previously in the *The Startup class* section. `context.GetApplicationBuilder()`
    and `context.GetEnvironment()` are just shortcuts to obtain the standard `IApplicationBuilder`
    and `IWebHostEnvironment` services from the dependency injection system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use this module in the `Startup` class of ASP.NET Core to integrate
    ABP Framework with ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `services.AddApplication()` method is defined by ABP Framework to configure
    the modules. It basically executes the `ConfigureServices` methods of all the
    modules by respecting the order of module dependencies. The `app.InitializeApplication()`
    method is also defined by ABP Framework; similarly, it executes the `OnApplicationInitialization`
    methods of all the modules by respecting the order of module dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConfigureServices` and `OnApplicationInitialization` methods are the most
    commonly used methods in a module class; there are more methods explained in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Module lifecycle methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AbpModule` class defines useful methods that you can override to execute
    code on application startup and shutdown. We saw `ConfigureServices` and `OnApplicationInitialization`
    in the previous section; here is a list of all the lifecycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PreConfigureServices`: This method is called before the `ConfigureServices`
    method. It allows you to write code to be executed before `ConfigureServices`
    of the depended-upon modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigureServices`: This is the main method to configure the module and register
    services, as explained in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostConfigureServices`: This method is called after the `ConfigureServices`
    method of all the modules (including the modules depending on your module), so
    you may perform a final configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPreApplicationInitialization`: This method is called before the `OnApplicationInitialization`
    method. In this stage, you can resolve services from dependency injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnApplicationInitialization`: This method allows your module to configure
    the ASP.NET Core request pipeline and initialize your services, as explained in
    the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPostApplicationInitialization`: This method is called in the initialization
    phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnApplicationShutdown`: You can implement your module''s shutdown logic if
    necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pre…` and `Post…` methods (such as `PreConfigureServices` and `PostConfigureServices`)
    have the same purpose as the original method. They are rarely used and provide
    a way to perform some configuration/initialization code that works before or after
    all other modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Lifecycle Methods
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle methods explained in this section are synchronous. At the time
    of writing this book, the ABP Framework team was working to introduce asynchronous
    lifecycle methods with ABP Framework version 5.1\. You can see [https://github.com/abpframework/abp/pull/10928](https://github.com/abpframework/abp/pull/10928)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: As explained before, a module class mainly contains code to register and configure
    services related to that module. In the next section, we will see how to register
    services with ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dependency injection system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a technique for obtaining a class's dependencies. It
    separates creating a class from using that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a `UserRegistrationService` class that uses `SmsService`
    to send a verification SMS, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `SmsService` has been obtained using the `SmsService`, in this example,
    is used in the `RegisterAsync` method to send a verification code after saving
    the user into the database.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core natively provides a dependency injection infrastructure, and ABP
    leverages this infrastructure rather than using a third-party dependency injection
    framework. Once you register all the services to the dependency injection system,
    any service can constructor-inject the dependent services without dealing with
    creating them (and their dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing you should consider while designing your services is
    the service lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Service lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core offers different lifetime options on service registration, so
    we should select a lifetime for every service. There are three lifetimes in ASP.NET
    Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: Transient services are created whenever you inject them. Every
    time you request/inject the service, a new instance is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: Scoped services are created per scope. This is generally considered
    by request lifetime, as each HTTP request creates a new scope in ASP.NET Core.
    You share the same instance in the same scope and get a different instance in
    different scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: A singleton service has only a single instance in an application.
    All the requests and clients use the same instance. The object is created the
    first time you request it. Then the same object instance is reused in the subsequent
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following module registers two services, one as transient and the other
    as a singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`context.Services` is a type of `IServiceCollection`, and all the ASP.NET Core
    extension methods can be used to register and configure your services manually.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, `AddTransient<ISmsService, SmsService>()`, I've registered
    the `SmsService` class with the `ISmsService` interface. In this way, whenever
    I inject `ISmsService`, the dependency injection system creates an `SmsService`
    object for me. For the second example, `AddSingleton<OtherService>()`, I've registered
    `OtherService` as a singleton with the class reference. To use this service, I
    should inject the `OtherService` class reference.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped Dependencies and ASP.NET Core's Dependency Injection Documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, scoped services are created per HTTP request for an ASP.NET Core
    application by default. For non-ASP.NET Core applications, you may need to manage
    scopes yourself. Please refer to ASP.NET Core''s documentation for all the details
    of the dependency injection system: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).'
  prefs: []
  type: TYPE_NORMAL
- en: When you use ABP Framework, you don't have to think so much about service registration,
    thanks to ABP Framework's conventional and declarative service registration system.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional service registrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ASP.NET Core, you should explicitly register all your services to `IServiceCollection`,
    as shown in the previous section. However, most of these registrations are just
    repetitive code and can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP automatically registers services for dependency injection for the following
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor page models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR hubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these services are registered with the transient lifetime. So, you don't
    need to care about service registration for these kinds of classes. If you have
    another class type, you can use one of the dependency interfaces, or the `Dependency`
    attribute as explained in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can implement an `ITransientDependency`, `IScopedDependency`, or `ISingletonDependency`
    interface to register your service for dependency injection. For example, in this
    code block, we''ve registered the service as a singleton, so only one shared instance
    is created in the application''s lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Dependency interfaces are easy and the suggested way for most cases, but they
    are limited compared to the `Dependency` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Dependency` attribute provides options for fine control of dependency
    registration with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Lifetime` (`enum`): The lifetime of the service: `Singleton`, `Transient`,
    or `Scoped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryRegister` (`bool`): Registers the service only if it''s not already registered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaceServices` (`bool`): Replaces the previous registration if the service
    is already registered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of service registration using the `Dependency` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used the `[Dependency]` attribute with a `Transient` lifetime and also
    with the `TryRegister` option to register the class to the dependency injection
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Attribute versus Dependency Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: The `Dependency` attribute can be used alongside the dependency interfaces introduced
    in the previous section. The `Dependency` attribute has a higher priority than
    the dependency interfaces if it defines the `Lifetime` property.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a class to the dependency injection system makes it usable in an
    application. However, a class may be injected with different types of class or
    interface references, depending on what service types are exposed by that class.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a class doesn't implement an interface, it can only be injected by the
    class reference. The `UserPermissionCache` class in the previous section is used
    by directly injecting the class type. However, it is common to implement interfaces
    for services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have an interface to abstract the SMS sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That is a pretty simple interface that only has a single method to send an
    SMS. Assume that you want to implement the `ISmsService` interface by using Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `AzureSmsService` class implements the `ISmsService` and `ITransientDependency`
    interfaces. The `ITransientDependency` interface is only for registering this
    service for dependency injection, as explained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You typically want to use the `AzureSmsService` class by injecting the `ISmsService`
    interface. ABP is smart enough to understand your purpose and automatically registers
    the `AzureSmsService` class for the `ISmsService` interface. You can consume the
    `AzureSmsService` class either by injecting the `ISmsService` interface or the
    `AzureSmsService` class reference. Injecting the `AzureSmsService` class by the
    `ISmsService` interface is possible by its naming conventions: the `ISmsService`
    interface is the *default interface* for the `AzureSmsService` class because it
    ends with the `SmsService` suffix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a class that implements multiple interfaces as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `PdfExporter` service can be used by injecting the `IPdfExporter` and `IExporter`
    interfaces or directly with the `PdfExporter` class reference. However, you can't
    inject it using the `ICanExport` interface because the name of `PdfExporter` doesn't
    end with `CanExport`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to change the default behavior, you can use the `ExposeServices`
    attribute, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use the `PdfExporter` class only by injecting the `IPdfExporter`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Question: Should I Define Interfaces for Each Service?'
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential question you may ask is whether you should define interfaces
    for your services and inject them using interfaces. ABP doesn''t force you to
    do anything here, and general interface best practices are applicable: define
    interfaces if you want to loosely couple your services, have multiple implementations
    of a service, mock in unit tests easily, physically separate interfaces from the
    implementations (say, we define application service interfaces in the `Application.Contracts`
    project and implement them in the `Application` project, or we define repository
    interfaces in the domain layer but implement them in the infrastructure layer),
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to register and consume services. Some services or libraries
    have options, and you may need to configure them before using them. The next two
    sections explain the standard infrastructure and patterns to configure options
    provided by such services and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core's **configuration** system provides a convenient way to read key-value-based
    configurations for applications. It is an extensible system and can read key-value
    pairs from various resources, such as JSON settings files, environment variables,
    command-line arguments, and Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework versus ASP.NET Core's Configuration System
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP Framework doesn''t add a specific feature to ASP.NET Core''s configuration
    system. However, it is essential to understand it to work with ASP.NET Core and
    ABP Framework properly. I will cover the basics in this book. Please see ASP.NET
    Core''s documentation for a complete reference: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the configuration values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to set a configuration value is to use the `appsettings.json`
    file by default. Assume that we are building a service to send SMS using Azure,
    and we need the following configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sender`: The sender number shown to the target user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionString`: The connection string of your Azure resouce'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define these settings in the configuration section of the `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The configuration section name (`AzureSmsService` here) and key names are completely
    arbitrary. You can set any name as long as you use the same keys in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've set values in the settings file, you can easily read them from your
    application code.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the configuration values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inject and use the `IConfiguration` service whenever you need to read
    configured values. For example, we can get the Azure configuration to send SMS
    in the `AzureSmsService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This class gets the configuration values from the `IConfiguration` service,
    and the`:` notation is used to access values in nested sections. In this example,
    `AzureSmsService:Sender` is used to get the `Sender` value inside the `AzureSmsService`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IConfiguration` service is also usable in the `ConfigureServices` of your
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can access the configured values even before the dependency injection
    registration phase is completed.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration system is a perfect way to configure and get key-value-style
    settings for your application. However, if you are building a reusable library,
    the options pattern can be a better way to define type-safe options for your library.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the options pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the **options pattern**, we use a plain class (sometimes called a **POCO**
    – **Plain Old C# Object**) to define a group of related options. Let's begin with
    how to define, configure, and use the configuration using the options pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an options class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An options class is a simple plain C# class. We can define an options class
    for the Azure SMS service as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is a convention to add the `Options` suffix to options classes. Once you
    define such a class, any module using this service can configure the options easily.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the *ABP modules* section, you can configure the services of
    the dependent modules in the `ConfigureServices` method of your module. We use
    the `IServiceCollection.Configure` extension method to set values for any options
    class. You can configure `AzureSmsServiceOptions` as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `context.Services.Configure` method is a generic method that gets the options
    class as the generic parameter. It also takes a delegate (an action) to set the
    option values. In this example, we've configured `AzureSmsServiceOptions` by setting
    the `Sender` and `ConnectionString` properties in the specified lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AbpModule` base class provides a `Configure` method as a shortcut of the
    `context.Services.Configure` method, so you could re-write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've just replaced the `context.Services.Configure<…>` call with the `Configure<…>`
    shortcut method.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the options is simple. Now, we can see how to use the configured
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Configure Actions
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the same options multiple times in an application. The same
    instance is sent to all delegates so that you can change the previously configured
    values. If multiple modules configure the same value, the last one wins. Remember
    that modules are initialized by the dependency order.
  prefs: []
  type: TYPE_NORMAL
- en: Using the configured option values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides an `IOptions<T>` interface to inject the options class
    to read the configured values. We can re-write the `AzureSmsService` class to
    use `AzureSmsServiceOptions` instead of the `IConfiguration` service, as in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are injecting `IOptions<AzureSmsServiceOptions>` and using its
    `Value` property to obtain the `AzureSmsServiceOptions` instance. The `IOptions<T>`
    interface is defined by the `Microsoft.Extensions.Options` package and is the
    standard way to inject an options class. It internally executes all the `Configure`
    methods and provides a configured instance of the options class for you. If you
    directly inject the `AzureSmsServiceOptions` class by mistake, you get a dependency
    injection exception. So, always inject as `IOptions<AzureSmsServiceOptions>`.
  prefs: []
  type: TYPE_NORMAL
- en: We've simply defined, configured, and used the options. What if we want to use
    the configuration system to set the options defined with the options pattern?
  prefs: []
  type: TYPE_NORMAL
- en: Setting the options via the configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The options pattern allows us to set the option values in any way. That means
    we can use the `IConfiguration` service to read the application configuration
    and set the option values. The following code block sets `AzureSmsServiceOptions`
    by getting the values from the configuration service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are getting the `IConfiguration` interface using `context.Services.GetConfiguration()`,
    then using the configuration values to set the option values.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since this usage is pretty common, there is a shortcut for it. We
    could re-write the code as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this usage, the `Configure` method gets a configuration section instead
    of a delegate action. It automatically matches the configuration keys with the
    properties of the options class by naming conventions. This code does not affect
    the options if the `AzureSmsService` section is not defined in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The options pattern gives more flexibility to the application developers; they
    may set these options from `IConfiguration` or any other source they like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Set Options from the Configuration by Default'
  prefs: []
  type: TYPE_NORMAL
- en: If you are building a reusable module, it is a good practice to set your options
    from the configuration wherever possible. That is, you can write the preceding
    code into your module. In this way, an application developer can directly configure
    their module from the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core and ABP options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core and ABP Framework intensively use the options pattern for their
    configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows configuring an option in ABP Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`AbpAuditingOptions` is defined by the audit logging system of ABP Framework.
    We are adding a type, `ProductDto`, to be ignored on audit logging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows configuring an option in ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`MvcOptions` is defined by ASP.NET Core to customize the behavior of the ASP.NET
    Core MVC framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex Types in the Options Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `AbpAuditingOptions.IgnoredTypes` is a list of `Type`, which is
    not a simple primitive type that you can define in an `appsettings.json` file.
    That is one of the benefits of the options pattern: you can define properties
    with complex types or even action callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration system and the options pattern provide a convenient way to
    configure and customize the behavior of the services being used. You can configure
    ASP.NET Core and ABP Framework and define configuration options for your own services.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains logging, another fundamental system that you will
    frequently use in your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Logging** is a common aspect used in every application. ASP.NET Core provides
    a simple yet efficient logging system. It can be integrated with popular logging
    libraries such as NLog, Log4Net, and Serilog.'
  prefs: []
  type: TYPE_NORMAL
- en: Serilog is a widely used library that provides many options for the log target,
    including console, text files, and Elasticsearch. ABP startup templates come with
    the Serilog library pre-installed and configured. It writes logs into a log file
    in the `Logs` folder of the application. So, you can directly use the logging
    system in your services. If you need, you can configure Serilog to write logs
    to different targets. Please refer to Serilog's documentation to configure the
    Serilog options. Serilog is not a core dependency of ABP Framework. All the configuration
    is included in the startup template. So, if you like, you can easily change it
    with another provider.
  prefs: []
  type: TYPE_NORMAL
- en: The `ILogger<T>` interface is used to write logs in ASP.NET Core, where `T`
    is typically your service type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example service that writes logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AzureSmsService` class injects the `ILogger<AzureSmsService>` service in
    its constructor and uses the `LogInformation` method to write information-level
    log text to the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more methods on the `ILogger` interface to write logs with different
    severity levels, such as LogError and LogDebug. Please refer to ASP.NET Core''s
    documentation for all details of the logging system: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered the core building blocks of ASP.NET Core and ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned about using the `Startup` class, configuration system, and options
    pattern to configure ASP.NET Core and ABP Framework services on application startup
    and implement your own configuration options when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: ABP offers a modularity system that takes ASP.NET Core's initialization and
    configuration system one step further to create multiple modules where each module
    initializes its services and configures its dependencies. In this way, you can
    split your application into modules to better organize your code base or create
    modules that can be reused in different applications.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency injection system is the most fundamental infrastructure of an
    ASP.NET Core application. A service consumes others using the dependency injection
    system. I've introduced the essential aspects of the dependency injection system
    and explained how ABP simplifies registering your services.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on data access infrastructure, which is an essential
    aspect of a business application. We will see how ABP Framework standardizes defining
    entities and using repositories to abstract and perform database operations while
    automating database connections and transaction management.
  prefs: []
  type: TYPE_NORMAL
