<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deploying Services on Azure</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn how to deploy the catalog web service on Microsoft Azure. Although we will be focusing on the Microsoft Azure cloud provider and most of the instructions will be strongly linked to that platform, some of the concepts can be applied to multiple cloud providers: containers are becoming a common way to build and run applications and web services on the cloud, therefore, every cloud provider offers slightly different services and products to host containers. This chapter will not go too deeply into Microsoft Azure; it will provide an overview of <strong>Azure Container Instances</strong><span> (</span><strong>ACI</strong><span>)</span> and Azure App Service features of the Azure cloud.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Getting started with Azure</li>
<li>Pushing containers into Azure Container Registry</li>
<li class="h1"><span>Configuring ACI</span></li>
<li>Configuring app services</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Azure</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, Microsoft Azure is the cloud platform built by Microsoft. Azure offers a wide range of IT products, technologies, and integration tools. Virtual machines, serverless technologies, databases, and machine learning pipelines are just some of the products that it provides. In this chapter, we will focus on a few of the services that are presented by Azure, such as<em> </em><strong>Container Instances</strong>, <strong>App Service</strong>, and <strong>Azure SQL Databases</strong>.</p>
<p>Let's start by creating a subscription. Microsoft allows us to try Azure services out when a new user creates an Azure account for the first time. It is possible to register for a new Microsoft Azure account at <a href="https://azure.microsoft.com/free/">https://azure.microsoft.com/free/</a>. </p>
<p>The signup<span> </span>process will ask you for some personal details, as well as a valid phone number and valid credit card. By default, Microsoft provides 12 months of popular free services, plus <span>€</span>170 of Azure services for 30 days and 25+ services that are always free. This makes it easy for a new developer or engineer to test/learn how to use some of Azure's new services.</p>
<p>Once you've completed the signup process, you will be able to log in to the Azure portal (<a href="https://portal.azure.com/">https://portal.azure.com</a>) using the account you just created.</p>
<p>The Azure CLI is Microsoft's official CLI for managing Azure resources; it is available for almost all OSes and is part of the Azure SDK. <span>The Azure SDK is cross-platform; therefore, it is possible to install it on Windows, macOS, or Linux in three different ways:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Platform</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Command</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Requirements</strong></td>
</tr>
<tr>
<td>Linux</td>
<td><kbd>curl -L https://aka.ms/InstallAzureCli | bash</kbd></td>
<td>You will require some preinstalled software, that is, Python 2.7 or Python 3.x (<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>),libffi (<a href="https://sourceware.org/libffi/">https://sourceware.org/libffi/</a>), and OpenSSL 1.0.2 (<a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a>). For more information, please go to<a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-linux?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-linux?view=azure-cli-latest</a>.</td>
</tr>
<tr>
<td>macOS</td>
<td><kbd><span>brew update &amp;&amp; brew install azure-cli</span></kbd></td>
<td>You will need <kbd>brew</kbd>, which should already be installed on your machine. For more information about <kbd>brew</kbd>, please go to <a href="https://brew.sh/">https://brew.sh/</a>.</td>
</tr>
<tr>
<td>Windows</td>
<td><a href="https://aka.ms/installazurecliwindows">https://aka.ms/installazurecliwindows</a></td>
<td>Microsoft provides an MSI for the Windows platform.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The Azure SDK and its CLI provide all of the command-line tools you'll need to manage Azure services. Let's start by signing in using the CLI. We can do this by executing the following command:</p>
<pre><strong><span class="hljs-keyword">az</span><span> </span><span class="hljs-keyword">login</span></strong></pre>
<p>The preceding command will open a browser window and send you to the sign-in page for the Microsoft Azure portal and save the session into your local environment. In the next section, we will see how to use the CLI to push the container images we built in the previous chapters into the container registry service of Azure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing containers into Azure Container Registry</h1>
                </header>
            
            <article>
                
<p>In this section, we will focus on deploying our containers into Microsoft Azure. This process involves some resources and services that are provided out of the box by the cloud provider. The following diagram is an overview of the architecture schema that we are going to build:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d32f4269-5723-4e15-92fc-fa0b1d67eddc.png" style=""/></div>
<p>Let's take a look at the different components that are involved in this schema:</p>
<ul>
<li><strong>Azure Container Registry</strong> is a managed Docker Registry service (<a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a>) based on the open source Docker Registry 2.0. It is possible to use Azure Container Registry to store, manage, and use your private Docker container images. <span>We will use it to save images related to our custom images, such as the <kbd>catalog_api</kbd> image, and make them available to other cloud services.  </span></li>
<li>The web app for containers allows us to use our containers and deploy them to <strong>App Service</strong> as a web app. <span>Furthermore, it eliminates time-consuming infrastructure management tasks such as updating, scaling, and in general, managing the infrastructure.</span></li>
<li>The other dependencies of the application, such as <kbd>catalog_esb</kbd> and <kbd>catalog_cache</kbd>, will take the image from the public Docker Hub <em>(</em><a href="https://hub.docker.com">https://hub.docker.com</a>)<em>.</em></li>
</ul>
<p>Let's continue by creating an Azure Container Registry. The registry will be used further in this<span> chapter to push and pull the image of</span> <kbd>catalog_api</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Azure Container Registry</h1>
                </header>
            
            <article>
                
<p>To create a new Azure Container Registry, we should start by creating a new resource group. Resource groups are a fundamental concept in Azure resource management: they allow us to group a collection of resources for management, deployment, and billing reasons. In general, all of the resources that have the same life cycle should be grouped into the same resource group. Let's get started:</p>
<ol>
<li>First, create a resource group by using the following command on the <span>Azure CLI</span>:</li>
</ol>
<pre style="padding-left: 60px">az group create --name handsOn --location westeurope</pre>
<p style="padding-left: 60px">The preceding command creates a new resource group called <kbd>handsOn</kbd> in our account stored in the West Europe region.</p>
<ol start="2">
<li>Next, we will create the Azure Container Registry by executing the following command:</li>
</ol>
<pre style="padding-left: 60px">az acr create --resource-group handsOn --name <strong>&lt;container_registry_name&gt;</strong> --sku Basic</pre>
<p>The preceding command creates a new Azure Container Registry under the <kbd>handsOn</kbd> resource group with the name we have chosen. It also defines the <strong>Stock-Keeping Unit</strong> (<strong>SKU</strong>) for this resource—in our case, the basic one.</p>
<div class="packt_infobox"><span>SKU usually refers to a specific variant of a product and all of the attributes that identify that type of product. In the same way, Microsoft Azure uses this term to identify a specific </span><span>purchasable </span><span>good or service. </span></div>
<p>Now that we have created an Azure Container Registry, let's push the <kbd>catalog_api</kbd> image into the registry. To solve the other dependencies of our container, we will create another <kbd>appsettings.json</kbd> file dedicated to a <kbd>Stage</kbd> environment. Therefore, we will set the <kbd>ASPNETCORE_ENVIRONMENT</kbd> variable to <kbd>Stage</kbd> to apply the connection string needed by the container. We can proceed by creating the <kbd>appsettings.Stage.json</kbd> file in the following way:</p>
<pre><span>{<br/></span><span>    </span><span>"Logging"</span><span>: {<br/></span><span>        </span><span>"LogLevel"</span><span>: {<br/></span><span>            </span><span>"Default"</span><span>: </span><span>"Warning"<br/></span><span>        </span><span>}<br/></span><span>    },<br/></span><span>    </span><span>"AllowedHosts"</span><span>: </span><span>"*"</span><span>,<br/></span><span>    </span><span>"DataSource"</span><span>: {<br/></span><span>        </span><span>"ConnectionString"</span><span>: </span><span>"Server=catalog db.westeurope<br/>        .azurecontainer.io;Database=master;User=sa;<br/>        Password=P@ssw0rd"<br/></span><span>    </span><span>},<br/></span><span>    </span><span>"ESB"</span><span>: {<br/></span><span>        </span><span>"ConnectionString"</span><span>: </span><span>"host=catalog-esb.westeurope.<br/>         azurecontainer.io;username=guest;password=guest;"</span><span>,</span><span><br/>        </span><span>"EndPointName"</span><span>: </span><span>"ItemSoldOut"<br/></span><span>    </span><span>},<br/></span><span>    </span><span>"CacheSettings"</span><span>: {<br/></span><span>        </span><span>"ConnectionString"</span><span>: </span><span>"catalog-cache.westeurope.<br/>         azurecontainer.io:6379,abortConnect=false"<br/></span><span>    </span><span>},<br/></span><span>    </span><span>"AuthenticationSettings"</span><span>: {<br/></span><span>        </span><span>"Secret"</span><span>: </span><span>"&lt;secret&gt;"</span><span>,<br/></span><span>        </span><span>"ExpirationDays" </span><span>: </span><span>"7"<br/></span><span>    </span><span>}<br/></span><span>}</span></pre>
<p>The preceding <kbd>appsettings.json</kbd> file definition declares the endpoints for the <kbd>catalog_db</kbd>, <kbd>catalog-esb</kbd>, and <kbd>catalog-cache</kbd> containers. Every endpoint is composed of the name of the container we are going to create, followed by the syntax—<kbd>&lt;region_name&gt;.azurecontainer.io</kbd>. The first part represents the region, followed by the subdomain of the service we are using, in our case, <kbd>azurecontainer.io</kbd>. Let's continue by defining the steps to push our local image into the container registry previously created:</p>
<ol>
<li>Let's start by authenticating the Azure CLI in the container registry using the following command:</li>
</ol>
<pre style="padding-left: 60px">az acr login --name <strong>&lt;container_registry_name&gt;</strong></pre>
<p style="padding-left: 60px">This should return a <span class="s1"><span class="packt_screen">Login Succeeded</span> </span>message to the CLI.</p>
<ol start="2">
<li>After that, we can proceed by preparing the Docker image of our service and build the image by triggering the following command in the <kbd>Catalog.API</kbd> folder:</li>
</ol>
<pre style="padding-left: 60px">docker-compose build</pre>
<p style="padding-left: 60px">This instruction creates a new Docker image based on the Dockerfile we already have in the project folder. The name of the image will depend on the name specified on the <kbd>docker-compose.yml</kbd> file and <kbd>COMPOSE_PROJECT_NAME</kbd> specified in the <kbd>.env</kbd> file: if the <kbd><span>COMPOSE_PROJECT_NAME</span></kbd> is <kbd>store</kbd>, then the command will create an image with the <kbd>store_catalog_api</kbd> name.</p>
<ol start="3">
<li>It is possible to verify the resulting image by executing the <kbd>docker images</kbd> command:</li>
</ol>
<pre style="padding-left: 60px">docker images<br/>REPOSITORY TAG IMAGE ID CREATED SIZE<br/>catalog_api latest 714e538b7da5 About a minute ago 618MB</pre>
<ol start="4">
<li>It is necessary to get the Azure Container Registry server address so that we can push the <span>local image to the registry. </span>We can proceed by tagging the container that we just created with the server address of the Azure Container Registry we created previously:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>docker tag catalog_api &lt;container_registry_name&gt;.azurecr.io/catalog_api:v1<br/>docker push &lt;container_registry_name&gt;.azurecr.io/catalog_api:v1</span></strong></pre>
<p>After tagging the image and using the <kbd>docker push</kbd> command, Docker will start uploading the container into our Azure container repository. Hence, we will be able to use our container image in all of the services provided by Azure. This upload usually takes some time, depending on the size of the image and the quality of your internet connection. When the upload is completed, it is possible to check the result by browsing the <span class="packt_screen">Container registries</span> section of the Azure portal (<a href="https://portal.azure.com/">https://portal.azure.com/</a>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ddbea9e-5b47-42b7-81ef-2d5ba99cd8df.png"/></div>
<p>In this case, we can see that we have created a container registry called <kbd>handsonaspnetcoreacr</kbd> under the <kbd>handsOn</kbd> resource group. Eventually, we can choose to create or manage the container registry directly from the portal. Now that we've pushed the container, we can proceed by configuring ACI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Azure Container Instances</h1>
                </header>
            
            <article>
                
<p>The ACI service by Microsoft Azure provides us with a fast and easy way to run containers in the cloud without worrying about the <span>management part of virtual machines or having to learn about new tools. This service is designed to be as quick as possible and ease the process of getting a container up and running in the cloud. Furthermore, it is possible to launch a container by executing a simple Azure CLI command, such as the following:</span></p>
<pre><strong><span>az </span>container create --resource-group myResourceGroup \</strong><br/><strong>                    --name cache-container \</strong><br/><strong>                    --image redis:alpine \</strong><br/><strong>                    --cpu <span>1 </span>\</strong><br/><strong>                    --memory <span>1 </span>\</strong><br/><strong>                    --dns-name-label cache-container \</strong><br/><strong>                    --ports </strong><span><strong>6379</strong> <br/></span></pre>
<p>The ACI service is the ideal service for testing and running containers in Azure. Hence,<span> the ACI service allows us to </span><span>lower our infrastructure costs by taking advantage of <em>per-second billing</em>.</span> For that reason, the ACI service is also the favorite service for continuous integration and continuous pipeline purposes. The following steps show you how to deploy the catalog service on ACI<em>:</em></p>
<ol>
<li>Let's start by creating a new resource group so that we can group our containers. Use the following command to do so:</li>
</ol>
<pre style="padding-left: 60px"><strong>az group create --name handsOnContainerServices --location "West Europe"</strong></pre>
<ol start="2">
<li class="mce-root">We can pro<span>ceed by getting the registry username and password of the service account of the container registry using the following command: </span></li>
</ol>
<pre class="p1" style="color: black;padding-left: 60px"><span class="s1">az acr credential show -n <strong>&lt;container_registry_name&gt;</strong></span></pre>
<ol start="3">
<li>After creating the group, we will need to execute the Azure CLI command using a Bash script from the GitHub repository called <kbd>aci-deploy.sh</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>#!/bin/bash<br/></span><span># Set the service group name<br/></span><strong><span>export </span><span>resource_group</span>=handsOnContainerServices</strong><br/><span># Set the registry address<br/></span><strong><span>export </span><span>registry_address</span>=&lt;registry_address&gt;</strong><span><br/># Set the registry username<br/><strong>export registry_username=&lt;registry_username&gt;</strong><br/># Set the registry password<br/><strong>export registry_password=&lt;registry_password&gt;<br/></strong># Set the api ASPNETCORE_ENVIRONMENT variables<br/>export environment=Stage<br/># Set the sql container name<br/></span><span>export </span><span>sql_name</span>=catalog-db<br/><span># Set the sql admin password<br/></span><span>export </span><span>sql_admin_pass</span>=P@ssw0rd<br/><span># Set the event service bus name<br/></span><span>export </span><span>esb_name</span>=catalog-esb<br/><span># Set the event service bus username<br/></span><span>export </span><span>rabbitmq_user</span>=guest<br/><span># Set the event service bus password<br/></span><span>export </span><span>rabbitmq_pass</span>=guest<br/><span># Set the cache container name<br/></span><span>export </span><span>cache_name</span>=catalog-cache<br/><span># Set the service name<br/></span><span>export </span><span>api_name</span>=catalog-api<br/><br/><br/><span>az </span>container create --resource-group <span>$</span><span>{resource_group}</span> \<br/>                    --location westeurope \<br/>                    --name <span>$</span><span>{sql_name}</span> \<br/>                    --image microsoft/mssql-server-linux \<br/>                    --cpu <span>1</span> \<br/>                    --memory <span>1</span> \<br/>                    --dns-name-label <span>$</span><span>{sql_name}</span> \<br/>                    --ports <span>1433</span> \<br/>                    --environment-variables ACCEPT_EULA=Y SA_PASSWORD=<span>$</span><span>{sql_admin_pass}<br/></span><span>                    <br/></span><span>az </span>container create --resource-group <span>$</span><span>{resource_group}</span> \<br/>                    --location westeurope \<br/>                    --name <span>$</span><span>{esb_name}</span> \<br/>                    --image rabbitmq:3-management \<br/>                    --cpu <span>1</span> \<br/>                    --memory <span>1</span> \<br/>                    --dns-name-label <span>$</span><span>{esb_name}</span> \<br/>                    --ports <span>5672</span> \<br/>                    --environment-variables RABBITMQ_DEFAULT_USER=<span>$</span><span>{rabbitmq_user} </span>RABBITMQ_DEFAULT_PASS=<span>$</span><span>{rabbitmq_pass} <br/></span><span><br/></span><span>az </span>container create --resource-group <span>$</span><span>{resource_group}</span> \<br/>                    --name <span>$</span><span>{cache_name}</span> \<br/>                    --image redis:alpine \<br/>                    --cpu <span>1</span> \<br/>                    --memory <span>1</span> \<br/>                    --dns-name-label <span>$</span><span>{cache_name}</span> \<br/>                    --ports <span>6379 <br/></span><span><br/></span><span>az </span>container create --resource-group <span>$</span><span>{resource_group}</span> \<br/>                    --location westeurope \<br/>                    --name <span>$</span><span>{api_name}</span> \<br/>                    --image <span>$</span><span>{registry_address}</span>/catalog_api:v1 \<br/>                    --cpu <span>1</span> \<br/>                    --memory <span>1</span> \<br/>                    --dns-name-label <span>$</span><span>{api_name}</span> \<br/>                    --ports <span>80</span> \<br/>                    --ip-address public \<br/>                    --environment-variables ASPNETCORE_ENVIRONMENT=<span>$</span><span>{environment}</span> \<br/>                    --registry-password=<span>$</span><span>{registry_password}</span> \<br/>                    --registry-username=<span>$</span><span>{registry_username}<br/></span></pre>
<p style="padding-left: 60px">The script mostly runs five different instructions for the creation of new instances of these containers:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>It declares information regarding the containers, such as the resource group, the names to assign to the containers, and some additional environment variables.</span></li>
<li>It executes the <kbd>az container create</kbd><span> command to create and run <kbd>microsoft/mssql-server-linux</kbd>.</span></li>
<li>It executes the <kbd>az container create</kbd> <span>instruction to create and run the </span><kbd>rabbitmq:3-management-alpine</kbd> <span>image, and it uses the </span><kbd>rabbitmq_user</kbd> <span>and</span> <kbd>rabbitmq_pass</kbd><span> environment variables to set the default user for the RabbitMQ instance.</span></li>
<li>It deploys the Redis cache instance using <kbd>redis:alpine</kbd><span>.</span></li>
<li>Finally, it executes <span><kbd>az container create</kbd> to create and deploy the <kbd>catalog_api</kbd> image that's already present in the Azure Container Registry</span><span> </span><span>repository by specifying the registry URL. </span></li>
</ul>
</li>
</ul>
<div class="packt_tip packt_infobox">Please note that the execution order follows the same logic of the dependencies of these containers; therefore, the API container is run last.<br/>
Note that, to keep the demo as simple as possible, the <kbd>aci-deploy.sh</kbd> script creates the catalog service container using <kbd>--ip-address public</kbd>, which means that our container can be accessed by anyone. Directly e<span>xposing </span>an API without any reverse proxy and an API gateway is strongly discouraged in a production environment so that you avoid exposing your containers to the outside world. </div>
<p><span>Now that we've executed the script, we can see the result by signing into the Azure portal (</span><a href="https://portal.azure.com/#">https://portal.azure.com/#</a><span>) and checking our container in the <span class="packt_screen">Container instances</span> section:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/69924149-046e-4903-b729-14b57491cd2b.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">As you can see, there are four container instances up and running. All of them are running on DNS using the <kbd>--dns-name-label</kbd> parameter and can access each other through their addresses. Hence, it is possible to call the container API using the address that was generated by our shell script. We can also check the statistics and the properties associated with the container by clicking on the name of the container:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4a71ce45-9376-4faf-be99-ef3ee41a0a4b.png" style=""/></div>
<p>Finally, we can call the health check HTTP route from our browser to verify that all of the dependencies are correct:</p>
<pre style="padding-left: 60px">http://catalog-api.westeurope.azurecontainer.io/health</pre>
<p>The preceding process describes how to deploy the catalog service into the ACI product. Although ACI are powerful and easy to deploy, <span>they lack some minimal out-of-the-box features, such as SSH, monitoring, and configuration management. Therefore, it becomes hard to manage container instances in a production environment.</span><span> </span><span>In the next section, we will focus on a different hosting process that uses app service technologies to host the application called app services. This way of working is more focused on the hosting of web applications and web services; therefore, it provides a set of tools and features for the monitoring and the configuration of the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring app services</h1>
                </header>
            
            <article>
                
<p>An alternative to ACI is app services. Microsoft Azure recently released a new feature so that we can deploy Docker images using <strong>app services</strong>. This kind of approach is useful when you want to keep the same environment for your development machine and production environment. In contrast to ACI<em>,</em> app services provides us with a managed way to run our containers. It comes with some out-of-the-box features, such as SSL encryption, monitoring, configuration management, remote debugging, and application scaling settings. On top of that, app services is strongly integrated<span> </span>with<span> </span>other Azure products. Therefore, it is possible to plug other services into<span> </span><kbd>catalog-srv</kbd> easily. For example, we may<span> </span>choose<span> </span>to run our Azure SQL Database solution to set up a fully-managed SQL database for the catalog service. <span>Azure SQL provides the broadest SQL Server engine compatibility; it simplifies the maintenance process using the SQL tools you prefer.</span></p>
<div class="packt_infobox">As we mentioned previously, it is not easy to integrate persistence data storage using Docker without using persistent volumes. For that reason, in this section, we will look at an alternative way to store data.</div>
<p>Let's proceed by creating a new Azure SQL database by using the<span> </span><kbd>azuresql-deploy.sh</kbd><span> </span>script in the root folder of the project:</p>
<pre><span>#!/bin/bash<br/></span><span><br/></span><span># Set an admin login and password for your database<br/></span><span>export </span>user_admin=catalog_srv<br/><span>export </span>user_pass=P@ssw0rd<br/><span># The logical server name has to be unique in the system<br/></span><span>export </span>server_name=storecatalogapi<br/><span>export </span>database_name=catalog<br/><span># The resource group name<br/></span><span>export </span>resourceGroup=handsOnAppService<br/><span># The ip address range that you want to allow to access your DB<br/></span><span>export </span>startip=0.0.0.0<br/><span>export </span>endip=0.0.0.0<br/><br/><span># Create a resource group<br/></span><span>az </span>group create \<br/>   --name <span>$</span>{resourceGroup} \<br/>   --location westeurope<br/><br/><span># Create a logical server in the resource group<br/></span><span>az </span>sql server create \<br/>   --name <span>$</span>{server_name} \<br/>   --resource-group <span>$</span>{resourceGroup} \<br/>   --location westeurope  \<br/>   --admin-user <span>$</span>{user_admin} \<br/>   --admin-password <span>$</span>{user_pass}<br/><br/><span># Configure a firewall rule and open to local Azure services<br/></span><span>az </span>sql server firewall-rule create \<br/>   --resource-group <span>$</span>{resourceGroup} \<br/>   --server <span>$</span>{server_name} \<br/>   -n AllowYourIp \<br/>   --start-ip-address <span>$</span>{startip} \<br/>   --end-ip-address <span>$</span>{endip}<br/><br/><span># Create a database in the server <br/></span><span>az </span>sql db create \<br/>   --resource-group <span>$</span>{resourceGroup} \<br/>   --server <span>$</span>{server_name} \<br/>   --name <span>$</span>{database_name} \<br/>   --service-objective S0 \<br/>    --zone-redundant false</pre>
<p>In the preceding script, the<span> </span><kbd>azuresql-deploy.sh</kbd><span> </span>file creates the logical server that hosts the<span> </span><kbd>store</kbd><span> </span>database and the effective database<span> </span>that<span> </span>contains the<span> </span>catalog<span> </span>information. First of all, the script proceeds by creating the resource group; then, it continues by creating the Azure SQL elements. Since <kbd>start-ip</kbd><span> </span>and<span> </span><kbd>end-ip</kbd>, which are specified in the firewall rules, are both<span> </span><kbd>0.0.0.0</kbd>, all of the Azure services that are part of that account can connect to the database. </p>
<p>By doing this, it is possible to connect the previously created<span> </span><kbd>catalog-srv</kbd><span> </span>app service to the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an app service using a container image</h1>
                </header>
            
            <article>
                
<p>Let's walk through how to create an app service using the previously published image, which is already present in Azure Container Registry, that is, <span><kbd>&lt;registry_name&gt;.azurecr.io/catalog_api:v1</kbd></span>. As a first step, we need to create an<span> app service plan using the following command:</span></p>
<pre><span class="s1">az appservice plan create --name catalogServicePlan --resource-group <strong>&lt;service_group_name&gt;</strong> --sku FREE --is-linux<br/></span></pre>
<p><span>The app service plan is required for the creation of the app service: it defines a set of computing resources that are used to run all of the app services that are part of the same plan. For this example, we will use the most basic service plan, which can be specified using the following flag: </span><kbd>--sku FREE</kbd><span>. This plan supports up to 10 instances and it does not provide any additional autoscale capability. </span></p>
<p>Now that we've created all of the requirements, we can proceed by executing the <kbd>appservice-deploy.sh</kbd> file, which is located in the root of the project:</p>
<pre><span>#!/bin/bash<br/></span><span># Set the service group name<br/></span><span>export </span><span>resource_group</span>=handsOnAppService<br/><span># Set the plan<br/></span><span>export </span><span>plan</span>=catalogServicePlan<br/><span># Set the service name<br/></span><span>export </span><span>app_service_name</span>=catalog-srv<br/><span># Set the api ASPNETCORE_ENVIRONMENT variables<br/></span><span>export </span><span>environment</span>=StageAppServices<br/><span># Defines the ACR registry URL<br/></span>export registry_address=<strong><span>&lt;</span><span>registry_address</span></strong><span><strong>&gt;</strong>.azurecr.io</span><br/><br/><span># Create the app service<br/></span><span>az </span>webapp create --resource-group <span>$</span><span>{resource_group}</span> \<br/>                             --plan <span>$</span><span>{plan}</span> \<br/>                             --name <span>$</span><span>{app_service_name}</span> \<br/>                             --deployment-container-image-name <span>$</span><span>{registry_address}</span>/catalog_api:v1<br/>                             <br/><span># Set the ASPNETCORE_ENVIRONMENT variable<br/></span><span>az </span>webapp config appsettings set -g <span>$</span><span>{resource_group}</span> \<br/>                                 -n <span>$</span><span>{app_service_name}</span> \<br/>                                 --settings ASPNETCORE_ENVIRONMENT=<span>$</span><span>{environment}</span></pre>
<p>The preceding script creates the web app using the <kbd>az webapp create</kbd> instruction, and after the creation of the app service, it proceeds by executing the <kbd>az webapp config appsettings set</kbd> command to set the right ASP.NET Core environment value. <span>Once the script has been executed, we can continue by checking the status of the app service in the portal:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59b4576b-52d0-43ac-94ab-20c0bd57bd3a.png" style=""/></div>
<p>Furthermore, we can verify the status of the service by calling the health check URL: <kbd>http://catalog-api.westeurope.azurecontainer.io/health</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen how we can host and run the catalog service project in Microsoft Azure. We also learned how to create a private Azure Container Registry and how to store the Docker image of the catalog service. Then, we showed you some of the patterns you can use to get a custom container into the cloud and how to run them using different services offered by the Microsoft Azure cloud provider. Finally, we looked at two different approaches <span>to hosting the catalog service</span>: <span>us</span>ing the ACI product and Azure App Service and <span>storing the data us</span>ing the Azure SQL service. </p>
<p><span>In the next chapter, we will learn how to document APIs using</span> the OpenAPI Specification by implementing <span>the Swagger framework.</span></p>


            </article>

            
        </section>
    </body></html>