- en: '*Chapter 12*: Content Negotiation Using a Custom OutputFormatter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about how to send your data to the client
    in different formats and types. By default, the ASP.NET Core web API sends data
    as JSON, but there are some more ways to distribute data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `OutputFormatter` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom `Outputformatter` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topics in this chapter relate to the WebAPI layer of the ASP.NET Core architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The ASP.NET Core architecture](img/Figure_12.1_B17996.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The ASP.NET Core architecture
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples in this chapter, you will need to create an ASP.NET
    Core MVC application. To do this, open your console, shell, or Bash terminal,
    and change to your working directory. Then, use the following command to create
    a new MVC application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code by typing the following command in the already-open console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OutputFormatter objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ASP.NET Core, `OutputFormatters` are classes that transform your existing
    data into different formats to send it through HTTP to clients. The web API uses
    a default `OutputFormatters` to turn objects into JSON, which is the default format
    to send structured data. Other built-in formatters include an XML formatter and
    a plain text formatter.
  prefs: []
  type: TYPE_NORMAL
- en: With so-called *content negotiation*, clients are able to decide which format
    they want to retrieve. The client needs to specify the content type of the format
    in the `Accept` header. Content negotiation is implemented in `ObjectResult`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the web API always returns JSON, even if you accept text/XML in
    the header. This is why the built-in XML formatter is not registered by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add `XmlSerializerOutputFormatter` to ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, alternatively, you can use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might need to add the `Microsoft.AspNetCore.Mvc.Formatters` namespace to
    the `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a formatter called `XmlDataContractSerializerOutputFormatter`
    available, which uses `DataContractSerializer` internally and is more flexible
    in its configurations.
  prefs: []
  type: TYPE_NORMAL
- en: By default, any `Accept` header will automatically be turned into `application/json`,
    even if you use one of these methods. However, we can fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to allow the clients to accept different headers, you need to switch
    that translation off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Some third-party components that don't completely support ASP.NET Core 5.0 or
    later won't write asynchronously to the response stream, but the default configuration
    since ASP.NET Core 3.0 *only* allows asynchronous writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable synchronous writing access, you will need to add these lines to the
    `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Add the `Microsoft.AspNetCore.Server.Kestrel.Core` namespace to the `using`
    statements to get access to the options.
  prefs: []
  type: TYPE_NORMAL
- en: To try the formatters, let's set up a small test project.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the console, we will create a small ASP.NET Core web API project, using
    the command shown previously in the *Technical requirements* section:'
  prefs: []
  type: TYPE_NORMAL
- en: First, execute the following commands to add the necessary `GenFu` is an awesome
    library to easily create test data, and the second package, `CsvHelper`, helps
    us to easily write CSV data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the project in Visual Studio or in VS Code and create a new API controller
    called `PersonsController` in the `controller` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PersonsController.cs` and add a `Get()` method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You might need to add the following `using` statements at the beginning of
    the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a list of 25 persons by using `GenFu`. The properties will automatically
    be filled with realistic data. `GenFu` is an open source, fast, lightweight, and
    extendable test data generator. It contains built-in lists of names, cities, countries,
    phone numbers, and so on, and it fills the data automatically into the right properties
    of a class, depending on the property names. For example, a property called `City`
    will be filled with the name of a city, and a property called `Phone`, `Telephone`,
    or `Phonenumber` will be filled with a well-formatted fake phone number. You'll
    see the magic of `GenFu` and the results later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `Models` folder, and create a new file called `Person.cs` with
    the `Person` class inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Program.cs` as well, add the XML formatters, and allow other `AcceptHeader`,
    as described earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it for now. Now, you are able to retrieve the data from the web API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the project by using the `dotnet run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll test the API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best tools to test a web API are **Fiddler** ([https://www.telerik.com/fiddler](https://www.telerik.com/fiddler))
    or **Postman** ([https://www.postman.com/](https://www.postman.com/)). I prefer
    Postman because I find it easier to use. You can use either tool, but in these
    demos, we will use Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: In Postman, create a new request. Enter the API URL, which is [https://localhost:5001/api/persons](https://localhost:5001/api/persons)
    (the port of the URL might vary), into the `address` field, and then, add a header
    with the `Accept` key and the `application/json` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After clicking `GenFu` object puts the data into the person''s properties,
    based on the property type and the property name: real first names and real last
    names, as well as real cities and properly formatted phone numbers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s test the XML output formatter. In Postman, change the `Accept`
    header from `application/json` to `text/xml` and click **Send**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – A screenshot of XML output in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.3_B17996.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – A screenshot of XML output in Postman
  prefs: []
  type: TYPE_NORMAL
- en: We now have an XML-formatted output. Now, let's go a step further and create
    some custom `OutputFormatter` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom OutputFormatter objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, our aim is to create a **VCard** output to be able to import
    the person's contact details directly into **Microsoft** **Outlook** or any other
    contact database that supports VCards. Later in this section, we also want to
    create a CSV output formatter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are text-based output formatters, and they will derive their values from
    `TextOutputFormatter`. Let''s look at the steps to create the VCard output:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in a new file called `VcardOutputFormatter.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, insert the following class skeleton in the new file. You will find the
    implementations of the empty methods in the following code snippets. The constructor
    contains the supported media types and content encodings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You might need to add the following `using` statements:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next code snippet shows the implementation of the `CanWriteType` method.
    It is optional to override this method, but it makes sense to restrict it to a
    specific condition. In this case, the `OutputFormatter` can only format objects
    of the `Person` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to override `WriteResponseBodyAsync` to convert the actual `Person`
    objects into the output you want to have. To get the objects to convert, you need
    to extract them from `OutputFormatterWriteContext` object that gets passed into
    the method. You also get the HTTP response from this context. This is needed to
    write the results and send them to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the method, we check whether we get one person or a list of persons
    and call the not yet implemented `FormatVcard` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To format the output to support standard `Vcard`, you need to do some manual
    work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to register the new `VcardOutputFormatter` object in `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might need to add a `using` statement to `OutputFormatterSample`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the app again using `dotnet run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change the `Accept` header to `text/vcard`, and let's see what happens:![Figure
    12.4 – A screenshot of VCard output in Postman
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.4_B17996.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 12.4 – A screenshot of VCard output in Postman
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now should see all of our data in `VCard` format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s do the same for a CSV output. We already added the `CsvHelper`
    library to the project. So, go to the following URL and download `CsvOutputFormatter`
    to put it into your project: [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at the `WriteResponseBodyAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This almost works the same way as `VcardOutputFormatter`. We can pass the response
    stream via `StreamWriter` directly into `CsvWriter`. After that, we are able to
    feed the persons or the list of persons to the writer. That's it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to register `CsvOutputFormatter` before we can test it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Postman, change the `Accept` header to `text/csv` and click **Send** again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – A screenshot of text/CSV output in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.5_B17996.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – A screenshot of text/CSV output in Postman
  prefs: []
  type: TYPE_NORMAL
- en: There we go – Postman was able to open all of the formats we tested.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Isn't that cool? The ability to change the format based on the `Accept` header
    is very handy. This way, you are able to create a web API for many different clients
    – an API that accepts many different formats, depending on the clients' preferences.
    There are still many potential clients out there that don't use JSON and prefer
    XML or CSV.
  prefs: []
  type: TYPE_NORMAL
- en: The other way around would be an option to consume CSV or any other format inside
    the web API. For example, let's assume your client sends you a list of people
    in CSV format. How would you solve this? Parsing the string manually in the `action`
    method would work, but it's not an easy option.
  prefs: []
  type: TYPE_NORMAL
- en: This is what `ModelBinder` objects can do for us. Let's see how they work in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
