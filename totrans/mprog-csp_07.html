<html><head></head><body>
		<div><h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor118"/>7</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor119"/>Reasoning about Expressions</h1>
			<p>So far, we’ve looked at the powerful metadata that is captured and how we can access it using reflection. We’ve also looked at how we can leverage this same metadata and generate code on the fly at runtime.</p>
			<p>Using reflection and generating code as techniques in metaprogramming are extremely powerful, but they’re not applicable to all scenarios. It can also be very involved and produce hard-to-read and maybe even hard-to-maintain code going deep with reflection and proxy generation.</p>
			<p>C# expressions can, for a lot of scenarios, represent a better approach or an additional approach for specific scenarios for doing runtime discovery and extraction of metadata.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>What are expressions?</li>
				<li>Traversing an expression tree</li>
				<li>Using expressions as descriptors of members on types</li>
			</ul>
			<p>From this chapter, you should understand what expressions are and how you can leverage them as a technique to reason about the running code at runtime.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7</a>), and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found at <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Both the <strong class="source-in ine">GetMemberExpression()</strong> and <strong class="source-in ine">GetPropertyInfo()</strong> methods can be found in the <strong class="source-in ine">ExpressionExtensions.cs</strong> file in <strong class="source-in ine">Fundamentals</strong> in the GitHub repository.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor121"/>What are expressions?</h1>
			<p><strong class="bo d">C# 3.0</strong> was introduced<a id="_idIndexMarker250"/> in <a id="_idIndexMarker251"/>late 2007, and its killer feature was something <a id="_idIndexMarker252"/>called<strong class="bo d"> Language-Integrated Query</strong> (<strong class="bo d">LINQ</strong>). With the underlying API model and combination of new capabilities in C#, it introduced a programming paradigm that bridges into the more functional programming space. The fluent interfaces and its use of lambdas can feel foreign if you’re used to more object-oriented approaches.</p>
			<p>What it brought to the table was a way of expressing queries for data in a more natural native C# way. Not only does it do this for your in-memory collections, but also for any other data source, such as a database. It basically gave developers a uniform way of expressing queries, filters, and projections.</p>
			<p>It did this by recognizing that a query operation consists of the following three distinct<a id="_idIndexMarker253"/> parts:</p>
			<ul>
				<li>The data source</li>
				<li>The query expression</li>
				<li>Executing the query</li>
			</ul>
			<p>Let’s look at an example without LINQ and compare it to how you could do the same with LINQ in a more expressive way:</p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var filtered = new List&lt;int&gt;();
foreach (var item in items)
{
    if( item &gt;= 37 )
    {
        filtered.Add(item);
    }
}
Console.WriteLine(string.Join(',', filtered));</pre>
			<p>Running this would print out <strong class="source-in ine">42, 84, 37</strong>, as expected. The challenge with something like this is that it is very verbose and coupled to the data source and gives no room for optimization.</p>
			<p>With LINQ and the recognition of the three distinct parts mentioned earlier that make up a query, there is a<a id="_idIndexMarker254"/> concept of <strong class="bo d">deferred execution</strong>. The actual execution of the query does not happen until you start enumerating it. That means you can build on the query while its final execution won’t occur until we really need the data. The execution is performed by the query provider, which could be the default in-memory one or <a id="_idIndexMarker255"/>something that represents a data source such as a database.</p>
			<p>Representing the previous sample with LINQ is much more expressive:</p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItems =
    from i in items
    where i &gt;= 37
    select i;
Console.WriteLine(string.Join(',', selectedItems));</pre>
			<p>The code becomes much more readable, but what happens behind the scenes is that it also becomes much more flexible in how it runs and makes it possible to optimize the execution as it sees fit for the data source the query is running against.</p>
			<p>LINQ is a language feature of C#, and it can’t work without support from the .NET class libraries and the .NET runtime. This is where expressions come in.</p>
			<p>As part of the base class libraries that were released at the same time, there was a new namespace called <strong class="source-in ine">System.Linq</strong> and another within it called <strong class="source-in ine">System.Linq.Expressions</strong>. This is where the <em class="ita ic">magic </em><em class="ita ic">sauce</em> lies.</p>
			<p>The C# compiler translates the native LINQ code using another feature that was introduced in C# 3.0 called extension methods. Extension methods are just static methods that look like they’re members of the actual type they extend, they can be used to form a fluent interface that can chain method calls.</p>
			<p>Taking the previous LINQ code, we can express it using expressions and the extension methods that are found in the <strong class="source-in ine">System.Linq</strong> namespace:</p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItemsExpressions = items
    .Where(i =&gt; i &gt;= 37)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',',
  selectedItemsExpressions));</pre>
			<p>All three<a id="_idIndexMarker256"/> approaches discussed so far do the same thing and print out the same result. The biggest difference is readability.</p>
			<p>Since our data source is just an in-memory array, the extension methods will reflect that and you’ll notice the signature of the <strong class="source-in ine">.Where()</strong> method it uses:</p>
			<pre class="source-code">
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this
  IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt;
    predicate);</pre>
			<p>The first parameter is the source it extends, <strong class="source-in ine">IEnumerable&lt;TSource&gt;</strong>, and the second parameter is <strong class="source-in ine">Func&lt;int, bool&gt;</strong>. This means that you’re giving it a callback that will be called to decide whether or not the specific value, while it iterates through them, should be included or not.</p>
			<p>This doesn’t really <a id="_idIndexMarker257"/>bring out the topic of this chapter. Let’s change it up a little to bring out the real<a id="_idTextAnchor122"/> magic.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor123"/>Expression</h2>
			<p>For LINQ to work<a id="_idIndexMarker258"/> as intended with regard to different data sources and deferred execution, there is an interface called <strong class="source-in ine">IQueryable</strong>. The <strong class="source-in ine">IQueryable</strong> interface is something a data source can implement, and instead of having an imperative approach to just iterating the data source, it can now get the query represented as an expression.</p>
			<p>An <strong class="source-in ine">IQueryable</strong> interface gives us different extension methods that expose <strong class="source-in ine">Expression</strong> as a type. Let’s change the array filtering up a little bit and introduce the concept of a queryable:</p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
var selectedItemsExpressions = items
    .AsQueryable()  // Making the array a queryable
    .Where(i =&gt; i &gt;= 37)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',', selectedItems
  Expressions));</pre>
			<p>The <strong class="source-in ine">.AsQueryable()</strong> array changes from an array, or more exactly, <strong class="source-in ine">IEnumerable&lt;int&gt;</strong> becomes <strong class="source-in ine">IQueryable&lt;int&gt;</strong>. That means we get access to a whole set of LINQ <a id="_idIndexMarker259"/>extension methods that are extending <strong class="source-in ine">IQueryable&lt;&gt;</strong>.</p>
			<p>If you look closer at the <strong class="source-in ine">.Where()</strong> method, you’ll notice that one of the extension methods now has the following signature:</p>
			<pre class="source-code">
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this
  IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource,
    bool&gt;&gt; predicate);</pre>
			<p>The first parameter is the source it extends, and the second parameter is <strong class="source-in ine">Expression&lt;Func&lt;TSource, bool&gt;&gt;</strong>. This is the most significant part. The C# compiler recognizes anything that is an expression type, and instead of just creating a callback that gets called, it expands it into an expression.</p>
			<p>In order for us to investigate what the compiler does, we can take the <strong class="source-in ine">where</strong> clause and separate it into its own line of code, enabling us to set a breakpoint in the debugger and look at what is going on:</p>
			<pre class="source-code">
int[] items = { 1, 2, 3, 42, 84, 37, 23 };
// Extracted expression
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;
var selectedItemsExpressions = items
    .AsQueryable()
    .Where(filter)
    .Select(i =&gt; i);
Console.WriteLine(string.Join(',', selectedItems
  Expressions));</pre>
			<p>With the expression extracted into its own line of code, we can easily see what the compiler generates for us. By setting a breakpoint after the <strong class="source-in ine">filter</strong> variable construction <a id="_idIndexMarker260"/>and looking at the <strong class="source-in ine">filter</strong> variable in the watch view of your debugger, you can see the following:</p>
			<div><div><img src="img/B19418_07_1.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The filter expression</p>
			<p>As you can see, it is no longer just a callback. It has captured all the details of what you are expressing. Notice the <strong class="source-in ine">Body</strong> property. This is the inner expression. The type, in our case, is translated into <strong class="source-in ine">LogicalBinaryExpression</strong>, which holds three things of importance:</p>
			<ul>
				<li><strong class="source-in ine">Left</strong></li>
				<li><strong class="source-in ine">NodeType</strong></li>
				<li><strong class="source-in ine">Right</strong></li>
			</ul>
			<p>The <strong class="source-in ine">Left</strong> property represents what is on the left-hand side of the expression, and the <strong class="source-in ine">Right</strong> property represents what is on the right-hand side. And in the middle of this, the operator, <strong class="source-in ine">NodeType</strong>, tells us the action it will be performing.</p>
			<p>For both the <strong class="source-in ine">Left</strong> and <strong class="source-in ine">Right</strong> properties, you also see that their type is <strong class="source-in ine">Expression</strong>. The <strong class="source-in ine">Left</strong> expression, in this case, is <strong class="source-in ine">PrimitiveParameterExpression</strong>, representing the parameter, the value that will be passed if we are iterating or calling the expression. While the <strong class="source-in ine">Right</strong> expression<a id="_idIndexMarker261"/> becomes <strong class="source-in ine">ConstantExpression</strong>, holding the concrete value, the <strong class="source-in ine">NodeType</strong> property is set to <strong class="source-in ine">GreaterThanOrEqual</strong>, which is what was expres<a id="_idTextAnchor124"/>sed by <strong class="source-in ine">&gt;=</strong>.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor125"/>Lambda expression</h2>
			<p>When you <a id="_idIndexMarker262"/>use the <strong class="source-in ine">=&gt;</strong> notation, you form what is known as a <strong class="bo d">lambda expression</strong>. Lambda expressions are anonymous functions. Lambda expressions are divided into the following two types:</p>
			<ul>
				<li>Expression lambdas</li>
				<li>Statement lambdas</li>
			</ul>
			<p>Expression lambdas are characterized by having the right side express an expression. An expression lambda returns the result of the expression and looks like the following:</p>
			<pre class="source-code">
(input parameters) =&gt; expression</pre>
			<p>This is the type of expression used in the expression you saw earlier:</p>
			<pre class="source-code">
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;</pre>
			<p>Its signature is defined by <strong class="source-in ine">Func&lt;int, bool&gt;</strong>, where the first generic argument is the type of the parameter used, and the last generic argument is the return type. You can have multiple parameters.</p>
			<p>Statement lambdas are characterized by it being enclosed in braces, <strong class="source-in ine">{}</strong>, and typically having multiple statements:</p>
			<pre class="source-code">
(input parameters) =&gt; { &lt;sequence of statements&gt; }</pre>
			<p>This could be something like the following code snippet:</p>
			<pre class="source-code">
(string name) =&gt;
{
    var message = $"Hello {name}";
    Console.WriteLIne(message);
}</pre>
			<p>With a statement, a lambda is typically something that is not possible to reason about, as it will not form an expression tree but rather have multiple statements within it.</p>
			<p>Lambdas represent <a id="_idIndexMarker263"/>a very powerful construct that can be used to gain insight into what is going on. It’s also a great way to help understand how expressions work and can be <a id="_idTextAnchor126"/>constructed.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor127"/>Traversing an expression tree</h1>
			<p>An <strong class="source-in ine">Expression</strong> is a simple<a id="_idIndexMarker264"/> construct that represents a node in a tree. The expression has a node type, and the implementation decides what the node type expresses and means. This forms a tree that can be recursively traversed and reasoned about.</p>
			<p>For lambda expressions, it means it has a body that consists of an expression that is of a specific type; this type could <a id="_idIndexMarker265"/>be a <strong class="bo d">Binary Expression</strong> that holds a left and a right and the node itself representing the operand (equals, not equals, and so forth):</p>
			<div><div><img src="img/B19418_07_2.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Binary expression</p>
			<p>Taking the example<a id="_idIndexMarker266"/> of the filter:</p>
			<pre class="source-code">
Expression&lt;Func&lt;int, bool&gt;&gt; filter = (i) =&gt; i &gt;= 37;</pre>
			<p>Visually it looks like the following:</p>
			<div><div><img src="img/B19418_07_3.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 - A parameter larger than the constant expression</p>
			<p>The operand is <strong class="source-in ine">greater than or equal</strong>, the left-hand side accesses the parameter passed into it, and the right-hand side holds the constant value of <strong class="source-in ine">37</strong>.</p>
			<p>Expressions can also represent accessing a member on the type being passed in as a parameter.</p>
			<p>Let’s say we have an object called <strong class="source-in ine">Employee</strong> that looks like the following:</p>
			<pre class="source-code">
public record Employee(string FirstName, string LastName);</pre>
			<p>A filter accessing the first name and looking for a person called <strong class="source-in ine">Jane</strong> would look like the following:</p>
			<pre class="source-code">
Expression&lt;Func&lt;Employee, bool&gt;&gt; employeeFilter =
  (employee) =&gt; employee.FirstName == "Jane";</pre>
			<p>Dissecting the<a id="_idIndexMarker267"/> expression tree, we will see that it now changes into the following:</p>
			<div><div><img src="img/B19418_07_4.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Member access equal constant expression</p>
			<p>Since we’re now accessing a member, the left-hand expression is now <strong class="source-in ine">MemberAccessExpression</strong>. <strong class="source-in ine">MemberAccessExpression</strong> has an expression on it that represents the source that holds the member, in our case, a parameter being passed in. To get the actual member, <strong class="source-in ine">MemberAccessExpression</strong> holds a property called <strong class="source-in ine">Member</strong>. Since the member we’re accessing is a property, it will be the actual <strong class="source-in ine">PropertyInfo</strong>.</p>
			<p>Expressions are not just used for filters; they can represent other operations as well. We could have an expression that represents adding values, such as the following:</p>
			<pre class="source-code">
Expression&lt;Func&lt;int, int&gt;&gt; addExpression = (i) =&gt; i + 42;</pre>
			<p>The expression itself now returns <strong class="source-in ine">int</strong> instead of <strong class="source-in ine">bool</strong>, takes the parameter passed to it, and adds <strong class="source-in ine">42</strong>.</p>
			<p>The expression tree <a id="_idIndexMarker268"/>is shown in the following diagram:</p>
			<div><div><img src="img/B19418_07_5.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Parameter adding constant expression</p>
			<p>As you can see, the node type is <strong class="source-in ine">Add</strong>. This is just one of many types of expressions you can use. You can create really complex structures and represent in an abstract way the core functionality of what the .NET runtime itself is capable of running. We will see more of the different types in <a href="B19418_08.xhtml#_idTextAnchor132"><em class="ita ic">Chapter 8</em></a>, <em class="ita ic">Building and </em><em class="ita ic">Executing<a id="_idTextAnchor128"/> Expressions</em>.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor129"/>Using expressions as descriptors of members on types</h1>
			<p>Expressions<a id="_idIndexMarker269"/> represent a way of describing intent in a declarative fashion. Rather than with an imperative approach where we tell the computer exactly what to do, we can declaratively describe it and let the code decide the best way to approach it.</p>
			<p>As we saw earlier with the filtering of numbers, the imperative approach using <strong class="source-in ine">foreach</strong> does not open for any other execution than what we have put in. While with the LINQ and expression approach, we describe what we want, and the execution is deferred, how it is handled and executed, we don’t know – but the results are the same.</p>
			<p>This type of declarative thinking can be a very powerful way to describe what you want for your system and can also make your code more readable and easier for others to reason about. Imperative code requires you to thoroughly read and understand what the code does, while a declarative approach describes the desired outcome and is much easier to reason about.</p>
			<p>Obviously, a declarative model is limited in its capabilities, while an imperative approach is fully flexible, and you can leverage the full power of the C# language. Combining the two methods is best if you can declaratively describe things using something such as a fluent interface and take full advantage of the C# extension methods to hold methods that represent the imperative actions.</p>
			<p>Let’s take a look at a library called <strong class="source-in ine">FluentValidation</strong> (<a href="https://docs.fluentvalidation.net/en/latest/">https://docs.fluentvalidation.net/en/latest/</a>). It is a library that lets you fluently write validation of input. It takes full advantage of expressions and gives you a declarative model that is extensible using extension methods for describing your intent.</p>
			<p>The following is the sample from their documentation:</p>
			<pre class="source-code">
public class CustomerValidator : AbstractValidator&lt;Customer&gt;
{
  public CustomerValidator()
  {
    RuleFor(x =&gt; x.Surname).NotEmpty();
    RuleFor(x =&gt; x.Forename).NotEmpty().WithMessage("Please
      specify a first name");
    RuleFor(x =&gt; x.Discount).NotEqual(0).When(x =&gt;
      x.HasDiscount);
    RuleFor(x =&gt; x.Address).Length(20, 250);
    RuleFor(x =&gt; x.Postcode).Must(
      BeAValidPostcode).WithMessage("Please specify a
      valid postcode");
  }
  private bool BeAValidPostcode(string postcode)
  {
    // custom postcode validating logic goes here
  }
}</pre>
			<p>The validator<a id="_idIndexMarker270"/> inherits from a base type called <strong class="source-in ine">AbstractValidator&lt;&gt;</strong>, and on this type, there is a method called <strong class="source-in ine">RuleFor()</strong>. This method is the starting point for describing rules for properties on the type passed in as a generic argument to <strong class="source-in ine">AbstractValidator&lt;&gt;</strong>. The <strong class="source-in ine">RuleFor()</strong> signature looks like the following:</p>
			<pre class="source-code">
public IRuleBuilderInitial&lt;T, TProperty&gt;
  RuleFor&lt;TProperty&gt;(Expression&lt;Func&lt;T, TProperty&gt;&gt;
    expression);</pre>
			<p>As you can see, the parameter for <strong class="source-in ine">RuleFor()</strong> is an expression. The expected expression is one that takes the type that was passed to <strong class="source-in ine">AbstractValidator&lt;&gt;</strong> as a parameter and returns any type. <strong class="source-in ine">TProperty</strong> will automatically be inferred by the C# compiler from the expression.</p>
			<p><strong class="source-in ine">FluentValidation</strong> uses this expression to know what property you’re validating by inspecting the expression.</p>
			<p>In <strong class="source-in ine">Fundamentals</strong> part of the code for the book, you’ll find a class called <strong class="source-in ine">ExpressionExtensions</strong> that has helper extension methods for doing the same type of inspection that <strong class="source-in ine">FluentValidation</strong> does.</p>
			<p>Since expressions can describe all kinds of members and the code for finding the member it represents is the same, there is a method for getting the expression that represents the member:</p>
			<pre class="source-code">
public static MemberExpression GetMemberExpression(this
  Expression expression)
{
    var lambda = expression as LambdaExpression;
    if (lambda?.Body is UnaryExpression)
    {
        var unaryExpression = lambda.Body as
          UnaryExpression;
        return (MemberExpression)unaryExpression!.Operand!;
    }
    return (MemberExpression)lambda?.Body!;
}</pre>
			<p>The code <a id="_idIndexMarker271"/>assumes that the incoming expression is <strong class="source-in ine">LambdaExpression</strong> and then checks whether this is a <strong class="source-in ine">UnaryExpression</strong> that holds the member. If it is not <strong class="source-in ine">UnaryExpression</strong>, we assume it is <strong class="source-in ine">MemberExpression</strong>.</p>
			<p>If it is not <strong class="source-in ine">MemberExpression</strong>, this will cause an invalid cast exception. You might want to consider checking types and throw a more specific exception.</p>
			<p>The reason for the check for <strong class="source-in ine">UnaryExpression</strong> is that for expressions that have the type of the value as <strong class="source-in ine">object</strong> and the actual value is a type that needs converting, casting, or unboxing for it to become the <strong class="source-in ine">object</strong> type, the compiler can decide to put in a unary expression that performs this action.</p>
			<p>Once you have the member expression, we can get the actual member as the <strong class="source-in ine">System.Reflection</strong> type that represents a property, <strong class="source-in ine">PropertyInfo</strong>:</p>
			<pre class="source-code">
public static PropertyInfo GetPropertyInfo(this Expression
  expression)
{
    var memberExpression = GetMemberExpression(expression);
    return (PropertyInfo)memberExpression.Member!;
}</pre>
			<p>The code calls <strong class="source-in ine">GetMemberExpression()</strong> and casts <strong class="source-in ine">Member</strong> to <strong class="source-in ine">PropertyInfo</strong>. If the member is not <strong class="source-in ine">PropertyInfo</strong>, this will throw an exception. You might want to check for correctness and throw a more specific exception.</p>
			<p>With <strong class="source-in ine">PropertyInfo</strong> returned, you <a id="_idIndexMarker272"/>now have all the information you need about the described property, its name an<a id="_idTextAnchor130"/>d type, and more.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, we learned about a valuable member of the .NET class libraries called expressions. Thanks to the symbiosis of the C# compiler and the runtime, you get another approach to reason about the running code.</p>
			<p>Expressions represent a structured approach for representing, well, expressions. There is somewhat of a resemblance to an abstract syntax tree, which all code compilers produce when parsing code. Something we’ll get more familiar with in <a href="B19418_15.xhtml#_idTextAnchor250"><em class="ita ic">Chapter 15</em></a>, <em class="ita ic">Roslyn </em><em class="ita ic">Compiler Extensions</em>.</p>
			<p>As we’ve seen in this chapter, the type of expressions can be for just capturing information, but they can also be more powerful and capture operations that can be executed.</p>
			<p>In the next chapter, we will dive deeper into expressions and see how you can build out expressions at runtime that you can then execute dynamically.</p>
		</div>
	</body></html>