<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Accelerate – Creating Generative Animation</h1></div></div></div><p>In this chapter we are going to learn the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basics of procedural animation</li><li class="listitem" style="list-style-type: disc">Animating multiple objects at the same time</li><li class="listitem" style="list-style-type: disc">How to make use of randomness</li><li class="listitem" style="list-style-type: disc">How to benefit from built-in animation easing functions</li></ul></div><p>We will create a relatively simple drawing by using basic shapes and then animate these shapes in a parametric way. We will also learn how to make use of built-in easing functions of Cinder that can make polishing our animations a lot easier.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Preparing the stage</h1></div></div></div><p>Before we begin, open <a class="indexterm" id="id181"/>TinderBox <a class="indexterm" id="id182"/>and create a new project with the name <code class="literal">BasicAnimation</code>. Open <code class="literal">xcode/BasicAnimation.xcodeproj</code> (<code class="literal">vc10\BasicAnimation.sln</code> on Windows). Open <code class="literal">BasicAnimationApp.cpp</code> in the editor so that we can start making changes.</p><p>We are going to change the window size this time as 640 x 480 px might be too small for most of the compositions we will want to create later. To do that, we need to override another Cinder <a class="indexterm" id="id183"/>
<code class="literal">AppBasic</code> method—<code class="literal">prepareSettings()</code>. Add a new declaration just after the <code class="literal">draw()</code> method<a class="indexterm" id="id184"/> declaration as follows:</p><div><pre class="programlisting">class BasicAnimationApp : public AppBasic {
public:
  void setup();
  void update();
  void draw();
<strong>  void prepareSettings( Settings *settings );</strong>
};</pre></div><p>Now add the <a class="indexterm" id="id185"/>implementation of the method that we just declared just before the implementation of the <code class="literal">setup()</code> method:</p><div><pre class="programlisting">void BasicAnimationApp::prepareSettings( Settings *settings ){}</pre></div><p>Let's change <a class="indexterm" id="id186"/>the window size. To do that, add the following line of code inside the <code class="literal">prepareSettings</code> method<a class="indexterm" id="id187"/> implementation:</p><div><pre class="programlisting">settings-&gt;setWindowSize( 800, 600 );</pre></div><p>We will also change the frame rate to something more appropriate for Cinder—60 frames per second is a good choice:</p><div><pre class="programlisting">settings-&gt;setFrameRate( 60 );</pre></div><p>So, this altogether looks as follows:</p><div><pre class="programlisting">void BasicAnimationApp::prepareSettings( Settings *settings ){
  settings-&gt;setWindowSize( 800, 600 );
  settings-&gt;setFrameRate( 60 );
}</pre></div><p>Now compile and run your application to test if it works.</p><p>Next we are going to draw a solid circle. As you might remember from the previous chapters, we have to use the <code class="literal">drawSolidCircle()</code> function<a class="indexterm" id="id188"/> in order to do that.</p><p>Navigate to the <code class="literal">draw()</code> member function implementation in the <code class="literal">BasicAnimationApp.cpp</code> file and add the following line of code just after the <code class="literal">gl::clear()</code> function call:</p><div><pre class="programlisting">gl::drawSolidCircle( getWindowCenter(), 30 );</pre></div><p>This draws a white circle with a radius of 30 pixels in the center of the window. As this chapter is about animation, let's think of some ways to move this circle.</p><div><img alt="Preparing the stage" src="img/9564_06_01.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Adding animation</h1></div></div></div><p>As we already <a class="indexterm" id="id189"/>know, in <a class="indexterm" id="id190"/>each frame before we draw something, we use black color to clear everything that is left there from the previous frame. We use <code class="literal">gl::clear()</code> <a class="indexterm" id="id191"/>to do that. To create the effect of moving something, we need to change the object's position in each frame.</p><p>To do that, we will need to replace the values of the <code class="literal">drawSolidCircle</code> position parameters to variables. Let's declare a new variable that will hold the position of the circle on the screen:</p><div><pre class="programlisting">  void prepareSettings( Settings *settings );
<strong>  Vec2f currentPosition;</strong>
};</pre></div><p>This variable will hold the <code class="literal">x</code> and <code class="literal">y</code> position of the circle that we are drawing inside the <code class="literal">draw()</code> method.</p><p>Now we will set the initial value of the variable in <a class="indexterm" id="id192"/>the <code class="literal">setup()</code> method:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
<strong>  currentPosition = getWindowCenter();</strong>
}</pre></div><p>As you can see, a part of the preceding code snippet is the same as we used in the <code class="literal">drawSolidCircle()</code> function<a class="indexterm" id="id193"/> call. We just made it changeable.</p><p>Finally, <a class="indexterm" id="id194"/>we have to replace the values <a class="indexterm" id="id195"/>in the <code class="literal">drawSolidCircle()</code> function to the newly created variable:</p><div><pre class="programlisting">void BasicAnimationApp::draw() {
  gl::clear( Color( 0, 0, 0 ) );
  gl::drawSolidCircle( <strong>currentPosition, 30</strong> );
}</pre></div><p>Compile and run our application. Nothing much has changed. Don't worry about that and add the following line of code before the <code class="literal">drawSolidCircle()</code> function call:</p><div><pre class="programlisting">currentPosition.x++;</pre></div><p>Compile and run the application again and there it is, a moving circle. Cool! We have our first animation! Now let's do something with the radius of the circle. To apply animation to it, we have to declare a new variable again:</p><div><pre class="programlisting">  void prepareSettings( Settings *settings );
  Vec2f currentPosition;
<strong>  float circleRadius;</strong>
};</pre></div><p>Now, set its starting value:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
  currentPosition = getWindowCenter();
  circleRadius = 100;
}</pre></div><p>And add an animation rule and replace the constant value of the circle radius parameter of the <code class="literal">drawSolidCircle()</code> function<a class="indexterm" id="id196"/> call in the <code class="literal">draw()</code> method <a class="indexterm" id="id197"/>implementation:</p><div><pre class="programlisting">  currentPosition.x++;
  circleRadius--;
  gl::drawSolidCircle( currentPosition, circleRadius );
}</pre></div><p>Compile and run our application. You should see a big white point disappearing in front of your eyes. It might seem that you did something wrong, but don't worry, everything is correct. The trick is that we decreased the circle radius by one pixel for each frame. It is happening at a rate of 60 times per second and that means that the radius of the circle will reach <code class="literal">0</code> in approximately 1.5 seconds. Therefore, if the radius is <code class="literal">0</code>, the circle becomes invisible as there can be no circle without a radius.</p><p>So far so good. Let's try to move our circle to some fixed location over time. Let's say we want to move it from the top-left corner of the screen to the bottom right. To do that we need to set the initial position of the circle to <code class="literal">0</code>. and let's change the initial <code class="literal">circleRadius</code> to something smaller as well:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
  currentPosition = <strong>Vec2f(0,0)</strong>;
  circleRadius = <strong>100</strong>;
}</pre></div><p>Let's <a class="indexterm" id="id198"/>declare<a class="indexterm" id="id199"/> another <code class="literal">Vec2f</code> variable that will hold the target position of the circle in the class declaration:</p><div><pre class="programlisting">  Vec2f currentPosition;
<strong>  Vec2f targetPosition;</strong>
  float circleRadius;
};</pre></div><p>We need to set the initial target position somewhere, so we have to add a new line in the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
  currentPosition = Vec2f(0,0);
<strong>  targetPosition = Vec2f(800,600);</strong>
  circleRadius = 100;
}</pre></div><p>Finally, we need to write some code that creates a smooth transition between <code class="literal">currentPosition</code> and <code class="literal">targetPosition</code>. Let's do it in the <code class="literal">update()</code> method implementation as it is meant for such calculations. Remember, try to use the <code class="literal">draw()</code> method just for drawing and place all your calculations inside <code class="literal">update()</code>. It does not matter much for a small application such as this one, but as your code grows bigger, it is possible that the application won't perform so well or will even crash if you don't stick to this simple rule.</p><div><pre class="programlisting">void BasicAnimationApp::update() {
  Vec2f difference = targetPosition - currentPosition;
  difference *= 0.95f;
  currentPosition = targetPosition - difference;
}</pre></div><p>These three lines of code calculate the difference between the current circle position and the target circle position. Then, we make the difference between these positions smaller by multiplying it with a floating point number that is smaller than <code class="literal">0</code>. Finally, we calculate the new current position by subtracting the new difference from the target position of the circle.</p><p>This <a class="indexterm" id="id200"/>would require a longer code if we didn't make use of the <a class="indexterm" id="id201"/>integrated vector algebra features of Cinder. As a <code class="literal">Vec2f</code> object contains two values (the x and the y coordinate), when we multiply it with a single value, both values inside the <code class="literal">Vec2f</code> object<a class="indexterm" id="id202"/> are multiplied by this value. Furthermore, if we multiply a <code class="literal">Vec2f</code> object with another <code class="literal">Vec2f</code> object, the first element of the first vector is multiplied with the first element of the second one, and the second element of the first one is multiplied with the second element of the second one, and so on.</p><p>Now compile and run our application. You should see a circle moving from the top-left corner to the bottom-right corner of the screen.</p><div><img alt="Adding animation" src="img/9564_06_02.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Adding randomness</h1></div></div></div><p>Let's add a bit of <a class="indexterm" id="id203"/>unpredictability to this by using the almighty random functions. To use them in Cinder, you have to include a header file that contains the necessary code:</p><div><pre class="programlisting">#include "cinder/Rand.h"</pre></div><p>Add this in the beginning of the <code class="literal">BasicAnimationApp.cpp</code> file. Next, we need to calculate random target position in the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
  currentPosition = Vec2f(0,0);
<strong>  targetPosition.x = Rand::randFloat(0, getWindowWidth());</strong>
<strong>  targetPosition.y = Rand::randFloat(0, getWindowHeight());</strong>
  circleRadius = 100;
}</pre></div><p>Now each time you run the application, a different end position will be calculated and the circle will fly to a different place on the screen.</p><p>Let's change the current position of the circle to something random as well:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
<strong>  currentPosition.x = Rand::randFloat(0, getWindowWidth());</strong>
<strong>  currentPosition.y = Rand::randFloat(0, getWindowHeight());</strong>
  targetPosition.x = Rand::randFloat(0, getWindowWidth());
  targetPosition.y = Rand::randFloat(0, getWindowHeight());
  circleRadius = 100;
}</pre></div><p>Compile and run the application to see the change.</p><p>It might seem a bit boring to see just one random animation after you have opened an application. People usually expect something more. So how about we calculate a new random end position as the circle reaches its current end position? Ok, let's do that! Add the following piece of code in the <code class="literal">update()</code> method implementation just after <code class="literal">currentPosition = targetPosition - difference;</code>:</p><div><pre class="programlisting">if ( currentPosition.distance(targetPosition) &lt; 1.0f ) {
  targetPosition.x = Rand::randFloat(0, getWindowWidth());
  targetPosition.y = Rand::randFloat(0, getWindowHeight());
}</pre></div><p>Comment out or delete the following highlighted lines from the <code class="literal">draw()</code> method:</p><div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) );
<strong>//currentPosition.x++;</strong>
<strong>//circleRadius--;</strong>
gl::drawSolidCircle( currentPosition, circleRadius );</pre></div><p>Compile and <a class="indexterm" id="id204"/>run our application. This is a bit more interesting, but still it needs something more to be complete.</p><div><img alt="Adding randomness" src="img/9564_06_03.jpg"/></div><p>How about we try to handle more than one circle on the screen? It would be worth explaining how to create a particle system as a separate class, but this won't fit in the scope of this book, so we will continue to make some changes in the same file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>More circles</h1></div></div></div><p>Let's <a class="indexterm" id="id205"/>define the <a class="indexterm" id="id206"/>count of the circles that we want the application to handle. Add the following line of code just after the<a class="indexterm" id="id207"/> <code class="literal">#include</code> statements:</p><div><pre class="programlisting">#define CIRCLE_COUNT 100</pre></div><p>Now, let's go to the class declaration part and change the declarations of our variables to arrays:</p><div><pre class="programlisting">Vec2f currentPosition[CIRCLE_COUNT];
Vec2f targetPosition[CIRCLE_COUNT];
float circleRadius[CIRCLE_COUNT];</pre></div><p>As you can see, we used the previously defined constant as the size of our arrays. By doing that we can change the circle count easily later.</p><p>Next, we have to change some code in the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">void BasicAnimationApp::setup() {
  for(int i=0; i&lt;CIRCLE_COUNT; i++) {
    currentPosition[i].x=Rand::randFloat(0,getWindowWidth());
    currentPosition[i].y=Rand::randFloat(0,getWindowHeight());
    targetPosition[i].x=Rand::randFloat(0,getWindowWidth());
    targetPosition[i].y=Rand::randFloat(0,getWindowHeight());
    circleRadius[i] = Rand::randFloat(1, 10);
  }
}</pre></div><p>Basically, we wrapped the same code we had before into a <code class="literal">for</code> loop that iterates over all our parameter arrays and sets initial values for each of them.</p><p>Don't compile yet as we still have to make changes to the <code class="literal">update()</code> and <code class="literal">draw()</code> methods in a similar way. Change our <code class="literal">update()</code> method as follows:</p><div><pre class="programlisting">void BasicAnimationApp::update() {
  Vec2f difference;
  for (int i=0; i&lt;CIRCLE_COUNT; i++) {
    difference = targetPosition[i] - currentPosition[i];
    difference *= 0.95f;
    currentPosition[i] = targetPosition[i] - difference;

    if (currentPosition[i].distance(targetPosition[i]) &lt; 1.0f) {
      targetPosition[i].x =
      Rand::randFloat(0,getWindowWidth());
      targetPosition[i].y =
      Rand::randFloat(0,getWindowHeight());
    }
  }
}</pre></div><p>And lastly, change our <code class="literal">draw()</code> method implementation as follows:</p><div><pre class="programlisting">void BasicAnimationApp::draw() {
  gl::clear( Color( 0, 0, 0 ) );
  for (int i=0; i&lt;CIRCLE_COUNT; i++) {
    gl::drawSolidCircle( currentPosition[i], circleRadius[i] );
  }
}</pre></div><p>Compile <a class="indexterm" id="id208"/>and <a class="indexterm" id="id209"/>run our application now. This looks a bit more interesting!</p><div><img alt="More circles" src="img/9564_06_04.jpg"/></div><p>It seems that 100 circles are not enough, so how about we set the <code class="literal">CIRCLE_COUNT</code> constant to <code class="literal">1000</code>?</p><div><pre class="programlisting">#define CIRCLE_COUNT 1000</pre></div><p>No problem!</p><p>But what if we don't want to focus on quantity, but on the quality of movement? This is where animation easing joins the game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Using built-in eases</h1></div></div></div><p>Now, say we want to <a class="indexterm" id="id210"/>make use of the easing algorithms that we saw in the <code class="literal">EaseGallery</code> <a class="indexterm" id="id211"/>sample. To do that, we have to change the code by following certain steps.</p><p>To use the easing functions, we have to include the <code class="literal">Easing.h</code> header file:</p><div><pre class="programlisting">#include "cinder/Easing.h"</pre></div><p>First we are going to add two more variables, <code class="literal">startPostition</code> and <code class="literal">circleTimeBase</code>:</p><div><pre class="programlisting">
<strong>Vec2f startPosition[CIRCLE_COUNT];</strong>
Vec2f currentPosition[CIRCLE_COUNT];
Vec2f targetPosition[CIRCLE_COUNT];
float circleRadius[CIRCLE_COUNT];
<strong>float circleTimeBase[CIRCLE_COUNT];</strong>
</pre></div><p>Then, in the <code class="literal">setup()</code> method implementation, we have to change the <code class="literal">currentPosition</code> parts to <code class="literal">startPosition</code> and add an initial value to the <code class="literal">circleTimeBase</code> array members:</p><div><pre class="programlisting">startPosition[i].x = Rand::randFloat(0, getWindowWidth());
startPosition[i].y = Rand::randFloat(0, getWindowHeight());
circleTimeBase[i] = 0;</pre></div><p>Next, we have to change the <code class="literal">update()</code> method so that it can be used along with the easing functions. They are based on time and they return a floating point value between <code class="literal">0</code> and <code class="literal">1</code> that defines the <code class="literal">playhead</code> position on an abstract <code class="literal">0</code> to <code class="literal">1</code> timeline:</p><div><pre class="programlisting">void BasicAnimationApp::update() {
  Vec2f difference;
  for (int i=0; i&lt;CIRCLE_COUNT; i++) {
<strong>    difference = targetPosition[i] - startPosition[i];</strong>
<strong>    currentPosition[i] = easeOutExpo(</strong>
<strong>      getElapsedSeconds()-circleTimeBase[i]) *</strong>
<strong>      difference + startPosition[i];</strong>

    if ( currentPosition[i].distance(targetPosition[i])
    &lt; 1.0f )
    {
      targetPosition[i].x =
      Rand::randFloat(0, getWindowWidth());
      targetPosition[i].y =
      Rand::randFloat(0, getWindowHeight());
<strong>      startPosition[i] = currentPosition[i];</strong>
<strong>      circleTimeBase[i] = getElapsedSeconds();</strong>
    }
  }
}</pre></div><p>The highlighted parts in the preceding code snippet are those that have been changed. The most important part of it is the <code class="literal">currentPosition[i]</code> calculation part. We take the distance between the start and end points of the timeline and multiply it with the position floating point number that is being <a class="indexterm" id="id212"/>returned by our easing function, which in this case is <code class="literal">easeOutExpo()</code>. Again, it returns a floating point variable between <code class="literal">0</code> and <code class="literal">1</code> that represents the position on an abstract <code class="literal">0</code> to <code class="literal">1</code> timeline. If we multiply any number with, say, <code class="literal">0.33f</code>, we get one-third of that number, <code class="literal">0.5f</code>, we get one-half of that number, and so on. So, we add this distance to the circle's starting position and we get it's current position!</p><p>Compile and run <a class="indexterm" id="id213"/>our application now. You should see something as follows:</p><div><img alt="Using built-in eases" src="img/9564_06_05.jpg"/></div><p>Almost like a snow storm! We will add a small modification to the code though. I will add a <code class="literal">TWEEN_SPEED</code> definition at the top of the code and multiply the <code class="literal">time</code> parameter passed to the ease function with it, so we can control the speed of the circles:</p><div><pre class="programlisting">#define TWEEN_SPEED 0.2</pre></div><p>Change the<a class="indexterm" id="id214"/> following line in the <code class="literal">update()</code> method implementation:</p><div><pre class="programlisting">currentPosition[i] = easeOutExpo(
<strong>  (getElapsedSeconds()-circleTimeBase[i])*TWEEN_SPEED) *</strong>
  difference + startPosition[i];</pre></div><p>I did this because the default time base for each tween is 1 second. That means that each transition is happening exactly for 1 second and that's a bit too fast for our current situation. We want it to be slower, so we multiply the time we pass to the easing function with a floating point number that is less than <code class="literal">1.0f</code> and greater than <code class="literal">0.0f</code>. By doing that we ensure that the time is scaled down and instead of 1 second we get 5 seconds for our transition.</p><p>So try to compile and run this, and see for yourself! Here is the full source code of our circle-creation:</p><div><pre class="programlisting">#include "cinder/app/AppBasic.h"
#include "cinder/gl/gl.h"
#include "cinder/Rand.h"
#include "cinder/Easing.h"

#define CIRCLE_COUNT 100
#define TWEEN_SPEED 0.2

using namespace ci;
using namespace ci::app;
using namespace std;

class BasicAnimationApp : public AppBasic {
  public:
  void setup();
  void update();
  void draw();

  void prepareSettings( Settings *settings );
  Vec2f startPosition[CIRCLE_COUNT];
  Vec2f currentPosition[CIRCLE_COUNT];
  Vec2f targetPosition[CIRCLE_COUNT];
  float circleRadius[CIRCLE_COUNT];
  float circleTimeBase[CIRCLE_COUNT];
};

void BasicAnimationApp::prepareSettings( Settings *settings ) {
  settings-&gt;setWindowSize(800,600);
  settings-&gt;setFrameRate(60);
}

void BasicAnimationApp::setup() {
  for(int i=0; i&lt;CIRCLE_COUNT; i++) {
    currentPosition[i].x=Rand::randFloat(0, getWindowWidth());
    currentPosition[i].y=Rand::randFloat(0, getWindowHeight());
    targetPosition[i].x=Rand::randFloat(0, getWindowWidth());
    targetPosition[i].y=Rand::randFloat(0, getWindowHeight());
    circleRadius[i] = Rand::randFloat(1, 10);
    startPosition[i].x = Rand::randFloat(0, getWindowWidth());
    startPosition[i].y = Rand::randFloat(0, getWindowHeight());
    circleTimeBase[i] = 0;
  }
}

void BasicAnimationApp::update() {
  Vec2f difference;
  for (int i=0; i&lt;CIRCLE_COUNT; i++) {
    difference = targetPosition[i] - startPosition[i];
    currentPosition[i] = easeOutExpo(
      (getElapsedSeconds()-circleTimeBase[i]) *
      TWEEN_SPEED) *
      difference + startPosition[i];

      if ( currentPosition[i].distance(
      targetPosition[i]) &lt; 1.0f )
    {
      targetPosition[i].x =
      Rand::randFloat(0, getWindowWidth());
      targetPosition[i].y =
      Rand::randFloat(0, getWindowHeight());
      startPosition[i] = currentPosition[i];
      circleTimeBase[i] = getElapsedSeconds();
    }
  }
}

void BasicAnimationApp::draw() {
  gl::clear( Color( 0, 0, 0 ) );
  for (int i=0; i&lt;CIRCLE_COUNT; i++) {
    gl::drawSolidCircle( currentPosition[i], circleRadius[i] );
  }
}

CINDER_APP_BASIC( BasicAnimationApp, RendererGl )</pre></div><p>Experiment<a class="indexterm" id="id215"/> with the properties and try to change the eases. Not all of them will work with this example, but at least you will understand how to use them to create smooth animations with Cinder.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we created our first generative animation application. We learned how to use instance variables for creating smooth movements and random functions to generate unpredictable results in predictable scale. We also used static arrays to change the count of the circles in the simulation and made use of Cinder easing functions that can prove themselves very handy when creating Flash-like applications (you might know the TweenLite tweening library, if you have some Flash coding background).</p><p>Finally, we tested the application with a relatively high amount of objects. This part should prove to you the real power of Cinder as you might know that creating a similar application with other frameworks based on non-C++ platforms does not run as smooth as this one.</p><p>In the next chapter, we will talk about real-time post-processing and basic methods for applying image, as well as video effects with Cinder.</p></div></body></html>