- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Application Settings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial. ASP.NET Core 9 provides a robust configuration
    system that allows developers to manage settings and behavior effectively. This
    chapter will explore the importance of application settings, how to manage them
    using the configuration system, and how to make your applications adaptable at
    runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **IConfiguration** concepts and abstractions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with configuration providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the Options pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dynamic configurations and behaviors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides a robust configuration system that allows developers
    to effectively manage configurations and behaviors. This chapter will explore
    the importance of application configurations, how to manage them using the configuration
    system, and how to make your applications adaptive at runtime.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : The Docker engine must be installed on your operating system and
    have a SQL Server container running. You can find more details about Docker and
    SQL Server containers in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis Insight** : This tool is used to connect to a Redis server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also need access to an Azure subscription.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IConfiguration concepts and abstractions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial, in addition to security requirements
    that have become increasingly essential in applications that run on different
    cloud providers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Most web applications have some type of configuration managed in files or classes,
    in order to centralize parameters that are used throughout the application flow.
    With each change in configurations or even application behaviors, a new version
    of the software must be generated. Furthermore, when working with remote teams,
    it is essential to maintain the correct management of configurations and sensitive
    data and not keep these parameters versioned in the application version control.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides powerful ways to manage application configurations in
    addition to enabling the use of other features, such as changing application behaviors
    without the need to generate new versions of the software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We will start learning about these resources via the fundamentals of configuration
    management through the **IConfiguration** interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: IConfiguration interface
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has the **IConfiguration** interface, which aims to provide a
    mechanism for managing application settings and configurations in a unified manner,
    allowing access to diverse configuration sources such as JSON files, environment
    variables, and arguments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the main concepts regarding the **IConfiguration** interface, we have
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration sources** : Support multiple configuration sources, which can
    be combined and layered. Common sources include JSON files (such as **appsettings.json**
    ), environment variables, command-line arguments, and user secrets.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchical configuration** : Configuration settings are organized in a
    hierarchical structure. This means that settings can be nested into sections,
    making complex settings easier to manage.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options pattern** : The Options pattern uses **IConfiguration** to bind configuration
    settings to strongly typed objects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we used the **appsettings.json**
    file to manage the connection string with the SQL Server database and retrieved
    the value of this configuration through the **IConfiguration** interface, in the
    **Program.cs** class. This practice brings several benefits, such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility** : **IConfiguration** allows you to extract configuration values
    from multiple sources, offering flexibility in how you manage configurations across
    different environments (development, test, production)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized management** : Centralizes configuration management, making it
    easier to maintain and update settings without spreading them across the application'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment-specific settings** : Supports environment-specific configuration,
    allowing you to customize settings based on the environment in which the application
    is running'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strongly typed configuration** : Through the Options pattern, it supports
    configuration settings linked to strongly typed classes, improving type safety
    and reducing errors'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code examples demonstrate a configuration defined in the **appsettings.json**
    file; this value is then retrieved through the **IConfiguration** interface, in
    the **Program.cs** file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of the **appsettings.json** file:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the content of the **Program.cs** file:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the highlighted line of the previous code snippet, the connection
    string is obtained from the **appsettings.json** file using the **IConfiguration**
    interface, using the **GetConnectionString** method and informing the configuration
    name or key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: As the **IConfiguration** lifecycle considers the application lifecycle, all
    the complexity of obtaining settings through files such as **appsettings.json**
    or other data sources is abstracted, simply using the methods available in the
    interface to obtain the desired parameters throughout the ASP.NET Core 9 application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The **IConfiguration** interface is also available in the **dependency injection
    container** ( **DIC** ), allowing you to reference it in the constructor of any
    application class that will have its dependencies resolved dynamically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: IConfiguration methods
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The **IConfiguration** interface provides several extension methods that offer
    different ways to obtain configuration data in ASP.NET Core 9 applications. See
    the following link for more details: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0)
    .'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The process of obtaining configurations in JSON files is a standard model for
    use in ASP.NET Core 9 applications. However, there are other ways of managing
    configurations, and for this possibility, there is the concept of providers, which
    we will explore in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Working with configuration providers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration providers allow configurations to be obtained from various sources,
    such as JSON files, environment variables, and more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Through configuration providers, we have greater flexibility and the ability
    to prepare our applications to run in different environments (such as development,
    test, or production) in an appropriate way without the need to implement string
    replacement logic in JSON files, in addition to bringing greater reliability and
    security.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will understand how to add other configuration providers to our ASP.NET
    Core 9 applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Adding configuration providers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration providers are used to read configuration data from various sources.
    This flexibility allows you to manage your application’s configuration settings
    in a consistent and centralized manner.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to use configuration sources such as databases and even
    cloud services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 9, there are already some configuration providers integrated
    by default, such as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON configuration provider** : Reads configuration data from JSON files
    such as **appsettings.json**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variable configuration provider** : Reads configuration data
    from environment variables'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line configuration provider** : Reads configuration data from command-line
    arguments'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory configuration provider** : Allows you to add in-memory configuration
    data, useful for unit testing'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the implementation of example applications in this book, we have constantly
    used the following method in the **Program.cs** file: **WebApplication.CreateBuilder(args);**
    .'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This method creates an instance of a **Builder** object, which represents a
    web application and allows us to add features such as services, middleware, and
    configurations. It creates a web application builder with some default parameters,
    so there is no need to define the provider configuration to obtain configuration
    data from the **appsettings.json** file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Default builder settings
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CreateBuilder** method defines some standardized parameters for the builder
    that will be created. You can learn more about these parameters by accessing the
    following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings)
    .'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'However, observe the following code example from the **Program.cs** file where
    configuration providers are explicitly added:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses two extension methods, **AddEnvironmentVariables** and
    **AddCommandLine** , allowing the application to obtain configurations from different
    providers. These extension methods are natively part of ASP.NET Core 9 applications.
    For other types of providers, it may be necessary to add NuGet packages to have
    access to extension methods for registering providers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Built-in ASP.NET Core 9 configuration providers
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core 9 offers several types of providers natively, as presented in
    the documentation: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers)
    .'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In the *Working with dynamic configurations and behaviors* section, we will
    use a provider to connect to a cloud resource that allows the management of configurations
    and behaviors in a dynamic and secure way. For now, let’s understand some important
    fundamentals, such as creating custom providers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom configuration provider
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a custom configuration provider in ASP.NET Core 9 allows you to load
    configuration data from sources not natively supported by the framework. This
    can be useful for integrating with custom configuration stores, third-party services,
    or even proprietary formats.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We already understand configuration management in native provisions in ASP.NET
    Core 9; now, we will create our first custom provider.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom provider, you need to create two classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**ConfigurationSource** : The **IConfigurationSource** interface represents
    a source of configuration data. It is responsible for creating an instance of
    **IConfigurationProvider** , which will actually load the data. Separating the
    source and provider interfaces allows for a clear delineation between where configuration
    data comes from and how it is loaded. Through this approach, we benefit from encapsulating
    data source configurations and implementing best practices through the **Factory**
    pattern.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigurationProvider** : The **ConfigurationProvider** class is an abstract
    base class that implements **IConfigurationProvider** . It is responsible for
    the actual loading and providing of configuration data. This class allows you
    to define how data is read, cached, and accessed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start creating a custom provider through the class responsible for
    creating a custom provider instance:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **IConfigurationSource** interface has only one method, **Build()** , which
    is responsible for returning a custom provider instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Despite being simple, this class allows for better separation of responsibilities,
    with the sole objective of providing an instance of the provider that will have
    all the necessary mechanisms for interacting with another data source.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the **CustomConfigurationProvider** class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The custom provider implemented in the preceding code has an inheritance from
    the abstract **ConfigurationProvider** class, which already has some utility implementations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: For this provider, we are creating two configurations that will be managed by
    an object of type **Dictionary<string, string>** , allowing us to create configurations
    based on key and value in memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The logic for managing provided information must be implemented by overriding
    the **Load** method, inherited from the **ConfigurationProvider** class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the **Load** method, it is necessary to set the value of the **Data**
    property, also inherited from the **ConfigurationProvider** class. The data type
    of the **Data** property is **Dictionary<string, string?>** ; that is, representing
    a key-value pair. Settings are persisted or serialized in string format. However,
    even with this feature, it is possible to create strongly typed configurations.
    We will cover this approach in the *Learning the Options* *pattern* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a simple and didactic example. However, we can easily connect
    the custom provider to a SQL Server database, a storage account, or any other
    persistence resource. In the book’s code repository, the link to which is in the
    *Technical requirements* section, you can analyze another version of a custom
    provider where the data is persisted in a database. However, the implementation
    principles are the same as those demonstrated in the previous code snippets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'For the new provider to be used, simply add the following code to the **Program.cs**
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also use the extension method creation technique learned in [*Chapter
    8*](B21788_08.xhtml#_idTextAnchor132) .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the settings through the new provider, simply use **Configuration**
    property methods, such as the **GetValue<T>** method, and rename the desired configuration,
    as demonstrated in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the creation of a custom provider does not change the development
    model already available in ASP.NET Core 9, bringing greater flexibility and possibilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Providers are an excellent abstraction for configuration management. However,
    ASP.NET Core 9 provides other types, such as the Options pattern, which we will
    discuss in the next section, making the configuration management model in our
    applications even more powerful.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Options pattern
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 offers a good way to handle application configurations through
    the use of the Options pattern. This pattern provides a robust mechanism for managing
    and accessing configuration settings in a strongly typed manner, improving the
    maintainability and testability of your code and organizing configuration settings
    into classes. In this section, we will understand what the Options pattern is
    and how to implement it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: What is the Options pattern?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every application must interact with some type of configuration, and in the
    previous chapters, we used the **IConfiguration** interface to obtain continuous
    information in the **appsettings.json** file. However, this is not the only way
    to interact with configurations in ASP.NET Core 9, which offers an implementation
    of the Options pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern is a design pattern that uses classes to represent groups
    of related configurations, allowing you to link configuration sections from various
    configuration sources (such as JSON files, environment variables, and so on) to
    these classes, allowing access to configuration settings, type-safe configuration,
    leveraging IntelliSense, and compile-time checking.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 9, the Options pattern has the following class hierarchy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9](img/B21788_09_01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in *Figure 9* *.1* , there are several interfaces for abstracting
    the Options pattern, in addition to their respective implementations. Let’s briefly
    understand the purpose of each of the interfaces represented in *Figure 9* *.1*
    :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**IOptions<T>** : The basic interface used to retrieve configured options.
    **IOptions<T>** types are registered as singletons. Then, when starting the application,
    the configurations are loaded into memory and made available throughout the application
    using **dependency injection** ( **DI** ). However, if any changes are made to
    the application so that they can be reflected, the application must be restarted.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IOptionsSnapshot<T>** : A variation of **IOptions<T>** that provides a mechanism
    that updates configurations with each request. This interface allows application
    settings to be updated in real time. The lifecycle of this class is scoped; that
    is, the configurations are loaded with each request.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IOptionsMonitor<T>:** An interface that allows you to monitor option changes
    and provides a way to receive notifications when options are updated. The lifecycle
    of this interface is singleton, available when the application is initialized.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that do not have the “ **I** ” prefix represent the concrete implementation
    of each interface.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Options pattern offers an excellent option for manipulating configurations
    without the need to call strings but by creating strongly typed configurations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand how the Options pattern is implemented.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Options pattern
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned throughout the book’s chapters, it is a good practice to centrally
    manage configuration information, and in most of the code available in this book,
    we use basic configurations, such as a database connection string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Although the **IConfiguration** interface provides us with mechanisms for obtaining
    configurations, in some cases, this can affect the management and responsibilities
    of each class, which must know exactly the strings it wants to obtain from the
    configuration file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: There are practices such as the use of constants; however, working with strongly
    typed classes to aggregate a set of information can be a powerful resource.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine the following context:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an e-commerce application, where we have different services and resources
    such as payment and shipping. These resources have a set of distinct settings.
    In this example, we would have approximately the following configurations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**PaymentGatewayURL** : URL of the gateway responsible for processing the payment'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIKey** : API key for using the payment gateway'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout** : Timeout configuration'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DefaultCarrier** : Default carrier for delivering orders'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreeShippingThreshold** : Free shipping threshold setting'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When developing the e-commerce application, for each configuration, it would
    be necessary to use the **IConfiguration** class to obtain data from the **appsettings.json**
    file, for example. Let’s look at the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding settings would be available in the **appsettings.json** file
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The implementation of the settings recovery code demonstrated is correct. However,
    in more complex scenarios, it may be difficult to manage different types of configurations;
    there may be code duplications, which makes maintenance difficult, and if there
    is a typing error in the configuration key, for example, this problem will only
    be detected at runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, through the abstraction of the Options pattern in ASP.NET Core
    9, we have the possibility of grouping configurations in a simple way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding example, we basically have two types of information:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**PaymentSettings**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PaymentGatewayURL**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIKey**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShipmentSettings**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DefaultCarrier**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreeShippingThreshold**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, we could group the configurations into two distinct classes, as shown
    in *Figure 9* *.2* :'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Grouping configurations](img/B21788_09_02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Grouping configurations
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding classes only have the properties that will reference the respective
    configurations in a grouped manner. With this, we will have the following code
    defining **PaymentSettings** and **ShipingmentSettings** classes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The classes represented in the preceding code only aim to abstract a set of
    configurations, not having any types of implemented behaviors, but there may be
    methods if necessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the classes that will be used in the Options pattern must follow the
    following rules:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Being non-abstract
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having public read-and-write properties
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields are disregarded during binding
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, we will just keep the properties. Additionally, we will change
    the **appsettings.json** file, which will have the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see in the preceding code that the settings are grouped by **PaymentSettings**
    and **ShippingSettings** , which are exactly the names of the classes, and respectively,
    the properties also have the same names.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern uses this convention to bind the settings with the class
    that will abstract this information in the application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the **Program.cs** file with the changes made to use the
    Options pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in the highlighted code lines in the preceding code block, the
    **GetSection** method is used from the **IConfiguration** interface, accessed
    through the **Configuration** extension method. The **GetSection** method is a
    generic implementation, where the type entered determines the return type. The
    name of the section is entered as a parameter, which, in this case, is the desired
    configuration group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, to facilitate understanding, we are registering
    the configuration classes using the Options pattern directly in the **Program.cs**
    file. However, it is good practice to create an extension method for registering
    classes that use the Options pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: When executing these methods, the settings will be loaded into a **PaymentSettings**
    or **ShipmentSettings** object and these will be instantiated as a singleton and
    available in every application through the DIC.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of code where the configurations depend on a given
    service class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we noted in the **OrderService** implementation, we just injected an **IOptions**
    interface for the **PaymentSettings** type. With this, the dependency is resolved
    by the ASP.NET Core 9 DIC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Adopting the Options pattern offers several benefits, such as allowing the organization
    of configuration settings, grouping them into dedicated classes, and the use of
    strongly typed configuration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In addition to improving maintenance and implementation quality, errors can
    also be detected during compilation time. You can also benefit from using unit
    tests, which is an excellent practice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The Options pattern in ASP.NET Core 9 is a powerful and flexible way to manage
    configuration settings, supporting environment-specific configurations and making
    it easier to manage configurations for different deployment environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to use the Options pattern to properly deal with
    application configurations, it is time to understand how to manage these configurations
    securely in a cloud environment, in addition to learning how to dynamically manipulate
    behaviors in our applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Working with dynamic configurations and behaviors
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of web applications, maintaining flexibility
    and responsiveness is crucial. As developers, we must ensure that our applications
    can adapt to changes quickly and securely. Dynamic configurations and behavior
    management are key strategies that allow us to achieve this flexibility. By managing
    configurations dynamically, we can update them without redeploying our applications.
    Additionally, by implementing application behavior management using techniques
    such as **feature toggles** , we can control resource availability in real time,
    giving us the ability to effortlessly test, deploy, or roll back features.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles or feature flags are a software development technique used to
    enable or disable specific functionality in a software application at runtime,
    facilitating **continuous integration and delivery** ( **CI/CD** ) by allowing
    code changes to be merged into the main code base without immediately exposing
    new functionality to all users. This technique helps in mitigating risks, conducting
    A/B testing, performing canary releases, and rolling back features without redeploying
    the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the following article to learn more about the technique: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into the details of dynamic configuration management and implement
    a practical example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Working with dynamic settings
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic settings refer to the ability to modify application configurations at
    runtime without the need for redeployment. This capability is essential for maintaining
    application uptime, ensuring quick responses to changes in requirements, and enhancing
    security by allowing rapid adjustments to sensitive configurations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern applications must have dynamic configuration management mechanisms to
    guarantee the quality of the solution, in addition to benefits such as the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero downtime** : Update configurations without redeploying the application,
    ensuring continuous availability. This is an important feature that allows us
    to bring reliability and a better experience to users.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : Quickly update security settings and credentials in response
    to threats.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility** : Adjust settings in real time to accommodate changing business
    requirements.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified deployments** : Reduce the complexity and risk associated with
    application deployments by decoupling configuration changes from code changes.
    In scenarios with many environments, such as development, testing, and production,
    the application will have different configurations based on the resources of each
    environment. Having the ability to abstract the management of application configurations
    improves quality, segregates responsibilities, and maintains continuous delivery
    flow.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several options are available to dynamically manage configurations in ASP.NET
    Core 9, including configuration files, environment variables, and cloud-based
    services such as **Azure App Configuration** . Azure App Configuration stands
    out for its robust features and seamless integration with other Azure services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration is a service that provides a centralized way to manage
    configuration settings and feature flags. It allows applications to dynamically
    adjust their behavior without redeployment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration is a powerful feature available in Microsoft Azure that
    allows us to manage configurations and feature toggles securely, supporting the
    deployment of cloud-native applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about Azure App Configuration, I suggest reading the rich
    documentation about the resource: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)
    .'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover all the details of setting up and using Azure App Configuration
    in this book. For now, we will use the main resources to exemplify the use of
    dynamic configurations in our applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an application that interacts with Azure App Configuration and
    uses some patterns already learned in this chapter, such as the Options pattern.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure App Configuration
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure App Configuration is a cloud-based service that provides a centralized
    repository for application configurations, enabling dynamic configuration management.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an Azure App Configuration resource before creating an application.
    You will need access to an Azure subscription, as described in the *Technical*
    *requirements* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'With access to the Azure subscription, follow these steps to create an Azure
    App Configuration resource:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), and in the search field, in the top bar, type **App Configuration** and click
    on the icon, as highlighted in *Figure 9* *.3* :'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Accessing the App Configuration service](img/B21788_09_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Accessing the App Configuration service
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, click on the **+ Create** option to add the new resource,
    as shown in *Figure 9* *.4* :'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Creating a new App Configuration resource](img/B21788_09_04.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Creating a new App Configuration resource
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, we must configure the parameters of the new resource. We
    will keep the default settings. Use the following parameter suggestions as a reference:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource group** : **rg-aspnetcore8** . Be sure to click the **Create new**
    button below the **Resource group** field to create the new resource group.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location** : **East** **US 2**'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource name** : **<Your** **Last Name>-configuration**'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing** **tier** : **Standard**'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the **Create replicas** option unchecked.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Review + Create** button then the **Create** button, and wait
    for the resource to be created.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you finish creating the new resource, click the **Go to resource** button,
    as shown in *Figure 9* *.5* , or access the **App Configuration** list, as described
    in *step 1* , and click on the created resource:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – New App Configuration creation status](img/B21788_09_05.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – New App Configuration creation status
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the configuration management resource created, it’s time to
    create and configure our application to interact with Azure App Configuration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting an application in Azure App Configuration
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this example, an ASP.NET Core 9 MVC application will be created and connected
    to the Azure App Configuration service created previously.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal, and in a folder of your choice, create a directory named
    **DynamicConfiguration** :'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, access the directory with the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the following command to create the application:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous command creates an MVC application with the name **DynamicConfiguration**
    , defined with the **-n** parameter and in the current directory, determined by
    the **–o .** parameter.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the application created, we will simply prepare it to integrate with Azure
    App Configuration. To do this, run the following command in the application directory
    to open Visual Studio Code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in the root of the project, create an **Options** folder and then create
    a file called **GlobalOptions.cs** . This file must contain the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The **GlobalOptions** class has only one property called **Title** that will
    be obtained through Azure App Configuration.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When the application starts, it loads the settings as we learned previously,
    using files such as **appsettings.json** and environment variables, among other
    providers that can be configured. However, for our classes, the details of obtaining
    the configurations are abstracted by ASP.NET Core 9, and, in this case, whatever
    the provider, when using the Options pattern, we will have the correct separation
    of responsibility, maintainability, flexibility, and extensibility.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the code of the **HomeController** class, in the **Controllers**
    folder, and add the settings previously created using the Options pattern. The
    **HomeController** class code will look like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Simple changes were made to the class. Let’s understand each of them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**GlobalOptions field** : A new field was created for the class that is of
    type **GlobalOptions** , created previously'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change in the constructor** : Configurations will be injected through the
    ASP.NET Core 9 DIC, and that is why we added a parameter of type **IOptionsSnapshot<GlobalSettings>**
    . The purpose of using the **IOptionsSnapshot<>** interface is to allow you to
    obtain configurations dynamically, as we learned in the *What is the Options pattern?*
    section. If another interface is used, such as **IOptions<>** , the parameters
    will be loaded, but not dynamically.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changing the Index action** : We change the **Index** action where we set
    the value of the **Title** property in the **ViewData** dictionary with the value
    of the configuration of the **Title** property of the **_globalOptions** object.
    The **ViewData["Title"]** dictionary is used in the **Views/Home/Index.cshtml**
    file to display the page title.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s change the code on the **Views/Home/Index.cshtml** page to display
    the title in the body of the page:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As can be seen in the highlighted code, we are only rendering the value contained
    in the **ViewData["Title"]** dictionary.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The application is prepared to render data obtained through configuration. Now,
    it’s time to connect the application to Azure App Configuration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the terminal in the application directory and run the following
    command to add the NuGet package that contains the necessary SDK:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you will need to get the connection string containing the resource from
    Azure App Configuration. Let’s execute the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Access the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search field, in the top bar of the portal, type **App Configuration**
    and click on the option.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the list of configuration resources, click on the previously created
    resource with the name **<Your** **Last Name>-configuration** .
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the side menu, look for the **Access settings** option and copy the connection
    string as shown in *Figure 9* *.6* :'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Getting the connection string from App Configuration](img/B21788_09_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Getting the connection string from App Configuration
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command in the terminal, in the application directory.
    The command uses a secret manager to store a secret named **ConnectionStrings:AppConfig**
    , which stores the connection string for your App Configuration store. Replace
    the **<your_connection_string>** placeholder with your App Configuration store’s
    connection string. This is a good practice to prevent sensitive data, such as
    connection strings that are credentials or have passwords, from being persisted
    in version control, bringing vulnerabilities to your application:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the definition of the secret that contains the App Configuration connection
    string, we will change the **Program.cs** file to add the necessary services and
    middleware. Let’s look at the changed **Program.cs** code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The App Configuration SDK has excellent abstraction and is simple to integrate
    into the application. Let’s understand the changes made to the preceding code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**builder.Services.AddAzureAppConfiguration()** : This method registers the
    necessary services for Azure App Configuration to work within your ASP.NET Core
    9 application.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Configuration.GetConnectionString("AppConfig")** : This line of code
    gets the Azure Application Configuration connection string, previously obtained
    from the Azure portal and added to the application via a secret. Note that getting
    the connection string is identical to getting it from **the appsettings.json**
    file. The big difference in managing configurations through secrets is that they
    are only kept on the local machine.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Configuration.AddAzureAppConfiguration** : This extension method
    adds Azure App Configuration as a configuration provider to your application.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.Connect(connectionString)** : Connects to the Azure application configuration
    instance using the previously obtained connection string.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.Select("Dynamic Configuration:*", LabelFilter.Null)** : Specifies that all
    keys with the **DynamicConfiguration:** prefix should be selected. The **LabelFilter.Null**
    parameter indicates that only unlabeled configurations are retrieved.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.ConfigureRefresh** : The **ConfigureRefresh** method registers keys that
    you want to monitor for changes in your application configuration store.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**refreshOptions.Register("Dynamic Configuration", updateAll: true)** : Registers
    a sentinel key ( **DynamicConfiguration:Sentinel** ) that triggers an update.
    When the value of this key changes, all settings will be updated ( **refreshAll:
    true** ).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Services.Configure<GlobalOptions>(builder.Configuration.GetSection("DynamicConfiguration:
    GlobalOptions"))** : This line of code binds the configuration created in Azure
    App Configuration and the **GlobalOptions** class created previously. With this,
    it will be possible to obtain the configuration through the DIC using the Options
    pattern.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UseAzureAppConfiguration** : Allows your application to use the application
    configuration middleware to update configuration automatically.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the previous configurations, added to the **Program.cs** file, allow
    the application to connect to Azure App Configuration via the connection string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The App Configuration SDK works with the concept of pooling. In this case, when
    obtaining the configurations, a cache is made in the application’s memory, to
    avoid constant requests to the Azure service and optimize the application’s functioning.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: By default, the time the application queries Azure App Configuration for updates
    is 30 seconds. It is possible to specify the refresh call time using the **refreshOptions.SetCacheExpiration**
    method. A **Sentinel** parameter was also configured, responsible for determining
    whether there were changes to the settings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: It is important as it prevents the SDK from analyzing each configuration individually,
    and if **Sentinel** has been changed, all configurations will be updated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned how Azure App Configuration settings work, let’s create
    configuration keys in the Azure portal:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), in the App Configuration resource created previously, select the **Configuration
    explorer** option, as shown in *Figure 9* *.7* :'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration](img/B21788_09_07.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on the **Create** | **Key-value** option, as shown in *Figure 9*
    *.8* :'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Adding a new configuration on Azure App Configuration](img/B21788_09_08.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Adding a new configuration on Azure App Configuration
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'A form will be displayed where we will enter the following parameters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**Key** : **DynamicConfiguration:Sentinel**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** : **1**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the rest of the parameters at their defaults.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply** .
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *step 2* and add another key with the following configuration:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Key** : **DynamicConfiguration:GlobalOptions:Title**'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** : **ASP.NET** **Core 9**'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the **DynamicConfiguration:GlobalOptions:Title** key. This key represents
    a hierarchy following the pattern **<Group Settings>:<Section>** . In this case,
    it is the name of the previously created settings class, configuration, or desired
    property of the configuration class format.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Labels in Azure App Configuration
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The **Label** parameter in Azure Application Configuration is used to differentiate
    configuration settings based on different contexts or environments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Labels allow you to separate configurations for different environments (for
    example, development, staging, production).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings benefits, such as the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**• Flexibility** : Easily switch between different sets of configurations'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**• Isolation** : Keep settings for different environments or scenarios isolated
    and organized'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**• Testing** : Safely test new configurations without affecting other environments'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Settings that do not have a **Label** parameter will be treated as default settings.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about labels, visit the following URL: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core](https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core)
    .'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application is integrated with Azure App Configuration, open the
    terminal and access the application directory. Then, run the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, access the application URL available on your terminal via the following
    URL: **http://localhost:<port>** . In the example shown in *Figure 9* *.9* , the
    URL is **http://localhost:5295** . We can also see in *Figure 9* *.9* a welcome
    message with the value defined in the App Configuration resource:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Application getting settings from Azure App Configuration](img/B21788_09_09.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Application getting settings from Azure App Configuration
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the configurations are being loaded directly from the Azure resource.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: With the application still running, access the Azure portal ( [http://portal.azure.com](http://portal.azure.com)
    ) and the Azure App Configuration resource.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Then, access the **Configuration explorer** option. We will change the settings.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, in the settings display grid, click on the three dots ( **...**
    ) as shown in *Figure 9* *.10* and click **Edit** :'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Editing configurations](img/B21788_09_10.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Editing configurations
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the following settings:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**DynamicConfiguration:GlobalOptions:Title** : **ASP.NET Core 9 With** **Dynamic
    config**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DynamicConfiguration:Sentinel** : **2**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wait a few seconds, access the application again, and refresh the page. The
    page body message was changed, as shown in *Figure 9* *.11* :'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Application obtaining configurations dynamically](img/B21788_09_11.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Application obtaining configurations dynamically
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a simple implementation example, using a config server is a good
    practice in cloud-native applications, as suggested in The Twelve-Factor App methodology
    ( [https://12factor.net](https://12factor.net) ), and ASP.NET Core 9 provides
    several extensibility mechanisms, such as the one we use when integrating with
    Azure’s App Configuration feature.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: This approach in large application scenarios in production environments can
    bring several benefits by offering an immediate response to certain changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve-Factor App methodology
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The Twelve-Factor App methodology is a methodology used as a reference in creating
    **SaaS** ( **Software as a Service** ) application and has 12 factors, technology
    agnostic, that offer best practices for developing cloud-native solutions. One
    of the factors is related to configuration management, related to what we learned
    in this chapter, and you can learn more about this factor through the following
    URL: [https://12factor.net/config](https://12factor.net/config) .'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Managing configurations on a server such as Azure App Configuration brings several
    benefits, the most important being security. With the easy integration with ASP.NET
    Core 9 applications, we can allow our applications to change settings dynamically
    and even segregate them by environment. This approach is very important in a CI/CD
    process. We will talk more about CI/CD in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162)
    .
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Another approach that can be used to bring greater capacity to our applications
    in addition to improving user experience, among other benefits, is real-time behavior
    management, which we will learn about in the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Connecting an ASP.NET Core 9 application to Azure App Configuration
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Surely at some point, you have already used a mechanism that dynamically changes
    the behavior of an application. Imagine a scenario where you install, for example,
    a messaging app that allows users to send videos, photos, and audio.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: These media are automatically downloaded when you receive messages, which requires
    data consumption on your smartphone. In general, the first action we would take
    would be to disable the automatic media download option. This setting is found
    in a settings menu; however, this setting completely changes, in real time, the
    way the application will behave.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned example is a simple concept of changing the behavior of
    applications in real time. Likewise, at some point, web applications may have
    their behavior dynamically managed, and their use brings several benefits, such
    as the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlled releases** : Gradually release features to a subset of users to
    monitor performance and user feedback'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A/B testing** : Conduct experiments by rotating features for different groups
    of users to determine the best approach'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instant rollbacks** : Quickly disable a feature if it causes problems, without
    redeploying the application'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technique that allows changing the behavior of applications in real time
    is called feature toggles or feature flags .
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles, also known as feature flags, are a software development technique
    that allows you to enable or disable features in an application at runtime without
    deploying new code, bringing flexibility for better risk management and improving
    the deployment process, enabling teams to release resources to specific users
    or environments, and improving overall development and operational efficiency.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of coding, a feature toggle can be represented as shown in *Figure
    9* *.12* :'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Representation of the feature toggle concept](img/B21788_09_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Representation of the feature toggle concept
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 9* *.12* , the feature toggle is basically a decision
    point in the application’s source code. This decision point checks whether a certain
    value, called a toggle, is activated. To check if a toggle is activated, we can
    obtain this value through a configuration file, environment variables, and even
    on a remote server, which is the most recommended way.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Implementing feature toggles in ASP.NET Core 9 should follow best practices
    to make your code cleaner, easier to maintain, and more scalable. When using feature
    toggles, it is bad practice to lump multiple behaviors into a single class, such
    as handling different features or switching between old and new logic within a
    service. This approach can lead to code that is difficult to understand and modify.
    A good practice is to follow the **Single Responsibility Principle** ( **SRP**
    ), which means that each class should handle only one responsibility or feature.
    By keeping each class focused on one task, you reduce complexity and make your
    application easier to maintain and extend.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, using factory methods with DI in ASP.NET Core 9 allows you to
    easily swap out different implementations based on feature toggles without breaking
    the SRP. If you need to add a new feature, you can simply create a new class for
    that feature, isolating the existing logic. To learn more about the SRP, access
    the following URL: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility)
    .'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: All the details surrounding the use of the feature toggle technique and its
    respective benefits not only for development teams but also for management and
    complexity aspects go beyond the scope of this book.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We already have a basic knowledge of using this technique, and now, it’s time
    to use it in an ASP.NET Core 9 application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Managing feature toggles with Azure App Configuration
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous topic, we used the Azure App Configuration feature for configuration
    management; however, this service also includes feature flags, which you can use
    to enable or disable a feature. Through the UI in the Azure portal, we can create
    and manage the feature flags of our applications.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make some changes to the **DynamicConfiguration** project code, created
    previously, and add feature toggles:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and go to the application directory. Then, run the following
    commands:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These packages are necessary to incorporate the SDK for managing toggles in
    the application.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the application in Visual Studio Code, then we will edit the **Program.cs**
    file, which will have the following updated code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Basically, we make three changes to the **Program.cs** file:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**using Microsoft.FeatureManagement** : Adding the namespaces necessary to
    add the SDK’s toggle management features.'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Services.AddFeatureManagement()** : Adding services to the application’s
    DIC.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.UseFeatureFlags** : We changed the connection settings with Azure App Configuration,
    informing us that the toggle management feature will be used. Additionally, a
    5-second cache was defined using the **featureFlagsOptions.CacheExpirationInterval**
    standard.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the Azure App Configuration SDK, we can work with toggles directly
    in the code of controllers or services, using the **IFeatureManager** interface,
    the **FeatureGate** attribute, or a **tag helper** directly in views. For this
    example, we will use a tag helper.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Using IFeatureManagement and the FeatureGate attribute
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we can analyze whether a toggle is activated or not through
    the **IFeatureManagement** interface, which is injected into a class and provides
    us with methods to test the values, such as the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**public class MyController :** **Controller**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**private readonly** **IFeatureManager _featureManager;**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**public** **MyController(IFeatureManager featureManager)**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**_featureManager =** **featureManager;**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**private async** **Task MyMethod()**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**if (await** **_featureManager**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**.** **IsEnableAsync("FeatureToggleName"))**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Console.WriteLine("New Approach");**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**Console.WriteLine("Legacy Approach");**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, it is possible to annotate an action or controller with the
    **FeatureGate** attribute:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '**using Microsoft.FeatureManagement.Mvc;**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**[** **FeatureGate("FeatureToggleName)]**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**public class MyController :** **Controller**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**// ....**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: This way, it is possible to benefit from the use of toggle management with different
    implementations but the same concept.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the application to use a tag helper, which will use the feature
    toggle. Follow the next steps:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, edit the **Views/_ViewImports.cshtml** file and add
    the following code to the file, below the existing code:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code adds a tag helper from the Azure App Configuration SDK.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, open the **Views/Home/Index.cstml** file and use the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the use of the feature tag, which will basically obtain information on
    whether a toggle is enabled. If yes, the new **div** tag will be displayed on
    the screen.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that everything is configured in the application, let’s add the feature
    toggle in Azure App Configuration.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ) and access the App Configuration resource created in the previous section.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Feature manager** menu, **Create** | **Feature flag**
    , as shown in *Figure 9* *.13* :'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Adding a new feature flag](img/B21788_09_13.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Adding a new feature flag
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, set the **New feature flag** field to the **NewFeature**
    value and leave the rest at their default values.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Apply** button.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A new feature flag will be created and disabled, as shown in *Figure 9* *.14*
    :'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Application using a disabled feature flag](img/B21788_09_14.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Application using a disabled feature flag
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We did this configuration on purpose. Now, run the application again using the
    **dotnet run** command, executed through the terminal in the application directory
    and you’ll see there is no changes on the application. The reason the new **Div**
    tag was not displayed is that we created the toggle as **Enabled= false** .
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the application running, access the Azure portal again, and enable the
    toggle by clicking on the **Enabled** column in the grid, as shown in *Figure
    9* *.15* :'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Enabling the feature flag](img/B21788_09_15.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Enabling the feature flag
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the application again, and we can see in *Figure 9* *.16* that a new
    HTML element has been added to the page:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Application behavior changed at runtime](img/B21788_09_16.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Application behavior changed at runtime
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and implementing dynamic configurations and feature toggles,
    we can create robust, flexible, and responsive ASP.NET Core 9 applications.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have used Azure App Configuration as a feature flag manager.
    However, ASP.NET Core 9 has integrations with several other types of toggle management
    servers using the same techniques learned in this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The combination of configuration management techniques and feature flags is
    very powerful for different application contexts, mainly interacting with cloud
    resources in a scenario of continuous delivery of value through automated mechanisms.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to host our applications in cloud environments using automated
    processes in the next chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into good practices for managing application configurations
    by understanding the concepts and abstractions of the IConfiguration interface.
    We also worked with concepts related to the ASP.NET Core 9 configuration provider,
    along with the implementation of the Options pattern. Finally, we worked with
    changing application configurations and behavior in real time using Microsoft
    Azure’s Azure App Configurator to implement the concept of feature flags or feature
    toggles. Working with cloud resources is an important premise for Software Engineers
    and in the next chapter, we will explore how to deploy applications in a Cloud
    environment.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Hosting, Deploying, and Preparing to the Cloud'
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications are dynamic, and as software engineers, our work doesn’t
    end after synchronizing the latest code developed. In a scenario where the market
    is constantly changing, it is necessary for applications to be dynamic enough
    to meet constant market demands. Therefore, development teams must adapt to the
    new topics surrounding the modern development model. ASP.NET Core 9 is prepared
    to provide high-quality solutions, suitable for cloud environments. In this part,
    we will learn about aspects involving the continuous delivery of solutions through
    the understanding and implementation of application publishing flows in a cloud
    environment with the support of automated pipelines such as **Continuous Integration**
    ( **CI** ) and **Continuous Delivery** ( **CD** ), processes associated with the
    DevOps culture. We will understand what a cloud-native mindset is and how to direct
    our solutions to a constantly changing market.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用是动态的，作为软件工程师，我们的工作并不仅仅在同步最新开发的代码后结束。在市场不断变化的场景中，应用需要足够动态，以满足不断的市场需求。因此，开发团队必须适应围绕现代开发模型的新主题。ASP.NET
    Core 9 准备提供适合云环境的高质量解决方案。在本部分，我们将通过理解和实施在云环境中支持自动化管道（如**持续集成**（**CI**）和**持续交付**（**CD**））的应用发布流程，了解涉及解决方案持续交付的各个方面。我们将了解云原生思维是什么，以及如何将我们的解决方案引导至不断变化的市场。
- en: 'This part has the following chapters:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) *, Deploying and Hosting Applications*'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21788_10.xhtml#_idTextAnchor162) ，*部署和托管应用*'
- en: '[*Chapter 11*](B21788_11.xhtml#_idTextAnchor183) *, Cloud-Native Development
    with* *ASP.NET Core 9*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21788_11.xhtml#_idTextAnchor183) ，*使用* *ASP.NET Core 9* *进行云原生开发*'
