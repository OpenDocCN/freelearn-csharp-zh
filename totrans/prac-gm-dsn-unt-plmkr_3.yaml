- en: Chapter 3. Components and State Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about Unity''s interface, and the way things
    are organized and displayed in the Editor. You added a FSM to a game object and
    briefly looked at the interface elements related to Playmaker. You also manipulated
    game objects and components using such interface elements as the **Hierarchy**
    and **Inspector** panels, as well as the **Scene** view. In this chapter we will
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The Component-based approach to game development that Unity relies on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game objects, components, and their properties in more detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interchangeable nature of game objects when using components to define appearance
    and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite state machines, actions, and transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making simple game mechanics using Playmaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game objects, components, and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity works using a popular and common approach for game development, which
    is called the component-based architecture. This approach is widely used in software
    development to make things more reusable and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Let us talk about the way things are organized in Unity. Some of them have already
    been mentioned in previous chapters, but I will repeat them briefly so that you
    can see the game objects, components, and their properties in the larger context.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you have a project, which is essentially a folder that contains
    all of the files and information about your game. Some of the files are called
    scenes (think of them as levels). A scene contains a number of game objects that
    you have added to it. The contents of your scenes are determined by you, and you
    can have as many of them as you want. You can also make your game switch between
    different scenes, thus making different sets of game objects active.
  prefs: []
  type: TYPE_NORMAL
- en: On a smaller scale, you have game objects and components. A game object by itself
    is simply an invisible container that does not do anything. Without adding appropriate
    components to it, it cannot, for instance, appear in the scene, receive input
    from the player, or move and interact with other objects. Using components, you
    can easily assemble powerful game objects while reusing several small parts, each
    responsible for a simple task or behavior—rendering the game object, handling
    the input, taking damage, playing an audio effect, and so on—making your game
    much simpler to develop and manage. Unity relies heavily on this approach, so
    the better you grasp it, the faster you will get good at it.
  prefs: []
  type: TYPE_NORMAL
- en: The only component that each and every game object in Unity has attached to
    it by default is **Transform**. It lets you define the game object's position,
    rotation, and scale. Normally, you can attach, detach, and destroy components
    in any given game object at will, but you cannot remove **Transform**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each component has a number of properties that you can access and change: these
    can be integer or floating point numbers, strings of text, textures, scripts,
    references to game objects or other components. They are used to change the way
    a certain component behaves, to influence its appearance or interaction. Some
    of the properties that you have already encountered in [Chapter 2](ch02.html "Chapter 2. Unity''s
    and Playmaker''s User Interface"), *Unity''s and Playmaker''s* *User Interface*,
    include the position, rotation, and scale properties of the **Transform** component.
    There are others that you have seen, including FSM, that we will talk about later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the **Wall** game object with the **Transform**,
    **Mesh Filter**, **Box Collider**, **Mesh Renderer**, and **Script** components
    attached to it. the properties of **Transform** are displayed. In order to reveal
    or hide a component's properties you need to left-click on its name or on the
    small arrow on the left of its icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Game objects, components, and properties](img/8108OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unity has a number of predefined game objects that already have components attached
    to them, such as cameras, lights, and primitives. You can access them by choosing
    **GameObject** | **Create** from the main menu. Alternatively, you can create
    empty game objects by pressing *command* + *Shift* + *N* (*Ctrl* + *Shift* + *N*
    in Windows) and attach components to them using the **Components** submenu.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the project structure that we have discussed. Note
    that there can be any number of scenes within a single project, any number of
    game objects within a single scene, any number of components attached to a single
    game object, and finally, any number of properties within a single component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Game objects, components, and properties](img/8108OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One final thing that you need to know about components right now is that you
    can copy them by right-clicking on the name of the component in the **Inspector**
    panel and selecting **Copy Component** from the contextual menu shown in the following
    screenshot. You can also reset the properties of the components to their default
    values, remove components, and move them up or down for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Game objects, components, and properties](img/8108OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The copied component can be pasted by right-clicking any component's name in
    the **Inspector** panel and selecting either **Paste Component As New** or **Paste
    Component Values** from the same contextual menu. The difference between these
    two commands is that the former will add a new component identical to the one
    that you have copied, while the latter will simply transfer the values of all
    the properties. These commands become active once you have copied a component.
  prefs: []
  type: TYPE_NORMAL
- en: Working with prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create multiple instances of a game object with the same components
    and properties, or access the same game object from different scenes, you can
    save it as a file in your `Assets` folder. These files are called prefabs in Unity
    and act like game object templates. To create an empty prefab, right-click on
    the empty space in the **Project** panel, then select **Create** | **Prefab**
    from the contextual menu. A new file called `New Prefab` should appear in the
    **Project** panel. Call this prefab `Wall`. Now create an empty folder called
    `Prefabs` and put the `Wall` prefab in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Right now the prefab is empty.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, select the **Wall** game object that you created
    in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's User Interface"),
    *Unity's and Playmaker's* *User Interface*. Click and drag it into the `Wall`
    prefab in the **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the **Wall** game object will become blue in **Hierarchy**, and
    when you select the `Wall` prefab, you will see all of the components that the
    original **Wall** game object had in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you drag-and-drop the `Wall` prefab into the scene, a new object called
    **Wall** will be created with exactly the same properties as those defined in
    the prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if you change some of the components and/or properties in the prefab
    using the **Inspector** panel, these changes will be automatically applied to
    all the instances of the prefab in the scene. This can save you a lot of time
    if you have multiple objects of the same type (that is, walls, monsters, trees,
    and so on) as you do not have to select them one-by-one in the **Hierarchy** and
    make the same changes multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: You can also modify your prefab (and, by extension, all of its instances in
    the scene) by selecting one of the instances in **Hierarchy**, making your changes,
    and clicking the **Apply** button near the top of the **Inspector** panel. You
    can also undo all of the changes by clicking on the **Revert** button. This will
    reset the currently selected instance to the way its prefab was set up.
  prefs: []
  type: TYPE_NORMAL
- en: This works because, in fact, all the components and properties of an instance
    are linked to the ones of the prefab. Only when you change them in the instance
    they become unlinked, which means that further updates of that property on the
    prefab won't be applied to this instance. These unlinked properties can be distinguished
    because their name becomes bold in the **Inspector** panel. If you want to re-link
    a specific unlinked property you can right-click on it and select **Revert value
    to Prefab**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the **Apply** and **Revert** buttons, all prefab instances also have
    a **Select** button. This button lets you select and highlight the prefab corresponding
    to the currently selected instance in the **Project** panel, so you can access
    it more easily. Moreover, as we saw earlier, a prefab instance can be easily identified
    by its blue tinted name in the **Hierarchy** panel. The alternative way of creating
    a prefab is even simpler: you can simply drag-and-drop a game object from the
    **Hierarchy** panel into the **Project** panel. An appropriately named file will
    be created in the `Assets` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very important thing to know about prefabs is that they can be copied
    and shared on the Web, since they are little more than the files recognized by
    Unity that contain information about components and properties. Now, follow these
    steps to modify the `Wall` prefab to suit our needs better:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the **Project** panel and call it `Materials`. It will
    contain material files that contain information about textures, shaders, and colors
    of your game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material file by clicking on the **Create** button in the top-left
    corner of the **Project** panel and selecting **Material** from the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new material `WallMaterial` and put it inside the `Materials` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **WallMaterial** in the **Project** panel, then in **Inspector**, click
    on the rectangle next to the text that says **Main Color**. In the **Color** window
    that appears, select the black color and close the **Color** window. The following
    screenshot shows the **Material** modification interface as well as the **Color**
    window:![Working with prefabs](img/8108OT_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have this new material set up, select the `Wall` prefab, then drag-and-drop
    **WallMaterial** into the **Element 0** element of the **Materials** property
    of the prefab's **Mesh Renderer** component. It should replace **Default Diffuse**.
    The following screenshot shows what the **Mesh Renderer** component should look
    like once your are done assigning the new material.![Working with prefabs](img/8108OT_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now all of the instances of the `Wall` prefab will be black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, set the X scale property of the **Transform** component to `15`. This
    will make all the new walls longer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Main Camera** game object and set its **Projection** property of
    the **Camera** component to **Orthographic** using the **Inspector** panel. This
    will make the view of the camera flat; the game view will now appear two-dimensional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Size** property to `5`. You can adjust the look later, but for now
    this will help us focus on gameplay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is often a good idea to restrict yourself to simple primitives, color-coded
    untextured materials, and orthographic projection cameras in the beginning of
    the design process, because it will let you focus on gameplay. This way, if your
    game is fun, you will know about it, and if it is not, you will not get distracted
    by fancy visuals.
  prefs: []
  type: TYPE_NORMAL
- en: Make four walls and arrange them in the scene so that what you see in the **Game**
    view looks like the following screenshot. If this is not the case, you can go
    back to the table in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's
    User Interface"), *Unity's and Playmaker's* *User Interface*, and see if your
    **Main Camera** game object is positioned and rotated correctly. Its position
    should be set to (`0`, `10`, `0`) and rotation to (`90`, `0`, `0`). Don't forget
    that you can rotate the objects to precise values such as `90` and `180` degrees
    by changing their rotation angle in the **Transform** component. Also make sure
    that the Y position of all the walls remains equal to `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with prefabs](img/8108OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finite state machines, states, and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked about game objects and components. Now it is time to have a look
    at Playmaker FSMs, states, and actions in them.
  prefs: []
  type: TYPE_NORMAL
- en: An FSM in Playmaker is a graph that consists of states and transitions between
    them, attached to a game object. It allows for a way of visual programming using
    different states of the graph and events that trigger transitions to other states.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the `Wall` prefab and open the **playMaker** panel, you will
    see that its FSM has two states: the default **Start** state where everything
    begins and another one called **State 1** by default, with an arrow connecting
    the former to the latter. The arrow is a transition. You cannot remove the Start
    state or the one it is connected to, because if you could you would not need the
    FSM attached to the object. However, you can create new states and define transitions
    to them.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can navigate the FSM view almost exactly the same way you would do the **Scene**
    view. Use the middle mouse button to drag the view. Use the left mouse button
    to move the states around. This does not change anything in the logic of the state
    machine, but lets you organize everything the way that makes sense to you, as
    well as look at the parts of the graph that you are most interested in at the
    moment if the whole state machine is too big to be shown at once.
  prefs: []
  type: TYPE_NORMAL
- en: A state in FSM is empty by default and does not do anything, a lot like an empty
    game object without any components attached to it. In order to make a state do
    something, you need to attach actions to it.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's
    User Interface"), *Unity's and Playmaker's* *User Interface*, you can add an FSM
    to an object by selecting the latter, right-clicking in the FSM view of the **playMaker**
    panel, and then selecting **Add FSM** from the contextual menu. You can remove
    an object from the Playmaker control by right-clicking the header of the Playmaker
    FSM (**Script**) component in **Inspector** and selecting **Remove Component**
    from the contextual menu. This will remove the FSM and erase all of the changes
    you made to it, including added states and transitions. An object has an FSM attached
    to it if there is a red Playmaker hieroglyph icon (![Finite state machines, states,
    and actions](img/8108OT_03_07.jpg)) next to its name in the **Hierarchy** panel.
  prefs: []
  type: TYPE_NORMAL
- en: As an example for this book, we will be making a version of the classic air
    hockey game. In order to begin, we will need to add a puck and a mallet. In this
    chapter, you will make the mallet move based on the mouse position and push the
    puck as you would expect it to do in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Right now in your scene there are four walls, a background quad, a camera, and
    a directional light (created in [Chapter 2](ch02.html "Chapter 2. Unity's and
    Playmaker's User Interface"), *Unity's and Playmaker's User Interface*). Now it
    is time to make things interactive. Let us start with a mallet.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new cylinder primitive by selecting **GameObject** | **Create Other**
    | **Cylinder** in the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this game object to `Mallet` and make a dark green (RGB color set to
    `10`, `155`, `10` in the **Color** window) material called **MalletMaterial**
    for it, then assign the material to it, as you did for the `Wall` prefab before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the scale of **Mallet** to (`1.35`, `1.35`, `1.35`) and its position to
    (`-6.5`, `1.45`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we are going to make the mallet move. First of all, we need to add a component
    called **Character Controller** to it. This component is in charge of character
    physics. Select **Mallet**, then click on the **Add Component** button near the
    bottom of the **Inspector** panel. Type `Character Controller` in the search bar,
    and then double-click on the **Character Controller** item in the list (as shown
    in the following screenshot). When Unity asks you if you want to replace the existing
    **CapsuleCollider** component, click on **Replace**.![Finite state machines, states,
    and actions](img/8108OT_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Character Controller** component, set the **Skin Width** property to
    `0` (it will be set to the minimum possible value, which is `0.0001`). We are
    doing this to make sure that our mallet's collisions look precise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an FSM to Mallet by selecting it, right-clicking in the FSM view of the
    **playMaker** panel, and selecting **Add FSM** from the contextual menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **State 1**, then in the **State** tab on the right of the **playMaker**
    panel enter `Move` in the first text field from the top. It is responsible for
    the name of the currently selected state. When you enter the new name, you should
    see the state change in the FSM view as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping the **Move** state selected, open the **Actions** panel (it should be
    attached to the same area of the **Editor** window as the **Inspector** panel;
    alternatively, click on the **Action Browser** button on the bottom-right of the
    **State** tab) and find the **Mouse Pick** action under the **Input** category.
    Click on it, then click on the **Add Action To State** button in the bottom-right
    corner of the panel. You should notice that the **Mouse Pick** action appeared
    in the **State** tab of the **playMaker** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This action gets the cursor position in 3D space when you hover an object. Under
    the hood it draws an invisible ray (this action is called **raycast**) from the
    mouse position on the camera's near clipping plane (you can see it as one of the
    white gizmo rectangles in the **Scene** view when you select **Main Camera**).
    If there is something in the way of the ray, a ray hit gets detected, and Unity
    finds out where exactly it happened. In our case, we will use the background quad
    to get the position of the mouse cursor, and then make the mallet follow it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to pick a correct ray-hit position, we need to make sure that nothing
    else gets in the way of the ray. To do this, we will tell the ray to interact
    only with the background quad. Select the **Quad** game object and rename it `Background`
    for clarity. Then find the **Layer** drop-down menu in the top-right corner of
    the **Inspector** panel, click on the drop-down button that says **Default** by
    default, and press **Add Layer…** in it. The appearance of **Inspector** should
    now change to reveal a list of tags and layers as shown in the following screenshot:![Finite
    state machines, states, and actions](img/8108OT_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This menu is called **TagManager**. Click on the right of **User Layer 8** and
    enter `Background` in the edit field that appears, then press *Return* on your
    keyboard. Select the **Background** object again and set its layer to **Background**
    by choosing the appropriate element from the drop-down **Layer** list you used
    to access the **TagManager** before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Mallet** again. In the **Mouse Pick** action of the **Move** state,
    set the **Layer Mask** parameter to `1`. This determines how many layers you will
    set to interact with the raycast. **Element 0** should appear below. In the drop-down
    list to its right, select the **Background** layer you created before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From now on, the raycast in the **Mouse Pick** action will ignore all objects
    that are not in the **Background** layer. Now we need to store the ray-hit position
    in a variable. Go to the **Variable** tab of the **playMaker** panel and enter
    `mousePos` in the **New Variable** field on the bottom. Click on the **Add** button.
    Set the **Variable Type** to **Vector3**. A **Vector 3** variable contains three
    numbers: **X**, **Y**, and **Z**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **State** tab and set the **Store Point** property of the **Mouse
    Pick** action to **mousePos**. This will save the position of the ray hit in the
    **Vector3** type variable that you just created. Finally, check the **Every Frame**
    property checkbox on the bottom of the **Mouse Pick** action to make sure that
    the mouse position is updated continuously as opposed to just once in the beginning
    of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the action called **Controller Simple Move** located under the **Character**
    category of the **Actions** panel to your **Move** state. It should appear just
    below the **Mouse Pick** action. If it appears above it, you can move it down
    by clicking and dragging it by its header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to note that the order of actions in the state matters: the
    actions mentioned earlier will be executed before the ones that are mentioned
    later, so if you want to use a variable set in the **Mouse Pick** action, you
    must make sure that **Mouse Pick** is above whatever action is going to use it
    (in our case it is **Controller Simple Move**).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the **Move Vector** property of the **Controller Simple Move** action to
    **mousePos**. Leave the rest of the properties at their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interaction between game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the mallet moves, we are going to make it interact with a puck. When
    the mallet touches the puck, we are going to apply a force to it in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: You can click the Play button in the toolbar and see how the mallet moves based
    on the mouse position. You will notice that it collides with the walls, follows
    the mouse cursor smoothly, and changes its movement speed based on how fast and
    far you move your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Create another cylinder called **Puck** and place it in (`-3`, `0.85`, `0`).
    Set its scale to (`1`, `0.7`, `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Rigidbody** component to it (**Component | Physics | Rigidbody**). Set
    the **Mass** property to `0.1`, uncheck **Use Gravity**, open the **Constraints**
    section, and check **Freeze Position Y** and **Freeze Rotation X**, **Y** and
    **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new dark grey (`65`, `60`, `60`) material (**Assets** | **Create** |
    **Material**) called **PuckMaterial** and assign it to the puck's **Mesh Renderer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the puck is all set, we will make the mallet push it. Go to the mallet's
    **Move** state in FSM and add an action called **Collision Event** (under Physics)
    to it. Set the **Collision** property to **On Controller Collider Hit**.![Interaction
    between game objects](img/8108OT_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **TagManager** by selecting the **Puck** game object and choosing **Add
    Tag...** from the **Tag** drop-down menu in **Inspector**. Create a tag called
    **Puck** by adding a new tag the same way you did with a layer for the background.
    Tags are situated near the top of **TagManager**. You can have as many as you
    want if you modify the **Size** variable. Set the **Puck** game object's tag to
    **Puck**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Move** state in Mallet's FSM. Set the **Collide Tag** property
    of the **Collision Event** action to **Puck**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Events** tab in the **playMaker** panel, enter `Push` in the **Add
    Event** field near the bottom of the tab, and press *Return* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **State** tab again and set the **Send Event** property of the **Collision
    Event** action to **Push**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have to tell the FSM what will happen once the event is called. Create
    a new state in the Mallet's FSM by right-clicking anywhere in the FSM view and
    selecting **Add State** from the context menu. Name the new state `Push Puck`.
    Right-click on the **Move** state in the FSM view and select **Add Transition**
    | **Push** from the contextual menu. A new light label saying **Push** should
    appear below the **Move** state. Click on it and drag the line that appears to
    the **Push Puck** state. This line is the transition that will happen once the
    **Push** event is called in the **Move** state. Add a **FINISHED** event to the
    **Push Puck** state the same way. You do not need to create it, because it is
    a default Playmaker event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a transition from the **FINISHED** event to the **Move** state to make
    sure that when the puck is pushed the mallet will remain under the player's control.
    The following figure shows what your FSM is supposed to look like:![Interaction
    between game objects](img/8108OT_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following actions to the **Push Puck** state in Mallet''s FSM one-by-one:
    **Get Controller Hit Info**, **Get Position**, **Vector3 Subtract**, **Vector3
    Normalize**, **Vector3 Multiply**, and **Add Force**. Keep in mind that the order
    of the actions matters, because the ones higher on the list will get executed
    earlier. The following screenshot shows the correct order of the actions.![Interaction
    between game objects](img/8108OT_03_13.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following variables using the **Variables** tab of the **playMaker**
    panel: **hitPos** (**Vector3**), **pushDir** (**Vector3**), **pushMag** (**Float**).
    Select **pushMag** and set its **Float Value** to `20`. This value will determine
    how hard the mallet pushes the puck.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in the **State** tab, set the **Contact Point** property of **Get Controller
    Hit Info** action to **hitPos**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Puck** game object from **Hierarchy** to the **Game Object** slot
    of the **Get Position** action, then set **Vector** to **pushDir**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Vector3 Subtract** action, set **Vector3 Variable** to `pushDir`. Click
    on the small option (![Interaction between game objects](img/8108OT_03_12.jpg))
    icon next to **Subtract Vector**. This will allow you to pick a variable from
    the list instead of using a numeric value. Set **Subtract Vector** to `hitPos`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Vector3 Normalize** action, set **Vector3 Variable** to **pushDir**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Vector3 Multiply** action, set **Vector3 Variable** to **pushDir** and
    **Multiply By** to **pushMag**. Click on the small option icon to show the FSM
    variables if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in **Add Force**, set the **Game Object** property to **Specify Game
    Object** and drag the **Puck** game object into the slot that will appear below.
    Set **Vector** to **pushDir**. Click on the option icons next to **X**, **Y**,
    and **Z** and leave them at **None** to make sure they are not reset to `0` and
    are simply not assigned instead. Click the small option icon to show the **None**
    option if needed. Then set **Space** to **World**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your puck should now become interactive if you click on play and make the Mallet
    collide with it. I realize that the last bit was a lot of actions at once, so
    we will discuss what exactly happens in those actions in the next chapter. This
    is an example of some complex logic that we will look into when we talk more about
    game mechanics. For now consider it an exercise to familiarize yourself with actions
    and variables and the way they are added and assigned in the **playMaker** panel.
  prefs: []
  type: TYPE_NORMAL
- en: As another exercise, save your scene, create a few new game objects with FSMs,
    and try to experiment with different actions and variables, see how they are added
    and assigned. Don't worry if your actions do not do much. Try to familiarize yourself
    with the Playmaker interface and remember how to add, move, and remove actions,
    create new variables and events, and assign them.
  prefs: []
  type: TYPE_NORMAL
- en: Once you feel like you are comfortable with these actions, you can delete the
    objects you used for practice or simply reload the scene without saving it by
    double-clicking the `Scene1` file in the **Project** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the project structure in Unity: scenes, game
    objects, components, and properties. We also took a closer look at the Playmaker
    interface: actions, events, variables, and transitions. You took the first step
    in creating an air hockey game by implementing a real game mechanic—a mallet that
    is moved with the mouse and a puck that is pushed when the mallet touches it.
    In the next chapter, we will add even more game mechanics, explain the ones already
    implemented in more detail, and try to make the game more fun and pretty.'
  prefs: []
  type: TYPE_NORMAL
