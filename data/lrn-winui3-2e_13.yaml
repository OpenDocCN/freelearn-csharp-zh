- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Take Your App Cross-Platform with Uno Platform
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Uno Platform 将您的应用程序跨平台化
- en: '**Uno Platform** allows developers to write XAML markup and C# code in a single
    code base and deploy the application to multiple platforms. Uno currently supports
    iOS, Android, Windows, macOS, Linux, Tizen, and the web (with **WebAssembly**).
    Uno Platform uses the same XAML syntax as WinUI, allowing WinUI developers to
    easily make the jump to Uno while reusing much of their existing XAML and C# code.
    We will look at how the **My Media Collection** sample app can be adapted to run
    on some of these other platforms with Uno Platform.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Uno Platform** 允许开发者在一个代码库中编写 XAML 标记和 C# 代码，并将应用程序部署到多个平台。目前 Uno 支持 iOS、Android、Windows、macOS、Linux、Tizen
    以及网页（通过 **WebAssembly**）。Uno Platform 使用与 WinUI 相同的 XAML 语法，使得 WinUI 开发者可以轻松地跳转到
    Uno，同时重用大量现有的 XAML 和 C# 代码。我们将探讨如何将 **My Media Collection** 示例应用程序适配到使用 Uno Platform
    在这些其他平台上运行。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The history of Uno Platform and discuss its current capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Uno Platform 的历史及其当前功能讨论
- en: How to configure Visual Studio to create Uno Platform projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置 Visual Studio 以创建 Uno Platform 项目
- en: Adapting existing WinUI views and ViewModels for reuse in Uno projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的 WinUI 视图和 ViewModels 适配以在 Uno 项目中重用
- en: Running and debugging an Uno Platform application on Android using the **Windows
    Subsystem for** **Android** (**WSA**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Windows Subsystem for Android** （**WSA**）在 Android 上运行和调试 Uno Platform
    应用程序
- en: Running your application in the browser natively with WebAssembly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 在浏览器中本地运行您的应用程序
- en: By the end of this chapter, you will understand how to take a WinUI application
    built with the Windows App SDK and port it to multiple platforms outside the Windows
    ecosystem with Uno Platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何将使用 Windows App SDK 构建的 WinUI 应用程序移植到 Windows 生态系统之外的其他多个平台使用 Uno
    Platform。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，需要以下软件：
- en: Windows 11 version 22000.0 or later with WSA installed from the Microsoft Store.
    To use WSA, 16 GB of RAM is recommended.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 11 版本 22000.0 或更高版本，并已从 Microsoft Store 安装 WSA。要使用 WSA，建议至少 16 GB 的
    RAM。
- en: Visual Studio 2022 or later with the **.NET Desktop Development** workload configured
    for Windows App SDK development.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本，并已配置 **.NET Desktop Development** 工作负载以进行 Windows App
    SDK 开发。
- en: If you want to build and run an iOS or macOS version of the sample application,
    you will need a Mac running macOS 12.5 or later with Xcode 14 or later installed
    from the App Store.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要构建和运行 iOS 或 macOS 版本的示例应用程序，你需要一台运行 macOS 12.5 或更高版本的 Mac，并已从 App Store
    安装 Xcode 14 或更高版本。
- en: To target Android devices, you can install the **.NET Multi-platform App UI
    development** workload in the Visual Studio Installer. This will install a supported
    version of the **Android SDK**.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要针对 Android 设备，你可以在 Visual Studio 安装程序中安装 **.NET Multi-platform App UI development**
    工作负载。这将安装一个受支持的 Android SDK 版本。
- en: An overview of Uno Platform
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uno Platform 概述
- en: 'Uno Platform is an open source UI framework that installs as an extension to
    Visual Studio. It is cross-platform, with the ability to target Windows, iOS,
    Android, macOS, Linux, and WebAssembly. With a single C# and WinUI XAML code base,
    you can target all of these platforms. While the Uno Platform team recommends
    Visual Studio for the best experience, you can build Uno applications with Visual
    Studio Code or the **JetBrains Rider** IDE. The pros and cons of each development
    environment are discussed on Uno Platform’s **Get Started** documentation: [https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment](https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Uno Platform 是一个开源的 UI 框架，作为 Visual Studio 的扩展进行安装。它是跨平台的，能够针对 Windows、iOS、Android、macOS、Linux
    和 WebAssembly。使用单个 C# 和 WinUI XAML 代码库，你可以针对所有这些平台。虽然 Uno Platform 团队推荐使用 Visual
    Studio 以获得最佳体验，但你也可以使用 Visual Studio Code 或 **JetBrains Rider** IDE 来构建 Uno 应用程序。每个开发环境的优缺点在
    Uno Platform 的 **入门** 文档中有讨论：[https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment](https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment)。
- en: 'Uno Platform was first released in May 2018 and has been growing in popularity
    in recent years. They have also added to their supported platforms and shifted
    from UWP to WinUI 3 in their XAML support. This year, in their 4.10.13 release,
    they even added support for embedding **.NET MAUI** controls within Uno Platform
    apps, with support for an extensive number of third-party controls. We won’t be
    covering .NET MAUI embedding in this chapter, but you can explore this exciting
    feature in their documentation: [https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html](https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Uno Platform 首次发布于 2018 年 5 月，近年来其受欢迎程度一直在增长。他们还增加了支持的平台，并在 XAML 支持中从 UWP 转向
    WinUI 3。今年，在他们的 4.10.13 版本中，他们甚至增加了在 Uno Platform 应用程序中嵌入 **.NET MAUI** 控件的支持，并支持大量第三方控件。我们不会在本章中介绍
    .NET MAUI 的嵌入，但您可以在他们的文档中探索这个令人兴奋的功能：[https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html](https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html)。
- en: Speaking of .NET MAUI, you are probably wondering why a developer may choose
    Uno Platform over Microsoft’s cross-platform successor to **Xamarin.Forms**. One
    reason why WinUI developers would choose Uno Platform is *familiarity*. Uno apps
    are created with WinUI XAML, so there is no learning curve. The .NET MAUI XAML
    is slightly different than WinUI. If targeting Linux and web browsers is important
    to you, .NET MAUI applications cannot currently target either of these platforms,
    whereas Uno Platform can. If you or the designers in your company use **Figma**
    to create user interfaces, you’ll find the Uno Platform Figma plugin will give
    your team a great head-start when building your next application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 .NET MAUI，您可能想知道为什么开发者会选择 Uno Platform 而不是 Microsoft 对 **Xamarin.Forms**
    的跨平台继任者。WinUI 开发者选择 Uno Platform 的一个原因是 **熟悉度**。Uno 应用程序使用 WinUI XAML 创建，因此没有学习曲线。.NET
    MAUI XAML 与 WinUI 略有不同。如果您认为针对 Linux 和网页浏览器很重要，.NET MAUI 应用程序目前无法针对这两个平台，而 Uno
    Platform 可以。如果您或您公司的设计师使用 **Figma** 创建用户界面，您会发现 Uno Platform Figma 插件将在构建下一个应用程序时为您的团队提供一个很好的起点。
- en: Uno Platform is open source. On their GitHub repository ([https://github.com/unoplatform/uno](https://github.com/unoplatform/uno)),
    you can track open issues, submit pull requests to improve the framework, or get
    insights into their latest releases. If you want to try Uno Platform before getting
    it installed and building your first app, you can open their interactive **Uno
    Playground** in your browser at [https://playground.platform.uno/#wasm-start:](https://playground.platform.uno/#wasm-start:)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Uno Platform 是开源的。您可以在他们的 GitHub 仓库 ([https://github.com/unoplatform/uno](https://github.com/unoplatform/uno))
    中跟踪开放问题、提交拉取请求以改进框架，或了解他们最新的发布信息。如果您想在安装并构建您的第一个应用程序之前尝试 Uno Platform，您可以在浏览器中打开他们的交互式
    **Uno Playground**，网址为 [https://playground.platform.uno/#wasm-start:](https://playground.platform.uno/#wasm-start:])
- en: '![Figure 13.1 – Exploring the Uno Playground in a web browser](img/B20908_13_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 在网页浏览器中探索 Uno Playground](img/B20908_13_01.jpg)'
- en: Figure 13.1 – Exploring the Uno Playground in a web browser
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 在网页浏览器中探索 Uno Playground
- en: The Uno Playground sample app runs interactively in the browser with WebAssembly.
    You can make changes to the XAML in the left panel and watch it update the preview
    on the right in real time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Uno Playground 示例应用程序在浏览器中以 WebAssembly 的形式交互式运行。您可以在左侧面板中修改 XAML，并实时观察右侧预览的更新。
- en: 'The other browser-based resource you can explore is the **Uno Gallery** ([https://gallery.platform.uno/](https://gallery.platform.uno/)).
    In the Uno Gallery, you can explore controls, theming capabilities, and other
    UI and non-UI features of Uno Platform. For example, on the gallery’s page for
    the **Button** control, you can see how the control will be rendered in different
    styles – **Material**, **Fluent**, or **Cupertino** designs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以探索的其他基于浏览器的资源是 **Uno Gallery** ([https://gallery.platform.uno/](https://gallery.platform.uno/))。在
    Uno Gallery 中，您可以探索 Uno Platform 的控件、主题功能以及其他 UI 和非 UI 功能。例如，在 **按钮** 控件的画廊页面中，您可以看到该控件将以不同的样式呈现
    – **Material**、**Fluent** 或 **Cupertino** 设计：
- en: '![Figure 13.2 – Exploring the Button control in the Uno Gallery](img/B20908_13_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 在 Uno Gallery 中探索按钮控件](img/B20908_13_02.jpg)'
- en: Figure 13.2 – Exploring the Button control in the Uno Gallery
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 在 Uno Gallery 中探索按钮控件
- en: Spend some time reviewing these online resources before we continue to create
    our first project with Uno Platform.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用 Uno Platform 创建第一个项目之前，花些时间查看这些在线资源。
- en: Creating your first Uno Platform project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个 Uno Platform 项目
- en: 'In this section, we are going to create a new Uno Platform project that will
    be the basis of our cross-platform version of the *My Media Collection* application
    that we created in several of the earlier chapters of this book. Before we can
    create a new Uno Platform project, we need to install the extension:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的 Uno Platform 项目，这将是我们跨平台版本的 *My Media Collection* 应用程序的基础，该应用程序在本书的几个早期章节中创建。在我们能够创建一个新的
    Uno Platform 项目之前，我们需要安装扩展：
- en: Start by opening Visual Studio and go to **Extensions** | **Manage Extensions**
    to open the **Manage** **Extensions** window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开 Visual Studio 并转到 **扩展** | **管理扩展** 以打开 **管理扩展** 窗口。
- en: In the `Uno Platform`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Uno Platform`。
- en: The **Uno Platform** extension should be the first result. Click **Install**
    and restart Visual Studio to complete the installation.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Uno Platform** 扩展应该是第一个结果。点击 **安装** 并重新启动 Visual Studio 以完成安装。'
- en: When you open Visual Studio again, select **Create a** **new project**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你再次打开 Visual Studio 时，选择 **创建一个** **新项目**。
- en: In the `Uno Platform`. You will get several results for the different Uno Platform
    project types.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Uno Platform` 中。你将得到不同 Uno Platform 项目类型的结果。
- en: Select the **Uno Platform App** template and click **Next**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Uno Platform App** 模板并点击 **下一步**。
- en: 'Name the project `UnoMediaCollection` and select **Create**. This will launch
    **Uno Platform** **Template Wizard**:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `UnoMediaCollection` 并选择 **创建**。这将启动 **Uno Platform** **模板向导**：
- en: '![Figure 13.3 – Uno Platform Template Wizard](img/B20908_13_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – Uno Platform 模板向导](img/B20908_13_03.jpg)'
- en: Figure 13.3 – Uno Platform Template Wizard
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Uno Platform 模板向导
- en: On the **Select startup type** page, select the **Customize** button on the
    **Default** type.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选择启动类型** 页面上，选择 **默认** 类型下的 **自定义** 按钮。
- en: This will open the detailed steps of the wizard. From here, you can configure
    all of the available Uno Platform options. We will leave most of these as default,
    but let’s step through each page.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打开向导的详细步骤。从这里，你可以配置所有可用的 Uno Platform 选项。我们将保留大多数默认设置，但让我们逐页浏览。
- en: On the **Framework** page, the default is currently **.NET 7.0**, but it may
    be **.NET 8.0** when you are reading this book. You can leave the default selection.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **框架** 页面上，当前默认为 **.NET 7.0**，但当你阅读这本书时，它可能是 **.NET 8.0**。你可以保留默认选择。
- en: On the **Platforms** page, we are going to only work with **Windows**, **Android**,
    and **WebAssembly**. You can unselect the other platforms.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **平台** 页面上，我们将只使用 **Windows**、**Android** 和 **WebAssembly**。你可以取消选择其他平台。
- en: On the `MyMediaCollection` application.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyMediaCollection` 应用程序。
- en: On the **Theme** page, select **Fluent** to use the same Fluent design of the
    original application.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **主题** 页面上，选择 **Fluent** 以使用原始应用程序相同的 Fluent 设计。
- en: On the **Extensions** page, you can remove **Localization** and change **Navigation**
    to **Blank**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **扩展** 页面上，你可以移除 **本地化** 并将 **导航** 改为 **空白**。
- en: You can uncheck the **Unit Tests** and **UI Tests** options on the **Testing**
    page. We won’t get into testing in this chapter.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 **测试** 页面上取消选中 **单元测试** 和 **UI 测试** 选项。我们不会在本章中涉及测试。
- en: 'You can leave the default settings on the **Projects**, **Features**, **Authentication**,
    and **Application** pages. To learn more about these options, you can review the
    Uno Platform documentation: [https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application](https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application).'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 **项目**、**功能**、**身份验证** 和 **应用程序** 页面上保留默认设置。要了解更多关于这些选项的信息，你可以查看 Uno Platform
    文档：[https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application](https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application)。
- en: Click **Create** to generate the projects and start working with them in Visual
    Studio. If Visual Studio prompts you to reload any projects, click **Reload**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 以生成项目并开始在 Visual Studio 中使用它们。如果 Visual Studio 提示你重新加载任何项目，请点击 **重新加载**。
- en: 'Follow the **Verify your developer environment** steps on the Uno welcome screen
    in Visual Studio:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 的 Uno 欢迎屏幕上遵循 **验证您的开发环境** 步骤：
- en: '![Figure 13.4 – Uno Platform welcome screen](img/B20908_13_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – Uno Platform 欢迎屏幕](img/B20908_13_04.jpg)'
- en: Figure 13.4 – Uno Platform welcome screen
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – Uno Platform 欢迎屏幕
- en: The `uno-check` command-line utility does a great job of diagnosing potential
    development environment issues and automatically fixing them. You should allow
    it to fix any issues it identifies before continuing. You may need to reboot your
    system after it’s done. Do this and open the project again before continuing to
    the next step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`uno-check`命令行工具在诊断潜在的开发环境问题并自动修复它们方面做得很好。您应该允许它在继续之前修复它识别出的任何问题。完成之后，您可能需要重新启动系统。完成此操作并重新打开项目，然后再继续下一步。'
- en: 'Make sure the `UnoMediaCollection.Windows` project is set as the startup project
    and start debugging. The app should launch and display a window containing a **Hello
    Uno** **Platform** message:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`UnoMediaCollection.Windows`项目设置为启动项目并开始调试。应用程序应该启动并显示一个包含**Hello Uno Platform**消息的窗口：
- en: '![Figure 13.5 – Running UnoMediaCollection as a Windows app](img/B20908_13_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 以Windows应用程序运行UnoMediaCollection](img/B20908_13_05.jpg)'
- en: Figure 13.5 – Running UnoMediaCollection as a Windows app
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 以Windows应用程序运行UnoMediaCollection
- en: That’s it! We’ve got a running app to use as our starting point. In the next
    section, we will learn more about the structure of the projects as we reuse code
    from the `MyMediaCollection` project to enhance `UnoMediaCollection`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经有一个运行的应用程序作为我们的起点。在下一节中，我们将通过从`MyMediaCollection`项目重用代码来增强`UnoMediaCollection`，我们将学习更多关于项目结构的信息。
- en: Migrating WinUI XAML markup and code to Uno Platform
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将WinUI XAML标记和代码迁移到Uno平台
- en: In this section, we are going to take the `UnoMediaCollection` solution that
    we created in the previous section and migrate the code from an earlier version
    of `MyMediaCollection`. This will give us a cross-platform version of the application
    that we will run on Windows, Android, and WebAssembly in the sections ahead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从上一节创建的`UnoMediaCollection`解决方案中提取代码，从`MyMediaCollection`的早期版本迁移代码。这将给我们一个跨平台的应用程序版本，我们将在接下来的部分中在Windows、Android和WebAssembly上运行。
- en: 'In order to keep things simple for our first project, we are going to migrate
    the code from the completed `MyMediaCollection` solution found in the completed
    code for [*Chapter 5*](B20908_05.xhtml#_idTextAnchor114), *Exploring WinUI Controls*.
    If you don’t have a copy of that code, you can get it from GitHub here: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete).
    The easiest way to follow along with the instructions is to download the solution,
    but you can also create each class in the Uno Project solution and copy and paste
    the WinUI project code from the GitHub editor.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的第一个项目保持简单，我们将从[*第5章*](B20908_05.xhtml#_idTextAnchor114)“探索WinUI控件”中找到的已完成的`MyMediaCollection`解决方案迁移代码。如果您没有该代码的副本，您可以从GitHub这里获取：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete)。遵循说明的最简单方法是下载解决方案，但您也可以在Uno项目解决方案中创建每个类，并将GitHub编辑器中的WinUI项目代码复制粘贴。
- en: 'We are going to use the code from [*Chapter 5*](B20908_05.xhtml#_idTextAnchor114)
    because the SQLite database hasn’t been added yet at this point. Adding code with
    file access to a Uno Platform project is possible but more complicated. It requires
    writing some **platform-specific code**. This code will be conditionally executed,
    depending on the platform where the application is currently running. Using SQLite
    on most platforms is relatively straightforward, but local file access on WebAssembly
    is not as easy. You can read more about platform-specific code on Uno Platform
    in their documentation: [https://platform.uno/docs/articles/platform-specific-csharp.html](https://platform.uno/docs/articles/platform-specific-csharp.html).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[*第5章*](B20908_05.xhtml#_idTextAnchor114)中的代码，因为在这个阶段还没有添加SQLite数据库。向Uno平台项目添加具有文件访问权限的代码是可能的，但更复杂。这需要编写一些**平台特定代码**。此代码将根据应用程序当前运行的平台进行条件执行。在大多数平台上使用SQLite相对简单，但在WebAssembly上本地文件访问则不那么容易。您可以在Uno
    Platform的文档中了解更多关于平台特定代码的信息：[https://platform.uno/docs/articles/platform-specific-csharp.html](https://platform.uno/docs/articles/platform-specific-csharp.html)。
- en: 'If working offline is not a concern, the best option for data access across
    all these platforms is to create a lightweight web service to handle your data
    access. Doing this also means adding an identity solution to ensure each user
    is accessing their own data. Uno Platform has some documentation on consuming
    a web API, if you’re interested in pursuing this option on your own: [https://platform.uno/docs/articles/howto-consume-webservices.html](https://platform.uno/docs/articles/howto-consume-webservices.html).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不关心离线工作，那么在这些所有平台上进行数据访问的最佳选项是创建一个轻量级的 Web 服务来处理您的数据访问。这样做也意味着添加一个身份解决方案以确保每个用户都在访问自己的数据。如果您对自行探索此选项感兴趣，Uno
    Platform 有一些关于消费 Web API 的文档：[https://platform.uno/docs/articles/howto-consume-webservices.html](https://platform.uno/docs/articles/howto-consume-webservices.html)。
- en: Now, let’s start our WinUI project migration to Uno Platform.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始将 WinUI 项目迁移到 Uno Platform。
- en: Migrating the WinUI project code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 WinUI 项目代码
- en: 'It’s time to get started with our cross-platform transformation of `MyMediaCollection`.
    We’ll start by importing the C# classes from the old project:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始我们的 `MyMediaCollection` 的跨平台转换了。我们将首先从旧项目中导入 C# 类：
- en: 'Start by opening the `UnoMediaCollection` solution from the previous section
    and create four new folders in the `UnoMediaCollection` project: `Enums`, `Interfaces`,
    `Model`, and `ViewModels`. We’ll also be adding classes from the `Services` folder,
    but that folder already exists in the new project:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从上一节打开 `UnoMediaCollection` 解决方案，并在 `UnoMediaCollection` 项目中创建四个新的文件夹：`Enums`、`Interfaces`、`Model`
    和 `ViewModels`。我们还将从 `Services` 文件夹添加类，但该文件夹已存在于新项目中：
- en: '![Figure 13.6 – The new folders added to the UnoMediaCollection project](img/B20908_13_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 添加到 UnoMediaCollection 项目的新的文件夹](img/B20908_13_06.jpg)'
- en: Figure 13.6 – The new folders added to the UnoMediaCollection project
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 添加到 UnoMediaCollection 项目的新的文件夹
- en: Right-click the `Enums` folder and select `Enums` folder in the WinUI `MyMediaCollection`
    project, select the `ItemType.cs` and `LocationType.cs` files, and click **Add**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Enums` 文件夹，在 WinUI `MyMediaCollection` 项目中选择 `Enums` 文件夹，选择 `ItemType.cs`
    和 `LocationType.cs` 文件，然后点击 **添加**。
- en: Open each newly added file and change the `namespace` to `UnoMediaCollection.Enums`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开每个新添加的文件，并将 `namespace` 改为 `UnoMediaCollection.Enums`。
- en: We’re going to repeat these steps for each of the remaining folders. Next, add
    the existing `IDataService.cs` and `INavigationService.cs` files to the `Interfaces`
    folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为剩余的每个文件夹重复这些步骤。接下来，将现有的 `IDataService.cs` 和 `INavigationService.cs` 文件添加到
    `Interfaces` 文件夹。
- en: 'In `IDataService`, change the `namespace` to `UnoMediaCollection.Interfaces`
    and update the `using` statements to the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IDataService` 中，将 `namespace` 改为 `UnoMediaCollection.Interfaces` 并更新 `using`
    语句为以下内容：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can remove any other `using` statements, as they’re part of the `INavigationService`,
    you can update the `namespace` to `UnoMediaCollection.Interfaces` and remove the
    `using` `System;` statement.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以删除任何其他 `using` 语句，因为它们是 `INavigationService` 的一部分，您可以更新 `namespace` 为 `UnoMediaCollection.Interfaces`
    并删除 `using` `System;` 语句。
- en: Add the existing `MediaItem.cs` and `Medium.cs` files to the `Model` folder.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `MediaItem.cs` 和 `Medium.cs` 文件添加到 `Model` 文件夹。
- en: 'Modify `MediaItem` to look like this (changes highlighted):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MediaItem` 以如下所示（变更已突出显示）：
- en: '[PRE1]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modify the `Medium` class to look like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Medium` 类以如下所示：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add the existing `DataService.cs` and `NavigationService.cs` files to the `Services`
    folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `DataService.cs` 和 `NavigationService.cs` 文件添加到 `Services` 文件夹。
- en: 'In `DataService`, update the `namespace` to `UnoMediaCollection.Services` and
    update your `using` statements to only contain these three statements:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DataService` 中，更新 `namespace` 为 `UnoMediaCollection.Services` 并更新您的 `using`
    语句，使其仅包含以下三个语句：
- en: '[PRE3]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `NavigationService`, update the `namespace` to `UnoMediaCollection.Services`
    and change the accessor of the `AppFrame` variable from `private static` to `internal
    static`. We’ll need to set this value from `App.cs` later. Also, update the `using`
    statements to contain only these two statements:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavigationService` 中，更新 `namespace` 为 `UnoMediaCollection.Services` 并将 `AppFrame`
    变量的访问器从 `private static` 更改为 `internal static`。我们稍后需要从 `App.cs` 设置此值。同时，更新 `using`
    语句，使其仅包含以下两个语句：
- en: '[PRE4]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add the existing `ItemDetailsViewModel.cs` and `MainViewModel.cs` files to the
    `ViewModels` folder.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `ItemDetailsViewModel.cs` 和 `MainViewModel.cs` 文件添加到 `ViewModels` 文件夹。
- en: 'In `ItemDetailsViewModel`, change the `namespace` to `UnoMediaCollection.ViewModels`
    and modify the `using` statements to contain these four statements:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ItemDetailsViewModel` 中，将 `namespace` 改为 `UnoMediaCollection.ViewModels`
    并修改 `using` 语句以包含以下四个语句：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `MainViewModel`, change the `namespace` to `UnoMediaCollection.ViewModels`
    and update the `using` statements to contain only these four statements:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中，将 `namespace` 更改为 `UnoMediaCollection.ViewModels` 并更新 `using`
    语句，使其只包含以下四个语句：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the changes so far are relatively simple. The Uno Platform project already
    uses the NuGet packages that we referenced in the WinUI project, so the code is
    very compatible.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止的所有更改都比较简单。Uno Platform 项目已经使用了我们在 WinUI 项目中引用的 NuGet 包，所以代码非常兼容。
- en: 'Before we move on to the two views, let’s make the necessary changes to `App.cs`.
    We need to set up `NavigationService` and register our services and ViewModel
    classes with the IoC container. First, add these three `using` statements to the
    `App` class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续到两个视图之前，让我们对 `App.cs` 进行必要的修改。我们需要设置 `NavigationService` 并将我们的服务和 ViewModel
    类注册到 IoC 容器中。首先，将以下三个 `using` 语句添加到 `App` 类中：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rename the `Host` variable to `HostContainer` to match the name from our WinUI
    project and make it `internal static`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Host` 变量重命名为 `HostContainer` 以匹配我们的 WinUI 项目的名称，并使其为 `internal static`：
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code to the beginning of the `OnLaunched` method, right before
    the `builder` object is created:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnLaunched` 方法开始处，在创建 `builder` 对象之前，添加以下代码：
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This creates the `navigationService` class, which will later be registered in
    the IoC container and registers the two views for navigation. I’ve highlighted
    the one difference from the code in the original WinUI project. We’re temporarily
    passing `new Frame()` into the constructor. Later in the method, we’ll set `AppFrame`
    to the `rootFrame` created toward the end of the `OnLaunched` method.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了 `navigationService` 类，稍后它将被注册到 IoC 容器中，并注册两个视图以进行导航。我已经突出显示了与原始 WinUI 项目代码的一个不同之处。我们暂时将
    `new Frame()` 传递到构造函数中。在方法中稍后，我们将 `AppFrame` 设置为 `OnLaunched` 方法末尾创建的 `rootFrame`。
- en: 'Next, update the `ConfigureServices` block in `OnLaunched` to look like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `OnLaunched` 中的 `ConfigureServices` 块，使其看起来像这样：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This registers our classes with the IoC container just like we did in our WinUI
    project.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就像我们在 WinUI 项目中所做的那样，将我们的类注册到 IoC 容器中。
- en: Update the `Host = builder.Build();` line of code in `OnLaunched` to `HostContainer
    =` `builder.Build();`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OnLaunched` 中的 `Host = builder.Build();` 代码行更新为 `HostContainer = builder.Build();`.
- en: 'Finally, immediately before the `MainWindow.Activate();` call at the end of
    `OnLaunched`, add this line of code to update the `AppFrame` static variable in
    `NavigationService`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `OnLaunched` 结尾的 `MainWindow.Activate();` 调用之前，添加以下代码行以更新 `NavigationService`
    中的 `AppFrame` 静态变量：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s everything we need to add and update except for the two views. The code
    won’t compile successfully yet because we referenced `ItemsDetailsPage` in `OnLaunched`
    but haven’t added it yet. We’ll take care of that in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个视图之外，我们还需要添加和更新的内容就这些了。代码还不能成功编译，因为我们已经在 `OnLaunched` 中引用了 `ItemsDetailsPage`，但还没有添加它。我们将在下一节中处理这个问题。
- en: Migrating the WinUI XAML views
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 WinUI XAML 视图
- en: 'In this section, we’ll finish the additions and changes to the `UnoMediaCollection`
    project and run the Windows version of the application. Let’s start with `ItemDetailsView`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成对 `UnoMediaCollection` 项目的添加和更改，并运行应用程序的 Windows 版本。让我们从 `ItemDetailsView`
    开始：
- en: Right-click the `UnoMediaCollection` project and select **Add** | **New Item**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `UnoMediaCollection` 项目，选择 **添加** | **新建项**.
- en: 'In the `ItemDetailsPage.xaml`, and click **Add**:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ItemDetailsPage.xaml` 中，并点击 **添加**：
- en: '![Figure 13.7 – Adding the ItemDetailsPage to the project](img/B20908_13_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 将 ItemDetailsPage 添加到项目中](img/B20908_13_07.jpg)'
- en: Figure 13.7 – Adding the ItemDetailsPage to the project
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 将 ItemDetailsPage 添加到项目中
- en: 'Open `ItemDetailsPage.xaml.cs` and replace the contents of the class with the
    following code from the WinUI project:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ItemDetailsPage.xaml.cs` 并将类的全部内容替换为 WinUI 项目中的以下代码：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we’re not migrating any of the user settings code following the `InitializeComponent`
    call in the constructor. We’ll keep things simple for our first migration attempt.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在构造函数中的 `InitializeComponent` 调用之后没有迁移任何用户设置代码。为了我们的第一次迁移尝试，我们将保持简单。
- en: 'You can also remove all `using` statements from the `ItemDetailsPage` class
    except for the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以从 `ItemDetailsPage` 类中删除所有 `using` 语句，除了以下这些：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Open `ItemDetailsPage.xaml` and replace the child contents of the `Page` with
    the contents of the `Page` from the `ItemDetailsPage.xaml` in the WinUI project.
    Do not replace the `Page` itself because the namespaces differ.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ItemDetailsPage.xaml` 并将 `Page` 的子内容替换为 WinUI 项目中 `ItemDetailsPage.xaml`
    的内容。不要替换 `Page` 本身，因为命名空间不同。
- en: 'Remove this `SplitButton.Resources` block because we won’t be using `TeachingTip`.
    We removed the code behind that relies on saving user preferences to the filesystem.
    Without that, it would appear every time the page opens:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除此 `SplitButton.Resources` 块，因为我们不会使用 `TeachingTip`。我们删除了依赖于将用户首选项保存到文件系统的代码。没有它，每次页面打开时都会出现：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `MainPage.xaml.cs` and add the following `using` statement:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml.cs` 并添加以下 `using` 语句：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The contents of the `MainPage` class will be similar to `ItemDetailsPage`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainPage` 类的内容将与 `ItemDetailsPage` 相似：'
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is slightly different than the implementation of `MainPage` in the WinUI
    project. We added an override of `OnNavigatedTo`. On some platforms, the list
    of items on `MainPage` was not updating after adding an item on `ItemDetailsPage`.
    Calling `PopulateData()` on `MainViewModel` when the user is navigating `Back`
    solved the behavior. This was an issue on both Android and WebAssembly. The Windows
    project worked as expected.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与 WinUI 项目中 `MainPage` 的实现略有不同。我们添加了对 `OnNavigatedTo` 的重写。在某些平台上，在 `ItemDetailsPage`
    上添加项目后，`MainPage` 上的项目列表没有更新。当用户导航到 `Back` 时调用 `MainViewModel` 上的 `PopulateData()`
    解决了这种行为。这是 Android 和 WebAssembly 上的一个问题。Windows 项目按预期工作。
- en: Open `MainPage.xaml` and replace the entire child contents of the `Page` from
    the `Page` in `MainPage.xaml`. Like we did in `ItemDetailsPage.xaml`, be careful
    not to replace the `Page` itself due to namespace differences.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml` 并替换 `Page` 中的 `Page` 的整个子内容。就像我们在 `ItemDetailsPage.xaml`
    中做的那样，由于命名空间的不同，请小心不要替换 `Page` 本身。
- en: 'Finally, add the following `using` declaration to the `Page` element in `MainPage`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下 `using` 声明添加到 `MainPage` 中的 `Page` 元素：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `MediaItem` model class is referenced by `DataTemplate` in our `ListView`
    and requires this `using` declaration.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MediaItem` 模型类在 `ListView` 中的 `DataTemplate` 中被引用，并需要此 `using` 声明。'
- en: Those are all the changes needed to get the application ready to run with Uno
    Platform. We didn’t have to change our XAML controls at all, outside of removing
    `TeachingTip`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是使应用程序准备好使用 Uno Platform 运行的所有更改。我们根本不需要更改我们的 XAML 控件，除了删除 `TeachingTip`。
- en: 'Let’s run the Windows version of the application to make sure everything works
    as expected. Make sure `UnoMediaCollection.Windows` is set as the startup project
    and run the application. It should look something like this when it launches:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 Windows 版本的应用程序，以确保一切按预期工作。确保将 `UnoMediaCollection.Windows` 设置为启动项目并运行应用程序。当它启动时，应该看起来像这样：
- en: '![Figure 13.8 – Running the Windows project with Uno Platform](img/B20908_13_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 使用 Uno Platform 运行 Windows 项目](img/B20908_13_08.jpg)'
- en: Figure 13.8 – Running the Windows project with Uno Platform
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 使用 Uno Platform 运行 Windows 项目
- en: It looks exactly like the [*Chapter 5*](B20908_05.xhtml#_idTextAnchor114) version
    of our WinUI application. If you try adding, editing, or removing items, everything
    should work as expected. Great work! That was pretty simple. Let’s move on and
    try using the application on Android with WSA.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与我们的 WinUI 应用程序的 [*第 5 章*](B20908_05.xhtml#_idTextAnchor114) 版本完全一样。如果您尝试添加、编辑或删除项目，一切都应该按预期工作。做得好！这很简单。让我们继续前进，尝试使用
    WSA 在 Android 上使用该应用程序。
- en: Running on Android with WSA
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WSA 在 Android 上运行
- en: 'Running and debugging Android applications on Windows is fast and easy with
    WSA. The easiest way to install WSA on Windows 11 is to install **Amazon Appstore**
    from the Microsoft Store. You can get the app here: [https://aka.ms/AmazonAppstore](https://aka.ms/AmazonAppstore).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WSA 在 Windows 上运行和调试 Android 应用程序既快又简单。在 Windows 11 上安装 WSA 的最简单方法是安装来自 Microsoft
    Store 的 **Amazon Appstore**。您可以通过此处获取应用程序：[https://aka.ms/AmazonAppstore](https://aka.ms/AmazonAppstore)。
- en: '![Figure 13.9 – The Amazon Appstore app in the Microsoft Store](img/B20908_13_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – Microsoft Store 中的 Amazon Appstore 应用](img/B20908_13_09.jpg)'
- en: Figure 13.9 – The Amazon Appstore app in the Microsoft Store
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – Microsoft Store 中的 Amazon Appstore 应用
- en: 'Install the app and follow the prompts to install WSA as part of the process.
    When it has finished with the initial installation, you will need to restart your
    computer to complete the WSA installation and configuration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应用程序并按照提示将 WSA 作为过程的一部分进行安装。在完成初始安装后，您需要重新启动计算机以完成 WSA 的安装和配置：
- en: '![Figure 13.10 – Completing the Amazon Appstore installation](img/B20908_13_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 完成Amazon Appstore的安装](img/B20908_13_10.jpg)'
- en: Figure 13.10 – Completing the Amazon Appstore installation
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 完成Amazon Appstore的安装
- en: 'After the reboot is complete, find the Amazon Appstore app in your Windows
    Start menu and launch it. You will see WSA start up first:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重启完成后，在您的 Windows 开始菜单中找到 Amazon Appstore 应用并启动它。您会看到 WSA 首先启动：
- en: '![Figure 13.11 – Starting the WSA process](img/B20908_13_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 启动 WSA 进程](img/B20908_13_11.jpg)'
- en: Figure 13.11 – Starting the WSA process
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 启动 WSA 进程
- en: 'Keep Amazon Appstore running in the background to ensure your Android system
    remains active. You can minimize the window if you like. The other thing you will
    have to do to use WSA from Visual Studio is to ensure **Developer mode** is turned
    on. Launch **Windows Subsytem for Android** from the Start menu. This will open
    the WSA **System** settings page. Select **Advanced settings** from the left navigation
    panel to open the **Advanced** **settings** page:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请保持 Amazon Appstore 在后台运行，以确保您的 Android 系统保持活跃。如果您喜欢，可以最小化窗口。您还需要做的另一件事是确保 **开发者模式**
    已开启。从开始菜单启动 **Windows Subsystem for Android**。这将打开 WSA **系统** 设置页面。从左侧导航面板中选择
    **高级设置** 以打开 **高级** **设置** 页面：
- en: '![Figure 13.12 – The WSA System settings](img/B20908_13_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.12 – WSA 系统设置](img/B20908_13_12.jpg)'
- en: Figure 13.12 – The WSA System settings
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – WSA 系统设置
- en: 'If **Developer mode** isn’t turned on, turn it on now. The last preparation
    step is to connect the **Android SDK** to the WSA for our debugging session. To
    do this, you’ll need to find where your Android SDK is installed. It should be
    at this path if it was installed with your Visual Studio installation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **开发者模式** 没有开启，请现在开启它。最后的准备步骤是将 **Android SDK** 连接到 WSA 以进行我们的调试会话。为此，您需要找到您的
    Android SDK 安装位置。如果它是与 Visual Studio 安装一起安装的，它应该在这个路径上：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will need to run the following command from a command prompt. Open a terminal
    or command window in the `platform-tools` subfolder of your SDK location. This
    is the command if you are running within **PowerShell**. I am using **Windows
    Terminal** with a PowerShell window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从命令提示符运行以下命令。在您的 SDK 位置的 `platform-tools` 子文件夹中打开一个终端或命令窗口。如果您在 **PowerShell**
    中运行，这是该命令：我使用 **Windows Terminal** 中的 PowerShell 窗口：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you get the `failed to authenticate to 127.0.0.1:58526` message, check whether
    there is a WSA pop-up dialog behind your other windows. Click the `adb connect`
    command each time you start debugging with WSA.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到 `failed to authenticate to 127.0.0.1:58526` 的消息，请检查是否有 WSA 弹出对话框在您的其他窗口后面。每次您使用
    WSA 开始调试时，都点击 `adb connect` 命令。
- en: 'It’s time to run the Android version of our application with WSA. Update the
    startup project to be **UnoMediaCollection.Mobile**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 WSA 运行我们应用程序的 Android 版本了。将启动项目更新为 **UnoMediaCollection.Mobile**：
- en: '![Figure 13.13 – Updating the startup project to run on mobile](img/B20908_13_13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 更新启动项目以在移动设备上运行](img/B20908_13_13.jpg)'
- en: Figure 13.13 – Updating the startup project to run on mobile
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 更新启动项目以在移动设备上运行
- en: 'If the WSA is still active, you should see **Microsoft Corporation Subsystem
    for Android** followed by an Android version number on the **Debug** button. Start
    debugging and wait a few minutes. Compiling, deploying, and running an Android
    application can take a bit longer than the Windows version. When the application
    launches, it should look something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WSA 仍然处于活动状态，您应该在 **调试** 按钮上看到 **Microsoft Corporation Subsystem for Android**
    以及一个 Android 版本号。开始调试并等待几分钟。编译、部署和运行 Android 应用程序可能比 Windows 版本花费的时间要长。当应用程序启动时，它应该看起来像这样：
- en: '![Figure 13.14 – Running the UnoMediaCollection application on Android with
    the WSA](img/B20908_13_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – 使用 WSA 在 Android 上运行 UnoMediaCollection 应用程序](img/B20908_13_14.jpg)'
- en: Figure 13.14 – Running the UnoMediaCollection application on Android with the
    WSA
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 使用 WSA 在 Android 上运行 UnoMediaCollection 应用程序
- en: Everything should function just as it did on Windows, but there could be slightly
    more lag in the UI, depending on the performance of your system. The cool thing
    about using the WSA is that you can resize your application’s window to test the
    UI layout in different aspect ratios. Give it a try.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的功能应该和在 Windows 上一样，但根据您系统的性能，UI 可能会有轻微的延迟。使用 WSA 的酷之处在于您可以将应用程序的窗口大小调整到测试不同宽高比下的
    UI 布局。试试看。
- en: 'If you have an Android emulator configured in the Android SDK on your system,
    you can also try selecting that on the **Debug** button and running it there.
    It will look something like this on a traditional phone emulator image:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在系统上的 Android SDK 中配置了 Android 模拟器，您也可以尝试在 **调试** 按钮上选择它并在那里运行。在传统手机模拟器图像上，它看起来可能像这样：
- en: '![Figure 13.15 – Running the application on an Android emulator](img/B20908_13_15.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 在 Android 模拟器上运行应用程序](img/B20908_13_15.jpg)'
- en: Figure 13.15 – Running the application on an Android emulator
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 在 Android 模拟器上运行应用程序
- en: We’re up and running on Android. In many cases, switching platforms is as easy
    as changing the startup project. Let’s finish up by trying our application on
    the web with WebAssembly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Android 上运行起来了。在许多情况下，切换平台就像更改启动项目一样简单。让我们通过在 Web 上使用 WebAssembly 尝试我们的应用程序来结束这次尝试。
- en: Running in the browser with WebAssembly
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 在浏览器中运行
- en: In this final section, we will try running the application in the browser with
    WebAssembly. Uno Platform makes it easy to do, but like Android, the compilation
    and deployment can take a little time. That’s because the entire application needs
    to run client-side within the browser. That means that in addition to deploying
    our application, all its dependencies (even a version of the .NET runtime) also
    need to be deployed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将尝试在浏览器中使用 WebAssembly 运行应用程序。Uno Platform 使得这变得很容易，但就像 Android 一样，编译和部署可能需要一点时间。这是因为整个应用程序需要在浏览器中作为客户端运行。这意味着除了部署我们的应用程序外，所有其依赖项（甚至包括
    .NET 运行时的一个版本）也需要被部署。
- en: 'This is one reason why the adoption of WebAssembly hasn’t been as fast as many
    anticipated. The first-time load performance of these apps can be sluggish at
    best. Uno Platform published a blog post about optimizing WebAssembly performance
    with Uno Platform applications. If you plan to pursue this option, you should
    read this post: [https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/](https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 WebAssembly 的采用速度没有像许多人预期的那样快的原因之一。这些应用程序的首次加载性能在最理想的情况下也可能比较慢。Uno Platform
    发布了一篇关于使用 Uno Platform 优化 WebAssembly 性能的博客文章。如果你打算追求这个选项，你应该阅读这篇文章：[https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/](https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/)。
- en: 'Change the startup project to `UnoMediaCollection.Wasm` and start debugging.
    You’ll notice a command window launch in the background, hosting the web server
    that deploys the WebAssembly application. Next, a browser window will open. While
    the application is deploying and loading, you’ll see a Uno Platform logo acting
    as a splash screen. When the application loads, it will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将启动项目更改为 `UnoMediaCollection.Wasm` 并开始调试。你会在后台看到一个命令窗口启动，它承载着部署 WebAssembly
    应用程序的 Web 服务器。接下来，将打开一个浏览器窗口。在应用程序部署和加载的过程中，你会看到一个 Uno Platform 标志作为启动画面。当应用程序加载完成后，它看起来会是这样：
- en: '![Figure 13.16 – Running the Uno Platform application in a browser with WebAssembly](img/B20908_13_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – 在浏览器中使用 WebAssembly 运行 Uno Platform 应用程序](img/B20908_13_16.jpg)'
- en: Figure 13.16 – Running the Uno Platform application in a browser with WebAssembly
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 在浏览器中使用 WebAssembly 运行 Uno Platform 应用程序
- en: Try using the application. It should function exactly as it did on other platforms.
    While a few of the visuals may differ from platform to platform, Uno Platform
    promises near-pixel-perfect applications on each supported platform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用该应用程序。它应该与在其他平台上运行时完全一样。虽然一些视觉元素可能在不同平台上有所不同，但 Uno Platform 承诺在每个支持平台上都能实现接近像素级的完美应用程序。
- en: 'If you would like to explore debugging further, there are some differences
    when debugging WebAssembly applications. The Uno Platform documentation has some
    great information on this: [https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html](https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进一步探索调试，调试 WebAssembly 应用程序时有一些不同之处。Uno Platform 文档中关于这方面的信息非常出色：[https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html](https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html)。
- en: That is all we will be doing in this section with WebAssembly and Uno Platform.
    Let’s wrap up and review what we’ve learned in this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 WebAssembly 和 Uno Platform 完成所有操作。让我们总结一下，回顾一下本章所学的内容。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all about Uno Platform. WinUI developers can take
    their Windows development experience and leverage it to build applications for
    every platform. While we focused on Visual Studio and Windows development here,
    with Visual Studio, VS Code, and JetBrains Rider, you can build your Uno Platform
    applications from any platform. We started with a basic *Hello World*-style application
    and imported the code and XAML from our WinUI project to create a cross-platform
    version of the application with very few changes. We also learned how you can
    leverage WSA to debug resizable Android applications on Windows without configuring
    an emulator. Finally, we ran our application in the browser with Uno Platform
    and WebAssembly. You’re ready to try Uno Platform for yourself and test some of
    the other platforms that it supports.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于 Uno Platform 的所有内容。WinUI 开发者可以利用他们的 Windows 开发经验，将其用于构建适用于每个平台的应用程序。虽然我们在这里专注于
    Visual Studio 和 Windows 开发，但使用 Visual Studio、VS Code 和 JetBrains Rider，你可以在任何平台上构建你的
    Uno Platform 应用程序。我们从基本的 *Hello World* 风格的应用程序开始，将代码和 XAML 从我们的 WinUI 项目导入，以极少的更改创建了一个跨平台版本的应用程序。我们还学习了如何利用
    WSA 在 Windows 上调试可调整大小的 Android 应用程序，而无需配置模拟器。最后，我们使用 Uno Platform 和 WebAssembly
    在浏览器中运行了我们的应用程序。你现在可以亲自尝试 Uno Platform 并测试它支持的其他平台。
- en: In the next (and final) chapter, we will discover how to deploy WinUI 3 applications
    to the Microsoft Store, via **WinGet**, or with enterprise deployment options.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（也是最后一章）中，我们将了解如何通过 **WinGet** 或企业部署选项将 WinUI 3 应用程序部署到 Microsoft Store。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are two deployment options when debugging Android applications with Visual
    Studio?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 调试 Android 应用程序时，有哪些两种部署选项？
- en: What are two application design patterns supported by Uno Platform?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Uno Platform 支持哪两种应用程序设计模式？
- en: What XAML schemas are supported by Uno Platform?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Uno Platform 支持哪些 XAML 架构？
- en: When was the first Uno Platform release?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一版 Uno Platform 是何时发布的？
- en: What client-side web technology can .NET and Uno Platform developers leverage
    to run applications natively in the browser?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 和 Uno Platform 开发者可以利用哪种客户端 Web 技术在浏览器中本地运行应用程序？
- en: What two online resources does Uno Platform provide to test their controls and
    components in your browser?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Uno Platform 提供哪两种在线资源，以便你在浏览器中测试其控件和组件？
- en: What design tool can you leverage to design your Uno Platform applications before
    developing them in your favorite IDE?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以利用哪种设计工具在设计你喜欢的 IDE 中开发 Uno Platform 应用程序之前设计它们？
