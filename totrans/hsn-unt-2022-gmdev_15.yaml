- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: User Interface Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面设计
- en: Everything that is shown on the screen and transmitted through the speakers
    of a computer is a form of communication. In previous chapters, we used 3D models
    to let the user know that they are in a base in the middle of the mountains, and
    we reinforced that idea with the appropriate sound and music. But for our game,
    we need to communicate other information, such as the amount of life the player
    has left and the current score, and sometimes, it is difficult to express these
    things using the in-game graphics (there are some successful cases that manage
    to do this, such as *Dead Space*, but let’s keep things simple).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示并通过计算机扬声器传输的每一件事，都是一种沟通方式。在之前的章节中，我们使用了3D模型来让用户知道他们身处山中的基地，并通过适当的声音和音乐强化了这个想法。但对我们游戏来说，我们需要传达其他信息，例如玩家剩余的生命值和当前得分，有时，使用游戏内的图形来表达这些事情是有困难的（有一些成功的案例能够做到这一点，例如*死亡空间*，但让我们保持简单）。
- en: In order to transmit this information, we need to add another layer of graphics
    on top of our scene, which is usually called the **User Interface** (**UI**).
    This will contain different visual elements, such as text fields, bars, and buttons,
    to prepare the user to make an informed decision based on things such as fleeing
    to a safe place when their life is low.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传输此类信息，我们需要在我们的场景之上添加另一层图形，这通常被称为**用户界面**（**UI**）。这将包含不同的视觉元素，例如文本字段、条形图和按钮，以便用户能够根据生命值低时逃往安全地点等情况做出明智的决定。
- en: 'In this chapter, we will visit the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding the Canvas and RectTransform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Canvas和RectTransform
- en: Canvas object types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas对象类型
- en: Creating a responsive UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式UI
- en: By the end of this chapter, you will be able to use the Unity UI system to create
    interfaces capable of informing the user about the state of the game and allowing
    them to take action by pressing buttons. Let’s start by discussing the basic concepts
    of the Unity UI system—the Canvas and RectTransform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Unity UI系统创建能够通知用户游戏状态并允许他们通过按按钮采取行动的界面。让我们首先讨论Unity UI系统的基本概念——Canvas和RectTransform。
- en: Understanding the Canvas and RectTransform
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Canvas和RectTransform
- en: We are only going to focus on the in-game UI to communicate different information
    to the player using the Unity GUI system (or uGUI). At the time of writing this
    book, a new GUI system called UI Toolkit has been released, but uGUI will still
    be here for a while, given UI Toolkit will be used mostly in new projects, and
    is still perfectly capable of handling all types of UI. We will explore UI Toolkit
    in the next chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注游戏内的UI，使用Unity GUI系统（或uGUI）向玩家传达不同的信息。在撰写本书时，一个新的GUI系统名为UI Toolkit已经发布，但uGUI仍将存在一段时间，因为UI
    Toolkit将主要用于新项目，并且仍然能够处理所有类型的UI。我们将在下一章探讨UI Toolkit。
- en: If you are going to work with Unity UI, you first need to understand its two
    main concepts—the **Canvas** and **RectTransform**. The **Canvas** is the master
    object that will contain and render our UI, and **RectTransform** is the feature
    in charge of positioning and adapting each UI element on our screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用Unity UI，你首先需要理解其两个主要概念——**Canvas**和**RectTransform**。**Canvas**是包含并渲染我们的UI的主对象，而**RectTransform**是负责在屏幕上定位和调整每个UI元素的特性。
- en: 'In this section, we will be:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下内容：
- en: Creating a UI with the Canvas
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: Positioning elements with RectTransform
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: Let’s start by using the Canvas component to create our UI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用Canvas组件来创建我们的UI开始。
- en: Creating a UI with the Canvas
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components, but in order for them to work, they must be a
    child of a master GameObject with the Canvas component. This component is responsible
    for triggering the UI generation and drawing iterations over each child object.
    We can configure this component to specify exactly how that process works and
    adapt it to different possible requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，UI中看到的每个图像、文本和元素都是一个具有一组适当组件的GameObject，但为了使它们能够工作，它们必须是一个具有Canvas组件的主GameObject的子对象。这个组件负责触发UI生成并在每个子对象上绘制迭代。我们可以配置这个组件来指定该过程的确切工作方式，并适应不同的可能需求。
- en: To start, you can simply create a canvas with the **GameObject** | **UI** |
    **Canvas** option. After doing that, you will see a rectangle in the scene, which
    represents the user screen, so you can put elements inside it and preview where
    they will be located relative to the user’s monitor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以简单地通过选择**GameObject** | **UI** | **Canvas**选项来创建一个画布。完成此操作后，你将在场景中看到一个矩形，它代表用户屏幕，因此你可以将其内部放入元素并预览它们相对于用户监视器的位置。
- en: You are probably wondering two things here. First, “*Why is the rectangle in
    the middle of the scene? I want it to always be on the screen!*” Don’t worry because
    that will be exactly the case. When you edit the UI, you will see it as part of
    the level, as an object inside it, but when you play the game, it will be always
    projected over the screen, on top of every object. Also, you may be wondering
    why the rectangle is huge, and that’s because one pixel of the screen map corresponds
    to one meter on the scene when using the default **Canvas** **Render Mode**, the
    one called **Screen Space - Overlay**. There are other modes, but discussing them
    is outside of the scope of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在这里有两个疑问。首先，“*为什么场景中间有一个矩形？我希望它始终显示在屏幕上!*”不用担心，情况确实如此。当你编辑UI时，你会看到它作为关卡的一部分，作为其中的一个对象，但当你玩游戏时，它将始终投影在屏幕上，覆盖在所有对象之上。此外，你可能想知道为什么矩形这么大，这是因为在使用默认的**画布****渲染模式**，即称为**屏幕空间
    - 覆盖**时，屏幕映射中的一个像素对应场景中的一米。还有其他模式，但讨论它们超出了本章的范围。
- en: 'Again, don’t worry about that; you will see all your UI elements in their proper
    size and position on the user’s screen when you see the game in the **Game** view.
    Consider setting the **Game** view size prior to editing it in the **Scene** view
    given that the **Scene** view will follow the **Game** view dimensions. You can
    do that by clicking the dropdown saying **Free Aspect** at the top part of the
    **Game** panel and selecting the desired resolution or aspect ratio, **16:9 Aspect**
    being the most used option:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要担心这个问题；当你从**游戏**视图中查看游戏时，你将看到所有UI元素在用户屏幕上的正确大小和位置。考虑到**场景**视图将遵循**游戏**视图的尺寸，建议在**场景**视图中编辑之前先设置**游戏**视图的大小。你可以通过点击**游戏**面板顶部说**自由纵横比**的下拉菜单，并选择所需的分辨率或纵横比来完成此操作，**16:9纵横比**是最常用的选项：
- en: '![](img/B18585_15_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_01.png)'
- en: 'Figure 15.1: A default image UI element—a white box'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：默认图像UI元素——一个白色框
- en: Before adding elements to our UI, it’s worth noting that when you created the
    UI, a second object was created alongside the Canvas, called **EventSystem**.
    This object is not necessary to render a UI but is necessary if you want the UI
    to be interactable, which means including actions such as clicking buttons, introducing
    text in fields, or navigating the UI with the joystick. The **EventSystem** component
    is responsible for sampling the user input, such as with a keyboard, mouse, or
    joystick, and sending that data to the UI to react accordingly. We can change
    the exact buttons to interact with the UI, but the defaults are OK for now, so
    just know that you need this object if you want to interact with the UI. If for
    some reason you delete the object, you can recreate it again in **GameObject**
    | **UI** | **Event System**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的UI添加元素之前，值得注意的是，当你创建UI时，与Canvas一起创建了一个名为**EventSystem**的第二个对象。这个对象对于渲染UI不是必需的，但如果你想让UI可交互，即包括点击按钮、在字段中输入文本或使用摇杆导航UI等动作，则是必需的。**EventSystem**组件负责采样用户输入，如键盘、鼠标或摇杆，并将这些数据发送到UI以做出相应反应。我们可以更改与UI交互的确切按钮，但默认设置现在是可以接受的，所以只需知道，如果你想与UI交互，你需要这个对象。如果由于某种原因你删除了这个对象，你可以在**GameObject**
    | **UI** | **Event System**中重新创建它。
- en: Now that we have the base objects to create our UI, let’s add elements to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建UI的基础对象，让我们向其中添加元素。
- en: Positioning elements with RectTransform
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components according to its usage, but you will see that
    most of them have one component in common—**RectTransform**. Each piece of the
    UI is essentially a rectangle filled with text or images and has different behavior,
    so it is important to understand how the **RectTransform** component works and
    how to edit it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，你看到的每个图像、文本和UI元素都是一个具有根据其使用情况设置的组件的GameObject，但你将看到它们大多数都有一个共同的组件——**RectTransform**。UI的每一部分本质上都是一个填充有文本或图像的矩形，并且具有不同的行为，因此理解**RectTransform**组件的工作原理以及如何编辑它非常重要。
- en: 'In order to experiment with this component, let’s create and edit the position
    of a simple white box element for the UI as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验这个组件，让我们创建并编辑UI的一个简单白色框元素的定位，如下所示：
- en: 'Go to **GameObject | UI | Image**. After that, you will see that a new GameObject
    is created within the **Canvas** element. Unity will take care of setting any
    new UI element as a child of the Canvas; outside it, the element will not be visible:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**GameObject | UI | Image**。之后，你将看到在**Canvas**元素内创建了一个新的GameObject。Unity将负责将任何新的UI元素设置为Canvas的子元素；在其外部，该元素将不可见：
- en: '![](img/B18585_15_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_02.png)'
- en: 'Figure 15.2: A default image UI element—a white box'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：默认图像UI元素——一个白色框
- en: 'Click on the 2D button in the top bar of the **Scene** view. This will just
    change the perspective of the Scene view to one that is better suited to edit
    the UI (and also 2D games):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Scene**视图顶部的2D按钮。这将仅更改Scene视图的视角，使其更适合编辑UI（以及2D游戏）：
- en: '![](img/B18585_15_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_03.png)'
- en: 'Figure 15.3: The 2D button location'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：2D按钮位置
- en: Double-click on the Canvas in the **Hierarchy** window to make the UI fit entirely
    in the Scene view. This will allow us to edit the UI clearly. You can also navigate
    the UI using the mouse scroll wheel to zoom, and click and drag the scroll wheel
    to pan the camera.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中双击Canvas，使UI完全适合Scene视图。这将允许我们清楚地编辑UI。你还可以使用鼠标滚轮导航UI进行缩放，点击并拖动滚轮来平移相机。
- en: 'Enable the **RectTransform** tool, which is the fifth button in the top-left
    part of the Unity Editor (or press the *T* key). This will enable the rectangle
    gizmo, which allows you to move, rotate, and scale 2D elements without the issues
    the regular 3D transform gizmos can cause:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**RectTransform**工具，这是Unity编辑器左上角第五个按钮（或按*T*键）。这将启用矩形辅助工具，允许你移动、旋转和缩放2D元素，而不会像常规3D变换辅助工具那样引起问题：
- en: '![](img/B18585_15_04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_04.png)'
- en: 'Figure 15.4: The rectangle gizmo button'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：矩形辅助工具按钮
- en: 'Using the rectangle gizmo, drag the object to move it, use the blue dots to
    change its size, or locate the mouse in a position near the blue dots until the
    cursor becomes a curved arrow to rotate it. Consider that resizing the object
    using this gizmo is not the same as scaling the object, but more on that in a
    moment:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形辅助工具，拖动对象以移动它，使用蓝色点来更改其大小，或将鼠标定位在蓝色点附近，直到光标变成曲线箭头以旋转它。请注意，使用此辅助工具调整对象大小与缩放对象不同，稍后我们将详细介绍这一点：
- en: '![](img/B18585_15_05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_05.png)'
- en: 'Figure 15.5: The rectangle gizmo for editing 2D elements'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：编辑2D元素的矩形辅助工具
- en: 'In the **Inspector** window, notice that after changing the size of the UI
    element, the **Rect Transform** setting’s **Scale** property is still at `1`,
    `1`, `1`, but you can see how the **Width** and **Height** properties changed.
    **RectTransform** is essentially a classic transform but with **Width** and **Height**
    added (among other properties to explore later). You can set the exact values
    you want here expressed in pixels:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口中，注意在更改UI元素的大小后，**Rect Transform**设置的**Scale**属性仍然为`1`，`1`，`1`，但你可以看到**Width**和**Height**属性已发生变化。**RectTransform**本质上是一个经典的变换，但增加了**Width**和**Height**（以及其他稍后要探索的属性）。你可以在这里设置你想要的精确值，以像素为单位：
- en: '![](img/B18585_15_06.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_06.png)'
- en: 'Figure 15.6: The Rect Transform properties'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：Rect Transform属性
- en: Now that we know the very basics of how to position any UI object, let’s explore
    the different types of elements you can add to the Canvas.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何定位任何UI对象的基础知识，让我们探索可以添加到Canvas的不同类型的元素。
- en: Canvas object types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas对象类型
- en: So far, we have used the simplest Canvas object type—a white box—but there are
    plenty of other object types we can use, such as images, buttons, and text. All
    of them use **RectTransform** to define their display area, but each one has its
    own concepts and configurations to understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是最简单的Canvas对象类型——一个白色框，但我们可以使用许多其他对象类型，例如图像、按钮和文本。所有这些都使用**RectTransform**来定义它们的显示区域，但每个都有其自己的概念和配置需要理解。
- en: 'In this section, we will explore the following Canvas object concepts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索以下Canvas对象概念：
- en: Integrating assets for the UI
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成UI资产
- en: Creating UI controls
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: Let’s first start exploring how we can integrate images and fonts to use in
    our Canvas so that we can integrate them in our UI using the **Images** and **Text**
    UI object types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索如何将图像和字体集成到Canvas中，以便我们可以使用**Images**和**Text**UI对象类型将它们集成到UI中。
- en: Integrating assets for the UI
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成UI资产
- en: 'Before making our UI use nice graphics assets, we need to integrate them properly
    into Unity. In the following screenshot, you will find the UI design we propose
    for our game:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的UI使用漂亮的图形资产之前，我们需要将它们正确集成到Unity中。在下面的屏幕截图中，您将找到我们为游戏提出的UI设计：
- en: '![](img/B18585_15_07.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_07.png)'
- en: 'Figure 15.7: UI design'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：UI设计
- en: 'On top of that, we will add a **Pause** menu, which will be activated when
    the user presses *Esc*. It will look like the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加一个**暂停**菜单，当用户按下*Esc*键时将被激活。它看起来如下截图所示：
- en: '![](img/B18585_15_08.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_08.png)'
- en: 'Figure 15.8: The Pause menu design'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：暂停菜单设计
- en: 'Based on these designs, we can determine that we will need the following assets:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些设计，我们可以确定我们需要以下资产：
- en: The hero’s avatar image
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄的头像图片
- en: A health bar image
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个健康条图片
- en: A **Pause** menu background image
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**暂停**菜单背景图片
- en: A **Pause** menu button image
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**暂停**菜单按钮图片
- en: Font for the text
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字体
- en: 'As always, we can find the required assets on the internet or in the Asset
    Store. In my case, I will use a mixture of both. Let’s start with the simplest
    one—the avatar. Take the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以在互联网或Asset Store上找到所需的资产。在我的情况下，我将使用两者的混合。让我们从最简单的一个开始——头像。按照以下步骤操作：
- en: Download the avatar you want from the internet, like an image with a face of
    a character.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网上下载您想要的头像，比如一个角色的面部图像。
- en: Add it to your project, either by dragging it to the Project window or by using
    the **Assets | Import New Asset** option. Add it to a `Sprites` folder.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到您的项目中，可以通过将其拖动到项目窗口或使用**资产 | 导入新资产**选项来实现。将其添加到`精灵`文件夹。
- en: Select the texture, and in the Inspector window, set the **Texture Type** setting
    to **Sprite (2D and UI)**. All textures are prepared to be used in 3D by default.
    This option prepares our texture to be used in 2D contexts, like the UI and also
    2D games.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理，并在检查器窗口中，将**纹理类型**设置为**精灵（2D和UI）**。所有纹理默认都准备用于3D。此选项将我们的纹理准备用于2D环境，如UI和2D游戏。
- en: 'For the bars, buttons, and the window background, I will use Asset Store to
    look for a UI pack. In my case, I found the package in the following screenshot
    a good one to start my UI. As usual, remember that this exact package might not
    be available right now. In that case, remember to look for another similar package,
    or pick the sprites from the GitHub repo:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条形、按钮和窗口背景，我将使用Asset Store来寻找一个UI包。在我的情况下，我在下面的屏幕截图中找到了一个很好的包来开始我的UI。像往常一样，请记住，这个确切的包可能现在不可用。在这种情况下，请记住寻找另一个类似的包，或者从GitHub仓库中选择精灵：
- en: '![](img/B18585_15_09.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_09.png)'
- en: 'Figure 15.9: Selected UI pack'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：选定的UI包
- en: At first, the package contains lots of images configured the same way, as sprites,
    but we can further modify the import settings to achieve advanced behavior, which
    we will need for the buttons. The button asset comes with a fixed size, but what
    happens if you need a bigger button? One option is to use other button assets
    with different sizes, but this will lead to a lot of repetitions of the buttons
    and other assets, such as different-sized backgrounds for different windows, which
    will unnecessarily consume RAM.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个包包含许多以相同方式配置的图像，作为精灵，但我们可以进一步修改导入设置以实现高级行为，这对于按钮是必需的。按钮资产有一个固定的大小，但如果你需要一个更大的按钮怎么办？一个选项是使用不同大小的其他按钮资产，但这会导致按钮和其他资产（如不同大小的窗口背景）的大量重复，这会不必要地消耗RAM。
- en: Another option is to use the **9-slices** method, which consists of splitting
    an image so that the corners are separated from the other parts. This allows Unity
    to stretch the middle parts of the image to fit different sizes, keeping the corners
    at their original size, which, when combined with an image prepared for the 9-slices
    technique, can be used to create almost any size you need.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用**九宫格**方法，它包括将图像分割成四个角落与其他部分分离。这允许Unity拉伸图像的中间部分以适应不同的大小，同时保持角落的原有大小。当与为九宫格技术准备的图像结合使用时，可以用来创建几乎任何你需要的尺寸。
- en: 'In *Figure 15.10*, you can see a shape with nine slices in the bottom-left
    corner, and at the bottom-right corner of the same diagram, you can see the shape
    is stretched but keeps its corners at their original size. The top-right corner
    shows the shape stretched without slices. You can see how the non-sliced version
    is distorted:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图15.10*中，您可以在左下角看到一个有九个切片的形状，在相同图表的右下角，您可以看到形状被拉伸但保持了原始大小的角落。右上角显示了没有切片的形状拉伸。您可以看到非切片版本是如何变形的：
- en: '![](img/B18585_15_10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_10.png)'
- en: 'Figure 15.10: Sliced versus non-sliced image stretching'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15.10**：切片与非切片图像拉伸对比'
- en: 'In this case, we can apply the nine slices to the button and the panel background
    images to use them in different parts of our game. In order to do this, do the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将九个切片应用于按钮和面板背景图像，以便在游戏的各个部分使用它们。为了做到这一点，请按照以下步骤操作：
- en: Open **Package Manager** using the **Window | Package Manager** option.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**窗口 | 包管理器**选项打开**包管理器**。
- en: Verify that **Package Manager** is showing all the packages by setting the dropdown
    to the right of the **+** button in the top-left part of the window to **Unity
    Registry** as usual.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将窗口左上角**+**按钮右侧的下拉菜单设置为**Unity Registry**来验证**包管理器**是否显示所有包。
- en: Install the **2D Sprite** package to enable the sprite editing tools (if it
    is not already installed).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**2D Sprite**包以启用精灵编辑工具（如果尚未安装）。
- en: 'Select the button sprite in the **Project** window and click on the **Sprite
    Editor** button in the **Inspector** window:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择按钮精灵，然后在**检查器**窗口中点击**精灵编辑器**按钮：
- en: '![](img/B18585_15_11.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_11.png)'
- en: 'Figure 15.11: The Sprite Editor button in the Inspector window'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15.11**：检查器窗口中的精灵编辑器按钮'
- en: In the **Sprite Editor** window, locate and drag the green dots at the edges
    of the image to move the slice rulers. Try to ensure that the slices are not located
    in the middle of the edges of the button. One thing to notice is that in our case,
    we will work with three slices instead of nine because our button won’t be stretched
    vertically. If you don’t see the dots, try clicking the image to make them appear.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵编辑器**窗口中，找到并拖动图像边缘的绿色点以移动切片标尺。尽量确保切片不在按钮边缘的中间。要注意的一件事是，在我们的情况下，我们将使用三个切片而不是九个，因为我们的按钮不会垂直拉伸。如果您看不到点，请尝试点击图像使它们出现。
- en: Notice that after dragging the green dots, the **Border** properties (**L**,
    **T**, **R**, and **B**, which are left, top, right, and bottom, respectively)
    in the bottom-right corner changed. Those are the exact values you set by moving
    the green dots. Feel free to change them to more round numbers to allow the 9
    slices to work evenly. In our case, Left and Right became a round 60, and top
    and bottom 50.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在拖动绿色点之后，窗口右下角的**边框**属性（**L**、**T**、**R**和**B**，分别代表左、上、右和下）发生了变化。这些就是您通过移动绿色点设置的精确值。您可以随意将它们更改为更圆的数字，以便9个切片均匀工作。在我们的例子中，左右变成了60的整数，上下变成了50。
- en: 'Click on the **Apply** button in the top-right corner of the window and close
    it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右上角的**应用**按钮并关闭它：
- en: '![](img/B18585_15_12.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_12.png)'
- en: 'Figure 15.12: Nine slices in the Sprite Editor window'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15.12**：精灵编辑器窗口中的九个切片'
- en: Repeat *steps 4* to *6* for the **Background** panel image. In my case, you
    can see in *Figure 15.13* that this background is not completely prepared with
    nine slices in mind because all the middle areas of the image can be made smaller
    to save memory.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复**步骤 4**到**6**以处理**背景**面板图像。在我的情况下，您可以在**图 15.13**中看到，这个背景并不是完全按照九个切片来准备的，因为图像的所有中间区域都可以缩小以节省内存。
- en: 'When displaying this image with a smaller width, the 9-slicing method will
    stretch the middle part and will look the same, so essentially is wasted memory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当以较小的宽度显示此图像时，9切片方法会拉伸中间部分，看起来相同，所以本质上浪费了内存：
- en: '![](img/B18585_15_13.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_13.png)'
- en: 'Figure 15.13: Nine slices in the Sprite Editor window'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15.13**：精灵编辑器窗口中的九个切片'
- en: Now that we have prepared our sprites, we can find a font to customize the text
    of our UI. Before discussing how to import fonts, it is worth mentioning that
    we will be using **TextMesh Pro**, a Unity package (already included in the project)
    that provides a text rendering solution much better than the old text component.
    If you never used that component before, you shouldn’t worry about this detail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的精灵，我们可以找到一个字体来自定义UI的文本。在讨论如何导入字体之前，值得提一下，我们将使用**TextMesh Pro**，这是一个Unity包（已包含在项目中），它提供了一个比旧文本组件更好的文本渲染解决方案。如果您之前从未使用过该组件，您不必担心这个细节。
- en: 'You must get fonts in the `.ttf` or `.otf` formats and import them to Unity.
    You can find lots of good, free font websites on the internet. I am used to working
    with the classic [DaFont.com](https://DaFont.com) site, but there are plenty of
    other sites that you can use. In my case, I will work with the `Militech` font:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须获取`.ttf`或`.otf`格式的字体并将它们导入到Unity中。互联网上有许多优秀的免费字体网站。我习惯于使用经典的[DaFont.com](https://DaFont.com)网站，但还有很多其他你可以使用的网站。在我的情况下，我将使用`Militech`字体：
- en: '![](img/B18585_15_14.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_14.png)'
- en: 'Figure 15.14: My chosen font from DaFont.com to use in the project'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：我在DaFont.com上选择的用于项目的字体
- en: 'If the font download comes with more than one file, you can just drag them
    all into Unity and then use the one that you like the most. Also, as usual, try
    to put the font inside a folder called `Fonts`. Now, these files’ format is not
    compatible with TextMesh Pro, our text rendering solution, so we must convert
    it using the **Font Asset Creator** window, as depicted in the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字体下载包含多个文件，你只需将它们全部拖入Unity，然后使用你最喜欢的一个。同样，通常情况下，尝试将字体放在名为`Fonts`的文件夹中。现在，这些文件的格式与我们的文本渲染解决方案TextMesh
    Pro不兼容，因此我们必须使用**字体资产创建器**窗口进行转换，如下面的步骤所示：
- en: Go to **Window | Text Mesh Pro | Font Asset Creator**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口 | Text Mesh Pro | 字体资产创建器**。
- en: 'If this is the first time you have used Text Mesh Pro in your project, a window
    will appear. You must click the option **Import TMP Essentials** and wait for
    the import process to finish:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是你第一次在项目中使用Text Mesh Pro，会出现一个窗口。你必须点击**导入 TMP 基础组件**选项并等待导入过程完成：
- en: '![](img/B18585_15_15.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_15.png)'
- en: 'Figure 15.15: TextMesh Pro first run initialization'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：TextMesh Pro首次运行初始化
- en: Close the **TMP Importer** window.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**TMP 导入器**窗口。
- en: In **Font Asset Creator**, drag your font from the **Project** view to the **Source
    Font File**, or select it by clicking the **Target** button at the right (the
    circle with the point at the center).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字体资产创建器**中，将你的字体从**项目**视图拖动到**源字体文件**，或者通过点击右侧的**目标**按钮（中心带点的圆形）来选择它。
- en: 'Click the **Generate Font Atlas** button and wait a moment:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成字体图集**按钮并稍等片刻：
- en: '![](img/B18585_15_16.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_16.png)'
- en: 'Figure 15.16: Converting font assets to TextMesh Pro'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16：将字体资产转换为TextMesh Pro
- en: 'Click the **Save** button and save the converted font in the **TextMesh Pro
    | Resources | Fonts & Materials** folder. Saving here is important so don’t forget
    to pick the proper folder:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮，并将转换后的字体保存到**TextMesh Pro | 资源 | 字体与材质**文件夹。在这里保存很重要，所以不要忘记选择正确的文件夹：
- en: '![](img/B18585_15_17.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_17.png)'
- en: 'Figure 15.17: Saving the converted font in the proper folder (Mac)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17：在正确的文件夹中保存转换后的字体（Mac）
- en: Now that we have all the required assets to create our UI, let’s explore the
    different types of components to create all the required UI elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建UI所需的所有资产，让我们探索不同类型的组件以创建所有必要的UI元素。
- en: Creating UI controls
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: 'Almost every single part of the UI will be a combination of images and texts
    configured cleverly. In this section, we will explore how to create images, text,
    and buttons, starting with images. We have already an image in our UI—the white
    rectangle we created previously. If you select it and look at the **Inspector**
    window, you will notice that it has an **Image** component, like the one in the
    following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎UI的每一个部分都将是由图像和文本巧妙配置的组合。在本节中，我们将探索如何创建图像、文本和按钮，从图像开始。我们UI中已经有一个图像——我们之前创建的白色矩形。如果你选择它并查看**检查器**窗口，你会注意到它有一个**Image**组件，如下面的截图所示：
- en: '![](img/B18585_15_18.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_18.png)'
- en: 'Figure 15.18: The Image component’s Inspector window'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18：Image组件的检查器窗口
- en: 'Let’s start exploring the settings of this component, starting with our hero’s
    avatar:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索这个组件的设置开始，首先是我们的英雄头像：
- en: 'Using the rectangle gizmo, move the white rectangle to the top-left part of
    the UI:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形工具，将白色矩形移动到UI的左上角：
- en: '![](img/B18585_15_19.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_19.png)'
- en: 'Figure 15.19: The white rectangle located at the top-left part of the UI'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19：位于UI左上角的白色矩形
- en: 'In the **Inspector** window, click on the circle to the right of the **Source
    Image** property and pick the downloaded hero avatar sprite:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**源图像**属性右侧的圆形，并选择下载的英雄头像精灵：
- en: '![](img/B18585_15_20.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_20.png)'
- en: 'Figure 15.20: Setting the sprite of our Image component'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20：设置我们的Image组件的精灵
- en: 'We need to correct the aspect ratio of the image to prevent distortion. One
    way to do this is to click the **Set Native Size** button at the bottom of the
    **Image** component to make the image use the same size as the original sprite.
    However, by doing this, the image can become too big, so you can reduce the image
    size by pressing *Shift* to modify both the **Width** and **Height** values. Another
    option is to check the **Preserve Aspect** checkbox to make sure the image fits
    the rectangle without stretching. In my case, I will use both:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要纠正图像的宽高比以防止扭曲。一种方法是在**图像**组件底部的**设置原生尺寸**按钮上单击，使图像使用与原始精灵相同的大小。然而，这样做，图像可能会变得太大，因此您可以按*Shift*键修改**宽度**和**高度**值以减小图像大小。另一种选项是勾选**保留宽高比**复选框以确保图像适合矩形而不会拉伸。在我的情况下，我将使用两者：
- en: '![](img/B18585_15_21.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_21.png)'
- en: 'Figure 15.21: The Preserve Aspect and Set Native Size image options'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21：保留宽高比和设置原生尺寸的图像选项
- en: 'Now, let’s create the life bars by doing the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤创建生命条：
- en: Create another **Image** component using the **GameObject** | **UI** | **Image**
    option.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **UI** | **Image**选项创建另一个**图像**组件。
- en: 'Set the **Source Image** property to the life bar image you downloaded:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**源图像**属性设置为下载的生命条图像：
- en: '![](img/B18585_15_22.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_22.png)'
- en: 'Figure 15.22: The avatar and life bar'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22：头像和生命条
- en: Set the **Image Type** property to **Filled**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**图像类型**属性设置为**填充**。
- en: Set the **Fill Method** property to **Horizontal**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**填充方法**属性设置为**水平**。
- en: 'Drag the **Fill Amount** slider to see how the bar is cut according to the
    value of the slider. We will change that value via scripting later in *Chapter
    18*, *Optimization with Profiler, Frame Debugger, and Memory Profiler*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动**填充量**滑块以查看根据滑块值如何切割条形。我们将在第18章*使用Profiler、帧调试器和内存Profiler进行优化*中通过脚本更改该值：
- en: '![](img/B18585_15_23.png)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_23.png)'
- en: 'Figure 15.23: The Fill Amount slider, cutting the image width by 73% of its
    size'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.23：填充量滑块，切割图像宽度为原始大小的73%
- en: 'In my case, the bar image also comes with a bar frame, creating another image,
    setting the sprite, and positioning it on top of the life bar to frame it. Bear
    in mind that the order the objects appear in the **Hierarchy** window determines
    the order in which they will be drawn. So, in my case, I need to be sure the frame
    GameObject is below the health bar image. Also, consider the bar frame image is
    not sliced, so there’s no need to use the **Sliced** **Image** **Type** in this
    case. Feel free to try slicing it and see the results:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的情况下，条形图像还附带了一个条形框架，创建另一个图像，设置精灵，并将其定位在生命条上方以形成框架。请注意，**层次结构**窗口中对象的显示顺序决定了它们将被绘制的顺序。因此，在我的情况下，我需要确保框架GameObject位于健康条图像下方。此外，考虑到条形框架图像未切片，因此在这种情况下不需要使用**切片**
    **图像** **类型**。您可以自由尝试切片并查看结果：
- en: '![](img/B18585_15_24.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_24.png)'
- en: 'Figure 15.24: Putting one image on top of the other to create a frame effect'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.24：将一个图像放在另一个图像上方以创建框架效果
- en: 'Repeat *steps 1* to *6* to create the base bar at the bottom, or just copy
    and paste the bar and the frame and locate it at the bottom of the screen:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*到*6*以创建底部的基线条，或者只需复制并粘贴条和框架，并将其定位在屏幕底部：
- en: '![](img/B18585_15_25.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_25.png)'
- en: 'Figure 15.25: The Player’s and Player’s Base health bars'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.25：玩家和玩家基地的健康条
- en: Click on the **+** button in the **Project** window and select the **Sprites**
    | **Square** option. This will create a simple squared sprite with a 4x4 resolution.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中点击**+**按钮，并选择**精灵** | **正方形**选项。这将创建一个具有4x4分辨率的简单方形精灵。
- en: Set the sprite as the base bar of the Player’s Base health bar instead of the
    downloaded bar sprite. This time, we will be using a plain-white image for the
    bar because in my case, the original one is red, and tinting the color of a red
    image to green is not possible. However, a white image can be easily tinted. Take
    into account the detail of the original bar—for example, the little shadow in
    my original bar won’t be present here.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵设置为玩家基地生命条的基线条，而不是下载的条形精灵。这次，我们将使用纯白色图像作为条形，因为在我的情况下，原始的是红色，将红色图像的颜色调整为绿色是不可能的。然而，白色图像可以很容易地着色。考虑到原始条形的细节——例如，我原始条形中的小阴影在这里将不会出现。
- en: 'Select the base health bar and set the **Color** property to green:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基础生命条，并将**颜色**属性设置为绿色：
- en: '![](img/B18585_15_26.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_26.png)'
- en: 'Figure 15.26: A bar with a squared sprite and green tint'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.26：具有方形精灵和绿色着色的条
- en: One optional step would be to convert the bar frame image into a nine-slices
    image to allow us to change the original width to fit the screen.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可选的步骤是将条形框架图像转换为九分割图像，以便我们可以调整原始宽度以适应屏幕。
- en: 'Now, let’s add the text fields for the **Score**, **Bullets**, **Remaining
    Waves**, and **Remaining Enemies** labels by doing the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下方式添加**得分**、**子弹**、**剩余波浪**和**剩余敌人**标签的文本字段：
- en: Create a text label using the **GameObject** | **UI** | **Text - Text Mesh Pro**
    option (avoid the one that only says **Text**). This will be the **Score** label.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **UI** | **Text - Text Mesh Pro**选项（避免只说**Text**的那个选项）创建一个文本标签。这将作为**得分**标签。
- en: Position the label at the top-right part of the screen.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签放置在屏幕的右上角。
- en: 'In the **Inspector** window, set the **Text Input** property to `Score: 0`.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在**检查器**窗口中，将**文本输入**属性设置为`得分: 0`。'
- en: Set the **Font Size** property to `20`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**字体大小**属性设置为`20`。
- en: Apply the converted font by clicking on the circle to the right of the **Font
    Asset** property and selecting the desired font.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**字体资产**属性右侧的圆圈并选择所需的字体来应用转换后的字体。
- en: 'In the **Alignment** property, select the **Horizontal Right Align** icon (third
    button from the first row) and the **Vertical Center Align** icon (second button
    from the second row):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对齐**属性中，选择第一行的第三个按钮**水平右对齐**图标和第二行的第二个按钮**垂直居中对齐**图标：
- en: '![](img/B18585_15_27.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_27.png)'
- en: 'Figure 15.27: The settings for a text label'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.27：文本标签的设置
- en: 'Repeat *steps 1* to *6* to create the other three labels (or just copy and
    paste the score three times). For the **Remaining Waves** label, you can use the
    left alignment option to better match the original design:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*到*6*以创建其他三个标签（或者只需复制粘贴得分三次）。对于**剩余波浪**标签，您可以使用左对齐选项以更好地匹配原始设计：
- en: '![](img/B18585_15_28.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_28.png)'
- en: 'Figure 15.28: All the labels for our UI'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.28：我们UI的所有标签
- en: Set the color of all the labels to white as our scene will be mainly dark.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标签的颜色设置为白色，因为我们的场景将主要是暗色调。
- en: 'Now that we have completed the original UI design, we can create the **Pause**
    menu:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了原始UI设计，我们可以创建**暂停**菜单：
- en: Create an **Image** component for the menu’s background (**GameObject** | **UI**
    | **Image**).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为菜单的背景创建一个**图像**组件（**GameObject** | **UI** | **Image**）。
- en: Set the **Background** panel sprite with the nine slices we made earlier.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前制作的九分割精灵设置**背景**面板。
- en: Set the **Image Type** property to **Sliced** if it is not already. This mode
    will apply the 9-slice scaling method to prevent the corners from stretching.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置，将**图像类型**属性设置为**分割**。此模式将应用9分割缩放方法，以防止角落拉伸。
- en: 'There’s a chance that the image will stretch the corners anyway, which happens
    because sometimes the corners are quite big compared to the **RectTransform**
    setting’s **Size** property that you are using, so Unity has no option other than
    to do that. In this scenario, the correct solution is to have an artist that creates
    assets tailored to your game, but sometimes we don’t have that option. This time,
    we can just increase the **Pixels Per Unit** value of the sprite file, which will
    reduce the scale of the original image while preserving its resolution. In the
    following two screenshots, you can see the background image with a **Pixels Per
    Unit** value of `100` and again with `700`. Remember to only do this for the nine-slices
    or tiled-image types, or if you don’t have an artist to adjust it for you:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能图像仍然会拉伸角落，这是因为有时角落相对于您使用的**RectTransform**设置的**大小**属性相当大，所以Unity没有其他选择，只能这样做。在这种情况下，正确的解决方案是让一位艺术家创建适合您游戏的资产，但有时我们没有这个选择。这次，我们只需增加精灵文件的**每单位像素**值，这将减小原始图像的缩放，同时保留其分辨率。在下面的两个屏幕截图中，您可以看到具有**每单位像素**值为`100`的背景图像，以及再次设置为`700`的图像。请记住，只为九分割或平铺图像类型这样做，或者如果您没有艺术家来调整它：
- en: '![](img/B18585_15_29.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_29.png)'
- en: 'Figure 15.29: On top, a large nine-slices image in a small RectTransform component,
    small enough to shrink the corners, and on the bottom, the same image with Pixels
    Per Unit set to 700'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.29：顶部是一个大九分割图像，位于一个足够小的RectTransform组件上，足以缩小角落，底部是设置每单位像素为700的相同图像
- en: Create a **TextMesh Pro** text field, position it where you want the **Pause**
    label to be in your diagram, set it to display the **Pause** text, and set the
    font. Remember that you can change the text color with the **Color** property.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**TextMesh Pro**文本字段，将其放置在你想要在图中显示**暂停**标签的位置，设置为显示**暂停**文本，并设置字体。记住，你可以使用**颜色**属性更改文本颜色。
- en: 'Drag the text field onto the background image. The parenting system in **Canvas**
    works the same—if you move the parent, the children will move with it. The idea
    is that if we disable the panel, it will also disable the buttons and all its
    content:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字段拖动到背景图像上。**画布**中的父子系统工作方式相同——如果你移动父对象，子对象也会随之移动。我们的想法是，如果我们禁用面板，它也会禁用按钮及其所有内容：
- en: '![](img/B18585_15_30.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_30.png)'
- en: 'Figure 15.30: The Pause label'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.30：暂停标签
- en: Create two buttons by going to **GameObject** | **UI** | **Button - Text Mesh
    Pro** (avoid using the one that only says **Button**). Position them where you
    want them on the background image.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**游戏对象** | **UI** | **按钮 - 文本网格Pro**（避免使用只说**按钮**的那个）创建两个按钮。将它们放置在背景图像上的你想要的位置。
- en: Set them as children of the **Pause** background image by dragging them in the
    **Hierarchy** window.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**窗口中拖动它们，将它们设置为**暂停**背景图像的子对象。
- en: Select the buttons and set the **Source Image** property of their **Image**
    components to use the button sprite that we downloaded earlier. Remember our **Pixels
    Per Unit** fix from *step 4* in this list if you have the same problem as before.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮，并将它们**图像**组件的**源图像**属性设置为使用我们之前下载的按钮精灵。如果你遇到与之前相同的问题，请记住我们的**每单位像素**修复，即本列表中的*步骤4*。
- en: 'You will notice that the button is essentially an image with a child **TextMesh
    Pro** text object. Change the font of each button and the text in each button
    to `Resume` and `Quit`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到按钮本质上是一个带有子**TextMesh Pro**文本对象的图像。更改每个按钮的字体以及每个按钮中的文本为`Resume`和`Quit`：
- en: '![](img/B18585_15_31.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_31.png)'
- en: 'Figure 15.31: The Pause menu implementation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.31：暂停菜单实现
- en: 'Remember that you can hide the panel by unchecking the checkbox to the right
    of the name of the object in the top part of the **Inspector** window:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，你可以通过取消勾选**检查器**窗口顶部对象名称右侧的复选框来隐藏面板：
- en: '![](img/B18585_15_32.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_32.png)'
- en: 'Figure 15.32: Disabling a GameObject'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.32：禁用GameObject
- en: In this section, we discussed how to import images and fonts to be integrated
    through the **Image**, **Text**, and **Button** components to create a rich and
    informative UI. Having done that, let’s discuss how to make them adapt to different
    devices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何通过**图像**、**文本**和**按钮**组件导入图像和字体，以创建丰富且信息丰富的UI。完成这些后，让我们讨论如何使它们适应不同的设备。
- en: Creating a responsive UI
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建响应式UI
- en: Nowadays, it is almost impossible to design a UI in a single resolution, and
    our target audience display devices can vary a lot. A PC has a variety of different
    kinds of monitors with different resolutions (such as 1080p and 4k) and aspect
    ratios (such as 16:9, 16:10, and ultra-wide), and the same goes for mobile devices.
    We need to prepare our UI to adapt to the most common displays, and Unity UI has
    the tools needed to do so.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎不可能在单个分辨率下设计UI，我们的目标受众显示设备可能差异很大。PC有多种不同类型的显示器，具有不同的分辨率（如1080p和4k）和纵横比（如16:9、16:10和超宽），移动设备也是如此。我们需要准备我们的UI以适应最常见的显示，而Unity
    UI拥有完成这一任务的工具。
- en: 'In this section, we will explore the following UI responsiveness concepts:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下UI响应性概念：
- en: Adapting object positions
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应对象位置
- en: Adapting object sizes
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应对象大小
- en: We are going to explore how the UI elements can adapt their position and size
    to different screen sizes using advanced features of the **Canvas** and **RectTransform**
    components, such as **Anchors** and **Scalers**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用**画布**和**RectTransform**组件的高级功能，如**锚点**和**缩放器**，使UI元素能够适应不同的屏幕尺寸。
- en: Adapting object positions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应对象位置
- en: 'Right now, if we play our game, we will see how the UI fits nicely onto our
    screen. But if for some reason we change the **Game** view size, we will see how
    objects start to disappear from the screen. In the following screenshots, you
    can see different-sized game windows and how the UI looks nice in one but bad
    in the others:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们运行我们的游戏，我们将看到UI如何很好地适应我们的屏幕。但如果出于某种原因我们更改**游戏**视图大小，我们将看到对象如何开始从屏幕上消失。在以下屏幕截图中，你可以看到不同大小的游戏窗口以及UI在一个中看起来很好，而在其他中则不好：
- en: '![](img/B18585_15_33.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_33.png)'
- en: 'Figure 15.33: The same UI but on different screen sizes'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.33：相同的 UI 但在不同屏幕尺寸下
- en: 'The problem is that we created the UI using whatever resolution we had in the
    editor, but as soon as we change it slightly, the UI keeps its design for the
    previous resolution. Also, if you look closely, you will notice that the UI is
    always centered, such as in the second image, where the UI is cropped at its sides,
    or in the third image, where extra space is visible along the borders of the screen.
    This happens because every single element in the UI has its own **Anchor**, a
    little cross you can see when you select an object, such as the one in the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们使用编辑器中拥有的任何分辨率创建了 UI，但一旦我们稍微改变它，UI 就会保留之前分辨率的布局。此外，如果你仔细观察，你会注意到 UI 总是居中的，例如在第二张图片中，UI
    在其边缘被裁剪，或在第三张图片中，屏幕边缘可以看到额外的空间。这是因为 UI 中的每个元素都有自己的 **Anchor**，当你选择一个对象时可以看到一个小十字形，如下面的截图所示：
- en: '![](img/B18585_15_34.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_34.png)'
- en: 'Figure 15.34: An Anchor cross in the bottom-right part of the screen belonging
    to the hero avatar in the top-left part of the screen'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.34：屏幕右下角属于屏幕左上角英雄头像的锚点十字形
- en: The *x* and *y* position of the object is measured as a distance to that Anchor,
    and the Anchor has a position relative to the screen, with its default position
    being at the center of the screen. This means that on an *800 x 600* screen, the
    Anchor will be placed at the *400 x 300* position, and on a *1920 x 1080* screen,
    the Anchor will be located at the *960 x 540* position. If the *x* and *y* position
    of the element (the one in **RectTransform**) is **0**, the object will always
    be at a distance of 0 from the center. In the middle screenshot of the previous
    three examples, the hero avatar falls outside of the screen because its distance
    from the center is greater than half the screen, and the current distance was
    calculated based on the previous bigger screen size. So, what we can do about
    that? Move the Anchor!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的 *x* 和 *y* 位置是以到该锚点的距离来测量的，而锚点相对于屏幕的位置是已知的，其默认位置位于屏幕中心。这意味着在一个 *800 x 600*
    的屏幕上，锚点将被放置在 *400 x 300* 的位置，而在一个 *1920 x 1080* 的屏幕上，锚点将位于 *960 x 540* 的位置。如果元素的
    *x* 和 *y* 位置（在 **RectTransform** 中）为 **0**，则对象将始终与中心保持 0 距离。在前三个示例的中间截图，英雄头像落在了屏幕外，因为其与中心的距离大于屏幕的一半，而当前距离是根据之前更大的屏幕尺寸计算的。那么我们能做什么呢？移动锚点！
- en: By setting a relative position, we can position the Anchor at different parts
    of our screen and make that part of the screen our reference position. In the
    case of our hero avatar, we can place the Anchor in the top-left corner of the
    screen to guarantee that our avatar will be at a fixed distance from that corner.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置相对位置，我们可以将锚点放置在屏幕的不同部分，并使该部分成为我们的参考位置。在我们的英雄头像的情况下，我们可以将锚点放置在屏幕的左上角，以确保我们的头像与该角落保持固定距离。
- en: 'We can do that by following these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤来实现这一点：
- en: Select your player avatar.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的玩家头像。
- en: Expand the **RectTranform** component in the **Inspector**, if not expanded
    yet, in a way that you can see its properties. This will reveal the **Anchors**
    in the **Scene** view.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未展开，请在 **Inspector** 中展开 **RectTranform** 组件，以便可以看到其属性。这将揭示 **Scene** 视图中的
    **Anchors**。
- en: 'Drag the Anchor cross with your mouse to the top-left part of the screen. If
    for some reason the Anchor breaks into pieces when you drag it, undo the change
    (press *Ctrl* + *Z*, or *Command* + *Z* on Mac) and try to drag it by clicking
    in the center. We will break the Anchor later. Check the avatar image **RectTransform**
    component to verify that the **Anchors** property **Min** and **Max** sub-properties
    have the same values as in *Figure 15.35*, meaning the object has correctly configured
    the Anchors to be in the top-left part of the screen:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标将锚点十字形拖动到屏幕的左上角。如果由于某种原因在拖动锚点时它被分成了几块，撤销更改（按 *Ctrl* + *Z*，或在 Mac 上按 *Command*
    + *Z*）然后尝试通过点击中心来拖动它。我们稍后会打破锚点。检查头像图像的 **RectTransform** 组件，以验证 **Anchors** 属性的
    **Min** 和 **Max** 子属性与 *图 15.35* 中的值相同，这意味着对象已正确配置锚点以位于屏幕的左上角：
- en: '![](img/B18585_15_35.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_35.png)'
- en: 'Figure 15.35: An image with an Anchor in the top-left part of the screen'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.35：屏幕左上角带有锚点的图像
- en: Put the Anchor of the **Health Bar** object and its frame in the same position.
    We want the bar to always be at the same distance from that corner so that it
    will move alongside the hero avatar if the screen size changes.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生命条**对象及其框架的锚点放置在同一位置。我们希望条始终与该角落保持相同的距离，这样如果屏幕大小改变，它就会随着英雄头像移动。
- en: Place the Anchor in the bottom-center part of the screen for the **Boss Bar**
    object so that it will always be centered. Later, we will deal with adjusting
    its size.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将锚点放置在屏幕的底部中心，以便**Boss Bar**对象始终居中。稍后，我们将处理调整其大小的问题。
- en: 'Put the **Remaining Waves** label in the bottom-left corner, and **Remaining
    Enemies** in the bottom-right corner:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**剩余波浪**标签放置在左下角，**剩余敌人**放置在右下角：
- en: '![](img/B18585_15_36.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_36.png)'
- en: 'Figure 15.36: The Anchors for the life bar and the labels'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.36：生命条和标签的锚点
- en: 'Put the **Score** and **Bullets** Anchors in the top-right corner:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**得分**和**子弹**锚点放置在右上角：
- en: '![](img/B18585_15_37.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_37.png)'
- en: 'Figure 15.37: The Anchors for the Score and Bullets labels'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.37：得分和子弹标签的锚点
- en: 'Select any element and drag the sides of the Canvas rectangle with your mouse
    to preview how the elements will adapt to their positions. Take into account that
    you must select any object that is a direct child of the Canvas; the text within
    the buttons won’t have that option:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何元素，并用鼠标拖动画布矩形的边缘来预览元素如何适应其位置。请注意，您必须选择任何Canvas的直接子对象；按钮内的文本不会有这个选项：
- en: '![](img/B18585_15_38.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_38.png)'
- en: 'Figure 15.38: Previewing the Canvas resizing'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.38：预览画布大小调整
- en: Now that our UI elements have adapted to their positions, let’s consider scenarios
    where the object size must adapt as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将UI元素调整到它们的位置，让我们考虑需要调整对象大小的场景。
- en: Adapting object sizes
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整对象大小
- en: The first thing to consider when dealing with different aspect ratios is that
    our screen elements may not only move from their original design position (which
    we fixed in the previous section) but also, they may not fit into the original
    design. In our UI, we have the case of the health bar, where the bar clearly doesn’t
    adapt to the screen width when we previewed it on a wider screen. We can fix this
    by breaking our Anchors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理不同的宽高比时，首先要考虑的是，我们的屏幕元素不仅可能从它们原始的设计位置（我们在上一节中固定了它）移动，而且可能无法适应原始设计。在我们的UI中，我们有生命条的情况，当我们在更宽的屏幕上预览它时，条显然不会适应屏幕宽度。我们可以通过打破我们的锚点来解决这个问题。
- en: 'When we break our Anchors, the position and size of our object are calculated
    as a distance relative to the different Anchor parts. If we split the Anchor horizontally,
    instead of having an **X** and **Width** property, we will have a **Left** and
    **Right** property, representing the distance to the left and right Anchor. We
    can use this in the following way:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打破锚点时，我们的对象的位置和大小是相对于不同锚点部分的距离来计算的。如果我们水平分割锚点，我们将不会有一个**X**和**宽度**属性，而将有一个**左**和**右**属性，代表到左右锚点的距离。我们可以用以下方式使用它：
- en: Select the health bar and drag the left part of the Anchor all the way to the
    left part of the screen, and the right part to the right part of the screen.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择生命条，并将锚点全部拖动到屏幕的左侧，并将右侧拖动到屏幕的右侧。
- en: 'Do the same for the health bar frame:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对生命条框架执行相同的操作：
- en: '![](img/B18585_15_39.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_39.png)'
- en: 'Figure 15.39: The splitter Anchor in the health bar'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.39：生命条中的分割锚点
- en: 'Check the **Rect Transform** setting’s **Left** and **Right** properties in
    the **Inspector** window, which represent the current distance to their respective
    Anchors. If you want, you can add a specific value, especially if your health
    bars are displaying outside the screen:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中检查**矩形变换**设置的**左**和**右**属性，它们代表各自锚点的当前距离。如果您想，您可以添加一个特定的值，尤其是如果您的生命条显示在屏幕之外：
- en: '![](img/B18585_15_40.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_40.png)'
- en: 'Figure 15.40: The Left and Right properties of a split anchor'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.40：分割锚点的左和右属性
- en: 'This way, the object will always be at a fixed distance of a relative position
    to the screen—in this case, the sides of the screen. If you are working with a
    child object, as is the case with the **Text** and **Image** components of the
    buttons, the Anchors are relative to the parent. If you pay attention to the Anchors
    of the text, they are not only split horizontally but also vertically. This allows
    the text to adapt its position to the size of the button, so you won’t have to
    change it manually:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对象将始终位于屏幕相对位置的一个固定距离——在这种情况下，屏幕的边缘。如果你正在处理一个子对象，例如按钮的**文本**和**图像**组件，锚点相对于父对象。如果你注意文本的锚点，它们不仅水平分割，还垂直分割。这允许文本根据按钮的大小调整其位置，因此你不需要手动更改它：
- en: '![](img/B18585_15_41.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_41.png)'
- en: 'Figure 15.41: The split Anchors of the text of the button'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.41：按钮文本的分割锚点
- en: Now, this solution is not suitable for all scenarios. Let’s consider a case
    where the hero avatar is displayed in higher resolution than what it was designed
    for. Even if the avatar is correctly placed, it will be displayed smaller because
    the screen has more pixels per inch than screens with lower resolutions and the
    same physical size. You consider using split Anchors, but the width and height
    Anchors could be scaled differently in different aspect ratio screens, so the
    original image becomes distorted. Instead, we can use the **Canvas Scaler** component.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个解决方案并不适用于所有场景。让我们考虑一个英雄头像显示的分辨率高于其设计分辨率的案例。即使头像放置正确，由于屏幕每英寸像素数比低分辨率屏幕多，所以它将显示得更小。你考虑使用分割锚点，但宽度和高度锚点在不同宽高比屏幕上可能以不同的方式缩放，因此原始图像会变形。相反，我们可以使用**画布缩放器**组件。
- en: The **Canvas Scaler** component defines what one pixel means in our scenario.
    If our UI design resolution is 1080p, but we see it in a 4k display (which is
    twice the resolution of 1080p), we can scale the UI so that a pixel becomes 2,
    adapting its size to keep the same proportional size as the original design. Basically,
    the idea is that if the screen is bigger, our elements should also be bigger.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布缩放器**组件定义了在我们的场景中一个像素代表什么。如果我们的UI设计分辨率为1080p，但我们在一个4k显示器上看到它（这是1080p分辨率的两倍），我们可以缩放UI，使一个像素变为2，以适应其大小，保持与原始设计相同的比例大小。基本上，这个想法是，如果屏幕更大，我们的元素也应该更大。'
- en: 'We can use this component by doing the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤使用此组件：
- en: Select the **Canvas** object and locate the **Canvas Scaler** component in the
    **Inspector** window.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**画布**对象，并在**检查器**窗口中定位**画布缩放器**组件。
- en: Set the **UI Scale Mode** property to **Scale with Screen Size**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI缩放模式**属性设置为**按屏幕大小缩放**。
- en: If working with an artist, set the reference resolution to the resolution in
    which the artist created the UI, keeping in mind that it must be the highest target
    device resolution (this isn’t the case for us). In our case, we are not sure which
    resolution the artist of the downloaded assets had in mind, so we can put *1920
    x 1080*, which is the full HD resolution size and is very common nowadays.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果与艺术家合作，将参考分辨率设置为艺术家创建UI的分辨率，同时记住它必须是最高目标设备分辨率（对我们来说不是这种情况）。在我们的案例中，我们不确定下载的资产艺术家心中所想的分辨率是什么，因此我们可以设置为*1920
    x 1080*，这是全高清分辨率大小，并且现在非常常见。
- en: Set the **Match** property to **Height**. The idea of this property is that
    it sets which side of the resolution will be considered when carrying out the
    scaling calculation. In our case, if we are playing the game in 1080p resolution,
    1 UI pixel equals 1 real screen pixel. However, if we are playing in 720p resolution,
    1 UI pixel will be 0.6 real pixels, so the elements will be smaller on smaller
    resolution screens, keeping the correct size. We didn’t choose a **Width** value
    in this case because we can have extreme widths in screens, such as ultra-wide,
    and if we picked that option, those screens would scale the UI unnecessarily.
    Another option is to set this value to `0.5` to consider the two values, but on
    a PC, this doesn’t make too much sense. On a mobile device, you should choose
    this based on the orientation of the game, setting the height for landscape mode
    and the width for portrait mode.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**匹配**属性设置为**高度**。这个属性的想法是，它设置在执行缩放计算时将考虑哪个分辨率的一侧。在我们的例子中，如果我们以1080p分辨率玩游戏，1个UI像素等于1个真实屏幕像素。然而，如果我们以720p分辨率玩游戏，1个UI像素将是0.6个真实像素，因此元素在较小分辨率的屏幕上会变小，保持正确的尺寸。我们没有选择**宽度**值，因为我们可以在屏幕上有极端的宽度，例如超宽屏幕，如果我们选择了那个选项，那些屏幕会不必要地缩放UI。另一个选项是将此值设置为`0.5`以考虑这两个值，但在PC上这没有太多意义。在移动设备上，你应该根据游戏的朝向来选择这个值，为横屏模式设置高度，为竖屏模式设置宽度。
- en: 'Try previewing a wider and higher screen and see how this setting works:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览更宽更高的屏幕，看看这个设置是如何工作的：
- en: '![](img/B18585_15_42.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_42.png)'
- en: 'Figure 15.42: Canvas Scaler with the correct settings for standard PC games'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.42：适用于标准PC游戏的正确设置的画布缩放器
- en: You will find that your UI will be smaller than your original design, which
    is because we should have set these properties before. Right now, the only fix
    is to resize everything again. Take this into account the next time you try this
    exercise; we only followed this order for learning purposes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现你的UI比原始设计要小，这是因为我们应该在之前设置这些属性。目前，唯一的解决办法是再次调整大小。下次尝试这个练习时请考虑这一点；我们只遵循这个顺序是为了学习目的。
- en: With this knowledge, you are now ready to start scripting the UI to reflect
    what’s happening in the game.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，你现在可以开始编写脚本，以反映游戏中的情况。
- en: Scripting the UI
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写UI脚本
- en: 'We previously created a UI layout with elements such as bars, text, and buttons,
    but so far, they are static. We need to make them adapt to the game’s actual state.
    In this section, we are going to discuss the following UI scripting concepts:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个包含条、文本和按钮等元素的UI布局，但到目前为止，它们是静态的。我们需要让它们适应游戏的实际状态。在本节中，我们将讨论以下UI脚本概念：
- en: Showing information in the UI
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: Programming the Pause menu
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程暂停菜单
- en: We will start by seeing how to display information on our UI using scripts that
    modify the text and images that are displayed with Canvas elements. After that,
    we will create the **Pause** functionality, which will be used throughout the
    UI.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何使用脚本在UI上显示信息，这些脚本通过修改Canvas元素显示的文本和图像来实现。之后，我们将创建**暂停**功能，该功能将在整个UI中使用。
- en: Showing information in the UI
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: 'As discussed earlier, we will use the UI to display information to the user
    to allow them to make informed decisions, so let’s start by seeing how we can
    make the player’s health bar react to the amount of life they have left in the
    `Life` script we created earlier:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用UI向用户显示信息，以便他们可以做出明智的决定，所以让我们先看看我们如何使玩家在`Life`脚本中创建的生命条对剩余的生命量做出反应：
- en: 'Add a new script called **Life Bar** to the **HealthBar** Canvas child object,
    which is the UI `Image` component we created earlier to represent the life bar:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为**生命条**的新脚本添加到**HealthBar**画布子对象中，这是我们之前创建的UI `Image`组件，用于表示生命条：
- en: '![](img/B18585_15_43.png)Figure 15.43: The Life Bar component in the player’s
    HealthBar Canvas'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_15_43.png)图15.43：玩家健康条画布中的生命条组件'
- en: 'In the `LifeBar`, the script adds a `Life` type field. This way, our script
    will ask the editor which `Life` component we will be monitoring. Save the script:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LifeBar`中，脚本添加了一个`Life`类型字段。这样，我们的脚本将询问编辑器我们将监控哪个`Life`组件。保存脚本：
- en: '![](img/B18585_15_44.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_44.png)'
- en: 'Figure 15.44: Editor-configurable reference to a Life component'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_15_44.png)图15.44：编辑器可配置的生命组件引用'
- en: 'In the editor, drag the `Player` GameObject from the **Hierarchy** window to
    the `targetLife` property to make the life bar reference the player’s life, and
    remember to have the `HealthBar` object selected before dragging **Player**. This
    way, we are telling our **LifeBar** script which Life component to check to see
    how much life the player has remaining. Something interesting here is that the
    enemies have the same Life component, so we can easily use this component to create
    life bars for every other object that has a life in our game:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从**层次结构**窗口拖动`Player`GameObject到`targetLife`属性，使生命条引用玩家的生命，并记得在拖动**Player**之前选择`HealthBar`对象。这样，我们就告诉了**LifeBar**脚本要检查哪个生命组件以查看玩家剩余的生命。这里有趣的是，敌人也有相同的生命组件，因此我们可以轻松地使用这个组件为游戏中每个有生命的其他对象创建生命条：
- en: '![](img/B18585_15_45.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_45.png)'
- en: 'Figure 15.45: Dragging Player to reference its Life component'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.45：拖动玩家以引用其生命组件
- en: 'Add the `using UnityEngine.UI;` line right after the `using` statements in
    the first few lines of the script. This will tell C# that we will be interacting
    with the UI scripts:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的前几行`using`语句之后添加`using UnityEngine.UI;`行。这将告诉C#我们将与UI脚本进行交互：
- en: '![](img/B18585_15_46.png)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_46.png)'
- en: 'Figure 15.46: All the using statements in our script. We are not going to use
    them all but let’s keep them for now'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.46：我们脚本中的所有`using`语句。我们不会使用它们全部，但现在让我们保留它们
- en: 'Create a `private` field (without the `public` keyword) of the `Image` type.
    We will save the reference to the component here in a moment:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`private`类型的`Image`字段。我们将在稍后在这里保存组件的引用：
- en: '![](img/B18585_15_47.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_47.png)'
- en: 'Figure 15.47: Private reference to an image'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.47：对图像的私有引用
- en: 'Using `GetComponent` in `Awake`, access the reference to the `Image` component
    in our GameObject (`HealthBar`) and save it in the `image` field. As usual, the
    idea is to get this reference just once and save it for later use in the `Update`
    function. Of course, this will always work when you put this component in an object
    with an `Image` component. If not, the other option would be to create a public
    field of the `Image` type and drag the image component into it:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中使用`GetComponent`获取我们GameObject（`HealthBar`）中`Image`组件的引用，并将其保存在`image`字段中。通常的想法是只获取这个引用一次，并在`Update`函数中稍后使用它。当然，当你把这个组件放在一个带有`Image`组件的对象中时，这总是可行的。如果不是这样，另一个选择是创建一个`Image`类型的公共字段，并将图像组件拖放到它里面：
- en: '![](img/B18585_15_48.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_48.png)'
- en: 'Figure 15.48: Saving the reference to the Image component in this object'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.48：在这个对象中保存Image组件的引用
- en: Create an `Update` event function in the `LifeBar` script. We will use this
    to constantly update the life bar according to the player’s life.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LifeBar`脚本中创建一个`Update`事件函数。我们将使用它来根据玩家的生命不断更新生命条。
- en: 'In the `Update` event, divide the amount of life by `100` to have our current
    life percentage expressed in the `0` to `1` range (assuming our maximum life is
    `100`), and set the result in the `fillAmount` field of the `Image` component
    as in the following screenshot. Remember that `fillAmount` expects a value between
    `0` and `1`, with `0` signaling that the bar is empty and `1` signaling that the
    bar is at its full capacity:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`事件中，将生命值除以`100`，以便以`0`到`1`的范围（假设最大生命值为`100`）表示当前生命百分比，并将结果设置在`Image`组件的`fillAmount`字段中，如以下截图所示。记住，`fillAmount`期望一个介于`0`和`1`之间的值，其中`0`表示条形是空的，`1`表示条形已满：
- en: '![](img/B18585_15_49.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_49.png)'
- en: 'Figure 15.49: Updating the fill amount of the LifeBar script’s Image component
    according to the Life component'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.49：根据生命组件更新LifeBar脚本Image组件的填充量
- en: Remember that putting `100` within the code is considered hardcoding (it is
    also known as a **magic number**), meaning later changes on that value would require
    us to look through the code for that value, which is a complicated task in big
    projects. That’s why it is considered bad practice. It would be better to have
    a **Maximum Life** field in the **Life** component or at least have a constant
    with this value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在代码中将`100`放入其中被认为是硬编码（它也被称为**魔法数字**），这意味着对该值的后续更改将需要我们查找代码中的该值，这在大型项目中是一项复杂的任务。这就是为什么被认为是不良做法。更好的做法是在**生命**组件中有一个**最大生命**字段，或者至少有一个具有该值的常量。
- en: 'Save the script and in the editor, select the player and play the game. During
    **Play** mode, press *Esc* to regain access to the mouse and change the player’s
    health in the Inspector window to see how the life bar updates accordingly. You
    can also test this by making the player receive damage somehow, such as by making
    enemies spawn bullets (more on enemies later):'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并在编辑器中选择玩家并开始游戏。在**播放**模式下，按*Esc*键以恢复鼠标访问权限，并在检查器窗口中将玩家的健康值更改以查看生命条如何相应更新。您也可以通过让玩家以某种方式受到伤害来测试此功能，例如，通过让敌人发射子弹（关于敌人的更多内容将在后面介绍）：
- en: '![](img/B18585_15_50.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_50.png)'
- en: 'Figure 15.50: Full LifeBar script'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.50：完整生命条脚本
- en: In the previous chapter, we explored the concept of events to detect changes
    in the state of other objects. The life bar is another example of using an event
    as we can change the fill amount of the image when the life actually changes.
    I challenge you to try to create an event when the life changes and implement
    this script using the one we looked at in the previous chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了事件的概念，用于检测其他对象状态的变化。生命条是使用事件作为另一个例子，因为我们可以在生命实际变化时更改图像的填充量。我挑战你尝试在生命变化时创建一个事件，并使用我们在上一章中查看的脚本实现此脚本。
- en: You may be thinking that this UI behavior could be directly coded within the
    `Life` component, and that’s completely possible, but the idea here is to create
    simple scripts with little pressure to keep our code separated. Each script should
    have just one reason to be modified, and mixing UI behavior and gameplay behavior
    in a single script would give the script two responsibilities, which results in
    two possible reasons to change our script. With this approach, we can also set
    the player’s base life bar at the bottom by just adding the same script to its
    life bar but dragging the **Base Damage** object, which we created in the previous
    chapter, as the target life this time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这种UI行为可以直接在`Life`组件中编码，这是完全可能的，但这里的想法是创建简单的脚本，压力小，以保持我们的代码分离。每个脚本应该只有一个修改的理由，将UI行为和游戏玩法行为混合在单个脚本中会给脚本增加两个责任，从而导致两个可能改变我们脚本的原因。采用这种方法，我们还可以通过将相同的脚本添加到生命条中，但这次将我们在上一章中创建的**基础伤害**对象作为目标生命，来在底部设置玩家的基础生命条。
- en: 'Regarding the Visual Scripting version, here is what you need to add to your
    health bar image GameObject:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，以下是你需要添加到你的健康条图像游戏对象中的内容：
- en: '![](img/B18585_15_51.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_51.png)'
- en: 'Figure 15.51: Full LifeBar Visual Graph'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.51：完整生命条视觉图形
- en: First, we added a `targetLife` variable of type `GameObject` to the **Variables**
    component of our life bar image. Then we dragged our **Player** GameObject (called
    **Robot** so far) to this variable, in a way the life bar now has a reference
    to the object from which we want to display its life. Then we added a **LifeBar**
    visual graph; in the **Update** node, it calls the **Set Fill Amount** node in
    order to update the fill amount of the **Image**. Remember that in this case,
    just calling the **Set Fill Amount** node will understand we are referring to
    the image component where this visual graph is located, so no need to use **GetComponent**
    here. In order to calculate the fill amount, we get the **targetLife** GameObject
    reference, and, using a second **Get Variable** node, we extract the life variable
    of that object. Finally, we divide that by 100 (we needed to create a **Float
    Literal** node in order to represent the value **100**) and pass that to the **Set
    Fill Amount** node. As usual, you can check the complete version on the GitHub
    repository.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在生命条图像的**变量**组件中添加了一个类型为`GameObject`的`targetLife`变量。然后，我们将我们的**Player**游戏对象（到目前为止称为**Robot**）拖动到这个变量上，这样生命条现在就有了我们想要显示其生命的对象的引用。然后我们添加了一个**LifeBar**视觉图形；在**更新**节点中，它调用**设置填充量**节点以更新**图像**的填充量。记住，在这种情况下，仅调用**设置填充量**节点就会理解我们指的是位于此视觉图形中的图像组件，因此在这里不需要使用**GetComponent**。为了计算填充量，我们获取**targetLife**游戏对象引用，并使用第二个**获取变量**节点提取该对象的生命变量。最后，我们将该值除以100（我们需要创建一个**浮点字面量**节点来表示值**100**）并将其传递给**设置填充量**节点。像往常一样，您可以在GitHub仓库中查看完整版本。
- en: The single object responsibility principle we just mentioned is one of the five
    object-oriented programming principles known as **SOLID**. If you don’t know what
    SOLID is, I strongly recommend you search for `SOLID programming principles` on
    the internet to improve your programming best practices.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的单一对象职责原则是被称为 **SOLID** 的五个面向对象编程原则之一。如果您不知道 SOLID 是什么，我强烈建议您在网上搜索 `SOLID
    编程原则` 以提高您的编程最佳实践。
- en: 'Now that we have sorted out the player’s life bar, let’s make the `Bullets`
    label update according to the player’s remaining bullets. Something to consider
    here is that our current `PlayerShooting` script has unlimited bullets, so let’s
    change that by following these steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了玩家的生命条，让我们让 `Bullets` 标签根据玩家的剩余子弹更新。这里需要考虑的是，我们当前的 `PlayerShooting`
    脚本具有无限子弹，所以让我们通过以下步骤来改变这一点：
- en: Add a public `int` type field to the `PlayerShooting` script called `bulletsAmount`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerShooting` 脚本中添加一个名为 `bulletsAmount` 的 `public` `int` 类型字段。
- en: In the `if` statement that checks the pressure of the left mouse button, add
    a condition to check whether the number of bullets is greater than `0`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查左鼠标按钮压力的 `if` 语句中，添加一个条件来检查子弹数量是否大于 `0`。
- en: 'Inside the `if` statement, reduce the number of bullets by `1`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if` 语句中，子弹数量减少 `1`：
- en: '![](img/B18585_15_52.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_52.png)'
- en: 'Figure 15.52: Limiting the number of bullets to shoot'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.52：限制射击的子弹数量
- en: 'In the Visual Scripting version, the modified shooting condition of the **PlayerShooting**
    visual graph will look like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉脚本版本中，**PlayerShooting** 视觉图的修改后的射击条件将如下所示：
- en: '![](img/B18585_15_53.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_15_53.png)'
- en: 'Figure 15.53: Shooting only if bullets are available and reducing the number
    of bullets after shooting'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.53：只有在有子弹可用时射击，并在射击后减少子弹数量
- en: 'As you can see, we simply check if the new **bullets** variable we added is
    greater than zero and then use an **If** node condition for the execution of the
    **Instantiate** node. Regarding the bullets decrement, it will look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只需检查我们添加的新 **bullets** 变量是否大于零，然后使用 **If** 节点条件来执行 **Instantiate** 节点。至于子弹的减少，它将如下所示：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_54.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B18585_15_54.png)'
- en: 'Figure 15.54: Decrementing bullet count in the Visual Graph'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.54：在视觉图形中减少子弹计数
- en: We simply subtract one from the bullets variable and set bullets again with
    this value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需从子弹变量中减去一个值，然后使用这个值重新设置子弹。
- en: 'Now that we have a field indicating the number of remaining bullets, we can
    create a script to display that number in the UI by doing the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个表示剩余子弹数量的字段，我们可以通过以下方式创建一个脚本，在 UI 中显示这个数字：
- en: Add a `PlayerBulletsUI` script to the bullet’s `Text` GameObject. In my case,
    I called it `Bullets Label`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PlayerBulletsUI` 脚本添加到子弹的 `Text` 游戏对象中。在我的例子中，我将其命名为 `Bullets Label`。
- en: Add the `using TMPro;` statement at the beginning of the file, given that we
    will modify the `Text Mesh Pro` component of our label.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头添加 `using TMPro;` 语句，因为我们将会修改标签的 `Text Mesh Pro` 组件。
- en: 'Add a private field of the `TMP_Text` type, saving it in the reference to our
    own `Text` component in `Awake`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Awake` 中添加一个 `private` 字段，类型为 `TMP_Text`，保存我们自己的 `Text` 组件的引用：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18585_15_55.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、电子邮件  自动生成的描述](img/B18585_15_55.png)'
- en: 'Figure 15.55: Caching the reference to our own Text component'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.55：缓存我们自己的 Text 组件的引用
- en: Create a `public` field of the `PlayerShooting` type called `targetShooting`
    and drag `Player` to this property in the Editor. As was the case for the `LifeBar`
    component, the idea is that our UI script will access the script that has the
    remaining bullets to update the text, bridging the two scripts (`Text` and `PlayerShooting`)
    to keep their responsibilities separated.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中将 `PlayerShooting` 类型的 `public` 字段 `targetShooting` 创建出来，并将 `Player` 拖动到这个属性上。与
    `LifeBar` 组件的情况一样，我们的想法是 UI 脚本将访问拥有剩余子弹的脚本以更新文本，将两个脚本（`Text` 和 `PlayerShooting`）连接起来以保持它们职责的分离。
- en: 'Create an `Update` statement and inside it, set the `text` field of the text
    reference (I know, confusing) with a concatenation of `"Bullets: "` and the `bulletsAmount`
    field of the `targetShooting` reference. This way, we will replace the text of
    the label according to the current amount of bullets:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个`Update`语句，并在其中设置文本引用的`text`字段（我知道，有点令人困惑），使用`"Bullets: "`和`targetShooting`引用的`bulletsAmount`字段的连接。这样，我们将根据当前子弹数量替换标签的文本：'
- en: '![A picture containing chart  Description automatically generated](img/B18585_15_56.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片，描述自动生成](img/B18585_15_56.png)'
- en: 'Figure 15.56: Updating the bullet’s text label'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.56：更新子弹的文本标签
- en: 'Remember that concatenating strings allocates memory, so again, I recommend
    you to only do this when necessary, using events. Also consider having two separated
    labels, one for the `"Bullets: "` part, and another for just the number of bullets,
    so you can only change the number label and avoid concatenation and UI text regeneration
    costs.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，字符串连接会分配内存，所以再次建议您只在必要时使用事件来执行此操作。同时考虑使用两个分开的标签，一个用于`"Bullets: "`部分，另一个仅用于子弹数量，这样您就可以只更改数字标签，避免连接和UI文本重生的成本。'
- en: 'Regarding Visual Scripting, before actually setting the text, we need to add
    support for TextMeshPro in Visual Scripting. Visual Scripting requires manually
    specifying which Unity systems and packages we are going to use, and as TextMeshPro
    is not strictly a core Unity feature, so it might not be included by default.
    We can add support for TextMeshPro in Visual Scripting by doing the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本，在实际设置文本之前，我们需要在视觉脚本中添加对TextMeshPro的支持。视觉脚本需要手动指定我们将要使用的Unity系统和包，由于TextMeshPro不是严格意义上的Unity核心功能，因此它可能默认不包含。我们可以通过以下方式在视觉脚本中添加对TextMeshPro的支持：
- en: Go to **Edit | Project Settings** and select the **Visual Scripting** category.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**并选择**视觉脚本**类别。
- en: Expand the **Node Library** option using the arrow to its left.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用左边的箭头展开**节点库**选项。
- en: Check if you have **Unity.TextMeshPro** in that list. If you do, feel free to
    skip these steps.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查列表中是否有**Unity.TextMeshPro**。如果有，您可以自由跳过这些步骤。
- en: Use the **+** button at the bottom of the list to add a new library.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表底部的**+**按钮添加一个新的库。
- en: Click where it says **(No Assembly)** and search for **Unity.TextMeshPro**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示**（无程序集）**的地方，搜索**Unity.TextMeshPro**。
- en: 'Click the **Regenerate Nodes** button and wait until the regeneration process
    is done:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**重新生成节点**按钮，等待生成过程完成：
- en: '![](img/B18585_15_57.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_57.png)'
- en: 'Figure 15.57: Adding TextMeshPro support to Visual Scripting'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.57：向视觉脚本添加TextMeshPro支持
- en: 'After setting that, this is what the visual graph to add to the **Bullets**
    text GameObject will look like:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，添加到**子弹**文本GameObject的视觉图形将如下所示：
- en: '![](img/B18585_15_58.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_15_58.png)'
- en: 'Figure 15.58: Updating the Bullets’ text label in Visual Scripting'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.58：在视觉脚本中更新子弹的文本标签
- en: 'As usual, we need a reference to the **Player** to check its bullets, so we
    created a `targetBullets` variable of type **GameObject** and dragged the player
    there. Then we use a **Get Variable** node to extract the bullets amount from
    that reference and concatenate the string `"Bullets: "`, using the **String Literal**
    node, with the amount of bullets using the **Concat** node. That node will do
    the same as when we added two strings together using the **+** operator in C#.
    Finally, we use the **Set Text (Source Text, Sync Text InputBox)** node to update
    the text of our text field.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '如同往常，我们需要一个**玩家**的引用来检查其子弹，因此我们创建了一个类型为**GameObject**的`targetBullets`变量，并将其拖到那里。然后我们使用**获取变量**节点从该引用中提取子弹数量，并使用**字符串字面量**节点和**连接**节点将字符串`"Bullets:
    "`与子弹数量连接起来。该节点将执行与我们在C#中使用**+**运算符连接两个字符串相同的功能。最后，我们使用**设置文本（源文本，同步文本输入框）**节点来更新文本字段的文本。'
- en: 'If you look at the two scripts, you will find a pattern. You can access the
    `UI` and `Gameplay` components and update the **UI** component accordingly, and
    most UI scripts will behave in the same way. Keeping this in mind, I challenge
    you to create the necessary scripts to make the **Score**, **Enemies**, and **Waves**
    counters work. Remember to add `using TMPro;` to use the `TMP_Text` component.
    After finishing this, you can compare your solution with the one in the following
    screenshot, starting with `ScoreUI`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这两个脚本，您会发现一个模式。您可以访问`UI`和`Gameplay`组件，并相应地更新**UI**组件，大多数UI脚本的行为方式相同。记住这一点，我挑战您创建必要的脚本，使**Score**、**Enemies**和**Waves**计数器工作。请记住添加`using
    TMPro;`以使用`TMP_Text`组件。完成此操作后，您可以比较以下截图中的解决方案，从`ScoreUI`开始：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_15_59.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成描述](img/B18585_15_59.png)'
- en: 'Figure 15.59: The ScoreUI script'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.59：ScoreUI脚本
- en: 'Also, we need the `WavesUI` component:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要`WavesUI`组件：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18585_15_60.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B18585_15_60.png)'
- en: 'Figure 15.60: The WavesUI script'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.60：WavesUI脚本
- en: 'Finally, we need `EnemiesUI`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要`EnemiesUI`：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18585_15_61.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B18585_15_61.png)'
- en: 'Figure 15.61: The EnemiesUI script'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.61：EnemiesUI脚本
- en: Notice how we took advantage of the existence of the **onChanged** events in
    the **WavesManager** and **EnemyManager** scripts to only update the text fields
    when needed. Observe how we didn’t need to drag a reference to get the values
    to display, as all these scripts use managers to get that info.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何利用**WavesManager**和**EnemyManager**脚本中存在的**onChanged**事件，仅在需要时更新文本字段。观察我们如何不需要拖动引用来获取要显示的值，因为这些脚本都使用管理器来获取这些信息。
- en: 'Regarding Visual Scripting, we have the **ScoreUI** script:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本，我们有**ScoreUI**脚本：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_62.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，自动生成描述](img/B18585_15_62.png)'
- en: 'Figure 15.62: The ScoreUI visual script'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.62：ScoreUI视觉脚本
- en: 'Then the **WavesUI** script:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是**WavesUI**脚本：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_15_63.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B18585_15_63.png)'
- en: 'Figure 15.63: The Waves UI visual script'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.63：Waves UI视觉脚本
- en: 'And finally, the **EnemiesUI** script:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是**EnemiesUI**脚本：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_15_64.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B18585_15_64.png)'
- en: 'Figure 15.64: The Enemies UI visual script'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.64：Enemies UI视觉脚本
- en: As you can see, we have used the events already coded in the managers to change
    the UI only when necessary. Also, observe how we used **Scene** variables to get
    the info to display. Now that we have coded the UI labels and bars, let’s code
    the `Pause` menu.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已使用管理器中已编写的事件，仅在必要时更改UI。此外，注意我们如何使用**Scene**变量来获取要显示的信息。现在我们已经编写了UI标签和条，让我们编写`Pause`菜单。
- en: Programming the Pause menu
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程暂停菜单
- en: 'Recall how we created a **Pause** menu in a previous section. It is currently
    disabled, so let’s make it work. First, we need to code the **Pause** feature,
    which can be quite complicated. So again, we will use a simple approach for pausing
    most behaviors, which is stopping the time! Remember that most of our movement
    scripts use time functionality, such as **Delta Time** (the one we discussed in
    *Chapter 2*, *Editing Scenes and Game Objects*), as a way to calculate the amount
    of movement to apply. There is also a way to simulate time going slower or faster,
    which is by setting `timeScale`. This field will affect Unity’s time system’s
    speed, and we can set it to `0` to simulate that time has stopped, which will
    pause animations, stop particles, and reduce **Delta Time** to `0`, making our
    movements stop. So, let’s do it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们如何在之前的章节中创建了一个**暂停**菜单。它目前是禁用的，所以让我们让它工作。首先，我们需要编写**暂停**功能，这可能相当复杂。所以，我们再次将使用一个简单的方法来暂停大多数行为，即停止时间！记住，我们的大多数移动脚本都使用时间功能，如**Delta
    Time**（我们在*第2章*，*编辑场景和游戏对象*中讨论过的），作为计算要应用的运动量的方式。还有一种方法可以模拟时间变慢或变快，即通过设置`timeScale`。这个字段将影响Unity的时间系统速度，我们可以将其设置为`0`来模拟时间已停止，这将暂停动画，停止粒子，并将**Delta
    Time**减少到`0`，使我们的运动停止。所以，让我们这样做：
- en: Create a script called `Pause` and add it to a new GameObject called `Pause`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pause`的脚本并将其添加到一个名为`Pause`的新GameObject中。
- en: Add the `using UnityEngine.InputSystem;` statement at the beginning of the script
    file to be able to read input.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本文件开头添加`using UnityEngine.InputSystem;`语句，以便能够读取输入。
- en: 'In `Update`, detect when the *Esc* key is pressed. We can add a mapping to
    our **Player Input** asset file and read the input as we did in *Chapter 2*, *Editing
    Scenes and Game Objects*, but to learn a new way of using the input system, we
    will use the `Keyboard.current` variable to read directly the state of a key in
    the **Update** method instead of using mapping. Consider that it is always recommended
    to use input mapping, but let’s do this for learning purposes. You can set the
    `Time.timeScale` variable to `0` when the *Esc* key is pressed, as you can see
    in the following image:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中检测是否按下了*Esc*键。我们可以将映射添加到我们的**玩家输入**资产文件中，并像在*第2章*，*编辑场景和游戏对象*中做的那样读取输入，但为了学习使用输入系统的新方法，我们将使用`Keyboard.current`变量直接在**Update**方法中读取键的状态，而不是使用映射。请注意，始终推荐使用输入映射，但为了学习目的，我们这样做。当按下*Esc*键时，可以将`Time.timeScale`变量设置为`0`，如下图中所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18585_15_65.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18585_15_65.png)'
- en: 'Figure 15.65: Stopping time to simulate a pause'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.65：停止时间以模拟暂停
- en: 'Save and test this by playing the game and pressing the *Esc* key. You will
    notice that almost everything will stop, but you can see how the shoot functionality
    still works. That’s because the `PlayerShooting` script is not time-dependent.
    One solution here could be to simply check whether `Time.timeScale` is greater
    than `0` to prevent this:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过玩游戏并按下*Esc*键来保存并测试此脚本。你会注意到几乎一切都会停止，但你仍然可以看到射击功能仍然在正常工作。这是因为`PlayerShooting`脚本不依赖于时间。这里的一个解决方案是简单地检查`Time.timeScale`是否大于`0`以防止这种情况：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_15_66.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18585_15_66.png)'
- en: 'Figure 15.66: Checking Pause in the player shooting script'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.66：检查玩家射击脚本中的暂停
- en: 'The same needs to be done in our `EnemyFSM` Shoot method, changing it for this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`EnemyFSM`射击方法中也需要做同样的操作，将其改为以下内容：
- en: As usual, we have pursued the simplest way here, but there is a better approach.
    I challenge you to try to create `PauseManager` with a Boolean indicating whether
    the game is paused or not, changing `timeScale` in the process.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们在这里追求最简单的方法，但有一个更好的方法。我挑战你尝试创建一个带有布尔值的`PauseManager`，该布尔值指示游戏是否已暂停，并在过程中更改`timeScale`。
- en: 'Now that we have a simple but effective way to pause the game, let’s make the
    **Pause** menu visible to resume the game by doing the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个简单但有效的方法来暂停游戏，让我们通过以下步骤使**暂停**菜单可见以恢复游戏：
- en: Add a field of the `GameObject` type called `pauseMenu` in the `Pause` script.
    The idea is to drag the **Pause** menu here so that we have a reference to enable
    and disable it
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pause`脚本中添加一个名为`pauseMenu`的`GameObject`类型的字段。想法是将**暂停**菜单拖到这里，以便我们有一个引用来启用和禁用它
- en: In `Awake`, add `pauseMenu.SetActive(false);` to disable the **Pause** menu
    at the beginning of the game. Even if we disabled the **Pause** menu in the editor,
    we add this just in case we re-enable it by mistake. It must always start disabled.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`状态下，添加`pauseMenu.SetActive(false);`以在游戏开始时禁用**Pause**菜单。即使我们在编辑器中禁用了**Pause**菜单，我们也添加这个代码以防我们不小心重新启用它。它必须始终处于禁用状态。
- en: 'Using the same function but passing `true` as the first parameter, enable the
    **Pause** menu in the *Esc* key pressure check:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的函数，但将`true`作为第一个参数传递，在*Esc*键压力检查中启用**Pause**菜单：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_67.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，描述自动生成](img/B18585_15_67.png)'
- en: 'Figure 15.67: Enabling the Pause menu when pressing the Esc key'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.67：按下Esc键时启用暂停菜单
- en: 'Now, we need to make the **Pause** menu buttons work. If you recall, we explored
    the concept of events, implementing them with `UnityEvents` in the different `Managers`.
    Our **Pause** menu buttons use the same class to implement the `onClick` event,
    which is an event that informs us that a specific button has been pressed. Let’s
    resume the game when pressing those buttons by doing the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使**Pause**菜单按钮正常工作。如果您还记得，我们探讨了事件的概念，通过在不同的`Managers`中使用`UnityEvents`来实现。我们的**Pause**菜单按钮使用相同的类来实现`onClick`事件，这是一个通知我们特定按钮已被按下的事件。让我们通过按下这些按钮来恢复游戏，操作如下：
- en: Create a field of the `Button` type in our `Pause` script called `resumeButton`,
    and drag `resumeButton` to it; this way, our `Pause` script has a reference to
    the button.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**Pause**脚本中创建一个名为`resumeButton`的`Button`类型字段，并将`resumeButton`拖放到其中；这样，我们的**Pause**脚本就有一个对按钮的引用。
- en: In `Awake`, add a listener function called `OnResumePressed` to the `onClick`
    event of `resumeButton`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`状态下，将名为`OnResumePressed`的监听函数添加到`resumeButton`的`onClick`事件中。
- en: 'Make the `OnResumePressed` function set `timeScale` to `1` and disable the
    **Pause** menu, as we did in `Awake`:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`OnResumePressed`函数将`timeScale`设置为`1`并禁用**Pause**菜单，就像我们在`Awake`中做的那样：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_68.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，描述自动生成](img/B18585_15_68.png)'
- en: 'Figure 15.68: Unpausing the game'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.68：取消暂停游戏
- en: 'If you save and test this, you will notice that you cannot click the **Resume**
    button because we disabled the cursor at the beginning of the game, so make sure
    you re-enable it while in `Pause` and disable it when you resume:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存并测试这段代码，你会注意到你不能点击**Resume**按钮，因为我们已经在游戏开始时禁用了光标，所以请确保你在`Pause`状态下重新启用它，并在恢复时禁用它：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_15_69.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，描述自动生成](img/B18585_15_69.png)'
- en: 'Figure 15.69: Showing and hiding the cursor while in Pause'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.69：在暂停时显示和隐藏光标
- en: 'One final thing to consider is that we want to set the time scale to `1` again
    on the **OnDestroy** method. This method gets executed when the **Pause** object
    is destroyed, which will happen when we manually destroy the object via scripting,
    or most importantly in this case, if we change scenes. The idea is to make sure
    to resume the time system if we change scenes while being in the **Pause** menu,
    so the next scene can play the game properly:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的一点是我们希望在**OnDestroy**方法中将时间比例重新设置为`1`。当**Pause**对象被销毁时，这个方法会被执行，这通常发生在我们通过脚本手动销毁对象时，或者在这个案例中，最重要的是当我们更改场景时。我们的想法是确保在**Pause**菜单中更改场景时恢复时间系统，这样下一个场景可以正确地播放游戏：
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B18585_15_70.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成，中等置信度](img/B18585_15_70.png)'
- en: 'Figure 15.70: Resetting the time scale when leaving the scene'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.70：离开场景时重置时间比例
- en: 'Regarding the Visual Scripting version of the **Pause** script, consider that
    we don’t have an equivalent to `Keyboard.current`, so we will need to do it using
    the input mappings. In order to add an input mapping for the *Esc* key, do the
    following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**Pause**脚本的Visual Scripting版本，请注意我们没有`Keyboard.current`的等价物，所以我们需要使用输入映射来实现。为了为*Esc*键添加输入映射，请执行以下操作：
- en: Double-click the **Player Input** asset to edit it. You can find it by selecting
    the **Player** GameObject, and clicking the box at the right of the **Actions**
    property of the `PlayerInput` component in the Inspector.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Player Input**资产进行编辑。您可以通过选择**Player**GameObject，然后点击检查器中`PlayerInput`组件的**Actions**属性右侧的框来找到它。
- en: 'Using the **+** button in the top-right corner of the **Actions** list (the
    middle list), create a new **Action** called `Pause`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**动作**列表（中间列表）右上角的**+**按钮创建一个新的**动作**，命名为`暂停`：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18585_15_71.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, application, table  Description automatically generated](img/B18585_15_71.png)'
- en: 'Figure 15.71: Creating a new input mapping'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.71：创建新的输入映射
- en: Click the `<No Binding>` item inside the **Pause** action we just created (below
    it).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚创建的**暂停**动作中的**<无绑定>**项（在其下方）。
- en: 'In the **Path** property in the **Binding Properties** section (at the right
    side of the screen), click the empty rectangle at its left, and search and select
    the **Escape [Keyboard]** button:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**绑定属性**部分的**路径**属性（屏幕右侧），点击其左侧的空矩形，并搜索并选择**Escape [键盘]**按钮：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_15_72.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, application  Description automatically generated](img/B18585_15_72.png)'
- en: 'Figure 15.72: Adding a key to the mapping'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.72：将键添加到映射
- en: Click the **Save Asset** button in the top-middle part of the screen.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕顶部中间的**保存资产**按钮。
- en: 'Now, you can add the following graph, this time to the **Player** GameObject,
    as we need to read input from it:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以添加以下图，这次是添加到**玩家**GameObject中，因为我们需要从它读取输入：
- en: '![](img/B18585_15_73.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18585_15_73.png]'
- en: 'Figure 15.73: Pausing when Esc is pressed'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.73：按下Esc键时暂停
- en: So far nothing new; we detect that *Esc* is pressed and, in such a moment, we
    call **Set Time Scale** and specify the `0` value. Then we activate the **Pause**
    menu (having a reference through a variable `pauseMenu` in the **Variables** component),
    and we enable the cursor. Finally, we set the time scale to `1` when the object
    is destroyed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有什么新东西；我们检测到按下了*Esc*键，在这样的时刻，我们调用**设置时间缩放**并指定`0`值。然后我们激活**暂停**菜单（通过**变量**组件中的变量`pauseMenu`引用），并启用光标。最后，当对象被销毁时，我们将时间缩放设置为`1`。
- en: 'Regarding the **Resume** behavior, the nodes to add to the same **Pause** graph
    will look like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**继续**的行为，需要添加到相同**暂停**图中的节点将看起来像这样：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18585_15_74.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text, application  Description automatically generated](img/B18585_15_74.png)'
- en: 'Figure 15.74: Unpausing when the Resume button is pressed'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.74：按下继续按钮时取消暂停
- en: The only new element on this graph is the usage of the **On Button Click** node.
    As you might expect, that node is an event, and anything connected to it will
    execute under the pressure of a button. The way to specify which button we are
    referring to is through connecting the **Button** reference variable to the input
    pin of **On Button Click**. You can see how we created a variable of type **Button**
    called `resumeButton` in the **Variables** component to do this.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的唯一新元素是**On Button Click**节点的使用。正如你所期望的，该节点是一个事件，任何连接到它的内容都会在按钮按下时执行。指定我们指的是哪个按钮的方法是通过将**Button**引用变量连接到**On
    Button Click**的输入引脚。你可以在**变量**组件中看到我们如何创建了一个名为`resumeButton`的**Button**类型的变量来完成这个操作。
- en: Now that you know how to code buttons, I challenge you to code the `Exit` button’s
    behavior. Again, remember to add `using UnityEngine.UI`. Also, you will need to
    call `Application.Quit();` to exit the game but take into account that this will
    do nothing in the editor; we don’t want to close the editor while creating the
    game. This function only works when you build the game.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写按钮的代码，我挑战你编写`退出`按钮的行为。再次提醒，记得添加`using UnityEngine.UI`。此外，你需要调用`Application.Quit();`来退出游戏，但请注意，在编辑器中这不会起作用；我们不想在创建游戏时关闭编辑器。这个函数只有在构建游戏时才会生效。
- en: 'So, for now, just call it, and if you want to print a message to be sure that
    the button is working properly, you can; a solution is provided in the following
    screenshot:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在只需调用它即可，如果你想打印一条消息以确保按钮正常工作，你可以这样做；以下截图提供了一个解决方案：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_75.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18585_15_75.png)'
- en: 'Figure 15.75: The Quit button script'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.75：退出按钮脚本
- en: This solution proposes that you add this script directly to the **Quit** button
    GameObject itself so that the script listens to the `onClick` event on its `Button`
    sibling component, and in that case, executes the `Quit` function. You could also
    add this behavior to the `Pause` script, and while that will work, remember that
    if a script can be split into two because it does two unrelated tasks, it is always
    best to split it so that separate behavior is unrelated. Here, the **Pause** behavior
    is not related to the **Quit** behavior.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本解决方案建议您将此脚本直接添加到**退出**按钮的GameObject本身，以便脚本监听其`Button`兄弟组件上的`onClick`事件，并在那种情况下执行`Quit`函数。您也可以将此行为添加到`Pause`脚本中，虽然这样也可以工作，但请记住，如果一个脚本可以分成两个，因为它执行两个不相关的任务，那么最好将其拆分，以便分离的行为不相关。在这里，**暂停**行为与**退出**行为不相关。
- en: 'Regarding the Visual Scripting version, the graph to add to the **Quit** button
    would look like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，要添加到**退出**按钮的图看起来像这样：
- en: '![Graphical user interface, application  Description automatically generated](img/B18585_15_76.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18585_15_76.png)'
- en: 'Figure 15.76: The Quit button visual script'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.76：退出按钮的视觉脚本
- en: Simple, right? As we put this in the `Button` itself, we don’t even need to
    specify which button, as it automatically detects that we are referring to ourselves.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？因为我们将其放入`Button`本身，所以我们甚至不需要指定哪个按钮，因为它会自动检测我们是在指自己。
- en: Now that we have our **Pause** system set up using the UI and buttons, let’s
    continue looking at other visual and auditive ways to make our player aware of
    what has happened.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用UI和按钮设置了**暂停**系统，让我们继续探讨其他视觉和听觉方式，让玩家意识到发生了什么。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basics of UI, understanding the **Canvas**
    and **RectTransform** components to locate objects onscreen and create a UI layout.
    We also covered different kinds of UI elements, mainly **Image** and **Text**,
    to give life to our UI layout and make it appealing to the user. Finally, we discussed
    how to adapt UI objects to different resolutions and aspect ratios to make our
    UI adapt to different screen sizes, even though we cannot predict the exact monitor
    our user will be playing the game on. All of this allows us to create any UI we
    will need in our game using the Canvas.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了UI的基础知识，理解**Canvas**和**RectTransform**组件以在屏幕上定位对象并创建UI布局。我们还介绍了不同类型的UI元素，主要是**图像**和**文本**，以使我们的UI布局生动，并吸引用户。最后，我们讨论了如何调整UI对象以适应不同的分辨率和宽高比，使我们的UI能够适应不同的屏幕尺寸，尽管我们无法预测用户将使用的确切显示器。所有这些使我们能够使用Canvas创建我们游戏中需要的任何UI。
- en: In the next chapter, we will explore how to create UIs using UI Toolkit instead,
    another Unity system to create UIs, and compare both the Canvas and UI Toolkit
    to see where to use which.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用UI Toolkit来创建UI，这是Unity系统中另一种创建UI的方法，并将Canvas和UI Toolkit进行比较，以确定在何处使用哪种。
- en: Join us on Discord!
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Unity game development experts, and the
    author himself.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家和作者本人一起阅读此书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过Ask Me Anything（问我任何问题）环节与作者聊天，等等。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接以加入社区。
- en: '![](img/Nicolas_QR_Code.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Nicolas_QR_Code.png)'
- en: '[https://packt.link/handsonunity22](Chapter_15.xhtml)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/handsonunity22](Chapter_15.xhtml)'
