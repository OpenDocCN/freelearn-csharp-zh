- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Catching Exceptions with Exception Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常处理捕获异常
- en: We always try to make our code as stable as possible when building web applications,
    but there are times when we can’t catch everything. This is why exceptions are
    considered a foundational part of development. Exception handling is essential
    for preventing web applications from crashing and displaying an ugly error message
    on a page. It’s tempting to wrap everything with `try`/`catch` or `try`/`finally`
    statements and move on. This should be avoided. Coding with `try`/`catch`/`finally`
    statements in an application should be the exception to the rule.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网络应用程序时，我们总是尽力使我们的代码尽可能稳定，但有时我们无法捕获所有内容。这就是为什么异常被认为是开发的基础部分。异常处理对于防止网络应用程序崩溃并在页面上显示丑陋的错误消息至关重要。用
    `try`/`catch` 或 `try`/`finally` 语句包裹一切是很诱人的。但这应该避免。在应用程序中使用 `try`/`catch`/`finally`
    语句应该是例外。
- en: The common coding standards in this chapter are meant to remove those types
    of scenarios and provide a better developer experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的常见编码标准旨在消除这些类型的场景，并提供更好的开发者体验。
- en: In this chapter, we’ll examine what exception handling means to developers and
    when to use it, along with where to handle global exceptions and examine performance
    considerations. Once we understand the basics of exception handling, the last
    section will cover some common practices of exception handling, such as applying
    the “prevention before exception” principle to code, using logging, learning how
    exception handling is similar to unit tests, and why empty catch blocks should
    be avoided.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨异常处理对开发者的意义，何时使用它，以及在哪里处理全局异常，并检查性能考虑。一旦我们理解了异常处理的基础知识，最后一节将涵盖一些常见的异常处理实践，例如将“预防胜于异常”原则应用于代码，使用日志记录，了解异常处理与单元测试的相似之处，以及为什么应该避免空的
    `catch` 块。
- en: Finally, we’ll learn how to use .NET’s new exception filter, along with pattern
    matching, when to use `finally` blocks, and why it’s a good idea to rethrow exceptions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何使用 .NET 的新异常过滤器，结合模式匹配，何时使用 `finally` 块，以及为什么重新抛出异常是个好主意。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using exception handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常处理
- en: Handling global exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理全局异常
- en: Performance considerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Common exception handling techniques
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的异常处理技术
- en: After completing this chapter, you’ll understand exception handling better,
    when and how to use it, how to implement global exception handling, and how to
    know if performance is a problem when using exception handling.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将更好地理解异常处理，何时以及如何使用它，如何实现全局异常处理，以及在使用异常处理时如何知道性能是否成为问题。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We recommend using a favorite editor to add the exception handling code snippets
    throughout this chapter. Our recommendations are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用您喜欢的编辑器，在本章中添加异常处理代码片段。我们的建议如下：
- en: Visual Studio (preferably the latest version)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（最好是最新版本）
- en: Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: JetBrains Rider
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的编辑器是 Visual Studio 2022 Enterprise，但任何版本（社区版或专业版）都可以与代码一起使用。
- en: Using exception handling
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常处理
- en: In this section, we’ll discuss what exception handling is, the two types of
    error handling, when to use error handling in an application, and how exceptions
    affect performance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论什么是异常处理，两种错误处理类型，何时在应用程序中使用错误处理，以及异常如何影响性能。
- en: What is exception handling?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是异常处理？
- en: Exception handling is the ability to recover gracefully from unexpected situations
    in the code during runtime; how do we handle errors or problems we experience
    in applications? It also involves cleaning up allocated resources when issues
    occur to avoid memory leaks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是在代码运行时从意外情况中优雅恢复的能力；我们如何处理在应用程序中遇到的问题或错误？它还涉及在出现问题时清理分配的资源，以避免内存泄漏。
- en: 'There are two types of errors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的错误：
- en: '**Runtime errors**: These are unexpected errors we experience when running
    the application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时错误**：这些是我们运行应用程序时遇到的意外错误。'
- en: '`ArgumentNullException.ThrowIfNull()` at the beginning of a method to confirm
    whether a parameter is null or not).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法开头使用 `ArgumentNullException.ThrowIfNull()` 来确认参数是否为 null。
- en: Since this book focuses on intermediate to advanced developers, we’re assuming
    debugging an ASP.NET application is a common process; we all know debugging and
    exception handling go hand-in-hand. Developers should have a general understanding
    of what the code in question does when they wrap it with a `try`/`catch` block.
    The ability to create useful exceptions is extremely important. Exceptions should
    be clear and simple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书主要面向中级到高级的开发者，我们假设调试ASP.NET应用程序是一个常见的流程；我们都知道调试和异常处理是相辅相成的。当开发者用`try`/`catch`块包裹代码时，他们应该对这段代码的功能有一个大致的了解。创建有用的异常的能力非常重要。异常应该是清晰和简单的。
- en: For example, early in my career, a developer was experiencing an error message
    telling them they were running out of disk space. Other developers were experiencing
    the same error in the application as well and were frantically trying to figure
    out the problem. The issue turned out to be a bad error message created by a developer
    along with a *server* running out of disk space, not individual developer machines.
    This could’ve been avoided by creating better log messages or detecting whether
    there was disk space available. While we can write better error messages in the
    exception handlers, we can only protect the code from so much.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我职业生涯的早期，一位开发者遇到了一条错误信息，告诉他们他们的磁盘空间即将耗尽。其他开发者也在应用程序中遇到了相同的错误，并疯狂地试图找出问题。问题最终被证明是由一位开发者创建的一个糟糕的错误信息，以及一个磁盘空间耗尽的*服务器*，而不是个别开发者的机器。这可以通过创建更好的日志消息或检测是否有可用磁盘空间来避免。虽然我们可以在异常处理程序中编写更好的错误信息，但我们只能保护代码到一定程度。
- en: Seriously, though – the ability to create a simple and clear error message can
    be a challenge while coding, but it does make a difference in the long run. We’ll
    cover some of the common exception handling techniques in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的——在编码时创建简单明了的错误信息可能是一个挑战，但从长远来看，这确实会带来影响。我们将在下一节中介绍一些常见的异常处理技术。
- en: When to use exception handling
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用异常处理
- en: The ability to identify whether or not code requires an exception handler can
    be tricky. In addition to whether a `try`/`catch`/`finally` block is required,
    are there resources involved that we need to clean up?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 识别代码是否需要异常处理的能力可能很棘手。除了是否需要`try`/`catch`/`finally`块之外，是否涉及我们需要清理的资源？
- en: 'Context is important when it comes to exception handling. In my experience,
    I always ask three questions before adding exception handling:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理方面，上下文很重要。根据我的经验，在添加异常处理之前，我总是要问自己三个问题：
- en: '`TryParse` instead of a full `try`/`catch`/`finally` block or having to manually
    throw an error because of an invalid parameter.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TryParse`而不是完整的`try`/`catch`/`finally`块，或者由于无效参数而手动抛出错误。
- en: '**Will an external resource throw exceptions?** Examples include web APIs,
    storage issues, file missing, and so on.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外部资源是否会抛出异常？** 例如，Web API、存储问题、文件丢失等。'
- en: '**Do I have to clean up after myself if an error occurs?** Examples include
    losing a file connection, loading a bitmap, or a database connection.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果发生错误，我必须自己清理吗？** 例如，丢失文件连接、加载位图或数据库连接。'
- en: Developers should only use exception handling when they encounter a line of
    code that they cannot handle and is considered outside of their control, similar
    to the possibility of not enough disk drive space.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者只有在遇到他们无法处理且被认为是超出他们控制范围的代码行时才应使用异常处理，类似于磁盘驱动器空间不足的可能性。
- en: In this section, we reviewed what exception handling was and when to use it
    properly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了异常处理是什么以及何时正确使用它。
- en: Handling global exceptions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理全局异常
- en: As mentioned earlier in this chapter, we can only handle so many errors when
    it comes to web applications. But what if we want to provide a catch-all for all
    unhandled exceptions?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，当我们谈到Web应用程序时，我们只能处理这么多错误。但如果我们想为所有未处理的异常提供一个通用的解决方案呢？
- en: 'For global exceptions, we need to revisit the middleware. There is a method
    called `UseExceptionHandler()` in the `Startup.cs` file that points to a `/Error`
    page (either Razor or MVC), as shown in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局异常，我们需要重新审视中间件。在`Startup.cs`文件中有一个名为`UseExceptionHandler()`的方法，它指向一个`/Error`页面（无论是Razor还是MVC），如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pay particular attention to the `env.IsDevelopment()` condition. *The* `/Error`
    *page is meant for non-development viewing only*. As we mentioned back in [*Chapter
    4*](B19493_04.xhtml#_idTextAnchor086) regarding security, always be careful what
    to show on this page. It may expose system data such as a database connection
    string that contains credentials or other sensitive data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意 `env.IsDevelopment()` 条件。*错误页*仅用于非开发环境查看。正如我们在[*第4章*](B19493_04.xhtml#_idTextAnchor086)中提到的关于安全性的内容，始终要小心在这个页面上显示什么。它可能会暴露系统数据，例如包含凭证或其他敏感数据的数据库连接字符串。
- en: 'To access the exception through the error page, we require the `IExceptionHandlerPathFeature`
    instance through `HttpContext.Features`. This can be seen in the following `OnGet()`
    method on the `/``Error` page:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过错误页访问异常，我们需要通过 `HttpContext.Features` 获取 `IExceptionHandlerPathFeature` 实例。这可以在以下
    `/Error` 页面的 `OnGet()` 方法中看到：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`HttpContext.Features` gives us access to the error. From there, we need to
    determine what to display on the page. In this case, we can see that the main
    page contains the error. Once we have identified the issue, we can create a public
    message, and log the error, and store it in `ErrorMessage` so that the main page
    can display it.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext.Features` 给我们提供了访问错误的权限。从那里，我们需要确定要在页面上显示什么。在这种情况下，我们可以看到主页面包含了错误。一旦我们确定了问题，我们可以创建一个公共消息，记录错误，并将其存储在
    `ErrorMessage` 中，以便主页面可以显示它。'
- en: 'While this is a simplistic example, alternatively, we can use our middleware
    to catch global errors as well. Instead of passing in a page location, we can
    use a Lambda for our exception handling in the middleware, as shown in the following
    code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但我们可以使用我们的中间件来捕获全局错误。我们不需要传递页面位置，可以在中间件中使用 Lambda 来处理异常，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We retrieve the `ExceptionHandlerPathFeature` instance the same way as we did
    on the `/Error` page. Of course, we always want to log the error, so we know what
    to fix (“It’s that darn home page again”).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与在 `/Error` 页面上相同的方式检索 `ExceptionHandlerPathFeature` 实例。当然，我们总是想记录错误，以便知道要修复什么（“又是那个讨厌的首页”）。
- en: In this section, we learned how to use middleware to create a global exception
    handler. This allows us to centralize the error handling and avoid too many exception
    handlers throughout our application. Next, we’ll focus on performance considerations
    when writing exception handlers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用中间件创建全局异常处理器。这使我们能够集中处理错误，并避免在应用程序中设置过多的异常处理器。接下来，我们将关注编写异常处理器时的性能考虑。
- en: Performance considerations
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能考虑
- en: One common myth about exception handling is that it doesn’t affect performance.
    If exceptions are significantly harming the application’s performance, that’s
    a sign that exceptions are being used too much. Exceptions should not control
    the flow of the application whatsoever.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常处理的一个常见误解是它不会影响性能。如果异常严重损害了应用程序的性能，那么这是一个迹象，表明异常被过度使用了。异常绝对不应该控制应用程序的流程。
- en: Ideally, the code should flow with no interruptions. In small web applications
    with a few users, this type of approach may be adequate, but for high-performing,
    high-traffic websites, placing a `try`/`catch` block in frequently-called code
    may cause the site to suffer a performance hit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，代码应该流畅无中断。在小型具有少量用户的网络应用程序中，这种方法可能是足够的，但对于高性能、高流量的网站，在频繁调用的代码中放置 `try`/`catch`
    块可能会使网站的性能受到影响。
- en: In this section, we covered what exception handling was, reviewed the two types
    of errors in applications, identified where exception handling is ideal, and covered
    some of the performance myths regarding exceptions. Next, we’ll look at some common
    exception handling techniques.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了异常处理的概念，回顾了应用程序中的两种错误类型，确定了异常处理理想的位置，并讨论了有关异常的一些性能误解。接下来，我们将探讨一些常见的异常处理技术。
- en: Common exception handling techniques
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的异常处理技术
- en: Exceptions are expensive in .NET. When an exception occurs in the application,
    there are resources in place to begin the error handling process when an exception
    occurs, such as the stack trace process. Even when we are catching and handling
    the errors, ASP.NET is still creating the `Exception` object and everything associated
    with it along with walking up the call stack to locate the handler.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在 .NET 中代价高昂。当应用程序中发生异常时，会有一套资源来开始错误处理过程，例如堆栈跟踪过程。即使我们在捕获和处理错误时，ASP.NET 仍在创建
    `Exception` 对象及其所有相关内容，并沿着调用堆栈向上查找处理器。
- en: In this section, we’ll look at common approaches in the industry to minimize
    the exceptions through “prevention before exception,” why to use logging, why
    unit testing is similar to exception handling, why empty catch blocks should be
    avoided, how to simplify exceptions using exception filtering and pattern matching,
    why blocks are important when releasing resources, and how to rethrow exceptions
    properly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨行业中的常见方法，通过“预防异常”来最小化异常，为什么使用日志记录，为什么单元测试与异常处理相似，为什么应该避免空的`catch`块，如何使用异常过滤和模式匹配简化异常，为什么在释放资源时块很重要，以及如何正确地重新抛出异常。
- en: Prevention before exception
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在异常之前进行预防
- en: As we said in the previous section, exceptions interrupt the flow of an application
    when encountered and can cause more problems than intended, such as releasing
    resources that were previously allocated and triggering multiple exceptions up
    the call stack. If we’re writing `try`/`catch` blocks of code to control the flow
    of the program, we’re doing it wrong. It’s best to perform checks before wrapping
    code with `try`/`catch` blocks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中说的，当遇到异常时，异常会中断应用程序的流程，并可能造成比预期更多的问题，例如释放之前分配的资源，并在调用栈中触发多个异常。如果我们正在编写`try`/`catch`块来控制程序的流程，我们就是在做错事。最好在用`try`/`catch`块包装代码之前进行检查。
- en: 'If there’s one thing to take away from this chapter, let it be this principle:
    prevention before exception.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从这个章节中只能学到一点，那就是这个原则：预防异常。
- en: The concept of prevention before exception refers to the idea of trying to prevent
    the error from happening using less destructive methods, such as stopping the
    execution of the website completely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 预防异常的概念是指尝试使用更少破坏性的方法来防止错误发生，例如完全停止网站的执行。
- en: 'For example, examine the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查以下代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In a happy path, the number will be parsed and the result will be `2`. However,
    if the string contained a value of “hi”, the result will become a zero.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个愉快的路径中，数字将被解析，结果将是`2`。然而，如果字符串包含值为“hi”，结果将变为零。
- en: 'A better approach would be using the newest `TryParse` with `var`, as shown
    here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用最新的`TryParse`与`var`结合，如下所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this approach, we are attempting to convert the number and store the converted
    value into a new variable called `result`. `TryParse` returns true if the conversion
    was successful and false if not. If the conversion fails, we set `result` to `0`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们试图将数字转换并存储转换后的值到一个名为`result`的新变量中。`TryParse`在转换成功时返回`true`，不成功时返回`false`。如果转换失败，我们将`result`设置为`0`。
- en: We prevented an exception by handling the conversion through easier means. There
    are a large number of conversion methods in .NET and we can accomplish the same
    thing without `try`/`catch`/`finally` blocks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过更简单的方式处理转换来预防异常。在.NET中有大量的转换方法，我们可以不使用`try`/`catch`/`finally`块来完成相同的事情。
- en: For simpler exceptions, look at the `try`/`catch` block and ask if we can apply
    some sort of prevention before creating exceptions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的异常，查看`try`/`catch`块，并询问我们是否可以在创建异常之前应用某种预防措施。
- en: Use logging
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日志记录
- en: When creating a `try`/`catch` block, it’s best to show the intent of what we
    want to get out of the code. Is the error something we can recover from or is
    it something that requires investigation when it occurs?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`try`/`catch`块时，最好展示我们想要从代码中获得的目的。错误是我们能够恢复的还是需要调查的？
- en: If it’s the latter, it’s best to send a well-constructed error message to the
    logger before throwing the error. As mentioned in various chapters, it’s best
    to use a logging strategy to identify issues throughout the code base.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是后者，在抛出错误之前最好向记录器发送一个构造良好的错误消息。正如在各个章节中提到的，最好使用日志策略来识别代码库中的问题。
- en: 'If we use the previous example to determine the value that caused the error,
    we can create a log entry, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前的例子来确定导致错误的值，我们可以创建一个日志条目，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this gives us a clear log entry for our `try`/`catch` block, we can copy
    this one-liner to our `TryParse` example as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这为我们提供了清晰的日志条目，但对于我们的`try`/`catch`块，我们也可以将这一行复制到`TryParse`示例中。
- en: The idea is to provide enough information to developers without jarring the
    user’s experience with errors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是提供足够的信息给开发者，同时又不让错误打扰用户的体验。
- en: Apply a unit testing methodology
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用单元测试方法
- en: If we have to use a `try`/`catch` block, look at it like a unit test. We mentioned
    that unit tests have the triple-A approach (Arrange, Act, and Assert). We want
    to create a minimal amount of code to get the job done and move on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不得不使用 `try`/`catch` 块，就要把它看作是一个单元测试。我们提到单元测试有 AAA 方法（安排、行动和断言）。我们希望创建尽可能少的代码来完成工作并继续前进。
- en: Initialize the objects at the beginning (Arrange) and wrap a `try`/`catch` block
    around the suspecting line causing the error (Act). Minimize the amount of code
    inside the `try`/`catch` block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时初始化对象（安排），并在导致错误的可疑行周围包裹一个 `try`/`catch` 块（行动）。尽量减少 `try`/`catch` 块内的代码量。
- en: 'Once again, we can apply this approach to the previous code example, which
    has been modified as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将这种方法应用于前面修改过的代码示例，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Anything above the `try` statement would be considered part of `Arrange`; the
    one-liner inside the try’s brackets is considered `Act`. The `Assert` piece would
    be part of the `catch` statement. This statement would be the equivalent of a
    failed `Assert`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try` 语句之上的任何内容都会被认为是 `Arrange` 部分；try 括号内的单行语句被认为是 `Act`。`Assert` 部分将是 `catch`
    语句的一部分。这个语句将相当于一个失败的 `Assert`。
- en: Avoid empty catch statements
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免空的 `catch` 语句
- en: 'While preventing errors is critical to our applications, consider an empty
    catch statement, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然防止错误对我们应用程序至关重要，但请考虑以下示例中的空 `catch` 语句：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What happens when the `Deposit()` method doesn’t work? If we do have an error
    in the code, the `catch` statement should contain something to let the developer
    know an error occurred. At the very least, a `Log` statement should exist to notify
    the team about the issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Deposit()` 方法不起作用时会发生什么？如果我们代码中确实有错误，`catch` 语句应该包含一些内容来让开发者知道发生了错误。至少，应该有一个
    `Log` 语句来通知团队有关问题。
- en: While an empty `try`/`catch` block keeps the program from crashing, it causes
    a bigger problem. Once someone discovers there’s an error with depositing funds,
    it may be hard to find the issue since it doesn’t log the problem because it’s
    not logging or throwing an error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空的 `try`/`catch` 块可以防止程序崩溃，但它会引发更大的问题。一旦有人发现存款有问题，由于没有记录问题，可能很难找到问题所在。
- en: Use exception filtering and pattern matching
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异常过滤和模式匹配
- en: If we are dealing with multiple exceptions for a section of code, a new feature
    in .NET called exception filtering can make the exception handling terser. If
    we have compact code, exception filtering can provide a more efficient and modern
    code base.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理代码段中的多个异常，.NET 中的一个新特性，称为异常过滤，可以使异常处理更加简洁。如果我们有紧凑的代码，异常过滤可以提供更高效和现代的代码库。
- en: 'For instance, file handling can often result in a wide variety of exceptions.
    Consider the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文件处理常常会导致各种异常。考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we log each exception and provide a message based on
    the specific exception. With exception filtering, we can shorten the lines to
    something a little easier to read:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们记录每个异常，并根据特定的异常提供消息。使用异常过滤，我们可以缩短行数，使其更容易阅读：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we are grouping `DirectoryNotFoundException` and `FileNotFoundException`
    and logging them as warnings. When we encounter a `NotSupportedException` or `IOException`
    error, we consider that a little more of a problem and log those as errors. Anything
    else coming through will be caught as a general exception and logged as an error
    with the message.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `DirectoryNotFoundException` 和 `FileNotFoundException` 进行分组，并将它们记录为警告。当我们遇到
    `NotSupportedException` 或 `IOException` 错误时，我们认为这是一个更大的问题，并将这些错误记录为错误。任何其他通过的内容都将被捕获为一般异常，并以消息的形式记录为错误。
- en: 'Along with exception filtering, .NET introduced another new feature called
    pattern matching. With pattern matching, we can shorten the code even further:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常过滤之外，.NET 还引入了另一个新特性，称为模式匹配。使用模式匹配，我们可以进一步缩短代码：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code uses a `switch` statement inside the `catch` brackets to
    identify what type of exception we’re experiencing. Think of switch pattern matching
    as an inline `if` statement. The preceding line returns the value of `logLevel`
    based on the exception type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 `catch` 括号内使用 `switch` 语句来识别我们正在经历的异常类型。将 switch 模式匹配视为内联的 `if` 语句。前面的行根据异常类型返回
    `logLevel` 的值。
- en: The underscore (`_`) is called a discard variable (it’s like a default in a
    switch statement). If everything else falls through the switch, then we’ll just
    default the log level to `LogLevel.Error` and log the message with the current
    method, the name of the exception type, and the exception message.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线（`_`）被称为丢弃变量（它类似于switch语句中的默认值）。如果其他所有情况都通过switch，那么我们将默认将日志级别设置为`LogLevel.Error`，并使用当前方法、异常类型名称和异常消息记录消息。
- en: Exception handling can be wordy with, for instance, I/O-based methods and connections.
    Exception filtering and pattern matching can help ease the wordiness of catching
    various exceptions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能会很冗长，例如，基于I/O的方法和连接。异常过滤和模式匹配可以帮助减轻捕获各种异常的冗长性。
- en: Use finally blocks for cleanup
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`finally`块进行清理
- en: When working with database connections, file-based operations, or resources,
    it’s best to use `finally` for cleanup.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据库连接、基于文件的操作或资源时，最好使用`finally`来进行清理。
- en: 'For example, if we’re connecting to a database and want to close the connection
    afterward, we’d have to create a piece of code similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们连接到数据库并在之后想要关闭连接，我们就必须创建一段类似于以下代码的代码：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the connection object is passed into the `SqlCommand`
    constructor. When we execute the SQL query, the command is passed into the connection
    and executed. Once our code is executed, we close the connection in the `finally`
    statement. Since we have a `using` statement and the `SqlConnection` class implements
    `IDisposable`, it will automatically be disposed of.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，连接对象被传递到`SqlCommand`构造函数中。当我们执行SQL查询时，命令被传递到连接并执行。一旦我们的代码执行完毕，我们在`finally`语句中关闭连接。由于我们有`using`语句，并且`SqlConnection`类实现了`IDisposable`接口，它将自动被销毁。
- en: There are times when we need `finally` statements to clean up, but there are
    exceptions when they aren’t necessary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要`finally`语句来进行清理，但有时它们是不必要的。
- en: Knowing when to throw
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知道何时抛出
- en: In the previous code example, we issued `throw;` as opposed to `throw ex;`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们使用了`throw;`而不是`throw ex;`。
- en: 'If we run the code example in the previous section with `throw;`, we see that
    the stack trace in Visual Studio is seen through the **Call** **Stack** pane:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上一节中的代码示例并使用`throw;`，我们会在Visual Studio的**调用栈**窗格中看到栈跟踪：
- en: '![Figure 8.1 – Snapshot of a call stack with a simple throw;](img/B19493_08_1.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 使用简单`throw;`的调用栈快照](img/B19493_08_1.jpg)'
- en: Figure 8.1 – Snapshot of a call stack with a simple throw;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用简单`throw;`的调用栈快照
- en: What happens if we change the line to `throw ex;`?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将该行更改为`throw ex;`会发生什么？
- en: '![Figure 8.2 – Snapshot of a call stack with throw ex;](img/B19493_08_2.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 使用`throw ex;`的调用栈快照](img/B19493_08_2.jpg)'
- en: Figure 8.2 – Snapshot of a call stack with throw ex;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 使用`throw ex;`的调用栈快照
- en: The stack trace completely disappears. The error will become harder to track
    if we don’t have a stack trace. There are times when we want to simply throw the
    exception. It’s always better to rethrow the exception so that the stack trace
    is left intact for locating errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 栈跟踪完全消失。如果没有栈跟踪，错误将更难追踪。有时我们只想简单地抛出异常。总是重新抛出异常更好，这样栈跟踪就可以保持完整，以便定位错误。
- en: In this section, we covered many standards of what is considered practical when
    applying exception handling in the code. We learned how to minimize exceptions
    with “prevention before exception,” why logging is important, and why exception
    handling is like unit testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了许多在代码中应用异常处理时被认为是实用的标准。我们学习了如何通过“预防胜于异常”来最小化异常，为什么记录日志很重要，以及为什么异常处理就像单元测试一样。
- en: We also learned to avoid empty catch blocks, simplify exceptions using exception
    filtering and pattern matching, when to use finally blocks, and how to rethrow
    exceptions properly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何避免空的捕获块，使用异常过滤和模式匹配简化异常，何时使用`finally`块，以及如何正确地重新抛出异常。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Exception handling is important but requires a level of experience when writing
    truly robust applications. Applications need to recover so that the user doesn’t
    have a jarring experience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理很重要，但在编写真正健壮的应用程序时需要一定的经验。应用程序需要恢复，以便用户不会有一个令人不快的体验。
- en: In this chapter, we learned about exception handling, when to use it, and where
    it makes sense, as well as performance considerations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了异常处理、何时使用它以及它在哪些情况下是有意义的，以及性能考虑。
- en: We ended this chapter by learning about the common techniques of exception handling
    by understanding the “prevention before exception” principle, why logging is important,
    and why exception handling is like unit testing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过理解“预防胜于异常”原则、了解日志记录的重要性以及异常处理为何像单元测试一样重要，来结束本章的学习。
- en: We also learned that empty catch blocks are wasteful, how to simplify exceptions
    using exception filtering and pattern matching, when to use finally blocks, and
    how to rethrow exceptions properly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到空捕获块是浪费的，如何通过异常过滤和模式匹配简化异常，何时使用finally块，以及如何正确地重新抛出异常。
- en: In the next chapter, we’ll look at web API standards and how they are extremely
    important to the ASP.NET Core ecosystem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Web API标准以及它们对ASP.NET Core生态系统极端重要性的原因。
