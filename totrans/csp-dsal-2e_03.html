<html><head></head><body>
<div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.2.1">Arrays and Sorting</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As a developer, you have certainly stored various collections within your applications, such as data of users, books, and logs. </span><span class="koboSpan" id="kobo.3.2">One of the natural ways of storing such data is by using arrays. </span><span class="koboSpan" id="kobo.3.3">However, have you ever thought about their variants? </span><span class="koboSpan" id="kobo.3.4">For example, have you heard about jagged arrays? </span><span class="koboSpan" id="kobo.3.5">In this chapter, you will see arrays in action, together with examples and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">detailed descriptions.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">You can use an array to </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">store many items of the same type</span></strong><span class="koboSpan" id="kobo.7.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">int</span></strong><span class="koboSpan" id="kobo.9.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">string</span></strong><span class="koboSpan" id="kobo.11.1">, as well as a user-defined class or record. </span><span class="koboSpan" id="kobo.11.2">Just keep in mind that </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">the number of elements in an array cannot be changed after initialization</span></strong><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">For this reason, you will not be able to easily add a new item at the end of the array or insert an element in a given position within the array while moving the remaining items one position further. </span><span class="koboSpan" id="kobo.13.3">If you need such features, you can use another data structure, namely a list and its variants, which will be described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">While developing applications in the C# language, you can benefit from a few variants of arrays, namely </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">single-dimensional arrays</span></strong><span class="koboSpan" id="kobo.17.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">multi-dimensional arrays</span></strong><span class="koboSpan" id="kobo.19.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">jagged arrays</span></strong><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">In this chapter, you will also get to know seven </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">sorting algorithms</span></strong><span class="koboSpan" id="kobo.23.1">, namely </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">selection sort</span></strong><span class="koboSpan" id="kobo.25.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">insertion sort</span></strong><span class="koboSpan" id="kobo.27.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">bubble sort</span></strong><span class="koboSpan" id="kobo.29.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">merge sort</span></strong><span class="koboSpan" id="kobo.31.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Shell sort</span></strong><span class="koboSpan" id="kobo.33.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">quicksort</span></strong><span class="koboSpan" id="kobo.35.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">heap sort</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">For each, you will see an illustration-based example, the implementation code, and a step-by-step explanation. </span><span class="koboSpan" id="kobo.37.3">You will also see their performance analysis, presented </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">with charts.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.41.1">Single-dimensional arrays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.42.1">Multi-dimensional arrays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Jagged arrays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Sorting algorithms</span></span></li>
</ul>
<h1 id="_idParaDest-63"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.45.1">Single-dimensional arrays</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Let’s start with the simplest variant of arrays, namely single-dimensional ones. </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Such an array stores a collection of items of the same type, which are accessible by an </span></strong><strong class="bold"><span class="koboSpan" id="kobo.48.1">index</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">It is important to</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.50.1"> remember that </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">indices of elements within arrays in C# are zero-based</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">This means that the first </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.53.1">element has an index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">0</span></strong><span class="koboSpan" id="kobo.55.1">, while the last one has an index equal to the length of the array </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">minus one.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.57.1">Imagine a single-dimensional array</span></p>
<p class="callout"><span class="koboSpan" id="kobo.58.1">If you want to better imagine a single-dimensional array, take your eyes off this book for a moment and look at the chest of drawers or wardrobe in your room. </span><span class="koboSpan" id="kobo.58.2">A standard chest of drawers consists of several drawers and a single-dimensional array looks similar. </span><span class="koboSpan" id="kobo.58.3">It also has several elements (as drawers), which are accessible via the index. </span><span class="koboSpan" id="kobo.58.4">You cannot change the size of the array in the same way as you cannot change the number of drawers since the furniture is prepared. </span><span class="koboSpan" id="kobo.58.5">An array has one significant advantage over a chest of drawers, namely all its “drawers” are always working </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">An example of a single-dimensional array is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 3.1 – Example of a single-dimensional array" src="image/B18069_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 3.1 – Example of a single-dimensional array</span></p>
<p><span class="koboSpan" id="kobo.64.1">It contains five </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.65.1">elements with the following values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">9</span></strong><span class="koboSpan" id="kobo.67.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">-11</span></strong><span class="koboSpan" id="kobo.69.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">6</span></strong><span class="koboSpan" id="kobo.71.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">-12</span></strong><span class="koboSpan" id="kobo.73.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">1</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">The first element has an index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">0</span></strong><span class="koboSpan" id="kobo.77.1">, while the last one has an index equal </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">To use a single-dimensional array, you need to declare and initialize it. </span><span class="koboSpan" id="kobo.81.2">The declaration is very simple because you just need to </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.82.1">specify a type of element and a name, </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.84.1">type[]</span></strong><span class="koboSpan" id="kobo.85.1"> name;</span></pre> <p><span class="koboSpan" id="kobo.86.1">The declaration of an array with integer values is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">following line:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.88.1">int[]</span></strong><span class="koboSpan" id="kobo.89.1"> numbers;</span></pre> <p><span class="koboSpan" id="kobo.90.1">So far, you know how to declare an array, but what about initializing one? </span><span class="koboSpan" id="kobo.90.2">To create an array with five elements and initialize them to default values, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">new</span></strong><span class="koboSpan" id="kobo.92.1"> operator, as </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
numbers = </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">new int[5];</span></strong></pre> <p><span class="koboSpan" id="kobo.96.1">Of course, you can combine a declaration and initialization in the same line, </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
int[] numbers = new int[5];</span></pre> <p><span class="koboSpan" id="kobo.99.1">Unfortunately, all the elements currently have default values – that is, zeros in the case of integer values. </span><span class="koboSpan" id="kobo.99.2">Thus, you need to set the values of particular elements. </span><span class="koboSpan" id="kobo.99.3">You can do this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">[]</span></strong><span class="koboSpan" id="kobo.101.1"> operator and an index of an element, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.103.1">numbers[0]</span></strong><span class="koboSpan" id="kobo.104.1"> = 9;
</span><strong class="bold"><span class="koboSpan" id="kobo.105.1">numbers[1]</span></strong><span class="koboSpan" id="kobo.106.1"> = -11;
</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">numbers[2]</span></strong><span class="koboSpan" id="kobo.108.1"> = 6;
</span><strong class="bold"><span class="koboSpan" id="kobo.109.1">numbers[3]</span></strong><span class="koboSpan" id="kobo.110.1"> = -12;
</span><strong class="bold"><span class="koboSpan" id="kobo.111.1">numbers[4]</span></strong><span class="koboSpan" id="kobo.112.1"> = 1;</span></pre> <p><span class="koboSpan" id="kobo.113.1">Moreover, you can combine a declaration and initialization of array elements to specific values using one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">following variants:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
int[] numbers = new int[] { 9, -11, 6, -12, 1 };
int[] numbers = { 9, -11, 6, -12, 1 };</span></pre> <p><span class="koboSpan" id="kobo.116.1">Another approach involves using the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">collection expression</span></strong><span class="koboSpan" id="kobo.118.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
int[] numbers = </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">[9, -11, 6, -12, 1]</span></strong><span class="koboSpan" id="kobo.122.1">;</span></pre> <p><span class="koboSpan" id="kobo.123.1">When you have the proper values of elements within an array, you can get values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">[]</span></strong><span class="koboSpan" id="kobo.125.1"> operator and by specifying the index, as shown in the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
int middle = </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">numbers[2]</span></strong><span class="koboSpan" id="kobo.129.1">;</span></pre> <p><span class="koboSpan" id="kobo.130.1">Here, you get a value of the third element (the index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">2</span></strong><span class="koboSpan" id="kobo.132.1">) from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">numbers</span></strong><span class="koboSpan" id="kobo.134.1"> array and store it as a value of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">middle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">The array has some properties that can be useful while developing applications. </span><span class="koboSpan" id="kobo.137.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Length</span></strong><span class="koboSpan" id="kobo.139.1"> property makes it possible to get the size of the array, namely the number of elements stored within it. </span><span class="koboSpan" id="kobo.139.2">If you want to access the last item in the array, regardless of its size, you </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.140.1">can use the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
int last = numbers</span><strong class="bold"><span class="koboSpan" id="kobo.143.1">[numbers.Length - 1]</span></strong><span class="koboSpan" id="kobo.144.1">;</span></pre> <p><span class="koboSpan" id="kobo.145.1">You can simplify this with the </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">index operator</span></strong><span class="koboSpan" id="kobo.147.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
int last = numbers</span><strong class="bold"><span class="koboSpan" id="kobo.150.1">[^1]</span></strong><span class="koboSpan" id="kobo.151.1">;</span></pre> <p><span class="koboSpan" id="kobo.152.1">It is worth noting that the second item from the end can be received by </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">[^2]</span></strong><span class="koboSpan" id="kobo.154.1">, the third by </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">[^3]</span></strong><span class="koboSpan" id="kobo.156.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">The other property is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Rank</span></strong><span class="koboSpan" id="kobo.160.1"> and returns the number of dimensions of the array. </span><span class="koboSpan" id="kobo.160.2">Usage of this property is shown in the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
int rank = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.163.1">Rank</span></strong><span class="koboSpan" id="kobo.164.1">;</span></pre> <p><span class="koboSpan" id="kobo.165.1">Apart from the already mentioned properties, you can use a set of static methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Array</span></strong><span class="koboSpan" id="kobo.167.1"> class, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Exists</span></strong><span class="koboSpan" id="kobo.169.1">, to check whether there is any element in the array that matches the given predicate. </span><span class="koboSpan" id="kobo.169.2">For example, you can easily verify whether the array contains any element whose value is greater than zero, </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
bool anyPositive = Array.</span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Exists</span></strong><span class="koboSpan" id="kobo.173.1">(numbers, e =&gt; e &gt; 0);</span></pre> <p><span class="koboSpan" id="kobo.174.1">Among other methods, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">TrueForAll</span></strong><span class="koboSpan" id="kobo.176.1"> to check whether all elements meet the provided predicate, such as to ensure that there are no zeros in </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
bool noZeros = Array.</span><strong class="bold"><span class="koboSpan" id="kobo.179.1">TrueForAll</span></strong><span class="koboSpan" id="kobo.180.1">(numbers, e =&gt; e != 0);</span></pre> <p><span class="koboSpan" id="kobo.181.1">You can also get the first element that matches the predicate. </span><span class="koboSpan" id="kobo.181.2">As an example, let’s get the value of the first number that is smaller than zero using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Find</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
int firstNegative = Array.</span><strong class="bold"><span class="koboSpan" id="kobo.185.1">Find</span></strong><span class="koboSpan" id="kobo.186.1">(numbers, e =&gt; e &lt; 0);</span></pre> <p><span class="koboSpan" id="kobo.187.1">If you want to get a new array with all the elements that meet the given condition, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">FindAll</span></strong><span class="koboSpan" id="kobo.189.1"> method. </span><span class="koboSpan" id="kobo.189.2">The following code shows how to get all </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">negative numbers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
int[] negatives = Array.</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">FindAll</span></strong><span class="koboSpan" id="kobo.193.1">(numbers, e =&gt; e &lt; 0);</span></pre> <p><span class="koboSpan" id="kobo.194.1">When you do not want to specify the predicate and you just want to check whether the array contains a given element or not, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">IndexOf</span></strong><span class="koboSpan" id="kobo.196.1"> method, which returns an index of the first found occurrence of the value or </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">-1</span></strong><span class="koboSpan" id="kobo.198.1">, if </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">not found:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
int index = Array.</span><strong class="bold"><span class="koboSpan" id="kobo.201.1">IndexOf</span></strong><span class="koboSpan" id="kobo.202.1">(numbers, -12);</span></pre> <p><span class="koboSpan" id="kobo.203.1">Another interesting static</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.204.1"> method is </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ForEach</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">It allows you to perform some operations for all the elements in the array. </span><span class="koboSpan" id="kobo.206.3">As an example, you can use it to write the absolute value of each array element in the console, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.209.1">ForEach</span></strong><span class="koboSpan" id="kobo.210.1">(numbers, 
    e =&gt; Console.WriteLine(Math.Abs(e)));</span></pre> <p><span class="koboSpan" id="kobo.211.1">As you can see, even for as simple a data structure as a single-dimensional array, you have a lot of useful built-in features. </span><span class="koboSpan" id="kobo.211.2">Let’s continue learning them and take a look at the two next methods, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Reverse</span></strong><span class="koboSpan" id="kobo.213.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">Sort</span></strong><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">According to their names, the first allows you to reverse the order of the elements, either for the whole array or only within some range. </span><span class="koboSpan" id="kobo.215.3">This is presented in the following line of code, which reverses the first </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">three elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Reverse</span></strong><span class="koboSpan" id="kobo.219.1">(numbers, 0, 3);</span></pre> <p><span class="koboSpan" id="kobo.220.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Sort</span></strong><span class="koboSpan" id="kobo.222.1"> method has even more variants. </span><span class="koboSpan" id="kobo.222.2">In its simplest form, it sorts the whole array. </span><span class="koboSpan" id="kobo.222.3">After running the following line, you’ll get the array with the elements sorted from the smallest to </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the biggest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.225.1">Sort</span></strong><span class="koboSpan" id="kobo.226.1">(numbers);</span></pre> <p><span class="koboSpan" id="kobo.227.1">If you want to fill the whole array with the same value or fill the range of elements with the same value, you can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">for</span></strong><span class="koboSpan" id="kobo.229.1"> loop and simply iterate through suitable indices and assign a given value. </span><span class="koboSpan" id="kobo.229.2">However, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Fill</span></strong><span class="koboSpan" id="kobo.231.1"> method instead. </span><span class="koboSpan" id="kobo.231.2">The following line places </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">3</span></strong><span class="koboSpan" id="kobo.233.1"> as a value of all elements in </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Fill</span></strong><span class="koboSpan" id="kobo.237.1">(numbers, 3);</span></pre> <p><span class="koboSpan" id="kobo.238.1">Another method we can use is </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">Clear</span></strong><span class="koboSpan" id="kobo.240.1">, which makes it possible to clear the whole array or a range of its elements. </span><span class="koboSpan" id="kobo.240.2">For example, you can fill the whole array with the default value of the integer type, namely zeros, using the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.243.1">Clear</span></strong><span class="koboSpan" id="kobo.244.1">(numbers);</span></pre> <p><span class="koboSpan" id="kobo.245.1">Now, let’s take a look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Copy</span></strong><span class="koboSpan" id="kobo.247.1">, which copies a range of elements from the source array to the destination array. </span><span class="koboSpan" id="kobo.247.2">You can use one out of a few variants, such as to specify indices from both arrays. </span><span class="koboSpan" id="kobo.247.3">As an example, let’s copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">3</span></strong><span class="koboSpan" id="kobo.249.1"> elements (specified as </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">length</span></strong><span class="koboSpan" id="kobo.251.1">) from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">numbers</span></strong><span class="koboSpan" id="kobo.253.1"> array (as the source array), starting from the first element (source index set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">0</span></strong><span class="koboSpan" id="kobo.255.1">), and place them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">subarray</span></strong><span class="koboSpan" id="kobo.257.1"> array, starting from the first element (destination index set </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
int[] subarray = new int[3];
Array.</span><strong class="bold"><span class="koboSpan" id="kobo.262.1">Copy</span></strong><span class="koboSpan" id="kobo.263.1">(numbers, 0, subarray, 0, 3);</span></pre> <p><span class="koboSpan" id="kobo.264.1">We’ve already covered a</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.265.1"> few available properties and methods, but it is worth mentioning</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.266.1"> some </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">extension methods</span></strong><span class="koboSpan" id="kobo.268.1"> as well, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Contains</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.270.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Max</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.273.1">Have you ever heard about extension methods?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.274.1">If not, think of them as methods that are “added” to a particular existing type (both built-in or user-defined) and can be called in the same way as when they are defined directly as instance methods. </span><span class="koboSpan" id="kobo.274.2">The declaration of an extension method requires you to specify it within a static class as a static method with the first parameter indicating the type to which you want to “add” this method with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Contains</span></strong><span class="koboSpan" id="kobo.279.1"> extension method to check whether the array contains an element passed as the parameter. </span><span class="koboSpan" id="kobo.279.2">As an example, let’s learn how to ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">numbers</span></strong><span class="koboSpan" id="kobo.281.1"> array contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">6</span></strong><span class="koboSpan" id="kobo.283.1"> as one of </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">its elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
bool contains = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.286.1">Contains</span></strong><span class="koboSpan" id="kobo.287.1">(6);</span></pre> <p><span class="koboSpan" id="kobo.288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Contains</span></strong><span class="koboSpan" id="kobo.290.1"> method is not the only available extension method. </span><span class="koboSpan" id="kobo.290.2">Among others, you can find </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">All</span></strong><span class="koboSpan" id="kobo.292.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Any</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">The first (</span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">All</span></strong><span class="koboSpan" id="kobo.296.1">) checks whether all of the elements match the given predicate, while the other (</span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Any</span></strong><span class="koboSpan" id="kobo.298.1">) verifies whether at least one element meets the condition. </span><span class="koboSpan" id="kobo.298.2">You can use them to ensure that there are no zeros in the array and check whether there is at least one positive element, as </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
bool noZeros = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.301.1">All</span></strong><span class="koboSpan" id="kobo.302.1">(n =&gt; n != 0);
bool anyPositive = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Any</span></strong><span class="koboSpan" id="kobo.304.1">(n =&gt; n &gt; 0);</span></pre> <p><span class="koboSpan" id="kobo.305.1">What will you do to find the minimum or maximum value in the array? </span><span class="koboSpan" id="kobo.305.2">You will probably iterate through all elements and check whether each element is smaller (for searching the minimum) or bigger (in the case of the maximum) than the already found minimum or maximum value. </span><span class="koboSpan" id="kobo.305.3">If that is your solution, you are correct and it is a good way of solving the problem. </span><span class="koboSpan" id="kobo.305.4">However, you can make your code much shorter by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Min</span></strong><span class="koboSpan" id="kobo.307.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Max</span></strong><span class="koboSpan" id="kobo.309.1"> extension methods, as </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
int min = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.312.1">Min</span></strong><span class="koboSpan" id="kobo.313.1">();
int max = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.314.1">Max</span></strong><span class="koboSpan" id="kobo.315.1">();</span></pre> <p><span class="koboSpan" id="kobo.316.1">Pretty simple, isn’t it? </span><span class="koboSpan" id="kobo.316.2">Let’s also take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Average</span></strong><span class="koboSpan" id="kobo.318.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Sum</span></strong><span class="koboSpan" id="kobo.320.1"> methods, which easily calculate the average value </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.321.1">of all of the elements, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">their sum:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
double avg = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Average</span></strong><span class="koboSpan" id="kobo.325.1">();
int sum = numbers.</span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Sum</span></strong><span class="koboSpan" id="kobo.327.1">();</span></pre> <p><span class="koboSpan" id="kobo.328.1">After this short introduction to single-dimensional arrays, it’s high time to take a look at an example of how to apply such arrays in </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">real-world scenarios.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.330.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.331.1">You can find a lot of interesting information about arrays and their various variants in the context of the C# language </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">at </span></span><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/"><span class="No-Break"><span class="koboSpan" id="kobo.333.1">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/a</span><span id="_idTextAnchor091"/><span id="_idTextAnchor092"/><span class="koboSpan" id="kobo.334.1">rrays/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.336.1">Example – month names</span></h2>
<p><span class="koboSpan" id="kobo.337.1">To summarize what you’ve learned</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.338.1"> about single-dimensional arrays, let’s use an array to store names of months, written in English. </span><span class="koboSpan" id="kobo.338.2">Such names should be obtained automatically, not by hardcoding them in </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">The implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
using System.Globalization;
CultureInfo culture = new("en");
</span><strong class="bold"><span class="koboSpan" id="kobo.343.1">string[] months = new string[12];</span></strong><span class="koboSpan" id="kobo.344.1">
for (int month = 1; month &lt;= 12; month++)
{
    DateTime firstDay = new(DateTime.Now.Year, month, 1);
    string name = firstDay.ToString("MMMM", culture);
    </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">months[month - 1] = name;</span></strong><span class="koboSpan" id="kobo.346.1">
}
</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">foreach (string m in months)</span></strong><span class="koboSpan" id="kobo.348.1">
{
    Console.WriteLine(m);
}</span></pre> <p><span class="koboSpan" id="kobo.349.1">First, you create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">CultureInfo</span></strong><span class="koboSpan" id="kobo.351.1"> class (from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">System.Globalization</span></strong><span class="koboSpan" id="kobo.353.1"> namespace), passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">en</span></strong><span class="koboSpan" id="kobo.355.1"> as a parameter, to later get the names of months in English. </span><span class="koboSpan" id="kobo.355.2">Then, you declare a new single-dimensional array and initialize it with default values. </span><span class="koboSpan" id="kobo.355.3">It contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">12</span></strong><span class="koboSpan" id="kobo.357.1"> elements to store the names of all the months in a year. </span><span class="koboSpan" id="kobo.357.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">for</span></strong><span class="koboSpan" id="kobo.359.1"> loop is </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.360.1">used to iterate through the numbers of all months – that is, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">1</span></strong><span class="koboSpan" id="kobo.362.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">12</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">For each of them, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">DateTime</span></strong><span class="koboSpan" id="kobo.366.1"> instance representing the first day in a particular month from the current year </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">The name of the month is obtained by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">ToString</span></strong><span class="koboSpan" id="kobo.370.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">DateTime</span></strong><span class="koboSpan" id="kobo.372.1"> instance, passing the proper format of the date (</span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">MMMM</span></strong><span class="koboSpan" id="kobo.374.1">), as well as specifying the culture. </span><span class="koboSpan" id="kobo.374.2">Then, the name is stored in the array using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">[]</span></strong><span class="koboSpan" id="kobo.376.1"> operator and an index of the element. </span><span class="koboSpan" id="kobo.376.2">It is worth noting that the index is equal to the current value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">month</span></strong><span class="koboSpan" id="kobo.378.1"> variable minus one. </span><span class="koboSpan" id="kobo.378.2">Such subtraction is necessary because the first element in the array has an index equal to zero, instead </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">of one.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">The next interesting part of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">foreach</span></strong><span class="koboSpan" id="kobo.382.1"> loop, which iterates through all elements of the array. </span><span class="koboSpan" id="kobo.382.2">For each of them, the name of the month is shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.384.1">
January
February (...)
December</span></pre> <p><span class="koboSpan" id="kobo.385.1">As mentioned earlier, single-dimensional arrays are not the only available variant. </span><span class="koboSpan" id="kobo.385.2">You will learn more about multi-dimensional arrays in the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">following</span><a id="_idTextAnchor094"/><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.387.1"> section.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.388.1">Multi-dimensional arrays</span></h1>
<p><span class="koboSpan" id="kobo.389.1">The arrays in the C# language do not </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.390.1">need to have only one dimension. </span><span class="koboSpan" id="kobo.390.2">It is possible to create two-dimensional arrays as well. </span><span class="koboSpan" id="kobo.390.3">As you will see, multi-dimensional arrays are very useful and are frequently used while developing </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">various applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.392.1">Imagine a two-dimensional array</span></p>
<p class="callout"><span class="koboSpan" id="kobo.393.1">If you want to imagine a two-dimensional </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.394.1">array, take a break, close your eyes, and play Sudoku. </span><span class="koboSpan" id="kobo.394.2">If you don’t know what this is, Sudoku is a popular game that requires you to fill empty cells of a 9x9 board with numbers from 1 to 9. </span><span class="koboSpan" id="kobo.394.3">However, each row, each column, and each 3x3 box can only contain unique numbers. </span><span class="koboSpan" id="kobo.394.4">Surprise – this board forms a two-dimensional array! </span><span class="koboSpan" id="kobo.394.5">You can point to any place on the board by specifying its </span><em class="italic"><span class="koboSpan" id="kobo.395.1">row</span></em><span class="koboSpan" id="kobo.396.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.397.1">column</span></em><span class="koboSpan" id="kobo.398.1">, the same as in the case of a two-dimensional array. </span><span class="koboSpan" id="kobo.398.2">And if you are a bit tired of solving such puzzles with a pencil and a piece of paper, take a look at </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.399.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.400.1">, </span><em class="italic"><span class="koboSpan" id="kobo.401.1">See in Action</span></em><span class="koboSpan" id="kobo.402.1">, where you will learn how to create an algorithm for solving a </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">Sudoku puzzle!</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">An example two-dimensional array that stores integer values is </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.406.1"><img alt="Figure 3.2 – Example of a two-dimensional array" src="image/B18069_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.407.1">Figure 3.2 – Example of a two-dimensional array</span></p>
<p><span class="koboSpan" id="kobo.408.1">First, you need to declare and initialize a two-dimensional array with </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">5</span></strong><span class="koboSpan" id="kobo.410.1"> rows and </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">3</span></strong><span class="koboSpan" id="kobo.412.1"> columns, as shown in the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
int</span><strong class="bold"><span class="koboSpan" id="kobo.415.1">[,]</span></strong><span class="koboSpan" id="kobo.416.1"> numbers = new int</span><strong class="bold"><span class="koboSpan" id="kobo.417.1">[5, 3]</span></strong><span class="koboSpan" id="kobo.418.1">;
numbers</span><strong class="bold"><span class="koboSpan" id="kobo.419.1">[0, 0]</span></strong><span class="koboSpan" id="kobo.420.1"> = 9; (...)</span></pre> <p><span class="koboSpan" id="kobo.421.1">You can combine a declaration with an initialization in a bit different way </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
int[,] numbers = new int[,]
{ 
    </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">{ 9, 5, -9 }, </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.425.1">    { -11, 4, 0 }, </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.426.1">    { 6, 115, 3 }, </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.427.1">    { -12, -9, 71 }, </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.428.1">    { 1, -6, -1 }</span></strong><span class="koboSpan" id="kobo.429.1"> 
};</span></pre> <p><span class="koboSpan" id="kobo.430.1">A small explanation is </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.431.1">necessary for the way you access particular elements from a two-dimensional array. </span><span class="koboSpan" id="kobo.431.2">Let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
int number = numbers</span><strong class="bold"><span class="koboSpan" id="kobo.434.1">[2, 1]</span></strong><span class="koboSpan" id="kobo.435.1">;
numbers</span><strong class="bold"><span class="koboSpan" id="kobo.436.1">[1, 0]</span></strong><span class="koboSpan" id="kobo.437.1"> = 11;</span></pre> <p><span class="koboSpan" id="kobo.438.1">In the first line of code, the value from the third row (index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">2</span></strong><span class="koboSpan" id="kobo.440.1">) and second column (index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">1</span></strong><span class="koboSpan" id="kobo.442.1">) is obtained (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">115</span></strong><span class="koboSpan" id="kobo.444.1">) and set as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">number</span></strong><span class="koboSpan" id="kobo.446.1"> variable. </span><span class="koboSpan" id="kobo.446.2">The other line replaces </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">-11</span></strong><span class="koboSpan" id="kobo.448.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">11</span></strong><span class="koboSpan" id="kobo.450.1"> in the second row and the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">first column.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Now that you’ve learned about one-dimensional and two-dimensional arrays, let’s proceed to three-dimensional ones. </span><span class="koboSpan" id="kobo.452.2">Do you know how to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">this structure?</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.454.1">Imagine a three-dimensional array</span></p>
<p class="callout"><span class="koboSpan" id="kobo.455.1">If you want to better imagine a </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.456.1">three-dimensional array, launch a game in which you can create buildings from blocks. </span><span class="koboSpan" id="kobo.456.2">You place each of them in a specified location on the board, in </span><em class="italic"><span class="koboSpan" id="kobo.457.1">X</span></em><span class="koboSpan" id="kobo.458.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.459.1">Y</span></em><span class="koboSpan" id="kobo.460.1"> coordinates. </span><span class="koboSpan" id="kobo.460.2">However, you can also build the next building floors, so you can specify the block’s </span><em class="italic"><span class="koboSpan" id="kobo.461.1">Z</span></em><span class="koboSpan" id="kobo.462.1"> coordinate as well. </span><span class="koboSpan" id="kobo.462.2">In such circumstances, you operate in a three-dimensional world with </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">three-dimensional arrays!</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">An example three-dimensional array is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.466.1"><img alt="Figure 3.3 – Example of a three-dimensional array" src="image/B18069_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Figure 3.3 – Example of a three-dimensional array</span></p>
<p><span class="koboSpan" id="kobo.468.1">If you want to create a three-dimensional array, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
int</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">[,,]</span></strong><span class="koboSpan" id="kobo.472.1"> numbers = new int</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">[3, 2, 3]</span></strong><span class="koboSpan" id="kobo.474.1">;</span></pre> <p><span class="koboSpan" id="kobo.475.1">The remaining operations can</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.476.1"> be performed similarly as in the case of arrays with a different number of dimensions. </span><span class="koboSpan" id="kobo.476.2">Of course, you need to specify three indices while accessing a particular element of </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the array.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">So far, you’ve learned about one-, two-, and three-dimensional arrays. </span><span class="koboSpan" id="kobo.478.2">But is it possible to use four-dimensional arrays? </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">Of course!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.480.1">Imagine a four-dimensional array</span></p>
<p class="callout"><span class="koboSpan" id="kobo.481.1">Imagining a four-dimensional array is not very </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.482.1">easy, but let’s try to do so! </span><span class="koboSpan" id="kobo.482.2">Once again, think about the three-dimensional game board we mentioned previously, but with content that changes depending on your level in the game. </span><span class="koboSpan" id="kobo.482.3">In this way, you can access a particular block in the three-dimensional world using </span><em class="italic"><span class="koboSpan" id="kobo.483.1">X</span></em><span class="koboSpan" id="kobo.484.1">, </span><em class="italic"><span class="koboSpan" id="kobo.485.1">Y</span></em><span class="koboSpan" id="kobo.486.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.487.1">Z</span></em><span class="koboSpan" id="kobo.488.1"> coordinates. </span><span class="koboSpan" id="kobo.488.2">To get a target value, you need to use another dimension, namely by providing your current level. </span><span class="koboSpan" id="kobo.488.3">In this way, you will get different results depending on the fourth dimension. </span><span class="koboSpan" id="kobo.488.4">Not so </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">difficult, right?</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">You can declare such an array using the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
int</span><strong class="bold"><span class="koboSpan" id="kobo.493.1">[,,,]</span></strong><span class="koboSpan" id="kobo.494.1"> numbers = new int</span><strong class="bold"><span class="koboSpan" id="kobo.495.1">[5, 4, 3, 2]</span></strong><span class="koboSpan" id="kobo.496.1">;</span></pre> <p><span class="koboSpan" id="kobo.497.1">If you need more dimensions, you can apply them. </span><span class="koboSpan" id="kobo.497.2">However, please keep in mind that using more dimensions can be</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.498.1"> quite difficult to understand and your code can be more difficult to follow and maintain in </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">With this introduction to the topic of multi-dimensional arrays out of the way, let’s proceed to some examples. </span><span class="koboSpan" id="kobo.500.2">They will show you how to use such data structures in t</span><a id="_idTextAnchor097"/><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.501.1">he </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">real world.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.503.1">Example – multiplication table</span></h2>
<p><span class="koboSpan" id="kobo.504.1">This first example shows basic operations being </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.505.1">performed on a two-dimensional array to present a multiplication table. </span><span class="koboSpan" id="kobo.505.2">It stores the results of the multiplication of all integer values in the range from </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">1</span></strong><span class="koboSpan" id="kobo.507.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">10</span></strong><span class="koboSpan" id="kobo.509.1"> in the array and present them in </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.511.1">
 1   2   3   4   5   6   7   8   9  10
 2   4   6   8  10  12  14  16  18  20
 3   6   9  12  15  18  21  24  27  30
 4   8  12  16  20  24  28  32  36  40
 5  10  15  20  25  30  35  40  45  50
 6  12  18  24  30  36  42  48  54  60
 7  14  21  28  35  42  49  56  63  70
 8  16  24  32  40  48  56  64  72  80
 9  18  27  36  45  54  63  72  81  90
10  20  30  40  50  60  70  80  90 100</span></pre> <p><span class="koboSpan" id="kobo.512.1">Let’s take a look at the declaration and initialization of </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
int[,] results = new int[10, 10];</span></pre> <p><span class="koboSpan" id="kobo.515.1">Here, a two-dimensional array with </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">10</span></strong><span class="koboSpan" id="kobo.517.1"> rows and </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">10</span></strong><span class="koboSpan" id="kobo.519.1"> columns is created and its elements are initialized to default values – that is, to zeros. </span><span class="koboSpan" id="kobo.519.2">When the array is ready, you fill it with the results of the multiplication, as well as present the result in the console. </span><span class="koboSpan" id="kobo.519.3">Such a task can be performed using two </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">for</span></strong><span class="koboSpan" id="kobo.521.1"> loops, as </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
for (int i = 0; i &lt; </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">results.GetLength(0)</span></strong><span class="koboSpan" id="kobo.525.1">; i++)
{
    for (int j = 0; j &lt; </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">results.GetLength(1)</span></strong><span class="koboSpan" id="kobo.527.1">; j++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">results[i, j] = (i + 1) * (j + 1);</span></strong><span class="koboSpan" id="kobo.529.1">
        Console.Write($"{</span><strong class="bold"><span class="koboSpan" id="kobo.530.1">results[i, j]</span></strong><span class="koboSpan" id="kobo.531.1">,4}");
    }
    Console.WriteLine();
}</span></pre> <p><span class="koboSpan" id="kobo.532.1">In the preceding code, you can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">GetLength</span></strong><span class="koboSpan" id="kobo.534.1"> method, which is called on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">results</span></strong><span class="koboSpan" id="kobo.536.1"> array. </span><span class="koboSpan" id="kobo.536.2">This method returns the number of elements in a particular dimension – that is, the first (when passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">0</span></strong><span class="koboSpan" id="kobo.538.1"> as the parameter) and the second (</span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">1</span></strong><span class="koboSpan" id="kobo.540.1"> as the parameter). </span><span class="koboSpan" id="kobo.540.2">In both cases, a </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.541.1">value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">10</span></strong><span class="koboSpan" id="kobo.543.1"> is returned, according to the values specified during the array’s initialization. </span><span class="koboSpan" id="kobo.543.2">Another important part of the code is the way of setting the value of an element. </span><span class="koboSpan" id="kobo.543.3">To do so, you must provide </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">two indices.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">The multiplication results, after converting them into </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">string</span></strong><span class="koboSpan" id="kobo.547.1"> values, have different lengths, from one character (as in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">4</span></strong><span class="koboSpan" id="kobo.549.1"> as a result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">2*2</span></strong><span class="koboSpan" id="kobo.551.1">) to three (</span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">100</span></strong><span class="koboSpan" id="kobo.553.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">10*10</span></strong><span class="koboSpan" id="kobo.555.1">). </span><span class="koboSpan" id="kobo.555.2">To improve their presentation, you need to write each result in </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">4</span></strong><span class="koboSpan" id="kobo.557.1"> characters. </span><span class="koboSpan" id="kobo.557.2">Therefore, if an integer value takes less space, leading spaces should be added. </span><span class="koboSpan" id="kobo.557.3">As an example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">1</span></strong><span class="koboSpan" id="kobo.559.1"> will be shown with three leading spaces (</span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">___1</span></strong><span class="koboSpan" id="kobo.561.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">_</span></strong><span class="koboSpan" id="kobo.563.1"> is a space), while </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">100</span></strong><span class="koboSpan" id="kobo.565.1"> will be shown with only one space (</span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">_100</span></strong><span class="koboSpan" id="kobo.567.1">). </span><span class="koboSpan" id="kobo.567.2">You can achieve this goal by using a proper composite format string (namely, </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">,4</span></strong><span class="koboSpan" id="kobo.569.1">) within the </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">inte</span><a id="_idTextAnchor100"/><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.571.1">rpolated string.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.572.1">Example – game map</span></h2>
<p><span class="koboSpan" id="kobo.573.1">Another example is a program that presents a map of a game. </span><span class="koboSpan" id="kobo.573.2">This map is a rectangle with 6 rows and 8 columns. </span><span class="koboSpan" id="kobo.573.3">Each element </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.574.1">of the array specifies a type of terrain as grass, sand, water, or brick (also referred to as wall). </span><span class="koboSpan" id="kobo.574.2">Each place on the map should be shown in a particular color (such as green for grass), as well as using a custom character that depicts the terrain type (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">≈</span></strong><span class="koboSpan" id="kobo.576.1"> for water), as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.578.1"><img alt="Figure 3.4 – ﻿Screenshot of the game map example" src="image/B18069_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.579.1">Figure 3.4 – Screenshot of the game map example</span></p>
<p><span class="koboSpan" id="kobo.580.1">Let’s start by creating two auxiliary methods that make it possible to get a particular color and character depending on the terrain’s type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">GetColor</span></strong><span class="koboSpan" id="kobo.582.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">GetChar</span></strong><span class="koboSpan" id="kobo.584.1">, respectively). </span><span class="koboSpan" id="kobo.584.2">The code for these </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.585.1">methods is </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.587.1">
ConsoleColor </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">GetColor</span></strong><span class="koboSpan" id="kobo.589.1">(char terrain)
{
    return terrain switch
    {
        'g' =&gt; ConsoleColor.Green,
        's' =&gt; ConsoleColor.Yellow,
        'w' =&gt; ConsoleColor.Blue,
        _ =&gt; ConsoleColor.DarkGray
    };
}
char </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">GetChar</span></strong><span class="koboSpan" id="kobo.591.1">(char terrain)
{
    return terrain switch
    {
        'g' =&gt; '\u201c',
        's' =&gt; '\u25cb',
        'w' =&gt; '\u2248',
        _ =&gt; '\u25cf'
    };
}</span></pre> <p><span class="koboSpan" id="kobo.592.1">As you can see, the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">GetColor</span></strong><span class="koboSpan" id="kobo.594.1"> method is self-explanatory. </span><span class="koboSpan" id="kobo.594.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">GetChar</span></strong><span class="koboSpan" id="kobo.596.1"> method returns a proper Unicode character depending on the character’s value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">g</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">s</span></strong><span class="koboSpan" id="kobo.600.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">w</span></strong><span class="koboSpan" id="kobo.602.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">b</span></strong><span class="koboSpan" id="kobo.604.1">). </span><span class="koboSpan" id="kobo.604.2">For example, in the case of water, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">'\u2248'</span></strong><span class="koboSpan" id="kobo.606.1"> value is returned, which is </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.607.1">a representation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">≈</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.609.1">character.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">Let’s take a look at the remaining part of the code. </span><span class="koboSpan" id="kobo.610.2">Here, you configure the map, as well as present it in the console. </span><span class="koboSpan" id="kobo.610.3">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
using System.Text;
char[,] map =
{
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 's', 's', 'b', 'b', 'b' },
    { 's', 's', 's', 's', 's', 'b', 's', 's' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' }
};
Console.OutputEncoding = </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Encoding.UTF8</span></strong><span class="koboSpan" id="kobo.614.1">;
for (int r = 0; r &lt; map.GetLength(0); r++)
{
    for (int c = 0; c &lt; map.GetLength(1); c++)
    {
        Console.ForegroundColor = </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">GetColor(map[r, c])</span></strong><span class="koboSpan" id="kobo.616.1">;
        Console.Write(</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">GetChar(map[r, c])</span></strong><span class="koboSpan" id="kobo.618.1"> + " ");
    }
    Console.WriteLine();
}
Console.ResetColor(); </span></pre> <p><span class="koboSpan" id="kobo.619.1">This code should not require additional comments or explanations. </span><span class="koboSpan" id="kobo.619.2">Just keep in mind that to use Unicode values in the console output, don’t forget to choose the UTF-8 encoding by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Encoding.UTF8</span></strong><span class="koboSpan" id="kobo.621.1"> value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">OutputEncoding</span></strong><span class="koboSpan" id="kobo.623.1"> property. </span><span class="koboSpan" id="kobo.623.2">You can set the foreground </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.624.1">color for the console using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">ForegroundColor</span></strong><span class="koboSpan" id="kobo.626.1"> property. </span><span class="koboSpan" id="kobo.626.2">If you want to reset such a color to the default one, just call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">ResetColor</span></strong><span class="koboSpan" id="kobo.628.1"> method, as presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">last line.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">So far, you’ve learned about both single- and multi-dimensional arrays, but one more variant remains to be presented in this book, namely jagged arrays. </span><span class="koboSpan" id="kobo.630.2">Let’s continue reading to lea</span><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.631.1">rn more </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">about them.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.633.1">Jagged arrays</span></h1>
<p><span class="koboSpan" id="kobo.634.1">The last variant of arrays to be described in this book is </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">jagged arrays</span></strong><span class="koboSpan" id="kobo.636.1">, also referred to as an </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">array of arrays</span></strong><span class="koboSpan" id="kobo.638.1">. </span><span class="koboSpan" id="kobo.638.2">It sounds complicated, but</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.639.1"> fortunately, it is very simple. </span><span class="koboSpan" id="kobo.639.2">A jagged array can be understood as </span><strong class="bold"><span class="koboSpan" id="kobo.640.1">a single-dimensional array, where each element is another array</span></strong><span class="koboSpan" id="kobo.641.1">. </span><span class="koboSpan" id="kobo.641.2">Of </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.642.1">course, such inner arrays can have different lengths or they can even be </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">not initialized.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.644.1">Imagine a jagged array</span></p>
<p class="callout"><span class="koboSpan" id="kobo.645.1">If you want to better imagine a jagged array, stop reading this book for a moment, open your calendar, and switch its view so that it presents the whole year. </span><span class="koboSpan" id="kobo.645.2">It contains 365 or 366 boxes, depending on the year. </span><span class="koboSpan" id="kobo.645.3">For each day, you have a different number of meetings. </span><span class="koboSpan" id="kobo.645.4">On some days, you have three meetings, while on others, only one or even zero. </span><span class="koboSpan" id="kobo.645.5">Your holidays are marked in the calendar and blocked for meetings. </span><span class="koboSpan" id="kobo.645.6">You can easily imagine an application of a jagged array in this case. </span><span class="koboSpan" id="kobo.645.7">Each day box is an element of this array and it contains an array with data of meetings organized on a particular day. </span><span class="koboSpan" id="kobo.645.8">If this day is during your holidays, a related item is not initialized. </span><span class="koboSpan" id="kobo.645.9">This makes a jagged array much easier </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">to visualize.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">An example jagged array is</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.648.1"> presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 3.5 – Example of a jagged array" src="image/B18069_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 3.5 – Example of a jagged array</span></p>
<p><span class="koboSpan" id="kobo.652.1">This jagged array contains four</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.653.1"> elements. </span><span class="koboSpan" id="kobo.653.2">The first has an array with two elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">9</span></strong><span class="koboSpan" id="kobo.655.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">5</span></strong><span class="koboSpan" id="kobo.657.1">). </span><span class="koboSpan" id="kobo.657.2">The second element has an array with three elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">0</span></strong><span class="koboSpan" id="kobo.659.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">-3</span></strong><span class="koboSpan" id="kobo.661.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">12</span></strong><span class="koboSpan" id="kobo.663.1">). </span><span class="koboSpan" id="kobo.663.2">The third is not initialized (</span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">null</span></strong><span class="koboSpan" id="kobo.665.1">), while the last one is an array with only one </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">element (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">54</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">Before proceeding to the example, it is worth mentioning the way of declaring and initializing a jagged array since it is a bit different from the arrays we’ve already described. </span><span class="koboSpan" id="kobo.669.2">Let’s take a look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
int</span><strong class="bold"><span class="koboSpan" id="kobo.672.1">[][]</span></strong><span class="koboSpan" id="kobo.673.1"> numbers = </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">new int[4][]</span></strong><span class="koboSpan" id="kobo.675.1">; 
numbers[0] = </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">new int[] { 9, 5 }</span></strong><span class="koboSpan" id="kobo.677.1">; 
numbers[1] = </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">new int[] { 0, -3, 12 }</span></strong><span class="koboSpan" id="kobo.679.1">; 
numbers[3] = </span><strong class="bold"><span class="koboSpan" id="kobo.680.1">new int[] { 54 }</span></strong><span class="koboSpan" id="kobo.681.1">; </span></pre> <p><span class="koboSpan" id="kobo.682.1">This code can be simplified with a collection expression, </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
int[][] numbers = new int[4][];
numbers[0] = </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">[9, 5]</span></strong><span class="koboSpan" id="kobo.686.1">;
numbers[1] = </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">[0, -3, 12]</span></strong><span class="koboSpan" id="kobo.688.1">;
numbers[3] = </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">[54]</span></strong><span class="koboSpan" id="kobo.690.1">;</span></pre> <p><span class="koboSpan" id="kobo.691.1">In the first line, we declare a single-dimensional array with four elements. </span><span class="koboSpan" id="kobo.691.2">Each element is another single-dimensional array of integer values. </span><span class="koboSpan" id="kobo.691.3">When the first line is executed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">numbers</span></strong><span class="koboSpan" id="kobo.693.1"> array is initialized with default</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.694.1"> values, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">null</span></strong><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">For this reason, we need to manually initialize particular elements, as shown in the following three lines of code. </span><span class="koboSpan" id="kobo.696.3">It is worth noting that the third element is </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">not initialized.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">You can also write the preceding code in a different way, as </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
int[][] numbers =
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">new int[] { 9, 5 },</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.702.1">    new int[] { 0, -3, 12 },</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.703.1">    null!,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.704.1">    new int[] { 54 }</span></strong><span class="koboSpan" id="kobo.705.1">
};</span></pre> <p><span class="koboSpan" id="kobo.706.1">That’s not all – an even shorter variant </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">is available:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.708.1">
int[][] numbers =
[
    </span><strong class="bold"><span class="koboSpan" id="kobo.709.1">[9, 5],</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.710.1">    [0, -3, 12],</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.711.1">    null!,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.712.1">    [54]</span></strong><span class="koboSpan" id="kobo.713.1">
];</span></pre> <p><span class="koboSpan" id="kobo.714.1">How can you access a particular element from a jagged array? </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">Let’s see:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
int number = numbers</span><strong class="bold"><span class="koboSpan" id="kobo.717.1">[1][2]</span></strong><span class="koboSpan" id="kobo.718.1">;
numbers</span><strong class="bold"><span class="koboSpan" id="kobo.719.1">[1][1]</span></strong><span class="koboSpan" id="kobo.720.1"> = 50;</span></pre> <p><span class="koboSpan" id="kobo.721.1">The first line of code sets the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">number</span></strong><span class="koboSpan" id="kobo.723.1"> variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">12</span></strong><span class="koboSpan" id="kobo.725.1"> – that is, to the value of the third element (index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">2</span></strong><span class="koboSpan" id="kobo.727.1">) from the array, which is the second element of the jagged array. </span><span class="koboSpan" id="kobo.727.2">The other line changes the value of the second element within the array, which is the second element </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.728.1">of the jagged array, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">-3</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.730.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">50</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">Now that we’ve introduced jagged arrays, l</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.734.1">et’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">an example.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.736.1">Example – yearly transport plan</span></h2>
<p><span class="koboSpan" id="kobo.737.1">In this example, you’ll learn how to develop a program that creates a plan for your transportation for the whole year. </span><span class="koboSpan" id="kobo.737.2">For each day of each month, the application draws one of the available means of </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.738.1">transport, such as by car, by bus, by subway, by bike, or simply on foot. </span><span class="koboSpan" id="kobo.738.2">In the end, the program presents the generated plan, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.740.1"><img alt="Figure 3.6 – Screenshot of the yearly transport plan example" src="image/B18069_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.741.1">Figure 3.6 – Screenshot of the yearly transport plan example</span></p>
<p><span class="koboSpan" id="kobo.742.1">First, let’s declare the enumeration type with constants representing types </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">of transport:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.744.1">
public enum </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">MeanEnum</span></strong><span class="koboSpan" id="kobo.746.1"> { Car, Bus, Subway, Bike, Walk }</span></pre> <p><span class="koboSpan" id="kobo.747.1">The next part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
Random random = new();
int meansCount = Enum.GetNames&lt;MeanEnum&gt;().Length;
int year = DateTime.Now.Year;
</span><strong class="bold"><span class="koboSpan" id="kobo.750.1">MeanEnum[][] means = new MeanEnum[12][];</span></strong><span class="koboSpan" id="kobo.751.1">
for (int m = 1; m &lt;= 12; m++)
{
    int daysCount = DateTime.DaysInMonth(year, m);
    </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">means[m - 1] = new MeanEnum[daysCount];</span></strong><span class="koboSpan" id="kobo.753.1">
    for (int d = 1; d &lt;= daysCount; d++)
    {
        int mean = random.Next(meansCount);
        </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">means[m - 1][d - 1] = (MeanEnum)mean;</span></strong><span class="koboSpan" id="kobo.755.1">
    }
} </span></pre> <p><span class="koboSpan" id="kobo.756.1">First, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Random</span></strong><span class="koboSpan" id="kobo.758.1"> class is created. </span><span class="koboSpan" id="kobo.758.2">This will be used to draw a suitable means of transport from the </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.759.1">available ones. </span><span class="koboSpan" id="kobo.759.2">In the next line, we get the number of available transport types. </span><span class="koboSpan" id="kobo.759.3">Then, the jagged array is created. </span><span class="koboSpan" id="kobo.759.4">It is assumed that it has </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">12</span></strong><span class="koboSpan" id="kobo.761.1"> elements, representing all months in the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">current year.</span></span></p>
<p><span class="koboSpan" id="kobo.763.1">Next, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">for</span></strong><span class="koboSpan" id="kobo.765.1"> loop is used to iterate through all the months within the year. </span><span class="koboSpan" id="kobo.765.2">In each iteration, the number of days is obtained using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">DaysInMonth</span></strong><span class="koboSpan" id="kobo.767.1"> static method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">DateTime</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">Each element of the jagged array is a single-dimensional array with </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">MeanEnum</span></strong><span class="koboSpan" id="kobo.771.1"> values. </span><span class="koboSpan" id="kobo.771.2">The length of such an inner array depends on the number of days in a month. </span><span class="koboSpan" id="kobo.771.3">For instance, it is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">31</span></strong><span class="koboSpan" id="kobo.773.1"> elements for January and </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">30</span></strong><span class="koboSpan" id="kobo.775.1"> elements </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">for April.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">The next </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">for</span></strong><span class="koboSpan" id="kobo.779.1"> loop iterates through all the days of the month. </span><span class="koboSpan" id="kobo.779.2">Within this loop, you draw a transport type and set it as a value of a suitable element within an array that is an element of the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">jagged array.</span></span></p>
<p><span class="koboSpan" id="kobo.781.1">The next part of the code is related to presenting the plan in </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
string[] months = GetMonthNames();
int nameLength = months.Max(n =&gt; n.Length) + 2;
</span><strong class="bold"><span class="koboSpan" id="kobo.784.1">for (int m = 1; m &lt;= 12; m++)</span></strong><span class="koboSpan" id="kobo.785.1">
{
    string month = months[m - 1];
    Console.Write($"{month}:".PadRight(nameLength));
    </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">for (int d = 1; d &lt;= means[m - 1].Length; d++)</span></strong><span class="koboSpan" id="kobo.787.1">
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.788.1">MeanEnum mean = means[m - 1][d - 1];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.789.1">        (char character, ConsoleColor color) = Get(mean);</span></strong><span class="koboSpan" id="kobo.790.1">
        Console.ForegroundColor = ConsoleColor.White;
        Console.BackgroundColor = color;
        Console.Write(character);
        Console.ResetColor();
        Console.Write(" ");
    }
    Console.WriteLine();
} </span></pre> <p><span class="koboSpan" id="kobo.791.1">First, a single-dimensional</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.792.1"> array with month names is created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">GetMonthNames</span></strong><span class="koboSpan" id="kobo.794.1"> method, which will be presented and described later. </span><span class="koboSpan" id="kobo.794.2">Then, a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">nameLength</span></strong><span class="koboSpan" id="kobo.796.1"> variable is set to the maximum necessary length of text for storing the month name. </span><span class="koboSpan" id="kobo.796.2">To do so, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">Max</span></strong><span class="koboSpan" id="kobo.798.1"> extension method is used to find the maximum length of text from the collection with names of months. </span><span class="koboSpan" id="kobo.798.2">The obtained result is increased by </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">2</span></strong><span class="koboSpan" id="kobo.800.1"> to reserve space for a colon and </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">a space.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">for</span></strong><span class="koboSpan" id="kobo.804.1"> loop is used to iterate through all the elements of the jagged array – that is, through all months. </span><span class="koboSpan" id="kobo.804.2">In each iteration, the month’s name is presented in the console. </span><span class="koboSpan" id="kobo.804.3">The next </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">for</span></strong><span class="koboSpan" id="kobo.806.1"> loop is used to iterate through all the items of the current element of the jagged array – that is, through all the days of the month. </span><span class="koboSpan" id="kobo.806.2">For each day, proper colors are set (for the foreground and background), and a suitable character is shown. </span><span class="koboSpan" id="kobo.806.3">Both a color and a character are returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">Get</span></strong><span class="koboSpan" id="kobo.808.1"> method, taking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">MeanEnum</span></strong><span class="koboSpan" id="kobo.810.1"> value as a parameter. </span><span class="koboSpan" id="kobo.810.2">This method will be</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.811.1"> shown a </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">bit later.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">Now, let’s take a look at the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">GetMonthNames</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
string[] </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">GetMonthNames</span></strong><span class="koboSpan" id="kobo.818.1">()
{
    CultureInfo culture = new("en");
    string[] names = new string[12];
    foreach (int m in </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">Enumerable.Range(1, 12)</span></strong><span class="koboSpan" id="kobo.820.1">)
    {
        DateTime firstDay = new(DateTime.Now.Year, m, 1);
        string name = firstDay.ToString("MMMM", culture);
        names[m - 1] = name;
    }
    return names;
} </span></pre> <p><span class="koboSpan" id="kobo.821.1">This code is self-explanatory, but let’s focus on the line where we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">Range</span></strong><span class="koboSpan" id="kobo.823.1"> method. </span><span class="koboSpan" id="kobo.823.2">It returns a collection of</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.824.1"> integer values from </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">1</span></strong><span class="koboSpan" id="kobo.826.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">12</span></strong><span class="koboSpan" id="kobo.828.1">. </span><span class="koboSpan" id="kobo.828.2">Therefore, we can use it together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">foreach</span></strong><span class="koboSpan" id="kobo.830.1"> loop, instead of a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">for</span></strong><span class="koboSpan" id="kobo.832.1"> loop iterating from </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">1</span></strong><span class="koboSpan" id="kobo.834.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">12</span></strong><span class="koboSpan" id="kobo.836.1">. </span><span class="koboSpan" id="kobo.836.2">Just think about it as an alternative way of solving the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">same problem.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">Finally, it is worth mentioning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Get</span></strong><span class="koboSpan" id="kobo.840.1"> method. </span><span class="koboSpan" id="kobo.840.2">It allows us to use one method instead of two, namely returning a character and a color for a given transport type. </span><span class="koboSpan" id="kobo.840.3">By returning data as a value tuple, the code is shorter and simpler, as </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.842.1">(char Char, ConsoleColor Color) Get</span></strong><span class="koboSpan" id="kobo.843.1">(MeanEnum mean)
{
    return mean switch
    {
        MeanEnum.Bike =&gt; ('B', ConsoleColor.Blue),
        MeanEnum.Bus =&gt; ('U', ConsoleColor.DarkGreen),
        MeanEnum.Car =&gt; ('C', ConsoleColor.Red),
        MeanEnum.Subway =&gt; ('S', ConsoleColor.Magenta),
        MeanEnum.Walk =&gt; ('W', ConsoleColor.DarkYellow),
        _ =&gt; throw new Exception("Unknown type")
    };
}</span></pre> <p><span class="koboSpan" id="kobo.844.1">Arrays are everywhere in this chapter! </span><span class="koboSpan" id="kobo.844.2">Now that we’ve learned about this data structure and its C# implementation-related topics, we can focus on some algorithms that are strictly related to arrays, namely </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.845.1">sorting algorithms. </span><span class="koboSpan" id="kobo.845.2">Are you ready to get to know a few of them? </span><span class="koboSpan" id="kobo.845.3">If so, let’s </span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.846.1">proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">next section.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.848.1">Sorting algorithms</span></h1>
<p><span class="koboSpan" id="kobo.849.1">Many algorithms use arrays for a very broad range of applications. </span><span class="koboSpan" id="kobo.849.2">However, one of the most common tasks is </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">sorting an array to arrange its elements in the correct order, either ascending or descending</span></strong><span class="koboSpan" id="kobo.851.1">. </span><span class="koboSpan" id="kobo.851.2">Of course, you can sort data of various types, including numbers, strings, or even instances of </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.852.1">user-defined classes. </span><span class="koboSpan" id="kobo.852.2">However, to keep things a bit simpler, here, we will only focus on sorting </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">integer values.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.854.1">Imagine a sorting algorithm</span></p>
<p class="callout"><span class="koboSpan" id="kobo.855.1">You benefit from the sorting procedure frequently in your daily life! </span><span class="koboSpan" id="kobo.855.2">For example, your inbox is sorted in a way to present the newest messages first (by sending date in descending order), your calendar presents a day plan sorted by hours (by event start date in ascending order), as well as your list of tasks shows entries from the most important to the least important (by priority in descending order). </span><span class="koboSpan" id="kobo.855.3">That’s not all – at work, you sort documents by their issue date, then you choose a suitable road to home from the variants sorted by time to reach the destination, and in the evening, you change programs on the TV using a remote control according to the predefined order </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">of channels.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">Sorting algorithms involve many approaches and are also a popular subject of research. </span><span class="koboSpan" id="kobo.857.2">There are a lot of sorting</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.858.1"> types, including selection sort, insertion sort, bubble sort, merge sort, Shell sort, quicksort, and heap sort. </span><span class="koboSpan" id="kobo.858.2">These will be expla</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.859.1">ined in detail in this chapter. </span><span class="koboSpan" id="kobo.859.2">However, these are not all of the available approaches. </span><span class="koboSpan" id="kobo.859.3">Various types differ in their performance results, which is one of the most important aspects that you should take into account while choosing your sorting implementation. </span><span class="koboSpan" id="kobo.859.4">This topic will be analyzed at the end of this chapter to give you some tips in </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">this area.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.861.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.862.1">Array sorting is a popular topic that’s presented in various resources in books and research papers, as well as online. </span><span class="koboSpan" id="kobo.862.2">For example, you can read more about sorting algorithms presented in this chapter at Wikipedia, as well as you can take a look at some implementation codes at Wikibooks. </span><span class="koboSpan" id="kobo.862.3">You can browse for more information about the merge sort at </span><a href="https://en.wikipedia.org/wiki/Merge_sort"><span class="koboSpan" id="kobo.863.1">https://en.wikipedia.org/wiki/Merge_sort</span></a><span class="koboSpan" id="kobo.864.1"> and </span><a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort"><span class="koboSpan" id="kobo.865.1">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort</span></a><span class="koboSpan" id="kobo.866.1">, about Shell sort at </span><a href="https://en.wikipedia.org/wiki/Shellsort"><span class="koboSpan" id="kobo.867.1">https://en.wikipedia.org/wiki/Shellsort</span></a><span class="koboSpan" id="kobo.868.1"> and </span><a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort"><span class="koboSpan" id="kobo.869.1">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort</span></a><span class="koboSpan" id="kobo.870.1">, about quicksort at </span><a href="https://en.wikipedia.org/wiki/Quicksort"><span class="koboSpan" id="kobo.871.1">https://en.wikipedia.org/wiki/Quicksort</span></a><span class="koboSpan" id="kobo.872.1"> and </span><a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort"><span class="koboSpan" id="kobo.873.1">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort</span></a><span class="koboSpan" id="kobo.874.1">, and about heap sort at </span><a href="https://en.wikipedia.org/wiki/Heapsort"><span class="koboSpan" id="kobo.875.1">https://en.wikipedia.org/wiki/Heapsort</span></a><span class="koboSpan" id="kobo.876.1"> and </span><a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort"><span class="koboSpan" id="kobo.877.1">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort</span></a><span class="koboSpan" id="kobo.878.1">. </span><span class="koboSpan" id="kobo.878.2">In a similar way, you can find information about other sorting algorithms. </span><span class="koboSpan" id="kobo.878.3">Of course, Wikipedia, together with Wikibooks, is not the only available source of content regarding such algorithms. </span><span class="koboSpan" id="kobo.878.4">There are a huge number of websites dedicated to this subject. </span><span class="koboSpan" id="kobo.878.5">Some of them also contain animations that show how various algorithms operate. </span><span class="koboSpan" id="kobo.878.6">This can help you visualize how </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">they work.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.880.1">Selection sort</span></h2>
<p><span class="koboSpan" id="kobo.881.1">Let’s start with </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">selection sort</span></strong><span class="koboSpan" id="kobo.883.1">, which is</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.884.1"> one of the simplest sorting algorithms. </span><strong class="bold"><span class="koboSpan" id="kobo.885.1">This algorithm divides the array into two parts, namely sorted and unsorted</span></strong><span class="koboSpan" id="kobo.886.1">. </span><span class="koboSpan" id="kobo.886.2">First, the</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.887.1"> sorted part is empty. </span><span class="koboSpan" id="kobo.887.2">In the following iterations, </span><strong class="bold"><span class="koboSpan" id="kobo.888.1">the algorithm finds the smallest element in the unsorted part and exchanges it with the first element in the unsorted part</span></strong><span class="koboSpan" id="kobo.889.1">. </span><span class="koboSpan" id="kobo.889.2">Thus, the sorted part increases by one element. </span><span class="koboSpan" id="kobo.889.3">This sounds quite simple, </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">doesn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">To better understand the selection sort algorithm, let’s take a look at the following iterations for an array with nine elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">-11</span></strong><span class="koboSpan" id="kobo.893.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">12</span></strong><span class="koboSpan" id="kobo.895.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">-42</span></strong><span class="koboSpan" id="kobo.897.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">0</span></strong><span class="koboSpan" id="kobo.899.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">1</span></strong><span class="koboSpan" id="kobo.901.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">90</span></strong><span class="koboSpan" id="kobo.903.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">68</span></strong><span class="koboSpan" id="kobo.905.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">6</span></strong><span class="koboSpan" id="kobo.907.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">-9</span></strong><span class="koboSpan" id="kobo.909.1">), as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">following </span></span><span class="No-Break"><a id="_idIndexMarker287"/></span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.912.1"><img alt="Figure 3.7 – Illustration of the selection sort algorithm" src="image/B18069_03_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.913.1">Figure 3.7 – Illustration of the selection sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.914.1">Bold lines are used to present </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.915.1">the borders between the sorted and unsorted parts of the array. </span><span class="koboSpan" id="kobo.915.2">First (</span><em class="italic"><span class="koboSpan" id="kobo.916.1">Step 1</span></em><span class="koboSpan" id="kobo.917.1">), the border is located just at the top of the array, which means that the sorted part is empty. </span><span class="koboSpan" id="kobo.917.2">Here, the algorithm finds the smallest value in the unsorted part (namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">-42</span></strong><span class="koboSpan" id="kobo.919.1">) and swaps it with the first element in this part (</span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">-11</span></strong><span class="koboSpan" id="kobo.921.1">). </span><span class="koboSpan" id="kobo.921.2">The result is shown in </span><em class="italic"><span class="koboSpan" id="kobo.922.1">Step 2</span></em><span class="koboSpan" id="kobo.923.1">, where the sorted part contains one element (</span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">-42</span></strong><span class="koboSpan" id="kobo.925.1">), while the unsorted part consists of eight elements. </span><span class="koboSpan" id="kobo.925.2">In the next step, the algorithm finds </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">-11</span></strong><span class="koboSpan" id="kobo.927.1"> as the smallest value in the unsorted part and swaps it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">12</span></strong><span class="koboSpan" id="kobo.929.1">, which is the first element in the unsorted part. </span><span class="koboSpan" id="kobo.929.2">As a result, the sorted part consists of two elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">-42</span></strong><span class="koboSpan" id="kobo.931.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">-11</span></strong><span class="koboSpan" id="kobo.933.1">, while the unsorted part contains only seven elements, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.934.1">Step 3</span></em><span class="koboSpan" id="kobo.935.1">. </span><span class="koboSpan" id="kobo.935.2">The aforementioned steps are performed a few times until only one element is left in the unsorted part. </span><span class="koboSpan" id="kobo.935.3">The final result is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.936.1">Step 9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">With that, you know how the selection sort algorithm works, but what role is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">i</span></strong><span class="koboSpan" id="kobo.940.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">m</span></strong><span class="koboSpan" id="kobo.942.1"> indicators shown on the left in the preceding diagram? </span><span class="koboSpan" id="kobo.942.2">They are related to the variables that are used in the implementation of this algorithm. </span><span class="koboSpan" id="kobo.942.3">So, it is time to see the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">C# language!</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">The implementation is created within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">Sort</span></strong><span class="koboSpan" id="kobo.946.1"> method, which takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">a</span></strong><span class="koboSpan" id="kobo.948.1"> array as the parameter and sorts it using </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">selection sort:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.950.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">Sort</span></strong><span class="koboSpan" id="kobo.952.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">for (int i = 0; i &lt; a.Length - 1; i++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.954.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.955.1">        int minIndex = i;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.956.1">        int minValue = a[i];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.957.1">        for (int j = i + 1; j &lt; a.Length; j++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.958.1">        {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.959.1">            if (a[j] &lt; minValue)</span></strong><span class="koboSpan" id="kobo.960.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.962.1">                minIndex = j;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.963.1">                minValue = a[j];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.964.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.965.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.966.1">        (a[i], a[minIndex]) = (a[minIndex], a[i]);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.967.1">    }</span></strong><span class="koboSpan" id="kobo.968.1">
}</span></pre> <p><span class="koboSpan" id="kobo.969.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">for</span></strong><span class="koboSpan" id="kobo.971.1"> loop is used to iterate through the elements until only one item is left in the unsorted part. </span><span class="koboSpan" id="kobo.971.2">Thus, the number of iterations</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.972.1"> of the loop is equal to the length of the array minus one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">a.Length - 1</span></strong><span class="koboSpan" id="kobo.974.1">). </span><span class="koboSpan" id="kobo.974.2">In each iteration, another </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">for</span></strong><span class="koboSpan" id="kobo.976.1"> loop is used to find the smallest value in the unsorted part (</span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">minValue</span></strong><span class="koboSpan" id="kobo.978.1">, from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">i + 1</span></strong><span class="koboSpan" id="kobo.980.1"> index until the end of the array), as well as to store an index of the smallest value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">minIndex</span></strong><span class="koboSpan" id="kobo.982.1">, referred to as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">m</span></strong><span class="koboSpan" id="kobo.984.1"> indicator in the preceding diagram). </span><span class="koboSpan" id="kobo.984.2">Finally, the smallest element in the unsorted part (with an index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">minIndex</span></strong><span class="koboSpan" id="kobo.986.1">) is swapped with the first element in the unsorted part (the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">i</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> index).</span></span></p>
<p><span class="koboSpan" id="kobo.989.1">That’s all! </span><span class="koboSpan" id="kobo.989.2">Let’s use the following code to test the implementation of the selection </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">sort algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
</span><strong class="bold"><span class="koboSpan" id="kobo.992.1">Sort(array);</span></strong><span class="koboSpan" id="kobo.993.1">
Console.WriteLine(string.Join(" | ", array));</span></pre> <p><span class="koboSpan" id="kobo.994.1">In the preceding code, an array is declared and initialized. </span><span class="koboSpan" id="kobo.994.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">Sort</span></strong><span class="koboSpan" id="kobo.996.1"> method is called, passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">array</span></strong><span class="koboSpan" id="kobo.998.1"> as a</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.999.1"> parameter. </span><span class="koboSpan" id="kobo.999.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">string</span></strong><span class="koboSpan" id="kobo.1001.1"> value is created by joining elements of the array, separated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">|</span></strong><span class="koboSpan" id="kobo.1003.1">. </span><span class="koboSpan" id="kobo.1003.2">The result is shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1005.1">
-42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90</span></pre> <p><span class="koboSpan" id="kobo.1006.1">Since we’re talking about various algorithms, one of the most important topics is computational complexity, especially</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.1007.1"> time complexity. </span><span class="koboSpan" id="kobo.1007.2">In the case of selection sort, both </span><strong class="bold"><span class="koboSpan" id="kobo.1008.1">the worst and the average time complexity is O(n</span></strong><span class="superscript"><span class="koboSpan" id="kobo.1009.1">2</span></span><strong class="bold"><span class="koboSpan" id="kobo.1010.1">)</span></strong><span class="koboSpan" id="kobo.1011.1">. </span><span class="koboSpan" id="kobo.1011.2">Why? </span><span class="koboSpan" id="kobo.1011.3">Let’s take a look at the code to answer this question. </span><span class="koboSpan" id="kobo.1011.4">There are two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">for</span></strong><span class="koboSpan" id="kobo.1013.1"> loops (one within the other), each iterating through many elements of the array, which contains </span><em class="italic"><span class="koboSpan" id="kobo.1014.1">n</span></em><span class="koboSpan" id="kobo.1015.1"> elements. </span><span class="koboSpan" id="kobo.1015.2">For this reason, the complexity is indicated </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">as </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1017.1">O(n</span></em></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.1018.1">2</span></span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1019.1">)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1021.1">A small reminder about computational complexity</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1022.1">You learned about computational complexity in the previous chapter. </span><span class="koboSpan" id="kobo.1022.2">As a quick reminder, there are a few variants, such as </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.1023.1">for the worst or average case. </span><span class="koboSpan" id="kobo.1023.2">This complexity can be interpreted as the number of basic operations that need to be performed by the algorithm, depending on the input size (</span><em class="italic"><span class="koboSpan" id="kobo.1024.1">n</span></em><span class="koboSpan" id="kobo.1025.1">). </span><span class="koboSpan" id="kobo.1025.2">The time complexity can be specified using Big O notation – for example, as </span><em class="italic"><span class="koboSpan" id="kobo.1026.1">O(n)</span></em><span class="koboSpan" id="kobo.1027.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1028.1">O(n</span></em><span class="superscript"><span class="koboSpan" id="kobo.1029.1">2</span></span><em class="italic"><span class="koboSpan" id="kobo.1030.1">)</span></em><span class="koboSpan" id="kobo.1031.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1032.1">O(n log(n))</span></em><span class="koboSpan" id="kobo.1033.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.1034.1">O(1)</span></em><span class="koboSpan" id="kobo.1035.1">. </span><span class="koboSpan" id="kobo.1035.2">As an example, the </span><em class="italic"><span class="koboSpan" id="kobo.1036.1">O(n)</span></em><span class="koboSpan" id="kobo.1037.1"> notation indicates that the number of operations increases linearly with the input </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">size (</span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1039.1">n</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">With that, you’ve learned about selection sort. </span><span class="koboSpan" id="kobo.1041.2">If you are interested in another approach to sorting, proceed to the next sec</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1042.1">t</span><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1043.1">ion, where insertion sort </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">is presented.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1045.1">Insertion sort</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1046.1">Insertion sort</span></strong><span class="koboSpan" id="kobo.1047.1"> is another algorithm that makes it</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.1048.1"> possible to sort a single-dimensional</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.1049.1"> array simply. </span><span class="koboSpan" id="kobo.1049.2">Here, </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">the array is divided into two parts, namely sorted and unsorted</span></strong><span class="koboSpan" id="kobo.1051.1">. </span><span class="koboSpan" id="kobo.1051.2">However, at the beginning, the first element is included in the sorted part. </span><span class="koboSpan" id="kobo.1051.3">In each iteration, </span><strong class="bold"><span class="koboSpan" id="kobo.1052.1">the algorithm takes the first element from the unsorted part and places it in a suitable location within the sorted part, to leave the sorted part in the correct order</span></strong><span class="koboSpan" id="kobo.1053.1">. </span><span class="koboSpan" id="kobo.1053.2">Such operations are repeated until the unsorted part </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">is empty.</span></span></p>
<p><span class="koboSpan" id="kobo.1055.1">As an example, let’s take a look </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.1056.1">at an illustration of sorting an array with</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.1057.1"> nine elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">-11</span></strong><span class="koboSpan" id="kobo.1059.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">12</span></strong><span class="koboSpan" id="kobo.1061.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">-42</span></strong><span class="koboSpan" id="kobo.1063.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">0</span></strong><span class="koboSpan" id="kobo.1065.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">1</span></strong><span class="koboSpan" id="kobo.1067.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">90</span></strong><span class="koboSpan" id="kobo.1069.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">68</span></strong><span class="koboSpan" id="kobo.1071.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">6</span></strong><span class="koboSpan" id="kobo.1073.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">-9</span></strong><span class="koboSpan" id="kobo.1075.1">) using </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">insertion sort:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.1077.1"><img alt="Figure 3.8 – Illustration of the insertion sort algorithm" src="image/B18069_03_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1078.1">Figure 3.8 – Illustration of the insertion sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1079.1">First, only one element (namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">-11</span></strong><span class="koboSpan" id="kobo.1081.1">) is located in the sorted part (</span><em class="italic"><span class="koboSpan" id="kobo.1082.1">Step 1</span></em><span class="koboSpan" id="kobo.1083.1">). </span><span class="koboSpan" id="kobo.1083.2">Then, you take the first element from the unsorted part (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">12</span></strong><span class="koboSpan" id="kobo.1085.1">). </span><span class="koboSpan" id="kobo.1085.2">In this case, the location of this element does not need to be changed, so the sorted part is increased to two elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">-11</span></strong><span class="koboSpan" id="kobo.1087.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">12</span></strong><span class="koboSpan" id="kobo.1089.1">. </span><span class="koboSpan" id="kobo.1089.2">Then, you take </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">-42</span></strong><span class="koboSpan" id="kobo.1091.1"> as the first element in the unsorted part and you move it to the correct location in the sorted part. </span><span class="koboSpan" id="kobo.1091.2">To do so, you need to perform two swap operations, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.1092.1">Step 2</span></em><span class="koboSpan" id="kobo.1093.1">. </span><span class="koboSpan" id="kobo.1093.2">Thus, the length of the sorted part is increased to three elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">-42</span></strong><span class="koboSpan" id="kobo.1095.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">-11</span></strong><span class="koboSpan" id="kobo.1097.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">12</span></strong><span class="koboSpan" id="kobo.1099.1">. </span><span class="koboSpan" id="kobo.1099.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1100.1">Step 3</span></em><span class="koboSpan" id="kobo.1101.1">, you take </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">0</span></strong><span class="koboSpan" id="kobo.1103.1"> as the first element from the unsorted part and perform one swap operation to place it in the correct position, just before </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">12</span></strong><span class="koboSpan" id="kobo.1105.1">, as presented in </span><em class="italic"><span class="koboSpan" id="kobo.1106.1">Step 4</span></em><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">At the same time, the size of the sorted part is increased to four already sorted elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">-42</span></strong><span class="koboSpan" id="kobo.1109.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">-11</span></strong><span class="koboSpan" id="kobo.1111.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">0</span></strong><span class="koboSpan" id="kobo.1113.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">12</span></strong><span class="koboSpan" id="kobo.1115.1">. </span><span class="koboSpan" id="kobo.1115.2">Such operations are repeated until the unsorted part is empty (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1116.1">Step 9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">The implementation code for the insertion sort algorithm is </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">very simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1120.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">Sort</span></strong><span class="koboSpan" id="kobo.1122.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1123.1">for (int i = 1; i &lt; a.Length; i++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1124.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1125.1">        int j = i;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1126.1">        while (j &gt; 0 &amp;&amp; a[j] &lt; a[j - 1])</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1127.1">        {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1128.1">            (a[j], a[j - 1]) = (a[j - 1], a[j]);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1129.1">            j--;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1130.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1131.1">    }</span></strong><span class="koboSpan" id="kobo.1132.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1133.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">for</span></strong><span class="koboSpan" id="kobo.1135.1"> loop is used to iterate through all elements in the unsorted part. </span><span class="koboSpan" id="kobo.1135.2">Thus, the initial value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">i</span></strong><span class="koboSpan" id="kobo.1137.1"> variable is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">1</span></strong><span class="koboSpan" id="kobo.1139.1">, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">0</span></strong><span class="koboSpan" id="kobo.1141.1">, because the unsorted part contains one element at the beginning. </span><span class="koboSpan" id="kobo.1141.2">In </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.1142.1">each iteration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">for</span></strong><span class="koboSpan" id="kobo.1144.1"> loop, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">while</span></strong><span class="koboSpan" id="kobo.1146.1"> loop is executed to move the first element </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.1147.1">from the unsorted part of the array (with the index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">i</span></strong><span class="koboSpan" id="kobo.1149.1">) to the correct location within the sorted part, </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">by swapping.</span></span></p>
<p><span class="koboSpan" id="kobo.1151.1">Finally, it is worth mentioning the time complexity of the insertion sort algorithm. </span><span class="koboSpan" id="kobo.1151.2">Similarly, as in the case of the selection sort, both </span><strong class="bold"><span class="koboSpan" id="kobo.1152.1">the worst and average time complexity is O(n</span></strong><span class="superscript"><span class="koboSpan" id="kobo.1153.1">2</span></span><strong class="bold"><span class="koboSpan" id="kobo.1154.1">)</span></strong><span class="koboSpan" id="kobo.1155.1">. </span><span class="koboSpan" id="kobo.1155.2">If you take a look at the code, you will see two loops (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">for</span></strong><span class="koboSpan" id="kobo.1157.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">while</span></strong><span class="koboSpan" id="kobo.1159.1">) placed one within the other, which could iterate mul</span><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1160.1">t</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1161.1">iple times, depending on the input </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">size (</span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1163.1">n</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">).</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.1165.1">Bubble sort</span></h2>
<p><span class="koboSpan" id="kobo.1166.1">The third sorting algorithm</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.1167.1"> we’ll cover is </span><strong class="bold"><span class="koboSpan" id="kobo.1168.1">bubble sort</span></strong><span class="koboSpan" id="kobo.1169.1">. </span><span class="koboSpan" id="kobo.1169.2">Its way of operation is very</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.1170.1"> simple. </span><strong class="bold"><span class="koboSpan" id="kobo.1171.1">The algorithm just iterates through the array and compares adjacent elements. </span><span class="koboSpan" id="kobo.1171.2">If they are located in an incorrect order, they are swapped.</span></strong><span class="koboSpan" id="kobo.1172.1"> It sounds very easy, doesn’t it? </span><span class="koboSpan" id="kobo.1172.2">Unfortunately, the algorithm is not efficient and its usage with large collections can cause </span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">performance-related problems.</span></span></p>
<p><span class="koboSpan" id="kobo.1174.1">To better understand </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.1175.1">how the algorithm works, let’s take a look at the following</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.1176.1"> figure, which shows how the algorithm operates in the case of sorting a single-dimensional array with nine elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">-11</span></strong><span class="koboSpan" id="kobo.1178.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">12</span></strong><span class="koboSpan" id="kobo.1180.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">-42</span></strong><span class="koboSpan" id="kobo.1182.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">0</span></strong><span class="koboSpan" id="kobo.1184.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">1</span></strong><span class="koboSpan" id="kobo.1186.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">90</span></strong><span class="koboSpan" id="kobo.1188.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">68</span></strong><span class="koboSpan" id="kobo.1190.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">6</span></strong><span class="koboSpan" id="kobo.1192.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">-9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.1196.1"><img alt="Figure 3.9 – Illustration of the bubble sort algorithm" src="image/B18069_03_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1197.1">Figure 3.9 – Illustration of the bubble sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1198.1">In each step, the algorithm compares two adjacent elements in the array and swaps them, if necessary. </span><span class="koboSpan" id="kobo.1198.2">For example, in </span><em class="italic"><span class="koboSpan" id="kobo.1199.1">Step 1</span></em><span class="koboSpan" id="kobo.1200.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">-11</span></strong><span class="koboSpan" id="kobo.1202.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">12</span></strong><span class="koboSpan" id="kobo.1204.1"> are compared. </span><span class="koboSpan" id="kobo.1204.2">They are placed in the correct order, so it is not necessary to swap such elements. </span><span class="koboSpan" id="kobo.1204.3">In </span><em class="italic"><span class="koboSpan" id="kobo.1205.1">Step 2</span></em><span class="koboSpan" id="kobo.1206.1">, the next adjacent elements are compared (namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">12</span></strong><span class="koboSpan" id="kobo.1208.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">-42</span></strong><span class="koboSpan" id="kobo.1210.1">). </span><span class="koboSpan" id="kobo.1210.2">This time, such elements are not placed in the correct order, so</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.1211.1"> they are swapped. </span><span class="koboSpan" id="kobo.1211.2">The aforementioned operations are performed many times. </span><span class="koboSpan" id="kobo.1211.3">Finally, the array is sorted, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1212.1">Step 72</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1214.1">The algorithm seems to</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.1215.1"> be very easy, but what about its implementation? </span><span class="koboSpan" id="kobo.1215.2">Is it also simple? </span><span class="koboSpan" id="kobo.1215.3">Fortunately, yes! </span><span class="koboSpan" id="kobo.1215.4">You just need to use two loops, compare adjacent elements, and swap them if necessary. </span><span class="koboSpan" id="kobo.1215.5">That’s all! </span><span class="koboSpan" id="kobo.1215.6">Let's take a look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1217.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1218.1">Sort</span></strong><span class="koboSpan" id="kobo.1219.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1220.1">for (int i = 0; i &lt; a.Length; i++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1221.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1222.1">        for (int j = 0; j &lt; a.Length - 1; j++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1223.1">        {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1224.1">            if (a[j] &gt; a[j + 1]) </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1225.1">            {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1226.1">                (a[j], a[j + 1]) = (a[j + 1], a[j]);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1227.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1228.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1229.1">    }</span></strong><span class="koboSpan" id="kobo.1230.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1231.1">Here, two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">for</span></strong><span class="koboSpan" id="kobo.1233.1"> loops are used, together with a comparison and swapping. </span><span class="koboSpan" id="kobo.1233.2">As mentioned previously, this algorithm is not efficient and its application can cause problems related to performance, especially in the case of large collections of data. </span><span class="koboSpan" id="kobo.1233.3">However, it is possible to use a bit more efficient version of the bubble sort algorithm by introducing a simple modification. </span><span class="koboSpan" id="kobo.1233.4">It is based on the assumption that </span><strong class="bold"><span class="koboSpan" id="kobo.1234.1">comparisons should be stopped when no changes are discovered during one iteration through the array</span></strong><span class="koboSpan" id="kobo.1235.1">. </span><span class="koboSpan" id="kobo.1235.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">as</span></span><span class="No-Break"><a id="_idIndexMarker305"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1"> follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1238.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1239.1">Sort</span></strong><span class="koboSpan" id="kobo.1240.1">(int[] a)
{
    for (int i = 0; i &lt; a.Length; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1241.1">bool isAnyChange = false;</span></strong><span class="koboSpan" id="kobo.1242.1">
        for (int j = 0; j &lt; a.Length - 1; j++)
        {
            if (a[j] &gt; a[j + 1])
            {
                </span><strong class="bold"><span class="koboSpan" id="kobo.1243.1">isAnyChange = true;</span></strong><span class="koboSpan" id="kobo.1244.1">
                (a[j], a[j + 1]) = (a[j + 1], a[j]);
            }
        }
        </span><strong class="bold"><span class="koboSpan" id="kobo.1245.1">if (!isAnyChange) { break; }</span></strong><span class="koboSpan" id="kobo.1246.1">
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1247.1">By introducing such a simple modification, the number of steps can decrease. </span><span class="koboSpan" id="kobo.1247.2">In the preceding example, it decreases from 72 steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">56 steps.</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">Before moving on to the next </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.1250.1">sorting algorithm, it is worth mentioning the time complexity of the bubble sort algorithm. </span><span class="koboSpan" id="kobo.1250.2">As you may have already guessed, </span><strong class="bold"><span class="koboSpan" id="kobo.1251.1">both worst and average cases</span></strong><span class="koboSpan" id="kobo.1252.1"> are the same as in the case of the selec</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.1253.1">t</span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1254.1">ion and insertion sort algorithms – that </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">is, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1256.1">O(n</span></strong></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.1257.1">2</span></span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1258.1">)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1260.1">Merge sort</span></h2>
<p><span class="koboSpan" id="kobo.1261.1">The fourth sorting algorithm operates in a significantly different way than the three already presented. </span><span class="koboSpan" id="kobo.1261.2">This approach is </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.1262.1">named </span><strong class="bold"><span class="koboSpan" id="kobo.1263.1">merge sort</span></strong><span class="koboSpan" id="kobo.1264.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.1265.1">This algorithm recursively splits the array in half until the array contains only one element, which is sorted. </span><span class="koboSpan" id="kobo.1265.2">Then, the algorithm merges the already sorted subarrays (starting with these with only one element) into the sorted array.</span></strong><span class="koboSpan" id="kobo.1266.1"> Finally, the whole array</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.1267.1"> is sorted and the algorithm stops </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">its operation.</span></span></p>
<p><span class="koboSpan" id="kobo.1269.1">To better understand the merge sort algorithm, let’s take a look at the following iterations for an array with six elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">-11</span></strong><span class="koboSpan" id="kobo.1271.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">12</span></strong><span class="koboSpan" id="kobo.1273.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">-42</span></strong><span class="koboSpan" id="kobo.1275.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">0</span></strong><span class="koboSpan" id="kobo.1277.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">90</span></strong><span class="koboSpan" id="kobo.1279.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1280.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">-9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.1283.1"><img alt="Figure 3.10 – Illustration of the merge sort algorithm" src="image/B18069_03_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1284.1">Figure 3.10 – Illustration of the merge sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1285.1">First (</span><em class="italic"><span class="koboSpan" id="kobo.1286.1">Step 1</span></em><span class="koboSpan" id="kobo.1287.1">), you have the whole unsorted array, which you split into two parts, namely (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">-11</span></strong><span class="koboSpan" id="kobo.1289.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">12</span></strong><span class="koboSpan" id="kobo.1291.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">-42</span></strong><span class="koboSpan" id="kobo.1293.1">) and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">0</span></strong><span class="koboSpan" id="kobo.1295.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">90</span></strong><span class="koboSpan" id="kobo.1297.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">-9</span></strong><span class="koboSpan" id="kobo.1299.1">), as shown in </span><em class="italic"><span class="koboSpan" id="kobo.1300.1">Step 2</span></em><span class="koboSpan" id="kobo.1301.1">. </span><span class="koboSpan" id="kobo.1301.2">In the next step, each of these subarrays is further split into (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">-11</span></strong><span class="koboSpan" id="kobo.1303.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">12</span></strong><span class="koboSpan" id="kobo.1305.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">-42</span></strong><span class="koboSpan" id="kobo.1307.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">0</span></strong><span class="koboSpan" id="kobo.1309.1">), and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">90</span></strong><span class="koboSpan" id="kobo.1311.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">-9</span></strong><span class="koboSpan" id="kobo.1313.1">). </span><span class="koboSpan" id="kobo.1313.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1314.1">Step 4</span></em><span class="koboSpan" id="kobo.1315.1">, you have the whole array divided into the subarrays with only one element each, namely (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">-11</span></strong><span class="koboSpan" id="kobo.1317.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">12</span></strong><span class="koboSpan" id="kobo.1319.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">-42</span></strong><span class="koboSpan" id="kobo.1321.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">0</span></strong><span class="koboSpan" id="kobo.1323.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">90</span></strong><span class="koboSpan" id="kobo.1325.1">), and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">-9</span></strong><span class="koboSpan" id="kobo.1327.1">). </span><span class="koboSpan" id="kobo.1327.2">Next, you merge all of these subarrays, together with sorting. </span><span class="koboSpan" id="kobo.1327.3">Thus, in </span><em class="italic"><span class="koboSpan" id="kobo.1328.1">Step 5</span></em><span class="koboSpan" id="kobo.1329.1">, you have </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.1330.1">three subarrays – that is, (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">-11</span></strong><span class="koboSpan" id="kobo.1332.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">12</span></strong><span class="koboSpan" id="kobo.1334.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">-42</span></strong><span class="koboSpan" id="kobo.1336.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">0</span></strong><span class="koboSpan" id="kobo.1338.1">), and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">-9</span></strong><span class="koboSpan" id="kobo.1340.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">90</span></strong><span class="koboSpan" id="kobo.1342.1">). </span><span class="koboSpan" id="kobo.1342.2">Please keep in mind that these subarrays are already sorted. </span><span class="koboSpan" id="kobo.1342.3">In </span><em class="italic"><span class="koboSpan" id="kobo.1343.1">Step 6</span></em><span class="koboSpan" id="kobo.1344.1">, you need to merge and sort them further into (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">-42</span></strong><span class="koboSpan" id="kobo.1346.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">-11</span></strong><span class="koboSpan" id="kobo.1348.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">0</span></strong><span class="koboSpan" id="kobo.1350.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">12</span></strong><span class="koboSpan" id="kobo.1352.1">) and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">-9</span></strong><span class="koboSpan" id="kobo.1354.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">90</span></strong><span class="koboSpan" id="kobo.1356.1">). </span><span class="koboSpan" id="kobo.1356.2">Finally, you have the whole array sorted, namely (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">-42</span></strong><span class="koboSpan" id="kobo.1358.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">-11</span></strong><span class="koboSpan" id="kobo.1360.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">-9</span></strong><span class="koboSpan" id="kobo.1362.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">0</span></strong><span class="koboSpan" id="kobo.1364.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">12</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">90</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1369.1">Does this seem simpler than</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.1370.1"> just reading the textual description of the algorithm?  </span><span class="koboSpan" id="kobo.1370.2">If so, let’s proceed to </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">its implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1372.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1373.1">Sort</span></strong><span class="koboSpan" id="kobo.1374.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1375.1">if (a.Length &lt;= 1) { return; }</span></strong><span class="koboSpan" id="kobo.1376.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1377.1">int m = a.Length / 2;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1378.1">    int[] left = GetSubarray(a, 0, m - 1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1379.1">    int[] right = GetSubarray(a, m, a.Length - 1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1380.1">    Sort(left);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1381.1">    Sort(right);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1382.1">    int i = 0, j = 0, k = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1383.1">    while (i &lt; left.Length &amp;&amp; j &lt; right.Length)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1384.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1385.1">        if (left[i] &lt;= right[j]) { a[k] = left[i++]; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1386.1">        else { a[k] = right[j++]; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1387.1">        k++;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1388.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1389.1">    while (i &lt; left.Length) { a[k++] = left[i++]; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1390.1">    while (j &lt; right.Length) { a[k++] = right[j++]; }</span></strong><span class="koboSpan" id="kobo.1391.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1392.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">Sort</span></strong><span class="koboSpan" id="kobo.1394.1"> method is called </span><strong class="bold"><span class="koboSpan" id="kobo.1395.1">recursively</span></strong><span class="koboSpan" id="kobo.1396.1"> and takes the array that needs to be sorted as the parameter, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">a</span></strong><span class="koboSpan" id="kobo.1398.1">. </span><span class="koboSpan" id="kobo.1398.2">To stop </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.1399.1">infinitely calling this method recursively, you must specify the stop condition at the beginning. </span><span class="koboSpan" id="kobo.1399.2">It simply checks whether the size of the array is not greater than 1. </span><span class="koboSpan" id="kobo.1399.3">It is related to the assumption that you cannot further divide an array with one element only, because it is </span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1">already sorted.</span></span></p>
<p><span class="koboSpan" id="kobo.1401.1">Next, you calculate an</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.1402.1"> index of the middle element and store it as a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">m</span></strong><span class="koboSpan" id="kobo.1404.1">. </span><span class="koboSpan" id="kobo.1404.2">In the following two lines, you call the auxiliary </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">GetSubarray</span></strong><span class="koboSpan" id="kobo.1406.1"> method, which creates a new array with only a part of elements, either from its left-hand side (with indices from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">0</span></strong><span class="koboSpan" id="kobo.1408.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">m-1</span></strong><span class="koboSpan" id="kobo.1410.1">, stored as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">left</span></strong><span class="koboSpan" id="kobo.1412.1">) or the right-hand side (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">m</span></strong><span class="koboSpan" id="kobo.1414.1"> to the length of the array minus 1, stored as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">right</span></strong><span class="koboSpan" id="kobo.1416.1">). </span><span class="koboSpan" id="kobo.1416.2">You will see its implementation after the explanation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">Sort</span></strong><span class="koboSpan" id="kobo.1418.1"> method. </span><span class="koboSpan" id="kobo.1418.2">Coming back to the explanation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">Sort</span></strong><span class="koboSpan" id="kobo.1420.1"> method, you then recursively call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">Sort</span></strong><span class="koboSpan" id="kobo.1422.1"> method, passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">left</span></strong><span class="koboSpan" id="kobo.1424.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">right</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1"> subarrays.</span></span></p>
<p><span class="koboSpan" id="kobo.1427.1">The remaining part of the code is related to merging subarrays into the whole sorted array. </span><span class="koboSpan" id="kobo.1427.2">Of course, this procedure is performed step by step, merging the subarrays into bigger and bigger subarrays until the whole array is sorted. </span><span class="koboSpan" id="kobo.1427.3">You use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">while</span></strong><span class="koboSpan" id="kobo.1429.1"> loop to iterate through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">left</span></strong><span class="koboSpan" id="kobo.1431.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">right</span></strong><span class="koboSpan" id="kobo.1433.1"> subarrays. </span><span class="koboSpan" id="kobo.1433.2">You use three auxiliary variables, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">i</span></strong><span class="koboSpan" id="kobo.1435.1"> as an index of the currently analyzed element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">left</span></strong><span class="koboSpan" id="kobo.1437.1"> array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">j</span></strong><span class="koboSpan" id="kobo.1439.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">right</span></strong><span class="koboSpan" id="kobo.1441.1"> array, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">k</span></strong><span class="koboSpan" id="kobo.1443.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">a</span></strong><span class="koboSpan" id="kobo.1445.1"> array. </span><span class="koboSpan" id="kobo.1445.2">Initially, all of them are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">0</span></strong><span class="koboSpan" id="kobo.1447.1">, so you keep an eye on the first element of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">left</span></strong><span class="koboSpan" id="kobo.1449.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">right</span></strong><span class="koboSpan" id="kobo.1451.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">a</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1453.1"> arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.1454.1">Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">while</span></strong><span class="koboSpan" id="kobo.1456.1"> loop, you check whether the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">left</span></strong><span class="koboSpan" id="kobo.1458.1"> array (with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">i</span></strong><span class="koboSpan" id="kobo.1460.1"> index) is not greater than the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">right</span></strong><span class="koboSpan" id="kobo.1462.1"> array (with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">j</span></strong><span class="koboSpan" id="kobo.1464.1"> index). </span><span class="koboSpan" id="kobo.1464.2">If so, you place the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">left</span></strong><span class="koboSpan" id="kobo.1466.1"> array as the first element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">a</span></strong><span class="koboSpan" id="kobo.1468.1"> array. </span><span class="koboSpan" id="kobo.1468.2">You also increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">i</span></strong><span class="koboSpan" id="kobo.1470.1"> index, which means that the second element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">left</span></strong><span class="koboSpan" id="kobo.1472.1"> array is the current one. </span><span class="koboSpan" id="kobo.1472.2">If this condition is not met – that is, the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">right</span></strong><span class="koboSpan" id="kobo.1474.1"> array is smaller than the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">left</span></strong><span class="koboSpan" id="kobo.1476.1"> array – you use the current element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">right</span></strong><span class="koboSpan" id="kobo.1478.1"> array as the first element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">a</span></strong><span class="koboSpan" id="kobo.1480.1"> array and increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">j</span></strong><span class="koboSpan" id="kobo.1482.1"> index. </span><span class="koboSpan" id="kobo.1482.2">Finally, you increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">k</span></strong><span class="koboSpan" id="kobo.1484.1"> index to keep an eye on the second element from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">a</span></strong><span class="koboSpan" id="kobo.1486.1"> array. </span><span class="koboSpan" id="kobo.1486.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">while</span></strong><span class="koboSpan" id="kobo.1488.1"> loop ends when you are out of bounds of either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">left</span></strong><span class="koboSpan" id="kobo.1490.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">right</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1"> array.</span></span></p>
<p><span class="koboSpan" id="kobo.1493.1">What about when some elements haven’t been analyzed yet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">left</span></strong><span class="koboSpan" id="kobo.1495.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">right</span></strong><span class="koboSpan" id="kobo.1497.1"> arrays? </span><span class="koboSpan" id="kobo.1497.2">To handle such cases, you use two additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">while</span></strong><span class="koboSpan" id="kobo.1499.1"> loops. </span><span class="koboSpan" id="kobo.1499.2">These allow you to place the remaining elements</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.1500.1"> from either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">left</span></strong><span class="koboSpan" id="kobo.1502.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">right</span></strong><span class="koboSpan" id="kobo.1504.1"> array on the remaining places in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">a</span></strong><span class="koboSpan" id="kobo.1506.1"> array. </span><span class="koboSpan" id="kobo.1506.2">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">Sort</span></strong><span class="koboSpan" id="kobo.1508.1"> method is equipped with a very simple way of merging two </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.1509.1">arrays into one, together with </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">their sorting.</span></span></p>
<p><span class="koboSpan" id="kobo.1511.1">While explaining the algorithm’s implementation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">GetSubarray</span></strong><span class="koboSpan" id="kobo.1513.1"> auxiliary method was mentioned. </span><span class="koboSpan" id="kobo.1513.2">So, let’s show its code, together with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">short explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1515.1">
int[] </span><strong class="bold"><span class="koboSpan" id="kobo.1516.1">GetSubarray</span></strong><span class="koboSpan" id="kobo.1517.1">(int[] a, int si, int ei)
{
    int[] result = new int[ei - si + 1];
    </span><strong class="bold"><span class="koboSpan" id="kobo.1518.1">Array.Copy(a, si, result, 0, ei - si + 1);</span></strong><span class="koboSpan" id="kobo.1519.1">
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.1520.1">This method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">Copy</span></strong><span class="koboSpan" id="kobo.1522.1"> static method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">Array</span></strong><span class="koboSpan" id="kobo.1524.1"> class to copy a part of the source array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">a</span></strong><span class="koboSpan" id="kobo.1526.1">) to the declared and initialized here destination array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">result</span></strong><span class="koboSpan" id="kobo.1528.1">). </span><span class="koboSpan" id="kobo.1528.2">To perform this task, you need to take the correct number of elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">ei</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">–</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">si</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">+</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">1</span></strong><span class="koboSpan" id="kobo.1534.1">. </span><span class="koboSpan" id="kobo.1534.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1535.1">ei</span></strong><span class="koboSpan" id="kobo.1536.1"> stands for </span><em class="italic"><span class="koboSpan" id="kobo.1537.1">end index</span></em><span class="koboSpan" id="kobo.1538.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">si</span></strong><span class="koboSpan" id="kobo.1540.1"> stands for </span><em class="italic"><span class="koboSpan" id="kobo.1541.1">start index</span></em><span class="koboSpan" id="kobo.1542.1">. </span><span class="koboSpan" id="kobo.1542.2">You need to copy elements between arrays starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">si</span></strong><span class="koboSpan" id="kobo.1544.1"> index in the source array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1545.1">a</span></strong><span class="koboSpan" id="kobo.1546.1">) and store them starting from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">0</span></strong><span class="koboSpan" id="kobo.1548.1"> index in the destination </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">array (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1552.1">Of course, you can fill a subarray in different ways, such as using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">for</span></strong><span class="koboSpan" id="kobo.1554.1"> loop, which iterates through elements and copies them accordingly. </span><span class="koboSpan" id="kobo.1554.2">If you want, you can prepare the alternative implementation on your own and then compare it during the performance tests, which you will see later in </span><span class="No-Break"><span class="koboSpan" id="kobo.1555.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1556.1">What about the time complexity? </span><span class="koboSpan" id="kobo.1556.2">It’s not very easy to specify it in the case of the merge sort algorithm compared to the other sorting algorithms I’ve presented. </span><span class="koboSpan" id="kobo.1556.3">However, its time complexity is much better and can be indicated as </span><strong class="bold"><span class="koboSpan" id="kobo.1557.1">O(n log(n))</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1558.1"> for both average and worst cases</span></strong><span class="koboSpan" id="kobo.1559.1">. </span><span class="koboSpan" id="kobo.1559.2">You will see what this means in practice while analyzing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">performance results.</span></span></p>
<p><span class="koboSpan" id="kobo.1561.1">However, you still have some algorithms to learn about, so let’s proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">next one.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1563.1">Shell sort</span></h2>
<p><span class="koboSpan" id="kobo.1564.1">A different approach to</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.1565.1"> sorting is used in the </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">Shell sort</span></strong><span class="koboSpan" id="kobo.1567.1"> algorithm, whose name comes from its author’s name. </span><span class="koboSpan" id="kobo.1567.2">It is a variation of the </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.1568.1">already presented insertion sort. </span><strong class="bold"><span class="koboSpan" id="kobo.1569.1">The algorithm performs h-</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1570.1">sorting</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1571.1"> to sort virtual subarrays consisting of elements with a distance equal to h, using the insertion sort. </span><span class="koboSpan" id="kobo.1571.2">At the beginning, h is set to half of the array’s length and is divided by 2 in each iteration, until it is equal to 1.</span></strong><span class="koboSpan" id="kobo.1572.1"> This description can </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.1573.1">seem a bit complicated, but it is a surprisingly efficient algorithm with a very </span><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">simple implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1575.1">First, let’s take a look at a figure that should make this topic much simpler and easier to understand than just the </span><span class="No-Break"><span class="koboSpan" id="kobo.1576.1">plain text:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.1577.1"><img alt="Figure 3.11 – Illustration of the Shell sort algorithm" src="image/B18069_03_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1578.1">Figure 3.11 – Illustration of the Shell sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1579.1">As the source array contains 7 elements, the initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">h</span></strong><span class="koboSpan" id="kobo.1581.1"> value is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">3</span></strong><span class="koboSpan" id="kobo.1583.1">. </span><span class="koboSpan" id="kobo.1583.2">So, now, it is time for </span><strong class="bold"><span class="koboSpan" id="kobo.1584.1">3-sorting</span></strong><span class="koboSpan" id="kobo.1585.1">. </span><span class="koboSpan" id="kobo.1585.2">You create virtual subarrays with elements whose indices differ by 3. </span><span class="koboSpan" id="kobo.1585.3">This means that the following indices are used: (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">0</span></strong><span class="koboSpan" id="kobo.1587.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">3</span></strong><span class="koboSpan" id="kobo.1589.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">6</span></strong><span class="koboSpan" id="kobo.1591.1">), (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">1</span></strong><span class="koboSpan" id="kobo.1593.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1594.1">4</span></strong><span class="koboSpan" id="kobo.1595.1">), and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">2</span></strong><span class="koboSpan" id="kobo.1597.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">5</span></strong><span class="koboSpan" id="kobo.1599.1">). </span><span class="koboSpan" id="kobo.1599.2">The first virtual subarray consists of (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">-11</span></strong><span class="koboSpan" id="kobo.1601.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">-15</span></strong><span class="koboSpan" id="kobo.1603.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">-13</span></strong><span class="koboSpan" id="kobo.1605.1">), so you sort it and receive (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">-15</span></strong><span class="koboSpan" id="kobo.1607.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">-13</span></strong><span class="koboSpan" id="kobo.1609.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">-11</span></strong><span class="koboSpan" id="kobo.1611.1">). </span><span class="koboSpan" id="kobo.1611.2">The second is (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">12</span></strong><span class="koboSpan" id="kobo.1613.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">-4</span></strong><span class="koboSpan" id="kobo.1615.1">) and forms (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">-4</span></strong><span class="koboSpan" id="kobo.1617.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">12</span></strong><span class="koboSpan" id="kobo.1619.1">) after sorting. </span><span class="koboSpan" id="kobo.1619.2">The last is (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">13</span></strong><span class="koboSpan" id="kobo.1621.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">-9</span></strong><span class="koboSpan" id="kobo.1623.1">) and is sorted into (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">-9</span></strong><span class="koboSpan" id="kobo.1625.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">13</span></strong><span class="koboSpan" id="kobo.1627.1">). </span><span class="koboSpan" id="kobo.1627.2">When 3-sorting is </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.1628.1">completed, you calculate the next </span><em class="italic"><span class="koboSpan" id="kobo.1629.1">h</span></em><span class="koboSpan" id="kobo.1630.1"> value, simply by dividing the current value by 2. </span><span class="koboSpan" id="kobo.1630.2">The result is 1 and it is also the last </span><em class="italic"><span class="koboSpan" id="kobo.1631.1">h</span></em><span class="koboSpan" id="kobo.1632.1">-sorting iteration, namely </span><strong class="bold"><span class="koboSpan" id="kobo.1633.1">1-sorting</span></strong><span class="koboSpan" id="kobo.1634.1">. </span><span class="koboSpan" id="kobo.1634.2">Now, you </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.1635.1">perform a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.1636.1">insertion sort.</span></span></p>
<p><span class="koboSpan" id="kobo.1637.1">The illustration and description look pretty simple, don’t they? </span><span class="koboSpan" id="kobo.1637.2">Let's write some C# code to implement the Shell sort algorithm, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1638.1">shown below:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1639.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1640.1">Sort</span></strong><span class="koboSpan" id="kobo.1641.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1642.1">for (int h = a.Length / 2; h &gt; 0; h /= 2)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1643.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1644.1">        for (int i = h; i &lt; a.Length; i++)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1645.1">        {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1646.1">            int j = i;</span></strong><span class="koboSpan" id="kobo.1647.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.1648.1">int ai = a[i];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1649.1">            while (j &gt;= h &amp;&amp; a[j - h] &gt; ai)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1650.1">            {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1651.1">                a[j] = a[j - h];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1652.1">                j -= h;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1653.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1654.1">            a[j] = ai;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1655.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1656.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1657.1">}</span></strong></pre> <p><span class="koboSpan" id="kobo.1658.1">The implementation consists of three loops. </span><span class="koboSpan" id="kobo.1658.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">for</span></strong><span class="koboSpan" id="kobo.1660.1"> loop is used to calculate proper values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">h</span></strong><span class="koboSpan" id="kobo.1662.1">, starting with the array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">a</span></strong><span class="koboSpan" id="kobo.1664.1">) length divided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1665.1">2</span></strong><span class="koboSpan" id="kobo.1666.1">. </span><span class="koboSpan" id="kobo.1666.2">It is further divided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1667.1">2</span></strong><span class="koboSpan" id="kobo.1668.1"> after each iteration and the last acceptable value </span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1672.1">The next </span><strong class="source-inline"><span class="koboSpan" id="kobo.1673.1">for</span></strong><span class="koboSpan" id="kobo.1674.1"> loop calculates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">i</span></strong><span class="koboSpan" id="kobo.1676.1"> index, starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">h</span></strong><span class="koboSpan" id="kobo.1678.1">, and increases it until the end of the array is reached. </span><span class="koboSpan" id="kobo.1678.2">This part is</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.1679.1"> used to perform the insertion sort on </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">virtual subarrays.</span></span></p>
<p><span class="koboSpan" id="kobo.1681.1">Within the loop, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">ai</span></strong><span class="koboSpan" id="kobo.1683.1"> variable to store the current value of the element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1684.1">i</span></strong><span class="koboSpan" id="kobo.1685.1"> index, so you can replace it later with another value. </span><span class="koboSpan" id="kobo.1685.2">Then, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1686.1">while</span></strong><span class="koboSpan" id="kobo.1687.1"> loop is used to shift elements in the </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.1688.1">virtual subarray to find the correct location for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">ai</span></strong><span class="koboSpan" id="kobo.1690.1">. </span><span class="koboSpan" id="kobo.1690.2">Finally, you store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">ai</span></strong><span class="koboSpan" id="kobo.1692.1"> variable in the location indicated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1693.1">j</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1694.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.1695.1">As you can see, the implementation is very short and quite simple. </span><span class="koboSpan" id="kobo.1695.2">What’s more, this algorithm is efficient and can be used for sorting large collections of data, as you will see later in this chapter. </span><span class="koboSpan" id="kobo.1695.3">But what about the time complexity? </span><strong class="bold"><span class="koboSpan" id="kobo.1696.1">In the worst case, it is</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1697.1">O(n</span></strong><span class="superscript"><span class="koboSpan" id="kobo.1698.1">2</span></span><strong class="bold"><span class="koboSpan" id="kobo.1699.1">)</span></strong><span class="koboSpan" id="kobo.1700.1">. </span><span class="koboSpan" id="kobo.1700.2">However, its </span><strong class="bold"><span class="koboSpan" id="kobo.1701.1">average time complexity is about </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1702.1">O(n log(n))</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1703.1">.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1704.1">Quicksort</span></h2>
<p><span class="koboSpan" id="kobo.1705.1">The sixth sorting algorithm </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1706.1">described in this book is </span><strong class="bold"><span class="koboSpan" id="kobo.1707.1">quicksort</span></strong><span class="koboSpan" id="kobo.1708.1">. </span><span class="koboSpan" id="kobo.1708.2">It is one of the popular algorithms from the </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1709.1">divide and conquer group and divides a problem into a set of smaller ones. </span><span class="koboSpan" id="kobo.1709.2">How does </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">it work?</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1711.1">The algorithm picks some value (for example, from the last element of the array) as a pivot. </span><span class="koboSpan" id="kobo.1711.2">Then, it reorders the array in such a way that values lower than the pivot are placed before it (forming the lower subarray), while values greater than or equal to the pivot are placed</span></strong><strong class="bold"><a id="_idIndexMarker324"/></strong><strong class="bold"><span class="koboSpan" id="kobo.1712.1"> after it (the higher subarray). </span><span class="koboSpan" id="kobo.1712.2">Such a process is called </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1713.1">partitioning</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1714.1">. </span><span class="koboSpan" id="kobo.1714.2">Next, the algorithm recursively sorts each of the aforementioned subarrays. </span><span class="koboSpan" id="kobo.1714.3">Each subarray is further divided into the next two subarrays, and so on. </span><span class="koboSpan" id="kobo.1714.4">The recursive calls stop when there are one or zero elements in a subarray because in such a case, there is nothing </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1715.1">to sort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1717.1">The preceding description may sound a bit complicated. </span><span class="koboSpan" id="kobo.1717.2">However, the following figure and the algorithm’s implementation should remove </span><span class="No-Break"><span class="koboSpan" id="kobo.1718.1">any doubts.</span></span></p>
<p><span class="koboSpan" id="kobo.1719.1">The following diagram shows how the </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.1720.1">quicksort algorithm sorts a single-dimensional array with nine </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.1721.1">elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1722.1">-11</span></strong><span class="koboSpan" id="kobo.1723.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1724.1">12</span></strong><span class="koboSpan" id="kobo.1725.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">-42</span></strong><span class="koboSpan" id="kobo.1727.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">0</span></strong><span class="koboSpan" id="kobo.1729.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">1</span></strong><span class="koboSpan" id="kobo.1731.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">90</span></strong><span class="koboSpan" id="kobo.1733.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">68</span></strong><span class="koboSpan" id="kobo.1735.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1736.1">6</span></strong><span class="koboSpan" id="kobo.1737.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1739.1">-9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.1741.1"><img alt="Figure 3.12 – Illustration of the quicksort algorithm" src="image/B18069_03_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1742.1">Figure 3.12 – Illustration of the quicksort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1743.1">In our case, it is assumed that the pivot is chosen as a value of the last element of the subarray that is currently being sorted. </span><span class="koboSpan" id="kobo.1743.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1744.1">Step 1</span></em><span class="koboSpan" id="kobo.1745.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1746.1">-9</span></strong><span class="koboSpan" id="kobo.1747.1"> is chosen as the pivot. </span><span class="koboSpan" id="kobo.1747.2">Then, it is necessary to swap </span><strong class="source-inline"><span class="koboSpan" id="kobo.1748.1">12</span></strong><span class="koboSpan" id="kobo.1749.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">-42</span></strong><span class="koboSpan" id="kobo.1751.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1752.1">Step 1</span></em><span class="koboSpan" id="kobo.1753.1">), as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1754.1">12</span></strong><span class="koboSpan" id="kobo.1755.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1756.1">-9</span></strong><span class="koboSpan" id="kobo.1757.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1758.1">Step 2</span></em><span class="koboSpan" id="kobo.1759.1">), to ensure that only values lower than the pivot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">-11</span></strong><span class="koboSpan" id="kobo.1761.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1762.1">-42</span></strong><span class="koboSpan" id="kobo.1763.1">) are in the lower subarray and only values greater than or equal to the pivot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">0</span></strong><span class="koboSpan" id="kobo.1765.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">1</span></strong><span class="koboSpan" id="kobo.1767.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">90</span></strong><span class="koboSpan" id="kobo.1769.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1770.1">68</span></strong><span class="koboSpan" id="kobo.1771.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1772.1">6</span></strong><span class="koboSpan" id="kobo.1773.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1774.1">12</span></strong><span class="koboSpan" id="kobo.1775.1">) are placed in the higher subarray (</span><em class="italic"><span class="koboSpan" id="kobo.1776.1">Step 3</span></em><span class="koboSpan" id="kobo.1777.1">). </span><span class="koboSpan" id="kobo.1777.2">Then, the algorithm is called recursively for both aforementioned subarrays, namely (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1778.1">-11</span></strong><span class="koboSpan" id="kobo.1779.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1780.1">-42</span></strong><span class="koboSpan" id="kobo.1781.1">, from </span><em class="italic"><span class="koboSpan" id="kobo.1782.1">Step 4</span></em><span class="koboSpan" id="kobo.1783.1">) and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">0</span></strong><span class="koboSpan" id="kobo.1785.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1786.1">1</span></strong><span class="koboSpan" id="kobo.1787.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1788.1">90</span></strong><span class="koboSpan" id="kobo.1789.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1790.1">68</span></strong><span class="koboSpan" id="kobo.1791.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1792.1">6</span></strong><span class="koboSpan" id="kobo.1793.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1794.1">12</span></strong><span class="koboSpan" id="kobo.1795.1">, from </span><em class="italic"><span class="koboSpan" id="kobo.1796.1">Step 7</span></em><span class="koboSpan" id="kobo.1797.1">), so that they are processed in the same way as the </span><span class="No-Break"><span class="koboSpan" id="kobo.1798.1">input array.</span></span></p>
<p><span class="koboSpan" id="kobo.1799.1">As an example, </span><em class="italic"><span class="koboSpan" id="kobo.1800.1">Step 7</span></em><span class="koboSpan" id="kobo.1801.1"> shows that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">12</span></strong><span class="koboSpan" id="kobo.1803.1"> is chosen as the pivot. </span><span class="koboSpan" id="kobo.1803.2">After partitioning, the subarray is divided into two </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.1804.1">other subarrays, namely (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1805.1">0</span></strong><span class="koboSpan" id="kobo.1806.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1807.1">1</span></strong><span class="koboSpan" id="kobo.1808.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1809.1">6</span></strong><span class="koboSpan" id="kobo.1810.1">) and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1811.1">90</span></strong><span class="koboSpan" id="kobo.1812.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">68</span></strong><span class="koboSpan" id="kobo.1814.1">). </span><span class="koboSpan" id="kobo.1814.2">For both, other pivot elements are chosen, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">6</span></strong><span class="koboSpan" id="kobo.1816.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">68</span></strong><span class="koboSpan" id="kobo.1818.1">. </span><span class="koboSpan" id="kobo.1818.2">After performing such operations for all</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.1819.1"> the remaining parts of the array, you receive the result shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1820.1">Step 16</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1821.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1822.1">It is worth mentioning that the pivot can be selected variously in other implementations of this algorithm. </span><span class="koboSpan" id="kobo.1822.2">Now that you understand how the algorithm works, let’s proceed to its implementation. </span><span class="koboSpan" id="kobo.1822.3">It’s no more complicated than the examples shown earlier, and it uses </span><strong class="bold"><span class="koboSpan" id="kobo.1823.1">recursion</span></strong><span class="koboSpan" id="kobo.1824.1"> to call the sorting method for subarrays. </span><span class="koboSpan" id="kobo.1824.2">The main code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1825.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1826.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1827.1">Sort</span></strong><span class="koboSpan" id="kobo.1828.1">(int[] a)
{
</span><strong class="bold"><span class="koboSpan" id="kobo.1829.1">    SortPart(a, 0, a.Length - 1);</span></strong><span class="koboSpan" id="kobo.1830.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1831.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">Sort</span></strong><span class="koboSpan" id="kobo.1833.1"> method takes only one parameter, namely the array that should be sorted. </span><span class="koboSpan" id="kobo.1833.2">It just calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">SortPart</span></strong><span class="koboSpan" id="kobo.1835.1"> method, which makes it possible to </span><strong class="bold"><span class="koboSpan" id="kobo.1836.1">specify the lower and upper indices, which indicate which part of the array should be sorted</span></strong><span class="koboSpan" id="kobo.1837.1">. </span><span class="koboSpan" id="kobo.1837.2">The code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">SortPart</span></strong><span class="koboSpan" id="kobo.1839.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1840.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1841.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1842.1">SortPart</span></strong><span class="koboSpan" id="kobo.1843.1">(int[] a, int l, int u)
{
    if (l &gt;= u) { return; }
    int pivot = a[u];
    int j = l - 1;
    for (int i = l; i &lt; u; i++)
    {
        if (a[i] &lt; pivot)
        {
            j++;
            (a[j], a[i]) = (a[i], a[j]);
        }
    }
    int p = j + 1;
    (a[p], a[u]) = (a[u], a[p]);
    SortPart(a, l, p - 1);
    SortPart(a, p + 1, u);
}</span></pre> <p><span class="koboSpan" id="kobo.1844.1">First, the method checks whether the array (or subarray) has at least two elements by comparing the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">l</span></strong><span class="koboSpan" id="kobo.1846.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1847.1">lower index</span></em><span class="koboSpan" id="kobo.1848.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">u</span></strong><span class="koboSpan" id="kobo.1850.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1851.1">upper index</span></em><span class="koboSpan" id="kobo.1852.1">) variables. </span><span class="koboSpan" id="kobo.1852.2">If not, you return from this method. </span><span class="koboSpan" id="kobo.1852.3">Otherwise, you perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.1853.1">partitioning phase.</span></span></p>
<p><span class="koboSpan" id="kobo.1854.1">Here, the pivot is chosen as a value of the last</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.1855.1"> element in the array (or subarray) and stored as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1856.1">pivot</span></strong><span class="koboSpan" id="kobo.1857.1"> variable. </span><span class="koboSpan" id="kobo.1857.2">Then, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1858.1">for</span></strong><span class="koboSpan" id="kobo.1859.1"> loop is used to rearrange the array using comparisons and swapping</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1860.1"> elements. </span><span class="koboSpan" id="kobo.1860.2">You need to perform this stage to ensure that values lower than the pivot are placed before it, while values greater than or equal to the pivot are placed </span><span class="No-Break"><span class="koboSpan" id="kobo.1861.1">after it.</span></span></p>
<p><span class="koboSpan" id="kobo.1862.1">Finally, you store a new index of the pivot value as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1863.1">p</span></strong><span class="koboSpan" id="kobo.1864.1"> and perform swapping to place it there. </span><span class="koboSpan" id="kobo.1864.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1865.1">p</span></strong><span class="koboSpan" id="kobo.1866.1"> variable is also used to calculate lower and upper bounds for subarrays, namely as (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1867.1">l</span></strong><span class="koboSpan" id="kobo.1868.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1869.1">p-1</span></strong><span class="koboSpan" id="kobo.1870.1">) and (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1871.1">p+1</span></strong><span class="koboSpan" id="kobo.1872.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1873.1">u</span></strong><span class="koboSpan" id="kobo.1874.1">). </span><span class="koboSpan" id="kobo.1874.2">Such ranges are then used while calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1875.1">SortPart</span></strong><span class="koboSpan" id="kobo.1876.1"> method recursively for the lower and upper parts. </span><span class="No-Break"><span class="koboSpan" id="kobo.1877.1">That’s all!</span></span></p>
<p><span class="koboSpan" id="kobo.1878.1">What about the time complexity? </span><span class="koboSpan" id="kobo.1878.2">It has </span><strong class="bold"><span class="koboSpan" id="kobo.1879.1">O(n log(n)) average time complexity, despite having O(n</span></strong><span class="superscript"><span class="koboSpan" id="kobo.1880.1">2</span></span><strong class="bold"><span class="koboSpan" id="kobo.1881.1">) worst time complexity</span></strong><span class="koboSpan" id="kobo.1882.1">. </span><span class="koboSpan" id="kobo.1882.2">Does this look similar to Shell sort to you? </span><span class="koboSpan" id="kobo.1882.3">If so, you are right! </span><span class="koboSpan" id="kobo.1882.4">You are coming closer and closer to the end of this chapter, where you will see results </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1883.1">from conducting performance tests on various </span><span class="No-Break"><span class="koboSpan" id="kobo.1884.1">sorting algorithms.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1885.1">Heap sort</span></h2>
<p><span class="koboSpan" id="kobo.1886.1">The last approach we’ll cover is </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1887.1">based on an interesting data structure known as a </span><strong class="bold"><span class="koboSpan" id="kobo.1888.1">binary heap</span></strong><span class="koboSpan" id="kobo.1889.1">. </span><span class="koboSpan" id="kobo.1889.2">To</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1890.1"> give you a brief introduction, </span><strong class="bold"><span class="koboSpan" id="kobo.1891.1">it is a tree-based structure where each node contains either zero, one, or two child nodes</span></strong><span class="koboSpan" id="kobo.1892.1">. </span><span class="koboSpan" id="kobo.1892.2">You’ll learn more</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1893.1"> about trees and their variants later in </span><span class="No-Break"><span class="koboSpan" id="kobo.1894.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.1895.1">It won’t come as a surprise to you that the sorting solution is named </span><strong class="bold"><span class="koboSpan" id="kobo.1896.1">heap sort</span></strong><span class="koboSpan" id="kobo.1897.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.1898.1">First, the algorithm </span></strong><strong class="bold"><a id="_idIndexMarker335"/></strong><strong class="bold"><span class="koboSpan" id="kobo.1899.1">builds a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1900.1">max-heap</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1901.1"> from the array (the </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1902.1">heapify</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1903.1"> operation). </span><span class="koboSpan" id="kobo.1903.2">Then, it repeats a</span></strong><strong class="bold"><a id="_idIndexMarker336"/></strong><strong class="bold"><span class="koboSpan" id="kobo.1904.1"> few steps until there is only one element in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1905.1">the heap:</span></strong></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.1906.1">Swap the first element (root with the maximum value) with the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1907.1">last element.</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1908.1">Remove the last element (which is currently the maximum value) from </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1909.1">the heap.</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1910.1">Build the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1911.1">max-heap again.</span></strong></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1912.1">By performing these operations, you efficiently receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.1913.1">sorted array.</span></span></p>
<p><span class="koboSpan" id="kobo.1914.1">As a new data structure must be introduced here, let’s look at what the binary heap looks like and how the algorithm operates to sort the </span><span class="No-Break"><span class="koboSpan" id="kobo.1915.1">example array:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.1916.1"><img alt="Figure 3.13 – Illustration of the heap sort algorithm" src="image/B18069_03_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1917.1">Figure 3.13 – Illustration of the heap sort algorithm</span></p>
<p><span class="koboSpan" id="kobo.1918.1">The input array consists of six elements, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1919.1">-11</span></strong><span class="koboSpan" id="kobo.1920.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">12</span></strong><span class="koboSpan" id="kobo.1922.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">-42</span></strong><span class="koboSpan" id="kobo.1924.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1925.1">0</span></strong><span class="koboSpan" id="kobo.1926.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1927.1">90</span></strong><span class="koboSpan" id="kobo.1928.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">-9</span></strong><span class="koboSpan" id="kobo.1930.1">. </span><span class="koboSpan" id="kobo.1930.2">You form a binary heap from it by placing the first element as a </span><em class="italic"><span class="koboSpan" id="kobo.1931.1">root</span></em><span class="koboSpan" id="kobo.1932.1"> and then by adding two of its child nodes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1933.1">12</span></strong><span class="koboSpan" id="kobo.1934.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">-42</span></strong><span class="koboSpan" id="kobo.1936.1">. </span><span class="koboSpan" id="kobo.1936.2">You do not have more space at this level of the heap, so let’s add the following two elements from the array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">0</span></strong><span class="koboSpan" id="kobo.1938.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">90</span></strong><span class="koboSpan" id="kobo.1940.1">) as child nodes to the node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1941.1">12</span></strong><span class="koboSpan" id="kobo.1942.1">. </span><span class="koboSpan" id="kobo.1942.2">The last element from the array is left. </span><span class="koboSpan" id="kobo.1942.3">You must place it as a child node of the node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1943.1">-42</span></strong><span class="koboSpan" id="kobo.1944.1">. </span><span class="koboSpan" id="kobo.1944.2">As you can see, you</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1945.1"> can easily map an array to a binary heap data structure and use an array as a </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1946.1">data structure to store the data of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1947.1">binary heap.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1948.1">Interesting properties of a binary heap</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1949.1">Remember that a root node in a binary </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1950.1">heap, represented by an array, is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">array[0]</span></strong><span class="koboSpan" id="kobo.1952.1">. </span><span class="koboSpan" id="kobo.1952.2">If you need to access the data of a parent node of the </span><em class="italic"><span class="koboSpan" id="kobo.1953.1">i</span></em><span class="koboSpan" id="kobo.1954.1">-th element, you can get it from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1955.1">array[(i-1)/2]</span></strong><span class="koboSpan" id="kobo.1956.1">. </span><span class="koboSpan" id="kobo.1956.2">The left and right child nodes of the </span><em class="italic"><span class="koboSpan" id="kobo.1957.1">i</span></em><span class="koboSpan" id="kobo.1958.1">-th element are available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1959.1">array[(2*i)+1]</span></strong><span class="koboSpan" id="kobo.1960.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1961.1">array[(2*i)+2]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1962.1">, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.1963.1">The next operation, which takes an important role in the heap sort algorithm, is named </span><strong class="bold"><span class="koboSpan" id="kobo.1964.1">heapify</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1965.1">.</span></strong><span class="koboSpan" id="kobo.1966.1"> It can look a bit complicated, but after a short explanation, it should be clear. </span><span class="koboSpan" id="kobo.1966.2">This operation aims to convert a binary heap into a </span><strong class="bold"><span class="koboSpan" id="kobo.1967.1">max-heap</span></strong><span class="koboSpan" id="kobo.1968.1">. </span><span class="koboSpan" id="kobo.1968.2">This means that </span><strong class="bold"><span class="koboSpan" id="kobo.1969.1">each node can contain only the child nodes whose values are smaller than or equal to the node’s value</span></strong><span class="koboSpan" id="kobo.1970.1">. </span><span class="koboSpan" id="kobo.1970.2">As an example, let’s take a look at the first row of the preceding figure. </span><span class="koboSpan" id="kobo.1970.3">By using the </span><em class="italic"><span class="koboSpan" id="kobo.1971.1">heapify</span></em><span class="koboSpan" id="kobo.1972.1"> operation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1973.1">90</span></strong><span class="koboSpan" id="kobo.1974.1"> is located as the </span><em class="italic"><span class="koboSpan" id="kobo.1975.1">root</span></em><span class="koboSpan" id="kobo.1976.1">. </span><span class="koboSpan" id="kobo.1976.2">It contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.1977.1">12</span></strong><span class="koboSpan" id="kobo.1978.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1979.1">-9</span></strong><span class="koboSpan" id="kobo.1980.1"> as nodes. </span><span class="koboSpan" id="kobo.1980.2">The node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1981.1">12</span></strong><span class="koboSpan" id="kobo.1982.1"> contains child nodes with smaller values, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1983.1">0</span></strong><span class="koboSpan" id="kobo.1984.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1985.1">-11</span></strong><span class="koboSpan" id="kobo.1986.1">. </span><span class="koboSpan" id="kobo.1986.2">The node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1987.1">-9</span></strong><span class="koboSpan" id="kobo.1988.1"> contains only one element, which is also smaller than it, </span><span class="No-Break"><span class="koboSpan" id="kobo.1989.1">namely </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1990.1">-42</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1991.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1992.1">Max-heap is not the only option</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1993.1">You can also </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1994.1">use the </span><em class="italic"><span class="koboSpan" id="kobo.1995.1">heapify</span></em><span class="koboSpan" id="kobo.1996.1"> operation to form the </span><strong class="bold"><span class="koboSpan" id="kobo.1997.1">min-heap</span></strong><span class="koboSpan" id="kobo.1998.1">. </span><span class="koboSpan" id="kobo.1998.2">It is similar to the max-heap, but each node needs </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1999.1">to meet the condition that the values of its child nodes are greater than or equal to the parent </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">node’s value.</span></span></p>
<p><span class="koboSpan" id="kobo.2001.1">Let’s proceed to the second row of the preceding figure. </span><span class="koboSpan" id="kobo.2001.2">Here, the last element of the array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2002.1">90</span></strong><span class="koboSpan" id="kobo.2003.1">) is already sorted. </span><span class="koboSpan" id="kobo.2003.2">This is the result of swapping the root (previously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2004.1">90</span></strong><span class="koboSpan" id="kobo.2005.1">) with the last element in the array (previously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2006.1">-42</span></strong><span class="koboSpan" id="kobo.2007.1">). </span><span class="koboSpan" id="kobo.2007.2">Then, you must perform another </span><em class="italic"><span class="koboSpan" id="kobo.2008.1">heapify</span></em><span class="koboSpan" id="kobo.2009.1"> operation and receive the max-heap with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2010.1">12</span></strong><span class="koboSpan" id="kobo.2011.1"> as the </span><em class="italic"><span class="koboSpan" id="kobo.2012.1">root</span></em><span class="koboSpan" id="kobo.2013.1">. </span><span class="koboSpan" id="kobo.2013.2">The aforementioned actions are repeated until the heap contains only </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.2014.1">one element. </span><span class="koboSpan" id="kobo.2014.2">In the end, you receive the sorted array, as shown in </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.2015.1">the bottom-right corner of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2016.1">preceding figure.</span></span></p>
<p><span class="koboSpan" id="kobo.2017.1">At this point, you should be ready to analyze the implementation code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2018.1">C# language:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2019.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.2020.1">Sort</span></strong><span class="koboSpan" id="kobo.2021.1">(int[] a)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.2022.1">for (int i = a.Length / 2 - 1; i &gt;= 0; i--)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2023.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2024.1">        Heapify(a, a.Length, i);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2025.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2026.1">    for (int i = a.Length - 1; i &gt; 0; i--)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2027.1">    {</span></strong><span class="koboSpan" id="kobo.2028.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.2029.1">(a[0], a[i]) = (a[i], a[0]);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2030.1">        Heapify(a, i, 0);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2031.1">    }</span></strong><span class="koboSpan" id="kobo.2032.1">
}</span></pre> <p><span class="koboSpan" id="kobo.2033.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2034.1">Sort</span></strong><span class="koboSpan" id="kobo.2035.1"> method contains two </span><strong class="source-inline"><span class="koboSpan" id="kobo.2036.1">for</span></strong><span class="koboSpan" id="kobo.2037.1"> loops. </span><span class="koboSpan" id="kobo.2037.2">The first performs the initial </span><em class="italic"><span class="koboSpan" id="kobo.2038.1">heapify</span></em><span class="koboSpan" id="kobo.2039.1"> operation to prepare the </span><em class="italic"><span class="koboSpan" id="kobo.2040.1">max-heap</span></em><span class="koboSpan" id="kobo.2041.1">. </span><span class="koboSpan" id="kobo.2041.2">You can do so by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2042.1">Heapify</span></strong><span class="koboSpan" id="kobo.2043.1"> multiple times, namely in reverse order and on each node that is not a leaf. </span><span class="koboSpan" id="kobo.2043.2">Then, you have the array with data forming </span><span class="No-Break"><span class="koboSpan" id="kobo.2044.1">the </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2045.1">max-heap</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2046.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2047.1">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.2048.1">for</span></strong><span class="koboSpan" id="kobo.2049.1"> loop is performed until there is at least one element in the heap. </span><span class="koboSpan" id="kobo.2049.2">In each iteration, it swaps the </span><em class="italic"><span class="koboSpan" id="kobo.2050.1">root</span></em><span class="koboSpan" id="kobo.2051.1"> element (with an index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2052.1">0</span></strong><span class="koboSpan" id="kobo.2053.1">) with the last element, which has an index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2054.1">i</span></strong><span class="koboSpan" id="kobo.2055.1">. </span><span class="koboSpan" id="kobo.2055.2">Then, you need to restore the </span><em class="italic"><span class="koboSpan" id="kobo.2056.1">max-heap</span></em><span class="koboSpan" id="kobo.2057.1"> property, which you do by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2058.1">Heapify</span></strong><span class="koboSpan" id="kobo.2059.1"> method, regarding the affected part of </span><span class="No-Break"><span class="koboSpan" id="kobo.2060.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.2061.1">Now, let’s take a look at the code of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2062.1">Heapify</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2063.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2064.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.2065.1">Heapify</span></strong><span class="koboSpan" id="kobo.2066.1">(int[] a, int n, int i)
{
    int max = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    max = l &lt; n &amp;&amp; a[l] &gt; a[max] ? </span><span class="koboSpan" id="kobo.2066.2">l : max;
    max = r &lt; n &amp;&amp; a[r] &gt; a[max] ? </span><span class="koboSpan" id="kobo.2066.3">r : max;
    if (max != i)
    {
        (a[i], a[max]) = (a[max], a[i]);
        Heapify(a, n, max);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.2067.1">It takes three parameters, namely an array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2068.1">a</span></strong><span class="koboSpan" id="kobo.2069.1">), the number of elements in a heap (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2070.1">n</span></strong><span class="koboSpan" id="kobo.2071.1">), as well as an index of an element (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2072.1">i</span></strong><span class="koboSpan" id="kobo.2073.1">), which is a root of a subtree that should be </span><em class="italic"><span class="koboSpan" id="kobo.2074.1">heapified</span></em><span class="koboSpan" id="kobo.2075.1">. </span><span class="koboSpan" id="kobo.2075.2">First, you get an index of the maximum</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.2076.1"> element (</span><em class="italic"><span class="koboSpan" id="kobo.2077.1">root</span></em><span class="koboSpan" id="kobo.2078.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2079.1">max</span></strong><span class="koboSpan" id="kobo.2080.1">), as well as its left and right children (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2081.1">l</span></strong><span class="koboSpan" id="kobo.2082.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2083.1">r</span></strong><span class="koboSpan" id="kobo.2084.1">, respectively). </span><span class="koboSpan" id="kobo.2084.2">You can calculate indices according to the formulas presented earlier, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.2085.1">2*i+1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2086.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2087.1">2*i+2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2088.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2089.1">In the following two lines, you check whether the left child index (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2090.1">l</span></strong><span class="koboSpan" id="kobo.2091.1">) is still within the heap (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2092.1">l&lt;n</span></strong><span class="koboSpan" id="kobo.2093.1">) and whether the element with this index (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2094.1">a[l]</span></strong><span class="koboSpan" id="kobo.2095.1">) is greater than the current root value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2096.1">a[max]</span></strong><span class="koboSpan" id="kobo.2097.1">). </span><span class="koboSpan" id="kobo.2097.2">If so, you</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.2098.1"> update the root index (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2099.1">max</span></strong><span class="koboSpan" id="kobo.2100.1">). </span><span class="koboSpan" id="kobo.2100.2">In the same way, you check the right child and adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2101.1">max</span></strong><span class="koboSpan" id="kobo.2102.1"> variable, </span><span class="No-Break"><span class="koboSpan" id="kobo.2103.1">if necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.2104.1">In the next line, you check whether the </span><em class="italic"><span class="koboSpan" id="kobo.2105.1">root</span></em><span class="koboSpan" id="kobo.2106.1"> index changed during the mentioned operations. </span><span class="koboSpan" id="kobo.2106.2">If so, this means that the current </span><em class="italic"><span class="koboSpan" id="kobo.2107.1">root</span></em><span class="koboSpan" id="kobo.2108.1"> is not the biggest value and you need to swap two elements in the array, namely representing the </span><em class="italic"><span class="koboSpan" id="kobo.2109.1">root</span></em><span class="koboSpan" id="kobo.2110.1"> (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2111.1">i</span></strong><span class="koboSpan" id="kobo.2112.1"> index) and the biggest value (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2113.1">max</span></strong><span class="koboSpan" id="kobo.2114.1"> index). </span><span class="koboSpan" id="kobo.2114.2">Next, you recursively perform the </span><em class="italic"><span class="koboSpan" id="kobo.2115.1">heapify</span></em><span class="koboSpan" id="kobo.2116.1"> operation for the affected subtree, namely a tree with a new </span><span class="No-Break"><span class="koboSpan" id="kobo.2117.1">root value.</span></span></p>
<p><span class="koboSpan" id="kobo.2118.1">After this detailed explanation, it is worth mentioning the time complexity. </span><span class="koboSpan" id="kobo.2118.2">It is very important in this case because the method is efficient and can be used successfully while sorting large data collections. </span><strong class="bold"><span class="koboSpan" id="kobo.2119.1">The time complexity is </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2120.1">O(n log(n))</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2122.1">Despite learning about seven different sorting algorithms, please keep in mind that there are many more such algorithms </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.2123.1">available, including </span><strong class="bold"><span class="koboSpan" id="kobo.2124.1">block sort</span></strong><span class="koboSpan" id="kobo.2125.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2126.1">tree sort</span></strong><span class="koboSpan" id="kobo.2127.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2128.1">cube sort</span></strong><span class="koboSpan" id="kobo.2129.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2130.1">strand sort</span></strong><span class="koboSpan" id="kobo.2131.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.2132.1">cycle sort</span></strong><span class="koboSpan" id="kobo.2133.1">. </span><span class="koboSpan" id="kobo.2133.2">If you are interested in this topic, I strongly encourage you to take a look at</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.2134.1"> them on your own. </span><span class="koboSpan" id="kobo.2134.2">In the meantime, let’s compare the algorithms we’ve covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.2135.1">this chapter.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2136.1">Performance analysis</span></h2>
<p><span class="koboSpan" id="kobo.2137.1">To perform some tests, you need </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.2138.1">to configure your environment. </span><span class="koboSpan" id="kobo.2138.2">So, let’s start by preparing the code for running various sorting algorithms using the same </span><span class="No-Break"><span class="koboSpan" id="kobo.2139.1">input arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.2140.1">Do you remember that each implementation presented in this chapter involves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2141.1">Sort</span></strong><span class="koboSpan" id="kobo.2142.1"> method, taking only one parameter (namely the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2143.1">a</span></strong><span class="koboSpan" id="kobo.2144.1"> array)? </span><span class="koboSpan" id="kobo.2144.2">Now, you can benefit from this assumption and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2145.1">AbstractSort</span></strong><span class="koboSpan" id="kobo.2146.1"> abstract class, which requires you to implement this method while deriving from </span><span class="No-Break"><span class="koboSpan" id="kobo.2147.1">this class.</span></span></p>
<p><span class="koboSpan" id="kobo.2148.1">The code for the abstract class is </span><span class="No-Break"><span class="koboSpan" id="kobo.2149.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2150.1">
public abstract class </span><strong class="bold"><span class="koboSpan" id="kobo.2151.1">AbstractSort</span></strong><span class="koboSpan" id="kobo.2152.1">
{
    public abstract void </span><strong class="bold"><span class="koboSpan" id="kobo.2153.1">Sort</span></strong><span class="koboSpan" id="kobo.2154.1">(int[] a);
}</span></pre> <p><span class="koboSpan" id="kobo.2155.1">Then, you need to prepare a separate class for each sorting algorithm (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2156.1">SelectionSort</span></strong><span class="koboSpan" id="kobo.2157.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2158.1">HeapSort</span></strong><span class="koboSpan" id="kobo.2159.1">) according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2160.1">following template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2161.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.2162.1">SelectionSort</span></strong><span class="koboSpan" id="kobo.2163.1">
    : </span><strong class="bold"><span class="koboSpan" id="kobo.2164.1">AbstractSort</span></strong><span class="koboSpan" id="kobo.2165.1">
{
    public override void </span><strong class="bold"><span class="koboSpan" id="kobo.2166.1">Sort</span></strong><span class="koboSpan" id="kobo.2167.1">(int[] a) { (...) }
}</span></pre> <p><span class="koboSpan" id="kobo.2168.1">Since all the classes representing sorting algorithms derive from the base abstract class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2169.1">AbstractSort</span></strong><span class="koboSpan" id="kobo.2170.1">)you can </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.2171.1">easily create a list containing </span><span class="No-Break"><span class="koboSpan" id="kobo.2172.1">their instances:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2173.1">List&lt;AbstractSort&gt;</span></strong><span class="koboSpan" id="kobo.2174.1"> algorithms = new()
{
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2175.1">SelectionSort</span></strong><span class="koboSpan" id="kobo.2176.1">(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2177.1">InsertionSort</span></strong><span class="koboSpan" id="kobo.2178.1">(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2179.1">BubbleSort</span></strong><span class="koboSpan" id="kobo.2180.1">(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2181.1">MergeSort</span></strong><span class="koboSpan" id="kobo.2182.1">(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2183.1">ShellSort</span></strong><span class="koboSpan" id="kobo.2184.1">(),
</span><strong class="bold"><span class="koboSpan" id="kobo.2185.1">    </span></strong><span class="koboSpan" id="kobo.2186.1">new </span><strong class="bold"><span class="koboSpan" id="kobo.2187.1">QuickSort</span></strong><span class="koboSpan" id="kobo.2188.1">(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.2189.1">HeapSort</span></strong><span class="koboSpan" id="kobo.2190.1">()
};</span></pre> <p><span class="koboSpan" id="kobo.2191.1">The most interesting part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.2192.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2193.1">for (int n = 0; n &lt;= 100000; n += 10000)</span></strong><span class="koboSpan" id="kobo.2194.1">
{
    Console.WriteLine($"\nRunning tests for n = {n}:");
    </span><strong class="bold"><span class="koboSpan" id="kobo.2195.1">List&lt;(Type Type, long Ms)&gt; milliseconds = [];</span></strong><span class="koboSpan" id="kobo.2196.1">
    for (int i = 0; i &lt; 5; i++)
    {
        int[] array = GetRandomArray(n);
        int[] input = new int[n];
        </span><strong class="bold"><span class="koboSpan" id="kobo.2197.1">foreach (AbstractSort algorithm in algorithms)</span></strong><span class="koboSpan" id="kobo.2198.1">
        {
            array.CopyTo(input, 0);
            Stopwatch stopwatch = Stopwatch.StartNew();
            </span><strong class="bold"><span class="koboSpan" id="kobo.2199.1">algorithm.Sort(input);</span></strong><span class="koboSpan" id="kobo.2200.1">
            stopwatch.Stop();
            Type type = algorithm.GetType();
            long ms = stopwatch.ElapsedMilliseconds;
            </span><strong class="bold"><span class="koboSpan" id="kobo.2201.1">milliseconds.Add((type, ms));</span></strong><span class="koboSpan" id="kobo.2202.1">
        }
    }
    List&lt;(Type, double)&gt; results = milliseconds
        .GroupBy(r =&gt; r.Type)
        .Select(r =&gt;
            (r.Key, r.Average(t =&gt; t.Ms))).ToList();
    foreach ((Type type, double avg) in results)
    {
        Console.WriteLine($"{type.Name}: {avg} ms");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.2203.1">Here, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2204.1">for</span></strong><span class="koboSpan" id="kobo.2205.1"> loop to choose suitable values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2206.1">n</span></strong><span class="koboSpan" id="kobo.2207.1">, which is the length of the input array used for sorting. </span><span class="koboSpan" id="kobo.2207.2">You</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.2208.1"> start with an array with zero elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2209.1">n</span></strong><span class="koboSpan" id="kobo.2210.1"> = </span><strong class="source-inline"><span class="koboSpan" id="kobo.2211.1">0</span></strong><span class="koboSpan" id="kobo.2212.1">) and end with hundreds of thousands of elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2213.1">n</span></strong><span class="koboSpan" id="kobo.2214.1"> = </span><strong class="source-inline"><span class="koboSpan" id="kobo.2215.1">100000</span></strong><span class="koboSpan" id="kobo.2216.1">), increasing the size by </span><strong class="source-inline"><span class="koboSpan" id="kobo.2217.1">10000</span></strong><span class="koboSpan" id="kobo.2218.1"> in each iteration. </span><span class="koboSpan" id="kobo.2218.2">The values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2219.1">n</span></strong><span class="koboSpan" id="kobo.2220.1"> will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.2221.1">0</span></strong><span class="koboSpan" id="kobo.2222.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2223.1">10000</span></strong><span class="koboSpan" id="kobo.2224.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2225.1">20000</span></strong><span class="koboSpan" id="kobo.2226.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2227.1">30000</span></strong><span class="koboSpan" id="kobo.2228.1">, up </span><span class="No-Break"><span class="koboSpan" id="kobo.2229.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2230.1">100000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2231.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2232.1">In each iteration, you create a new instance of the list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2233.1">milliseconds</span></strong><span class="koboSpan" id="kobo.2234.1">) . </span><span class="koboSpan" id="kobo.2234.2">Each its element stores a tuple consisting of two elements, namely a type of the sorting algorithm class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2235.1">Type</span></strong><span class="koboSpan" id="kobo.2236.1">) and elapsed milliseconds of execution (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2237.1">Ms</span></strong><span class="koboSpan" id="kobo.2238.1">). </span><span class="koboSpan" id="kobo.2238.2">Then, you use another </span><strong class="source-inline"><span class="koboSpan" id="kobo.2239.1">for</span></strong><span class="koboSpan" id="kobo.2240.1"> loop to perform such tests </span><strong class="source-inline"><span class="koboSpan" id="kobo.2241.1">5</span></strong><span class="koboSpan" id="kobo.2242.1"> times. </span><span class="koboSpan" id="kobo.2242.2">In each of them, you get a random array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2243.1">array</span></strong><span class="koboSpan" id="kobo.2244.1">) with a given size by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.2245.1">GetRandomArray</span></strong><span class="koboSpan" id="kobo.2246.1">, which will be used as a template for each test. </span><span class="koboSpan" id="kobo.2246.2">Next, you declare and initialize the input </span><span class="No-Break"><span class="koboSpan" id="kobo.2247.1">array (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2248.1">input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2249.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.2250.1">The next part involves a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2251.1">foreach</span></strong><span class="koboSpan" id="kobo.2252.1"> loop and iterates through all instances of classes deriving from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2253.1">AbstractSort</span></strong><span class="koboSpan" id="kobo.2254.1">. </span><span class="koboSpan" id="kobo.2254.2">For each of them, you create an input array by copying elements from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2255.1">array</span></strong><span class="koboSpan" id="kobo.2256.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2257.1">input</span></strong><span class="koboSpan" id="kobo.2258.1">. </span><span class="koboSpan" id="kobo.2258.2">Then, you start the stopwatch and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2259.1">Sort</span></strong><span class="koboSpan" id="kobo.2260.1"> method. </span><span class="koboSpan" id="kobo.2260.2">As soon as it has finished running, you stop the stopwatch and add results to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2261.1">milliseconds</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2262.1"> list.</span></span></p>
<p><span class="koboSpan" id="kobo.2263.1">The last part of the code is </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.2264.1">related to calculating the average result for each sorting algorithm and its presentation in the console. </span><span class="koboSpan" id="kobo.2264.2">To do so, you use a few extension methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2265.1">GroupBy</span></strong><span class="koboSpan" id="kobo.2266.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2267.1">Select</span></strong><span class="koboSpan" id="kobo.2268.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2269.1">Average</span></strong><span class="koboSpan" id="kobo.2270.1">, as well as a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2271.1">foreach</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2272.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.2273.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2274.1">GetRandomArray</span></strong><span class="koboSpan" id="kobo.2275.1"> method was mentioned earlier, so let’s take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.2276.1">at it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2277.1">
int[] </span><strong class="bold"><span class="koboSpan" id="kobo.2278.1">GetRandomArray</span></strong><span class="koboSpan" id="kobo.2279.1">(long length)
{
    Random random = new();
    int[] array = new int[length];
    for (int i = 0; i &lt; length; i++) 
    {
        array[i] = random.Next(-100000, 100000);
    }
    return array;
}</span></pre> <p><span class="koboSpan" id="kobo.2280.1">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2281.1">Random</span></strong><span class="koboSpan" id="kobo.2282.1"> class to get a random integer value in the range of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2283.1">&lt;-100,000, 100,000)</span></strong><span class="koboSpan" id="kobo.2284.1">. </span><span class="koboSpan" id="kobo.2284.2">The whole array is filled with such </span><span class="No-Break"><span class="koboSpan" id="kobo.2285.1">random values.</span></span></p>
<p><span class="koboSpan" id="kobo.2286.1">At this point, your environment is ready and you can perform tests! </span><span class="koboSpan" id="kobo.2286.2">So, let’s run the code and see the results. </span><span class="koboSpan" id="kobo.2286.3">I received the </span><span class="No-Break"><span class="koboSpan" id="kobo.2287.1">following values:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.2288.1"><img alt="Figure 3.14 – Results of analyzing the performance of ﻿the sorting algorithms" src="image/B18069_03_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2289.1">Figure 3.14 – Results of analyzing the performance of the sorting algorithms</span></p>
<p><span class="koboSpan" id="kobo.2290.1">Apart from the table and its data, let’s take</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.2291.1"> a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.2292.1">the chart:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.2293.1"><img alt="Figure 3.15 – Comparison of the sorting algorithms’ performance results" src="image/B18069_03_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2294.1">Figure 3.15 – Comparison of the sorting algorithms’ performance results</span></p>
<p><span class="koboSpan" id="kobo.2295.1">As you can see, the worst results are received for bubble sort, then the insertion sort and selection sort algorithms. </span><span class="koboSpan" id="kobo.2295.2">For an array with 100,000 elements, they need almost 33 seconds (bubble sort), almost 14 seconds (insertion sort), and more than 5 seconds (selection sort). </span><span class="koboSpan" id="kobo.2295.3">Such values </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.2296.1">look extremely high compared to the results of merge sort, Shell sort, quicksort, and heap sort. </span><span class="koboSpan" id="kobo.2296.2">These algorithms needed between 12 and 28 milliseconds! </span><span class="koboSpan" id="kobo.2296.3">Does this seem surprising? </span><span class="koboSpan" id="kobo.2296.4">It shouldn’t if you recall </span><span class="No-Break"><span class="koboSpan" id="kobo.2297.1">time complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.2298.1">Let’s remember the average time complexity for the </span><span class="No-Break"><span class="koboSpan" id="kobo.2299.1">mentioned algorithms:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.2300.1">O(n</span></em><span class="superscript"><span class="koboSpan" id="kobo.2301.1">2</span></span><em class="italic"><span class="koboSpan" id="kobo.2302.1">)</span></em><span class="koboSpan" id="kobo.2303.1">: Selection sort, insertion sort, and </span><span class="No-Break"><span class="koboSpan" id="kobo.2304.1">bubble sort</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.2305.1">O(n log(n))</span></em><span class="koboSpan" id="kobo.2306.1">: Merge sort, Shell sort, quicksort, and </span><span class="No-Break"><span class="koboSpan" id="kobo.2307.1">heap sort</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2308.1">Oh, so it seems that such time complexities really have an importance! </span><span class="koboSpan" id="kobo.2308.2">;-) If you earlier had any doubts, it’s the high time to take attention to the algorithms you use in your applications. </span><span class="koboSpan" id="kobo.2308.3">You should choose them carefully and optimize the solution to handle various amounts of data that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.2309.1">be processed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.2310.1">Don’t forget about performance</span></p>
<p class="callout"><span class="koboSpan" id="kobo.2311.1">Taking care of performance is important not only for sorting but for all operations that you perform in your mobile applications, web applications, APIs, and long-running background services. </span><span class="koboSpan" id="kobo.2311.2">Let’s try to write efficient code and test it not only by meeting the functional requirements but also by taking care of non-functional ones, such as those related </span><span class="No-Break"><span class="koboSpan" id="kobo.2312.1">to performance.</span></span></p>
<p><span class="koboSpan" id="kobo.2313.1">In the previous chart, you almost cannot see any data regarding the algorithms with </span><em class="italic"><span class="koboSpan" id="kobo.2314.1">O(n log(n))</span></em><span class="koboSpan" id="kobo.2315.1"> time complexity, so </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.2316.1">let’s prepare another set of tests. </span><span class="koboSpan" id="kobo.2316.2">Now, you can choose only these algorithms and increase the maximum number of </span><em class="italic"><span class="koboSpan" id="kobo.2317.1">n</span></em><span class="koboSpan" id="kobo.2318.1"> to one million! </span><span class="koboSpan" id="kobo.2318.2">You can see my results in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2319.1">following chart:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.2320.1"><img alt="Figure 3.16 – Comparison of the sorting algorithms’ performance results" src="image/B18069_03_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2321.1">Figure 3.16 – Comparison of the sorting algorithms’ performance results</span></p>
<p><span class="koboSpan" id="kobo.2322.1">There are some differences here, especially between quicksort and the remaining ones, namely Shell sort, merge sort, and heap sort. </span><span class="koboSpan" id="kobo.2322.2">However, such changes are only visible with quite a huge input size and can be caused by the implementation details. </span><span class="koboSpan" id="kobo.2322.3">All of the sorting algorithms with </span><em class="italic"><span class="koboSpan" id="kobo.2323.1">O(n log(n))</span></em><span class="koboSpan" id="kobo.2324.1"> time complexity are good solutions for sorting and can handle various amounts of data. </span><span class="koboSpan" id="kobo.2324.2">It is also worth noting that these results were received on my device, so you may get different results. </span><span class="koboSpan" id="kobo.2324.3">However</span><a id="_idTextAnchor126"/><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.2325.1">, the relationship between the received </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.2326.1">number of elapsed milliseconds should </span><span class="No-Break"><span class="koboSpan" id="kobo.2327.1">be consistent.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.2328.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2329.1">Arrays are among the most common data structures that are used while developing various kinds of applications, such as mobile, web, or distributed ones. </span><span class="koboSpan" id="kobo.2329.2">However, this topic is not as easy as it seems to be because even arrays can be divided into a few variants, namely </span><strong class="bold"><span class="koboSpan" id="kobo.2330.1">single-dimensional</span></strong><span class="koboSpan" id="kobo.2331.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2332.1">multi-dimensional</span></strong><span class="koboSpan" id="kobo.2333.1">, such as two-dimensional and three-dimensional, as well as </span><strong class="bold"><span class="koboSpan" id="kobo.2334.1">jagged arrays</span></strong><span class="koboSpan" id="kobo.2335.1">, also referred to as arrays </span><span class="No-Break"><span class="koboSpan" id="kobo.2336.1">of arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.2337.1">While talking about arrays, don’t forget about </span><strong class="bold"><span class="koboSpan" id="kobo.2338.1">sorting algorithms</span></strong><span class="koboSpan" id="kobo.2339.1">, which are one of the most popular algorithms used with this data structure. </span><span class="koboSpan" id="kobo.2339.2">There are plenty of sorting algorithms that differ by their concept, application, implementation details, and performance results. </span><span class="koboSpan" id="kobo.2339.3">In this chapter, you learned about seven different sorting algorithms, namely </span><strong class="bold"><span class="koboSpan" id="kobo.2340.1">selection sort</span></strong><span class="koboSpan" id="kobo.2341.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2342.1">insertion sort</span></strong><span class="koboSpan" id="kobo.2343.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2344.1">bubble sort</span></strong><span class="koboSpan" id="kobo.2345.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2346.1">merge sort</span></strong><span class="koboSpan" id="kobo.2347.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2348.1">Shell sort</span></strong><span class="koboSpan" id="kobo.2349.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.2350.1">quicksort</span></strong><span class="koboSpan" id="kobo.2351.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.2352.1">heap sort</span></strong><span class="koboSpan" id="kobo.2353.1">. </span><span class="koboSpan" id="kobo.2353.2">Each of them was described, visualized in figures, and written in </span><span class="No-Break"><span class="koboSpan" id="kobo.2354.1">C# code.</span></span></p>
<p><span class="koboSpan" id="kobo.2355.1">At the end of this chapter, you saw how important time complexity is and how big an impact it can have on </span><strong class="bold"><span class="koboSpan" id="kobo.2356.1">performance results</span></strong><span class="koboSpan" id="kobo.2357.1"> while you’re using algorithms with different computational complexity, such as </span><em class="italic"><span class="koboSpan" id="kobo.2358.1">O(n</span></em><span class="superscript"><span class="koboSpan" id="kobo.2359.1">2</span></span><em class="italic"><span class="koboSpan" id="kobo.2360.1">)</span></em><span class="koboSpan" id="kobo.2361.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.2362.1">O(n log(n))</span></em><span class="koboSpan" id="kobo.2363.1">. </span><span class="koboSpan" id="kobo.2363.2">You learned how to prepare a simple environment for the performance tests and run them to get the results. </span><span class="koboSpan" id="kobo.2363.3">They were later shown in a table, as well as in charts, together with </span><span class="No-Break"><span class="koboSpan" id="kobo.2364.1">an explanation.</span></span></p>
<p><span class="koboSpan" id="kobo.2365.1">Are you ready to learn other data structures? </span><span class="koboSpan" id="kobo.2365.2">If so, proceed to the next chapter, where you’ll learn about various </span><strong class="bold"><span class="koboSpan" id="kobo.2366.1">variants of lists</span></strong><span class="koboSpan" id="kobo.2367.1">, namely simple, generic, sorted, as well as singly, doubly, and circular linked. </span><span class="koboSpan" id="kobo.2367.2">You will see their implementation and a few examples of how you can use them in </span><span class="No-Break"><span class="koboSpan" id="kobo.2368.1">real-world examples.</span></span></p>
</div>
</body></html>