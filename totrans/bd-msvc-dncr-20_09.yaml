- en: Introduction to Reactive Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now gained a clear understanding of microservices-based architecture
    and how to harness its power. Up until now, we''ve discussed various aspects of
    this architecture, such as communication, deployment, and security, in detail.
    We also looked at how microservices collaborate when required. Now let''s take
    the effectiveness of microservices to the next level by introducing the reactive
    programming aspect within them. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reactive microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication in reactive microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding reactive microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into reactive microservices, let's see what the word *reactive* means.
    There are certain fundamental attributes that a piece of software must possess
    in order to be considered reactive. These attributes are responsiveness, resilience,
    elasticity, and above all, being message-driven. We'll discuss these attributes
    in detail and look at how they can make microservices stronger candidates for
    most enterprise requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It wasn't long ago when one of the key requirements of business sponsors, discussed
    in requirement gathering sessions, was a guaranteed response time of a few seconds.
    For example, a T-shirt custom print e-shop where you could upload images and then
    have it rendered onto the chosen piece of apparel. Move forward a few years and—I
    can vouch for this myself—we will close the browser window if any web page takes
    longer than a couple of seconds to load.
  prefs: []
  type: TYPE_NORMAL
- en: Users today expect near instantaneous response. But this is not possible unless
    the code that you write follows certain standards to deliver the expected performance.
    There will always be so many different components cooperating and coordinating
    to solve some business problem. The time that each component is expected to return
    the results in has therefore reduced to milliseconds today. Also, the system has
    to exhibit consistency along with performance when it comes to response time.
    If you have a service that exhibits variable response times over a defined period,
    then it is a sign of an impending problem in your system. You will have to, sooner
    or later, deal with this baggage. And there is no doubt that in most cases, you
    will manage to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: However, the challenge is much bigger than what is visible on the surface. Any
    such trait needs to be probed for the possibility of an issue in the design. It
    could be some kind of dependency on another service, too many functions performing
    at the same time within the service, or synchronous communication blocking the
    workflow at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the buzz around distributed computing, what does a user expect from
    such a system in the event of the failure of one or more components? Does a single
    failure result in a catastrophic domino effect, resulting in the failure of the
    entire system? Or does the system bounce back from such an event with grace and
    within expected timelines? The end user shouldn't be affected at all in such scenarios,
    or the system should at least minimize the impact to an extent, ensuring that
    user experience is not affected.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive microservices take the concept of microservices to the next level.
    As the number of microservices grows, so does the need for communication between
    them. It won't be very long before the task of tracking a list of a dozen other
    services, orchestrating a cascading transaction between them, or just generating
    a notification across a set of services, becomes a challenge. In the scope of
    this chapter, the concept of cascading is more important than the transaction
    itself. Instead of the transaction, it could very well be just the need to notify
    some external system based on some filtering criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge arises as an enterprise-level microservice-based system would
    always extend far beyond a handful of microservices. The sheer size and complexity
    of this cannot be pictured fully here in a chapter. In such a scenario, the need
    to track a set of microservices and communicate with them can quickly become nightmarish.
  prefs: []
  type: TYPE_NORMAL
- en: What if we could take away the responsibility of communicating an event to other
    microservices from individual microservices? The other aspect of this could very
    well be freedom for the services in the ecosystem from being tracked. To do this,
    you will have to keep track of their whereabouts. Just add authentication to this
    and you could very easily be tangled in a mess you never signed up for.
  prefs: []
  type: TYPE_NORMAL
- en: The solution lies in a design change, where the responsibility of tracking microservices
    for an event or communicating an event to others is taken away from individual
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: While transitioning from a monolithic application to a microservice-style architecture,
    we learned that they are isolated. Using seam identification, we isolated modules
    into independent sets of services that own their data and don't allow other microservices/processes
    to access them directly. We achieved autonomy by catering to a single business
    functionality and taking care of aspects such as its data and encapsulated business
    functionality. Asynchronous was another characteristic that we achieved for our
    microservices in order to make non-blocking calls to them.
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All along, we have been strongly advocating the correct isolation of microservices.
    Seam identification was a concept we briefly touched on in Chapter 2, *Implementing
    Microservices*. There were numerous benefits that we derived while successfully
    implementing the microservice-style architecture. We can safely state that isolation
    is one of the fundamental requirements here. However, the benefits of successful
    implementation of isolation go far beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important for microservices to be autonomous, or else our work will
    be incomplete. Even after implementing the microservice architecture, if one microservice
    failure results in a delay for other services or a domino effect, it means we
    missed something in our design. However, if microservice isolation is done right,
    along with the right breakdown of the functionality to be performed by this particular
    microservice, it would mean that the rest of the design would fall into place
    itself to handle any kind of resolution conflict, communication, or coordination.
  prefs: []
  type: TYPE_NORMAL
- en: The information required to perform such an orchestration would depend primarily
    on the well-defined behavior of the service itself. So, the consumer of a microservice
    that is well-defined doesn't need to worry about the microservice failing or throwing
    an exception. If there is no response within the stipulated period of time, just
    try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Message-driven: a core of reactive microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being message-driven is the core of reactive microservices. All reactive microservices
    define, as part of their behavior, any event that they might be generating. These
    events may or may not have additional information payloads within them, depending
    on the design of the individual event. The microservice that is the generator
    of this event would not be bothered about whether the event generated was acted
    upon or not. Within the scope of this specific service, there is no behavioral
    definition for the action beyond the generation of this event. The scope ends
    there. It is now, in terms of the rest of the system, comprising other microservices
    to act upon this information based on their individual scope.
  prefs: []
  type: TYPE_NORMAL
- en: The difference here is that all these events being generated could be captured
    asynchronously by listening to them. No other service is waiting in blocking mode
    for any of these services. Anyone listening to these events is called a subscriber,
    and the action of listening for the events is called subscribing. The services
    that subscribe to these events are called **observers**, and the source service
    of the events generated is called **observable**. This pattern is known as the
    **Observer Design Pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: However, the very exercise of a concrete implementation on each of the observers
    is somewhat inconsistent with our motto of designing loosely coupled microservices.
    If this is what you are thinking, then you have the right thinking cap on and
    we are on the right track. In a short while, when mapping our processes as reactive
    microservices, we will see how we can achieve this purpose in the world of reactive
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on with mapping our processes, it is important that we briefly
    discuss the pattern with respect to our topic here. In order to act upon a message,
    you first need to show your intent to watch the message of that type. At the same
    time, the originator of the message must have an intent to publish such a message
    to the interested observers. So there would be at least one observable to be observed
    by one or more observers. To add some spice to it, the observable can publish
    more than one type of message, and the observers can observe one or more of the
    messages they intend to act upon.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern doesn't restrict observers from unsubscribing when they want to
    stop listening for these messages. So, it sounds pretty, but is it as easily implemented?
    Let's move ahead and look at this for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make code reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine our application and see how it would look with the reactive
    style of programming. The following diagram depicts the flow of the application
    that is reactive in nature and is completely event-driven. In this diagram, services
    are depicted by hexagons, and events are represented by square boxes. Here''s the
    entire flow in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ac2cf0-9c5d-4f19-b41c-08ee4fc70e68.png)'
  prefs: []
  type: TYPE_IMG
- en: The flow depicted in the diagram describes the scenario of a customer placing
    an order after having searched for the items he/she is looking for. The **Place
    order** event is raised to **Order service**. In response to this event, our service
    analyzes arguments, such as order item and quantity, and raises the **Item **available event
    to **Product service**. From here on, there are two possible outcomes: either
    the requested product is available and has the required quantity or it is not
    available or doesn't have the required quantity. If the items are available, **Product
    service** raises an event called generate invoice to **Invoice service**. Since
    raising the invoice means confirming the order, the items on the invoice would
    no longer be available in stock; we need to take care of this and update the stock
    accordingly. To handle this, our invoice service further raises an event called **Update
    Product Quantity** to **Product service** and takes care of this requirement.
    For the sake of simplicity, we will not go into the details of who will handle
    the event of **Mail invoice**.
  prefs: []
  type: TYPE_NORMAL
- en: Event communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding discussion may have left you thinking about how the event being
    raised maps the call of the respective microservice perfectly; let''s discuss
    this in further detail. Think of all the events being raised as being stored in
    an event store. The event stored has an associated delegate function that is called
    to cater to the respective event. Although it is shown that the store has just
    two columns, it stores much more information, such as details of the publisher,
    subscriber, and so on. Each event contains the complete information that is required
    to trigger the corresponding service. So event delegation might be a service to
    be called or a function within the application itself. It doesn''t matter to this
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29962310-822b-4399-9140-311aacc3da72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous ways in which security can be handled while implementing
    reactive microservices. However, given the limited scope that we have here, we
    will restrict our discussion to one type only. Let's go on and discuss message-level
    security here and see how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: Message-level security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message-level security is the most fundamental method available to secure your
    individual request messages. After the initial authentication is performed, the
    request message itself may contain the OAuth bearer token or the JWTs, based on
    the implementation. This way, each and every request is authenticated, and the
    information related to the user can be embedded within these tokens. The information
    could be as simple as a username along with an expiration timestamp indicating
    token validity. After all, we don't want to allow a token to be utilized beyond
    a certain time frame.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note here that you are free to implement it in such
    a manner so that a lot more information can be embedded and utilized for different
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another aspect you need to consider here as well. Within this token,
    we could also embed authorization information apart from authentication information.
    Note that having all of this information within a token that is being passed around
    frequently could soon become an overhead. We can make the necessary changes to
    ensure that the information pertaining to the authorization is a one-time activity
    and is later persisted with the services as required.
  prefs: []
  type: TYPE_NORMAL
- en: When we decide to persist authorization-related information with individual
    services, we make them elastic in a way. The task of persisting authorization
    information with individual services does away with the requirement of reaching
    out to the authentication service each time for authorization-related data. This
    means we can scale our services quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Communication resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What would happen if the authentication service that contains all the user authentication
    data and authorization data became unavailable? Does this mean that the entire
    microservice ecosystem would come down to its knees, as all the actions—or a big
    percentage of them—would need to be authorized for the user attempting the action?
    This does not fit in the domain of the microservice architecture. Let's see how
    we could deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: One way would be to replicate user authorization data within each service that
    requires it. When the authorization data is already available with the respective
    services, it will reduce the data being transferred through the JWTs being moved
    around. What this would achieve is that in the event our Auth service becomes
    unavailable, the users who are authenticated and have accessed the system would
    not be affected. With all of the authorization data already available within the
    individual services that need to verify it, the business can continue as usual
    without any hindrances.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach comes with a price of its own. It will become a challenge
    to maintain this data, as it is updated all the time with all the services. The
    replication required for each service would be an exercise in itself. There is
    a way out of this specific challenge as well, though.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of making this data available in all the microservices, we could simply
    store it in a central store and have the services validate/access authorization-related
    data from this central store. This would enable us to build resilience beyond
    the authentication service.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking a single order being placed is easy. However, multiply that number
    with the million orders being placed and canceled every hour; it could quickly
    become a challenge in the reactive microservices domain. The challenge is how
    you would perform a transaction across multiple services. Not only is it difficult
    to track such a transaction, but it poses other challenges, such as persisting
    such a transaction that spans the database and message broker. The task of reversing
    such an operation in the likelihood of the transaction breaking somewhere in the
    middle due to a service failure could be even more daunting.
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, we can utilize the event sourcing pattern. This is a strong
    candidate, especially since we are not looking for a two-phase commit, generally
    referred to as 2PC. Instead of storing a transaction, we persist all the state-changing
    events of our entities. In other words, we store all the events that change their
    states in the form of entities, such as order and product. When a client places
    an order, then under regular circumstances, we would persist the order to the
    order table as a row. However, here we will persist the entire sequence of events,
    up to the final stage of the order being accepted or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the preceding diagram, where we analyzed the sequence of events that
    are generated while creating an order. Look at how those events will be stored
    in this pattern and how a transaction would be deduced from that set of events.
    First, let''s see how the data will be stored. As seen in the following diagram,
    individual records are saved as rows. Data consistency is confirmed after the
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca2d4397-ca55-4e7f-885a-13b3b13361e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the preceding diagram, the **Product service** can subscribe to
    the order events and update itself accordingly. There are numerous benefits to
    be derived from this approach, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the events are being persisted, the challenge of recognizing a transaction
    is separated from the task of maintaining database integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to find the exact state of the system at any given point in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to migrate a monolith with this approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to move back in time to a specific set of events and identify
    any possible problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image is depicting our **Order** and **Order Details** table(s)
    in view of **Order service**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cc3dc4a-12d7-43fe-9d19-86f35c3706be.png)'
  prefs: []
  type: TYPE_IMG
- en: Apart from all the benefits, it has some drawbacks as well. The most important
    one is how to query the event store. To reconstruct the state of a given business
    entity at a given point in time would require some complex queries. Apart from
    this, there would be a learning curve involved to grasp the concept of an event
    store replacing the database and then deducing the state of an entity. Query complexity
    can be handled with the help of the CQRS pattern easily. However, this will be
    outside the scope of this chapter. It is worthwhile to note that the event sourcing
    pattern and CQRS deserve separate chapters in the wake of reactive microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the initial chapters, we need to get ready for big changes when
    embracing microservices. The discussions we've presented on deployment, security,
    and testing so far would have had you thinking by now about accepting this fact.
    Unlike monoliths, the adoption of microservices requires you to prepare beforehand
    so that you start building the infrastructure along with it and not after it.
    In a way, microservices thrive in a complete ecosystem where everything is worked
    out, from deployment to testing, security, and monitoring. The returns associated
    with embracing such a change are huge. There is definitely a cost involved to
    make all these changes. However, instead of having a product that doesn't get
    on the market, it is better to incur some costs and design and develop something
    that thrives and does not die out after the first few rollouts.
  prefs: []
  type: TYPE_NORMAL
- en: Coding reactive microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's try to sum up everything and see how it actually looks in the code.
    We will use Visual Studio 2017 for this. The first step is to create a reactive
    microservice, and then we will move onto creating a client for consuming the service
    created by us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now go ahead and create our reactive microservice example. In order
    to do this, we need to create a project of the ASP.NET web application type. Just
    follow these steps and you should be able to see your first reactive microservice
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by navigating to File | New | Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the installed templates, select .NET Core | ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name it `FlixOne.BookStore.ProductService` and click on OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b057fc3c-85ba-40a0-b9f7-51641480ac89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the New ASP.NET Core Web Application screen, select .NET Core and ASP.NET
    Core 2.0 and then select Web Application (Model-View-Controller) and click on OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8cf49cfa-2873-4e9f-b57f-01422029d466.png)'
  prefs: []
  type: TYPE_IMG
- en: You can enable Docker support for Windows if you enable the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have selected C#7.1; to do so, right-click on the project from
    the solution explorer and click on Properties. From the project properties screen,
    click on the Build tab and then scroll down to Advance. Click on Advance, and
    then select C# 7.1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fbc7aaf8-5dc7-4167-965c-ebf0b885a8b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open NuGet Manager and add the System.Reactive.Core NuGet package to the project.
    Make sure you select Include prerelease on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fad91898-4d26-4241-bd49-8e5f128706c0.png)'
  prefs: []
  type: TYPE_IMG
- en: You are also required to add a package for EF core; to do so, refer to the *EF
    Core migrations* section in Chapter 2, *Implementing Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Product.cs` model to the `Models` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Category.cs` model to the `Models` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Add `context` and `persistence` folders to the project. Add `ProductContext` to the `context` folder,
    and add the `IProductRepository` interface and the `ProductRepository` class to
    the `persistence` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, showing our context and persistence classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have created our models. Our next step is to add the code for interacting
    with the database. These models help us project data from a data source into our
    models.
  prefs: []
  type: TYPE_NORMAL
- en: For database interaction, we have already created a context, namely `ProductContext`,
    deriving it from `DbContext`. In one of the preceding steps, we created a folder
    named `Context`.
  prefs: []
  type: TYPE_NORMAL
- en: The Entity Framework Core context helps query the database. Also, it helps us
    collate all the changes that we perform on our data and execute them on the database
    in one go. We will not go into detail about Entity Framework Core or the contexts
    here, because they are not part of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The context picks the connection string from the `appsettings.json` file in
    the `connectionStrings` section—a key named `ProductConnectionString`.
  prefs: []
  type: TYPE_NORMAL
- en: You are required to update the `startup.cs` file to make sure you're using a
    correct database. We have already discussed modifying the `appsettings.json` and
    `Statrup.cs` files in [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml),
    *Implement Microservices*. You need to add the `Swashbuckle.AspNetCore` NuGet
    package for Swagger support in the project while updating the `Startup.cs` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could name it anything shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Communication between the application and the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our context in place, and taking care of the communication between our
    application and the database, let's go ahead and add a repository for facilitating
    interaction between our data models and our database. Please refer to the code
    for our repository, as discussed in step 10 of the *Creating the project* section.
  prefs: []
  type: TYPE_NORMAL
- en: Marking our result from `GetAll` as `IObservable` adds the reactive functionality
    we are looking for. Also, pay special attention to the return statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this observable model, it becomes possible for us to handle streams of
    asynchronous events with the same ease we are used to when handling other, simpler
    collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to expose the functionality through our controllers. Right-click
    on the folder controller, click on Add New Item, and then select ASP.NET Core,
    Web API Controller class. Name it `ProductController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/247eb9fe-30fa-454b-9f67-d32fb4b55410.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is what our controller will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final structure looks similar to the following screenshot of the Solution
    explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96684d1a-efe5-41b0-96b2-e6c1984d3245.png)'
  prefs: []
  type: TYPE_IMG
- en: To create the database, you can refer to the *EF Core migrations* section in Chapter
    2, *Implementing Microservices*, or simply call the Get API of our newly deployed
    service. When the service finds out that the database doesn't exist, the entity
    framework core code-first approach, in this case, will ensure that the database
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: We can now go ahead and deploy this service to our client. With our reactive
    microservice deployed, we now need a client to call it.
  prefs: []
  type: TYPE_NORMAL
- en: Client – coding it down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a web client for consuming our newly deployed reactive microservice
    with the help of AutoRest. Let''s create a console application for it and add
    these NuGet packages: `Reactive.Core`, `WebApi.Client`, `Microsoft.Rest.ClientRuntime`,
    and `Newtonsoft.Json`:'
  prefs: []
  type: TYPE_NORMAL
- en: AutoRest will add a folder named `Models` to the main project and create copies
    of the model's product and category, as in the service that we just created. It
    will have the necessary deserialization support built into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ProductOperations.cs` and `ProductServiceClient.cs` contain the main plumbing
    required for all the calling.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Main` function of the `Program.cs` file, change the `Main` function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if the database is not created, then it will be created as required
    by the Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: We need to know how this list, which is returned from our microservice, differs
    from the regular list. The answer is that if this were a non-reactive scenario
    and you were to make any changes to the list, it would not be reflected in the
    server. In the case of reactive microservices, changes that are made to such a
    list would be persisted to the server without having to go through the process
    of tracking and updating the changes manually.
  prefs: []
  type: TYPE_NORMAL
- en: You can use any other client to make the Web API call (for example, RestSharp,
    or HttpClient).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we had to do very little or no work at all when it
    came to messy callbacks. This helps keep our code clean and easier to maintain.
    With an observable, it is the producer that pushes the values when they are available.
    Also, there is a difference here that the client is not aware of: whether your
    implementation is blocking or non-blocking. To the client, it all seems asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: You can now focus on important tasks rather than figuring out what calls to
    make next or which ones you missed altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the aspect of reactive programming to our microservice-based
    architecture. There are trade-offs with this message-driven approach of microservices
    communicating with each other. However, at the same time, this approach tends
    to solve some of the fundamental problems when we advance our microservice architecture
    further. The event sourcing pattern comes to our rescue and lets us get past the
    limitation of an ACID transaction or a two-phase commit option. This topic requires
    a separate book altogether, and restricting it to a single chapter does not do
    it justice. We used our sample application to understand how to restructure our
    initial microservice in a reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have the entire application ready for us to explore,
    and we will put together everything that we have discussed so far in this book.
  prefs: []
  type: TYPE_NORMAL
