- en: '*Chapter 8*: File and Stream I/O'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：文件和流I/O'
- en: In this chapter, you will learn how to improve directory, file, and streaming
    performance. You will also learn how to efficiently enumerate directories, process
    small and large files, perform asynchronous operations, use local storage, handle
    exceptions, and work with memory efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何提高目录、文件和流性能。您还将学习如何高效地枚举目录、处理小文件和大文件、执行异步操作、使用本地存储、处理异常以及高效地与内存协同工作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Understanding the various Windows file path formats**: This section provides
    information on the different file path formats that you will encounter on the
    Windows operating system. Also covered is the 256-character file path limit on
    Windows, and techniques that cover how to remove this limitation.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解各种Windows文件路径格式**：本节提供了关于您将在Windows操作系统上遇到的不同文件路径格式的信息。还涵盖了Windows上的256个字符文件路径限制，以及如何去除这一限制的技术。'
- en: '**Considering improved I/O performance**: In this section, we will be benchmarking
    some code to see which method of coding performs fastest when it comes to calculating
    directory sizes and moving files. Plus, we will look at how to read and write
    files asynchronously.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑改进I/O性能**：在本节中，我们将对一些代码进行基准测试，以查看在计算目录大小和移动文件时哪种编码方法性能最快。此外，我们还将探讨如何异步读取和写入文件。'
- en: '**Handling I/O operation exceptions**: We will cover how to handle I/O exceptions
    in this section. You will learn how to handle exceptions so that performance is
    not negatively impacted. You will also learn when to recover from exceptions,
    as well as when to exit them to preserve data integrity when exceptions cannot
    be graciously recovered from.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理I/O操作异常**：在本节中，我们将介绍如何处理I/O异常。您将学习如何处理异常，以确保性能不受负面影响。您还将学习何时从异常中恢复，以及何时退出异常以在无法优雅恢复时保护数据完整性。'
- en: '**Performing memory tasks efficiently**: In this section, you will learn how
    to efficiently use memory when processing strings and dealing with objects. We
    will also discuss how to defragment the Large Object Heap.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效执行内存任务**：在本节中，您将学习如何在处理字符串和处理对象时高效使用内存。我们还将讨论如何对大对象堆进行碎片整理。'
- en: '**Understanding local storage tasks**: In this section, we will discuss the
    various options for local file storage, some problems that can arise in networked
    environments, and when users install software just for themselves when multiple
    people use the same software on the same computer.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解本地存储任务**：在本节中，我们将讨论本地文件存储的各种选项、网络环境中可能出现的某些问题，以及当多个人在同一台计算机上使用相同的软件时，用户只为自身安装软件的情况。'
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够做到以下事项：
- en: Understand the different Windows file path formats.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同的Windows文件路径格式。
- en: Overcome the 256-character file path limit on Windows.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越Windows上的256个字符文件路径限制。
- en: Understand how hardware affects the performance of your code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解硬件如何影响您代码的性能。
- en: Choose the best option for calculating directory sizes.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择计算目录大小的最佳选项。
- en: Choose the best option for moving files.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择移动文件的最佳选项。
- en: Read and write files asynchronously.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步读取和写入文件。
- en: Handle I/O and other exceptions effectively.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地处理I/O和其他异常。
- en: Improve the performance of memory-based tasks.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高基于内存的任务性能。
- en: Understand what local file storage options are available to you.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您可用的本地文件存储选项。
- en: Understand the problems that can occur in networked environments, such as when
    applications that should be installed for all users on a single machine are installed
    only for the current user, and how to effectively resolve them.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在网络环境中可能出现的问题，例如当应该为单台机器上的所有用户安装的应用程序仅安装给当前用户时，以及如何有效地解决这些问题。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Visual Studio 2022
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: 'The source code for this book: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH08)
- en: Understanding the various Windows file path formats
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各种Windows文件路径格式
- en: You probably already know that .NET provides managed code that hides interaction
    with the Windows APIs from the end user. So, it will come as no surprise that
    the System.IO namespace passes file path information to the Windows APIs to handle.
    The Windows APIs perform the required task, and then control is handed back to
    .NET.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道 .NET 提供了管理代码，它隐藏了与 Windows API 的交互。因此，当 System.IO 命名空间将文件路径信息传递给 Windows
    API 以处理时，这并不会令人惊讶。Windows API 执行所需的任务，然后将控制权交还给 .NET。
- en: 'File paths in .NET can be absolute, relative, UNC paths, or DOS device paths.
    Non-Windows files and directories are case-sensitive. But on Windows, files and
    directories are case-insensitive. The following table provides examples of the
    different Windows file path formats:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中的文件路径可以是绝对路径、相对路径、UNC 路径或 DOS 设备路径。非 Windows 文件和目录是区分大小写的。但在 Windows 上，文件和目录是不区分大小写的。以下表格提供了不同
    Windows 文件路径格式的示例：
- en: '![Table 7.1 – Windows path format examples'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 7.1 – Windows 路径格式示例'
- en: '](img/B16617_Table_8.1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Table_8.1.jpg)'
- en: Table 7.1 – Windows path format examples
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – Windows 路径格式示例
- en: By default, Windows can only accept paths with a length of 256\. As a programmer,
    you have probably encountered the `Destination Path Too Long` warning when backing
    up your files or moving them. A situation that can often lead to this warning
    is developing web projects using node modules via NPM. NPM packages can have particularly
    long file paths that exceed 256 characters in length, which will lead to this
    exception being raised.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Windows 只能接受长度为 256 的路径。作为一名程序员，你可能遇到过在备份文件或移动文件时出现的“目标路径太长”警告。这种情况通常发生在使用
    NPM 通过节点模块开发 Web 项目时。NPM 软件包可能具有特别长的文件路径，超过 256 个字符，这将导致此异常被触发。
- en: You can remove the maximum path length limitation by either editing the registry
    or by editing the group policy. First, you will learn how to remove this limitation
    using the registry. Then, you will learn how to remove this limitation using the
    group policy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编辑注册表或编辑组策略来移除最大路径长度限制。首先，您将学习如何使用注册表来移除此限制。然后，您将学习如何使用组策略来移除此限制。
- en: Removing the maximum path length limitation using the registry
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注册表移除最大路径长度限制
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Always exercise caution when making changes to the registry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改注册表时，请始终谨慎行事。
- en: In this section, you will learn how to remove the file path limit of 260 characters
    by modifying the registry.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何通过修改注册表来移除 260 个字符的文件路径限制。
- en: In terms of performance, the `MAX_PATH` issue on Windows can waste your time.
    Copying many gigabytes of data can be very time-consuming. This can be made worse
    if a file copy fails after 28 minutes of you moving files between locations on
    different disks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，Windows 上的 `MAX_PATH` 问题可能会浪费您的时间。复制大量数据可能非常耗时。如果在您在不同磁盘之间移动文件 28 分钟后文件复制失败，这可能会使问题变得更糟。
- en: So, with file management applications, for example, if a user is going to copy
    files between two locations that will raise a file length exception, it is best
    to warn the user and provide them with the option to restructure their files before
    they perform the copy, or offer to update the registry for them. This way, you
    can save the end user a lot of wasted time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用文件管理应用程序时，例如，如果用户打算在两个位置之间复制文件，这可能会引发文件长度异常，最好提醒用户，并在他们执行复制操作之前提供重新组织文件的选择，或者为他们提供更新注册表的选项。这样，您可以节省最终用户大量的时间。
- en: 'To manually remove the `MAX_PATH` file path limit, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动移除 `MAX_PATH` 文件路径限制，请按照以下步骤操作：
- en: Open `regedit`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `regedit`。
- en: 'Once you have opened the registry editor, navigate to the following key:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开注册表编辑器，导航到以下键：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Identify the `1`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别 `1`。
- en: If the key does not exist, then add it as a `1`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果键不存在，则将其添加为 `1`。
- en: It may not be necessary, but it is a good idea to restart your computer for
    the changes to be picked up.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能没有必要，但重启计算机以使更改生效是个好主意。
- en: You should now be able to process files with paths with over 260 characters.
    If you experience permission issues after performing the preceding steps, then
    open the registry editor as an administrator. If you still have problems, then
    see your system administrator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够处理路径长度超过 260 个字符的文件。如果在执行前面的步骤后遇到权限问题，请以管理员身份打开注册表编辑器。如果您仍然有问题，请联系系统管理员。
- en: Now, let’s learn how to do this using the local group policy editor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用本地组策略编辑器来完成这项操作。
- en: Removing the maximum path length limitation using the group policy
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组策略移除最大路径长度限制
- en: 'You can also remove the file path limit of 260 characters by modifying the
    computer’s policy. You can do this with the `gpedit.msc` tool. This may be unavailable
    on some versions of Windows, or may not be available because of enterprise group
    policies that have been put in place. If you find that to be the case, then see
    your system administrator. Otherwise, follow these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过修改计算机的策略来移除260个字符的文件路径限制。您可以使用`gpedit.msc`工具完成此操作。在某些Windows版本上，这可能不可用，或者由于已实施的集团策略而不可用。如果您发现这种情况，请咨询系统管理员。否则，请按照以下步骤操作：
- en: Open `gpedit.msc`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`gpedit.msc`。
- en: Under **Computer Configuration**, navigate to **Administrative Templates** |
    **System** | **Filesystem**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**计算机配置**下，导航到**管理模板** | **系统** | **文件系统**。
- en: There will be a setting called `Not configured` by default. Edit this setting
    by setting it to `Enabled`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下将有一个名为“未配置”的设置。通过将其设置为“启用”来编辑此设置。
- en: It may not be necessary, but it is a good idea to restart your computer for
    the changes to be picked up.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能没有必要，但为了使更改生效，重启计算机是个好主意。
- en: With that, we’ve learned how to overcome the limiting path situation on Windows
    by editing the registry and local group policy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑注册表和本地组策略，我们已经学会了如何通过编辑注册表和本地组策略来克服Windows上的限制路径情况。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is really important to remove the file path limitation. There have been instances
    where critical backups on client and server computers have failed due to this
    limitation being in place. It can also break your development project when you’re
    working with third-party libraries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 移除文件路径限制非常重要。有实例表明，由于存在此限制，客户端和服务器计算机上的关键备份失败。当您与第三方库一起工作时，这也可能破坏您的开发项目。
- en: We will now look at some considerations that will help boost I/O operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨一些有助于提升I/O操作的考虑因素。
- en: Considering improved I/O performance
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑提高I/O性能
- en: There are several common I/O tasks that we do often, such as traversing directories
    searching for files, adding, renaming, moving and deleting directories, adding,
    renaming, moving, and deleting files, password protecting files and directories,
    encrypting and decrypting files and directories, and compressing files and directories.
    We also transmit and load files synchronously, asynchronously, and via streams
    such as file streams and memory streams. Then, there are all the NoSQL and SQL
    data operations, all of which will be happening frequently on corporate networks,
    and streaming data and audio/visual content at work and home.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常执行一些常见的I/O任务，例如遍历目录查找文件、添加、重命名、移动和删除目录、添加、重命名、移动和删除文件、对文件和目录进行密码保护、加密和解密文件和目录，以及压缩文件和目录。我们还同步、异步以及通过文件流和内存流等方式传输和加载文件。然后，还有所有NoSQL和SQL数据操作，这些操作将在企业网络中频繁发生，以及在工作场所和家中传输数据和音频/视频内容。
- en: When working with I/O, it is quite easy to completely slow a system down to
    the point that it becomes unusable while file reading and file writing is taking
    place. So, if you are going to be performing heavy I/O, you must keep the system
    where the work is being carried out fully operational and responsive for the end
    user and other processes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理I/O时，很容易完全减慢系统速度，以至于在文件读取和写入过程中变得无法使用。因此，如果您将要执行大量的I/O操作，您必须确保执行工作的地方的系统对最终用户和其他进程保持完全运行和响应。
- en: If your hardware is poor, then no matter how good your software is, it will
    more than likely be slow!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的硬件性能不佳，那么无论您的软件有多好，它很可能都会很慢！
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you consider optimizing your software to improve the speed and performance
    of I/O operations, you need to make sure that the hardware in place is suited
    to the type of I/O you will be performing. Otherwise, you could be wasting your
    time trying to improve your software!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑优化软件以提高I/O操作的速度和性能之前，您需要确保现有的硬件适合您将要执行的类型I/O。否则，您可能会浪费时间试图改进软件！
- en: When you’re dealing with hardware to speed up input and output operations, things
    to consider include the speed of your network card, whether or not you are using
    SSD disks, the number of CPUs, and the amount of RAM in use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理硬件以加快输入和输出操作时，需要考虑的事项包括网卡的速度、是否使用SSD硬盘、CPU的数量以及正在使用的RAM量。
- en: You also need to consider what other software processes will be running on the
    target computers. Security software that’s performing real-time scanning can often
    be overlooked when it comes to application slowdowns. When this is the case, you
    can have your application added as an exception to the antivirus software so that
    real-time scanning no longer slows down your software.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要考虑目标计算机上将要运行的其他软件进程。当涉及到应用程序速度减慢时，正在执行实时扫描的安全软件往往会被忽视。在这种情况下，您可以将应用程序添加为防病毒软件的例外，以便实时扫描不再减慢您的软件。
- en: 'Another issue that’s encountered in the wild is running one or more backups
    over the network during critical times of operation. No matter how efficient your
    program is, if it is running on a backup server, its performance can be severely
    impacted by the running backup software and process. This can also be the case
    if your software is not on the backup server, but requires the network to run
    and then send and receive files and data. The following are things to consider:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外遇到的一个问题是，在操作的关键时刻通过网络运行一个或多个备份。无论您的程序多么高效，如果它在备份服务器上运行，其性能可能会受到正在运行的备份软件和过程的严重影响。如果您的软件不在备份服务器上，但需要通过网络运行并发送接收文件和数据，这也可能发生。以下是需要考虑的事项：
- en: Change backup schedules to run at non-critical times.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将备份计划更改为在非关键时间运行。
- en: Install your software on a different server with a better overall performance.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能更好的服务器上安装您的软件。
- en: Check your network for bottlenecks and alleviate those bottlenecks.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您的网络是否存在瓶颈，并缓解这些瓶颈。
- en: Make sure your network cards are fast enough and configured appropriately.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的网络卡足够快并且配置得当。
- en: Make sure your Ethernet cables are up to date. Cat-5 cables are fine for typical
    internet traffic, but if you are doing a lot of file and data operations over
    your network, then you will want to upgrade to Cat-6a/Cat-7 cables for increased
    performance. However, with Cat-7 cables, you need to be careful not to damage
    the foil shielding when you bend the cable.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的以太网电缆是最新的。Cat-5电缆适用于典型的互联网流量，但如果您在网络中进行大量的文件和数据操作，那么您可能需要升级到Cat-6a/Cat-7电缆以提高性能。然而，使用Cat-7电缆时，您需要小心不要在弯曲电缆时损坏箔屏蔽。
- en: With web projects, it is important to reduce file size to speed up how files
    are transmitted and received over the internet. This helps reduce the overall
    page load time and results in happier customers. To improve the load performance
    of your web applications, enable the Windows Dynamic Content Compression feature.
    This will reduce the data’s size, thus increasing the response time from the user’s
    perspective. The need for data compression also applies to client/server applications,
    especially if the file and data sizes that are being transmitted are huge.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web项目，减少文件大小以加快文件在互联网上的传输和接收速度非常重要。这有助于减少整体页面加载时间，并使客户更加满意。为了提高Web应用程序的加载性能，启用Windows动态内容压缩功能。这将减小数据的大小，从而从用户的角度提高响应时间。数据压缩的需求也适用于客户端/服务器应用程序，尤其是当传输的文件和数据大小非常大时。
- en: Employ caching to improve network performance. Caching will store resources
    locally or keep them in memory for a certain period. Should such resources be
    requested again, then the locally stored resources will be checked and used instead
    of the network resources. This increases the access and load times of resources,
    and it also reduces network traffic. Cached resources will be updated if the resources
    have been updated, if the cache period has expired, or if the user has cleared
    their cache.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓存来提高网络性能。缓存将资源存储在本地或将其保留在内存中一段时间。如果再次请求这些资源，则将检查本地存储的资源并使用它们，而不是网络资源。这增加了资源的访问和加载时间，同时也减少了网络流量。如果资源已更新、缓存周期已过期或用户已清除其缓存，则缓存的资源将被更新。
- en: The two most common data transfer mechanisms are XML and JSON. These are text
    files that store structured information. Parsers are required to extract information
    from such files so that the extracted data can be utilized in the applications.
    But not all XML and JSON parsers perform the same. It would be prudent to benchmark
    the performance of various XML and JSON parsers to help you choose the most efficient
    and performant one for your data processing needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最常见的数据传输机制是XML和JSON。这些是存储结构化信息的文本文件。需要解析器从这些文件中提取信息，以便提取的数据可以在应用程序中使用。但并非所有XML和JSON解析器都表现相同。明智的做法是基准测试各种XML和JSON解析器的性能，以帮助你选择最适合你数据处理需求的最有效和性能最好的一个。
- en: When you’re serializing and deserializing data, your objects and their hierarchies
    should match your JSON and XML formats so that processing is much faster.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在序列化和反序列化数据时，你的对象及其层次结构应与你的JSON和XML格式相匹配，这样处理速度会更快。
- en: 'Microsoft recommends that developers shouldn''t use BinaryFormatter for transferring
    binary data as it is unsafe and can lead to **denial-of-service** (**DOS**) attacks.
    .NET offers several in-box serializers that can handle untrusted data safely:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议开发者不要使用BinaryFormatter来传输二进制数据，因为它是不安全的，可能导致**拒绝服务**（**DOS**）攻击。.NET提供了一些内置序列化器，可以安全地处理不受信任的数据：
- en: '`XmlSerializer` and `DataContractSerializer` can serialize object graphs into
    and from XML. Do not confuse `DataContractSerializer` with `NetDataContractSerializer`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlSerializer`和`DataContractSerializer`可以将对象图序列化到XML中，也可以从XML中反序列化。不要将`DataContractSerializer`与`NetDataContractSerializer`混淆。'
- en: '`BinaryReader` and `BinaryWriter` for XML and JSON.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryReader`和`BinaryWriter`用于XML和JSON。'
- en: The `System.Text.Json` APIs can serialize object graphs into JSON.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Text.Json` API可以将对象图序列化到JSON中。'
- en: Data types can vary in size as they can hold different data values, and data
    values can vary in length. Both number values and string values are variable in
    length. The bigger the number or string, the more bytes are saved to the file.
    The smaller the number or string, the fewer bytes are saved to the file. Likewise,
    with data type names, the longer the name, the more bytes are used, and the shorter
    the name, the fewer bytes are used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的大小可能不同，因为它们可以存储不同的数据值，数据值长度也可能不同。数值和字符串值都是可变长度的。数值或字符串越大，保存到文件中的字节数就越多。数值或字符串越小，保存到文件中的字节数就越少。同样，对于数据类型名称，名称越长，使用的字节数就越多，名称越短，使用的字节数就越少。
- en: While writing one or two files occasionally, the size of bytes may not be an
    issue to the end user or your application’s performance. But when you move into
    the realms of batch file processing, the more bytes that have to be written per
    file, the longer batch processing will take to complete.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当偶尔移动一两个文件时，字节数量可能对最终用户或应用程序性能不是问题。但是，当你进入批量文件处理的领域时，每个文件需要写入的字节数越多，批量处理完成所需的时间就越长。
- en: Depending on your OS version, drivers, disk, and networking hardware, it is
    possible that copying or moving small files is more performance-heavy than moving
    around large files. You can optimize file transfer at the OS level under the hood
    by leveraging burst copy or similar techniques.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统版本、驱动程序、磁盘和网络硬件，复制或移动小文件可能比移动大文件更消耗性能。你可以在操作系统级别通过利用突发复制或类似技术来优化文件传输。
- en: As an example, you can have a lot of performance issues when moving around media
    files (photo/audio/video) or AI/ML datasets (usually text-based). If files are
    small (ranging from a few KBs to a few MBs), you can group them in ZIP files (without
    compression, if they’re media files) so that it results in bigger files that can
    be transferred faster.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在移动媒体文件（照片/音频/视频）或AI/ML数据集（通常是文本）时，可能会遇到许多性能问题。如果文件很小（从几个KB到几个MB不等），你可以将它们分组到ZIP文件中（如果它们是媒体文件则不进行压缩），这样可以得到更大的文件，可以更快地传输。
- en: In the next section, we will be benchmarking three different methods for moving
    files. We will be using `File.Copy`, `FileInfo.MoveTo`, and obtaining `FileInfo`
    from the memory cache and using `FileInfo.MoveTo`. This will help us identify
    the quickest method to use in our applications, especially when large numbers
    of files need to be moved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对三种不同的文件移动方法进行基准测试。我们将使用`File.Copy`、`FileInfo.MoveTo`以及从内存缓存中获取`FileInfo`并使用`FileInfo.MoveTo`。这将帮助我们确定在应用程序中使用最快的移动方法，尤其是在需要移动大量文件时。
- en: Moving files
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件移动
- en: A common function in various enterprise applications is the need to move around
    large numbers of files. For example, a reporting function may require the amalgamation
    of last month’s sales figures from various teams to be entered into a data warehouse
    for report processing purposes. Those sales figures could reside in spreadsheets
    in various locations. Each spreadsheet would need to be moved to a central file
    storage location for further processing. The more files that you have in any file
    move operation, the more processing time will be required. So, it pays to know
    which method of moving a large number of files is the most performant in C#.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种企业应用程序中，一个常见的功能是需要移动大量文件。例如，一个报告功能可能需要将来自各个团队的上一月的销售数据合并到数据仓库中，以便进行报告处理。这些销售数据可能位于各种位置的电子表格中。每个电子表格都需要被移动到一个中央文件存储位置以进行进一步处理。在文件移动操作中，你拥有的文件越多，所需的处理时间就越多。因此，了解在C#中移动大量文件哪种方法性能最佳是有益的。
- en: 'With that in mind, we will write a simple application to benchmark three different
    ways of moving files. Each method that we write will vary in performance. Our
    method of choice will be the method that performs the fastest, and this will be
    identified in our benchmark summary report once we have run our compiled executable.
    Let’s start writing our benchmarks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们将编写一个简单的应用程序来基准测试三种不同的文件移动方式。我们编写的每个方法在性能上都会有所不同。我们选择的方法将是执行最快的，一旦我们运行了编译后的可执行文件，这将在我们的基准测试总结报告中识别出来。让我们开始编写我们的基准测试：
- en: Start a new C# .NET 5 console application and name it `CH08_FileAndStreamIO`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的C# .NET 5控制台应用程序，并将其命名为`CH08_FileAndStreamIO`。
- en: Install the `BenchmarkDotNet` NuGet package.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`BenchmarkDotNet` NuGet包。
- en: 'Add a new class called `MovingFiles` to the root of the project:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`MovingFiles`的新类添加到项目的根目录：
- en: '[PRE1]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our class is now set up to benchmark our methods and report on memory usage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的类已经设置好了，可以用来基准测试我们的方法并报告内存使用情况。
- en: 'At the top of the class, add the following code (you can replace the `Moonshine-3.0.0.exe`
    file with a file of your own choosing):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部添加以下代码（你可以用你自己的文件替换`Moonshine-3.0.0.exe`文件）：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have declared a dictionary of `FileInfo` objects, which will act as
    our in-memory cache, and three constants for our source directory, destination
    directory, and filename. We will need these constants in the other methods we
    will be writing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`FileInfo`对象的字典，它将作为我们的内存缓存，以及三个常量用于我们的源目录、目标目录和文件名。我们将在我们将要编写的其他方法中需要这些常量。
- en: 'We need to have a procedure in place to prepare our code so that it can be
    benchmarked without exceptions being raised. If we don’t, our benchmarks will
    fail to execute more than once because the file will have been moved. Each time
    a benchmark runs, the moved file needs to be moved back to its original location.
    So, we are going to need a `[GlobalSetup]` method and a `[GlobalCleanup]` method.
    First, add the `[GlobalSetup]` method to the `MovingFiles` class. We will call
    the `PreloadFilesAndCacheThem()` method here:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要有一个程序来准备我们的代码，以便在没有抛出异常的情况下进行基准测试。如果没有，我们的基准测试将无法执行多次，因为文件已经被移动。每次基准测试运行时，移动的文件需要被移回到其原始位置。因此，我们需要一个`[GlobalSetup]`方法和一个`[GlobalCleanup]`方法。首先，将`[GlobalSetup]`方法添加到`MovingFiles`类中。我们将在那里调用`PreloadFilesAndCacheThem()`方法：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is getting `FileSystemInfo` for each file in the source directory
    identified by the `SOURCE_DIRECTORY` string. Then, it instantiates `_cache` as
    a dictionary of `FileInfo` objects. After that, the list of files is iterated
    through, and the `FileInfo` object for the current file is added to `_cache`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过`SOURCE_DIRECTORY`字符串标识的源目录中的每个文件获取`FileSystemInfo`。然后，它将`_cache`实例化为一个`FileInfo`对象的字典。之后，遍历文件列表，并将当前文件的`FileInfo`对象添加到`_cache`中。
- en: 'Add the `PreMoveCheck() [GlobalCleanup]` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`PreMoveCheck() [GlobalCleanup]`方法：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The cleanup code checks whether the file already exists in `SOURCE_DIRECTORY`.
    If it does, then `DESTINATION_DIRECTORY` is checked for the file. If it exists,
    it is deleted. If the file does not exist in `SOURCE_DIRECTORY` but exists in
    `DESTINATION_DIRECTORY`, then the file is moved from `DESTINATION_DIRECTORY` back
    into `SOURCE_DIRECTORY`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理代码检查文件是否已存在于`SOURCE_DIRECTORY`中。如果存在，则检查`DESTINATION_DIRECTORY`中的文件。如果存在，则将其删除。如果文件不在`SOURCE_DIRECTORY`中但存在于`DESTINATION_DIRECTORY`中，则将文件从`DESTINATION_DIRECTORY`移回到`SOURCE_DIRECTORY`。
- en: We need the `[GlobalSetup]` and `[GlobalCleanup]` methods because if they are
    not in place doing what they are doing, the benchmarks will fail because the file
    cannot be found.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`[GlobalSetup]`和`[GlobalCleanup]`方法，因为如果它们不在适当的位置执行它们的功能，基准测试将失败，因为文件找不到。
- en: 'Add the `FileCopy()` method to the `MovingFiles` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FileCopy()`方法添加到`MovingFiles`类中：
- en: '[PRE5]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `FileCopy()` method performs a `PreMoveCheck()` so that the file is in place,
    ready for the benchmark to run without failing. It then proceeds to copy the file
    from `SOURCE_DIRECTORY` to `DESTINATION_DIRECTORY`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileCopy()`方法执行`PreMoveCheck()`以确保文件已就位，准备进行基准测试而不会失败。然后，它继续将文件从`SOURCE_DIRECTORY`复制到`DESTINATION_DIRECTORY`。'
- en: 'Now, add the `FileInfoMoveTo()` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`FileInfoMoveTo()`方法：
- en: '[PRE6]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `FileInfoMoveTo()` method also performs a `PreMoveCheck()`, ensuring that
    the file is in place, ready for the move. Then, it creates a `FileInfo` object
    for the specified file and uses the `MoveTo(string destinatation)` method to move
    the file from `SOURCE_DIRECTORY` to `DESTINATION_DIRECTORY`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileInfoMoveTo()`方法也执行`PreMoveCheck()`，确保文件已就位，准备移动。然后，它为指定的文件创建一个`FileInfo`对象，并使用`MoveTo(string
    destinatation)`方法将文件从`SOURCE_DIRECTORY`移动到`DESTINATION_DIRECTORY`。'
- en: 'Add the `FileInfoReadCacheAndMoveTo()` method to the `MovingFiles` class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FileInfoReadCacheAndMoveTo()`方法添加到`MovingFiles`类中：
- en: '[PRE7]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `FileInfoReadCacheAndMoveTo()` method performs a `PreMoveCheck()`. Then,
    it creates a `FileInfo` object from the `FileInfo` object stored in `_cache`.
    If the `FileInfo` object exists, it is then moved to `DESTINATION_DIRECTORY`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileInfoReadCacheAndMoveTo()`方法执行`PreMoveCheck()`。然后，它从存储在`_cache`中的`FileInfo`对象创建一个`FileInfo`对象。如果`FileInfo`对象存在，它随后被移动到`DESTINATION_DIRECTORY`。'
- en: 'Add the following line of code to the `Main` method in the `Program` class:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中添加以下代码行：
- en: '[PRE8]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build the project in `Release` mode, and then run the executable from the command
    line. You should see the following benchmark summary report:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Release`模式下构建项目，然后从命令行运行可执行文件。你应该会看到以下基准摘要报告：
- en: '![Figure 7.1 – The BenchmarkDotNet summary report for various file move operations'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – BenchmarkDotNet对各种文件移动操作的摘要报告'
- en: '](img/B16617_Figure_8.1.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_8.1.jpg](img/B16617_Figure_8.1.jpg)'
- en: Figure 7.1 – The BenchmarkDotNet summary report for various file move operations
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – BenchmarkDotNet对各种文件移动操作的摘要报告
- en: From the timings, we can see that the `File.Copy(string source, string destination)`
    method is the slowest method of moving files, followed by the `FileInfo.MoveTo(string
    destination)` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间统计中，我们可以看到`File.Copy(string source, string destination)`方法是移动文件中最慢的方法，其次是`FileInfo.MoveTo(string
    destination)`方法。
- en: The fastest file move operation is to extract `FileInfo` from the in-memory
    cache and then use the `FileInfo.MoveTo(string destination)` method to perform
    the move operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的文件移动操作是从内存缓存中提取`FileInfo`，然后使用`FileInfo.MoveTo(string destination)`方法执行移动操作。
- en: In the next section, we will look at two different methods for calculating the
    size of all the files in a directory. We can then use the fastest method for when
    we need to calculate the size of directories, such as before doing a batch file
    move in an enterprise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨两种不同的方法来计算目录中所有文件的大小。然后我们可以使用最快的方法来计算目录的大小，例如在企业中进行批量文件移动之前。
- en: Calculating directory sizes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算目录大小
- en: When you’re batch processing files and directories, it can pay to know how large
    the sum of files is before moving them to a new location. This can help you determine
    the amount of time that it will take to copy the files, as well as whether the
    destination has space to store all the files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对文件和目录进行批量处理时，在将它们移动到新位置之前了解文件总和的大小是有益的。这可以帮助你确定复制文件所需的时间，以及目标位置是否有足够的空间来存储所有文件。
- en: An example of some dialog that pops up when you’re copying or moving files is
    the Windows Explorer dialog. It traverses the files and directories to be moved
    or copied. As it does, it logs the total amount of bytes that are being used by
    the files and directories. Then, it provides a time estimate regarding how long
    it will take to move or copy those bytes. There are times when this process can
    take a very long time and be frustrating for the end user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你复制或移动文件时，弹出的某些对话框示例是Windows资源管理器对话框。它遍历要移动或复制的文件和目录。在这个过程中，它记录文件和目录使用的总字节数。然后，它提供一个时间估计，关于移动或复制这些字节需要多长时间。有时这个过程可能非常耗时，对最终用户来说可能很令人沮丧。
- en: 'Another reason to know about directory sizes is when you have critical business
    needs that are time-sensitive. Prolonged file move operations can be detrimental
    to the business’ time plan. In this section, we will calculate directory size
    by benchmarking two different methods. The method that performs the fastest is
    the one we would choose when calculating a directory’s size. Let’s begin:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个了解目录大小的理由是当您有紧急且时间敏感的业务需求时。长时间的文件移动操作可能会损害业务的进度计划。在本节中，我们将通过基准测试两种不同的方法来计算目录大小。执行最快的那个方法是我们计算目录大小时会选择的方法。让我们开始吧：
- en: 'Add a new class to the project called `GettingFileSizes` and configure it for
    benchmarking, as you did withthe `MovingFiles` class. Then, add the `DIRECTORY`
    constant to the top of the class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `GettingFileSizes` 的新类，并像对 `MovingFiles` 类所做的那样对其进行基准测试配置。然后，将 `DIRECTORY`
    常量添加到类的顶部：
- en: '[PRE9]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `GetDirectorySizeUsingGetFileSystemInfos()` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetDirectorySizeUsingGetFileSystemInfos()` 方法：
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `GetDirectorySizeUsingGetFileSystemInfos()` method creates a new `DirectoryInfo`
    object based on the directory defined in the `DIRECTORY` constant. Then, it gets
    an array of `FileSystemInfo` from the `DirectoryInfo` variable. The `FileSystemInfo`
    array is then iterated through and the `directorySize` variable is incremented.
    Once `directorySize` has been calculated, the value is returned to the caller.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetDirectorySizeUsingGetFileSystemInfos()` 方法基于在 `DIRECTORY` 常量中定义的目录创建一个新的
    `DirectoryInfo` 对象。然后，它从 `DirectoryInfo` 变量中获取一个 `FileSystemInfo` 数组。然后遍历 `FileSystemInfo`
    数组，并将 `directorySize` 变量递增。一旦 `directorySize` 被计算出来，该值将被返回给调用者。'
- en: 'Add the `GetDirectorySizeUsingArrayAndFileInfo()` method to the `MovingFiles`
    class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GetDirectorySizeUsingArrayAndFileInfo()` 方法添加到 `MovingFiles` 类中：
- en: '[PRE11]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GetDirectorySizeUsingArrayAndFileInfo()` method gets a string array of
    filenames for the given directory. The array is then iterated and `directorySize`
    is incremented by the current file size. Once the iteration is complete, `directorySize`
    is returned.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetDirectorySizeUsingArrayAndFileInfo()` 方法获取给定目录的文件名字符串数组。然后遍历数组，并将 `directorySize`
    通过当前文件大小递增。一旦迭代完成，`directorySize` 被返回。'
- en: 'Add the `benchmark` runner method to the `Main` method in the `Program` class,
    perform a `Release` build, and then run the executable from the command line.
    You will see the following report:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `benchmark` 运行器方法添加到 `Program` 类的 `Main` 方法中，执行 `Release` 构建并从命令行运行可执行文件。您将看到以下报告：
- en: '![Figure 7.2 – The benchmark summary report for obtaining directory sizes'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 获取目录大小的基准总结报告](img/B16617_Figure_8.2.jpg)'
- en: '](img/B16617_Figure_8.2.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 获取目录大小的基准总结报告](img/B16617_Figure_8.2.jpg)'
- en: Figure 7.2 – The benchmark summary report for obtaining directory sizes
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 获取目录大小的基准总结报告
- en: As you can see, we used two different methods to calculate the size of the `System32`
    directory. The slowest method of calculating a directory size was our second method.
    So, for performance reasons, the best method for calculating the size of a directory
    is to get `DirectoryInfo` for the directory in question. Then, you can call `GetFileSystemInfos()`
    and iterate through the result, summing the length of the `FileInfo` objects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了两种不同的方法来计算 `System32` 目录的大小。计算目录大小的最慢方法是我们的第二种方法。因此，出于性能考虑，计算目录大小的最佳方法是获取相关目录的
    `DirectoryInfo`。然后，您可以调用 `GetFileSystemInfos()` 并遍历结果，累加 `FileInfo` 对象的长度。
- en: In the next section, we will look at asynchronous file operations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨异步文件操作。
- en: Accessing files asynchronously
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步访问文件
- en: 'Why should you access files asynchronously? Well, here are a few reasons that
    you might consider when using asynchronous file access:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该异步访问文件？好吧，这里有一些原因，您可能在使用异步文件访问时考虑：
- en: Your user interface thread will be more responsive as the file operation won’t
    block the user interaction if it takes a few seconds or longer to complete.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文件操作需要几秒钟或更长的时间才能完成时，您的用户界面线程将更加响应，因为文件操作不会阻塞用户交互。
- en: An asynchronous process reduces the need for manually managed threads, making
    applications more scalable. ASP.NET and server-side applications are specific
    examples of applications that will benefit from asynchronous file processing.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步进程减少了手动管理的线程需求，使应用程序更具可扩展性。ASP.NET 和服务器端应用程序是具体的应用程序示例，它们将从异步文件处理中受益。
- en: File access latency is also something you must consider. Computer resources
    such as the type of hard disk, network upload and download speeds, and real-time
    scanning by the security software, as well as file size, are all factors that
    can affect file access times.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件访问延迟也是你必须考虑的因素。计算机资源，如硬盘类型、网络上传和下载速度、安全软件的实时扫描，以及文件大小，都是可能影响文件访问时间的因素。
- en: There is only a small overhead for using asynchronous tasks over threads.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步任务而不是线程只有很小的开销。
- en: You can run asynchronous tasks in parallel.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以并行运行异步任务。
- en: 'The `FileStream` class gives you the most control over file access operations.
    You can configure the class to execute I/O operations at the operating system
    level. By doing this, you avoid blocking thread pool threads. To execute I/O operations
    at the operating system level, you must specify one of the following in the constructor
    call:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`类让你对文件访问操作有最大的控制权。你可以配置该类以在操作系统级别执行I/O操作。通过这样做，你可以避免阻塞线程池线程。要在构造函数调用中指定在操作系统级别执行I/O操作，你必须指定以下之一：'
- en: '`useAsync=true`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAsync=true`'
- en: '`options=FileOptions.Asynchronous`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options=FileOptions.Asynchronous`'
- en: Note
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This option can only be used with the `StreamReader` and `StreamWriter` classes
    when the stream that’s provided to them is one that was opened by the `FileStream`
    class.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个选项只能与`StreamReader`和`StreamWriter`类一起使用，当提供给它们的流是由`FileStream`类打开的流时。
- en: Now, let’s look at a very simple example of performing asynchronous file writing
    and reading. Let’s start by writing some text to a text file asynchronously. Then,
    we will read the text from the same file asynchronously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个执行异步文件读写操作非常简单的例子。让我们先异步地将一些文本写入一个文本文件。然后，我们将异步地从同一个文件中读取文本。
- en: Writing text to a file asynchronously
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步写入文件
- en: 'In this section, we will write some text to a text file asynchronously. There
    is a simpler way to perform this task but the method we will be using provides
    the most control and operates at the operating system level:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将异步地将一些文本写入一个文本文件。虽然有一个更简单的方法来完成这个任务，但我们将使用的方法提供了最大的控制权，并且是在操作系统级别上操作的：
- en: Add a new file to the `CH08_FileAndStreamIO` project called `AsyncFileAccess`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新文件添加到`CH08_FileAndStreamIO`项目，名为`AsyncFileAccess`。
- en: 'Add a new method called `WriteTextToFileAsync(string text, string path)` to
    the `AsyncFileAccess` class:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为`WriteTextToFileAsync(string text, string path)`的新方法添加到`AsyncFileAccess`类中：
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we pass a string of text in and the name of the file to write the text
    to. Then, we read all the text into a byte array. Next, we declare an asynchronous
    `FileStream` variable with a buffer size of 4,096 bytes, write the text asynchronously
    to the specified file, and wait for the operation to complete. The reason for
    using 4,096 bytes is that it is a power of two number and a memory page size.
    A page, memory page, or virtual page is a fixed-length contiguous block of virtual
    memory that’s described by a single entry in the page table. So, when the system
    chooses to swap out a page to disk, it can do so in one go without any overhead
    involved.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递一个文本字符串和一个要写入文本的文件名。然后，我们将所有文本读入一个字节数组。接下来，我们声明一个具有4,096字节缓冲区的异步`FileStream`变量，将文本异步写入指定的文件，并等待操作完成。使用4,096字节的原因是因为它是2的幂，并且是内存页面大小。页面，内存页面，或虚拟页面是由页面表中的单个条目描述的固定长度连续的虚拟内存块。因此，当系统选择将页面交换到磁盘时，它可以一次性完成，而不涉及任何开销。
- en: 'Add the `ReadTextFromFileAsync(string path)` method to the `AsynFileAccess`
    class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ReadTextFromFileAsync(string path)`方法添加到`AsynFileAccess`类中：
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we declare a `StringBuilder` for efficient string concatenation.
    Then, we declare and initialize a new byte array that will be our buffer and declare
    a `numberOfBytesToDecode` variable. A new `FileStream` object is instantiated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们声明一个`StringBuilder`以实现高效的字符串连接。然后，我们声明并初始化一个新的字节数组，它将成为我们的缓冲区，并声明一个`numberOfBytesToDecode`变量。创建一个新的`FileStream`对象。
- en: The `numberOfBytesToDecode` variable is set by awaiting the call to the `ReadAsync`
    method. This variable is set for each iteration of the `For` loop. For each iteration
    of the loop, we obtain the number of bytes to be decoded. Then, we append a line
    to the output, with the items taken from the buffer. Finally, we return the resulting
    string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`numberOfBytesToDecode`变量通过等待对`ReadAsync`方法的调用来设置。这个变量在`For`循环的每次迭代中都会设置。对于循环的每次迭代，我们获取要解码的字节数。然后，我们向输出追加一行，其中包含从缓冲区中取出的项。最后，我们返回结果字符串。'
- en: 'Add the `DemonstrateAsyncFileOps()` method to the `AsyncFileAccess` class:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DemonstrateAsyncFileOps()` 方法添加到 `AsyncFileAccess` 类：
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `DemonstrateAsynFileOps()` method writes some text to a file asynchronously
    by calling the asynchronous write operation. Then, it reads the text back asynchronously
    by calling the asynchronous read operation. The result is then printed to the
    console window.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemonstrateAsynFileOps()` 方法通过调用异步写入操作将一些文本异步写入文件。然后，它通过调用异步读取操作异步读取文本。结果随后打印到控制台窗口。'
- en: 'Modify your `Program` class’s `Main` method as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改您的 `Program` 类的 `Main` 方法：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code creates a new instance of our `AsyncFileAccess` class, and then calls
    the `DemonstrateAsyncFileOps()` method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了我们 `AsyncFileAccess` 类的新实例，然后调用 `DemonstrateAsyncFileOps()` 方法。
- en: 'Build and run your code. In your console window, you should see the following
    line printed out:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行您的代码。在您的控制台窗口中，您应该看到以下行被打印出来：
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As can be seen from our simple example, asynchronous file access is fairly straightforward.
    In the next section, we will look at how to handle I/O exceptions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的简单示例所示，异步文件访问相当直接。在下一节中，我们将探讨如何处理I/O异常。
- en: Handling I/O operation exceptions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理I/O操作异常
- en: When working with I/O operations, you can encounter several different exceptions.
    The base I/O exception is `IOException`. It pays to differentiate between the
    different I/O exceptions and to log them as this can help expedite problem resolution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理I/O操作时，您可能会遇到几种不同的异常。基本的I/O异常是 `IOException`。区分不同的I/O异常并将它们记录下来是有益的，因为这有助于加快问题解决的速度。
- en: 'The following table provides a breakdown of the various I/O exceptions that
    can be raised by your I/O operations. By trapping these specific exceptions, you
    can provide a more detailed exception log entry that helps with identifying the
    root source of the problem more easily:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了由您的I/O操作可能引发的各种I/O异常的分解。通过捕获这些特定的异常，您可以提供更详细的异常日志条目，这有助于更容易地识别问题的根本原因：
- en: '![Table 7.2 – Microsoft .NET I/O exceptions'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.2 – Microsoft .NET I/O异常'
- en: '](img/B16617_Table_8.2.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Table_8.2.jpg]'
- en: Table 7.2 – Microsoft .NET I/O exceptions
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 – Microsoft .NET I/O异常
- en: Now that you know about the kind of I/O exceptions that can be raised, you also
    need to know about the correct way to handle, log, and display such exceptions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了可能引发的I/O异常的类型，您还需要了解正确处理、记录和显示这些异常的方法。
- en: As programmers, we need to write code that can detect malfunctioning code. Code
    that malfunctions leaves a computer program in an undefined state. This can lead
    to side effects that are unexpected and unpredictable. A computer program that
    is in an unpredictable state can lead to all manner of issues such as performance
    slowing down, application hangs, and invalid data, leading to incorrect information.
    This can lead to serious business and consumer issues, and that is not good.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们需要编写能够检测代码故障的代码。故障代码会使计算机程序处于未定义的状态。这可能导致意外和不可预测的副作用。处于不可预测状态的计算机程序可能导致各种问题，如性能降低、应用程序挂起和无效数据，从而导致错误信息。这可能导致严重的商业和消费者问题，这是不好的。
- en: 'Therefore, your code needs to be fault-tolerant and should be able to handle
    faults appropriately. Exceptions should be handled so that data integrity remains
    intact. You should also bear in mind that there are two categories of exceptions
    that your computer program should be aware of:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的代码需要具有容错性，并且应该能够适当地处理故障。异常应该被处理，以确保数据完整性保持不变。您还应该记住，您的计算机程序应该了解两种异常类别：
- en: '**Expected exceptions** are exceptions that your computer program can recover
    from.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期异常**是您的计算机程序可以从中恢复的异常。'
- en: '**Unexpected exceptions** are exceptions that your computer program is unable
    to recover from.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意外异常**是您的计算机程序无法从中恢复的异常。'
- en: The expected exceptions need to be handled silently. You know what has the potential
    to fail and why, so you can put defensive code in place to act against such code-raising
    exceptions in the first place. This is important, as you don’t want bubbling exceptions
    since this reduces application performance. In turn, a reduction in application
    performance impacts the user experience.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 预期异常需要静默处理。您知道什么有可能失败以及为什么，因此您可以在一开始就放置防御性代码来应对可能引发这些异常的代码。这很重要，因为您不希望异常冒泡，因为这会降低应用程序的性能。反过来，应用程序性能的降低会影响用户体验。
- en: Allowing exceptions to propagate through your computer program is expensive
    in terms of performance. With this in mind, best practice stipulates that it is
    better to handle exceptions at the point where they occur within your code for
    improved application performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 允许异常在您的计算机程序中传播会消耗大量的性能。考虑到这一点，最佳实践规定，最好在代码中异常发生的位置处理异常，以提高应用程序的性能。
- en: When you’re trapping for errors using a `try/catch` block, it is also a good
    practice to have multiple `catch` blocks. The only exceptions that would form
    the `catch` blocks are those that can be thrown by the current method. You would
    put the exception `catch` blocks in an order where the most specific exception
    is at the top, and then reduce to the least specific, which would be your bottom
    `catch` block. This helps make your code more readable to fellow programmers,
    and it also makes debugging your code for specific exceptions much easier.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `try/catch` 块捕获错误时，拥有多个 `catch` 块也是一个好的做法。唯一会形成 `catch` 块的异常是当前方法可以抛出的异常。您应该将异常
    `catch` 块按顺序放置，最具体的异常在顶部，然后逐渐减少到最不具体的，这将是您的底部 `catch` 块。这有助于使您的代码对其他程序员更易读，并且也使得针对特定异常调试您的代码变得更加容易。
- en: You can use exception filters to handle an exception when a specific condition
    is present. If the exception filter returns true, then the exception is handled.
    But if it returns false, the search for an exception handler continues. It is
    preferable to use exception filters instead of catching and rethrowing because
    filters leave the stack unharmed. If a later handler dumps the stack, you can
    see where the exception originally came from, rather than just the last place
    it was rethrown.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用异常过滤器来处理在特定条件下出现的异常。如果异常过滤器返回 true，则异常被处理。但如果它返回 false，则继续搜索异常处理器。与捕获和重新抛出相比，使用异常过滤器更可取，因为过滤器不会损害调用栈。如果稍后的处理器清空了调用栈，您可以看到异常最初来自哪里，而不仅仅是它被重新抛出的最后位置。
- en: When an unexpected exception occurs, it must be thrown because it can have a
    seriously detrimental effect on the predictability of your computer program. When
    unexpected exceptions occur, you should log the exception and exit to protect
    the integrity of your data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生意外的异常时，它必须被抛出，因为它可能会对您计算机程序的预测性产生严重影响。当发生意外的异常时，您应该记录异常并退出以保护数据的完整性。
- en: This is why using `System.Exception` is a bad idea in that it swallows all exceptions.
    Your methods should only trap for the exceptions that they expect to be raised.
    All unexpected exceptions should be handled by the application in such a way that
    the exception is logged and the program is exited. It is in the main application’s
    `try/catch` block that you would have your `System.Exception` catch block to catch
    unexpected exceptions. This block would handle all unexpected exceptions that
    are allowed to bubble up back to the main application code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么使用 `System.Exception` 是一个坏主意，因为它会吞没所有异常。您的方法应该只捕获它们预期会引发的异常。所有意外的异常都应该以记录异常并退出程序的方式由应用程序处理。在主应用程序的
    `try/catch` 块中，您会有您的 `System.Exception` 捕获块来捕获意外的异常。这个块将处理所有允许冒泡回主应用程序代码的意外异常。
- en: When unexpected exceptions propagate back to the main application code’s exception
    `catch` block, you can extract the underlying base exception by calling `Exception.GetBaseException()`.
    This will get the original exception that was raised, causing any subsequent exceptions
    to also be raised.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当意外的异常传播回主应用程序代码的异常 `catch` 块时，您可以通过调用 `Exception.GetBaseException()` 来提取基本异常。这将获取最初引发的异常，导致任何后续异常也被引发。
- en: In my experience, I have found that IT professionals will often neglect to review
    the event log and application logs when troubleshooting. However, when they have
    drawn blanks and have asked for my help, this has usually been my first port of
    call. It may be that nothing gets logged in **Event Viewer**, and nothing gets
    logged by the application. But there are times when valuable information does
    get logged, and it can be a time-saver in terms of problem-solving and getting
    the application working again in a more stable manner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我发现IT专业人士在故障排除时往往会忽略审查事件日志和应用程序日志。然而，当他们一无所获并寻求我的帮助时，这通常是我的首要任务。可能是在**事件查看器**中没有记录任何内容，应用程序也没有记录任何内容。但有时确实记录了有价值的信息，这可以在问题解决和以更稳定的方式重新使应用程序运行方面节省时间。
- en: 'There are essentially three different locations where an exception can be logged:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，异常可以记录在三个不同的位置：
- en: '**Application log files**: When an exception is encountered, it will be logged
    by the application to a text file, JSON file, or XML file.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序日志文件**：当遇到异常时，应用程序会将异常记录到文本文件、JSON文件或XML文件中。'
- en: '**Event Viewer**: When an expected exception is encountered, this will be logged
    by the application to a named event log. When an unexpected exception is encountered
    such as an application hang, the system will log this exception in either the
    Windows Application Log or the Windows System Log.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件查看器**：当遇到预期的异常时，应用程序会将此异常记录到命名事件日志中。当遇到意外的异常，如应用程序挂起时，系统会将此异常记录在Windows应用程序日志或Windows系统日志中。'
- en: '**The database**: When an application is encountered, the application will
    log the exception to a database table.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：当遇到应用程序时，应用程序会将异常记录到数据库表中。'
- en: Whichever mechanism or mechanisms you choose is down to you and your application
    needs. However, you must make sure that the logs are well-formatted and that the
    data that’s provided is meaningful. Logs are no good if they are hard to read
    and contain lots of noise!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种机制或机制，都取决于你和你应用程序的需求。然而，你必须确保日志格式良好，并且提供的数据是有意义的。如果日志难以阅读且包含大量噪声，那么日志就没有价值了！
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use a best practice that dictates managed and unmanaged resources should be
    correctly disposed of, especially if an application does crash. When providing
    tech support, I have often come across situations where applications have crashed
    and locked resources, and where resources have been kept alive in memory. This
    leads to bad user experiences and can lead to files, directories, and other resources
    not being accessible, and the application itself not being able to start up. Often,
    in these cases, the only options are to kill the application using Task Manager
    or restart the computer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最佳实践，规定托管和非托管资源应正确释放，特别是如果应用程序崩溃的话。在提供技术支持时，我经常遇到应用程序崩溃并锁定资源的情况，以及资源在内存中保持活跃的情况。这会导致糟糕的用户体验，并可能导致文件、目录和其他资源不可访问，以及应用程序本身无法启动。在这些情况下，通常唯一的选择是使用任务管理器结束应用程序或重启计算机。
- en: Performing memory tasks efficiently
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效执行内存任务
- en: 'When benchmarking C# programs, you will see that sometimes, the objects that
    allocate the most memory will be faster than the methods that allocate fewer objects.
    A case in point is strings. Using formatted strings can allocate fewer memory
    interpolated strings. However, formatted strings can be slower than using interpolated
    strings. We are going to demonstrate this with a really simple piece of code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当基准测试C#程序时，你会看到有时分配最多内存的对象会比分配较少对象的方程序更快。一个例子是字符串。使用格式化字符串可以分配较少的内存插值字符串。然而，格式化字符串可能比使用插值字符串更慢。我们将用一个非常简单的代码片段来演示这一点：
- en: Add a class to the `Memory` and configure it for using *BenchmarkDotNet*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个类添加到`Memory`中，并配置它使用*BenchmarkDotNet*。
- en: 'Add the `ReturnFormattedString()` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ReturnFormattedString()`方法：
- en: '[PRE17]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method returns a formatted string. It is essentially one line and contains
    no named variables.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个格式化字符串。它基本上是一行，不包含命名变量。
- en: 'Add the `ReturnInterpolatedString()` method to the `Memory` class:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ReturnInterpolatedString()`方法添加到`Memory`类中：
- en: '[PRE18]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method declares several strings and assigns values to them. It then returns
    the interpolated string. This method covers multiple lines and looks like it will
    be slower and use the most memory. However, the only way to know for sure is to
    run the benchmarks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法声明了几个字符串并将值赋给它们。然后它返回一个插值字符串。此方法覆盖多行，看起来可能会更慢并使用最多的内存。然而，唯一确定的方法是运行基准测试。
- en: 'Add the `BenchmarkRunner.Run<Memory>();` call to your `Main` method, do a `Release`
    build, and then run the executable from the command line. The following screenshot
    shows the memory that was allocated and the time it took to perform each method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BenchmarkRunner.Run<Memory>();`调用添加到`Main`方法中，进行`Release`构建，然后从命令行运行可执行文件。以下截图显示了分配的内存以及执行每个方法所需的时间：
- en: '![Figure 7.3 – The Benchmark summary report comparing String.Format against
    interoperable strings'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 比较String.Format与可互操作字符串的基准测试总结报告'
- en: '](img/B16617_Figure_8.3.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_8.3.jpg)'
- en: Figure 7.3 – The Benchmark summary report comparing String.Format against interoperable
    strings
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 比较String.Format与可互操作字符串的基准测试总结报告
- en: As you can see, even though we can declare multiple variables and allocate the
    most memory using our string interoperability method, it is much faster than doing
    the same thing with `String.Format`. If you have a lot of string processing to
    do, such as in batch report generation or document processing, then you can almost
    halve the time it takes to perform your string manipulations using string interoperability.
    The memory also never reaches generation 1, so it is dealt with efficiently by
    the garbage collector.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管我们可以声明多个变量并使用我们的字符串互操作性方法分配最多的内存，但它比使用`String.Format`执行相同操作要快得多。如果你有很多字符串处理要做，比如在批量报告生成或文档处理中，那么你可以几乎将执行字符串操作所需的时间减半，使用字符串互操作性。内存也永远不会达到第1代，因此它被垃圾回收器有效地处理。
- en: Also, you need to reduce the amount of boxing and unboxing that you do. Every
    time you convert a value type into a reference type, it will be stored on the
    heap. And every time you convert a reference type into a value type, you place
    it on the stack. So, what are the performance implications for doing this? Boxing
    and unboxing are computationally expensive processes. The more computations that
    are required to perform a function, the slower the process will be. So, by eliminating
    unnecessary computations caused by boxing and unboxing, you speed up your application
    and can end up using less memory. So, when you can, try and use value types on
    the stack instead of reference types on the heap.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要减少你进行的装箱和拆箱的数量。每次将值类型转换为引用类型时，它都会存储在堆上。每次将引用类型转换为值类型时，你都会将其放置在栈上。那么，这样做对性能有什么影响呢？装箱和拆箱是计算密集型的过程。需要执行函数的计算越多，过程就越慢。因此，通过消除由装箱和拆箱引起的非必要计算，你可以加快应用程序的速度，并最终使用更少的内存。所以，当你能这样做的时候，尽量使用栈上的值类型而不是堆上的引用类型。
- en: Avoid code duplication in your objects. If you have multiple constructor overrides,
    then place the common code in the common constructor and do the same with your
    methods. A class with duplicate code will use more memory than the same class
    correctly coded to have no duplication. You should always look for ways to refactor
    your objects to reduce code bloat, and removing code duplication and reusing code
    is an easy way to do this.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在对象中重复代码。如果你有多个构造函数重写，那么将公共代码放在公共构造函数中，并对你自己的方法做同样的事情。具有重复代码的类将比正确编写的没有重复的相同类使用更多的内存。你应该始终寻找方法来重构你的对象以减少代码膨胀，移除代码重复和重用代码是这样做的一种简单方法。
- en: Memory fragmentation can be a major cause of performance issues for C# programs.
    Memory fragmentation occurs when objects are added to the heap, garbage is collected,
    and then other objects fill the available space. If you end up with free space
    between the objects in memory, then your memory has become fragmented. The GC
    will perform a compacting collection when it is most efficient to do so. Doing
    this manually should only be done after carefully investigating the scenario in
    question.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内存碎片化可能是C#程序性能问题的重大原因。当对象被添加到堆中，垃圾回收，然后其他对象填充可用空间时，就会发生内存碎片化。如果你在内存中的对象之间有空闲空间，那么你的内存已经碎片化了。GC将在最有效的时候执行压缩收集。手动执行此操作应在仔细调查了相关场景之后进行。
- en: 'In C#, you can defragment the **Large Object Heap** (**LOH**) using the garbage
    collection settings that are available, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，你可以使用可用的垃圾回收设置来对**大型对象堆（LOH**）进行碎片整理，如下所示：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code ensures that the objects on the LOH occupy a contiguous area of memory.
    All the free space that is located between objects in memory is removed and placed
    at the end of the allocated memory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保LOH上的对象占用连续的内存区域。所有位于内存中对象之间的空闲空间都被移除并放置在分配内存的末尾。
- en: You should also consider not using finalizers. An object will remain in memory
    longer if it uses finalizers. This will cause a build-up of memory usage. And
    a build-up of memory usage will lead to reduced performance by your applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑不使用终结器。如果对象使用终结器，它将在内存中保持更长时间。这将导致内存使用量增加。内存使用量的增加会导致应用程序性能降低。
- en: It is a best practice to dispose of objects and resources when you have finished
    with them. This helps prevent objects remaining in memory that are not being used,
    and also releases locks on resources such as files and directories.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成对象和资源时，销毁它们是一种最佳实践。这有助于防止未使用的对象留在内存中，并且还释放了文件和目录等资源上的锁。
- en: When utilizing disposable objects, you should always try and use the `using`
    statement. This is because when the block of code finishes, the object will automatically
    be disposed of. When you write a class that uses various disposable resources,
    even if it does not own those disposable resources, you should implement the disposable
    pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一次性对象时，你应该始终尝试使用`using`语句。这是因为当代码块执行完毕后，对象将自动被销毁。当你编写一个使用各种可处置资源的类时，即使它不拥有这些可处置资源，你也应该实现可处置模式。
- en: So far, we have looked at file and memory operations and how performance can
    be impacted. Now, let’s turn our attention to local storage tasks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了文件和内存操作以及性能可能受到影响的情况。现在，让我们将注意力转向本地存储任务。
- en: Understanding local storage tasks
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解本地存储任务
- en: 'On Windows 10, there are several locations that you can use to store data locally.
    These are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10上，有几个位置可以用来本地存储数据。具体如下：
- en: '`AppData` folder, this folder can contain settings, files, and folders. This
    folder is used for data that is not that easy to recreate or download. If you
    have backup applications that can back up a user’s `AppData` folder, then anything
    stored in the `Local` folder will be backed up.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppData`文件夹，这个文件夹可以包含设置、文件和文件夹。这个文件夹用于那些不容易重新创建或下载的数据。如果你有可以备份用户`AppData`文件夹的备份应用程序，那么存储在`Local`文件夹中的任何内容都将被备份。'
- en: '`ApplicationData.LocalCacheFolder` property can be stored in the local cache.
    Items stored using the local cache will be persisted across sessions.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationData.LocalCacheFolder`属性可以存储在本地缓存中。使用本地缓存存储的项目将在会话之间持久化。'
- en: '**Roaming**: Roaming profiles can be used by network users to store their local
    data on the server. This has the advantage that prudent network managers will
    ensure profiles are backed up regularly, so users will always have a restore point
    if they happen to lose data.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**漫游**：网络用户可以使用漫游配置文件在服务器上存储他们的本地数据。这有一个优点，那就是谨慎的网络管理员会确保配置文件定期备份，这样如果用户意外丢失数据，他们总有一个恢复点。'
- en: '`AppData\Temp` folder for temporary data. It is a good idea to clean data in
    the `Temp` folder when you have finished with it. Application initialization and
    shutdown are good points to perform system housekeeping.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppData\Temp`文件夹用于临时数据。当你完成对临时文件夹的数据操作后，清理数据是一个好主意。应用程序的初始化和关闭是执行系统维护的好时机。'
- en: '**C:\ProgramData**: This location is a best practice location for storing application
    data. However, this location does not always get backed up. So, it is always a
    good idea to provide an in-application way to ensure data is regularly backed
    up and stored in a safe location in case your computer dies, which does happen!'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C:\ProgramData**：这是一个存储应用程序数据的最佳实践位置。然而，这个位置并不总是会被备份。因此，始终提供一个应用程序内的方式以确保数据定期备份并存储在安全的位置是一个好主意，以防你的电脑出现故障，这种情况确实会发生！'
- en: It’s down to you regarding how and where you store your data. From my extensive
    experience providing IT support to schools, they can have some extremely complicated
    and very hardened systems security-wise. You cannot assume your application will
    be installed on the `C:\` drive, and you cannot assume you will have access to
    the `C:\ProgramData` folder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何以及在哪里存储你的数据，这取决于你。根据我提供学校IT支持的丰富经验，他们可能有一些极其复杂且在安全方面非常坚固的系统。你不能假设你的应用程序将安装在`C:\`驱动器上，也不能假设你将能够访问`C:\ProgramData`文件夹。
- en: Many business and assessment hours have been lost by schools trying to install
    and run educational vendor software on such complicated systems. Often, this leads
    to remote technical support sessions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 学校在尝试在如此复杂的系统上安装和运行教育供应商软件时，已经失去了许多商业和评估时间。这通常会导致远程技术支持会议。
- en: Another problem that can often arise is the use of the Microsoft VirtualStore.
    When a user installs software and they are presented with the question, `Install
    for anyone who uses this computer` or `Install for Just Me`, they tend to select
    the latter. On Windows 10 computers, `Install for Just Me` puts the stored data
    for the installed application into the user’s virtual store. But selecting `Install
    for anyone who uses this computer` will normally store application data in the
    `C:\ProgramData\YOUR_APPLICATION` folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题经常出现是使用微软虚拟存储。当用户安装软件并遇到问题，`为使用此计算机的任何人安装`或`仅为我安装`时，他们往往会选择后者。在Windows
    10计算机上，选择`仅为我安装`会将已安装应用程序的存储数据放入用户的虚拟存储中。但选择`为使用此计算机的任何人安装`通常会将应用程序数据存储在`C:\ProgramData\YOUR_APPLICATION`文件夹中。
- en: A telltale sign that a user has installed the software for only themselves to
    use is when multiple people log onto an office computer, and each person has a
    copy of the data. When this happens, multiple copies of the data exist. These
    copies can be found in each person’s virtual store.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当多人登录到办公室计算机上，并且每个人都有一份数据副本时，一个明显的迹象是用户只为自己的使用安装了软件。当这种情况发生时，数据存在多个副本。这些副本可以在每个人的虚拟存储中找到。
- en: This is exactly what happened to me and my colleagues. We develop educational
    software that comes in standalone, network, and online formats. For our standalone
    customers, we offer a single-user license. The data for the application is stored
    in a Microsoft Access database. Originally a problem on Windows 7, which remains
    a potential problem on Windows 10, is users being given the prompt to install
    for just them or all users. When they install for all users, the Microsoft Access
    database can be found under `C:\ProgramData\CompanyName\ProductName`. All users
    who log onto the computer to use our software will see the same datasets. But
    should a user select to install only for themselves, then our software’s data
    will be stored under the user profile's VirtualStore
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我和我的同事所经历的情况。我们开发的教育软件有独立、网络和在线格式。对于我们的独立客户，我们提供单用户许可证。应用程序的数据存储在Microsoft
    Access数据库中。最初是Windows 7上的一个问题，现在在Windows 10上仍然是一个潜在的问题，即用户被提示安装给自己或所有用户。当他们为所有用户安装时，Microsoft
    Access数据库可以在 `C:\ProgramData\CompanyName\ProductName` 下找到。所有登录到计算机使用我们软件的用户将看到相同的数据集。但如果用户选择仅为自己安装，那么我们的软件数据将存储在用户配置文件的VirtualStore下
- en: The location of the Virtual Store is `C:\Users\%USERNAME%\AppData\Local\VirtualStore`.
    This is useful to know because it reduces your time locating the data for the
    various users under their profiles. The difficulty arises when the customer demands
    that the data be merged and stored in a central location. When this situation
    arises, uninstall the software and reinstall it, making sure that you select the
    option to `Install for all users`. Then, request the users stop using the software
    until you have provided them with the merged data. Information such as this may
    not increase the performance of your C# and .NET programs, but it certainly improves
    your performance when you’re providing technical support. And that can be a feather
    in your cap, as I have found to my benefit! And as programmers/technical support
    staff/software developers, we all go through personal performance reviews to see
    how well we are doing in our roles.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟存储的位置是 `C:\Users\%USERNAME%\AppData\Local\VirtualStore`。了解这一点很有用，因为它可以减少你在各个用户配置文件下定位数据所需的时间。当客户要求将数据合并并存储在中央位置时，困难就出现了。在这种情况下，卸载软件并重新安装它，确保选择“为所有用户安装”选项。然后，要求用户停止使用软件，直到你为他们提供合并后的数据。此类信息可能不会提高你的C#和.NET程序的性能，但它确实在你提供技术支持时提高了你的效率。这可以成为你的优势，正如我发现的对我有益的那样！并且作为程序员/技术支持人员/软件开发人员，我们都会进行个人绩效评估，以了解我们在各自角色中的表现如何。
- en: Now that we have concluded the material for this chapter, let’s summarize what
    we have learned.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了本章的内容，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by looking at various file paths. There are four
    different types of file paths – absolute paths, relative paths, UNC paths, and
    DOS device paths.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先查看了几种不同的文件路径。有四种不同类型的文件路径——绝对路径、相对路径、UNC路径和DOS设备路径。
- en: After discussing the various types of paths, we learned that, by default, Windows
    and Windows Server are limited to a complete file path length of 256 characters.
    In today’s world of open source and web-based software working across platforms,
    this maximum standard length on Windows computers can be very limiting. This can
    cause backup issues when you’re performing disk-to-disk backups, and deeply nested
    projects can blow the maximum file path length. To overcome this limitation, we
    learned how to remove the limit by accessing and modifying the registry.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了各种路径类型之后，我们了解到，默认情况下，Windows和Windows Server被限制在256个字符的完整文件路径长度。在当今开源和基于Web的软件跨平台工作的世界中，Windows计算机上的这个最大标准长度可能非常有限。这在进行磁盘到磁盘备份时可能会引起备份问题，并且深度嵌套的项目可能会超出最大文件路径长度。为了克服这一限制，我们学习了如何通过访问和修改注册表来移除限制。
- en: The next thing we looked at was the various considerations for improving disk
    I/O. We started looking at I/O performance considerations by considering the different
    hardware devices that can affect performance. Then, we benchmarked some code to
    find the most efficient ways of calculating directory sizes, moving files, and
    performing asynchronous file manipulation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来关注的是提高磁盘I/O的各种考虑因素。我们通过考虑可能影响性能的不同硬件设备开始考虑I/O性能考虑因素。然后，我们对一些代码进行了基准测试，以找到计算目录大小、移动文件和执行异步文件操作的最有效方法。
- en: The next thing we looked at was exception handling. We came to understand that
    bubbling up exceptions unnecessarily affects performance and that they should
    be caught and dealt with at the source. We also came to understand that we should
    not swallow exceptions by catching generic exceptions. Generic exceptions should
    only be a last resource for logging purposes before you close the application
    down due to encountering a non-recoverable exception.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来关注的是异常处理。我们认识到，不必要地向上冒泡异常会影响性能，并且它们应该在源头被捕获和处理。我们还认识到，我们不应该通过捕获通用异常来吞没异常。通用异常只应在关闭应用程序以处理不可恢复异常之前，作为日志记录的最后一资源。
- en: We then looked at memory tasks. After benchmarking `string.Format` and interpolated
    strings, where we learned how using interpolated strings almost doubled our `performane.Next`,
    we considered memory fragmentation, which can occur when we’re adding and removing
    objects of various sizes. We also learned how to compact fragmented memory to
    make it run more efficiently.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来关注的是内存任务。在基准测试`string.Format`和插值字符串之后，我们了解到使用插值字符串几乎将我们的`performane.Next`提高了两倍，然后我们考虑了内存碎片化，这可能会在添加和删除各种大小的对象时发生。我们还学习了如何压缩碎片化内存以提高其运行效率。
- en: Finally, we looked at local storage tasks. We discussed the various types of
    local storage available and their uses. Plus, we discussed the end user installation
    of our products, which can result in different logged-on users having their own
    sets of data. This problem arises when users choose to install for themselves
    instead of all users. Thus, each user has their copy of the application data stored
    against the profile in `C:\Users\%USERNAME%\AppData\Local\VirtualStore`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了本地存储任务。我们讨论了可用的各种本地存储类型及其用途。此外，我们还讨论了我们的产品的最终用户安装，这可能导致不同登录用户拥有自己的数据集。当用户选择为自己安装而不是为所有用户安装时，就会出现这个问题。因此，每个用户都有其应用程序数据的副本存储在`C:\Users\%USERNAME%\AppData\Local\VirtualStore`的配置文件中。
- en: In the next chapter, we will look at networking. But before we do, see if you
    can answer the following questions. Then, improve your knowledge on the topic
    of I/O performance by looking at the *Further reading* section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨网络。但在我们这样做之前，看看你是否能回答以下问题。然后，通过查看*进一步阅读*部分来提高你对I/O性能主题的了解。
- en: Questions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: What are the various Windows file path formats that you need to be aware of?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要了解哪些各种Windows文件路径格式？
- en: How do you remove the 256-character limit for Windows file paths?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何移除Windows文件路径的256字符限制？
- en: Which method is the most efficient for calculating directory sizes?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法是最有效的计算目录大小的方法？
- en: Which method is the most efficient for moving files?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法是最有效的移动文件的方法？
- en: When should you catch exceptions using the `Exception` class?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在何时使用`Exception`类来捕获异常？
- en: What is the base I/O `Exception` class?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础I/O `Exception` 类是什么？
- en: What file location options do you have for local storage?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本地存储，你有哪些文件位置选项？
- en: What is one of the potential pitfalls that may be encountered when users install
    your software?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户安装你的软件时可能会遇到哪些潜在陷阱？
- en: What is the Microsoft Virtual Store?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软虚拟存储是什么？
- en: Where is the Microsoft Virtual Store located?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软虚拟存储位于何处？
- en: Further reading
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请参阅以下资源：
- en: '*File and Stream I/O*: [https://docs.microsoft.com/dotnet/standard/io/](https://docs.microsoft.com/dotnet/standard/io/).'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件和流I/O*: [https://docs.microsoft.com/dotnet/standard/io/](https://docs.microsoft.com/dotnet/standard/io/).'
- en: '*Pipes*: [https://docs.microsoft.com/dotnet/standard/io/pipe-operations](https://docs.microsoft.com/dotnet/standard/io/pipe-operations).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管道*: [https://docs.microsoft.com/dotnet/standard/io/pipe-operations](https://docs.microsoft.com/dotnet/standard/io/pipe-operations).'
- en: '*Faster file move method other than File.Move*: [https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move](https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*除了 File.Move 之外更快的文件移动方法*: [https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move](https://stackoverflow.com/questions/18968830/faster-file-move-method-other-than-file-move).'
- en: '*C# GetFileSystemInfos can get file sizes quickly*: [https://thedeveloperblog.com/getfilesysteminfos](https://thedeveloperblog.com/getfilesysteminfos).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C# GetFileSystemInfos 可以快速获取文件大小*: [https://thedeveloperblog.com/getfilesysteminfos](https://thedeveloperblog.com/getfilesysteminfos).'
- en: '*Performance of writing to a file in C#*: [https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp](https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C# 写入文件的性能*: [https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp](https://stackoverflow.com/questions/9437265/performance-of-writing-to-file-c-sharp).'
- en: '*Asynchronous File Processing*: https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/using-async-for-file-access#:~:text=%20Asynchronous%20file%20access%20(C#)%20%201%20Use,writing%2010%20text%20files.%20For%20each...%20More.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步文件处理*: https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/using-async-for-file-access#:~:text=%20Asynchronous%20file%20access%20(C#)%20%201%20Use,writing%2010%20text%20files.%20For%20each...%20More.'
- en: '*How to iterate file directories with PLINQ*: [https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3](https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用 PLINQ 遍历文件目录*: [https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3](https://docs.microsoft.com/bs-cyrl-ba/dotnet/standard/parallel-programming/how-to-iterate-file-directories-with-plinq?view=dynamics-usd-3).'
- en: '*Handling I/O exceptions in .NET*: [https://docs.microsoft.com/dotnet/standard/io/handling-io-errors](https://docs.microsoft.com/dotnet/standard/io/handling-io-errors).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 .NET 中处理 I/O 异常*: [https://docs.microsoft.com/dotnet/standard/io/handling-io-errors](https://docs.microsoft.com/dotnet/standard/io/handling-io-errors).'
- en: '*Calling Windows 10 APIs from a desktop application*: https://blogs.windows.com/windowsdeveloper/2017/01/25/calling-windows-10-apis-desktop-application/#vZiZ96PlZUqTduts.97.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从桌面应用程序调用 Windows 10 API*: https://blogs.windows.com/windowsdeveloper/2017/01/25/calling-windows-10-apis-desktop-application/#vZiZ96PlZUqTduts.97.'
- en: '*Performance Improvements in .NET 6*: [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET 6 的性能改进*: [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/).'
- en: '*Page (Computer Memory)*: [https://en.wikipedia.org/wiki/Page_(computer_memory)](https://en.wikipedia.org/wiki/Page_(computer_memory)).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*页面（计算机内存）*: [https://en.wikipedia.org/wiki/Page_(computer_memory)](https://en.wikipedia.org/wiki/Page_(computer_memory)).'
