- en: The Containerization of Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的容器化
- en: The previous chapter focused on several advanced topics to do with building
    web services using ASP.NET Core. This chapter offers a quick introduction to containers
    and how they can be useful for running your application locally in a sandbox environment.
    This chapter is not designed to cover everything about containers; rather, it's
    more of a brief introduction to them. We will learn how to run the catalog service
    on containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章重点介绍了使用 ASP.NET Core 构建网络服务的一些高级主题。本章快速介绍了容器以及它们如何在本地沙盒环境中运行应用程序方面非常有用。本章的设计并不是要涵盖所有关于容器的内容；相反，它更多的是对它们的简要介绍。我们将学习如何在容器上运行目录服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介
- en: How to run the catalog service on Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Docker 上运行目录服务
- en: An overview of .NET Core Docker images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core Docker 镜像概述
- en: Optimizing Docker images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 Docker 镜像
- en: An introduction to containers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: Nowadays, distributed systems form the base of every application. In turn, the
    foundation of distributed systems is containers. The goal of containerization
    is to run resources in an isolated environment. Containers define boundaries and
    the separation of concerns between the components of a distributed system. This
    separation of concerns is a way for us to reuse containers by providing parameterized
    configurations. Another important feature of web services and web applications
    is *scalability*. It should be easy to scale up your containers and create new
    instances.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分布式系统构成了每个应用程序的基础。反过来，分布式系统的基础是容器。容器化的目标是资源在隔离环境中运行。容器定义了分布式系统组件之间的边界和关注点的分离。这种关注点的分离是我们通过提供参数化配置来重用容器的方式。网络服务和网络应用的另一个重要特性是
    *可伸缩性*。应该很容易扩展容器并创建新的实例。
- en: Docker is a tool that is designed to create, run, and deploy applications using
    containers. Docker is also referred to as a platform that promotes this technology.
    Over the last few years, Docker has become somewhat of a buzzword, and it has
    been adopted by a considerable number of companies, start-ups, and open source
    projects. Various projects are associated with Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个旨在使用容器创建、运行和部署应用程序的工具。Docker 也被称为推广这项技术的平台。在过去的几年里，Docker 已经成为了一个热门词汇，并且被相当多的公司、初创企业和开源项目所采用。许多项目都与
    Docker 有关。
- en: To begin, let's talk about **Moby** ([https://github.com/moby/moby](https://github.com/moby/moby)),
    which is an open source project created by Docker. As a large number of people
    and communities started to contribute to the project, Docker decided to develop
    Moby. All contributions to the Moby project, which can be considered as a sort
    of research and development department of Docker, are open source.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈 **Moby** ([https://github.com/moby/moby](https://github.com/moby/moby))，这是一个由
    Docker 创建的开源项目。随着大量的人和社区开始为该项目做出贡献，Docker 决定开发 Moby。Moby 项目的所有贡献，可以被视为 Docker
    的一个研发部门，都是开源的。
- en: 'Moby is a framework that is used to build specific container systems. It provides
    a library of components that are the fundamentals of a container system:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Moby 是一个用于构建特定容器系统的框架。它提供了一组组件，这些组件是容器系统的基本要素：
- en: OS and container runtime
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统和容器运行时
- en: Orchestration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排
- en: Infrastructure management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施管理
- en: Networking
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Storage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Security
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Build
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Image distribution
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像分发
- en: It also provides the tools that are necessary to build up these components to
    create a runnable artifact for each platform and architecture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了构建这些组件所需的工具，以创建适用于每个平台和架构的可运行工件。
- en: If we are looking for more downstream solutions, we have the Docker **Community
    Edition** (**CE**) and Docker **Enterprise Edition** (**EE**) versions, which
    are products that use the Moby project. Docker CE is used by small teams and developers
    to build their system, while business customers use Docker EE. Both are recommended
    solutions allowing us to use containerization in development and enterprise environments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们寻找更多的下游解决方案，我们有 Docker **社区版**（**CE**）和 Docker **企业版**（**EE**）版本，这些是使用 Moby
    项目的产品。Docker CE 被小型团队和开发者用来构建他们的系统，而商业客户使用 Docker EE。两者都是推荐解决方案，允许我们在开发和企业环境中使用容器化。
- en: 'This chapter will use Docker CE to containerize the catalog service. Docker
    CE and Docker EE are available on the Docker website: [https://www.docker.com/](https://www.docker.com/).
    You can download and install the Community Edition by following the steps provided
    at [https://www.docker.com/get-started](https://www.docker.com/get-started).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用Docker CE对目录服务进行容器化。Docker CE和Docker EE可在Docker网站上找到：[https://www.docker.com/](https://www.docker.com/)。您可以通过遵循提供的步骤下载并安装社区版：[https://www.docker.com/get-started](https://www.docker.com/get-started)。
- en: Docker terminology
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker术语
- en: Before setting up our service to use Docker, let's take a quick look at the
    terminology behind this technology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的服务使用Docker之前，让我们快速了解一下这项技术背后的术语。
- en: Let's begin by defining a container image, which is the list of all dependencies
    and artifacts needed to create a container instance. The term *container image*
    should not be confused with the term *container instance*, which refers to a single
    instance of a container image*.*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义容器镜像开始，这是创建容器实例所需的所有依赖项和工件列表。术语*容器镜像*不应与术语*容器实例*混淆，后者指的是容器镜像的单个实例*。
- en: 'A core part of a container image is the Dockerfile. The Dockerfile provides
    the instructions to build a container. For example, in the case of a container
    that runs a .NET Core solution, it gives the commands to restore the packages
    and build the solution. Docker also provides a way to tag the container images
    and group them all in collections known as **repositories**. Repositories are
    usually covered by a registry, which allows access to a specific repository. The
    repositories can be public or private, depending on what they are used for. For
    example, a private company can use a private repository to provide different versions
    of containers to internal teams. This centralized way of thinking is powerful,
    and it gives us a way to reuse containers. The main example of a public repository
    is [https://hub.docker.com/](https://hub.docker.com/), which is the world''s most
    extensive library that provides container images:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的核心部分是Dockerfile。Dockerfile提供了构建容器的指令。例如，对于一个运行.NET Core解决方案的容器，它提供了恢复包和构建解决方案的命令。Docker还提供了一种对容器镜像进行标记并将它们分组到称为**仓库**的集合中的方法。仓库通常由注册表覆盖，允许访问特定的仓库。仓库可以是公共的或私有的，具体取决于它们的使用目的。例如，一家私人公司可以使用私有仓库为内部团队提供不同版本的容器。这种集中式思考方式非常强大，它为我们提供了重用容器的方法。公共仓库的主要例子是[https://hub.docker.com/](https://hub.docker.com/)，这是世界上最大的库，提供容器镜像：
- en: '![](img/c3f3196b-bd1e-44b6-b602-8c37057cdda5.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3f3196b-bd1e-44b6-b602-8c37057cdda5.png)'
- en: The preceding diagram describes a typical interaction between the components
    we described in this section. The client usually provides some Docker commands
    that are parsed and executed in the **Docker HOST**. The **Docker HOST**contains
    both of the *containers* we are running on the local machine and the images used
    by those containers. The images are usually taken by a Docker public or private
    registry, which is generally to the Docker Hub website or a private company repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了本节中描述的组件之间的典型交互。客户端通常会提供一些Docker命令，这些命令在**Docker HOST**上被解析和执行。**Docker
    HOST**包含我们在本地机器上运行的**容器**以及这些容器使用的镜像。这些镜像通常来自Docker公共或私有仓库，这通常是Docker Hub网站或私人公司仓库。
- en: Another essential term to do with Docker is the compose tool. The compose tool
    is used for defining and running a multi-container application or service. A composer
    is usually combined with a definition file in a different format, such as a YAML
    file that defines the structure of the container group.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker相关的另一个重要术语是compose工具。Compose工具用于定义和运行一个多容器应用程序或服务。通常，composer会与一个不同格式的定义文件结合使用，例如一个YAML文件，该文件定义了容器组的结构。
- en: The compose tool usually runs using the `docker-compose` CLI command. In this
    chapter, we will use the `docker-compose` command to get our service running in
    the local environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Compose工具通常使用`docker-compose` CLI命令运行。在本章中，我们将使用`docker-compose`命令使我们的服务在本地环境中运行。
- en: An essential part of a container system is the *orchestrator*. An *orchestrator*
    simplifies the use of a multi-container system. Moreover, orchestrators are usually
    applied to complex systems. Examples of container orchestrators include Kubernetes,
    Azure Service Fabric, and Docker Swarm.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器系统的一个基本部分是*编排器*。编排器简化了多容器系统的使用。此外，编排器通常应用于复杂系统。容器编排器的例子包括Kubernetes、Azure
    Service Fabric和Docker Swarm。
- en: This book will not cover the use of orchestrators. This chapter gives a high-level
    overview of the capabilities of Docker and, more generally, containerization.
    More complex topics to do with Docker require DevOps and system engineering skills.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖编排器的使用。本章提供了 Docker 和更广泛的容器化能力的高级概述。更复杂的 Docker 主题需要 DevOps 和系统工程技能。
- en: Let's move on to look at the power of containerization and how to use it to
    build our applications and services quickly. The next section will apply container
    principles to the catalog service built in the previous chapter. The following
    section will also use container technologies extensively to get our examples up
    and running.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨容器化的力量以及如何快速使用它来构建我们的应用程序和服务。下一节将应用上一章中构建的目录服务的容器原则。下一节也将广泛使用容器技术来使我们的示例运行起来。
- en: Using Docker to run the catalog service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 运行目录服务
- en: 'This section explains how to combine our catalog service with Docker to get
    it running locally. Let''s start by examining the systems behind the catalog service:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何将我们的目录服务与 Docker 结合起来，使其在本地运行。让我们首先检查目录服务背后的系统：
- en: '![](img/70b28f16-f147-46c6-9efd-3a732844e21c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70b28f16-f147-46c6-9efd-3a732844e21c.png)'
- en: As we can see from the preceding diagram, the web service part runs over the
    `microsoft/dotnet` Docker image, and the data source part runs over the Microsoft
    SQL Server instance using the `microsoft/mssql-server-linux` Docker image (we
    already dealt with the containerization of MSSQL in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*). Both of the images are downloaded from the
    public Microsoft repository already present in Docker Hub; let's take a look at
    how to use `docker-compose` to define the whole infrastructure of the service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Web 服务部分运行在 `microsoft/dotnet` Docker 镜像上，数据源部分运行在 Microsoft SQL Server
    实例上，使用的是 `microsoft/mssql-server-linux` Docker 镜像（我们已经在第 8 章[84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml]，*构建数据访问层*中处理了
    MSSQL 的容器化）。这两个镜像都已从 Docker Hub 中现有的公共 Microsoft 仓库下载；让我们看看如何使用 `docker-compose`
    定义整个服务的基础设施。
- en: 'First of all, let''s create a `docker-compose.yml` file with the following
    content in the root folder of the project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目的根目录下创建一个包含以下内容的 `docker-compose.yml` 文件：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding file uses the YAML syntax to define two containers. The first
    is the `catalog_api` container: it will be used to host the core part of the service
    built on top of the ASP.NET Core framework. The second container is `catalog_db`,
    which uses a `microsoft/mssql-server-linux` image (the same that we used in [Chapter
    8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data Access Layer*)
    to set up the MSSQL database.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件使用 YAML 语法定义了两个容器。第一个是 `catalog_api` 容器：它将用于托管基于 ASP.NET Core 框架构建的服务核心部分。第二个容器是
    `catalog_db`，它使用 `microsoft/mssql-server-linux` 镜像（与我们在第 8 章[84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml]，*构建数据访问层*中使用的一样）来设置
    MSSQL 数据库。
- en: 'Furthermore, we should proceed by creating the following folder structure in
    the root of the project:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应在项目的根目录下创建以下文件夹结构：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding folders will contain the files related to the API and the database
    containers specified in the `docker-compose.yml` file. Let''s continue by examining
    the definition of the `catalog_api` container:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件夹将包含 `docker-compose.yml` 文件中指定的 API 和数据库容器的相关文件。让我们继续通过检查 `catalog_api`
    容器的定义来深入了解：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding snippet of code specifies the current folder as the build context
    and the `containers/api/Dockerfile` file to build the Docker image. It also refers
    to an environment variables file by using the following syntax:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段指定当前文件夹为构建上下文，并引用 `containers/api/Dockerfile` 文件来构建 Docker 镜像。它还通过以下语法引用环境变量文件：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, it declares the container under a network called `my_network` and exposes
    port `5000` to the hosting system using the `ports:` directive.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它声明了一个名为 `my_network` 的网络下的容器，并使用 `ports:` 指令将端口 `5000` 暴露给宿主系统。
- en: In the same way, the `catalog_db` container declares the same network defined
    for the `catalog_api` container, and it specifies a different environment variables
    file using the same approach as seen previously.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`catalog_db` 容器声明了与 `catalog_api` 容器相同的网络，并使用之前看到的方法指定了一个不同的环境变量文件。
- en: At the end of the `docker-compose.yml` file, there is the definition of `my_network`,
    which uses a bridge driver. The bridge driver is the default option for the network.
    Two containers under the same bridge network can share traffic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`文件末尾，定义了`my_network`，它使用桥接驱动程序。桥接驱动程序是网络的默认选项。在同一桥接网络下的两个容器可以共享流量。
- en: 'For more information about the types of drivers provided out of the box, refer
    to the following link: [https://docs.docker.com/network/](https://docs.docker.com/network/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于开箱即用的驱动程序类型的信息，请参阅以下链接：[https://docs.docker.com/network/](https://docs.docker.com/network/)。
- en: Defining environment variables
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义环境变量
- en: 'Docker provides a lot of ways to specify the environment variables of a container.
    In the `docker-compose.yml` file specified earlier; we use the `env_file` approach.
    Furthermore, we can proceed by creating the `api/api.env` file in the corresponding
    path specified in the definition of the `catalog_api` container:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了许多指定容器环境变量的方法。在前面指定的`docker-compose.yml`文件中，我们使用了`env_file`方法。此外，我们还可以通过在`catalog_api`容器的定义中指定的路径创建`api/api.env`文件来继续：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The file syntax expects each line in the file to be in the following format:
    `VAR=VAL`. In the preceding case, we are defining the environment variables used
    by ASP.NET Core to run the service: the `ASPNETCORE_URLS` variable specifies the
    URLs used by the web service and `ASPNETCORE_ENVIRONMENT` specifies the environment
    name used by the application. In the same way, we should also proceed by defining
    the `db/db.env` file in the corresponding folder:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 文件语法期望文件中的每一行都遵循以下格式：`VAR=VAL`。在前面的例子中，我们正在定义ASP.NET Core运行服务所使用的环境变量：`ASPNETCORE_URLS`变量指定了由网络服务使用的URL，`ASPNETCORE_ENVIRONMENT`指定了应用程序使用的环境名称。同样，我们也应该在相应的文件夹中定义`db/db.env`文件：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, the file defines the corresponding variables for the SQL Server
    container: `SA_PASSWORD` specifies the system administrator account password,
    the `ACCEPT_EULA` needed by the startup process of SQL Server.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件定义了SQL Server容器的相应变量：`SA_PASSWORD`指定系统管理员账户密码，`ACCEPT_EULA`是SQL Server启动过程所需的。
- en: 'In addition to this, `docker-compose` supports declaring default environment
    variables in the `.env` file. The file must be placed in the same directory as
    the `docker-compose.yml` file. The file contains some simple rules for defining
    environment variables. Let''s create a new `.env` file in the root folder of the
    catalog service directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`docker-compose`支持在`.env`文件中声明默认环境变量。该文件必须放置在`docker-compose.yml`文件相同的目录中。该文件包含一些定义环境变量的简单规则。让我们在目录服务目录的根文件夹中创建一个新的`.env`文件：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `COMPOSE_PROJECT_NAME` variable is a reserved variable of the `docker-compose`
    command provided by Docker. It specifies the project name to use to run the containers.
    Therefore, both the `catalog_api` and `catalog_db` containers will run under the
    same project, called `store`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMPOSE_PROJECT_NAME`变量是Docker提供的`docker-compose`命令的保留变量。它指定了运行容器时要使用的项目名称。因此，`catalog_api`和`catalog_db`容器都将运行在同一个名为`store`的项目下。'
- en: Defining the Dockerfile
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Dockerfile
- en: 'Let''s proceed by describing the Dockerfile of our compose project. As mentioned
    previously, the Dockerfile is a simple text file that contains the commands a
    user could call to assemble an image. Let''s examine a possible definition of
    the Dockerfile contained in the `containers/api/` folder:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述我们的compose项目的Dockerfile来继续。如前所述，Dockerfile是一个简单的文本文件，其中包含用户可以调用的命令来构建镜像。让我们检查`containers/api/`文件夹中可能包含的Dockerfile的定义：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code defines specific steps to build the Docker image. The `FROM` directive
    refers to the base image to use during the build process. This directive is mandatory,
    and it must be the first instruction of the file. The `COPY` directive copies
    the project into the `/app` folder, and the `WORKDIR` command sets the `/app`
    folder as the default working directory. After that, the build script proceeds
    by executing the `dotnet restore` and `dotnet build` commands. Finally, the Dockerfile
    adds the `/root/.dotnet/tools` path inside the `PATH` variable and executes the
    `containers/api/entrypoint.sh` Bash file, which has the following content:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了构建Docker镜像的特定步骤。`FROM`指令指明了构建过程中要使用的基镜像。此指令是强制性的，并且必须是文件的第一条指令。`COPY`指令将项目复制到`/app`文件夹，`WORKDIR`命令将`/app`文件夹设置为默认工作目录。之后，构建脚本通过执行`dotnet
    restore`和`dotnet build`命令继续进行。最后，Dockerfile在`PATH`变量中添加了`/root/.dotnet/tools`路径，并执行了`containers/api/entrypoint.sh`Bash文件，其内容如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `entrypoint.sh` entry point file is stored on the same level as the Dockerfile.
    It runs the main project of the catalog service by performing the `dotnet run`
    command and, once the database container is ready, it proceeds by executing the
    `dotnet ef database update` command to create the database schema.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`entrypoint.sh`入口点文件存储在与Dockerfile相同的级别。它通过执行`dotnet run`命令运行目录服务的主要项目，一旦数据库容器准备就绪，它将继续执行`dotnet
    ef database update`命令以创建数据库模式。'
- en: Executing the docker-compose command
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行docker-compose命令
- en: To run the catalog service locally, we must complete the compose process from
    the CLI using the `docker-compose` command. It is possible to get an overview
    of the commands by running `docker-compose --help`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行目录服务，我们必须使用`docker-compose`命令从CLI完成组合过程。可以通过运行`docker-compose --help`来获取命令的概述。
- en: 'The main commands related to the composition of a multi-container application
    are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与多容器应用组合相关的命令如下：
- en: '`docker-compose build`: This builds the services. It executes the build using
    the Dockerfile associated with the images.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose build`: 这构建服务。它使用与镜像关联的Dockerfile执行构建。'
- en: '`docker-compose images`: This lists the current container images.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose images`: 这列出了当前容器镜像。'
- en: '`docker-compose up`: This creates and runs the containers.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose up`: 这创建并运行容器。'
- en: '`docker-compose config`: This validates and views the `docker-compose.yml`
    file.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose config`: 这验证并查看`docker-compose.yml`文件。'
- en: 'We can proceed by running the catalog service using the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令运行目录服务：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By specifying the `--build` flag, it is possible to trigger the build before
    running the containers. Once the build is made, we can just run the `docker-compose
    up` command until our code changes and we need to rebuild the project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`--build`标志，可以在运行容器之前触发构建。一旦构建完成，我们只需运行`docker-compose up`命令，直到我们的代码更改并需要重新构建项目。
- en: 'Although we are now able to run our service using containers, the build and
    run process is not optimized: we are copying all of the files in the solution
    into the container; on top of that, we are running the container using the whole
    SDK of .NET Core, which is not needed if we want to run the project. In the next
    section, we will see how to optimize the containerization process to be more lightweight.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在能够使用容器运行我们的服务，但构建和运行过程尚未优化：我们将解决方案中的所有文件都复制到容器中；除此之外，我们还在整个.NET Core SDK上运行容器，如果我们只想运行项目，这是不必要的。在下一节中，我们将看到如何优化容器化过程以使其更轻量。
- en: Optimizing Docker images
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Docker镜像
- en: Microsoft provides different Docker images to run ASP.NET Core, and, in general,
    .NET Core applications using Docker. It is essential to understand that a container
    that executes an ASP.NET Core service doesn't need to provide the SDK as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了不同的Docker镜像来运行ASP.NET Core以及使用Docker的.NET Core应用程序。重要的是要理解，执行ASP.NET Core服务的容器不需要提供SDK。
- en: This section presents an overview of the different Docker images available on
    Docker Hub and how to optimize our deployment using proper Docker images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了Docker Hub上可用的不同Docker镜像以及如何使用合适的Docker镜像优化我们的部署。
- en: An overview of different Docker images
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同Docker镜像概述
- en: 'Microsoft provides various images, depending on what it is you''re trying to
    achieve with your application. Let''s take a look at the different Docker images
    supplied in the `microsoft/dotnet` repository in Docker Hub ([https://hub.docker.com/u/microsoft/](https://hub.docker.com/r/microsoft/dotnet/)):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微软根据您尝试通过应用程序实现的目标提供各种镜像。让我们看看 Docker Hub 中 `microsoft/dotnet` 仓库提供的不同 Docker
    镜像（[https://hub.docker.com/u/microsoft/](https://hub.docker.com/r/microsoft/dotnet/))）：
- en: '| **Image** | **Description** | **Size** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **图像** | **描述** | **大小** |'
- en: '| `mcr.microsoft.com/dotnet/core/sdk:3.1` | This image contains the whole SDK
    of .NET Core. It provides all of the tools to develop, run, and build your application.
    It is possible to use development commands such as `dotnet run`, `dotnet ef`,
    and the whole set of commands provided by the SDK. | 690 MB |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `mcr.microsoft.com/dotnet/core/sdk:3.1` | 此镜像包含整个 .NET Core SDK。它提供了所有开发、运行和构建应用程序的工具。可以使用开发命令，如
    `dotnet run`、`dotnet ef` 以及 SDK 提供的整套命令。 | 690 MB |'
- en: '| `mcr.microsoft.com/dotnet/core/runtime:3.1` | This image contains the .NET
    Core runtime. It provides a way to run .NET Core applications, such as console
    applications. Since the image contains only the runtime, it is not possible to
    build the application. The image exposes only the runtime CLI command, `dotnet`.
    | 190 MB |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `mcr.microsoft.com/dotnet/core/runtime:3.1` | 此镜像包含 .NET Core 运行时。它提供了一种运行
    .NET Core 应用程序（如控制台应用程序）的方式。由于镜像仅包含运行时，因此无法构建应用程序。该镜像仅暴露运行时 CLI 命令 `dotnet`。 |
    190 MB |'
- en: '| `mcr.microsoft.com/dotnet/core/aspnet:3.1` | This image contains the .NET
    Core runtime and the ASP.NET Core runtime. It is possible to execute both the
    .NET Core application and the ASP.NET Core application. As a runtime image, it
    is not possible to build the application. | 205 MB |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `mcr.microsoft.com/dotnet/core/aspnet:3.1` | 此镜像包含 .NET Core 运行时和 ASP.NET
    Core 运行时。可以执行 .NET Core 应用程序和 ASP.NET Core 应用程序。作为一个运行时镜像，无法构建应用程序。 | 205 MB |'
- en: '| `mcr.microsoft.com/dotnet/core/runtime-deps:3.1` | This image is a very light
    one. It contains only the lower-level dependencies ([https://github.com/dotnet/core/blob/master/Documentation/prereqs.md](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md))
    that .NET Core needs to run. It doesn''t contain the .NET Core runtime or the
    ASP.NET Core runtime. It is designed for self-hosted applications. | 110 MB |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `mcr.microsoft.com/dotnet/core/runtime-deps:3.1` | 此镜像非常轻量。它仅包含 .NET Core
    运行所需的底层依赖项（[https://github.com/dotnet/core/blob/master/Documentation/prereqs.md](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)）。它不包含
    .NET Core 运行时或 ASP.NET Core 运行时。它旨在用于自托管应用程序。 | 110 MB |'
- en: 'Docker images are usually available in three modes: *debian:stretch-slim*,
    *ubuntu:bionic*, and *alpine*, depending on the OS the image runs on. By default,
    images run on the DebianOS. It is possible, however, to use another OS, such as
    *Alpine*, to save some storage. For example, Alpine-based images reduce the size
    of the `aspnetcore-runtime` image from ~260 MB to ~160 MB.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像通常以三种模式可用：*debian:stretch-slim*、*ubuntu:bionic* 和 *alpine*，具体取决于镜像运行的操作系统。默认情况下，镜像运行在
    DebianOS 上。然而，也可以使用其他操作系统，例如 *Alpine* 来节省一些存储空间。例如，基于 Alpine 的镜像将 `aspnetcore-runtime`
    镜像的大小从 ~260 MB 减少到 ~160 MB。
- en: Multi-stage builds on the catalog service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录服务上的多阶段构建
- en: Let's apply the concept of a *multi-stage* build to the previously defined Docker
    image. Multi-stage builds are a new feature that requires Docker 17.05 or higher.
    Multi-stage builds are useful for anyone who has struggled to optimize Dockerfiles
    while keeping them easy to read and maintain.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 *多阶段* 构建的概念应用到之前定义的 Docker 镜像上。多阶段构建是 Docker 17.05 或更高版本的新功能。多阶段构建对于在保持
    Dockerfile 易读和易于维护的同时优化 Dockerfile 的人来说非常有用。
- en: 'Let''s explore how it is possible to apply the multi-stage build process by
    taking a look at the catalog service Dockerfile:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看目录服务 Dockerfile 来探索如何应用多阶段构建过程：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previously defined file can be changed in the following way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以下方式更改之前定义的文件：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the Dockerfile now executes three different steps (the first
    two steps are described together because they use the same Docker image):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Dockerfile 现在执行了三个不同的步骤（前两个步骤一起描述，因为它们使用相同的 Docker 镜像）：
- en: The `builder` step uses the `mcr.microsoft.com/dotnet/core/sdk` image to copy
    the files and trigger the build of the project using the `dotnet build` command.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder` 步骤使用 `mcr.microsoft.com/dotnet/core/sdk` 镜像来复制文件，并使用 `dotnet build`
    命令触发项目的构建。'
- en: The `publish` step uses the same image to trigger the `dotnet publish` command
    for the `Catalog.API` project.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish` 步骤使用相同的镜像来触发 `dotnet publish` 命令，用于 `Catalog.API` 项目。'
- en: The `final` step, as the name suggests, executes the published package in the
    runtime environment using the `mcr.microsoft.com/dotnet/core/aspnet:3.1` image.
    Finally, it runs the service using the `ENTRYPOINT` command.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如其名所示，`final` 步骤使用 `mcr.microsoft.com/dotnet/core/aspnet:3.1` 镜像在运行时环境中执行已发布的包。最后，它使用
    `ENTRYPOINT` 命令运行服务。
- en: It is important to note that this change optimizes the resulting image produced
    by the Dockerfile. After this change, we don't need the `entrypoint.sh` file anymore
    because the Dockerfile directly triggers the execution of the service using the
    `dotnet Catalog.API.dll` command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个更改优化了由 Dockerfile 生成的最终镜像。在此更改之后，我们不再需要 `entrypoint.sh` 文件，因为 Dockerfile
    直接使用 `dotnet Catalog.API.dll` 命令触发服务的执行。
- en: 'Using a multi-stage build approach, we should also notice that we cannot trigger
    the execution of the database migrations because the runtime Docker image doesn''t
    use the **Entity Framework Core** (**EF Core**) tools. Consequently, we need to
    find another way to trigger the migrations. One possible option is to unleash
    the migrations from the `Startup` file of our service. Furthermore, EF Core provides
    a way to apply migrations at runtime by using the following syntax in the `Configure`
    method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多阶段构建方法时，我们还应该注意到，我们不能触发数据库迁移的执行，因为运行时 Docker 镜像不使用 **Entity Framework Core**
    （**EF Core**） 工具。因此，我们需要找到另一种触发迁移的方法。一个可能的选择是从我们服务的 `Startup` 文件中释放迁移。此外，EF Core
    提供了一种在 `Configure` 方法中使用以下语法在运行时应用迁移的方法：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code ensures the execution of the database migrations through
    the execution of the `app.ApplicationServices.GetService<CatalogContext>().Database.Migrate()`
    instruction. Because of the startup times of the `msssql` container, we need to
    implement a retry policy by handling `SqlException` and retrying with an exponential
    time approach. The preceding implementation uses `Polly` to define and execute
    a retry policy. Furthermore, we need to add the `Polly` dependency by executing
    the following command in the `Catalog.API` project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码确保通过执行 `app.ApplicationServices.GetService<CatalogContext>().Database.Migrate()`
    指令来执行数据库迁移。由于 `msssql` 容器的启动时间，我们需要通过处理 `SqlException` 并采用指数时间方法重试来实现重试策略。前面的实现使用
    `Polly` 来定义和执行重试策略。此外，我们还需要通过在 `Catalog.API` 项目中执行以下命令来添加 `Polly` 依赖项：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Retry policies are really useful in the distributed systems world, to successfully
    handle failure. `Polly` and the implementation of resilience policies in a web
    service will be discussed in the next chapter as part of communication over HTTP
    between multiple services.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重试策略在分布式系统世界中非常有用，可以成功处理失败。`Polly` 和在 Web 服务中实现弹性策略将在下一章中作为多个服务之间通过 HTTP 通信的一部分进行讨论。
- en: In a real-world application, it is quite unusual to execute migrations during
    the deployment phase of the service. The database schema rarely changes, and it
    is essential to separate the implementations related to the service with the changes
    made in the database schema. For demonstration reasons, we are executing the migrations
    of the database in every deployment by overwriting the database changes to take
    the most straightforward approach.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，在服务的部署阶段执行迁移是非常不寻常的。数据库模式很少改变，将与服务相关的实现与数据库模式中的更改分开是至关重要的。出于演示目的，我们通过覆盖数据库更改以采取最直接的方法，在每次部署中都执行数据库的迁移。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided a quick overview of the capabilities of Docker
    and how to use it to improve isolation, maintainability, and service reliability.
    We looked at the different Docker images supplied by Microsoft and how to use
    them combined with a multi-step build approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速概述了 Docker 的功能以及如何使用它来提高隔离性、可维护性和服务可靠性。我们探讨了 Microsoft 提供的不同 Docker
    镜像以及如何结合多步骤构建方法使用它们。
- en: The topics covered in this chapter provide an easy way to run our service locally,
    in an isolated environment, and spread the same environment configuration into
    staging and production environments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题提供了一个简单的方法来在本地、隔离的环境中运行我们的服务，并将相同的环境配置传播到预发布和生产环境中。
- en: In the next chapter, we are going to improve our knowledge of how to share information
    between multiple services. We will also explore some patterns to do with multi-service
    systems. The concepts related to Docker that we explored in this chapter will
    also be used in the next chapter to provide a smooth deployment experience.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提升如何在多个服务之间共享信息的知识。我们还将探讨一些与多服务系统相关的模式。本章中我们探讨的与Docker相关的概念也将在下一章中应用，以提供顺畅的部署体验。
