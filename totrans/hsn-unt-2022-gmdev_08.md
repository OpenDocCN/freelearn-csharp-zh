# 8

# 胜利和失败条件

现在我们已经有一个基本的游戏体验，是时候让游戏以胜利或失败的结果结束。一种常见的实现方式是通过具有监督一组对象以检测需要发生的情况的责任的独立组件，例如玩家生命值为 0 或所有波次都被清除。我们将通过**管理器**的概念来实现这一点，这些组件将管理和监控多个对象。

在本章中，我们将探讨以下管理器概念：

+   创建对象管理器

+   创建游戏模式

+   使用事件改进我们的代码

带着这些知识，你不仅能够创建游戏的胜利和失败条件，而且还能以正确的方式使用设计模式如**单例**和**事件监听器**来做到这一点。这些技能不仅对创建游戏的胜利和失败代码有用，而且对任何代码都很有用。首先，让我们从创建代表如分数或游戏规则等概念的管理器开始。

# 创建对象管理器

并非场景中的每个对象都应该是可以被看到、听到或与之碰撞的。一些对象也可以存在概念意义，而不是有形的东西。例如，想象你需要计算敌人的数量：你将把它保存在哪里？你还需要一个地方来保存玩家的当前分数，你可能认为它可以在玩家本身上，但如果玩家死亡并重生会发生什么呢？

数据将会丢失！在这种情况下，**管理器**的概念可以是我们最初游戏中解决问题的有用方式，让我们来探索一下。

在本节中，我们将看到以下对象管理器概念：

+   使用单例设计模式共享变量

+   在视觉脚本中共享变量

+   创建管理器

我们将首先讨论单例设计模式是什么以及它如何帮助我们简化对象的通信。有了它，我们将创建管理对象，使我们能够集中管理一组对象的信息，以及其他事情。让我们先从讨论单例设计模式开始。

## 使用单例设计模式共享变量

设计模式通常被描述为对常见问题的常见解决方案。在编写游戏代码时，你将不得不做出几个编码设计决策，但幸运的是，处理最常见情况的方法是众所周知的，并且有详细的文档。在本节中，我们将讨论最常见的设计模式之一，**单例**，它在简单项目中易于实现。

单例模式用于需要对象单个实例的情况，这意味着一个类不应该有多个实例，并且我们希望它易于访问（虽然不一定是必需的，但在我们的场景中很有用）。在我们的游戏中有很多情况可以应用这种模式，例如，`ScoreManager`，一个将保存当前得分的组件。在这种情况下，我们永远不会有多于一个的得分，因此我们可以利用单例管理器的优势。

一个好处是确保我们不会有重复的得分，这使我们的代码更不容易出错。此外，到目前为止，我们需要创建公共引用并通过编辑器拖动对象来连接两个对象，或者使用`GetComponent`来查找它们；然而，使用这种模式，我们将能够全局访问我们的单例组件，这意味着你只需在脚本中写下组件的名称，就可以访问它。最终，只有一个`ScoreManager`组件，所以通过编辑器指定哪一个是没有必要的。这类似于`Time.deltaTime`，负责管理时间的类——我们只有一个时间。

如果你是一个高级程序员，你现在可能正在考虑代码测试和依赖注入，你是对的，但请记住，我们到目前为止一直在尝试编写简单的代码，所以我们将坚持这个简单的解决方案。

让我们创建一个**得分管理器**对象，负责处理得分，以下是如何通过单例的示例：

1.  创建一个空的 GameObject（**GameObject | 创建空对象**），并将其命名为`ScoreManager`；通常，管理器被放在空对象中，与场景中的其他对象分开。

1.  将名为`ScoreManager`的脚本添加到该对象中，并添加一个名为`amount`的`int`字段，该字段将保存当前得分。

1.  添加一个名为`instance`的`ScoreManager`类型的字段，但向它添加`static`关键字；这将使变量全局，意味着只需写下它的名称就可以在任何地方访问它：

![](img/B18585_08_01.png)

图 8.1：一个可以在代码的任何地方访问的静态字段

1.  在`Awake`方法中，检查`instance`字段是否不为`null`，如果是，则使用`this`引用将该`ScoreManager`实例设置为实例引用。

1.  在`null`检查`if`语句的`else`子句中，打印一条消息，指出存在第二个`ScoreManager`实例，该实例必须被销毁：

![](img/B18585_08_02.png)

图 8.2：检查是否只有一个单例实例

策略是将对唯一的 `ScoreManager` 实例的引用保存在实例静态字段中，但如果用户不小心创建了两个具有 `ScoreManager` 组件的对象，这个 `if` 语句将检测到它，并通知用户错误，要求他们采取行动。在这种情况下，首先执行 `Awake` 的 `ScoreManager` 实例会发现没有设置实例（字段是 `null`），因此它会将自己设置为当前实例，而第二个 `ScoreManager` 实例会发现实例已经设置，并打印出消息。

记住，`instance` 是一个静态字段，在所有类之间共享，与常规引用字段不同，每个组件将有自己的引用，因此在这种情况下，我们向场景中添加了两个 `ScoreManager` 实例，它们将共享相同的实例字段。

为了稍微改进一下示例，最好有一种简单的方法来在游戏中找到第二个 `ScoreManager`。它将隐藏在 Hierarchy 的某个地方，可能很难找到，但我们通过以下方式解决这个问题：

1.  将 `print` 替换为 `Debug.Log`。`Debug.Log` 与 `print` 类似，但它有一个期望在控制台中点击消息时突出显示对象的第二个参数。在这种情况下，我们将传递 `gameObject` 引用，以便控制台突出显示复制的对象：

![](img/B18585_08_03.png)

图 8.3：使用 Debug.Log 在控制台打印消息

点击日志消息后，包含复制的 `ScoreManager` 的 GameObject 将在 Hierarchy 中突出显示：

![](img/B18585_08_04.png)

图 8.4：点击消息后突出显示的对象

1.  最后，可以通过将 `Debug.Log` 替换为 `Debug.LogError` 来在这里进行一点小小的改进，这将打印出消息，但会显示一个错误图标。在实际游戏中，控制台会有很多消息，通过突出显示错误信息而不是信息消息，可以帮助我们快速识别它们：

![](img/B18585_08_05.png)

图 8.5：使用 LogError 打印错误消息

1.  尝试运行代码并观察控制台中的错误消息：

![](img/B18585_08_06.png)

图 8.6：控制台中的错误消息

下一步是在某个地方使用这个 Singleton，所以在这种情况下，我们将通过以下方式让敌人被击杀时获得分数：

1.  将名为 `ScoreOnDeath` 的脚本添加到 `Enemy` 预制件中，其中包含一个名为 `amount` 的 `int` 字段，该字段将指示敌人被击杀时将获得的分数。请记住，在编辑器中将值设置为非 `0`，以便为预制件设置。

1.  创建 `OnDestroy` 事件函数，当此对象被销毁时，Unity 将自动调用此函数，在我们的例子中，是敌人：

![](img/B18585_08_07.png)

图 8.7：OnDestroy 事件函数

请注意，当我们在更改场景或游戏退出时，`OnDestroy` 函数也会被调用，因此在这种情况下，我们可能会在更改场景时获得分数，这是不正确的。到目前为止，在我们的案例中这不是问题，但稍后在本章中，我们将看到一种防止这种情况的方法。

1.  在 `OnDestroy` 函数中通过编写 `ScoreManager.instance` 来访问单例引用，并将我们脚本的 `amount` 字段添加到单例的 `amount` 字段中，以便在敌人被击杀时增加分数：

![图片](img/B18585_08_08.png)

图 8.8：完整的 ScoreOnDeath 组件类内容

1.  在层级中选择 `ScoreManager`，点击 **播放**，然后消灭一些敌人以查看分数随着每次击杀而上升。请记住设置 Prefab 中 `ScoreOnDeath` 组件的 `amount` 字段。

如您所见，单例模式简化了访问 `ScoreManager` 的方式，并采取了安全措施以防止其自身的重复，这将有助于我们减少代码中的错误。需要注意的是，现在您可能会倾向于将一切事物都做成单例，例如玩家的生命或玩家的子弹，以便在创建游戏机制如升级时使生活变得更简单。

虽然这完全可行，但请记住，您的游戏将会发生变化，我的意思是变化会很大；任何真实的项目都会经历不断的变更。也许今天，游戏只有一个玩家，但也许在未来，您想添加第二个玩家或人工智能同伴，并且希望升级能够影响他们，所以如果您过度使用单例模式，您将难以处理这些场景以及更多的情况。也许未来的玩家同伴会尝试获取生命恢复物品，但主要玩家却被治愈了！

这里的关键是尽量少使用这种模式，除非您没有其他方法来解决问题。说实话，总有办法在不使用单例的情况下解决问题，但它们对初学者来说实施起来要困难一些，所以我更喜欢简化您的生活，让您保持动力。随着足够的练习，您将达到一个可以准备好提高您的编码标准的阶段。

现在，让我们讨论如何在 Visual Scripting 中实现这一点，鉴于它会有所不同，它值得拥有自己的部分。如果您对 Visual Scripting 方面不感兴趣，可以考虑跳过下面的部分。

## 使用 Visual Scripting 共享变量

视觉脚本有一个机制，用**场景变量**取代单例作为对象间共享变量的持有者：**场景变量**。如果你检查**脚本图**编辑器（我们编辑脚本节点窗口）中的左侧面板（显示我们对象变量的面板），你会注意到它将有许多标签页：**图**、**对象**、**场景**、**应用**和**已保存**。如果你看不到**黑板**面板，点击窗口左上角从左数第三个按钮，即**i**（信息）按钮右侧的按钮：

![图片](img/B18585_08_09.png)

图 8.9：脚本图（变量）编辑器

到目前为止，当我们在任何对象的**变量**组件中创建一个变量时，我们实际上是在创建**对象变量**：属于对象的变量，在同一个对象的所有视觉脚本之间共享，但变量可以拥有的作用域不止这一种。以下是一个剩余作用域的列表：

+   **图**：只能由我们当前图访问的变量。其他脚本不能读取或写入该变量。这有助于保存内部状态，如 C#中的私有变量。

+   **场景**：可以被当前场景中所有对象访问的变量。当我们更改场景时，这些变量就会丢失。

+   **应用**：可以在游戏的任何部分任何时间访问的变量。这有助于将值从一个场景移动到另一个场景。例如，你可以在一个级别中增加分数，并在下一个级别中继续增加，而不是从 0 重新开始分数。

+   **已保存**：在游戏运行之间保持其值的变量。你可以保存持久数据，如**玩家等级**或**库存**以继续任务，或者更简单的事情，如用户在**选项**菜单中设置的音量（如果你创建了一个）。

在这种情况下，**场景**作用域是我们想要的，因为我们打算增加的分数将被场景中的多个对象访问（关于这一点稍后讨论），我们不希望它在重置级别以再次播放时持续存在；它需要在每个级别的每次运行和游戏中重新设置为 0。

要创建场景变量，你可以在编辑任何**脚本图**时，简单地选择**黑板**面板中的**场景**标签页，或者你也可以使用当你开始编辑任何图时自动创建的**场景变量**GameObject。这个对象是真正持有变量的那个，不能被删除。你会注意到它将有一个**变量**组件，就像我们之前使用的那样，但它还将有一个**场景****变量**组件，表示这些变量是场景变量。

在以下屏幕截图中，你可以看到我们如何简单地添加了**分数**变量到**场景变量**标签页，使其在我们的任何脚本图中都可以访问。

![图片](img/B18585_08_10.png)

图 8.10：将场景变量添加到我们的游戏中

最后，对于增加分数的行为，我们可以在我们的敌人中添加以下图表。记住，像往常一样，只保留 C#或视觉脚本版本的脚本，不要两者都保留。

![](img/B18585_08_11.png)

图 8.11：当此对象被销毁时增加分数

首先，这个脚本看起来与我们的 C#版本非常相似；我们添加我们的对象`scoreToAdd`变量（**对象**范围）并将其添加到节点中指定的整个场景的`score`变量中。您可以看到的主要区别是，这里我们使用的是**OnDisable**事件而不是**OnDestroy**。实际上，**OnDestroy**是正确的选择，但在当前版本的视觉脚本中存在一个错误，阻止它正常工作，所以我暂时替换了它。**OnDisable**的问题在于它会在对象被禁用时执行，而对象在被销毁之前可能被禁用，也可能在其他情况下被禁用（例如，使用**Object Pooling**，这是一种回收对象而不是不断销毁和实例化对象的方法），但到目前为止这对我们来说已经足够了。请在尝试此图表时首先考虑使用**OnDestroy**，以查看它是否在您的 Unity 或视觉脚本包版本中正常运行。

需要强调的是，使用**Has Variable**节点来检查**分数变量**是否存在。这样做是因为**OnDisable**可以在敌人被销毁的瞬间执行，或者当场景改变时执行，我们将在本章后面的内容中通过输赢屏幕来实现这一点。如果我们试图在那个时刻获取场景变量，由于场景变化涉及首先销毁场景中的每个对象，我们可能会在**GameMode**对象之前销毁**Scene Variables**对象，从而风险自己遇到错误。

如您现在可能已经注意到的，尽管视觉脚本（Visual Scripting）在大多数情况下与 C#非常相似，但有一种概念可以解决另一种无法解决的问题。现在我们知道了如何共享变量，让我们完成一些我们在游戏后期需要的其他管理器。

## 创建管理器

有时候，我们需要一个地方来汇总一组相似对象的信息，例如，`EnemyManager`，用于检查敌人的数量，并可能访问它们的数组以遍历并执行某些操作，或者可能是`MissionManager`，以便访问我们游戏中的所有活动任务。再次强调，这些情况可以被视为单例（Singletons），即不会重复出现的单个对象（在我们的当前游戏设计中），因此让我们创建我们在游戏中需要的那些，即`EnemyManager`和`WaveManager`。

在我们的游戏中，`EnemyManager`和`WaveManager`将仅用作保存现有敌人和波次的引用数组的存储位置，就像知道它们当前数量的方式一样。有方法可以搜索特定类型的所有对象来计算它们的数量，但这些函数成本高昂，除非你真的知道你在做什么，否则不建议使用。因此，拥有一个具有单独更新目标对象类型引用列表的单例将需要更多的代码，但性能会更好。此外，随着游戏功能的增加，这些管理器将具有更多功能以及与这些对象交互的帮助函数。

让我们从敌人管理器开始，执行以下操作：

1.  向**Enemy**预设件添加一个名为`Enemy`的脚本；这将是一个将此对象与`EnemyManager`连接的脚本。

1.  创建一个名为`EnemyManager`的空`GameObject`，并向其添加一个名为`EnemiesManager`的脚本。

1.  在脚本内部创建一个名为`instance`的`public`静态字段，类型为`EnemiesManager`，并在`Awake`中添加单例重复检查，就像我们在`ScoreManager`中做的那样。

1.  创建一个名为`enemies`的公共字段，类型为`List<Enemy>`：

![](img/B18585_08_12.png)

图 8.12：敌人组件列表

C#中的列表表示一个动态数组，一个能够添加和删除对象的数组。你会在编辑器中看到你可以向此列表添加和删除元素，但请保持列表为空；我们将以另一种方式添加敌人。请注意，`List`位于`System.Collections.Generic`命名空间中；你将在我们脚本的开始处找到`using`语句。此外，考虑到你可以将列表设置为私有，并通过 getter 而不是公共字段将其暴露给代码；但像往常一样，我们现在将使代码尽可能简单：

![](img/B18585_08_13.png)

图 8.13：使用 List 类所需的 using 语句

考虑到`List`是一个类类型，因此必须实例化，但由于此类型在编辑器中具有暴露支持，Unity 将自动实例化它。如果你想要一个非编辑器暴露的列表，如私有列表或常规非组件 C#类中的列表，你必须使用`new`关键字来实例化它。

C#中的列表在内部实现为一个数组。如果你需要一个链表，请使用`LinkedList`集合类型代替。

1.  在`Enemy`脚本的`Start`函数中，访问`EnemyManager`单例，并使用敌人列表的`Add`函数，将此对象添加到列表中。这将“注册”此敌人在管理器中的活动状态，以便其他对象可以访问管理器并检查当前敌人。`Start`函数在所有`Awake`函数调用之后被调用，这很重要，因为我们需要确保在敌人`Start`函数之前执行管理器的`Awake`函数，以确保已设置管理器实例。

我们用`Start`函数解决的问题被称为竞态条件，即当两段代码不能保证按相同顺序执行时，而`Awake`的执行顺序可能会因不同原因而改变。代码中有很多情况都会发生这种情况，所以请注意你代码中可能存在的竞态条件。此外，你可能考虑在这里使用更高级的解决方案，如`懒初始化`，这可以给你更好的稳定性，但为了简单起见，以及探索 Unity API，我们目前将使用`Start`函数的方法。

1.  在`OnDestroy`函数中，从列表中移除敌人以保持列表只更新活跃的敌人：

![图片](img/B18585_08_14.png)

图 8.14：注册为我们自己的活跃敌人的敌人脚本

通过这种方式，我们现在有一个集中的地方可以以简单而有效的方式访问所有活跃的敌人。我挑战你使用`WaveManager`以同样的方式来做，这将有一个所有活跃波浪的集合，以便稍后检查是否所有波浪都完成了它们的工作，以考虑游戏胜利。花些时间解决这个问题；你将在下面的截图中发现解决方案，从`WavesManager`开始：

![图片](img/B18585_08_15.png)

图 8.15：完整的 WavesManager 脚本

你还需要`WaveSpawner`脚本：

![图片](img/B18585_08_16.png)

图 8.16：支持 WavesManager 的修改后的 WaveSpawner 脚本

如你所见，`WaveManager`的创建方式与`EnemyManager`相同，只是一个带有`WaveSpawner`引用列表的单例，但`WaveSpawner`是不同的。我们在`WaveSpawner`的`Start`事件中执行列表的`Add`函数来注册波浪为活跃波浪，但`Remove`函数需要做更多的工作。

策略是在生成器完成工作后从活跃波浪列表中注销波浪。在这次修改之前，我们使用`Invoke`在一段时间后调用`CancelInvoke`函数来停止生成，但现在我们需要在结束时间之后做更多的事情。

而不是在指定的波浪结束时间后调用`CancelInvoke`，我们将调用一个名为`EndSpawner`的自定义函数，该函数将调用`CancelInvoke`来停止生成器，`Invoke Repeating`，同时还会调用从`WavesManager`列表中移除的函数，以确保在`WaveSpawner`完成其工作的时候正好调用移除列表的函数。

关于视觉脚本版本，我们可以在场景变量中添加两个 GameObject 类型的列表来保存现有波浪和敌人的引用，这样我们就可以跟踪它们。只需在变量类型选择器的搜索栏中搜索“GameObject 列表”，你就可以找到它。在这种情况下，由于**WaveSpawner**和敌人脚本的视觉脚本版本不是我们可以像 C#那样引用的类型，所以列表中只包含 GameObject。如果你同时创建了这些脚本的 C#和视觉脚本版本，你会看到你可以引用 C#版本，但我们将不会混合 C#和视觉脚本，因为这超出了本书的范围，所以忽略它们。无论如何，鉴于视觉脚本**变量**系统的工作方式，我们仍然可以使用**获取变量**节点在需要时访问变量内部——记住变量不在视觉脚本中，而是在**变量**节点中：

![图片](img/B18585_08_17.png)

图 8.17：将列表添加到场景变量

然后，我们可以在**WaveSpawner**图表中添加以下内容：

![图片](img/B18585_08_18.png)

图 8.18：向列表中添加元素

我们使用**添加列表项**节点将我们的 GameObject 添加到**波浪**变量中。我们在**On Start**事件节点之前将其作为第一件事来做。要移除这个波浪从活动波浪中，你需要进行以下更改：

![图片](img/B18585_08_19.png)

图 8.19：从列表中移除元素

我们使用**For Loop**的**Exit**流程输出引脚从列表中移除这个生成器，这是在`for`循环完成迭代时执行的。

最后，关于**敌人**，你需要创建一个新的**敌人脚本**图表，其外观将类似：

![图片](img/B18585_08_20.png)

图 8.20：敌人添加和从列表中移除自身

如你所见，我们只是在**OnStart**时添加敌人，在**OnDisable**时移除它。记住，由于我们之前提到的错误，首先尝试使用**OnDestroy**而不是**OnDisable**。你可以通过在**场景变量**GameObject 被选中时玩游戏来检查这些更改，并看到其值如何变化。还要记住，如果我们正在更改场景，需要使用**有变量**节点。

使用对象管理器，我们现在可以集中管理一组对象的信息，并且可以在这里添加各种对象组逻辑。我们创建了`EnemiesManager`、`WavesManager`和`ScoreManager`作为集中存储多个游戏系统信息的中心位置，例如场景中存在的敌人和波浪，以及分数。我们还看到了视觉脚本版本，将数据集中存储在场景变量对象中，这样所有的视觉脚本都可以读取这些数据。但除了为了更新 UI（我们将在下一章中这样做）而拥有这些信息之外，我们还可以使用这些信息来检测我们的游戏是否满足胜利和失败条件，创建一个**游戏模式**对象来检测。

# 创建游戏模式

我们已经创建了对象来模拟游戏中的许多游戏玩法方面，但游戏总需要结束，无论我们赢或输。一如既往，问题是将这种逻辑放在哪里，这引出了更多的问题。主要问题将是，我们是否总是以相同的方式赢或输游戏？我们是否会有一个特殊的关卡，其标准不同于“消灭所有波次”，例如有时间限制的生存？只有你知道这些问题的答案，但如果现在答案是“不”，并不意味着它不会在以后改变，因此建议我们准备代码以无缝适应变化。

说实话，准备代码以无缝适应变化几乎是不可能的；没有一种方法可以考虑到每个可能的情况，我们迟早都需要重写一些代码。我们将尝试使代码尽可能适应变化；总是这样做不会消耗太多开发时间，有时快速编写简单的代码比慢速编写可能不必要的复杂代码更可取，因此我们建议您明智地平衡时间预算。

为了做到这一点，我们将胜利和失败条件的逻辑分离到自己的对象中，我喜欢将其称为“游戏模式”（不一定是行业标准）。这将是一个将监督游戏、检查需要满足的条件以考虑游戏结束的组件。它将像我们游戏中的裁判。游戏模式将不断检查对象管理器中的信息以及可能的其他信息源，以检测所需条件。将此对象与其他对象分离，使我们能够创建具有不同游戏模式的关卡；只需在该关卡中使用另一个游戏模式脚本即可。

在我们这个例子中，我们现在将只有一个游戏模式，它将检查波次和敌人的数量是否变为`0`，这意味着我们已经杀死了所有可能的敌人，游戏胜利。同时，它还将检查玩家的生命值是否达到`0`，在这种情况下，将游戏视为失败。让我们通过以下步骤创建它：

1.  创建一个空的`GameMode`对象，并向其中添加一个`WavesGameMode`脚本。正如你所见，我们给脚本起了一个描述性的名字，考虑到我们可以添加其他游戏模式。

1.  在其`Update`函数中，使用`Enemy`和`Wave`管理器检查敌人波次数量是否达到`0`；在这种情况下，目前只需在控制台`print`一条消息。所有列表都有一个`Count`属性，它将告诉你存储在内部元素的数量。

1.  添加一个名为`PlayerLife`的`public`字段，其类型为`Life`，并将玩家拖到该字段；这里的想法是也要检测失败条件。

1.  在`Update`中，添加另一个检查以检测`playerLife`引用的生命值是否达到`0`，在这种情况下，在控制台`print`一条失败消息：

![图片](img/B18585_08_21.png)

图 8.21：WavesGameMode 中的胜利和失败条件检查

1.  玩游戏并测试两种情况，即玩家生命值是否达到 0，或者你是否已经杀死了所有敌人以及所有波次。

现在，是时候用更有趣的消息替换它们了。目前，我们只是将当前场景更改为**胜利场景**或**失败场景**，这两个场景将只包含带有胜利或失败消息以及一个重新开始按钮的 UI。将来，你可以添加一个主菜单场景，并有一个选项返回到它。让我们通过以下步骤来实现：

1.  创建一个新的场景（**文件 | 新场景**）并保存它，命名为`WinScreen`。

1.  添加一些指示这是胜利场景的东西，比如简单地用一个摄像机指向的球体。这样我们就可以知道何时切换到胜利场景。

1.  在**项目视图**中选择场景，然后按*Ctrl* + *D*（在 Mac 上为*Cmd* + *D*）来复制场景。将其重命名为`LoseScreen`。

1.  双击`LoseScreen`场景以打开它，并将球体更改为其他东西，比如一个立方体。

1.  前往**文件 | 构建设置**以打开此窗口内的**构建中的场景**列表。

理念是 Unity 需要你明确声明所有必须包含在游戏中的场景。你可能有一些测试场景或你不想发布的场景，这就是为什么我们需要这样做。在我们的案例中，我们的游戏将包含`WinScreen`、`LoseScreen`以及我们迄今为止创建的带有游戏场景的场景，我将其称为`Game`，所以只需将这些场景从**项目视图**拖到**构建设置**窗口的列表中；我们需要这样做才能使游戏模式脚本在场景之间正确切换。此外，考虑到列表中的第一个场景将是我们在最终版本（称为构建）中玩游戏时首先打开的场景，所以你可能想要根据这一点重新排列列表：

![](img/B18585_08_22.png)

图 8.22：将场景注册到游戏的构建中

1.  在`WavesGameMode`中添加对`UnityEngine.SceneManagement`命名空间的`using`语句，以启用此脚本中的场景更改功能。

1.  将控制台`print`消息替换为调用`SceneManager.LoadScene`函数的调用，该函数将接收一个包含要加载的场景名称的字符串；在这种情况下，将是`WinScreen`和`LoseScreen`。你只需要场景名称，而不需要文件的完整路径。

如果你想链接不同的层级，你可以创建一个`public`字符串字段，以便你通过编辑器指定要加载的场景。记住将场景添加到**构建设置**中，否则，当你尝试更改场景时，控制台将显示错误信息：

![](img/B18585_08_23.png)

图 8.23：使用 SceneManager 更改场景

1.  玩游戏并检查场景是否正确更改。

目前，我们选择了最简单的方式来显示我们输赢的状态，但将来，你可能想要比场景突然变化更柔和的方式，比如使用`Invoke`等待几秒钟来延迟变化，或者直接在游戏中显示获胜信息而不改变场景。在测试游戏并检查玩家在玩游戏时是否理解发生了什么时，请记住这一点——游戏反馈对于让玩家了解正在发生的事情非常重要，并且这不是一个容易解决的问题。

关于视觉脚本版本，我们在一个分离的对象中添加了一个新的脚本图。让我们逐个检查它，以便更清楚地了解它。让我们从胜利条件开始：

![图片](img/B18585_08_24.png)

图 8.24：在视觉脚本中的胜利条件

在这里，我们从场景上下文中获取**敌人**列表（**获取变量**节点），并且知道它包含一个列表，所以我们使用**计数项**节点来检查这个列表中剩余多少敌人。记住，我们有一个脚本在敌人被生成时将其添加到列表中，在它被销毁时将其移除。我们对波次也做同样的处理，所以将条件与**与**节点组合，并通过**如果**节点连接，然后执行某些操作（更多内容将在稍后讨论）。

现在我们来检查失败条件：

![图片](img/B18585_08_25.png)

图 8.25：视觉脚本中的失败条件

由于玩家的生命值不在场景上下文中（也不应该），而且玩家是一个与名为`GameMode`的对象不同的 GameObject（我们专门为这个脚本创建的），我们需要一个类型为 GameObject 的变量**player**来引用它。

如您所见，我们在**变量**组件中将我们的玩家拖拽到它上面。最后，我们使用**获取变量**来访问图中的玩家引用，然后使用另一个**获取变量**来提取生命值。我们通过将玩家引用连接到生命变量的**获取变量**节点来实现这一点。然后我们对玩家的基础重复这一过程。

最后，我们通过以下步骤加载场景：

![图片](img/B18585_08_26.png)

图 8.26：在视觉脚本中加载场景

如您所见，我们使用**场景管理器加载场景（场景名称）**节点来加载场景。注意我们如何使用后缀`_VisualScripting`来加载场景，因为我们 GitHub 上有两个版本的场景，一个是 C#版本，另一个是视觉脚本版本。

现在我们有一个功能齐全的简单游戏，具有机制和胜负条件，虽然这足以开始开发我们游戏的其它方面，但我想要讨论一下我们当前管理方法中的一些问题以及如何通过事件来解决它们。

# 使用事件改进我们的代码

到目前为止，我们使用了 Unity 事件函数来检测游戏中可能发生的情况，例如`Awake`和`Update`。Unity 还使用其他类似函数来允许组件之间相互通信，例如`OnTriggerEnter`，这是 Rigidbody 通知 GameObject 中的其他组件发生了碰撞的一种方式。在我们的情况下，我们使用`Update`方法中的`if`语句来检测其他组件的变化，例如`GameMode`检查敌人数量是否达到 0。但如果我们从敌人管理器那里得到通知，当某些事情发生变化时，我们可以在那一刻进行检查，例如，用 Rigidbody 告诉我们何时发生碰撞，而不是每帧检查碰撞。

此外，有时我们依赖于 Unity 事件来执行逻辑，例如在`OnDestroy`事件中给出分数，该事件通知我们对象何时被销毁。但由于事件的本性，它可能在我们不希望添加分数的情况下被调用，例如当场景改变或游戏关闭时。在这种情况下，对象会被销毁，但这并不是因为玩家杀死了敌人，导致在不应该增加分数的情况下分数增加。在这种情况下，有一个事件告诉我们生命达到 0 以执行此逻辑，而不是依赖于通用的`OnDestroy`事件会很好。

事件的想法是改进我们对象之间的通信模型，确保在某个事件发生的确切时刻，相关部分被通知并做出相应的反应。Unity 有很多事件，但我们可以创建特定于我们游戏逻辑的事件。让我们先应用我们之前讨论的得分场景；想法是让`Life`组件有一个事件来通知其他组件对象被销毁是因为生命达到 0。

实现这一点有几种方法，我们将使用与`Awake`和`Update`方法略有不同的方法；我们将使用`UnityEvent`字段类型。这是一种字段类型，可以存储在需要执行时执行的函数引用，就像 C#委托一样，但具有其他优点，例如更好的 Unity 编辑器集成。

要实现这一点，请执行以下操作：

1.  在`Life`组件中，创建一个名为`onDeath`的`UnityEvent`类型的`public`字段。这个字段将代表一个事件，其他类可以订阅它，以便在`Life`达到 0 时得到通知：

![](img/B18585_08_27.png)

图 8.27：创建自定义事件字段

1.  如果你保存脚本并进入编辑器，你可以在检查器中看到事件。Unity 事件支持在编辑器中订阅方法，这样我们就可以将两个对象连接起来。我们将在 UI 脚本章节中使用这个功能，所以现在就忽略它：

![](img/B18585_08_28.png)

图 8.28：UnityEvents 在检查器中显示

你可以使用通用委托操作或自定义委托来创建事件，而不是使用`UnityEvent`，除了某些性能方面外，唯一明显的区别是`UnityEvent`将在编辑器中显示，如*步骤 2*所示。

1.  当生命值达到`0`时，调用事件的`Invoke`函数。这样，我们将告诉任何对事件感兴趣的脚本它已经发生：

![](img/B18585_08_29.png)

图 8.29：执行事件

1.  在`ScoreOnDeath`中，将`OnDestroy`函数重命名为`GivePoints`或你喜欢的任何名称；这里的想法是在`OnDestroy`事件中停止给予分数。

1.  在`ScoreOnDeath`脚本的`Awake`函数中，使用`GetComponent`获取`Life`组件并将其保存在局部变量中。

1.  调用`Life`引用的`onDeath`字段的`AddListener`函数，并将`GivePoints`函数作为第一个参数传递。这被称为**订阅**我们的`listener`方法`GivePoints`到事件`onDeath`。想法是告诉`Life`在`onDeath`事件被调用时执行`GivePoints`。这样，`Life`就会通知我们这种情况。记住，你不需要调用`GivePoints`，只需将其作为字段传递即可：

![](img/B18585_08_30.png)

图 8.30：在那种情况下订阅 OnDeath 事件以给予分数

考虑在`OnDestroy`中调用`RemoveListener`；像往常一样，在可能的情况下取消订阅监听器以防止任何内存泄漏（引用阻止 GC 释放内存）是方便的。在这种情况下，这并不是完全必要的，因为`Life`和`ScoreOnDeath`组件将同时被销毁，但尽量养成这种良好的习惯。

1.  保存，在编辑器中选择`ScoreManager`，然后点击**播放**来测试这个功能。尝试在**播放**模式下从层次结构中删除一个敌人，以检查分数是否不会上升，因为敌人被销毁的原因不是他们的生命值变为 0；你必须射击敌人以看到分数增加。

现在，由于`Life`有了`onDeath`事件，我们也可以通过以下步骤将玩家的`Life`检查从`WavesGameMode`替换为使用该事件：

1.  在`WavesGameMode`脚本上创建一个`OnPlayerDied`函数，并将`LoseScreen`场景的加载从`Update`方法移动到这个函数。你将移除检查生命的`if`语句，因为事件版本将替换它。

1.  在`Awake`中，将这个新函数添加到玩家`Life`组件引用的`onDeath`事件中，在我们的脚本中称为`playerLife`：

![](img/B18585_08_31.png)

图 8.31：使用事件检查失败条件

如您所见，创建自定义事件允许您检测比 Unity 中的默认值更具体的情况，并保持您的代码整洁，无需在`Update`函数中不断询问条件，这并不一定是坏事，但事件方法生成更清晰的代码。

记住，我们也可以通过玩家的基础`Life`达到 0 来输掉游戏。因此，让我们创建一个代表敌人将攻击以减少基地`Life`的对象的立方体。考虑到这一点，我挑战你将第二个失败条件（玩家的基础生命达到 0）添加到我们的脚本中。当你完成时，你可以在以下截图中检查解决方案：

![](img/B18585_08_32.png)

图 8.32：完整的 WavesGameMode 失败条件

如您所见，我们只是重复了`life`事件订阅，请记住创建一个对象来表示玩家的基础伤害点，向其添加一个`Life`脚本，并将其拖动作为 Waves 游戏模式的玩家基础`Life`引用。这里有趣的是，我们订阅了名为`OnPlayerOrBaseDied`的相同函数，用于玩家的`Life`和基地`Life`的`onDeath`事件，因为我们希望在这两种情况下得到相同的结果。

现在，让我们通过将其应用于管理器来继续说明这个概念，以防止游戏模式每帧都检查条件：

1.  在`EnemyManager`中添加一个名为`onChanged`的`UnityEvent`字段。这个事件将在敌人被添加或从列表中移除时执行。

1.  创建两个函数，`AddEnemy`和`RemoveEnemy`，都接收一个`Enemy`类型的参数。想法是，而不是让`Enemy`直接从列表中添加和删除自己，它应该使用这些函数。

1.  在这两个函数内部，调用`onChanged`事件来通知其他人敌人列表已被更新。想法是，任何想要从列表中添加或删除敌人的人都需要使用这些函数：

![](img/B18585_08_33.png)

图 8.33：在添加或删除敌人时调用事件

这里，我们没有阻止我们绕过这两个函数并直接使用列表的问题。你可以通过将列表设为私有并使用`IReadOnlyList`接口公开它来解决。记住，这样，列表在编辑器中不可见，以便进行调试。

1.  将`Enemy`脚本更改为使用这些函数：

![](img/B18585_08_34.png)

图 8.34：使敌人使用添加和删除函数

1.  对`WaveManager`和`WaveSpawner`重复相同的过程，创建一个`onChanged`事件，创建`AddWave`和`RemoveWave`函数，并在`WaveSpawner`中调用它们而不是直接访问列表。这样，我们就确保在需要时调用事件，就像我们对`EnemyManager`所做的那样。尝试自己解决这个问题，然后检查以下截图中的解决方案，从`WavesManager`开始：

![](img/B18585_08_35.png)

图 8.35：WaveManager OnChanged 事件实现

1.  此外，`WavesSpawner`也需要以下更改：

![](img/B18585_08_36.png)

图 8.36：实现 AddWave 和 RemoveWave 函数

1.  在`WavesGameMode`中，将`Update`重命名为`CheckWinCondition`，并将其订阅到`EnemyManager`和`WavesManager`的`onChanged`事件。想法是只在必要时检查敌人和波次的数量变化。记住，由于单例在`Awake`中初始化，所以在`Start`函数中订阅事件。 

![](img/B18585_08_37.png)

图 8.37：当敌人或波次数量变化时检查胜利条件

关于视觉脚本版本，让我们从事件开始检查失败条件，首先检查**生命脚本图表**中需要的一些更改：

![](img/B18585_08_38.png)

图 8.38：在我们的生命图表中触发自定义事件

首先，当生命值达到 0 时销毁物体后，我们使用**触发自定义事件**节点，指定事件名称为`OnDeath`。这将告诉所有等待执行`OnDeath`事件的人我们已经执行了。记住，这是我们**生命脚本图表**。在触发事件后务必调用销毁操作——虽然大多数时候顺序并不重要，因为销毁动作实际上是在帧尾发生的，但有时可能会引起问题，所以在这里还是安全为好。在这种情况下，游戏模式应该监听玩家的`OnDeath`事件，所以让我们在我们的**游戏模式图表**中做出以下更改：

![](img/B18585_08_39.png)

图 8.39：在视觉脚本中监听玩家的 OnDeath 事件

我们使用了**自定义事件**节点，将其连接到我们的游戏模式的玩家引用。这样我们指定，如果那个玩家执行该事件，我们将执行**加载场景**节点。记住，玩家引用是至关重要的，因为它指定了我们想从谁那里执行`OnDeath`事件，并且记住**生命视觉图表**也会出现在敌人中，而我们对此不感兴趣。此外，记得移除我们之前用来检测此情况的`If`节点和条件节点——我们的游戏模式将只有一个`If`，那就是胜利条件。

实际上，我们让任何带有`Life`脚本的物体都有一个`OnDeath`事件，并且让游戏模式特别监听玩家的`OnDeath`事件。

我们也可以为敌人和波次做事件，但这会在一定程度上使我们的图表变得复杂，因为我们视觉脚本版本中没有`WaveManager`或`EnemyManager`。我们当然可以创建这些来完成任务，但有时使用视觉脚本的目的就是创建简单的逻辑，这类改变往往会使得图表变得相当庞大。

另一个可能的解决方案是让敌人波直接通知游戏模式。我们可以在敌人和波中使用**触发自定义事件**，将此节点连接到游戏模式，最终让游戏模式拥有一个**自定义事件**节点来监听。问题是这会违反我们对象之间的正确依赖关系；低级对象，如敌人和波，不应该与高级对象，如游戏模式，进行通信。本质上，游戏模式原本应该是一个监管者。如果我们应用本段中描述的解决方案，我们将无法在没有游戏模式的情况下在另一个场景或游戏中拥有敌人。因此，为了简单和代码解耦，让我们保持其他条件不变——更复杂的逻辑，如这个，在完整的生产项目中可能会用 C#来处理。

是的，使用事件意味着我们比以前需要编写更多的代码，从功能的角度来看，我们没有获得任何新的东西，但在更大的项目中，通过`Update`检查来管理条件，正如之前讨论的那样，会导致各种问题，如竞争条件和性能问题。有时，拥有可扩展的代码库需要更多的代码，这就是其中之一。

在我们结束之前，需要考虑的是，Unity 事件不是在 Unity 中创建此类事件通信的唯一方式；你将找到一个类似的方法，称为**Action**，这是事件的本地 C#版本，如果你想要查看所有选项，我建议你了解一下。

# 摘要

在本章中，我们完成了游戏的一个重要部分：无论是胜利还是失败，我们都讨论了通过使用通过单例创建的管理器来分离不同责任层的一种简单但强大的方法，以确保每种类型的经理只有一个实例，并通过静态访问简化它们之间的连接。此外，我们还探讨了事件的概念，以简化对象之间的通信，防止问题并创建更有意义的对象间通信。

带着这些知识，你现在不仅能够检测游戏的胜利和失败条件，而且还能以更好的结构化方式来做。这些模式可以用来改进我们的游戏代码，我建议你在其他相关场景中尝试应用它们。

在下一章中，我们将开始本书的**第三部分**，我们将看到不同的 Unity 系统来改进游戏的图形和音频方面，首先我们将看到如何创建材料来修改对象的一些属性，并使用 Shader Graph 创建着色器。

# 加入我们的 Discord 频道！

与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。

提出问题，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。

扫描二维码或访问链接加入社区。

![尼古拉斯二维码](img/Nicolas_QR_Code.png)

`packt.link/handsonunity22`
