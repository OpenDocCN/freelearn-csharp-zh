- en: Chapter 9. Playing and Manipulating Sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Matching the audio pitch to the animation speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating acoustic environments with Reverb Zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing an Audio Clip from restarting if it is already playing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for audio to finish playing before auto-destructing an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding volume control with Audio Mixers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a dynamic soundtrack with Snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing in-game audio with Ducking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound is a very important part of the gaming experience. In fact, we can't stress
    enough how crucial it is to the player's immersion in a virtual environment. Just
    think of the engine running in your favorite racing game, the distant urban buzz
    in a simulator game, or the creeping noises in horror games. Think of how these
    sounds transport you *into* the game.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting on with the recipes, let's step back and have a quick review
    on how sound works on Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: Audio files can be embedded into GameObjects through the **Audio Source** component.
    Unity supports **3D sounds**, which means that the location and distance between
    the audio sources and **Audio Listener** matter in the way the sound is perceived
    in terms of loudness and the left/right balance. This is unless the audio source
    is specified as **2D sound** (which is usually the case for the background soundtrack
    music).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although all sound is sent to the scene''s **Audio** **Listener** (a component
    that is usually attached to the **Main Camera**, and that shouldn''t be attached
    simultaneously on more than one object), Unity 5 brings a new player to the audio
    scene: the **Audio Mixer**. The Audio mixer radically changes the way in which
    sound elements can be experienced and worked with. It allows developers to mix
    and arrange audio pretty much in the same way that musicians and producers do
    in their **Digital Audio Workstations** (**D.A.W**), such as **GarageBand** or
    **ProTools**. It allows you to route audio source clips into specific channels
    that can have their volumes individually adjusted and processed by customized
    effects and filters. You can work with multiple Audio Mixers, send a mixer''s
    output to a parent mixer, and save mix preferences as **Snapshots**. Also, you
    can access mixer parameters from scripting. The following figure represents the
    main Unity 5 audio mixing concepts and their relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The big picture](img/1362_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking advantage of the new Audio Mixer feature in many example projects, this
    chapter is filled with recipes that will hopefully help you implement a better
    and more efficient sound design for your projects, augmenting the player's sense
    of immersion, transporting him or her into the game environment, and even improving
    the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Matching the audio pitch to the animation speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many artifacts sound higher in pitch when accelerated and lower when slowed
    down. Car engines, fan coolers, Vinyl—a record player… the list goes on. If you
    want to simulate this kind of sound effect in an animated object that can have
    its speed changed dynamically, follow this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need an animated 3D object and an audio clip. Please
    use the files `animatedRocket.fbx` and `engineSound.wav`, available in the `1362_09_01`
    folder of the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To change the pitch of an audio clip according to the speed of an animated
    object, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `animatedRocket.fbx` file into your **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `animatedRocket` file in the **Project** view. Then, from the **Inspector**
    view, check its **Import Settings**. Select **Animations**, then select the clip
    **Take 001**, and make sure to check the **Loop Time** option. Click on the **Apply**
    button, shown as follows, to save the changes:![How to do it...](img/1362_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why we didn't need to check **Loop Pose** option is because our animation
    already loops in a seamless fashion. If it didn't, we could have checked that
    option to automatically create a seamless transition from the last to the first
    frame of the animation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the **animatedRocket** GameObject to the scene by dragging it from the **Project**
    view into the **Hierarchy** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `engineSound.wav` audio clip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **animatedRocket** GameObject. Then, drag **engineSound** from the
    **Project** view into the **Inspector** view, adding it as an **Audio Source**
    for that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Audio Source** component of **animatedRocket**, check the box for the
    **Loop** option, as shown in the following screenshot:![How to do it...](img/1362_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a **Controller** for our object. In the **Project** view,
    click **Create** and select **Animator Controller**. Name it as `rocketlController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on **rocketController** object to open the **Animator** window,
    as shown. Then, right-click on the gridded area and select the **Create State**
    | **Empty** option, from the contextual menu:![How to do it...](img/1362_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new state `spin` and set **Take 001** as its motion in the **Motion**
    field:![How to do it...](img/1362_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select **animatedRocket**. Then, in the **Animator**
    component (in the **Inspector** view), set **rocketController** as its **Controller**
    and make sure that the **Apply Root Motion** option is unchecked as shown:![How
    to do it...](img/1362_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** view, create a new **C# Script** and rename it to `ChangePitch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script in your editor and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your script and add it as a component to **animatedRocket** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene and change the animation speed by pressing key *1* (accelerate)
    and *2* (decelerate) on your alphanumeric keyboard. The audio pitch will change
    accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the `Start()` method, besides storing the **Animator** and **AudioSource**
    components in variables, we'll get the initial `speed` from the **Animator**,
    and we'll call the `AccelRocket()` function by passing `0` as an argument, only
    for that function to calculate the resulting pitch for the **Audio Source**. During
    `Update()` function, the lines of the `if(Input.GetKey (KeyCode.Alpha1))` and
    `if(Input.GetKey (KeyCode.Alpha2))` code detect whenever the *1* or *2* keys are
    being pressed on the alphanumeric keyboard to call the `AccelRocket()` function,
    passing a `accel` float variable as an argument. The `AccelRocket()` function,
    in its turn, increments `speed` with the received argument (the `accel` float
    variable). However, it uses the `Mathf.Clamp()`command to limit the new speed
    value between the minimum and maximum speed as set by the user. Then, it changes
    the **Animator** speed and **Audio Source** pitch according to the new `speed`
    absolute value. The value is clamped a second time to avoid negative numbers.
    Should you reverse the animation, check out a solution in the completed project
    included with the code files. Also, please note that setting the animation speed
    and therefore, the sound pitch to `0` will cause the sound to stop, making it
    clear that stopping the object's animation also prevents the engine sound from
    playing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is some information on how to fine-tune and customize this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Animation/Sound Ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want the audio clip pitch to be more or less affected by the animation
    speed, change the value of the **Animation/Sound Ratio** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the function from other scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AccelRocket()` function was made public so that it can be accessed from
    other scripts. As an example, we have included the `ExtChangePitch.cs` script
    in `1362_09_01` folder. Try attaching this script to the **Main Camera** object
    and use it to control the speed by clicking on the left and right mouse buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating acoustic environments with Reverb Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created your level's geometry and the scene is looking just the
    way you want it to, you might want your sound effects to correspond to that look.
    Sound behaves differently depending upon the environment in which it is projected,
    so it can be a good idea to make it reverberate accordingly. In this recipe, we
    will address this acoustic effect by using **Reverb Zones**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `ReverbZone.unitypackage` file, containing
    a basic level named `reverbScene` and the `Signal` prefab. The package is in the
    `1362_09_02` folder in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to simulate the sonic landscape of a tunnel:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `ReverbZone` package into your Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** view, open the **reverbScene** level, inside the `ReverbZones`
    folder. This is a basic scene, featuring a controllable character and a tunnel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the **Signal** prefab from the **Project** view into **Hierarchy**,
    as shown in the following screenshot. This will add a sound-emitting object to
    the scene. Place it in the center of the tunnel.![How to do it...](img/1362_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make five copies of the **Signal** GameObject and distribute them across the
    tunnel (leaving a copy just outside each entrance):![How to do it...](img/1362_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In in the **Hierarchy** view, navigate to **Create** | **Audio** | **Audio Reverb
    Zone** to add a **Reverb Zone** to the scene. Then, place it in the center of
    the tunnel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Reverb Zone** GameObject. In the **Inspector** view, change the
    **Reverb Zone** component parameters to these values: **Min Distance**: `6`; **Max
    Distance**: `18`; and **Preset**: `StoneCorridor` as shown in the following screenshot:![How
    to do it...](img/1362_09_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene and walk through the tunnel using the *W A S D* keys ( and pressing
    *Shift* to run). You will hear the audio reverberate when inside the **Reverb
    Zone** area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once positioned, the **Audio Reverb Zone** applies an audio filter to all audio
    sources within its radius.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are more options for you to try.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the Audio Reverb Zone component to Audio Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of creating an **Audio Reverb Zone** GameObject, you can attach it to
    the sound emitting object (in our case, **Signal**) as a component through the
    **Component** | **Audio** | **Audio Reverb Zone** menu. In this case, the **Reverb
    Zone** will be individually set up around the object.
  prefs: []
  type: TYPE_NORMAL
- en: Making your own Reverb settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity comes with several **Reverb Presets**. We have used **StoneCorridor**,
    but your scene can ask for something less intense (such as **Room**) or more radical
    (such as **Psychotic**). If these presets still won't be able to recreate the
    effect that you have in mind, change it to **User** and edit its parameters as
    you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing an Audio Clip from restarting if it is already playing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a game, there may be several different events that cause a sound to start
    playing. If the sound is already playing, then in almost all cases, we won't wish
    to restart the sound. This recipe includes a test, so that an **Audio Source**
    component is only sent a `Play()` message if it is currently not playing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try this with any audio clip that is one second or longer in duration. We have
    included the `engineSound` audio clip inside the `1362_09_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent an **Audio Clip** from restarting, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an **Empty** GameObject and rename it to **AudioObject**. Then, add an
    **Audio Source** component to this object (in the **Component** | **Audio** |
    **Audio Source** menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `engineSound` audio clip and drag it from the **Project** view to
    populate the **Audio Clip** parameter of the **Audio Source** component of **AudioObject**:![How
    to do it...](img/1362_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a UI button named **PlaySoundButton** on the screen and attach the following
    script to this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With **PlaySoundButton** selected in the **Hierarchy** panel, drag **AudioObject**
    into the **Inspector** view for the public **Audio Source** variable, and drag
    the **Text** child of **PlaySoundButton** for the public **ButtonText**:![How
    to do it...](img/1362_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **PlaySoundButton** selected in the **Hierarchy** panel, create a new on-click
    event handler, dragging the **PlaySoundButton** into the **Object** slot, and
    selecting the **PlaySoundIfNotPlaying()** function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Audio Source** components have a public readable property **isPlaying**,
    which is a Boolean true/false flag, indicating if the sound is currently playing.
    The text of the button is set to display `Play Sound` when the sound is not playing,
    and (`sound playing`) when it is. When the button is clicked, the `PlaySoundIfNotPlaying()`
    method is called. This method uses an `if` statement, ensuring that a `Play()`
    message is only sent to the Audio Source component if its **isPlaying** is false.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Waiting for the audio to finish before auto-destructing an object* recipe
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for audio to finish playing before auto-destructing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event may occur (such as an object pickup or the killing of an enemy) that
    we wish to notify to the player by playing an audio clip, and an associated visual
    object (such as an explosion particle system, or a temporary object in the location
    of the event). However, as soon as the clip has finished playing, we will wish
    for the visual object to be removed from the scene. This recipe provides a simple
    way to link the ending of a playing audio clip with the automatic destruction
    of its containing object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try this with any audio clip that is a second or more in duration. We have included
    the `engineSound` audio clip inside the `1362_09_04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To wait for audio to finish playing before destroying a GameObject, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an **Empty** GameObject and rename it to **AudioObject**. Then, add an
    **Audio Source** component to this object (in the **Component** | **Audio** |
    **Audio Source** menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `engineSound` audio clip and drag it from the **Project** view to
    populate the **Audio Clip** parameter of the **Audio Source** component of **AudioObject**,
    and deselect the component's **Play On Awake** checkbox:![How to do it...](img/1362_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following script class to **AudioObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In **Inspector** view, disable (un-check) the `AudioDestructBehaviour` scripted
    component of **AudioObject** (when needed, it will be re-enabled via C# code):![How
    to do it...](img/1362_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# file named **ButtonActions**, containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a UI button named **PlaySoundButton** on the screen with a button `Play
    Sound` text, and attach the **ButtonActions** script to this button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **PlaySoundButton** selected in the **Hierarchy**, create a new on-click
    event handler, dragging **PlaySoundButton** into the **Object** slot, and selecting
    the **PlaySound()** function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **PlaySoundButton** selected in the **Hierarchy** panel, drag **AudioObject**
    into the **Inspector** view for the public **Audio Source** variable **AudioObject**.
    Also, drag **AudioObject** into the **Inspector** view for the public **Script**
    variable **AudioDestructScriptedObject**, shown as follows:![How to do it...](img/1362_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second UI button named **DestoryWhenSoundFinishedButton** on screen,
    with the button text `Destroy When Sound Finished`, and attach the **ButtonActions**
    script to this button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **DestoryWhenSoundFinishedButton** selected in the **Hierarchy** panel,
    create a new on-click event handler, dragging **PlaySoundButton** into the **GO**
    slot, and then selecting the **DestroyAfterSoundStops()** function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just as you did with the other button, now the **DestoryWhenSoundFinishedButton**
    selected in the **Hierarchy** panel, drag **AudioObject** into the **Inspector**
    view for the public **Script** variable **MyAudioDestructObect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GameObject named **AudioObject** contains an Audio Source component, which
    stores and manages the playing of the audio clip. **AudioObject** also contains
    a scripted component, which is an instance of the **AudioDestructBehaviour** class.
    This script is initially disabled. When enabled, every frame this object (via
    its `Update()` method) tests whether the audio source is not playing (`!audio.isPlaying`).
    As soon as the audio is found to be not playing, the GameObject is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: There are two UI buttons created. Button **PlaySoundButton** calls the `PlaySound()`
    method. This method will start playing the audio clip, if it is not already playing.
  prefs: []
  type: TYPE_NORMAL
- en: The second button called **DestoryWhenSoundFinishedButton** calls the `DestoryAfterSoundStops()`
    method. This method enables the scripted component **AudioDestructBehaviour**
    in GameObject **AudioObject**—so that that GameObject will be destroyed, once
    the sound has finished playing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Preventing an Audio Clip from restarting if it is already playing* recipe
    in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding volume control with Audio Mixers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound volume adjustment can be a very important feature, especially if your
    game is a standalone. After all, it can be very frustrating to access the operational
    system volume control. In this recipe, we will use the new **Audio Mixer** feature
    to create independent volume controls for Music and Sound FX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have provided a Unity package named `Volume.unitypackage`,
    containing an initial scene featuring soundtrack music and sound effects. The
    file is available inside the `1362_09_05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add volume control sliders to your scene, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `Volume.unitypackage` into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Volume** scene (available in the **Assets** | **Volume** folder).
    Play the scene and walk towards the semitransparent green wall in the tunnel,
    using the *W A S D* keys (while pressing the *Shift* key to run). You will be
    able to listen to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A looping soundtrack music
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bells ringing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A robotic speech whenever the character collides with the wall
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **Project** view, use the **Create** drop-down menu to add **Audio
    Mixer** to the project. Name it **MainMixer**. Double-click on it to open the
    **Audio Mixer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Groups** view, highlight **Master** and click the **+** sign to add
    a child to the **Master** group. Name it **Music**. Then, highlight **Master**
    again and add a new child group named **FX**, as shown in the following screenshot:![How
    to do it...](img/1362_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Mixers** view, highlight **MainMixer** and click the **+** sign to
    add a new **Mixer** to the project. Name it **MusicMixer**. Then, drag it into
    the **MainMixer** and select the **Music** group as its **Output**. Repeat the
    operation to add a mixer named **FxMixer** to the project by selecting the **FX**
    group as its output:![How to do it...](img/1362_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, select **MusicMixer**. Select its **Master** group and add a child named
    **Soundtrack**. Then, select **FxMixer** and add two children to its **Master**
    group: one named **Speech**, and another named **Bells**, as shown:![How to do
    it...](img/1362_09_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select the **DialogueTrigger** object. Then, in
    the **Inspector** view, change its **Output** track to **FxMixer** | **Speech**
    in the **Audio Source** component:![How to do it...](img/1362_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **Soundtrack** GameObject. From the **Inspector** view, find
    the **Audio Source** component and change its **Output** track to **MusicMixer**
    | **Soundtrack**:![How to do it...](img/1362_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, from the **Assets** folder in the **Project** view, select the **Signal**
    prefab . From the **Inspector** view, access its **Audio Source** component and
    change its **Output** to **FxMixer** | **Bells**:![How to do it...](img/1362_09_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Audio Mixer** window, choose **MainMixer** and select its **Master**
    track. Then, from the **Inspector** view, right-click on **Volume** in the **Attenuation**
    component. From the context menu, select **Expose 'Volume (of Master) to script**
    as shown in the following screenshot. Repeat the operation for the **Music and
    FX** tracks:![How to do it...](img/1362_09_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top of the **Audio Mixer** with the **MainMixer** selected, access
    the **Exposed Parameters** drop-down menu. Then, right-click on **MyExposedParam**
    and rename it to `OverallVolume`. Then, rename **MyExposedParam1** as `MusicVolume`
    and **MyExposedParam2** as `FxVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, create a new **C# Script** and rename it to `VolumeControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script in your editor and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the **Hierarchy** view, use the **Create** dropdown menu to add a **Panel**
    to the scene (**Create** | **UI** | **Panel**). Note that it will automatically
    add a **Canvas** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, use the **Create** dropdown menu to add a **Slider**
    to the scene (**Create** | **UI** | **Slider**). Make it a child of the **Panel**
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the slider as **OverallSlider**. Duplicate it and rename the new copy
    to **MusicSlider**. Then, in the **Inspector** view, **Rect Transform** component,
    change its **Pos Y** parameter to `-40`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **MusicSlider** and rename the new copy to **FxSlider**. Then, change
    its **Pos Y** parameter to `-70`:![How to do it...](img/1362_09_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Canvas** GameObject and add the **VolumeControl** script to it.
    Then, populate the **MyMixer** field of **Volume Control** with **MainMixer**:![How
    to do it...](img/1362_09_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OverallSlider** component. From the **Inspector** view at the **Slider**
    component, change **Min Value** to `0.000025` (or **2.5e-05**). Then, below the
    **On Value Changed** list, click the **+** sign to add an action. From **Hierarchy**
    panel, drag **Canvas** into the **Object** slot and using the drop-down menu,
    choose **VolumeControl** | **ChangeOverallVol** option, as shown in the following
    screenshot, For testing purposes, change the appropriate selector from **Runtime
    Only** to **Editor and Runtime**.![How to do it...](img/1362_09_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step with **MusicSlider** and **FxSlider**, but this time,
    choose **ChangeMusicVol** and **ChangeFxVol** options respectively from the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene. You will be able to access the sliders when pressing *Escape*
    on your keyboard and adjust volume settings from there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new **Audio Mixer** feature works in a similar fashion to Digital Audio
    Workstations, such as Logic and Sonar. Through **Audio Mixers**, you can organize
    and manage audio elements by routing them into specific groups that can have individual
    audio tracks to be tweaked around, allowing for adjustments in volume level and
    sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: By organizing and routing our audio clips into two groups (**Music** and **FX**),
    we established the **MainMixer** as a unified controller for volume. Then, we
    have used the **Audio Mixer** to expose the volume levels for each track of the
    **MainMixer**, making them accessible to our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have set up a basic GUI featuring three sliders that, when in use,
    will pass their float values (between `0.000025` and `1`) as arguments to three
    specific functions in our script: `ChangeMusicVol`, `ChangeFxVol`, and `ChangeOverallVol`.
    These functions, on their turn, use the `SetFloat` command to effectively change
    the volume levels at runtime. However, before passing on the new volume levels,
    the script converts linear values (between `0.000025` and `1`) to the decibel
    levels that are used by the **Audio Mixer**. This conversion is calculated through
    the *log(x) * 20* mathematical function.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a full explanation on issues regarding the conversion of linear values to
    decibel levels and vice-versa, check out Aaron Brown's excellent article at [http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/](http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning that the `VolumeControl` script also includes code to
    enable and disable the **GUI** and the **EventSystem**, depending upon if the
    player hits the Escape key to activate/deactivate the volume control sliders.
  prefs: []
  type: TYPE_NORMAL
- en: A very important note—do not change the volume of any **MainMixer'**s tracks;
    leave them at `0` dB. The reason is that our `VolumeControl` script sets their
    maximum volume level. For general adjustments, use the secondary Mixers **MusicMixer**
    and **FxMixer**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is some extra information on Audio Mixers.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Audio Production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many creative uses for exposed parameters. We can, for instance, add
    effects such as **Distortion**, **Flange**, and **Chorus** to audio channels,
    allowing users to operate virtual sound tables/mixing boards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Balancing the in-game audio with Ducking* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a dynamic soundtrack with Snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic soundtracks are the ones that change according to what is happening
    to the player in the game, musically reflecting that place or moment of the character's
    adventure. In this recipe, we will implement a soundtrack that changes twice;
    the first time when entering a tunnel, and the second time when coming out of
    its end. To achieve this, we will use the new **Snapshot** feature of the **Audio
    Mixer**.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshots are a way of saving the state of your **Audio Mixer**, keeping your
    preferences for volume levels, audio effects, and more. We can access these states
    through script, creating transitions between mixes, and by bringing up the desired
    sonic ambience for each moment of the player's journey.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we have prepared a basic game level, contained inside the
    Unity package named `DynamicSoundtrack`, and two soundtrack audio clips in `.ogg`
    format: `Theme01_Percussion` and `Theme01_Synths`. All these files can be found
    in the `1362_09_06` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a dynamic soundtrack, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `DynamicSoundtrack` package and both `.ogg` files to your Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the level named **Dynamic**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, use the **Create** drop-down menu to add **Audio
    Mixer** to the project. Name it **MusicMixer**. Double-click on it to open the
    **Audio Mixer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Groups** view, highlight **Master** and click the **+** sign to
    add a child to the **Master** group. Name it as **Music**. Then, add two child
    groups to **Music**: **Percussion** and **Synths**:![How to do it...](img/1362_09_25.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, create a new **Empty** GameObject. Name it **Music**.
    Then, add two **Empty Child** GameObjects to it. Name them as **Percussion** and
    **Synth**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, drag the **Audio Clip** named **Theme01_Percussion**
    into the **Percussion** GameObject in **Hierarchy**. Select **Percussion** and
    in the **Inspector** view, access the **Audio Source** component. Change its **Output**
    to **Percussion (MusicMixer)**, make sure the **Play On Awake** option is checked,
    check the **Loop** option, and make sure its **Spatial Blend** is set to **2D**,
    as shown in the following screenshot:![How to do it...](img/1362_09_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the **Theme01_Synths** audio file into the **Synths** GameObject.
    From the **Inspector** view, change its **Output** to **Synths (MusicMixer)**,
    make sure the **Play On Awake** option is checked, check the **Loop** option,
    and make sure its **Spatial Blend** is set to **2D**, as shown:![How to do it...](img/1362_09_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Audio Mixer** and play the scene. We will now use the mixer to set
    the soundtrack for the start of the scene. With the scene playing, click on the
    **Edit in Play Mode** button, as shown in the screenshot, at the top of the **Audio
    Mixer**. Then, drop the volume on the **Synths** track down to **-30 dB**:![How
    to do it...](img/1362_09_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **Percussion** track. Right-click on **Attenuation** and add
    the **High-pass** effect before it:![How to do it...](img/1362_09_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** view, change the **Cutoff frequency** of the **High-pass**
    effect to **544.00 Hz**:![How to do it...](img/1362_09_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every change, so far, has been assigned to the current **Snapshot**. From the
    **Snaphots** view, right-click on the current **Snapshot** and rename it to **Start**.
    Then, right-click on **Start** and select the **Duplicate** option. Rename the
    new snapshot as **Tunnel**, as shown:![How to do it...](img/1362_09_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Tunnel** snapshot. Then, from the **Inspector** view, change the
    **Cutoff frequency** of the **Highpass** effect to **10.00 Hz**:![How to do it...](img/1362_09_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch between the **Tunnel** and **Start** snapshots. You'll be able to hear
    the difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **Tunnel** snapshot, rename it as **OtherSide**, and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise the volume of the **Synths** track up to **0 dB**:![How to do it...](img/1362_09_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our three **Snapshots**, it's time to create triggers to make
    transitions among them. From the **Hierarchy** view, use the **Create** drop-down
    menu to add a **Cube** to the scene (**Create** | **3D Object** | **Cube**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new **Cube** and rename it `SnapshotTriggerTunnel`. Then, from the
    **Inspector** view, access the **Box Collider** component and check the **Is Trigger**
    option, as shown in the following screenshot. Also, uncheck its **Mesh Renderer**
    component. Finally, adjust its size and position to the scene tunnel's interior:![How
    to do it...](img/1362_09_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make two copies of `SnapshotTriggerTunnel` and rename them to `SnapshotTriggerStart`
    and `SnapshotTriggerOtherSide`. Then, adjust their size and position, so that
    they occupy the areas before the tunnel's entrance (where the character is) and
    after its other end, as shown in the following screenshot:![How to do it...](img/1362_09_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** view, create a new **C# Script** file and rename it to `SnapshotTrigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script in your editor and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your script and attach it to `SnapshotTriggerTunnel`, `SnapshotTriggerStart`,
    and `SnapshotTriggerOtherSide` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `SnapshotTriggerTunnel`. Then, from the **Inspector** view, access the
    **Snapshot Trigger** component, setting **Snapshot** as **Tunnel**, and **Crossfade**
    as `2`, as shown in the following screenshot:![How to do it...](img/1362_09_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make changes to `SnapshotTriggerStart` and `SnapshotTriggerOtherSide` by setting
    their **Snapshots** to **Start** and **OtherSide** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene. The background music will change as the character moves from
    its starting point, through the tunnel, and into the other side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Snapshot** feature allows you to save **Audio Mixer** states (including
    all volume levels, every filter setting, and so on) so that you can change those
    mixing preferences at runtime, making the audio design more suitable for specific
    locations or gameplay settings. For this recipe, we have created three **Snapshots**
    for different moments in the player''s journey: before entering the tunnel, inside
    the tunnel, and outside the tunnel. We have used the **Highpass** filter to make
    the initial Snapshot less intense. We have also turned the **Synths** track volume
    up to emphasize the open environment outside the tunnel. Hopefully, changes in
    the audio mix will collaborate with setting the right mood for the game.'
  prefs: []
  type: TYPE_NORMAL
- en: To activate our snapshots, we have placed **trigger colliders**, featuring our
    **Snapshot Trigger** component in which we set the desired Snapshot and the time
    in seconds, that it takes to make the transition (a crossfade) between the previous
    Snapshot and the next. In fact, the function in our script is really this straightforward—the
    line of `snapshot.TransitionTo (crossfade)` code simply starts a transition lasting
    `crossfade` seconds to the desired `Snapshot`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is some information on how to fine-tune and customize this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the need for multiple audio clips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed how different the `Theme01_Percussion` audio clip sounds
    when the **Cutoff frequency** of the **High-pass** filter is set as `10.00 Hz`.
    The reason for this is that the high-pass filter, as its name suggests, cuts off
    lower frequencies of the audio signal. In this case, it attenuated the bass drum
    down to inaudible levels while keeping the shakers audible. The opposite effect
    can be achieved through the **Lowpass** filter. A major benefit is the opportunity
    of virtually having two separate tracks into the same audio clip.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with audio file formats and compression rates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid loss of audio quality, you should import your sound clips using the
    appropriate file format, depending upon your target platform. If you are not sure
    which format to use, please check out Unity's documentation on the subject at
    [http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html).
  prefs: []
  type: TYPE_NORMAL
- en: Applying Snapshots to background noise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we have applied Snapshots to our music soundtrack, background noise
    can also benefit immensely. If your character travels across places that are significantly
    different, transitioning from open spaces to indoor environments, you should consider
    applying snapshots to your environment audio mix. Be careful, however, to create
    separate Audio Mixers for Music and Environment—unless you don't mind having musical
    and ambient sound tied to the same Snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting creative with effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we have mentioned the High-pass and Low-pass filters. However,
    there are many effects that can make audio clips sound radically different. Experiment!
    Try applying effects such as Distortion, Flange, and Chorus. In fact, we encourage
    you to try every effect, playing with their settings. The creative use of these
    effects can bring out different expressions to a single audio clip.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding volume control with Audio Mixers* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Balancing soundtrack volume with Ducking* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing in-game audio with Ducking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as the background music can be important in establishing the right atmosphere,
    there will be times when other audio clips should be emphasized, and the music
    volume turned down for the duration of that clip. This effect is known as **Ducking**.
    Maybe you will need it for dramatic effect (simulating hearing loss after an explosion
    took place), or maybe you want to make sure that the player listens to a specific
    bit of information. In this recipe, we will learn how to emphasize a piece of
    dialog by ducking the audio whenever a specific sound message is played. For that
    effect, we will use the new **Audio Mixer** to send information between tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have provided the `soundtrack.mp3` audio clip and a Unity
    package named `Ducking.unitypackage`, containing an initial scene. All these files
    are available inside the `1362_09_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply Audio Ducking to your soundtrack, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `Ducking.unitypackage` and `soundtrack.mp3` into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Ducking** scene (available in the **Assets** | **Ducking** folder).
    Play the scene and walk towards the semitransparent green wall in the tunnel,
    using the *W A S D* keys (by pressing *Shift* to run). You will hear the **robotDucking**
    audio clip play as the character collides with the wall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Create** drop-down at the top of the **Hierarchy** view, choose **Create
    Empty** to add a new GameObject to the scene. Name it **Soundtrack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **soundtrack** audio clip you have imported into the **Soundtrack**
    GameObject. Then, select the **Soundtrack** object and from the **Inspector**
    view, **Audio Source** component, check the **Loop** option. Make sure the **Play
    On Awake** option is checked and **Spatial Blend** set to **2D**, as shown in
    the following in the following screenshot:![How to do it...](img/1362_09_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene again. The soundtrack music should be playing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, use the **Create** drop-down menu to add an **Audio
    Mixer** to the project. Name it **MainMixer**. Double-click on it to open the
    **Audio Mixer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Groups** view, highlight **Master** and click the **+** sign to add
    a child to the **Master** group. Name it **Music**. Then, highlight **Master**
    again and add a new child group named **FX**, as shown in the following screenshot.
    Finally, add a third child to the **Master** group, named **Input**:![How to do
    it...](img/1362_09_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Mixers** view, highlight **MainMixer** and click the **+** sign to
    add a new **Mixer** to the project. Name it **MusicMixer**. Then, drag it into
    the **MainMixer** and select the group **Music** as its **Output**. Repeat the
    operation to add a mixer named **FxMixer** to the project, selecting the **FX**
    group as the output:![How to do it...](img/1362_09_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select **MusicMixer**. Select its **Master** group and add a child named
    **Soundtrack**. Then, select **FxMixer** and add a child named **Bells**, as shown:![How
    to do it...](img/1362_09_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select the **DialogueTrigger** object. Then, in
    the **Inspector** view, **Audio Source** component, Change its **Output** track
    to **MainMixer** | **Input**:![How to do it...](img/1362_09_41.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **Soundtrack** GameObject and in the **Inspector** view, in
    the **Audio Source** component, change its **Output** track to **MusicMixer**
    | **Soundtrack**:![How to do it...](img/1362_09_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, from the **Assets** folder in the **Project** view, select the **Signal**
    prefab. From the **Inspector** view, access its the **Audio Source** component
    and change its **Output** to **FxMixer** | **Bells**:![How to do it...](img/1362_09_43.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Audio Mixer** window. Choose **MainMixer**, select the **Music**
    track controller, right-click on **Attenuation**, and using the context menu,
    add the **Duck Volume** effect before **Attenuation**:![How to do it...](img/1362_09_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **Input** track, right-click on **Attenuation**, and using the
    context menu, add **Send** after **Attenuation**:![How to do it...](img/1362_09_45.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Input** track still selected, go to the **Inspector** view and change
    the **Receive** setting in **Send** to **Music\Duck Volume** and its **Send**
    level to `0.00 db`, as shown:![How to do it...](img/1362_09_46.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Music** track. From the **Inspector** view, change the settings
    on the **Duck Volume** as follows: **Threshold**: -`40.00 db`; **Ratio**: `300.00
    %`; **Attack Time**: `100.00 ms`; **Release Time**: `2000.00 ms`, as shown in
    the following screenshot:![How to do it...](img/1362_09_47.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene again. Entering the trigger object will cause the soundtrack
    volume to drop considerably, recovering the original volume in 2 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have created, in addition to Music and Sound FX, a group
    named **Input**, to which we have routed the audio clip that triggers the **Duck
    Volume** effect attached to our music track. The **Duck Volume** effect changes
    the track's volume whenever it receives an input that is louder than indicated
    in its **Threshold** setting. In our case, we have sent the **Input** track as
    input, and adjusted the settings so the volume will be reduced as soon as 0.1
    seconds after the input had been received, turning back to its original value
    of 2 seconds after the input has ceased. The amount of volume reduction was determined
    by our **Ratio** of **300.00 %**. Playing around with the setting values will
    give you a better idea on how each parameter affects the final result. Also, make
    sure to visualize the graphic as the trigger sound is played. You will be able
    to see how the **Input** sound passes the threshold, triggering the effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1362_09_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Duck Volume
  prefs: []
  type: TYPE_NORMAL
- en: Also, please note that we have organized our tracks so that the other sound
    clips (other than speech) will not affect the volume of the music—but every music
    clip will be affected by audio clips sent to the input track.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding volume control with Audio Mixers* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
