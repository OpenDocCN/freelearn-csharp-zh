- en: Social VR Metaverse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交VR元宇宙
- en: '*That''s me, Linojon, the guy with a baseball cap in front, to the left!* Momentously,
    the following photo was captured during the eve of the metaverse on December 21,
    2014 at a live VRChat session. I had built a seasonally-themed world named GingerLand
    and invited my chatroom friends to visit during one of the weekly meetups. Then,
    someone suggested, "Hey, let''s take a group picture!" So, we all assembled on
    the front porch of my wintry cabin and said "Cheese!" The rest is history:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*那是我，Linojon，前面戴棒球帽的家伙!* 重要的是，以下照片是在2014年12月21日元宇宙前夕，在一场现场VRChat会议期间捕捉到的。我建立了一个季节性的世界名为GingerLand，并邀请我的聊天室朋友在每周聚会期间参观。然后，有人建议，“嘿，让我们拍一张集体照！”于是，我们都聚集在我的冬日小屋前门，说“Cheese！”其余的就是历史：'
- en: '![](img/5a4f0680-a02b-4481-8843-d4de41941b49.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a4f0680-a02b-4481-8843-d4de41941b49.png)'
- en: 'For many people, the visceral experience of socially interacting live with
    other people in VR is at least as dramatic as the difference between using Facebook
    versus browsing a static website, or sharing Snapchats versus viewing an online
    photo album. It''s very personal and alive. If you''ve tried it out yourself,
    you know exactly what I mean. We''re now going to look at how social VR experiences
    can be implemented using Unity. There are many approaches, from building it from
    scratch to plugging into an existing social VR platform. In this chapter, we will
    discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，在VR中与其他人实时社交互动的直观体验至少与使用Facebook浏览静态网站或分享Snapchats查看在线相册之间的差异一样戏剧性。这非常个人化和生动。如果你亲自尝试过，你就知道我是什么意思。我们现在将探讨如何使用Unity实现社交VR体验。有许多方法，从从头开始构建到连接到现有的社交VR平台。在本章中，我们将讨论以下主题：
- en: An introduction to how multiplayer networking works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多玩家网络工作原理简介
- en: Implementing a multiplayer scene that runs in VR using the Unity Networking
    engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity网络引擎在VR中实现多玩家场景
- en: Using Oculus personalized avatars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Oculus个性化化身
- en: Building and sharing a custom VRChat room
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和分享自定义VRChat房间
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的项目是独立的，并不直接需要本书其他章节中的其他章节。如果你决定跳过其中任何部分或没有保存你的工作，那没问题。
- en: Multiplayer networking
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多玩家网络
- en: Before we begin any implementation, let's take a look at what multiplayer networking
    is all about and define some terms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何实现之前，让我们先了解一下多玩家网络是什么，并定义一些术语。
- en: Networking services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: Consider a situation where you are running a VR application that is connected
    over the internet to other players running the same application on their own VR
    rigs at the same time. When you move your first person view within the game, shoot
    things, or otherwise interact with the virtual environment, you expect the other
    players to see that, too. Their version of the game stays in sync with yours and
    vice versa. How does this work?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，你正在运行一个VR应用程序，该应用程序通过互联网连接到其他玩家，这些玩家同时在自己的VR设备上运行相同的应用程序。当你移动你的第一人称视角在游戏中，射击东西，或以其他方式与虚拟环境互动时，你希望其他玩家也能看到。他们的游戏版本与你的保持同步，反之亦然。这是如何工作的？
- en: One instance of the running game acts as a host or server. Other players are
    concurrently connected to the same. When you move, your character's new position
    is shared with each of the other connections, which then updates your avatar's
    position in their own views. Similarly, when your game receives a changed position
    of another character, it is updated in your view. The faster, the better. That
    is, the shorter the delay (latency) between the *send* and *receive* messages
    and the corresponding screen updates, the more live, or real-time, the interaction
    feels.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的游戏的一个实例充当主机或服务器。其他玩家同时连接到同一个实例。当你移动时，你的角色的新位置会与每个其他连接共享，然后它们在自己的视图中更新你的化身位置。同样，当你游戏接收到另一个角色的位置变化时，它会在你的视图中更新。越快越好。也就是说，发送和接收消息以及相应屏幕更新的延迟（延迟）越短，交互感觉就越真实，或越实时。
- en: Multiplayer services should help you manage the sharing of the game's state
    between all active clients, the spawning of new players and objects, security
    considerations, as well as the management of low-level network connections, protocols,
    and quality of service (such as data rate and performance).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多玩家服务应该帮助你管理所有活跃客户端之间游戏状态的共享，新玩家和对象的生成，安全考虑，以及低级网络连接、协议和服务质量（如数据速率和性能）的管理。
- en: Networking is built as a series of API layers, where the low-level functions
    deal with details of the data transport and would be agnostic to the content of
    the data. Middle and higher layers provide increasingly aggregated features that
    also may be more directly helpful for the networking application. In our case,
    this is multiplayer gaming and social VR. Ideally, the high-level layer will provide
    all you need to implement multiplayer features into your games with minimal custom
    scripting, while offering access to other layers through a clean API in case you
    have special requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络被构建为一系列 API 层，其中低级函数处理数据传输的细节，并且对数据内容一无所知。中间和高级层提供越来越聚合的功能，也可能更直接地有助于网络应用程序。在我们的案例中，这是多玩家游戏和社交
    VR。理想情况下，高级层将提供你将多玩家功能集成到游戏中的所有所需，同时通过干净的 API 提供对其他层的访问，以防你有特殊要求。
- en: There are a number of multiplayer services available, including Photon from
    Exit Games and platforms from Google, Facebook/Oculus, Apple, Microsoft, Amazon,
    and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的多玩家服务有很多，包括 Exit Games 的 Photon 和来自 Google、Facebook/Oculus、Apple、Microsoft、Amazon
    等平台的平台。
- en: The popular Photon Cloud service can be easily added using their free **Photon
    Unity Networking** (**PUN**) package from the Unity Asset Store (for more information,
    visit [https://www.assetstore.unity3d.com/#/content/1786](https://www.assetstore.unity3d.com/#/content/1786)).
    If you are interested in trying Photon with Unity, take a look their documentation
    and tutorial pages ([https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links](https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 Unity Asset Store 中的免费 **Photon Unity Networking**（**PUN**）包轻松添加流行的 Photon
    Cloud 服务（更多信息，请访问 [https://www.assetstore.unity3d.com/#/content/1786](https://www.assetstore.unity3d.com/#/content/1786)）。如果你对在
    Unity 中尝试 Photon 感兴趣，请查看他们的文档和教程页面（[https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links](https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links)）。
- en: Unity has its own built-in networking system, **Unity Networking** (**UNet**),
    which reduces the need for custom scripting and provides a feature-rich set of
    components and API that tightly integrate with Unity. There is a whole tutorial
    series on the Unity website ([https://unity3d.com/learn/tutorials/s/multiplayer-networking](https://unity3d.com/learn/tutorials/s/multiplayer-networking)),
    and it's what we will use in this chapter's project.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 拥有自带的内置网络系统，称为 **Unity Networking**（**UNet**），这减少了自定义脚本的需求，并提供了一套功能丰富的组件和
    API，这些组件和 API 与 Unity 紧密集成。Unity 网站上有一整套关于多玩家网络教程（[https://unity3d.com/learn/tutorials/s/multiplayer-networking](https://unity3d.com/learn/tutorials/s/multiplayer-networking)），这是我们本章项目中将使用的内容。
- en: The network architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络架构
- en: A key to networking is the client-server system architecture. We see this all
    around us in today's world; your web browser is a client and websites are hosted
    on a server. Your favorite music listening app is a client and its streaming service
    is a server. Similarly, each instance of your game, when connected to a network,
    is a client. It talks to a server, which communicates the status and control information
    between all the other game clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的关键是客户端-服务器系统架构。我们在当今世界的各个方面都能看到这一点；你的网页浏览器是一个客户端，而网站托管在服务器上。你最喜欢的音乐收听应用是一个客户端，它的流媒体服务是服务器。同样，当你的游戏实例连接到网络时，它也是一个客户端。它与服务器通信，传递所有其他游戏客户端之间的状态和控制信息。
- en: I say *server*, but it doesn't necessarily need to be a separate physical computer
    somewhere. It could be, but it's probably not. It's best to think of a client
    and server as *processes*: instances of a program or an application running somewhere.
    A **cloud server** is a virtual process that is accessible via the internet as
    a service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的是 **服务器**，但并不一定需要是一个位于某处的独立物理计算机。它可以是，但可能不是。最好将客户端和服务器视为 **进程**：程序或应用程序的实例在某处运行。一个
    **云服务器** 是一个可以通过互联网作为服务访问的虚拟进程。
- en: A single app can sometimes act as both a client and a server at the same time.
    This latter case, where the server and client are one, is said to be running as
    a host. With Unity networking, games can be run as a client, a server, and/or
    as a host.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序有时可以同时充当客户端和服务器。这种服务器和客户端合为一体的运行方式被称为作为主机运行。使用Unity网络，游戏可以作为客户端、服务器和/或作为主机运行。
- en: Even so, a public **IP** (**Internet Protocol**) address is needed for game
    instances to talk to one another. A lightweight relay server can provide this
    service with minimal resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，游戏实例之间进行通信需要公共**IP**（**互联网协议**）地址。一个轻量级的中继服务器可以用最少的资源提供这项服务。
- en: Local versus server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地与服务器
- en: In Unity, you can use scripting to create, or instantiate, new objects during
    gameplay. In a multiplayer situation, these objects need to be activated, or spawned,
    locally as well as on the network so that all the clients will know about it.
    A spawning system manages objects across all the clients.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，你可以在游戏过程中使用脚本创建或实例化新对象。在多人游戏中，这些对象需要在本地以及网络上激活或生成，以便所有客户端都能了解它。一个生成系统管理所有客户端的对象。
- en: It is important to make a distinction between objects that are local player
    o*bjects* versus network ones. Local player objects are controlled by actions
    in your playing version of the game, on your client, rather than remotely.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 区分本地玩家对象和网络对象非常重要。本地玩家对象由你在游戏版本中的操作控制，在你的客户端上，而不是远程控制。
- en: For example, in a first-person experience, you are the camera whereas other
    players see you as your avatar, and you would want security precautions; for example,
    to prevent others from hacking a game and changing your avatar.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第一人称体验中，你是摄像头，而其他玩家将你视为你的化身，你希望有安全预防措施；例如，防止他人黑客攻击游戏并更改你的化身。
- en: Local player objects have local authority, that is, the player object is responsible
    for controlling itself, such as its own movement. Otherwise, when the creation,
    movement, and destruction of objects are not controlled by any player, the authority
    should reside on a server. Local authority is needed when individual players are
    driving gameplay.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本地玩家对象具有本地权限，也就是说玩家对象负责控制自身，例如其自身的移动。否则，当对象的创建、移动和销毁不由任何玩家控制时，权限应位于服务器上。当个别玩家在驱动游戏玩法时，需要本地权限。
- en: On the other hand, server authority is needed when game logic and random events
    are driving the gameplay. For example, when a game creates enemies at random locations,
    you'd want all the clients to get the same random locations. When a new player
    joins an ongoing game, the server helps create and set up objects that are active
    in the current gameplay. You wouldn't want an object to show up in its default
    position and then jump to a different current position as it's syncing with the
    other clients.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当游戏逻辑和随机事件驱动游戏玩法时，需要服务器权限。例如，当游戏在随机位置创建敌人时，你希望所有客户端都能获得相同的随机位置。当新玩家加入正在进行的游戏时，服务器帮助创建和设置当前游戏玩法中活跃的对象。你不想对象出现在默认位置，然后在与其他客户端同步时跳转到不同的当前位置。
- en: 'The following image from Unity documentation shows ways in which actions are
    performed across the network. The server makes **remote procedure calls** (**RPC**)
    to the client to spawn or update objects. The client sends **commands** to the
    server and affects actions, which then are communicated to all the remote clients:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下来自Unity文档的图片显示了在网络中执行操作的方式。服务器对客户端进行**远程过程调用**（RPC）以生成或更新对象。客户端向服务器发送**命令**并影响动作，然后这些动作被传达给所有远程客户端：
- en: '![](img/d81af447-bdbf-426a-b0ba-6ace7f23b0f1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d81af447-bdbf-426a-b0ba-6ace7f23b0f1.jpg)'
- en: Image source: [https://docs.unity3d.com/Manual/class-NetworkBehaviour.html](https://docs.unity3d.com/Manual/class-NetworkBehaviour.html)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[https://docs.unity3d.com/Manual/class-NetworkBehaviour.html](https://docs.unity3d.com/Manual/class-NetworkBehaviour.html)
- en: Real-time networking is an engineering discipline. Layered network architectures
    aim to simplify and shield you from brutally arcane details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实时网络是一个工程学科。分层网络架构旨在简化并保护你免受残酷的神秘细节。
- en: It all comes down to performance, security, and reliability. If you need to
    debug or optimize any of these in your multiplayer game, you may need to dig in
    your heels and gain a better understanding of what's going on under the hood.
    Refer to the next chapter, [Chapter 13](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml), *Optimizing
    for Performance and Comfort*, for suggestions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都归结于性能、安全和可靠性。如果你需要在你的多人游戏中调试或优化这些方面中的任何一个，你可能需要站稳脚跟，更好地理解底层发生了什么。请参考下一章，[第13章](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml)，*优化性能和舒适度*，以获取建议。
- en: The Unity networking system
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity网络系统
- en: The **Unity Networking** engine (**UNet**) includes a robust set of high-level
    component scripts that make it easy to add multiplayer capabilities to your games.
    Some of the more important components include *Network Identity*, *Network Behavior*,
    *Network Transform*, and *Network Manager*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity网络**引擎（**UNet**）包括一套强大的高级组件脚本，使得将多人游戏功能添加到你的游戏中变得容易。其中一些更重要的组件包括*网络身份*、*网络行为*、*网络变换*和*网络管理器*。'
- en: A good overview of Unity Networking and exposition of the concepts is the Unity
    Networking Concepts document ([http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Unity网络概念和概念的概述可以在Unity网络概念文档中找到（[http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)）。
- en: The **Network Identity** component is required on each game object prefab that
    may be spawned (created) on clients. Internally, it provides a universally unique
    asset ID, and other parameters, so that objects can be unambiguously identified
    and spawned across the network.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能在客户端被实例化（创建）的游戏对象预制件都需要**网络身份**组件。内部，它提供了一个通用的唯一资产ID和其他参数，以便对象可以在网络中被明确识别和实例化。
- en: The `NetworkBehaviour` class is derived from `MonoBehaviour` and provides network
    functionality to scripts. We'll be using it in the examples in this chapter. Details
    are documented at [http://docs.unity3d.com/Manual/class-NetworkBehaviour.html](http://docs.unity3d.com/Manual/class-NetworkBehaviour.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkBehaviour`类是从`MonoBehaviour`派生出来的，为脚本提供网络功能。我们将在本章的示例中使用它。详细信息请参阅[http://docs.unity3d.com/Manual/class-NetworkBehaviour.html](http://docs.unity3d.com/Manual/class-NetworkBehaviour.html)。'
- en: When you want to synchronize the movement and physics of objects, add a **Network
    Transform** component. It's like a shortcut for the more general `SyncVar` variable
    synchronization with additional intelligent interpolation for smoother movement
    between updates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想同步对象的运动和物理时，添加一个**网络变换**组件。它类似于更通用的`SyncVar`变量同步的快捷方式，并具有额外的智能插值，以在更新之间实现更平滑的运动。
- en: The **Network Manager** component is the glue that puts it all together. It
    handles the managing of connections, the spawning of objects across the network,
    and configuration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络管理器**组件是将其全部粘合在一起的关键。它处理连接管理、跨网络的对象实例化以及配置。'
- en: When new player objects are spawned, you can specify a spawn position in the
    Network Manager component. Alternatively, you can add game objects to your scene
    and give them a *Network Start Position* component, which can be used by the spawning
    system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的玩家对象被实例化时，你可以在网络管理器组件中指定一个实例化位置。或者，你可以在场景中添加游戏对象并给它们一个*网络起始位置*组件，该组件可以被实例化系统使用。
- en: Nonplayer objects that can get spawned can also be set in the Network Manager
    spawn list. Additionally, the Network Manager component handles scene changes
    and provides debugging information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被实例化的非玩家对象也可以在网络管理器的实例列表中设置。此外，网络管理器组件处理场景变化并提供调试信息。
- en: Related to the Network Manager component is the matchmaking functionality, using
    Unity Cloud Services, which can be configured to match up players to make them
    come together and start a game at the same time-a multiplayer lobby manager where
    players can set themselves as ready for the game to start, among other useful
    features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络管理器组件相关的是匹配功能，使用Unity云服务，可以配置以匹配玩家，使他们能够同时聚集并开始游戏——一个多人游戏大厅管理器，玩家可以在其中设置自己已准备好开始游戏，以及其他有用功能。
- en: Setting up a simple scene
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置简单场景
- en: Let's jump right in and make our own multiplayer demo project. For instructional
    purposes, we'll start out with a very simple scene with a standard first-person
    camera and get the networking implemented. Then, we'll synchronize multiple players'
    avatars over the network. And then we'll share a game object, a bouncy ball, between
    players to play a game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始制作自己的多人演示项目。出于教学目的，我们将从一个非常简单的场景开始，其中包含标准的单人第一人称摄像头，并实现网络功能。然后，我们将通过网络同步多个玩家的头像。然后，我们将共享一个游戏对象，一个弹跳球，让玩家玩游戏。
- en: Creating a scene environment
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景环境
- en: 'To get set up, we will make a new scene with a ground plane and a cube and
    create a basic first-person character. Perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置环境，我们将创建一个带有地面平面和立方体的新场景，并创建一个基本的单人第一人称角色。执行以下步骤：
- en: Create a new scene by navigating to File | New Scene. Then, File | Save Scene
    As... and name the scene `MultiPlayer`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到文件 | 新场景创建一个新的场景。然后，文件 | 另存为...并将场景命名为`MultiPlayer`。
- en: Remove the `Main Camera` and insert a copy of your `MeMyselfEye` prefab. Reset
    its Transform so it's positioned at the origin.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Main Camera`并插入你的`MeMyselfEye`预制件的副本。重置其变换，使其位于原点。
- en: Create a new plane by navigating to GameObject | 3D Object | Plane, rename it
    `GroundPlane`, and reset its Transform using the Transform component's *gear*
    icon | Reset. Make the plane bigger by setting Scale to (`10, 1, 10`).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到游戏对象 | 3D对象 | 平面创建一个新的平面，将其重命名为`GroundPlane`，并使用变换组件的*齿轮*图标 | 重置来重置其变换。通过设置缩放为(`10,
    1, 10`)来使平面更大。
- en: Make `GroundPlane` easier on the eyes. Drag your `Ground Material` onto the
    plane. If you need to create one, navigate to Assets | Create | Material, name
    it `Ground Material`, click on its Albedo color chip, and select a neutral color.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`GroundPlane`看起来更舒服。将你的`Ground Material`拖到平面上。如果你需要创建一个，导航到资产 | 创建 | 材质，命名为`Ground
    Material`，点击其Albedo颜色芯片，并选择一个中性颜色。
- en: To provide some context and orientation, we'll just add a cube. Navigate to
    GameObject | 3D Object | Cube, reset its Transform, and set its Position to the
    side, such as (`-2, 0.75, 1`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供一些上下文和方向，我们只需添加一个立方体。导航到游戏对象 | 3D对象 | 立方体，重置其变换，并将其位置设置为侧面，例如(`-2, 0.75,
    1`)。
- en: Give the cube some color. Drag your `Red Material` onto the cube. If you need
    to create one, Navigate to Assets | Create | Material, name it `Red Material`,
    click on its Albedo color chip, and select a nice red, such as RGB (`240, 115,
    115`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给立方体添加一些颜色。将你的`Red Material`拖到立方体上。如果你需要创建一个，导航到资产 | 创建 | 材质，命名为`Red Material`，点击其Albedo颜色芯片，并选择一个漂亮的红色，例如RGB
    (`240, 115, 115`)。
- en: Creating an Avatar head
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建头像头部
- en: 'Next, you''ll need an avatar to represent yourself and your friends. Again,
    I''m going to keep this super simple so that we can focus on the fundamentals.
    Forget about a body for now. Just make a floating head with a face. Here''s what
    I did. Your mileage may vary. Just be sure that it''s facing forward (the positive
    Z direction):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一个头像来代表你自己和你的朋友。同样，我会保持这个非常简单，这样我们就可以专注于基础知识。现在先不考虑身体。只需制作一个带有脸的漂浮头部。这是我做的。你的效果可能会有所不同。只需确保它面向前方（正Z方向）：
- en: Create an avatar container. Navigate to GameObject | Create Empty, rename it
    `Avatar`, reset its Transform, and set its `Position` to the eye level, such as
    (`0, 1.4, 0`).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个头像容器。导航到游戏对象 | 创建空对象，重命名为`Avatar`，重置其变换，并将其`位置`设置为眼睛水平，例如(`0, 1.4, 0`)。
- en: Create a sphere under the `Avatar` for the head (3D Object | Sphere), rename
    it `Head`, reset its transformation, and set Scale to (`0.5, 0.5, 0.5`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Avatar`下创建一个球体作为头部（3D对象 | 球体），重命名为`Head`，重置其变换，并将缩放设置为(`0.5, 0.5, 0.5`)。
- en: Give the head some color. Navigate to Assets | Create | Material, name it `Avatar
    Head Material`, click on its Albedo color chip, and select a nice red, such as
    RGB (`115, 115, 240`). Drag the `Avatar Head Material` onto the `Head`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给头部添加一些颜色。导航到资产 | 创建 | 材质，命名为`Avatar Head Material`，点击其Albedo颜色芯片，并选择一个漂亮的红色，例如RGB
    (`115, 115, 240`)。将`Avatar Head Material`拖到`Head`上。
- en: The dude has got to be cool (and bald headed). We'll borrow a pair of Ethan's
    glasses and put them on the head. Navigate to GameObject | Create Empty, as a
    child of `Avatar`, rename it `Glasses`, reset its Transform, and set its Position
    to (`0, -5.6, 0.1`) and Scale (`4, 4, 4`).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这家伙必须很酷（并且秃头）。我们将借用一副伊森的眼镜并戴在头上。导航到游戏对象 | 创建空对象，作为`Avatar`的子对象，重命名为`Glasses`，重置其变换，并将其位置设置为(`0,
    -5.6, 0.1`)和缩放(`4, 4, 4`)。
- en: Then, while `Glasses` is selected, go to the `Project` pane, drill down into
    the `Assets/Standard Assets/Characters/ThirdPersonCharacter/ Models` folder, unfold
    the `Ethan` prefab, find the `EthanGlasses.fbx` file (the mesh file), and drag
    it into the Inspector panel*.* Be sure to select the fbx version of `EthanGlasses`,
    not the prefab.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当 `Glasses` 被选中时，转到 `项目` 选项卡，深入到 `Assets/Standard Assets/Characters/ThirdPersonCharacter/Models`
    文件夹，展开 `Ethan` 预制体，找到 `EthanGlasses.fbx` 文件（网格文件），并将其拖入检查器面板*.* 请确保选择 `EthanGlasses`
    的fbx版本，而不是预制体。
- en: It has a mesh, but it needs a material. While `Glasses` is selected, go to the
    Project pane, find the `Assets/Standard Assets/Characters/ThirdPersonCharacter/Materials/`
    folder, find  ` EthanWhite`, and drag it into the Inspector.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有一个网格，但需要一个材质。当 `Glasses` 被选中时，转到项目面板，找到 `Assets/Standard Assets/Characters/ThirdPersonCharacter/Materials/`
    文件夹，找到  ` EthanWhite`，并将其拖入检查器。
- en: 'The following screenshot shows a version of mine (which also includes a mouth):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 mine 的一个版本（其中也包括了嘴巴）：
- en: '![](img/89e2e205-974f-47f8-82a2-e8efc8dc94bb.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89e2e205-974f-47f8-82a2-e8efc8dc94bb.png)'
- en: 'When running as multiplayer, an instance of the avatar will get spawned for
    each connected player. So, we must first save the object as a prefab and remove
    it from the scene, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当以多人游戏运行时，将为每个连接的玩家实例化一个头像实例。因此，我们必须首先将对象保存为预制体并将其从场景中删除，如下所示：
- en: With `Avatar` selected in the Hierarchy, drag it into your  Project `Assets/Prefabs`
    folder
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `Avatar` 并将其拖入您的  项目 `Assets/Prefabs` 文件夹
- en: Select `Avatar` again from the Hierarchy and delete it
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从层次结构中选择 `Avatar` 并删除它
- en: Save the scene
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景
- en: OK, now we should be ready to add multiplayer networking.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们应该准备好添加多人网络。
- en: Adding multiplayer networking
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多人网络
- en: To make the scene run as multiplayer, we need at a minimum a Network Manager
    component and we need to identify any objects that will get spawned using the
    Network Identity component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使场景以多人游戏运行，我们至少需要一个网络管理器组件，并且需要使用网络身份组件识别任何将被实例化的对象。
- en: Network Manager and HUD
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络管理器和HUD
- en: 'First, we''ll add the Network Manager component, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加网络管理器组件，如下所示：
- en: Create an Empty game object and name it `NetworkController`
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象并将其命名为 `NetworkController`
- en: Select Add Component | Network | Network Manager
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 添加组件 | 网络 | 网络管理器
- en: Select Add Component | Network | Network Manager HUD
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 添加组件 | 网络 | 网络管理器HUD
- en: We added a Network Controller HUD which displays a simplistic default menu,
    in screen space, that Unity offers to select the runtime networking options (you
    can see it in the images that follow). It's for development. In a real project,
    you'll probably replace the default HUD with something more interesting. And for
    VR, you'll want to make yours in world space.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个网络控制器HUD，它显示了一个Unity提供的简单默认菜单，在屏幕空间中，可以选择运行时网络选项（您可以在随后的图像中看到它）。它是用于开发的。在实际项目中，您可能会用更有趣的东西替换默认的HUD。对于VR，您希望在自己的世界中创建它。
- en: Network Identity and sync Transform
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络身份和同步变换
- en: 'Next, add a Network Identity to the `Avatar` prefab. We will also add a Network
    Transform, which instructs the networking system to synchronize the player''s
    Transform values to the avatar instances on each client, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `Avatar` 预制体添加一个网络身份。我们还将添加一个网络变换，指示网络系统将玩家的变换值同步到每个客户端上的头像实例，如下所示：
- en: In Project Assets, select the `Avatar` prefab
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资产中，选择 `Avatar` 预制体
- en: Navigate to Add Component | Network | Network Identity
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到添加组件 | 网络 | 网络身份
- en: Ensure the Local Player Authority checkbox is checked
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选“本地玩家权限”复选框
- en: 'We will now tell the `Avatar` to sync its Transform properties with all other
    players over the network, by adding an `Network Transform` component:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将告诉 `Avatar` 通过添加 `Network Transform` 组件与所有其他玩家通过网络同步其变换属性：
- en: Navigate to Add Component | Network | Network Transform
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到添加组件 | 网络 | 网络变换
- en: Ensure that Transform Sync Mode is set to Sync Transform
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保变换同步模式设置为同步变换
- en: And Rotation Axis is set to XYZ (full 3D)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且旋转轴设置为XYZ（完整3D）
- en: The Network Transform component is configured to share the actual Transform
    values with other player's instances of this object, including the full XYZ rotations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 网络变换组件被配置为与其他玩家实例的此对象的实际变换值共享，包括完整的XYZ旋转。
- en: 'Now, tell the `Network Manager` that our `Avatar` prefab represents players:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，告诉 `网络管理器` 我们的 `Avatar` 预制体代表玩家：
- en: In Hierarchy, select `NetworkController`
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择 `NetworkController`
- en: In Inspector, unfold the Network Manager Spawn Info parameters so that you can
    see the Player Prefab slot
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，展开网络管理器出生信息参数，以便可以看到玩家预制件槽位
- en: Drag the `Avatar` prefab from Project Assets onto the Player Prefab slot
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Avatar` 预制件从项目资源拖放到玩家预制件槽位
- en: Save the scene
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景
- en: Running as a host
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为主机运行
- en: 'Click on the Play mode. As shown in the following screenshot, the screen comes
    up with the HUD start menu, which lets you select whether you wish to run and
    connect this game:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放模式。如图所示，屏幕出现 HUD 启动菜单，允许你选择是否运行并连接此游戏：
- en: '![](img/e29b8521-b239-4f76-981e-5bdaba07b3a5.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e29b8521-b239-4f76-981e-5bdaba07b3a5.png)'
- en: Choose LAN Host (press *H* on keyboard). This will initiate a server (default
    port `7777` on `localhost`) and spawn an `Avatar`. The avatar is positioned at
    a default location, (`0, 0, 0`). Also, it's not connected to the camera. So, it
    is more like a third-person view. As mentioned above, for VR you'll eventually
    want to modify this default HUD to run in World Space.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 LAN 主机（按键盘上的 *H* 键）。这将启动一个服务器（默认端口 `7777` 在 `localhost` 上）并生成一个 `Avatar`。该头像位于默认位置（`0,
    0, 0`）。此外，它没有连接到相机。因此，它更像是第三人称视角。如上所述，对于 VR，你最终可能希望修改此默认 HUD 以在 World Space 中运行。
- en: The next thing to do is run a second instance of the game and see two spawned
    avatars in the scene. However, we wouldn't want them to overlap as both are positioned
    at the origin, so first we define a couple of spawn positions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要做的是运行第二个游戏实例，并在场景中看到两个生成的头像。然而，我们不想让它们重叠，因为它们都位于原点，所以首先我们定义几个出生位置。
- en: Adding spawn positions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加出生位置
- en: 'To add a spawn position, you just need a game object with a Network Start Position
    component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加出生位置，你只需要一个具有网络起始位置组件的游戏对象：
- en: Navigate to GameObject | Create Empty, rename it `Spawn1`, and set its Position
    to (`0, 1.4, 1`)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到游戏对象 | 创建空对象，将其重命名为 `Spawn1`，并设置其位置为 (`0, 1.4, 1`)
- en: Navigate to Add Component | Network | Network Start Position
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到添加组件 | 网络 | 网络起始位置
- en: Duplicate the object (Ctrl-D), rename it  `Spawn2`, and set its Position to
    (`0, 1.4, -1`)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制对象（Ctrl-D），重命名为 `Spawn2`，并设置其位置为 (`0, 1.4, -1`)
- en: In Hierarchy, select `NetworkController`. In Inspector,  Network Manager | Spawn
    Info | Player Spawn Method, select Round Robin
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择 `NetworkController`。在检查器中，网络管理器 | 出生信息 | 玩家出生方法，选择循环
- en: We now have two different spawn locations. The Network Manager will choose one
    or the other when a new player joins the game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的出生位置。网络管理器将在新玩家加入游戏时选择其中一个或另一个。
- en: Running two instances of the game
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行两个游戏实例
- en: A reasonable way to run two copies of the game on the same machine (`localhost`)
    is to build and run one instance as a separate executable and the other instance
    from the Unity Editor (the Play mode). Unfortunately, we cannot run both in VR.
    (Ordinarily, you can only run one VR device on a PC at a time, and one VR app
    on that device). So, we'll build one without VR, using a non-VR first-person controller,
    and run the editor version with VR enabled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一台机器（`localhost`）上运行两个游戏副本的合理方法是构建并运行一个实例作为独立的可执行文件，另一个实例从 Unity 编辑器（播放模式）运行。不幸的是，我们无法在
    VR 中同时运行它们。（通常，你一次只能在 PC 上运行一个 VR 设备，并在该设备上运行一个 VR 应用程序）。因此，我们将构建一个不带 VR 的版本，使用非
    VR 第一人称控制器，并启用 VR 运行编辑器版本。
- en: 'Add a standard first-person character to the scene, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准第一人称角色添加到场景中，如下所示：
- en: If you do not have the standard Characters assets package loaded, navigate to Assets | Import
    Package | Characters and choose Import
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有加载标准的 Characters 资产包，导航到 Assets | 导入包 | Characters 并选择导入
- en: Find the `FPSController` in the Project `Assets /Standard Assets/Characters/FirstPersonCharacter/Prefabs/` folder
    and drag it into the scene
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目 `Assets /Standard Assets/Characters/FirstPersonCharacter/Prefabs/` 文件夹中找到
    `FPSController` 并将其拖入场景
- en: Reset its Transform, and set it looking at the front of objects. Set Position to
    eye level, (`0, 1.4, 0`)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其 Transform，并使其朝向物体的前方。设置 Position 为眼睛水平，(`0, 1.4, 0`)
- en: With `FPSController` selected, in the Inspector, on the First Person Controller component,
    set Walk Speed to `1`
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `FPSController`，在检查器中，在第一人称控制器组件上，将行走速度设置为 `1`
- en: Disable`MeMyselfEye`
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用`MeMyselfEye`
- en: It can also be helpful to modify the XR Settings in Player Settings, by adding
    the SDK named `None` to the top of this list. This will cause projects to build
    and run without VR hardware even if you forget to uncheck the Virtual Reality
    Supported checkbox.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在玩家设置中修改 XR 设置来有所帮助，通过将名为 `None` 的 SDK 添加到列表的顶部。这将导致项目在没有 VR 硬件的情况下构建和运行，即使你忘记取消勾选虚拟现实支持复选框。
- en: 'Build the executable as usual. For standalone Windows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规构建可执行文件。对于独立Windows：
- en: Navigate to File | Build Settings....
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“文件”|“构建设置…”
- en: Ensure that the current scene is the only one checked in Scenes In Build. If
    it's not present, click on Add Open Scenes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保当前场景在“构建中的场景”中是唯一被勾选的。如果它不存在，点击“添加打开场景”。
- en: OpenPlayer Settings....
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开玩家设置...
- en: Under XR Settings, uncheck the Virtual Reality Supported checkbox.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“XR设置”下，取消勾选“虚拟现实支持”复选框。
- en: Under Resolution and Presentation, check the Run In Background checkbox as true.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“分辨率和显示”下，将“在后台运行”复选框勾选为真。
- en: Select Build and Run, give it a name. Subsequently, you can launch the game
    by double-clicking after it's built.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“构建和运行”，给它起个名字。随后，你可以通过双击构建后的文件来启动游戏。
- en: Enabling the Run In Background will permit the user input controls (keyboard
    and mouse) in each window when running the executables.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 启用“在后台运行”将允许在运行可执行文件时在每个窗口中输入用户控制（键盘和鼠标）。
- en: 'To run the game in Unity Editor, we need to reverse some of these settings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity编辑器中运行游戏，我们需要反转一些设置：
- en: In Hierarchy, disable `FPSController` and enable `MeMyselfEye`
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，禁用`FPSController`并启用`MeMyselfEye`
- en: In Player Settings, check the Virtual Reality Supported checkbox and move your
    SDK to the top of the list
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家设置中，勾选“虚拟现实支持”复选框，并将你的SDK移动到列表的顶部
- en: 'In one of your game windows, click on the Play mode and select LAN Host (H),
    like we did previously. Then, in the other window, select LAN Client (C). In each
    game, you should now see two instances of the avatar, one for each player, as
    shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏窗口之一中，点击播放模式并选择LAN主机（H），就像我们之前做的那样。然后在另一个窗口中，选择LAN客户端（C）。在每个游戏中，你现在应该看到两个头像实例，每个玩家一个，如下面的截图所示：
- en: '![](img/60190bd5-d23d-4621-bcaf-884af4b0a034.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60190bd5-d23d-4621-bcaf-884af4b0a034.png)'
- en: If you want to run an instance of the game on a separate machine, enter the
    IP address of the host machine into the Client input field (for instance, `10.0.1.14`
    on my LAN) instead of `localhost`. If each machine has its own VR device, they
    can each run the corresponding MeMyselfEye prefab as applicable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在另一台机器上运行游戏实例，将主机机的IP地址输入到客户端输入字段中（例如，我的LAN上的`10.0.1.14`），而不是`localhost`。如果每台机器都有自己的VR设备，它们可以分别运行相应的MeMyselfEye
    prefab。
- en: If you're running multiple instances of the project on a single machine, just
    set the LAN Client address to `localhost`. If you want to run on other machines
    on your network (including mobile devices), note the IP address of the LAN host
    machine and enter that value on the Client connections (for example, mine is `10.0.1.14`).
    A default value for this can even be added to your project's Network Manager component's
    Network Info | Network Address parameter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一台机器上运行多个项目实例，只需将LAN客户端地址设置为`localhost`。如果你想在你的网络上的其他机器（包括移动设备）上运行，注意LAN主机机的IP地址，并在客户端连接中输入该值（例如，我的LAN上的`10.0.1.14`）。甚至可以将此默认值添加到你的项目网络管理器组件的“网络信息
    | 网络地址”参数中。
- en: Associating Avatar with the first-person character
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Avatar与第一人称角色关联
- en: It's not very interesting if the avatars don't move. That's the next piece of
    this puzzle.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果头像不移动，那就没有多大意思。这是这个谜题的下一部分。
- en: You might think that we should have parented the avatar object under the player
    camera, (`MeMyselfEye` or `FPSController` ) and saved it as a Prefab, and then
    told the Network Manager to use that for spawns. But then, you'd end up with multiple
    cameras in the scene and controller scripts listening on user input. Not good.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我们应该将头像对象放在玩家相机下（`MeMyselfEye`或`FPSController`），并将其保存为Prefab，然后告诉网络管理器使用它进行生成。但那样的话，场景中会有多个相机和控制脚本监听用户输入，这并不好。
- en: 'We must have only one active player in the scene. Other players'' avatars get
    spawned but are not controlled here. In other words, when the local player (and
    only the local player) gets spawned, its avatar should become a child of the camera.
    To achieve this, we will write a script:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中必须只有一个活动的玩家。其他玩家的头像会被生成，但在这里不会被控制。换句话说，当本地玩家（只有本地玩家）被生成时，其头像应该成为相机的子对象。为了实现这一点，我们将编写一个脚本：
- en: In Project Assets, select `Avatar`, navigate to Add Component | New Script,
    and name it `AvatarMultiplayer`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资产中，选择`Avatar`，导航到添加组件 | 新脚本，并将其命名为`AvatarMultiplayer`
- en: 'Open and edit the `AvatarMultiplayer.cs` script, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开并编辑`AvatarMultiplayer.cs`脚本，如下所示：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing you'll notice is that we need to include the `using UnityEngine.Networking`
    namespace to access the networking API. Then, the class `AvatarMultiplayer` is
    derived from `NetworkBehaviour`, which internally is derived from `MonoBehaviour`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先会注意到，我们需要包含`using UnityEngine.Networking`命名空间以访问网络API。然后，`AvatarMultiplayer`类从`NetworkBehaviour`派生，而`NetworkBehaviour`内部是从`MonoBehaviour`派生的。
- en: '`NetworkBehaviour` provides additional callback functions. We are going to
    use `OnStartLocalPlayer`, which gets called whenever the local player object is
    spawned. However, it is not called when the remote player objects are spawned.
    Its declaration requires the `override` keyword.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkBehaviour`提供了额外的回调函数。我们将使用`OnStartLocalPlayer`，该函数在本地玩家对象被实例化时被调用。然而，当远程玩家对象被实例化时，它不会被调用。其声明需要`override`关键字。'
- en: '`OnStartLocalPlayer` is exactly what we want because only when a local player
    is spawned do we want to parent it to the camera. We access the current main camera
    object and make it the avatar''s parent (`transform.parent = camera.transform`).
    We also reset the avatar''s transform so that it''s centered at the camera''s
    position.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStartLocalPlayer`正是我们想要的，因为只有当本地玩家被实例化时，我们才希望将其与摄像头关联。我们访问当前主摄像头对象并将其设置为角色的父对象（`transform.parent
    = camera.transform`）。我们还重置了角色的变换，使其位于摄像头的位置。'
- en: Consider improving the script to specify the actual game object you want to
    parent your avatar.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑改进脚本以指定您想要将角色作为父对象的实际游戏对象。
- en: 'Run two instances of the game: Build & Run to execute one, and use the Play
    mode for the other. Control the player in one window, and it moves the avatar
    in the other. Wow! You can even launch more executables and have a party!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行两个游戏实例：一个用于构建和运行，另一个使用游戏模式。在一个窗口中控制玩家，它将在另一个窗口中移动角色。哇！您甚至可以启动更多可执行文件并举办派对！
- en: Depending on the size and local position of your avatar, its model objects (such
    as eye glasses) may be visible from the first person camera and obstruct the view.
    You can hide them by disabling the child graphics. But then, for example, you
    wont see your own shadow (which I like). Another option is to shift the avatar
    graphics backwards to ensure they don't obstruct the camera's view. Either way,
    this can be done in this `AvatarMultiplayer` script. Likewise, if your game gives
    each avatar a body, or chair, or whatnot, the current player's instance may not
    need or want all those graphic detail to be following them around.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的角色的大小和本地位置，其模型对象（如眼镜）可能从第一人称摄像头中可见并遮挡视线。您可以通过禁用子图形来隐藏它们。但这样，例如，您将看不到自己的影子（我喜欢）。另一个选项是将角色图形向后移动，以确保它们不会遮挡摄像头的视线。无论哪种方式，这都可以在`AvatarMultiplayer`脚本中完成。同样，如果您的游戏为每个角色提供了身体、椅子或其他东西，当前玩家的实例可能不需要或想要所有这些图形细节跟随他们。
- en: Adding a matchmaking lobby
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加匹配大厅
- en: So far, connecting two or more players over the network requires you to know
    the IP address of the host instance of the game that is running, or simply `localhost`
    if they're all running on the same machine.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，通过网络连接两个或更多玩家需要您知道正在运行的游戏主实例的IP地址，或者如果它们都在同一台机器上运行，则简单地使用`localhost`。
- en: Unity Networking and Cloud Services includes a built-in networking lobby manager
    for matchmaking between online players. It lets you create and join online "rooms,"
    limited to a maximum number of players. Using the lobby feature is as easy as
    choosing Enable Match Maker in the Network HUD in your app. But first, you must
    subscribe to Unity Multiplayer cloud services (free, with limits for the number
    of concurrent users, based on your Unity license).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Unity网络和云服务包括一个内置的网络大厅管理器，用于在线玩家之间的匹配。它允许您创建和加入在线“房间”，玩家数量有限。使用大厅功能与在应用程序中的网络HUD中选择“启用匹配器”一样简单。但首先，您必须订阅Unity多人云服务（免费，基于您的Unity许可证，对并发用户数量有限制）。
- en: 'To use it, first enable Unity Cloud Services for your app:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，首先为您的应用程序启用Unity Cloud Services：
- en: Above Inspector, select the Cloud icon (indicated in the following screenshot)
    to open the Services window
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器上方，选择云图标（如下截图所示）以打开服务窗口
- en: Create or choose a Unity Project ID for this project. To create an ID, click Select
    Organization and choose your organization, and then click Create.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此项目创建或选择一个Unity项目ID。要创建ID，请点击“选择组织”并选择您的组织，然后点击“创建”。
- en: Choose Multiplayer to open the multiplayer services panel
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择多人游戏以打开多人服务面板
- en: From there, open the web-based dashboard, where you're asked to specify the
    Max Players Per Room. Enter `4` and press Save
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，打开基于Web的仪表板，你将被要求指定每间房的最大玩家数。输入`4`并按保存
- en: 'A configured Multiplayer Services panel is shown here, with the Cloud services
    icon highlighted for your reference:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一个配置好的多人服务面板，云服务图标突出显示以供参考：
- en: '![](img/4efeb373-190d-45a3-a550-4efb051b51f0.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4efeb373-190d-45a3-a550-4efb051b51f0.png)'
- en: 'After enabling the services in your project, you may need to rebuild the executable
    (File | Build And Run) and then, in the first instance of the game:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中启用服务后，你可能需要重新构建可执行文件（文件 | 构建和运行），然后在游戏的第一个实例中：
- en: From the HUD menu choose Enable Match Maker (M)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从HUD菜单中选择启用匹配器（M）
- en: Type in a name for your room
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你的房间名称
- en: Choose Create Internet Match
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建互联网匹配
- en: 'In the second instance of the game:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的第二个实例中：
- en: From the HUD menu, also choose Find Internet Match
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从HUD菜单中，还可以选择查找互联网匹配
- en: Your room should appear as a new button
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的房间应作为一个新按钮出现
- en: 'Choose the Join: button for your room'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的房间的“加入”按钮
- en: You can now run the multiplayer game across the internet, letting Unity Services
    negotiate the IP addresses and maximum connections per room.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在互联网上运行多人游戏，让Unity服务协商IP地址和每间房的最大连接数。
- en: This will get you started. Of course, you have full control of the networking
    lobby matchmaking, like other Unity Networking services. And you most likely will
    want to make your own GUI. For documentation, see the NetworkManager API ([https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html](https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你开始。当然，你对网络大厅匹配制作有完全的控制权，就像其他Unity网络服务一样。你很可能想制作自己的GUI。有关文档，请参阅NetworkManager
    API（[https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html](https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html)）。
- en: Consider starting with the example Network Lobby free asset from Unity ([https://assetstore.unity.com/packages/essentials/network-lobby-41836](https://assetstore.unity.com/packages/essentials/network-lobby-41836)).
    Unfortunately this asset is out of date and has bugs, but you can get it to work (read
    the comments). Or at least, reference it as an example when writing your own UI.
    Also, it is a screen space UI; for VR, you would need to modify it to be a world
    space canvas.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从Unity的示例网络大厅免费资产开始（[https://assetstore.unity.com/packages/essentials/network-lobby-41836](https://assetstore.unity.com/packages/essentials/network-lobby-41836)）。不幸的是，这个资产已经过时并且有bug，但你可以使它工作（阅读评论）。或者至少，在编写自己的UI时将其作为示例参考。此外，它是一个屏幕空间UI；对于VR，你需要修改它以成为世界空间画布。
- en: An example of HUD code that seems up to date can be found in this forum comment: [https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400](https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个论坛评论中可以找到一个看起来最新的HUD代码示例：[https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400](https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400)
- en: Syncing objects and properties
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步对象和属性
- en: Let's play ball! Back in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing With Physics And Fire*, we implemented various ball games in VR. Now,
    we have the means to make a multiplayer one. We will make a game similar to the
    *Headshot* game, which uses your head as the paddle. But after this exercise,
    feel free to go and build multiplayer versions of the *Paddle Ball* and/or *Shooter
    Ball* games, which use a hand controller to hold and move a paddle to hit or deflect
    the ball.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始玩球！在[第8章](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml)，“与物理和火焰玩耍”中，我们实现了各种VR球类游戏。现在，我们有制作多人游戏的方法。我们将制作一个类似于*Headshot*的游戏，该游戏使用你的头部作为桨。但在这次练习之后，你可以自由地构建*Paddle
    Ball*和/或*Shooter Ball*游戏的多人版本，这些游戏使用手柄控制器来握住和移动桨来击打或反弹球。
- en: Also, since the objective here is to focus on the multiplayer networking considerations,
    we will leave out some details covered in the earlier chapter, such as sound effects,
    particles, and object pooling.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这里的目的是专注于多人网络考虑因素，我们将省略早期章节中的一些细节，例如音效、粒子效果和对象池。
- en: Setting up the headshot ball game
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置头像球游戏
- en: 'First, we''ll add the cube paddle to the Avatar head as the one and only Collider
    on the Avatar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把立方体桨添加到Avatar头部，作为Avatar上的唯一Collider：
- en: Drag a copy of the `Avatar` prefab into your Hierarchy for editing
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Avatar`预制体的副本拖动到你的层次结构中进行编辑
- en: For each of its children (`Head, Glasses`), disable the Collider if present
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于它的每个子项（`Head, Glasses`），如果存在则禁用Collider
- en: Create a new cube child of `Avatar` (Create | 3D Object | Cube) and name it
    `CubePaddle`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CubePaddle`的新立方体子对象（创建 | 3D对象 | 立方体），并将其命名为`CubePaddle`
- en: Reset its Transform and set its Scale to (`0.5, 0.5, 0.5`)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其变换并设置其缩放为（`0.5, 0.5, 0.5`）
- en: Disable the Cube's Mesh Renderer
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用立方体的Mesh Renderer
- en: Apply the Avatar changes back to its prefab (click Apply in Inspector)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Avatar更改应用到其预制件上（在检查器中点击应用）
- en: Delete it from Hierarchy
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中删除它
- en: 'Now, we''ll add a `GameController` object and a script that serves balls to
    the avatar at fixed intervals:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个`GameController`对象和一个以固定间隔向角色提供球体的脚本：
- en: Create an Empty game object at the Hierarchy root named `GameController`, and
    reset its Transform
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构根处创建一个名为`GameController`的空游戏对象，并重置其变换
- en: Add Component | New Script and name it `BallServer`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件 | 新脚本并将其命名为`BallServer`
- en: 'Open the script and write it as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开脚本并按照以下内容编写：
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this script, we play a new ball every 5 seconds. Each ball remains in the
    scene for 25 seconds (`interval * 5`). We use a coroutine, with `yield return
    new WaitForSeconds(interval)` to instantiate a new ball each interval.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们每5秒播放一个新的球。每个球在场景中保持25秒（`interval * 5`）。我们使用协程，通过`yield return new WaitForSeconds(interval)`在每个间隔中实例化一个新的球。
- en: 'We also create a list of `colors` and randomly choose one for this player when
    the game starts. All balls instantiated by this player will be this color. Create
    the list of colors to pick from:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`colors`列表，并在游戏开始时为该玩家随机选择一个颜色。该玩家实例化的所有球都将为此颜色。创建一个可供选择的颜色列表：
- en: On Ball Server component, unfold the Colors parameter
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在球服务器组件中，展开颜色参数
- en: Set Size to `4` or higher
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置大小为`4`或更高
- en: Define unique colors for each of the Element n color slots
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个元素的颜色槽定义独特的颜色
- en: 'The GameController component will look similar to this in Inspector:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: GameController组件在检查器中的外观将类似于以下内容：
- en: '![](img/a85e9964-4a9e-4a14-9207-cda2e5a5e12c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a85e9964-4a9e-4a14-9207-cda2e5a5e12c.png)'
- en: 'Create a bouncy ball. We''ll name it `NetworkBall` because in the next section
    we will share it across the network:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个弹跳球。我们将它命名为`NetworkBall`，因为在下一节中我们将在网络上共享它：
- en: Create 3D Object | Sphere, name it `NetworkBall`, and Scale (`0.5, ``0.5, 0.5`)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建3D对象 | 球体，将其命名为`NetworkBall`，并缩放（`0.5, 0.5, 0.5`）
- en: On its Sphere Collider, assign the `Bouncy` physic material to the Material
    slot
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其球体碰撞器上，将`Bouncy`物理材质分配到材质槽
- en: Add a `Rigidbody` component (Add Component | Physics | Rigidbody)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Rigidbody`组件（添加组件 | 物理 | Rigidbody）
- en: Drag `NetworkBall` into your Project Assets *Prefabs* folder to create a prefab,
    and delete the object from Hierarchy
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NetworkBall`拖动到你的项目资源*预制件*文件夹中创建一个预制件，并从层次结构中删除该对象
- en: Drag a `NetworkBall` from *Prefabs* onto Ball Prefab slot of the GameController's
    BallServer
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NetworkBall`从*预制件*拖动到GameController的BallServer的球预制件槽中
- en: Press Play. Locally, you'll get served balls from above, and you can deflect
    them with your head, just like we did in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。本地，你将从上方获得球，你可以用你的头将其反弹，就像我们在[第8章](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml)，*玩物理和火*中所做的那样。
- en: Spawning the ball over the network
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上生成球
- en: 'Other players in our networked game need to see the same balls you do. There
    are several steps to getting this going:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网络游戏中其他玩家需要看到与你相同的球。要实现这一点，需要几个步骤：
- en: First, when we instantiate a ball locally, we need to tell the network to also
    spawn it for all the players
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当我们本地实例化一个球时，我们需要告诉网络为所有玩家也生成它
- en: When the ball moves, is bounced or hit, its Transform must be updated for all
    the players
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球移动、弹跳或被击中时，其变换必须对所有玩家进行更新
- en: When the ball's life is done, it must be destroyed for all the players
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球的寿命结束时，它必须对所有玩家进行销毁
- en: 'In our present single-player version of the game, we instantiate new balls
    in the `BallServer` script. Let''s make it networked:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们目前单玩家版本的游戏中，我们在`BallServer`脚本中实例化新的球。让我们使其网络化：
- en: Open the `BallServer` script for editing
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BallServer`脚本进行编辑
- en: Add `using UnityEngine.Networking;` namespace at the top
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部添加`using UnityEngine.Networking;`命名空间
- en: Add a call to `NetworkServer.Spawn(ball);` once we have an instance created
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建实例后，添加对`NetworkServer.Spawn(ball);`的调用
- en: 'Then, we must register the `NetworkBall` prefab with the `NetworkManager` to
    inform it the prefab is spawnable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将`NetworkBall`预制件注册到`NetworkManager`中，以通知它预制件是可生成的：
- en: Select `NetworkController` in Hierarchy
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`NetworkController`
- en: In Inspector, unfold the Spawn Info parameters
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，展开Spawn Info参数
- en: Click + in the Registered Spawnable Prefabs list
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册的可生成预制件列表中点击+
- en: Drag a copy of `NetworkBall` onto the spawnable prefab Game Object slot
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NetworkBall`的副本拖动到可生成预制件游戏对象槽中
- en: 'The Network Manager component now looks like the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理组件现在看起来如下：
- en: '![](img/e932bb89-1992-48f0-bd5c-0790831b1735.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e932bb89-1992-48f0-bd5c-0790831b1735.png)'
- en: 'There''s one other thing that we did not handle yet: destroying ball instances.
    In the standalone version, we called `Destroy(ball, interval*5)` to destroy the
    ball after the given time. For network spawned objects, you will call `Network.Destroy(ball)` instead.
    However, there is not an equivalent version with a timer argument. You could write
    a countdown timer for it in BallServer, or use some other strategy for determining
    when its life cycle is complete and it can be destroyed (such as a DestroySelf
    script on the ball prefab itself) that runs locally.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一件事我们还没有处理：销毁球实例。在独立版本中，我们调用`Destroy(ball, interval*5)`在给定时间后销毁球。对于网络生成的对象，您将调用`Network.Destroy(ball)`代替。然而，没有带有计时器参数的等效版本。您可以在BallServer中为其编写倒计时计时器，或者使用其他策略来确定其生命周期何时完成并且可以被销毁（例如，在球预制件本身上的DestroySelf脚本）。
- en: Synchronizing the ball transform
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步球变换
- en: 'Unity Networking has a component to share this data between players,`Network
    Transform`, which we used earlier for syncing the Avatar head. Now, we''ll use
    it for the ball:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Networking有一个组件可以在玩家之间共享此数据，即`Network Transform`，我们之前用它来同步Avatar头部。现在，我们将用它来同步球：
- en: Select the `NetworkBall` prefab in Project Assets.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源中选择`NetworkBall`预制件。
- en: Add Component | Network Transform.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件 | 网络变换。
- en: Ensure the Transform Sync Mode is set to Sync Rigidbody/3D.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保变换同步模式设置为同步Rigidbody/3D。
- en: Adding Network Transform will add a Network Identity for you. Check its Local
    Player Authority checkbox.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加网络变换将为您添加一个网络身份。勾选其本地玩家权限复选框。
- en: 'The Network Transform parameters for `NetworkBall` are shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkBall`的网络变换参数如下所示：'
- en: '![](img/942a0b77-a304-4b76-9d48-9c9bef6a66c4.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/942a0b77-a304-4b76-9d48-9c9bef6a66c4.png)'
- en: Run two copies of your project now. *Voila!* When you connect the games on the
    network, the player's balls will be visible to all other players (*nsfw? Keep
    it clean guys*). The movement of each ball in the local game will control its
    transform on all the other game instances.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您项目的两个副本。*哇!* 当您在网络中将游戏连接起来时，玩家的球将对所有其他玩家可见（*nsfw？保持干净，伙计们*）。本地游戏中每个球的移动将控制其他所有游戏实例中的变换。
- en: Note that Unity is providing optimizations to limit the amount of data and frequency
    of updates while ensuring each player continues to see the same thing. For example,
    in the Network Transform, while you can sync an object's Transform position and
    rotation each update, you can also specify movement and velocity thresholds that
    signal when a sync is required. Perhaps more significant, you can choose what
    to sync. Instead of the Transform values themselves, you can sync changes in the
    Rigidbody physics (velocity, angular velocity, and so on), which happen much less
    often, and let each player's local game calculate the corresponding new Transform.
    This is the option we chose for the NetworkBall.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Unity正在提供优化，以限制数据量和更新的频率，同时确保每个玩家继续看到相同的内容。例如，在网络变换中，虽然您可以在每次更新时同步对象的变换位置和旋转，但您还可以指定移动和速度阈值，以指示何时需要同步。也许更重要的是，您可以选择要同步的内容。您不必同步变换值本身，可以同步Rigidbody物理（速度、角速度等）的变化，这些变化发生得较少，并让每个玩家的本地游戏计算相应的新变换。这就是我们为NetworkBall选择的选项。
- en: State variable synchronization
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态变量同步
- en: When we spawn an object over the network, it uses the prefab object we registered
    with the Network Manager. So the spawned balls all have the default color, not
    the one we set locally when the object was instantiated in BallServer. We'll use
    this as an opportunity to show how to synchronize other properties.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在网络上生成对象时，它使用与网络管理器注册的预制件对象。因此，生成的球都具有默认颜色，而不是我们在BallServer中实例化对象时在本地设置的颜色。我们将利用这个机会来展示如何同步其他属性。
- en: The example is a little contrived, but let's say we want the object color to
    be a state variable. (You could add others too, such as power, health, magic and
    so on.) We will write a script that tells the network to sync the properties across
    the network, if and when its value is changed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点牵强，但让我们假设我们想要对象颜色成为一个状态变量。（您也可以添加其他变量，例如功率、健康、魔法等。）我们将编写一个脚本，告诉网络在值更改时同步网络上的属性。
- en: The compiler `[SyncVar]` attribute identifies the property we want to sync and
    sets up an *observer*. If we include a `hook`, that function will be called by
    the observer when the value changes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器`[SyncVar]`属性标识了我们想要同步的属性，并设置了一个*观察者*。如果我们包含一个`hook`，那么当值发生变化时，观察者将调用该函数。
- en: 'On the `NetworkBall` prefab, create a new script named `StateVariables` and
    write it as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NetworkBall`预制体上，创建一个新的脚本名为`StateVariables`，并编写如下：
- en: '[PRE2]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class derives from `NetworkBehaviour`. We declare `color` with a `SyncVar`
    attribute. We provide a public setter function, `SetColor`, that can be called
    from other game objects as normal. Likewise, when the `color` variable is changed,
    it will be synchronized over the network. Remote copies running your game will
    call `OnColorChanged` to change that instance of the object too.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该类从`NetworkBehaviour`派生。我们使用`SyncVar`属性声明`color`。我们提供了一个公共设置函数`SetColor`，可以从其他游戏对象中正常调用。同样，当`color`变量发生变化时，它将通过网络同步。运行你的游戏的远程副本将调用`OnColorChanged`来更改该实例的对象。
- en: 'Now, we just need to modify the `BallServer` to set the color using this interface
    rather than modifying the material color directly. Modify the loop in the `DropBall`
    function to read as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改`BallServer`，使用这个接口来设置颜色，而不是直接修改材质颜色。修改`DropBall`函数中的循环，使其如下所示：
- en: '[PRE3]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now the server will not just spawn balls on the clients, but will then send
    its color property setting as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器不仅会在客户端生成球，还会发送其颜色属性设置。
- en: 'Here is a screenshot of live two-player HeadShot gameplay on our makeshift
    game court:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们临时游戏场的实时双人HeadShot游戏截图：
- en: '![](img/92b61774-5e4a-48c8-9426-aee68f71552f.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92b61774-5e4a-48c8-9426-aee68f71552f.png)'
- en: Using this basic pattern, you could extend this script to set and sync other
    variables representing the state of individual objects (heath, power, and so on)
    or the game itself (score, who's turn it is to serve, and so on).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本模式，你可以扩展这个脚本以设置和同步表示单个对象状态（健康、力量等）或游戏本身（得分、轮到谁发球等）的其他变量。
- en: Advanced networking topics
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级网络主题
- en: We have only touched the surface of what you can do with networking. If this
    interests you, I recommend you look closely at the Unity manual and go through
    their tutorials too. As we mentioned at the beginning of this chapter, a good
    place to start is the Unity Networking Concepts document ([http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了你可以用网络做到的事情的表面。如果你对此感兴趣，我建议你仔细阅读Unity手册，并完成他们的教程。正如我们在本章开头提到的，一个好的开始是Unity网络概念文档（[http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)）。
- en: It's important to understand Peer-to-Peer versus Client-Server versus Dedicated
    Server networking architecture. As we've seen, by default Unity Networking is
    Client-Server, with a player as the host Server (the player is also its own Client).
    You also have the option of setting up with a dedicated server running Unity as
    a standalone player in headless mode.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对等网络与客户端-服务器与专用服务器网络架构之间的区别非常重要。正如我们所见，默认情况下Unity网络是客户端-服务器，玩家作为主机服务器（玩家也是自己的客户端）。你还可以选择设置一个专用服务器，运行Unity作为独立玩家在无头模式下。
- en: 'Some other networking topics and issues include:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他的网络主题和问题包括：
- en: Synchronizing other serializable state variables ([https://docs.unity3d.com/Manual/UNetStateSync.html](https://docs.unity3d.com/Manual/UNetStateSync.html))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步其他可序列化状态变量（[https://docs.unity3d.com/Manual/UNetStateSync.html](https://docs.unity3d.com/Manual/UNetStateSync.html)）
- en: Client custom spawn functions ([https://docs.unity3d.com/Manual/UNetCustomSpawning.html](https://docs.unity3d.com/Manual/UNetCustomSpawning.html))
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端自定义生成函数（[https://docs.unity3d.com/Manual/UNetCustomSpawning.html](https://docs.unity3d.com/Manual/UNetCustomSpawning.html)）
- en: Spawning and controlling non-player characters (NPC) from a server
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器生成和控制非玩家角色（NPC）
- en: Further understanding when to use local player authority versus server authority
    ([https://answers.unity.com/questions/1440902/unet-local-player-authority.html](https://answers.unity.com/questions/1440902/unet-local-player-authority.html))
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步了解何时使用本地玩家权限与服务器权限（[https://answers.unity.com/questions/1440902/unet-local-player-authority.html](https://answers.unity.com/questions/1440902/unet-local-player-authority.html)）
- en: Calling Commands (client to server) versus  Remote Procedure Call (RPC) (server
    to client) ([https://docs.unity3d.com/Manual/UNetActions.html](https://docs.unity3d.com/Manual/UNetActions.html))
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用命令（客户端到服务器）与远程过程调用（RPC）（服务器到客户端）对比（[https://docs.unity3d.com/Manual/UNetActions.html](https://docs.unity3d.com/Manual/UNetActions.html)）
- en: Building your own multiplayer lobby ([https://docs.unity3d.com/Manual/UNetLobby.html](https://docs.unity3d.com/Manual/UNetLobby.html))
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的多人游戏大厅 ([https://docs.unity3d.com/Manual/UNetLobby.html](https://docs.unity3d.com/Manual/UNetLobby.html))
- en: Testing, debugging, and simulating networking conditions ([https://docs.unity3d.com/Manual/UNetManager.html](https://docs.unity3d.com/Manual/UNetManager.html))
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试、调试和模拟网络条件 ([https://docs.unity3d.com/Manual/UNetManager.html](https://docs.unity3d.com/Manual/UNetManager.html))
- en: Networking is not specifically a VR topic, but if you do embark on building
    a multiplayer networked VR application, you should spend time gaining an understanding
    of how data, messages, and commands are exchanged between client and server. VR
    includes its own unique networking challenges. The immediate, immersive experience
    of VR can amplify problems of latency, synchronization, and realism. We will also
    address some of these issues in the next chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 网络不是专门针对 VR 的主题，但如果你决定构建一个多人网络 VR 应用程序，你应该花时间了解客户端和服务器之间数据、消息和命令是如何交换的。VR 包括其独特的网络挑战。VR
    的即时、沉浸式体验可能会放大延迟、同步和现实感的问题。我们将在下一章中讨论一些这些问题。
- en: Options for voice chat
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音聊天的选项
- en: Once you have two or more people in the same VR space, it is natural to want
    to speak with one another. Almost all VR devices have headphones and microphones
    so the hardware support is ubiquitous.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当有两个人或更多人同时在同一个 VR 空间时，自然想要相互交谈。几乎所有的 VR 设备都配备了耳机和麦克风，因此硬件支持无处不在。
- en: 'Presently, Unity Networking does not support voice chat (VoIP). But there are
    other solutions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Unity Networking 不支持语音聊天 (VoIP)。但还有其他解决方案：
- en: Third-party packages such as *Dissonance Voice Chat* ([https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078](https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078))
    add voice chat over your existing network connection.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包，如 *Dissonance Voice Chat* ([https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078](https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078))，可以在你的现有网络连接上添加语音聊天功能。
- en: '*Photon Voice* ([https://assetstore.unity.com/packages/tools/audio/photon-voice-45848](https://assetstore.unity.com/packages/tools/audio/photon-voice-45848)). If
    you are already using **Photon Unity Networking** (**PUN**), this is the go-to
    package to use. If you are using Unity Network (UNet), then Photon Voice is not
    a great choice, or at least you''d need to establish separate connections for
    voice on the Photon network from your other networking.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Photon Voice* ([https://assetstore.unity.com/packages/tools/audio/photon-voice-45848](https://assetstore.unity.com/packages/tools/audio/photon-voice-45848))。如果你已经在使用
    **Photon Unity Networking** (**PUN**)，那么这个包是首选。如果你使用的是 Unity Network (UNet)，那么
    Photon Voice 可能不是最佳选择，或者至少你需要从你的其他网络中为 Photon 网络上的语音建立单独的连接。'
- en: '*Oculus VoIP* ([https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/](https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/)).
    If you are using the Oculus OVR Utilities for Unity (see next topic), you can
    add the Oculus VoIP SDK and its sister package, Oculus Lipsync.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Oculus VoIP* ([https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/](https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/))。如果你使用的是
    Oculus OVR Utilities for Unity（见下一主题），你可以添加 Oculus VoIP SDK 及其姐妹包 Oculus Lipsync。'
- en: Using Oculus platform and avatars
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Oculus 平台和头像
- en: It is worthwhile, and fun, to mention at this point the rich platform networking
    tools provided by Oculus for their VR devices. As a Facebook organization, Oculus
    obviously has a keen interest in making VR an engaging social experience. With
    Oculus Platform SDK ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/)),
    each user can create and use a personalized identity and avatar across Oculus
    games and apps, and find and connect with friends, all with a respectable degree
    of security and authentication.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上提及 Oculus 为其 VR 设备提供的丰富平台网络工具是值得的，也是有趣的。作为一个 Facebook 组织，Oculus 显然对使 VR
    成为一个引人入胜的社会体验有着浓厚的兴趣。通过 Oculus 平台 SDK ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/))，每个用户都可以在
    Oculus 游戏 和应用中创建和使用个性化的身份和头像，并找到并连接朋友，这一切都拥有可尊敬的安全性和认证度。
- en: Oculus Platform SDK Intro ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/))
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus 平台 SDK 简介 ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/))
- en: Oculus Platform Getting Started Guide ([https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/](https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/))
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus 平台入门指南 ([https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/](https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/))
- en: Oculus Avatar Getting Started Guide ([https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/](https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/))
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus Avatar 入门指南 ([https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/](https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/))
- en: Along with the basic Unity integration SDK, the Oculus development ecosystem
    includes Oculus Rooms with match-making, 3D ambisonic audio, voice chat, lip sync,
    and their integrated Oculus Avatar system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 Unity 集成 SDK 之外，Oculus 开发生态系统还包括带有匹配功能的 Oculus Rooms、3D 球面声、语音聊天、唇同步以及他们集成的
    Oculus Avatar 系统。
- en: 'In [Chapter 3](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml), *VR Build and Run*,
    we included a section on *Building for Oculus Rift*, where you may have set up
    your scene to include the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml)，“VR 构建和运行”中，我们包括了一个关于
    *为 Oculus Rift 构建* 的部分，您可能已经设置了场景以包含以下内容：
- en: Add `Oculus` SDK to the Virtual Reality SDKs in Player Settings
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Oculus` SDK 添加到玩家设置中的虚拟现实 SDK
- en: Import the *Oculus Integration package* from the Asset Store, which installs
    an OVR folder in your Project Assets ([https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022](https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022))
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从资产商店导入 *Oculus 集成包*，这将安装一个 OVR 文件夹到您的项目资产中 ([https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022](https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022))
- en: Use the `OVRCameraRig` prefab instead of `Main Camera` in `MeMyselfEye`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“MeMyselfEye”中，使用 `OVRCameraRig` 预制件而不是 `Main Camera`
- en: Oculus platform entitlement check
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oculus 平台权限检查
- en: To use the Oculus platform and cloud services, your app needs to be registered
    with Oculus.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Oculus 平台和云服务，您的应用需要在 Oculus 上注册。
- en: 'Register your app in the Developer Center in order to obtain an App ID, as
    follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者中心注册您的应用以获取 App ID，如下所示：
- en: In your browser, go to [https://dashboard.oculus.com/](https://dashboard.oculus.com/)
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，访问 [https://dashboard.oculus.com/](https://dashboard.oculus.com/)
- en: Select Create New App and choose the device, GearVR or Oculus Rift
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建新应用”并选择设备，GearVR 或 Oculus Rift
- en: Make a note of the App ID (copy into your clipboard), required to initialize
    the Platform SDK (if you need to revisit this page, it's located at Manage | your
    organization | your app | Getting Started API)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下 App ID（复制到您的剪贴板），这是初始化平台 SDK 所必需的（如果您需要再次访问此页面，它位于“管理”|“您的组织”|“您的应用”|“入门
    API”）
- en: Create a Test User by navigating to Manage | your organization | Settings |
    Test Users, and Add Test User
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到“管理”|“您的组织”|“设置”|“测试用户”，创建一个测试用户并添加测试用户
- en: 'Now in Unity, we need to configure your settings so it will pass the entitlement
    checks:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Unity 中，我们需要配置您的设置，以便它可以通过权限检查：
- en: Select Oculus Platform | Edit Settings from the main menu
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单选择“Oculus 平台”|“编辑设置”
- en: Paste your App ID into the corresponding slot in Inspector
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 App ID 粘贴到检查器中的相应槽位
- en: Under the Unity Editor Settings, check the Use Standalone Platform checkbox,
    and enter the Test User Email and Password generated by Add Test User previously
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器设置下，勾选“使用独立平台”复选框，并输入之前通过“添加测试用户”生成的测试用户电子邮件和密码
- en: 'Setting Use Standalone Platform will bypass your credential''s entitlement
    checks on the Oculus server when running in the Unity Editor. But otherwise, you
    need to add code for this to your project, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 设置“使用独立平台”将在 Unity 编辑器运行时绕过您的凭证权限检查在 Oculus 服务器上的检查。但否则，您需要将此代码添加到您的项目中，如下所示：
- en: On an object in your Hierarchy, such as `GameController`, create a script named
    `OculusEntitlementCheck`
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的层次结构中的对象上创建一个名为 `OculusEntitlementCheck` 的脚本，例如 `GameController`
- en: 'Write it as follows (derived from the Oculus docs):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写（源自 Oculus 文档）：
- en: '[PRE4]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding a local avatar
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加本地头像
- en: 'Now, we''ll add the Oculus Avatar to the scene for the local player. There
    are two avatar prefabs in the Project `Assets/OvrAvatar` folder: one for the local
    user, which may show just the player''s hands in first-person view, and one for
    the remote players. Note that the Oculus avatars will not appear in your Unity
    Scene window until you press play, as they are procedurally generated and (ordinarily)
    require a connection to the Oculus cloud server:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为本地玩家将Oculus Avatar添加到场景中。在项目`Assets/OvrAvatar`文件夹中有两个头像预制件：一个用于本地用户，在第一人称视图中可能只显示玩家的手，另一个用于远程玩家。请注意，Oculus头像将在您按下播放之前不会出现在您的Unity场景窗口中，因为它们是程序生成的，并且（通常）需要连接到Oculus云服务器：
- en: In Hierarchy, locate and unfold your `OVRCameraRig`. Notice it contains a child
    `TrackingSpace`
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“层次”中，找到并展开您的`OVRCameraRig`。注意它包含一个子项`TrackingSpace`
- en: From the Project Assets `OvrAvatar/Content/Prefabs/` folder, drag the `LocalAvatar`
    into the Hierarchy as a child of `TrackingSpace`
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“项目资源”`OvrAvatar/Content/Prefabs/`文件夹中，将`LocalAvatar`拖到层次中的`TrackingSpace`作为子项
- en: In Inspector, check the Start With Controllers checkbox
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，勾选“使用控制器开始”复选框
- en: Check the Show First Person checkbox
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“显示第一人称”复选框
- en: Press Play. You can now see your hands and controllers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。现在您可以看到您的手和控制器。
- en: Adding remote avatars
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加远程头像
- en: 'The Avatar SDK also uses the Oculus cloud services to get specific player''s
    avatar settings and preferences. Set the App ID for the Avatar SDK, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Avatar SDK还使用Oculus云服务来获取特定玩家的头像设置和偏好。按照以下方式设置Avatar SDK的App ID：
- en: Select Oculus Avatars | Edit Settings from the main menu
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择“Oculus头像”|“编辑设置”
- en: Paste your App ID into the corresponding slot in Inspector
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的App ID粘贴到检查器中相应的槽位
- en: 'This may not really be necessary right now if you''re OK with the default "blue"
    avatar, but we''ll need it for multiplayer networking. According to the Oculus
    docs:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对默认的“蓝色”头像感到满意，现在可能并不真正需要它，但我们在多人联网时将需要它。根据Oculus文档：
- en: Note: You may ignore any **No Oculus Rift App ID** warnings you see during development.
    While an App ID is required to retrieve Oculus avatars for specific users, you
    can prototype and test experiences that make use of Touch and Avatars with just
    the default blue avatar.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在开发过程中，您可能可以忽略任何**“无Oculus Rift App ID”**警告。虽然需要App ID才能为特定用户检索Oculus头像，但您可以使用默认的蓝色头像来原型设计和测试使用Touch和头像的体验。
- en: To add other player's avatars, we'll use the Oculus RemoteAvatar prefab. We
    need to set it up for Unity Networking like we did previously with our handmade
    one, including a Network Identity and Network Transform.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加其他玩家的头像，我们将使用Oculus RemoteAvatar预制件。我们需要像之前为我们手工制作的预制件那样设置它以用于Unity Networking，包括网络身份和网络变换。
- en: In the Project Assets `OvrAvatar/Content/Prefabs/` folder, select the `RemoteAvatar`
    prefab
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目资源”`OvrAvatar/Content/Prefabs/`文件夹中，选择`RemoteAvatar`预制件
- en: Choose  Add Component | Network | Network Identity
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加组件”|“网络”|“网络身份”
- en: Ensure the Local Player Authority checkbox is checked
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选“本地玩家权限”复选框
- en: Choose Add Component | Network | Network Transform
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加组件”|“网络”|“网络变换”
- en: Set Transform Sync Mode to Sync Transform
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Transform同步模式”设置为“同步变换”
- en: Set Rotation Axis to XYZ (full 3D)
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“旋转轴”设置为XYZ（完整3D）
- en: Select `Network Manager` in Hierarchy
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次中选择`Network Manager`
- en: Drag the `RemoteAvatar` onto the Network Manager's Player Prefab slot
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RemoteAvatar`拖到网络管理器的玩家预制件槽中
- en: 'We can also modify the `AvatarMultiplayer` script we wrote previously, which
    moves the local player''s avatar under the player camera. In the present case,
    we don''t really want to render the remote avatar but we do want other players
    to sync its Transform values, so we''ll disable the rendering as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改我们之前编写的`AvatarMultiplayer`脚本，该脚本将本地玩家的头像移动到玩家相机下。在这种情况下，我们并不真的想渲染远程头像，但我们确实想使其他玩家的变换值同步，因此我们将禁用渲染如下：
- en: '[PRE5]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, when two or more players join the same room, the players should be tracked
    and synchronized over the network. Here is a screen capture of an Oculus Avatar
    playing ball in our scene:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当两个或更多玩家加入同一个房间时，玩家应该通过网络进行跟踪和同步。以下是Oculus Avatar在我们的场景中玩球的屏幕截图：
- en: '![](img/26671fd8-03af-4a84-a310-79854ddec6ea.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26671fd8-03af-4a84-a310-79854ddec6ea.png)'
- en: Building and sharing custom VRChat rooms
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和共享自定义VRChat房间
- en: If your goal is simpler, to build a virtual reality world and share it with
    others as a shared social experience, you can use one of a number of existing
    social VR platforms that provide the infrastructure and allow customization. Among
    the best, VRChat is the only one that lets you create custom worlds and personalized
    avatar rigs using Unity.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标更简单，即构建一个虚拟现实世界并与他人共享作为共享社交体验，你可以使用许多现有的社交 VR 平台之一，这些平台提供基础设施并允许定制。在最好的平台中，VRChat
    是唯一一个让你可以使用 Unity 创建自定义世界和个性化角色装备的平台。
- en: VRChat is built with Unity, and you can use Unity to make custom worlds and
    avatars. If you haven't tried it, download a copy of the client from Steam ([http://store.steampowered.com/app/438100/VRChat/](http://store.steampowered.com/app/438100/VRChat/))
    and play around with it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: VRChat 是使用 Unity 构建的，你可以使用 Unity 来创建自定义的世界和角色。如果你还没有尝试过，请从 Steam（[http://store.steampowered.com/app/438100/VRChat/](http://store.steampowered.com/app/438100/VRChat/））下载客户端并尝试一下。
- en: As of this writing, VRChat requires the older Unity 5.6.3p1 version. (Download
    at [https://unity3d.com/unity/qa/patch-releases/5.6.3p1](https://unity3d.com/unity/qa/patch-releases/5.6.3p1).)
    Copy your project into a new folder before attempting to open it in an older version
    of Unity. You may get warnings, but go ahead. They're mostly pertaining to scripts
    and we will not be exporting scripts to VRChat.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 就本文所述，VRChat 需要旧的 Unity 5.6.3p1 版本。（在 [https://unity3d.com/unity/qa/patch-releases/5.6.3p1](https://unity3d.com/unity/qa/patch-releases/5.6.3p1)
    下载。）在尝试在旧版本的 Unity 中打开之前，将你的项目复制到一个新文件夹中。你可能会收到警告，但请继续。它们大多与脚本有关，而我们不会将脚本导出到 VRChat。
- en: To develop for VRChat requires you have an account on their site (not the same
    as your Steam account). Go to [https://www.vrchat.net/register](https://www.vrchat.net/register)
    to register.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 VRChat 开发，你需要在他们网站上有一个账户（不同于你的 Steam 账户）。前往 [https://www.vrchat.net/register](https://www.vrchat.net/register)
    进行注册。
- en: Preparing and building the world
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备和构建世界
- en: Before we begin, decide a scene to use in VRChat. Pick any Unity scene you want.
    It could be the `Diorama` playground that we used earlier in this book, the PhotoGallery
    from Chapter 9, *Making Interactive Spaces*, or something else.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，决定在 VRChat 中使用哪个场景。选择你想要的任何 Unity 场景。这可能是在本书中较早使用的 `Diorama` 游戏场，第 9
    章 *制作交互式空间* 中的 PhotoGallery，或者其他任何东西。
- en: Open the scene in Unity that you want to export.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你想要导出的 Unity 场景。
- en: Save a copy to a new name, such as `VRChatRoom`
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将副本保存为新名称，例如 `VRChatRoom`
- en: 'Download the VRChat SDK from [http://www.vrchat.net/download/sdk](http://www.vrchat.net/download/sdk)
    and check the documentation at [https://docs.vrchat.com/](https://docs.vrchat.com/)
    for the latest instructions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://www.vrchat.net/download/sdk](http://www.vrchat.net/download/sdk) 下载
    VRChat SDK，并查看 [https://docs.vrchat.com/](https://docs.vrchat.com/) 上的最新说明：
- en: Import the VRChat SDK package. Navigate to Assets | Import Package | Custom
    Package..., find your downloaded copy of `VRCSDK-*.package`, click on Open, and
    select Import
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 VRChat SDK 包。导航到 Assets | 导入包 | 自定义包...，找到你下载的 `VRCSDK-*.package` 复制件，点击打开，并选择导入
- en: Delete the camera object (`Main Camera`, or `MeMyselfEye`, or whatever it is
    named)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除相机对象（`Main Camera`、`MeMyselfEye` 或任何其他名称）
- en: From the Project `Assets/VRCSDK/Prefabs/World/` folder, add the `VRCWorld` prefab
    into the scene
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Project `Assets/VRCSDK/Prefabs/World/` 文件夹中，将 `VRCWorld` 预制件添加到场景中
- en: Spawn points define where players enter the scene. `VRCWorld`, by default, acts
    as a spawn point itself, so you can just position this object in the scene. Or,
    create other Empty game objects, position them where you like, and add them to
    the Spawns list in the `VRCWorld` VRC_SceneDescriptor component.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 生成点定义了玩家进入场景的位置。默认情况下，`VRCWorld` 充当生成点，因此你只需将此对象放置在场景中即可。或者，创建其他空游戏对象，将它们放置在你喜欢的地方，并将它们添加到
    `VRCWorld` VRC_SceneDescriptor 组件中的生成列表中。
- en: 'Take a look at the other VRC_SceneDescriptor parameters. Explanations can be
    found in the documentation at [https://docs.vrchat.com/docs/vrc_scenedescriptor](https://docs.vrchat.com/docs/vrc_scenedescriptor).
    The VRC_SceneDescriptor inspector is shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其他 VRC_SceneDescriptor 参数。解释可以在 [https://docs.vrchat.com/docs/vrc_scenedescriptor](https://docs.vrchat.com/docs/vrc_scenedescriptor)
    的文档中找到。这里显示了 VRC_SceneDescriptor 检查器：
- en: '![](img/30760ecb-e49e-4ebd-ada8-c7b1ede9d926.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30760ecb-e49e-4ebd-ada8-c7b1ede9d926.png)'
- en: 'Continue to prepare your scene for VRChat as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤继续准备你的 VRChat 场景：
- en: Log in to your VRChat account, via VRChat SDK | Settings
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 VRChat SDK | 设置登录你的 VRChat 账户
- en: Navigate to VRChat SDK | Show Build Control Panel and review the options there.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 VRChat SDK | 显示构建控制面板并查看那里的选项。
- en: Click the Setup Layers button, if present, to add the layers required by VRChat
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，点击“设置层”按钮以添加 VRChat 所需的层
- en: Click the Setup Collision Layer Matrix button, if present
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，点击“设置碰撞层矩阵”按钮
- en: Click the Enable 3D Spatialization button
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“启用 3D 空间化”按钮
- en: 'When you''re ready, you can test your world:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，你可以测试你的世界：
- en: Click the Test | New Build button to begin building a new test world
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“测试 | 新构建”按钮以开始构建新的测试世界
- en: A local version of VRChat will open in a window
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VRChat 的本地版本将在一个窗口中打开
- en: 'When you''re ready to publish the world in cyberspace:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好在虚拟空间中发布世界时：
- en: Click the Publish | New Build button
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“发布 | 新构建”按钮
- en: When prompted, enter the name, player capacity, description, and other information
    requested in the Game window in Unity
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，在 Unity 的游戏窗口中输入名称、玩家容量、描述和其他请求的信息
- en: The world will be uploaded to VRChat
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 世界将被上传到 VRChat
- en: You can manage your uploads via VRChat SDK | Manage Uploaded Content
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过 VRChat SDK | 管理上传内容来管理你的上传
- en: Your uploaded world will be private. You can use it in VRChat and invite others
    to join you, but otherwise it is not public. To go public with your uploaded content,
    you must email a request to `support@vrchat.net`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你上传的世界将是私有的。你可以在 VRChat 中使用它并邀请他人加入你，但除此之外它不是公开的。要使你的上传内容公开，你必须向 `support@vrchat.net`
    发送请求邮件。
- en: The VRC SDK provides a toolbox of components you can add to your scene, including
    pedestals, mirror reflections, YouTube videos, and even a combat system. To make
    your scene interactive, you can add your own scripts to objects with basic actions
    triggered by events in the world, including `OnSpawn`, `OnPickup`, `OnDrop`, and `OnAvatarHit`,
    to name just a few.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: VRC SDK 提供了一系列组件，你可以将其添加到你的场景中，包括基座、镜面反射、YouTube 视频，甚至战斗系统。为了使你的场景交互式，你可以向具有基本动作的对象添加自己的脚本，这些动作由世界中的事件触发，包括
    `OnSpawn`、`OnPickup`、`OnDrop` 和 `OnAvatarHit` 等，仅举几例。
- en: VRChat is one of the original social VR platforms and has proven itself with
    a strong community and longevity. It is a little rough around the edges but as
    an indie project, we have a great deal of respect and offer a lot of kudos! It
    is a good stable implementation that is community driven and welcomes user contributions
    of content.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: VRChat 是最初的社会虚拟现实平台之一，凭借强大的社区和持久性证明了自己的实力。它在边缘处略显粗糙，但作为一个独立项目，我们非常尊重并给予了很多赞誉！它是一个良好的稳定实现，由社区驱动，并欢迎用户贡献内容。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about networking concepts and architecture and used
    some of the many features of Unity's own multiplayer networking system. We built
    a simple scene and an avatar, keeping in mind that the intent is to allow the
    avatar's head movement to be synchronized with the player's head-mounted display.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了网络概念和架构，并使用了一些 Unity 自身多玩家网络系统的许多功能。我们构建了一个简单的场景和一个化身，考虑到意图是允许化身的头部运动与玩家的头戴式显示器同步。
- en: We then converted the scene to multiplayer, adding the Unity Network components,
    which simplifies the multiplayer implementation to just a handful of clicks. Having
    proven we can build a shared multiplayer experience with the avatars, we added
    a bouncy ball game object shared between players, providing the fundamentals for
    building a multiplayer networked game.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将场景转换为多玩家模式，添加了 Unity 网络组件，这简化了多玩家实现，只需几步点击即可完成。在证明我们可以使用化身构建共享的多玩家体验后，我们添加了一个玩家之间共享的弹跳球游戏对象，为构建多玩家网络游戏提供了基础。
- en: Next, we took a quick spin of the Oculus Avatar SDKs, replacing our spherical
    avatars with full bodied personalized ones from the Oculus Platform ecosystem. Finally,
    we stepped through how easy it is to create a virtual room in VRChat by exporting
    a scene that you can share almost instantly.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们快速浏览了 Oculus Avatar SDKs，用 Oculus 平台生态系统中完整的个性化化身替换了我们的球形化身。最后，我们展示了在
    VRChat 中创建虚拟房间是多么容易，只需导出可以几乎立即分享的场景。
- en: In the next chapter, we will dive into the technical details of optimizing your
    VR projects to run smoothly and comfortably in VR. We will consider the different
    areas that affect performance and latency, from model polygon count, to Unity
    scripting, to bottlenecks on the CPU and GPU processors.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解优化你的 VR 项目以在 VR 中平稳舒适运行的细节。我们将考虑影响性能和延迟的不同区域，从模型多边形数量到 Unity 脚本，再到
    CPU 和 GPU 处理器的瓶颈。
