- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we’ve been focusing on creating the app, but there is danger in going
    too far without introducing unit testing. In this chapter, we will focus on writing
    comprehensive and meaningful unit tests using best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development (TDD)
  prefs: []
  type: TYPE_NORMAL
- en: Some developers believe that unit tests should come *before* the code (TDD),
    but that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is crucial to creating robust applications and knowing that your
    app works before you ship it. It is also a critical aspect of debugging, telling
    you right away if something you just changed or added broke some aspect of your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate unit tests, you’ll want to use dependency injection so that you
    can mock up time-consuming services, such as APIs, databases, and so on. We’ll
    spend time with mocks, injected into our test classes, to ensure that we are processing
    data as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific topics in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Why create unit tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started creating unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSubstitute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need Visual Studio. You will also
    install two NuGet packages, as shown in the chapter itself. If you are going to
    enter the code as you go, you’ll want to start with the source from the previous
    chapter: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/UnitTests).'
  prefs: []
  type: TYPE_NORMAL
- en: Why create unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of tests you will want to run on a production app. These
    include unit tests (testing one small part of an app – typically, a method), integration
    tests (how well the parts of the program run together), UI tests (making sure
    that interacting with the UI acts as expected), and end-to-end tests (making sure
    the entire program works as expected).
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests** are a critical part of this process and are created for every
    method and every unit of logic. In fact, multiple tests are typically created
    for each unit, so that you can test the happy path, the sad path, and corner conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: The **happy path** is when the data is as expected. The **sad path** is when
    the data is predictably wrong (for example, the user does not enter a required
    field).
  prefs: []
  type: TYPE_NORMAL
- en: '`123` as the username).'
  prefs: []
  type: TYPE_NORMAL
- en: A key benefit of unit tests is that they make your code less *brittle*. Without
    unit tests, it is easy to get into a situation where a change over here breaks
    code over there, and you don’t know about the breakage until either you run the
    entire program or, worse, your customer finds it.
  prefs: []
  type: TYPE_NORMAL
- en: Key to all of this is that research has shown that it is easier and less expensive
    to fix a bug found during a unit test than it is to find bugs found later. For
    example, in the 1990s, Capers Jones analyzed data about bugs from more than 400
    software projects and found that the cost of fixing a bug increased by a factor
    of 6 to 7 for every phase of development.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, unit tests act as excellent documentation for your app, describing
    precisely what you expect to happen under a wide variety of situations. Unlike
    comments, which rust – that is, become out of sync with the code – unit tests
    can never depart from the code because they will break when your code changes
    in ways that make the expected outcome change.
  prefs: []
  type: TYPE_NORMAL
- en: Vote early and vote often
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to run all of your unit tests after every change you make to
    the code. You want to catch inadvertent and unwanted side effects as quickly as
    possible. However, for this to work, your unit tests must be *fast*. A suite of
    unit tests that take an appreciable amount of time to run will be used less often.
    The longer they take to run, the less frequently the programmer will run them.
  prefs: []
  type: TYPE_NORMAL
- en: Good unit tests are not only fast but also *isolated* from one another. That
    means that one unit test does not depend on the outcome or state of another –
    it should not matter what order they are run in.
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to be able to look at the outcome of unit tests and immediately identify
    what went wrong so that you can fix it quickly. To accomplish this, your unit
    tests should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test exactly one thing at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be well named
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you test more than one thing in a unit test and that test fails, you won’t
    know which of the things was the culprit. Well-named unit tests make it clear
    at a glance what they are testing and thus what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a bad unit test name: `DoesGetBuddiesWork`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good unit test name: `GettingBuddiesListDoesNotThrowAnException`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the test fails, a glance at the name of the *good unit test name* tells you
    exactly what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test names
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programmers use very rigid naming schemes for unit tests. For example,
    some will create the name by the name of the method followed by the condition
    followed by the expected outcome. So, you might have a name like this: `GetBuddiesList_WhenEmpty_ShouldNotThrowAnException`.'
  prefs: []
  type: TYPE_NORMAL
- en: These can be useful, as glancing at the name of the test gives you a lot of
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, as the program grows, so too will your set of unit tests. When you
    have hundreds (or even thousands), you’ll want to be able to zip through your
    tests so quickly that you don’t mind running them after each meaningful change,
    and when one or more fail, you want to know what was tested without having to
    open up the test and look.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, right-click on the solution and choose **Add New Project**.
    In the dialog box, use the dropdown to pick **UnitTest**. There are a number of
    unit test frameworks. The two most popular are the older **NUnit** and the newer
    **xUnit**. We’ll choose **xUnit Test Project**, as shown in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Selecting the unit test type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Selecting the unit test type
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `.Tests`, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Naming the test project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Naming the test project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** and select the .NET platform (this book will use .NET 7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will create your project as well as the first unit test class
    and method. Since this is generic, delete that class and create one called `PreferencesTests`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the project reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before doing anything else, we need to make `ForgetMeNotDemo.Tests` aware of
    the `ForgetMeNotDemo` project. To do so, right-click on the test project and select
    **Add** | **ProjectReference**, and check the box next to **ForgetMeNotDemo**,
    as shown in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Referencing ForgetMeNotDemo from the unit test project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Referencing ForgetMeNotDemo from the unit test project
  prefs: []
  type: TYPE_NORMAL
- en: With all that set up, we are ready to write our first unit test, designed only
    to ensure that the testing structure is in place and working.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This will not build. Please refer to the *Tweaking the project file* section
    that appears later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure all is right with the world, open `UnitTest1` and add a test method
    that must pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'xUnit tests come in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Facts**: These are invariants – they always take the same data and should
    always pass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theories**: These are a suite of tests that execute the same code but are
    given different input arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the theories. The first test we created, `MustBeTrue`, simply
    asserts that the value true is `true`. This makes a good first test, as it will
    test that your unit testing is set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To run this test, click on the **Test** | **Run All Tests** menu item – but
    be warned, *it* *won’t work!*
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this work, there is a bit of tweaking we have to do to the
    project file.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the project file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem is that your .NET MAUI `.csproj` project file lists the following
    `TargetFrameworks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the unit test project file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this discrepancy, exit Visual Studio and open your .NET MAUI project
    `.csproj` file using your favorite text editor (not Word or other programs that
    add special characters – I like to use Visual Studio Code, but whatever floats
    your boat). Modify `<TargetFramework>` to include .`net7.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re halfway there. The next issue is that we need to output the test as
    a DLL, but the output for the project is an EXE. The best way to fix this is to
    add a condition – only do the output as an EXE when the target framework is not
    7.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reopen Visual Studio and open the solution. Your test should work now.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, rename `UnitTest1` to `PreferencesTests`. Next, go to the menu and select
    **Test** | **Test Explorer**. This will open (surprise!) **Test Explorer**. Click
    the green *Play* button, as shown in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The Play button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – The Play button
  prefs: []
  type: TYPE_NORMAL
- en: 'Your project will build and Test Explorer will run your test, showing you results
    as shown in *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Test results
  prefs: []
  type: TYPE_NORMAL
- en: Reading down from the top, it shows that `ForgetMeNotDemo.Tests` has one test,
    and the green check indicates that all the tests in `ForgetMeNotDemo.Tests` have
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `ForgetMeNotDemo.Tests` will be a list of all the test classes – in this
    case, just the one, `PreferencesTests`, and this too shows that there is one test
    and that it passed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, inside `PreferencesTests` will be a list of each individual test, and
    again, the green check indicates the test passed.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you’ve created your first test, run it, and seen it pass!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s settle down to writing some tests for `ForgetMeNotDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: ForgetMeNotDemo unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we examine one ViewModel at a time, paying attention to the
    methods. We do this because what we want to test is the business logic, and if
    you’ve done it right, most of your business logic will be in a `ViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, turning our attention to `PreferencesViewModel`, we see the `Init()`
    method. The job of `Init` is to populate the `PreferenceList` collection. For
    now, we’ll ignore how it does this and just write a test to ensure that it does.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the triple-A pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, create an interface for `PreferenceService`, as described earlier
    in the book (open `PreferenceService`, right-click on the class name, and choose
    **Extract Interface**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic design pattern for unit tests is the **Arrange, Act, Assert** (**AAA**)
    pattern. That is, you set up your test (Arrange), then you call a method or two
    (Act), and then check to make sure you have the expected results (Assert). Let’s
    see this in action (note, this test has two flaws that will be discussed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set up `IPreferenceService`, which we’ll need to create `PreferencesViewModel`,
    and then we create an instance of that `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, we can call the `Init()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the results using Assert. Assert has many methods that you
    can use to test the success of your test. These include, but are not limited to,
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assert.True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.Equal<T>(T expected,` `T actual)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.InRange<T>(T actual, T low,` `T high)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.Null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.NotNull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.IsType<T>(object obj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.Empty(IenumerableCollection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.Contains<T>(T expected,` `Ienumerable<t> collection)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more too. The definitive list can be found at the `xUnit` repository:
    [https://github.com/xunit/assert.xunit/blob/main/Assert.cs](https://github.com/xunit/assert.xunit/blob/main/Assert.cs).
    The various Asserts are arranged as classes, each of which has a variety of `Assert`
    methods. A partial list is shown in *Figure 9**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – A partial list of Assert classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – A partial list of Assert classes
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are asserting that, after running `Init`, `PreferenceList`
    is not empty. Open **Test Explorer** and click on the **Run All Tests In View**
    button, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Run All Tests In View button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Run All Tests In View button
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests run, and Test Explorer gives us the results, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Test Explorer results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Test Explorer results
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what each numbered option in the figure means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] The number of tests'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] The number of tests that passed'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] The number of tests that failed'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] A summary and statement on how long the test took'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Each passed test in the context of where the text is located. A green check
    means that it passed, and a red x indicates that it failed. Notice that the time
    for each test is listed. Also note that the tests took at most 6 milliseconds,
    but the entire test suite took 408 ms. The difference is the overhead of beginning
    the test procedure. This will soon be swamped by the time for all the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s wrong with this test?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned previously that this test has two significant flaws. The first is
    that the call to `Init` may not populate `PreferenceList` because the service
    may return zero records. We’ll need to adjust for that by asserting instead that
    `PreferenceList` is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second, more important, problem is that the test depends on running `PreferenceService`.
    If we examine the code for `PreferenceService`, we see that the call to `GetPreferences`
    has a significant problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Right now, while developing the app, we are calling to `GetPreferencesMock`,
    which is just a method in `PreferenceService`. But that is not how we’ll finish
    the app. In [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216), we’ll convert this
    to make an API call. API calls can take an unpredictably long time, and potentially,
    can grind our test to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, we need a mock `PreferenceService` that both returns quickly
    and returns a predictable collection (or an empty collection if we want to test
    that eventuality).
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when testing, you need to interact with a method that takes an indeterminate
    amount of time, such as retrieving data from a database or, worse, retrieving
    data from an API (that is, over the internet rather than locally from your device).
  prefs: []
  type: TYPE_NORMAL
- en: Calling this kind of method can bring your unit test to a screeching halt, making
    it almost unusable. To avoid this, we create fake representations of the database
    or the API using an object called a **mock**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocks offer two advantages: they respond instantly and, perhaps as importantly,
    they respond predictably. Once written, they give the same input and mock will
    always provide the same output.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use mocks, we’ll need to implement dependency injection for some
    of our classes, so let’s start there.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, anytime we needed an object inside a class, we passed in the object
    or we created it in the body of the class. This creates a `PreferencesViewModel`,
    we need a `PreferenceService` object. The approach we’ve taken so far is to *new
    one up* in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection decouples the classes and allows for more powerful unit
    testing, as we’ll see when we continue the discussion of mocks. Rather than *newing-up*
    a `PreferenceService`, we want to pass in an interface and have .NET MAUI create
    it for us (that is, no calling function will add the interface to the constructor
    call – it will be done automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Not just for testing
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection can be used throughout your project, not only for unit
    tests. In fact, when combined with an **Inversion of Control** (**IoC**) container,
    dependency injection creates a powerful pattern for decoupling objects throughout
    the app. More on IoC containers later.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, we first need to create an `IPreferenceService` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Resharper
  prefs: []
  type: TYPE_NORMAL
- en: Everything I’m about to show uses **Resharper**, an essential tool for serious
    .NET MAUI programmers, but it is not free. You can certainly do all this by hand;
    it is just that Resharper makes it much easier. Since I highly recommend buying
    Resharper, I’ll show you how to do the following with that tool. (Please note,
    as a Microsoft MVP, I get my copy of Resharper for free.)
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to **Solution Explorer**, open **PreferenceService**, and follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the class name and choose **Refactor This**. A context menu
    will appear, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Refactor context menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Refactor context menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Extract Interface**, and a dialog box will appear as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Extracting the interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Extracting the interface
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check all the public methods and choose the **Its own file** radio
    button for where to move the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hey, presto! You’ll have an interface file in the same directory (`Services`),
    as shown in *Figure 9**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – New interface file in the Services folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – New interface file in the Services folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your new file and you’ll see a typical C# interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the original `PreferenceService`. Resharper was nice enough to designate
    that `PreferenceService` implements `IPreferenceService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Please make `PreferenceService.GetPreferencesMock` public.
  prefs: []
  type: TYPE_NORMAL
- en: With an interface, we can use constructor injection – that is, we can define
    that we’re going to pass an instance of the interface into the constructor, and
    then pass in anything that implements that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the class constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go back to `PreferencesViewModel`. Since we know we’re going to use dependency
    injection to send `PreferenceService` into `ViewModel`, we can modify the declaration
    of `PreferenceService` and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[1] We change the local service member to an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] We pass `IPreferenceService` into the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] We assign the member to the passed-in parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: But who calls `PreferencesViewModel` with the `IPreference` service, and where
    does that method get it?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the IoC container is responsible for all of this.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET MAUI IoC container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET MAUI has a built-in IoC container that we use by registering the interfaces
    we want to be managed. You do this in the `CreateMauiApp` method in `MauiProgram.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As seen in `[1]`, the first thing we do is instantiate a `MauiAppBuilder` object.
    We then tack a number of other configuration requirements onto the Builder.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use that to register all the interfaces to all our services. In fact,
    we’ll also register our views and ViewModels so that we can pass them into methods
    using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Registering your interfaces, services, and ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI provides an IoC container. By registering our interfaces, services,
    and so on, .NET MAUI will supply what we need when we need it, without our having
    to *new-up* instances. Beyond that, the IoC container will also fix up all the
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register the `IPreferences` interface, we add a call to `Builder.Services.AddTransient`,
    passing in the interface and the class that implements that interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Builder.Services` offers two ways to register your interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddTransient`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddSingleton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll use `AddTransient` when you may or may not instantiate the object (we
    may never look at the user’s preferences, and thus may never need the service).
    You use `AddSingleton` when you know you’ll want the object and there is no point
    in creating more than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re here, let’s register all the ViewModels. We don’t need interfaces
    for them, as we won’t be passing them anywhere via dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it together, this is what `CreateMauiApp` looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all the registration happens before we return the result of calling
    `Build` on the `Builder` object.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using dependency injection to inject mock objects where objects that
    would otherwise take an unpredictable amount of time would normally be used. That
    is, rather than waiting for a database or API call, we can inject a mock database
    or a mock service and get back a response instantly and predictably.
  prefs: []
  type: TYPE_NORMAL
- en: Our first decision is which mocking library to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NSubstitute package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of different mocking libraries available to you, some free
    and some commercial. For this book, we’ll use **NSubstitute**, an open source
    and free option available as a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your solution and choose **ManageNugetPackagesForSolution**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `NSubstitute`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first package you want is **NSubstitute** by Anthony Egerton et al., as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – NSubstitute NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – NSubstitute NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right, click on the project you want this added to (`ForgetMeNotDemo.Tests`)
    and click on **Install**, as shown in *Figure 9**.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Installing NSubstitute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Installing NSubstitute
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that installs, install **NSubstitute.Analyzers.CSharp**, as shown in the
    following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Selecting NSubstitute.Analyzers.CSharp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Selecting NSubstitute.Analyzers.CSharp
  prefs: []
  type: TYPE_NORMAL
- en: While not strictly required, this second library will detect potential mistakes
    in your use of NSubstitute. Install it into the test project as you did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Adding NSubstitute to your test fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add NSubstitute to your test fixture, add `using NSubstitute;` to the top
    of the C# file.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a substitute for `PreferenceService`.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks depend on constructor dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn to the constructor in `PreferencesViewModel` and notice that the service
    is injected as an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` `PreferencesViewModel(IPreferenceService service)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.service =` `service;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: This is critical. Mocks only work with constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our unit test, let’s declare a mock for the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Declare the mock for `IpreferenceService`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Pass that mock into the constructor for `PreferencesViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the test. It fails with the error that the collection cannot be null. Why?
  prefs: []
  type: TYPE_NORMAL
- en: The original service was returning a list of `Preference` objects, but our new
    mock is not. We need to teach the mock to return a predictable set of `Preference`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the top of the `Arrange` method, in which we create a couple of `Preference`
    objects and then add them to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create our substitute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Create the mock.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Tell the mock which method it will be mocking.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Tell the mock what to return when that method is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the mock in calling the `PreferencesViewModel` constructor, which you
    will remember takes `IpreferenceService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `Act` portion of the test, we’ll call `Init` on that `PreferencesViewModel`
    object and then assert that the list is not empty. This will work this time because
    the service it relies on can now be predicted to return a list of two preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Testing corner cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What happens if `PreferenceService` returns no records? Will that cause `ViewModel`
    to blow up? We can test that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Set up `List<Preference>` to be empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Have the service return the empty preferences list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Use `Record.ExceptionAsync` and pass in the call to `Init`. This will return
    the exception or null if none was thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Assert that there was no exception thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of all the uses of NSubstitute is available at [https://nsubstitute.github.io/help.html](https://nsubstitute.github.io/help.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the critical importance of writing unit tests and
    comprehensively testing your program. In a nutshell, unit tests allow you to code
    with confidence, knowing that if you make a change and it breaks something seemingly
    unrelated, you’ll find out about it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that, at times, your unit test must interact with slower external systems
    (APIs, databases, and more) and that you can keep your subsecond response time
    by using mocks; the mocking library we chose is `NSubstitute`, though there are
    other free mocking systems as well (a very popular one is **Moq**).
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate using mocks, we looked at dependency injection and briefly
    reviewed the role of IoC containers. In the next chapter, *Consuming a Rest Service*,
    we will look at getting our data from a cloud-based (Azure) service, rather than
    mocking the data.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it important to write unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is most of the code you will test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you use mocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is dependency injection important for mocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identify a method in the ViewModel or service that interacts with the API or
    database, and write a unit test that uses a mock.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part, we will dive into ninja-level topics, including how to interact
    with a REST-based service (in our case, Azure) and how to modify the appearance
    of our app based on the runtime data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19723_10.xhtml#_idTextAnchor187), *Consuming REST Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19723_11.xhtml#_idTextAnchor216), *Exploring Advanced Topics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
