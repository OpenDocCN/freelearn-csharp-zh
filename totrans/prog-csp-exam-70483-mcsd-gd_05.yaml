- en: Creating and Implementing Events and Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on events and callbacks in C#. They are important to understand
    since they give us more control over programs. An event is a message or notification
    from an object when either its property has been changed or a button has been
    clicked. A callback, also known as a delegate, holds a reference to a function.
    C# comes with Lambda expressions, which can be used to create delegates. These
    are also called anonymous methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will also spend some time looking at a new operator, known as a Lambda operator.
    These are used in Lambda expressions. They were introduced in version 3.0 of C#
    so that developers could instantiate delegates. Lambda expressions replaced the
    anonymous methods that were introduced in C# 2.0 and are now widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling and raising events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know what delegates are and how you can
    use them in events and callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from 7.0 onward
    require that you have Visual Studio 2017 installed.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of the aforementioned products, you can
    download the community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **delegate** is nothing but a reference to a method, along with some parameters
    and a return type. When a delegate is defined, it can be associated with any instance
    that provides a compatible signature and a return type of the method. In other
    terms, delegates can be defined as function pointers in C and C++. However, delegates
    are type-safe, secure, and object-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: A delegate model follows the observer pattern, which allows the subscriber to
    register with and receive notifications from the provider. To get a better understanding
    of the observer pattern, take a look at the references provided at the end of
    this chapter, in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of a delegate is event handlers in a Windows application,
    which are methods that are invoked by delegates. In the context of events, a delegate
    is an intermediary between the event source and the code that handles the event.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are ideal for callbacks because of their ability to pass methods as
    parameters. Delegates are derived from the `System.Delegate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of `delegate` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a delegate declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the delegate that's been defined can be referenced
    by any method that has a single string parameter and returns a string variable.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The named method can be used to a when we're using versions of C# prior to 2.0\.
    Version 2.0 introduced a new way to instantiate delegates. We will try to understand
    these methods in the upcoming sections. Version 3.0 of C# replaces anonymous methods
    with Lambda expressions, which are now widely used.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating delegates using NamedMethod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example of `NamedMethod` so that we can understand how to
    initiate a `delegate`. This is the method that was used prior to C# 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we defined a delegate called `MathDelegate`, which
    accepts `2` parameters, `1` integer and another double type. Then, we defined
    a class where we wanted to invoke `MathDelegate` using a named method known as
    `Multiply`.
  prefs: []
  type: TYPE_NORMAL
- en: The `MathDelegate d = m.Multiply;` line is where we assigned a named method
    to a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Named method delegates can encapsulate a static or instance method with any
    accessible class or structure that matches the type of delegate. This allows the
    developer to extend these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will see how a delegate can be mapped to static
    and instance methods. Add the following method to the `Chapter5Samples` class
    we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined two methods: the first one is a normal method,
    while the second one is a static method. In the case of invoking delegates using
    a named method, we can either use the first normal method or the second static
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SampleDelegate d = helper.InstanceMethod;`: This is a normal method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d = HelperClass.StaticMethod;`: This is a static method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating a delegate using anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a situation where creating new methods can be classed as overhead, C# allows
    us to initiate a delegate and specify a code block. The delegate will process
    this code block when it is invoked. This is the method that's used in C# 2.0 to
    invoke delegates. They are also known as anonymous methods.
  prefs: []
  type: TYPE_NORMAL
- en: An expression or a statement that's defined inline instead of a delegate type
    is known as an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at these two types of functions in the upcoming subsections. However,
    before we move on, we should also understand one new operator, called the **Lambda
    operator**. This is used to represent Lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With C# 3.0, Lambda expressions were introduced and are widely used in invoking
    delegates. Lambda expressions are created using Lambda operators. On the left-hand
    side of the operator, we specify the input parameters, while on the left-hand
    side, we specify the expression or code block. When a Lambda operator is used
    in an expression body, it separates the member's name from the member's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda operator is represented as a `=>` token. This operator is right-associative
    and has the same precedence as an assignment operator. An assignment operator
    assigns a right-hand operand value to a left-hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are using a Lambda operator to compare a specific
    word in a string array and return it. Here, we are applying a Lambda expression
    to each element of the `words` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example also shows how we can use a LINQ query to get the same output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are trying to find "apple" from an array of words using a LINQ query. Any
    enumerable collection allows us to query using LINQ and returns the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A Lambda expression is the right-hand side operator of a Lambda operator and
    is widely used in expression trees.
  prefs: []
  type: TYPE_NORMAL
- en: More information on expression trees can be on the Microsoft documentation website.
  prefs: []
  type: TYPE_NORMAL
- en: This Lambda expression must be a valid expression. If the member type is void,
    it's classed as a statement expression.
  prefs: []
  type: TYPE_NORMAL
- en: From C# 6 onward, these expressions support method and property get statements,
    while from C# 7 onward, these expressions support constructors, finalizers, property
    set statements, and indexers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are using an expression to write the first name and
    last name of the variable and we have also used the `Trim()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this basic understanding of Lambda expressions and the Lambda operator,
    we can move on and look at how we can use Lambda expressions to invoke a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that a Lambda expression can be represented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, two extra lines have been added to the existing method
    to invoke the delegate using a Lambda expression. `X` is the input parameter,
    where the type of `X` is identified by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# 2.0 introduced anonymous methods, while C# 3.0 introduced Lambda expressions,
    which were later replaced with anonymous methods.
  prefs: []
  type: TYPE_NORMAL
- en: One case where anonymous methods provide functionality that isn't possible when
    using a Lambda expression is that they allow us to avoid parameters. These allow
    anonymous methods to be converted into delegates with a number of different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to use anonymous methods to initiate a delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined a string delegate and wrote some inline code
    to invoke it. The following is the code where we defined the inline delegate,
    also known as an anonymous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how we can create an anonymous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a code block and passed it as a `delegate` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: An anonymous method will throw an error if the runtime encounters any jump statements,
    such as `goto`, `break`, or `continue`, inside the code block and the target is
    outside the code block. Also, in a scenario where a jump statement is outside
    the code block and the target is in it, with the `int` anonymous method, an exception
    will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any local variables that are created outside of the delegate''s scope and contained
    in an anonymous method declaration are called *outer* variables of the anonymous
    method. For example, in the following code segment, `n` is an outer variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous methods are not allowed on the left-hand side of the is operator.
    No unsafe code can be accessed or used in an anonymous method, including the `in`,
    `ref`, or `out` parameters of an outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: Variance in delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# supports variance in delegate types with matching method signatures. This
    feature was introduced in .NET Framework 3.5\. This means delegates can now be
    assigned with matching signatures but also that methods can return derived types.
  prefs: []
  type: TYPE_NORMAL
- en: If a method has a return type derived from the one defined in a delegate, it
    is defined as covariance in delegates. Similarly, if a method has fewer derived
    parameter types than those defined in a delegate, it is defined as contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example to understand covariance. For the purpose of this example,
    we will create a few classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will create the `ParentReturnClass`, `Child1ReturnClass`, and `Child2Return`
    classes. Each of these has a string type property. Both child classes are inherited
    from `ParentReturnClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add two new methods to the previously defined helper class, each
    returning the respective child classes we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define a delegate that returns `ParentReturnClass`. We''ll also
    define a new method that will initiate this delegate for each of the child methods.
    One important point to observe in the following code is that we have used explicit
    typecast to convert `ParentReturnClass` into `ChildReturnClass1` and `ChildReturnClass2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the delegate is returning `ParentReturnClass`. However,
    both `ChildMethod1` and `ChildMethod2` are returning child classes that were inherited
    from `ParentReturnClass`. This means that methods that return more derived types
    than those defined in the delegate are permitted. This is called covariance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at another example to understand contravariance. Extend the
    previously created helper class by adding a new method that accepts `ParentReturnClass`
    as a parameter and returns void:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a delegate that accepts `Child1ReturnClass` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a method to initiate the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because method one works with the parent class, it will definitely work with
    the class that is inherited from the parent class. C# permits fewer derived types
    as parameters than those defined in the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how we can create custom delegates and use them in our
    program. C# comes with a couple of built-in delegates, which developers can use
    instead of having to create custom delegates. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Func` takes zero or more parameters and returns one value as an `out` parameter,
    whereas `Action` accepts zero or more parameters but returns nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no requirement to declare an explicit delegate when working with `Func`
    or `Action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Action` can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, both take zero or more parameters. C# supports 16 different
    forms of both delegates, all of which can be used in our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form of `Func` with two or more parameters is as follows. It takes
    comma-separated in and out parameters, where the last parameter is always an out
    parameter called `TResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `Func`, here is the general form for `Action` with two or more parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Multicast delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Invoking more than one method through a delegate is called multicasting. You
    can use `+`, `-`, `+=`, or `-+` to add or remove methods from the list of invoking
    methods. This list is called the invocation list. It's used in event handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we can invoke multiple methods by invoking
    a delegate. We have two methods, both of which accept a string parameter and display
    it on the screen. In the multicast delegate method, we are associating two methods
    with `stringdelegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Handling and raising events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the introduction of this chapter, events are any actions,
    such as a keypress, mouse movement, or I/O operation, performed by the user. Sometimes,
    events can be raised by system-generated operations such as creating/updating
    a record in a table.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework events are based on the delegate model, which follows the observer
    pattern. The observer pattern allows a subscriber to register for notifications
    and a publisher to register for push notifications. It's like late binding and
    is a way for an object to broadcast that something has happened.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern that allows you to subscribe/unsubscribe to a stream of events
    coming from a publisher is called an observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous chapter, we worked on a code snippet where the
    program finds whether the character that was entered by the user is a vowel or
    not. Here, the user pressing a key on the keyboard is the publisher, which notifies
    the program regarding which key was pressed. Now, our program, which is a subscriber
    to the provider, responds to it by checking whether the character that was entered
    was a vowel or not and displays it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: A message that's sent by an object to notify it that an action has occurred
    is called an event. The object that raises this event is called an event sender
    or publisher. An object that receives and responds to an event is called a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: A publisher event can have multiple subscribers, while a subscriber can handle
    publishing events. Remember that multicast delegates, which we discussed in the
    previous sections, are extensively used in events (publish-subscribe pattern).
  prefs: []
  type: TYPE_NORMAL
- en: By default, if a publisher has multiple subscribers, all are invoked synchronously.
    C# supports calling these event methods asynchronously. We will understand this
    in more detail in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into an example, let''s try to understand a few of the terms
    we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `event` | This is a keyword that''s used to define an event in the `publisher`
    class in C#. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventHandler` | This method is used to handle an event. This may or may
    not have event data. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventArgs` | It represents a base class for the class that contains event
    data. |'
  prefs: []
  type: TYPE_TB
- en: 'Event handlers support two variations: one with no event data and another with
    event data. The following code represents a method that handles an event with
    no event data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code represents a method that handles an event with event data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at an example and try to understand how we can raise events and handle
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we are going to have a banking application where customers
    make transactions such as creating new accounts, looking at their credit and debit
    amounts, and making requests for their total balance. We will raise events whenever
    such a transaction is made and notify the customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with an `Account` class (`publisher` class), along with all the
    supporting methods, such as `credit()`, `debit()`, `showbalance()`, and `initialdeposit()`.
    These are the types of transactions a customer can operate their account with.
    Because the customer needs to be notified whenever such a transaction happens,
    we will define an event and an event handler with event data to handle the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have observed the new class that we used in the previous example, that
    is, `TrasactionEventArgs`. This class carries event data. We are going to define
    this class now, which inherits from the `EventArgs` base class. We are going to
    define two variables, `amt` and `type`, to carry variables to the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define a subscriber class to test how our event and event handler
    work. Here, we will define an `AlertCustomer` method whose signature matches the
    delegate that was declared in the `publisher` class. Pass a reference of this
    method to the delegate so that it reacts to the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the preceding program, for each transaction made, a transaction
    handler event is raised that invokes the notify-customer method and displays what
    type of transactions took place on the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about delegates and how we can define, initiate,
    and use them in our program. We understood variance in delegates, built-in delegates,
    and multicast delegates. Finally, we looked at how delegates form the base for
    events before understanding events, event handlers, and `EventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can say that events encapsulate delegates and that delegates encapsulate
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about multithreading and asynchronous processing
    in C#. We will understand and use threads in our program, and understand tasks,
    parallel classes, async, await, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates are ideal for ___ because of their ability to pass a method as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multicast delegates
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Built-in delegates
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different ways to initiate delegates? Choose all that apply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anonymous methods
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Named methods
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method can have a derived return type than the one defined in the delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anonymous method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Anonymous function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda expression
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which built-in delegate accepts zero or more parameters and returns void?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Action`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Func`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`event`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`delegate`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is used in the declaration of a C# event?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`event`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`delegate`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EventHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`class`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A subscriber can notify the publisher about a change that happened to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Callbacks**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**All of the above**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Covariance**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Action**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**event**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**False**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a better understanding of the observer pattern, please take a look at
    [https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a good article that talks about declaring, initiating, and
    using delegates. Samples can also be found there: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate).'
  prefs: []
  type: TYPE_NORMAL
