<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Concepts of Building an API</h1>
                
            
            
                
<p class="mce-root">The previous chapter went through the implementation of the HTTP layer of the web service. Although the core functionalities of the service are already in place, there are still some refinements to cover. This chapter provides a walk-through of some additional implementations that will be a part of the catalog web service<em>,</em> such as soft deleting resources, the HATEOAS approach, adding a response-time middleware, and some of the best practices for asynchronous code in ASP.NET Core. More specifically, it will cover the following topics:</p>
<ul>
<li>Implementing the soft delete technique</li>
<li>Implementing HATEOAS</li>
<li>An overview of asynchronous code in ASP.NET Core</li>
<li style="font-weight: 400">Measuring the response time of APIs using middleware</li>
</ul>
<p>The code present in this chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the soft delete procedure</h1>
                
            
            
                
<p>As mentioned in the <em>Deleting resources</em> section of <a href="deede298-fc20-4523-afa6-02ed2c0592fd.xhtml">Chapter 5</a>, <em>Web Service Stack in ASP.NET Core</em>, the soft delete technique is a widespread deletion practice in real-world applications. Furthermore, it is quite uncommon to physically delete entities from our data source.</p>
<p>Deleted data may be relevant for historical purposes and for performing analysis and reports. The soft delete implementation involves all the projects we have seen in the previous three chapters. In order to proceed, let's add a new <kbd>IsInactive</kbd> field to our <kbd>Item</kbd> entity inside the <kbd>Catalog.Domain</kbd> project:</p>
<pre>namespace Catalog.Domain.Entities<br/>{<br/>    public class Item<br/>    {<br/>        ...<br/>        <strong>public bool IsInactive { get; set; }</strong><br/>    }<br/>}</pre>
<p>Since we changed the schema of the <kbd>Item</kbd> entity, we need to perform another EF Core migration by executing the following commands inside the <kbd>Catalog.API</kbd> project:</p>
<pre>dotnet ef migrations add Added_IsInactive_field<br/>dotnet ef database update</pre>
<p>The result of the execution of the aforementioned command will generate a new migration file inside the <kbd>Migrations</kbd> folder and the application of the newly created migration in the database specified in the connection string of the <kbd>Startup</kbd> class.</p>
<p>Furthermore, as we saw in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, if we want to connect to the local Docker SQL Server instance, we can specify the following connection string in the <kbd>appsettings.json</kbd> file:</p>
<pre>{<br/>    "Logging": {<br/>        "LogLevel": {<br/>            "Default": "Warning"<br/>        }<br/>    },<br/><strong>    "DataSource": {</strong><br/><strong>        "ConnectionString": "Server=localhost,1433;Initial Catalog=Store;User Id=catalog_srv;Password=P@ssw0rd"<br/>    }</strong><br/>}</pre>
<p>The preceding connection string provides the connection to the local instance of SQL Server. In order to run the instance, it is necessary to follow the command we saw in Chapter 8. The following runs the docker instance using the name sql1:</p>
<pre>docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=&lt;YOUR_SA_PASSWORD&gt;" -p 1433:1433 --name sql1 -d mcr.microsoft.com/mssql/server:2017-latest</pre>
<p>Furthermore, we can log in into the container using the following command:</p>
<pre>docker exec -it sql1 "bash"</pre>
<p>and finally, we can execute the <kbd>sqlcmd</kbd> in order to log in into the SQL server instance:</p>
<pre>/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P '&lt;YOUR_SA_PASSWORD&gt;'<strong><br/></strong><br/>1&gt; CREATE LOGIN catalog_srv WITH PASSWORD = 'P@ssw0rd';<br/>2&gt; CREATE DATABASE Store;<br/>3&gt; GO<br/>1&gt; USE Store;<br/>2&gt; CREATE USER catalog_srv;<br/>3&gt; GO<br/>1&gt; EXEC sp_addrolemember N'db_owner', N'catalog_srv';<br/>2&gt; GO</pre>
<p>The code above creates the <kbd>Store</kbd> database with a login user called <kbd>catalog_srv</kbd>. Later in the book, we will see how to automate this process using the tools provided by Docker. Now, the database schema is updated, and we are able to continue by including the <kbd>IsInactive</kbd> field in the repository and the service layer of the application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the IItemRepository implementation</h1>
                
            
            
                
<p>Since we added the new <kbd>IsInactive</kbd> field in our database, we can proceed by adapting the <kbd>IItemRepository</kbd> interface to filter our data based on the <kbd>IsInactive</kbd> field. Therefore, we will proceed by implementing the following changes in order to maintain consistency in our data source:</p>
<ul>
<li>The <kbd>IItemRepository.GetAsync()</kbd> method will filter all the fields by <kbd>IsInactive = false</kbd>. Consequently, the resulting response will only contain active entities. This kind of approach guarantees that we get a lightweight response when we try to get multiple entities from the database. </li>
<li>In the same way, <kbd>GetItemByArtistIdAsync</kbd> and <kbd>GetItemByGenreIdAsync</kbd> will filter the result by using the <kbd>IsInactive = false</kbd> flag. Also, in this case, we want to keep the response as light as possible.</li>
<li>The <kbd>IItemRepository.GetAsync(Guid id)</kbd> method will retrieve the details of the required entity regardless of the <kbd>IsInactive</kbd> flag. Moreover, this method is used by the validation checks of the application, therefore, we need to avoid duplicate IDs when we insert new objects, whether they are active or not.</li>
</ul>
<p>Let's proceed by implementing these specifications mentioned in the <kbd>IItemRepository</kbd> interface:</p>
<pre>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class ItemRepository<br/>        : IItemRepository<br/>    {<br/>        ...<br/><br/>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetAsync()<br/>        {<br/>            return await _context.Items<br/>                <strong>.Where(x =&gt; !x.IsInactive)</strong><br/>                .AsNoTracking()<br/>                .ToListAsync();<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByArtistIdAsync(Guid id)<br/>        {<br/>            var items = await _context<br/>                .Items<br/>                <strong>.Where(x =&gt; !x.IsInactive)</strong><br/>                .Where(item =&gt; item.ArtistId == id)<br/>                .Include(x =&gt; x.Genre)<br/>                .Include(x =&gt; x.Artist)<br/>                .ToListAsync();<br/><br/>            return items;<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetItemByGenreIdAsync(Guid id)<br/>        {<br/>            var items = await _context.Items<br/>               <strong> .Where(x =&gt; !x.IsInactive)</strong><br/>                .Where(item =&gt; item.GenreId == id)<br/>                .Include(x =&gt; x.Genre)<br/>                .Include(x =&gt; x.Artist)<br/>                .ToListAsync();<br/><br/>            return items;<br/>        }<br/>...</pre>
<p>This implementation changes the behavior of the <kbd>GetAsync</kbd>, <kbd>GetItemByArtistIdAsync</kbd>, and <kbd>GetItemByGenreIdAsync</kbd> methods by filtering for <kbd>IsInactive == false</kbd> using the <kbd>Where</kbd> LINQ  clause. On the other hand, <kbd>GetAsync(Guid id)</kbd> remains the same because, as mentioned in the specifications, we want the get detail operation to always retrieve the information, including cases where the record is not active. Therefore, we can test the resulting implementation by executing the following command in the root of the project:</p>
<pre><strong>dotnet test</strong></pre>
<p>All tests should pass because, by default, the <kbd>IsInactive</kbd> Boolean field is always <kbd>false</kbd>. To test the <kbd>Where(x=&gt;!x.IsInactive)</kbd> change, we can add a new record in the <kbd>Catalog.API/tests/Catalog.Fixtures/Data/item.json</kbd> file by adding a new inactive item:</p>
<pre>{<br/>    "Id": "f5da5ce4-091e-492e-a70a-22b073d75a52",<br/>    "Name": "Untitled",<br/>    "Description": "Untitled by Kendrick Lamar",<br/>    "PictureUri": "https://mycdn.com/pictures/32423423",<br/>    "ReleaseDate": "2016-01-01T00:00:00+00:00",<br/>    "Price": {<br/>      "Amount": 23.5,<br/>      "Currency": "EUR"<br/>    },<br/>    "Format": "Vinyl 33g",<br/>    "AvailableStock": 6,<br/>    "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>    "Genre": null,<br/>    "ArtistId": "3eb00b42-a9f0-4012-841d-70ebf3ab7474",<br/>    "Artist": null,<br/>   <strong> "IsInactive": true</strong><br/>  },</pre>
<p>Therefore, we can verify that the number of records retrieved by the get operation changes by creating a new test and counting the results. For example, if the <kbd>item.json</kbd> file contains three records and one is inactive, the get operation should retrieve three records. As an alternative, we can double-check by verifying that the <kbd>Item.Id</kbd> fields of the result do not include an inactive record:</p>
<pre>namespace Catalog.Infrastructure.Tests<br/>{<br/>    ...<br/>    public class ItemRepositoryTests : IClassFixture&lt;CatalogContextFactory&gt;<br/>    {<br/>        <br/>        [Theory]<br/>        [InlineData("f5da5ce4-091e-492e-a70a-22b073d75a52")]<br/>        public async Task getitems_should_not_return_inactive_records(string id)<br/>        {<br/>            var result =<br/>                await _sut.GetAsync();<br/><br/>            result.Any(x =&gt; x.Id == new Guid(id)).ShouldBeFalse();<br/>        }<br/>     <br/>      ...<br/>   }<br/>}</pre>
<p>I chose to test the deletion behavior by adding a new  <kbd>getitems_should_not_return_inactive_records</kbd> method in the <kbd>ItemRepositoryTests</kbd> class. The test verifies that when I call the <kbd>GetAsync</kbd> method of the repository, the result excludes the <kbd>Item</kbd> entity with the <kbd>Id</kbd> specified as a parameter of the test. A similar approach can be also taken for the <kbd>GetItemByArtistIdAsync</kbd> and the <kbd>GetItemByGenreIdAsync</kbd> methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing delete operations</h1>
                
            
            
                
<p>Now that we have implemented the right filtering logic on the repository side, let's proceed by implementing delete operations in the <kbd>Catalog.Domain</kbd><em> </em>project by adding a new <kbd>DeleteItemAsync</kbd> method in the declaration of the <kbd>IItemService</kbd> interface:</p>
<pre>namespace Catalog.Domain.Services<br/>{<br/>    public interface IItemService<br/>    {<br/>        ...<br/>        <strong>Task&lt;ItemResponse&gt; DeleteItemAsync(DeleteItemRequest request);</strong><br/>    }<br/>}</pre>
<p>The <kbd>DeleteItemAsync</kbd> method refers to a <kbd>DeleteItemRequest</kbd> type, which can be declared as follows:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Requests.Item<br/>{<br/>    public class DeleteItemRequest<br/>    {<br/>        public Guid Id { get; set; }<br/>    }<br/>}</pre>
<p>Once we update the <kbd>IItemService</kbd> interface declaration, we can proceed by adding the implementation to the <kbd>ItemService</kbd> concrete class:</p>
<pre>public async Task&lt;ItemResponse&gt; DeleteItemAsync(DeleteItemRequest request)<br/>{<br/>    if (request?.Id == null) throw new ArgumentNullException();<br/><br/>    var result = await _itemRepository.GetAsync(request.Id);<br/>    result.IsInactive = true;<br/><br/>    _itemRepository.Update(result);<br/>    await _itemRepository.UnitOfWork.SaveChangesAsync();<br/><br/>    return _itemMapper.Map(result);<br/>}</pre>
<p>The <kbd>DeleteItemAsync</kbd> method receives an <kbd>Id</kbd> field that is part of the <kbd>DeleteItemRequest</kbd> class. Besides, it uses the <kbd>GetAsync</kbd> method to get the details of the entity, and it continues by calling the <kbd>Update</kbd> method by passing the entity with the <kbd>IsInactive</kbd> flag set to <kbd>true</kbd>. The next step is to implement a new action method in the <kbd>ItemController</kbd> that covers the following HTTP call:</p>
<pre>DELETE /items/{id}</pre>
<p>Moreover, we can proceed by changing the <kbd>ItemController</kbd> as follows:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Filters;<br/>using Catalog.Domain.Requests.Item;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    public class ItemController : ControllerBase<br/>    {<br/>        ...<br/><br/><strong>        [HttpDelete("{id:guid}")]</strong><br/><strong>        [ItemExists]</strong><br/><strong>        public async Task&lt;IActionResult&gt; Delete(Guid id)</strong><br/><strong>        {</strong><br/><strong>            var request = new DeleteItemRequest { Id = id };<br/></strong><br/><strong>            await _itemService.DeleteItemAsync(request);<br/></strong><br/><strong>            return NoContent();</strong><br/><strong>        }</strong><br/>    }<br/>}</pre>
<p>The <kbd>Delete</kbd> action method is decorated with the <kbd>HttpDelete</kbd> attribute verb, which means that it is mapped with the HTTP <kbd>Delete</kbd> requests. The implementation sets the <kbd>IsInactive</kbd> flag through the <kbd>DeleteItemAsync</kbd> method, and it returns a <kbd>NoContent</kbd> result, which represents an HTTP <kbd>204 No Content</kbd> status code.</p>
<p>We will proceed by testing the changes made to the <kbd>ItemController</kbd> class by implementing the following tests:</p>
<pre>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ItemsController : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;<br/><br/>        public ItemsController(InMemoryApplicationFactory&lt;Startup&gt; factory)<br/>        {<br/>            _factory = factory;<br/>        }<br/>        <br/>        ...<br/><br/>        [Theory]<br/>        [LoadData("item")]<br/>        public async Task delete_should_returns_no_content_when_called_with_right_id(DeleteItemRequest <br/>        request)<br/>        {<br/>            var client = _factory.CreateClient();<br/><br/>            var response = await client.DeleteAsync($"/api/items/{request.Id}");<br/><br/>            response.StatusCode.ShouldBe(HttpStatusCode.NoContent);<br/>        }<br/>        <br/>        [Fact]<br/>        public async Task delete_should_returns_not_found_when_called_with_not_existing_id()<br/>        {<br/>            var client = _factory.CreateClient();<br/><br/>            var response = await client.DeleteAsync($"/api/items/{Guid.NewGuid()}");<br/><br/>            response.StatusCode.ShouldBe(HttpStatusCode.NotFound);<br/>        }<br/>    }<br/>}<br/><br/></pre>
<p>This test code covers the following two behaviors:</p>
<ul>
<li>The <kbd>delete_should_returns_no_content_when_called_with_right_id</kbd> test method checks whether the action method correctly returns the HTTP <kbd>NoContent</kbd> response.</li>
<li>The <kbd>delete_should_returns_not_found_when_called_with_not_existing_id</kbd> method checks that the action method returns <kbd>HttpStatusCode.NotFound</kbd> by passing a non-existent GUID (<kbd>Guid.NewGuid</kbd>).</li>
</ul>
<p>In both test cases, we are using the already implemented test infrastructure to verify the new behavior of the web service. In this section, we have seen how to extend our web service in order to support the soft delete operation.</p>
<p>The next section focuses on the implementation of the HATEOAS response approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing HATEOAS </h1>
                
            
            
                
<p>We already discussed the theory around the HATEOAS principle in <a href="b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml">Chapter 1</a>, <em>REST 101 and Getting Started with ASP.NET Core.</em> This section explains how to implement the HATEOAS approach for the <kbd>ItemController</kbd> already present in the <kbd>Catalog.API</kbd> project. The following snippet of code shows an example of a generic HATEOAS response:</p>
<pre>{<br/>    "_links": {<br/>        "get": {<br/>            "rel": "ItemsHateoas/Get",<br/>            "href": "https://localhost:5001/api/hateoas/items",<br/>            "method": "GET"<br/>        },<br/>        "get_by_id": {<br/>            "rel": "ItemsHateoas/GetById",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "GET"<br/>        },<br/>        "create": {<br/>            "rel": "ItemsHateoas/Post",<br/>            "href": "https://localhost:5001/api/hateoas/items",<br/>            "method": "POST"<br/>        },<br/>        "update": {<br/>            "rel": "ItemsHateoas/Put",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "PUT"<br/>        },<br/>        "delete": {<br/>            "rel": "ItemsHateoas/Delete",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "DELETE"<br/>        }<br/>    },<br/>    "id": "8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>    "name": "Malibu",<br/>    "description": "Malibu. by Anderson Paak",<br/>    "labelName": "Steel Wool/OBE/Art Club",<br/>    "price": {<br/>        "amount": 23.5,<br/>        "currency": "EUR"<br/>    },<br/>    "pictureUri": "https://mycdn.com/pictures/32423423",<br/>    "releaseDate": "2016-01-01T00:00:00+00:00",<br/>    "format": "Vinyl 43",<br/>    "availableStock": 3,<br/>    "genreId": "7fcdde39-342b-4f80-0db1-08d65233f5a6",<br/>    "genre": null,<br/>    "artistId": "ff1921a8-f49a-4db2-0c2e-08d65233875e",<br/>    "artist": null<br/>}</pre>
<p>Although this kind of response adds a heavy payload to the effective JSON response, it assists the client by providing the URL for each operation and resource on our data. The HATEOAS principle will be implemented side-by-side with <kbd>ItemController</kbd>, and it will give all the necessary information to the client to interact with the data owned by the catalog service<em>.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enriching our model with HATEOAS data</h1>
                
            
            
                
<p class="mce-root">To get HATEOAS working, we will rely on a third-party NuGet package called <kbd>RiskFirst.Hateoas</kbd><em>.</em> This package allows us to integrate the HATEOAS principle in our service efficiently. First of all, let's proceed by adding the package to <kbd>Catalog.API</kbd> by executing the following command in both project folders:</p>
<pre><strong> dotnet add package RiskFirst.Hateoas</strong></pre>
<p>Next, create a new entity called the <kbd>ItemHateoasResponse</kbd> class, which represents the HATEOAS response. This class refers to the already implemented <kbd>ItemResponse</kbd> class, and it implements the <kbd>ILinkContainer</kbd> interface exposed by the <kbd>RiskFirst.Hateoas</kbd> package:</p>
<pre>using System.Collections.Generic;<br/>using Newtonsoft.Json;<br/>using RiskFirst.Hateoas.Models;<br/>using Catalog.Domain.Responses.Item;<br/><br/>namespace Catalog.API.ResponseModels<br/>{<br/>        public class ItemHateoasResponse :  ILinkContainer<br/>        {<br/>           <strong> public ItemResponse Data;</strong>          <br/>            private Dictionary&lt;string, Link&gt; _links;<br/><br/>            [JsonProperty(PropertyName = "_links")]<br/>            public Dictionary&lt;string, Link&gt; Links<br/>            {<br/>                get =&gt; _links ?? (_links = new Dictionary&lt;string, Link&gt;());<br/>                set =&gt; _links = value;<br/>            }<br/><br/>            public void AddLink(string id, Link link)<br/>            {<br/>                Links.Add(id, link);<br/>            }<br/>        }<br/>}</pre>
<p>The <kbd>Links</kbd> field is a  <kbd>Dictionary&lt;string, Link&gt;</kbd> type and it contains the URLs to the resources related to the response. For example, if we get the response of a specific item, the <kbd>Link</kbd> attribute will provide the URLs to add, update, and delete the item. The <kbd>AddLink</kbd> method is used to add new fields to the <kbd>Links</kbd> dictionary. Therefore, we will continue by using this type of response in a controller in order to provide a HATEOAS-compliant reaction to our client.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing HATEOAS in a controller</h1>
                
            
            
                
<p>The final step is to implement a controller that can handle the <kbd>ItemHateoasResponse</kbd> response model implemented previously. More specifically, we can proceed by creating a new <kbd>ItemHateoasController</kbd> class in our <kbd>Catalog.API</kbd> project. Note that we are building a new controller for demonstration purposes. An alternative would be to edit the already defined <kbd>ItemController</kbd> to return HATEOAS-compliant responses. </p>
<p>The <kbd>ItemHateoasController</kbd> class will use the <kbd>ILinksService</kbd> interface provided by the <kbd>RiskFirst.Hateoas</kbd> namespace to enrich the <kbd>Links</kbd> attribute of the <kbd>ItemHateoasResponse</kbd> model and return it to our client. Let's proceed by implementing the controller:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Filters;<br/>using Catalog.API.ResponseModels;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Mvc;<br/>using RiskFirst.Hateoas;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/hateoas/items")]<br/>    [ApiController]<br/>    [JsonException]<br/>    public class ItemsHateoasController : ControllerBase<br/>    {<br/>        private readonly IItemService _itemService;<br/>        private readonly ILinksService _linksService;<br/><br/>        public ItemsHateoasController(ILinksService linkService, IItemService itemService)<br/>        {<br/>            _linksService = linkService;<br/>            _itemService = itemService;<br/>        }<br/><br/>        [HttpGet(Name = nameof(Get))]<br/>        public async Task&lt;IActionResult&gt; Get([FromQuery] int pageSize = 10, [FromQuery] int pageIndex = 0)<br/>        {<br/>            var result = await _itemService.GetItemsAsync();<br/><br/>            var totalItems = result.Count();<br/><br/>            var itemsOnPage = result.OrderBy(c =&gt; c.Name)<br/>                .Skip(pageSize * pageIndex)<br/>                .Take(pageSize);<br/><br/>            var hateoasResults = new List&lt;ItemHateoasResponse&gt;();<br/><br/>            foreach (var itemResponse in itemsOnPage)<br/>            {<br/>                var hateoasResult = new ItemHateoasResponse { Data = itemResponse };<br/>                await _linksService.AddLinksAsync(hateoasResult);<br/><br/>                hateoasResults.Add(hateoasResult);<br/>            }<br/><br/>            var model = new PaginatedItemResponseModel&lt;ItemHateoasResponse&gt;(<br/>                pageIndex, pageSize, totalItems, hateoasResults);<br/><br/>            return Ok(model);<br/>        }<br/><br/><br/>        [HttpGet("{id:guid}", Name = nameof(GetById))]<br/>        [ItemExists]<br/>        public async Task&lt;IActionResult&gt; GetById(Guid id)<br/>        {<br/>            var result = await _itemService.GetItemAsync(new GetItemRequest { Id = id });<br/>            var hateoasResult = new ItemHateoasResponse { Data = result };<br/>            await _linksService.AddLinksAsync(hateoasResult);<br/><br/>            return Ok(hateoasResult);<br/>        }</pre>
<p>The <kbd>Get</kbd> and <kbd>GetById</kbd> action methods are quite similar to the one that is present in <kbd>ItemController</kbd>. The only difference is that they return a different response type, which is represented by the <kbd>ItemHateoasResponse</kbd> class. Furthermore, the action methods assign the <kbd>response</kbd> object to the <kbd>Data</kbd> field. Each action method also calls the <kbd>AddLinksAsync</kbd> method provided by the <kbd>ILinksService</kbd> interface to populate the link attribute. In the same way, we can extend the behavior of the other action methods present in the controller class:</p>
<pre>...<br/><br/>        [HttpPost(Name = nameof(Post))]<br/>        public async Task&lt;IActionResult&gt; Post(AddItemRequest request)<br/>        {<br/>            var result = await _itemService.AddItemAsync(request);<br/>            return CreatedAtAction(nameof(GetById), new { id = result.Id }, null);<br/>        }<br/><br/>        [HttpPut("{id:guid}", Name = nameof(Put))]<br/>        [ItemExists]<br/>        public async Task&lt;IActionResult&gt; Put(Guid id, EditItemRequest request)<br/>        {<br/>            request.Id = id;<br/>            var result = await _itemService.EditItemAsync(request);<br/><br/>            var hateoasResult = new ItemHateoasResponse { Data = result };<br/>            await _linksService.AddLinksAsync(hateoasResult);<br/><br/>            return Ok(hateoasResult);<br/>        }<br/><br/>        [HttpDelete("{id:guid}", Name = nameof(Delete))]<br/>        [ItemExists]<br/>        public async Task&lt;IActionResult&gt; Delete(Guid id)<br/>        {<br/>            var request = new DeleteItemRequest { Id = id };<br/>            await _itemService.DeleteItemAsync(request);<br/>            return NoContent();<br/>        }<br/>..</pre>
<p>This is the declaration of the implementation of the create, update, and delete action methods. Also, in this case, we are using the <kbd>ItemHateoasResponse</kbd> model class to retrieve the response of the action method. We should notice that the action methods declare <kbd>Name</kbd> in the <kbd>[HttpVerb]</kbd> attribute decorator, such as <kbd> [HttpDelete("{id:guid}", Name = nameof(Delete))]</kbd>. Indeed, we will use the <kbd>Name</kbd> declared by the attribute in the <kbd>Startup</kbd> class to refer to each route and include it in the <kbd>Link</kbd> property:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>        ...<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>          ...<br/><br/>            services.AddLinks(config =&gt; <br/>            {<br/>                config.AddPolicy&lt;ItemHateoasResponse&gt;(policy =&gt;<br/>                {<br/>                    policy<br/>                        .RequireRoutedLink(nameof(ItemsHateoasController.Get), <br/>                         nameof(ItemsHateoasController.Get))<br/>                        .RequireRoutedLink(nameof(ItemsHateoasController.GetById), <br/>                         nameof(ItemsHateoasController.GetById), _ =&gt; new {id = _.Data.Id})<br/>                        .RequireRoutedLink(nameof(ItemsHateoasController.Post), <br/>                         nameof(ItemsHateoasController.Post))<br/>                        .RequireRoutedLink(nameof(ItemsHateoasController.Put), <br/>                         nameof(ItemsHateoasController.Put), x =&gt; new {id = x.Data.Id})<br/>                        .RequireRoutedLink(nameof(ItemsHateoasController.Delete), <br/>                         nameof(ItemsHateoasController.Delete), x =&gt; new {id = x.Data.Id});<br/>                });<br/>            });<br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>The <kbd>AddLinks</kbd> extension method provided by the <kbd>RiskFirst.Hateoas</kbd> package allows us to define the policies related to a response model. This is the case for the <kbd>config.AddPolicy&lt;ItemHateoasResponse&gt;</kbd> method, which calls <kbd>RequireRoutedLink</kbd> for each action method name declared in <kbd>ItemsHateoasController</kbd>. Note that, similar to the previous cases, we can extract this snippet of code in an external extension method to keep the <kbd>Startup</kbd> class as clean as possible. Finally, this kind of approach allows us to define different groups of links for different response models. Moreover, it is possible to establish a policy related to a specific response model.</p>
<p>Consequently, we can now run and verify the result by executing the <kbd>dotnet run</kbd> command in the <kbd>Catalog.API</kbd> folder. Please note, to run the Docker SQL Server, specify the connection string in <kbd>appsetting.json</kbd> file. After that, we can run the following <kbd>curl</kbd> request to verify <kbd>ItemsHateoasController</kbd>. The resulting JSON response will look as follows:</p>
<pre>{<br/>    "_links": {<br/>        "get": {<br/>            "rel": "ItemsHateoas/Get",<br/>            "href": "https://localhost:5001/api/hateoas/items",<br/>            "method": "GET"<br/>        },<br/>        "get_by_id": {<br/>            "rel": "ItemsHateoas/GetById",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "GET"<br/>        },<br/>        "create": {<br/>            "rel": "ItemsHateoas/Post",<br/>            "href": "https://localhost:5001/api/hateoas/items",<br/>            "method": "POST"<br/>        },<br/>        "update": {<br/>            "rel": "ItemsHateoas/Put",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "PUT"<br/>        },<br/>        "delete": {<br/>            "rel": "ItemsHateoas/Delete",<br/>            "href": "https://localhost:5001/api/hateoas/items/8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>            "method": "DELETE"<br/>        }<br/>    },<br/>    "id": "8ff0fe8f-9dbc-451f-7a57-08d652340f56",<br/>    "name": "Malibu",<br/><br/>...</pre>
<p>As you can see, in addition to the list of items, <kbd>ItemHateoasController</kbd> also retrieves an envelope that provides additional information to the client, such as the other routes needed for the get, add, update, and delete operations. Furthermore, this approach gives all the URIs needed by the client, in order to navigate through the information exposed by the web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The asynchronous code in ASP.NET Core</h1>
                
            
            
                
<p>In this section, we will discuss the asynchronous code stack of ASP.NET Core. We have already dealt with the asynchronous pattern, and we have already seen that some of the implementations in the previous chapters used asynchronous code extensively.</p>
<p>Note that the following section is mainly focused on asynchronous code in ASP.NET Core based on .NET Core. Bear in mind that there are some differences between asynchronous programming in .NET Core and .NET Framework. Some of the deadlocking issues that we are used to seeing in .NET Framework are not present in .NET Core.</p>
<p>Before we start digging into the asynchronous code, let's take a look at the differences between synchronous and asynchronous systems in ASP.NET Core.</p>
<p>First of all, when a synchronous API receives a request, a thread from the thread pool will handle the request. The assigned thread is busy until the end of the request life cycle. In most cases, the API performs I/O operations on data or third-party APIs, which means that the thread will be blocked until the end of these operations. More specifically, a blocked thread cannot be used by other operations and requests. For asynchronous code, however, the behavior is entirely different.</p>
<p>The request will be assigned to a thread, but the thread will not be locked, and it can be assigned and used by other operations. If the task is awaited and it doesn't involve CPU-bound work, then the thread can be released to return to the pool to carry out other work. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Task definitions</h1>
                
            
            
                
<p>The <kbd>Task</kbd> type represents asynchronous tasks. The <kbd>Task</kbd> class is a representation of a unit of work. We can find similar concepts in other languages. For example, in JavaScript, the concept of <kbd>Task</kbd> is represented by a <kbd>Promise</kbd>.</p>
<p>It is common to associate a <kbd>Task</kbd> type with a thread in our CPU, which is not correct: wrapping a method execution in a <kbd>Task</kbd> doesn't guarantee that the operation will be executed on another thread. </p>
<p>The <kbd>async</kbd> and <kbd>await</kbd> keywords are the easiest way to deal with asynchronous operations in C#: the <kbd>async</kbd> keyword converts the method into a state machine and it enables the <kbd>await</kbd> keyword in the implementation of the method. The <kbd>await</kbd> keyword indicates to the compiler the operations that need to be awaited in order to proceed with the execution of the asynchronous method. Therefore, it is common to find something similar in C# codebases:</p>
<pre>public async Task&lt;String&gt; GetStringAsync(String url)<br/>{<br/>    var request = await _httpClient.GetAsync(url);<br/>    var responseContent = await request.Content.ReadAsStringAsync();<br/>    return responseContent;<br/>}</pre>
<p>The preceding snippet is very intuitive: it calls a <kbd>url</kbd> using the <kbd>GetAsync</kbd> method of the <kbd>_httpClient</kbd> instance, and it uses <kbd>ReadAsStringAsync</kbd> to get the resulting string and store it in the <kbd>responseContent</kbd> object. It is essential to understand that <kbd>async</kbd> and <kbd>await</kbd> are syntactic sugar keywords, and the same result can be achieved in a less readable way by using the <kbd>ContinueWith</kbd> method:</p>
<pre>public Task&lt;String&gt; GetStringAsync(String url) <br/>{ <br/>     var request =_httpClient.GetAsync(url); <br/>     var responseContentTask = request.<strong>ContinueWith</strong>(http =&gt; <br/>                         http.Result.Content.ReadAsStringAsync()); <br/>     return responseContentTask.Unwrap(); <br/>}</pre>
<p>This code snippet has the same effect as the previous one. The main difference is that this code is less intuitive. Furthermore, in complex operations that execute a lot of nested transactions, we would create a lot of nesting levels. </p>
<p>It is essential to embrace the <kbd>async</kbd>/<kbd>await</kbd> syntax as the primary way of working with asynchronous code. Other languages have taken a similar approach to keep the code more clean and readable. This is the case for ECMAScript, which introduced the <kbd>async</kbd>/<kbd>await</kbd> syntax in ES 2016: <a href="https://github.com/tc39/ecma262/blob/master/README.md">https://github.com/tc39/ecma262/blob/master/README.md</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The need for asynchronous code in ASP.NET Core</h1>
                
            
            
                
<p>The first thing to underline is that asynchronous code is not about speed. As mentioned before, asynchronous programming is just about not blocking incoming requests. Therefore, the real benefit is about better vertical scalability<em>,</em> instead of increasing the speed of our code.  For example, let's suppose that our web services perform some I/O operations such as queries on a database: in case we run our code stack in a synchronous way, the thread used by an incoming request will be blocked and not used by any other request until the read or write (I/O operation) process is completed.  By taking an asynchronous approach we are able to release the thread as soon as the read/write operation is executed. Therefore, once the I/O operation is finished, the application will pick up another or the same thread in order to continue the execution of the stack.</p>
<p>The asynchronous code also adds an overhead cost to our system, in fact, it is necessary to add additional logic to coordinate asynchronous operations. For example, let's take a look at the following code:</p>
<pre>[Route("api/[controller]")]<br/>[ApiController]<br/>public class ValuesController : ControllerBase<br/>{<br/>    // GET api/values<br/>    [HttpGet]<br/>    public async Task&lt;ActionResult&lt;string&gt;&gt; Get()<br/>    {<br/>        <strong>return await OperationAsync();</strong><br/>    }<br/><br/><br/>    public async Task&lt;string&gt; OperationAsync()<br/>    {<br/>        await Task.Delay(100);<br/>        return "Response";<br/>    }<br/>}</pre>
<p>The aforementioned example defines an action method that calls an asynchronous method. With the help of some external tools, such as ILSpy, it is possible to decompile the C# code and analyze the IL code. The <strong>IL code</strong> is also known as the <strong>intermediate code</strong>, which is the code that is generated by the C# compiler and executed at runtime.</p>
<p>The resulting transformation in the IL code of the previously defined <kbd>Get</kbd> method looks as follows:</p>
<pre>[CompilerGenerated]<br/>private sealed class &lt;Get&gt;d__0 : <strong>IAsyncStateMachine</strong><br/>{<br/>    // Fields<br/>    public int &lt;&gt;1__state;<br/>    public AsyncTaskMethodBuilder&lt;ActionResult&lt;string&gt;&gt; &lt;&gt;t__builder;<br/>    public ValuesController &lt;&gt;4__this;<br/>    private string &lt;&gt;s__1;<br/>    private TaskAwaiter&lt;string&gt; &lt;&gt;u__1;<br/><br/>    // Methods<br/>    public &lt;Get&gt;d__0();<br/>    <strong>private void MoveNext();</strong><br/>    [DebuggerHidden]<br/>    private void SetStateMachine(IAsyncStateMachine stateMachine);<br/>}</pre>
<p>As you can see, the method has been transformed into a sealed class that implements the <kbd>IAsyncStateMachine</kbd> interface. The <kbd>MoveNext</kbd> method continuously checks whether the <kbd>__state</kbd> of the state machine is changed and updates the result of the operation. All these operations are performed for each asynchronous operation contained in our code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What's new in ASP.NET Core?</h1>
                
            
            
                
<p>Since its introduction in the old ASP.NET framework, the <kbd>async</kbd>/<kbd>await</kbd> code was previously affected by some <em>deadlock issues</em>. The old version of ASP.NET uses a class called <kbd>SynchronizationContext</kbd>, which essentially provides a way to queue a <kbd>Task</kbd> to a context when a method calls other tasks that are nested asynchronous methods and forces them to be executed synchronously using the <kbd>.Result</kbd> or <kbd>.Wait()</kbd> keywords, therefore, this causes a deadlock of the request context.</p>
<p>For example, let's suppose that the following code is executed on the old version of ASP.NET:</p>
<pre>   public class ValuesController : ApiController<br/>    {<br/>        public string Get()<br/>        {<br/>            return Operation1Async().Result;<br/>        }<br/><br/>        public async Task&lt;string&gt; Operation1Async()<br/>        {<br/>            await Task.Delay(1000);<br/>            return "Test";<br/>        }<br/>    }</pre>
<p>This leads to a deadlock in the application because the <kbd>Get()</kbd> and <kbd>Operation1Async()</kbd> methods are using the same context. While the <kbd>Operation1Async()</kbd> method captures the context, which will be used to continue running the method, the <kbd>Get()</kbd> action method is blocking the context because it is waiting for a result.</p>
<p>For this reason, developers started to fill their asynchronous code with <kbd>.ConfigureAwait(false)</kbd> instructions, which primarily provides a way to execute the <kbd>Task</kbd> in a different context by avoiding the deadlock issue seen before:</p>
<pre>   public class ValuesController : ApiController<br/>    {<br/>        public string Get()<br/>        {<br/>            return Operation1Async().Result;<br/>        }<br/><br/>        public async Task&lt;string&gt; Operation1Async()<br/>        {<br/>            await Task.Delay(1000)<br/>                      <strong>.ConfigureAwait(continueOnCapturedContext:false);</strong><br/>            return "Test";<br/>        }<br/>    }</pre>
<p>This kind of approach works, but we should consider that by calling <kbd>Result</kbd> or <kbd>.Wait()</kbd>, we are losing all the benefits provided by the asynchronous programming pattern.</p>
<p>The good news about ASP.NET Core is that it doesn't use <kbd>SynchronizationContext</kbd>. The <em>context-less</em> idea provides lightweight management of the asynchronous code: while ASP.NET queues each asynchronous unit in the request context before assigning it to a thread, ASP.NET Core picks up a thread from the assigned thread pool and attaches it to the asynchronous task.</p>
<p>Moreover, the ASP.NET team has done an excellent job with ASP.NET Core and, as we saw in previous chapters, almost every component that is part of the ASP.NET Core pipeline has both a <em>synchronous</em> and an <em>asynchronous</em> version. This is the case, for example, for the action filter that we saw in <a href="13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml">Chapter 6</a><em>,</em> <em>Filter Pipeline</em>.</p>
<p>While the <kbd>.ConfigureAwait(false)</kbd> method is not needed anymore with the new version of .NET Core, we should keep in mind that it is still useful in some codebases. If you are building a .NET library that compiles in .NET Core but also in older version of the .NET Framework, you should still use the <kbd>.ConfigureAwait(false)</kbd> method in order to avoid deadlocks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Best practices in asynchronous programming</h1>
                
            
            
                
<p>Let's take a look at some good and bad practices to do with the asynchronous programming model in ASP.NET Core. First of all, the central concept to keep in mind is to avoid mixing between synchronous and asynchronous code. As mentioned previously, ASP.NET Core exposes both the sync and <kbd>async</kbd> versions of the majority of classes and interfaces. Therefore, before blocking an asynchronous stack with synchronous code, you should explore and check all the alternatives provided by the framework.</p>
<p>The following recommendations come from a high-level perspective of asynchronous programming in .NET. This book is focused on other aspects of the framework. If you want to get more details about how to work with asynchronous programming, I suggest you navigate to the following link: <a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md">https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md</a>. Moreover, if you want a more general overview of concurrency in .NET, I suggest you read the following book:  <em>Concurrency in C# Cookbook</em> by Stephen Cleary (<a href="https://stephencleary.com/book/">https://stephencleary.com/book/</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Don't use async void methods</h1>
                
            
            
                
<p>A common mistake about asynchronous programming in .NET Core and, more in general, in the whole .NET ecosystem, is to declare a method as <kbd>async void</kbd>. Indeed, when we declare a method as <kbd>async void</kbd>, we will not be able to catch exceptions thrown by the method. Furthermore, the <kbd>Task</kbd> type is used to capture the exceptions of the method and propagate them to the caller. In summary, we should always implement our <kbd>async</kbd> methods by returning the <kbd>Task</kbd> type when the method returns <kbd>void</kbd>, otherwise, we should return the  <kbd>Task&lt;T&gt;</kbd> generic type when the method returns a type.  Furthermore, the <kbd>Task</kbd> type is also useful when we want to notify the status of the operation to the caller: the <kbd>Task</kbd> type exposes the status of the operation through the following attributes: <kbd>Status</kbd>, <kbd>IsCanceled</kbd>, <kbd>IsCompleted, </kbd>and <kbd>IsFaulted</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use Task.FromResult over Task.Run</h1>
                
            
            
                
<p class="mce-root">If you have previously worked with .NET Core or .NET Framework, you have probably dealt with both <kbd>Task.FromResult</kbd> and <kbd>Task.Run</kbd>. Both can be used to return <kbd>Task&lt;T&gt;</kbd>.  The main difference between them is in their input parameters. Take a look at the following <kbd>Task.Run</kbd> snippet:</p>
<pre> public Task&lt;int&gt; AddAsync(int a, int b)
   {
       return Task.Run(<strong>() =&gt; a + b</strong>);
   }</pre>
<p>The <kbd>Task.Run</kbd> method will queue the execution as a work item in the thread pool. The work item will immediately complete with the pre-computed value. As a result, we have wasted a thread pool.  Furthermore, we should also notice that the initial purpose of <kbd>Task.Run</kbd> method was intended for the client-side .NET applications: ASP.NET Core is not optimized for the <kbd>Task.Run</kbd> operations and it shouldn't ever be used to offload the execution of a portion of code. On the opposite side, let's examine another case:</p>
<pre> public Task&lt;int&gt; AddAsync(int a, int b)
   {
       return Task.<strong>FromResult</strong>(<strong>a + b</strong>);
   }</pre>
<p>In this case, the <kbd>Task.FromResult</kbd> method will wrap the pre-computed result without wasting a thread pool which means that we will not have the overhead provided by the execution of the <kbd>Task.Run</kbd> operation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enable cancellation</h1>
                
            
            
                
<p>Another important topic is to enable the cancellation of asynchronous operations. If we take a look at the service layer that we implemented in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, and <a href="f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml">Chapter 9</a>, we can see that in some cases we have the possibility of passing <kbd>CancellationToken</kbd> as a parameter.  The <kbd>CancellationToken</kbd> provides a light way to notify all asynchronous operations that the consumer wants to cancel the current transaction. Moreover, our code can examine the <kbd>CancellationToken.IsCancellationRequested</kbd> property to detect whether the consumer has requested the cancellation of the task. This kind of approach is especial suitable for long-running operations because the consumer of our asynchronous code can request the cancellation of the current performing task at any point in the process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous code in I/O bound operations</h1>
                
            
            
                
<p>When we implement code in an asynchronous way we should ask ourselves if the underlying process involves any kind of I/O operation. If this is the case, we should proceed by using an asynchronous approach for that stack. For example, the <kbd>Get</kbd> operation of the <kbd>ItemRepository</kbd> class involves a query to the database:</p>
<pre>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class ItemRepository : IItemRepository<br/>    {<br/>        ..<br/>        public async Task&lt;Item&gt; GetAsync(Guid id)<br/>        {<br/>            var item = await _context.Items<br/>                .AsNoTracking()<br/>                .Where(x =&gt; x.Id == id)<br/>                .Include(x =&gt; x.Genre)<br/>                .Include(x =&gt; x.Artist)<strong>.FirstOrDefaultAsync()</strong>;<br/><br/>            return item;<br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>In this case, we are using the <kbd>FirstOrDefaultAsync</kbd> method to execute the operation in an asynchronous way. On the opposite side, if we take as an example another operation, such as the <kbd>Add</kbd> method of the <kbd>ItemRepository</kbd> we can see that the operation is not asynchronous even if the EF Core framework exposes the <kbd>AddAsync</kbd> methods:</p>
<pre>public Item Add(Item order)<br/>{<br/>    return _context.Items<br/>        .Add(order).Entity;<br/>}</pre>
<p class="mce-root">This is because in the case of the adding operation we are not performing any kind of I/O operation: the entity is added to the <kbd>context</kbd> attribute and marked with an added status. The proper synchronization with the database happens when we call the <kbd>SaveChangesAsync</kbd> method which is asynchronous because it involves I/O operations with the database. In conclusion, we should always keep in mind to understand the full context and stack of the operation that we want to execute in an asynchronous manner. In general, every time we have to deal with the file system, a database, and any other network call we should implement our code using an asynchronous stack, otherwise we can keep the code synchronous in order to avoid additional thread overheads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Measure response time using middleware</h1>
                
            
            
                
<p>A common way to measure the response time of ASP.NET Core actions is by using a <em>middleware component</em>. As seen in <a href="77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml">Chapter 3</a>, <em>Working with the Middleware Pipeline</em>, these components act at the edge of the ASP.NET Core request life cycle, and they are useful for performing cross-cutting implementations. Measuring the response time of an action method falls into this implementation case. Furthermore, middleware is the first component hit by a request and the last one that can process an outgoing response. This means that we can analyze and include almost the whole life cycle of the request.</p>
<p>Let's take a look at an implementation of <kbd>ResponseTimeMiddlewareAsync</kbd>:</p>
<pre>using System.Diagnostics;<br/>using System.Threading.Tasks;<br/>using Microsoft.AspNetCore.Http;<br/><br/>namespace Catalog.API.Infrastructure.Middleware<br/>{<br/>    public class ResponseTimeMiddlewareAsync {  <br/>        <br/>        private const string X_RESPONSE_TIME_MS = "X-Response-Time-ms";  <br/>        <br/>        private readonly RequestDelegate _next;  <br/>        <br/>        public ResponseTimeMiddlewareAsync(RequestDelegate next) {  <br/>            _next = next;  <br/>        }  <br/>        <br/>        public Task InvokeAsync(HttpContext context) {  <br/><br/>            var watch = new Stopwatch(); <br/>            <br/>            watch.Start();  <br/>            <br/>            context.Response.OnStarting(() =&gt; {  <br/>                <br/>                watch.Stop();  <br/>                <br/>                var responseTimeForCompleteRequest = watch.ElapsedMilliseconds;  <br/>                context.Response.Headers[X_RESPONSE_TIME_MS] = responseTimeForCompleteRequest.ToString(); <br/>                <br/>                return Task.CompletedTask;  <br/>            });  <br/>            <br/>            return _next(context);  <br/>        }  <br/>    }  <br/>}</pre>
<p>The previous class defines an <kbd>async</kbd> middleware to detect the response time of the requests. It follows these steps:</p>
<ol>
<li>It declares a <kbd>Stopwatch</kbd> instance in the <kbd>InvokeAsync</kbd> method.</li>
<li>It executes the <kbd>Start()</kbd> method of the <kbd>Stopwatch</kbd> instance.</li>
<li>It defines a new response delegate using the <kbd>OnStarting</kbd> method. The <kbd>OnStarting</kbd> method, which allows us to declare a delegate action to be invoked just before the response headers, will be sent to the client.</li>
<li>It calls the <kbd>Stop()</kbd> method and sets the <kbd>ElapsedMilliseconds</kbd> property as a custom header using the <kbd>X-Response-Time-ms</kbd> header.</li>
</ol>
<p>It is possible to include the <kbd>ResponseTimeMiddlewareAsync</kbd> class in the middleware pipeline by adding the following line in the <kbd>Startup</kbd> class:</p>
<pre>...<br/>public void Configure(IApplicationBuilder app, IWebHostingEnvironment env)<br/>{<br/>    ...<br/>    app.UseMiddleware&lt;ResponseTimeMiddlewareAsync&gt;();<br/>    ...<br/>}<br/>...<br/><br/></pre>
<p>Furthermore, it is also possible to test the middleware by following the same approach we took for testing the controllers by implementing the following:</p>
<pre>using System.Threading.Tasks;<br/>using Shouldly;<br/>using Catalog.Fixtures;<br/>using Xunit;<br/><br/>namespace Catalog.API.Tests.Middleware<br/>{<br/>    public class ResponseTimeMiddlewareTests : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        public ResponseTimeMiddlewareTests(InMemoryApplicationFactory&lt;Startup&gt; factory)<br/>        {<br/>            _factory = factory;<br/>        }<br/><br/>        private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;<br/><br/><br/>        [Theory]<br/>        [InlineData("/api/items/?pageSize=1&amp;pageIndex=0")]<br/>        [InlineData("/api/artist/?pageSize=1&amp;pageIndex=0")]<br/>        [InlineData("/api/genre/?pageSize=1&amp;pageIndex=0")]<br/>        public async Task middleware_should_set_the_correct_response_time_custom_header(string url)<br/>        {<br/>            var client = _factory.CreateClient();<br/>            var response = await client.GetAsync(url);<br/><br/>            <strong>response.EnsureSuccessStatusCode();</strong><br/><strong>            response.Headers.GetValues("X-Response-Time-ms").ShouldNotBeEmpty();</strong><br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>ResponseTimeMiddlewareTests</kbd> class allows us to make an HTTP call by extending the <kbd>InMemoryApplicationFactory</kbd> class. We can check whether the <kbd>X-Response-Time-ms</kbd> header exists in the response object. It is important to note that the other measurement doesn't include the startup time of the web server or the application pool. Furthermore, it takes some additional time when the webserver is not initialized. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered some different topics about building an API: from the soft deletion of our resources to how to measure the performance of responses. We also had an overview of the asynchronous programming stack of ASP.NET Core and some recommendations as to how to use it. The topics covered in this chapter will be helpful to you at an advanced development stage in order to improve the readability of the returned data and the performance of the web service.  In the next chapter, we will see how to run our catalog solution using containerization technologies.  The chapter provides an overview of Docker and on the related Docker compose tools.</p>


            

            
        
    </body></html>