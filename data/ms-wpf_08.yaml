- en: Creating Visually Appealing User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视觉上吸引人的用户界面
- en: While adding form elements to a View is simple, it takes somewhat more to produce
    an application that looks visually appealing. Luckily, **Windows Presentation
    Foundation** (**WPF**) provides us with many features that can help us to achieve
    this goal, such as gradient brushes, rounded corners, opacity control, layered
    visuals, and animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个视图中添加表单元素很简单，但要制作一个看起来视觉上吸引人的应用程序则需要更多的工作。幸运的是，**Windows Presentation Foundation**（**WPF**）为我们提供了许多可以帮助我们实现这一目标的特性，例如渐变画刷、圆角、透明度控制、分层视觉效果和动画。
- en: In this chapter, we'll take a look at a number of ways of using these elements
    in order to greatly improve the visual aspect of our applications. We'll investigate
    solutions that are simple to implement, using style properties, and other solutions
    that will take more work, such as animations and custom controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨多种使用这些元素的方法，以极大地改善我们应用程序的视觉外观。我们将研究简单易实现的解决方案，例如使用样式属性，以及需要更多工作的解决方案，如动画和自定义控件。
- en: Styling applications consistently
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致地样式化应用程序
- en: One of the easiest ways to make our applications stand out is to make them look
    unique. This can be achieved by defining custom styles for the controls that we
    use in it. However, if we decide to style our controls, it is essential that we
    style all of the controls that we use, as a half styled application can often
    look worse than an application that merely uses the default styles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的应用程序脱颖而出的一种最简单的方法是让它们看起来独特。这可以通过为我们在其中使用的控件定义自定义样式来实现。然而，如果我们决定为我们的控件添加样式，那么为所有使用的控件添加样式是至关重要的，因为半样式化的应用程序往往比仅使用默认样式的应用程序看起来更糟糕。
- en: It is therefore absolutely essential that we design our application control
    styles consistently, in order to attain a professional look for our application.
    In this section, we'll discuss a number of tips and tricks to help us to implement
    these application styles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们设计应用程序控件样式的一致性是绝对必要的，以便为我们的应用程序提供专业的外观。在本节中，我们将讨论一些技巧和窍门，以帮助我们实现这些应用程序样式。
- en: Overriding default control styles
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖默认控件样式
- en: When providing custom styles for our application controls, this typically requires
    us to define a new `ControlTemplate` element for each of them. As these can often
    be very large, it is customary to declare them in a separate resource file and
    merge it with the application resources in the `App.xaml` file, as shown in [Chapter
    5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml), *Using the Right Controls for
    the Job*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的应用程序控件提供自定义样式时，这通常需要我们为每个控件定义一个新的`ControlTemplate`元素。由于这些元素往往非常大，因此通常将它们声明在一个单独的资源文件中，并在`App.xaml`文件中将它们与应用程序资源合并，如[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)中所示，“为工作选择正确的控件”。
- en: Before starting this task, we need to plan how we want our controls to look
    and then apply this same look to each control. Another mistake would be to customize
    different controls with different styles, as consistency is key to providing a
    professional look. For example, if we want our single-line textboxes to be a certain
    height, then we should also define our other controls to be the same height.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这项任务之前，我们需要规划我们的控件外观，然后将这种外观应用到每个控件上。另一个错误是使用不同的样式定制不同的控件，因为一致性是提供专业外观的关键。例如，如果我们希望我们的单行文本框具有特定的高度，那么我们也应该定义其他控件具有相同的高度。
- en: The custom styles that we declare for our controls can be part of our application
    framework. If we define them without naming them via the `x:Key` directive, they
    will be implicitly applied and so, the developers that utilize our application
    framework need not concern themselves with the look of each control, effectively
    freeing them up to concentrate on aggregating them into the various Views.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为控件声明的自定义样式可以是我们的应用程序框架的一部分。如果我们通过`x:Key`指令未命名它们，它们将被隐式应用，因此利用我们的应用程序框架的开发者无需关心每个控件的外观，从而有效地使他们能够专注于将它们聚合到各种视图中。
- en: The first thing to do before starting to design our custom styles is to define
    a small range of colors that we will use in our application. Using too many colors
    in an application can make it look less professional, so we should choose a few
    shades of a small number of colors to use. There are a number of online tools
    that can help us to pick a color palette to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始设计自定义样式之前，首先要定义我们将要在应用程序中使用的一小部分颜色。在应用程序中使用过多的颜色可能会使其看起来不够专业，因此我们应该选择少量颜色的一两种色调来使用。有许多在线工具可以帮助我们选择要使用的调色板。
- en: 'Once we have chosen our application colors, we should declare them, first,
    as `Color` objects in the `App.xaml` file, and then declare brush elements that
    use them, as most controls use brushes rather than colors. This has two benefits;
    using only these colors will promote consistency and if we ever need to change
    a color, we only need to change it in a single place:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了应用程序颜色，我们首先应该在 `App.xaml` 文件中将它们声明为 `Color` 对象，然后声明使用它们的画笔元素，因为大多数控件使用画笔而不是颜色。这有两个好处；只使用这些颜色将促进一致性，并且如果我们需要更改颜色，我们只需要在一个地方更改它：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is often a good idea to also define multiple named styles for the most common
    types of controls. For example, having a `Label` style for `TextBlock` elements,
    that right aligns them and adds suitable margins, or a `Heading` style that sets
    a larger font size and heavier font weight. Providing the developers with a set
    of predefined styles helps to make the application look consistent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义最常见的控件类型的多个命名样式通常也是一个好主意。例如，为 `TextBlock` 元素提供一个 `Label` 样式，使其右对齐并添加合适的边距，或者提供一个
    `Heading` 样式，设置更大的字体大小和更重的字体重量。为开发者提供一组预定义的样式有助于使应用程序看起来保持一致。
- en: 'When defining multiple named styles, it is common to reuse some of them in
    others. For example, if we have a default style for the `TextBox` control, we
    can base other style variations on it. Let''s see some XAML examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义多个命名样式时，通常会在其他样式中重用其中的一些。例如，如果我们为 `TextBox` 控件有一个默认样式，我们可以在其他样式变体上基于它。让我们看看一些
    XAML 示例：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the simplified `TextBoxStyle` style defines the majority of the properties
    for all `TextBox` controls. The `Max2LineTextBoxStyle` style inherits all of the
    property settings from this style and sets a few more that ensure that the vertical
    scrollbar can appear when required and enforce a maximum height for the control.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，简化的 `TextBoxStyle` 样式定义了所有 `TextBox` 控件的大部分属性。`Max2LineTextBoxStyle` 样式从该样式继承所有属性设置，并设置了一些额外的属性，以确保在需要时可以出现垂直滚动条，并强制控件的最大高度。
- en: The `Max3LineTextBoxStyle` style extends the `Max2LineTextBoxStyle` style and
    so, inherits all of its property settings, as well as those of the `TextBoxStyle`
    style. It overrides the `MaxHeight` property that was set in the previous style.
    The `ReadOnlyTextBoxStyle` style also extends the `TextBoxStyle` style and sets
    properties to ensure that the control is read-only. Defining styles in this way
    ensures that controls in each View will remain consistent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Max3LineTextBoxStyle` 样式扩展了 `Max2LineTextBoxStyle` 样式，因此继承了其所有属性设置，以及 `TextBoxStyle`
    样式的属性。它覆盖了之前样式中设置的 `MaxHeight` 属性。`ReadOnlyTextBoxStyle` 样式也扩展了 `TextBoxStyle`
    样式，并设置了属性以确保控件为只读。以这种方式定义样式可以确保每个视图中的控件保持一致性。'
- en: As well as defining default styles for our application controls, it is often
    also a good idea to provide default data template resources for each data Model
    in the application. In a similar way to the controls, predefining these data templates
    can result in improved consistency. We can also define a number of named templates
    to override the default ones with and use in different scenarios.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们的应用程序控件定义默认样式外，通常还为应用程序中的每个数据模型提供默认数据模板资源。与控件类似，预先定义这些数据模板可以提高一致性。我们还可以定义多个命名模板来覆盖默认模板并在不同场景中使用。
- en: If there are a large number of data models in an application, it can be helpful
    to also declare their data templates in a separate resource file and merge it
    with the application resources in the `App.xaml` file, like to the default control
    templates. It is therefore not unusual to see multiple resource files being merged
    in the application resources file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中有大量数据模型，将它们的数据模板声明在单独的资源文件中，并在 `App.xaml` 文件中将它们与应用程序资源合并，例如合并到默认控件模板中，可能会有所帮助。因此，在应用程序资源文件中合并多个资源文件并不罕见。
- en: Using professional icons
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专业图标
- en: One thing that can often be underestimated when developing applications is the
    overall impact that a consistent set of decent icons can have. Using mis-matched
    icons that have been sourced from a number of different places can really make
    an otherwise professional looking application look far less professional.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，经常会被低估的是一套一致且质量不错的图标对整体影响。使用来自多个不同地方的不匹配图标，真的会让一个原本看起来专业的应用程序显得不那么专业。
- en: If you or your company cannot afford to or will not for any other reason buy
    a set of custom icons, all is not lost. Visual Studio has long since offered sets
    of professional icons in a number of different formats, that we can utilize in
    our applications free of charge. These are the actual icons that are used in Visual
    Studio, Office and other Microsoft applications, so many users will already be
    familiar with them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您或您的公司无法负担或出于任何其他原因购买一套自定义图标，这并不意味着一切都结束了。Visual Studio早已提供了一系列不同格式的专业图标，我们可以在我们的应用程序中免费使用。这些图标实际上是Visual
    Studio、Office和其他Microsoft应用程序中使用的图标，因此许多用户已经熟悉它们。
- en: 'In older versions of Visual Studio, such as the 2010, or even 2008 versions,
    the provided image libraries were installed with the application and could be
    found at one of the following paths:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio的旧版本中，例如2010版或甚至2008版，提供的图像库与应用程序一起安装，可以在以下路径之一找到：
- en: '`C:\Program Files\Microsoft Visual Studio 9.0\Common7\VS2008ImageLibrary\1033`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Microsoft Visual Studio 9.0\Common7\VS2008ImageLibrary\1033`'
- en: '`C:\Program Files\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
- en: 'Note that on a 64 bit machine, this path would change to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在64位机器上，此路径将更改为以下内容：
- en: '`C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033`'
- en: However, Microsoft changed how the image libraries could be accessed in newer
    versions of Visual Studio, from the 2012 version onwards. In these later versions,
    the image libraries were no longer included in the installation of Visual Studio.
    Instead, we have to search for `Visual Studio Image Library` and manually download
    them from the **Microsoft** website.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Microsoft从Visual Studio的2012版本开始改变了访问图像库的方式。在这些后续版本中，图像库不再包含在Visual Studio的安装中。相反，我们必须搜索`Visual
    Studio Image Library`并从**Microsoft**网站手动下载它们。
- en: The newer icon sets also contain searchable Adobe Reader files that list the
    contents of the icon sets and provide links to the relevant folders of each of
    the icons. Most of the icons are also included in multiple sizes and so the newer
    libraries are much larger than the previous ones.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 新的图标集还包含可搜索的Adobe Reader文件，列出了图标集的内容，并提供到每个图标相关文件夹的链接。大多数图标还包括多个尺寸，因此新的库比之前的库大得多。
- en: 'A few examples of the 2010 icons can be seen in the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了2010年图标的一些示例：
- en: '![](img/09b06e31-4096-49b5-b296-c3e365a1b914.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09b06e31-4096-49b5-b296-c3e365a1b914.png)'
- en: 'The following image shows the same icons, but in the flat style introduced
    in 2015:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了相同的图标，但采用了2015年引入的扁平化风格：
- en: '![](img/30902505-d996-4831-8fd8-634663029cf5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30902505-d996-4831-8fd8-634663029cf5.jpg)'
- en: 'The following image shows how the flat style icons changed in 2017, for comparison:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了2017年扁平化风格图标的变化，以供比较：
- en: '![](img/7286858f-fbf1-49ff-b711-1168980e9eca.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7286858f-fbf1-49ff-b711-1168980e9eca.png)'
- en: Note that no image library was made available with Visual Studio 2019, so maybe
    this is a sign of things to come. However, the current collections of icons will
    cover most purposes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Visual Studio 2019没有提供任何图像库，这可能是未来趋势的一个迹象。然而，当前的图标集合将覆盖大多数用途。
- en: Layering visuals
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层叠视觉元素
- en: So far, we've just looked at simple redefinitions of the standard controls,
    by altering shapes, sizes, borders, and other common properties. However, we can
    do much more than that with WPF. Before continuing with this section, it is important
    to know that the more visuals each control is comprised of, the longer it will
    take to render them and so, this can negatively affect performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是通过改变形状、大小、边框和其他常见属性来查看标准控件的基本重新定义。然而，我们可以用WPF做更多的事情。在继续本节之前，重要的是要知道，每个控件包含的视觉元素越多，渲染它们所需的时间就越长，这可能会对性能产生负面影响。
- en: As such, it's important not to overdo the visual aspect of our controls if our
    application will be run on slow, old computers. Conversely, if we know that our
    end users will have plenty of RAM and/or graphics cards, then we can go the extra
    distance and develop visually stunning controls. Let's take a look at some techniques
    that we can use to improve the look of our controls.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们的应用程序将在运行速度慢、旧的计算机上运行，那么我们就不应该过度强调控件的外观。相反，如果我们知道我们的最终用户将有足够的 RAM 和/或显卡，那么我们可以走得更远，开发出视觉上令人惊叹的控件。让我们看看我们可以使用的一些提高控件外观的技术。
- en: Throwing shadows
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影阴影
- en: One of the easiest ways to make our UI elements pop out of the screen is to
    add a shadow to them. Each control has an `Effect` property that is inherited
    from the `UIElement` class. We can set an object of type `DropShadowEffect` to
    this property to add a shadow to our controls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的 UI 元素从屏幕中跳出来的一种最简单的方法是为它们添加阴影。每个控件都有一个 `Effect` 属性，该属性是从 `UIElement` 类继承的。我们可以将
    `DropShadowEffect` 类型的对象设置到这个属性上，为我们的控件添加阴影。
- en: 'However, we must be conservative with the settings that we use on the `DropShadowEffect`
    element because this effect can be easily overdone. We also do not want to apply
    this effect to every control, as that would spoil the overall effect. It is most
    useful when setting on a panel that contains other controls, or on a border that
    surrounds such a panel. Let''s see a simple example of applying this effect:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须对 `DropShadowEffect` 元素上使用的设置持保守态度，因为这个效果很容易过度使用。我们也不想将此效果应用于每个控件，因为这会破坏整体效果。当设置在包含其他控件的面板上，或设置在围绕此类面板的边框上时，它最有用。让我们看看应用此效果的一个简单示例：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see what the output of this code looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码的输出效果：
- en: '![](img/2b474d8e-e2de-4c43-a0a0-ab80d183dcb7.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b474d8e-e2de-4c43-a0a0-ab80d183dcb7.png)'
- en: In this example, we have a standard button with a `DropShadowEffect` element
    that is set as its `Effect` property. As we'll see later in in this chapter, the
    `DropShadowEffect` class has a number of uses, but its primary use is to create
    shadow effects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个标准的按钮，它将 `DropShadowEffect` 元素设置为 `Effect` 属性。正如我们将在本章后面看到的，`DropShadowEffect`
    类有许多用途，但其主要用途是创建阴影效果。
- en: When using this element for shadow effects, we generally want to set its `Color`
    property to black and its `Opacity` property to a value that is at least semi-transparent
    for best, or most realistic, results. The `ShadowDepth` property dictates how
    far from the element the shadow should fall. Along with the `BlurRadius` property,
    this property is used to add a sense of height to the element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此元素创建阴影效果时，我们通常希望将其 `Color` 属性设置为黑色，并将 `Opacity` 属性设置为至少半透明的值，以获得最佳或最逼真的效果。`ShadowDepth`
    属性决定了阴影应该落在元素多远的位置。与 `BlurRadius` 属性一起，此属性用于为元素添加高度感。
- en: The `BlurRadius` property spreads out the shadow area while also making it less
    dense. Like the `ShadowDepth` property, this property has a default value of five.
    The `Direction` property specifies which direction the shadow should fall in,
    with a value of zero degrees making the shadow fall to the right and increasing
    values moving the shadow angle anti-clockwise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlurRadius` 属性在扩展阴影区域的同时，也使其密度降低。与 `ShadowDepth` 属性类似，此属性的默认值为五。`Direction`
    属性指定阴影应该落在哪个方向，零度值使阴影落在右侧，增加的值使阴影角度逆时针移动。'
- en: Note that a value of `270` makes the shadow fall directly below the applied
    control and is often most suitable for use in business applications. Using this
    angle results in what appears to be an element that is hovering slightly above,
    or in front of, the screen, with a light source coming from above, which is the
    most natural direction for light to come from.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`270` 的值使阴影直接落在应用控件下方，这在商业应用中通常是最合适的。使用这个角度会产生一种元素略微悬停在屏幕上方或前面的效果，光源来自上方，这是光线最自然的方向。
- en: In contrast to this, an angle of `45` degrees for example, would place the shadow
    to the top right of the element and this would have the effect of telling the
    brain that there is a light source to the bottom left. However, this particular
    effect is unnatural looking and can detract from, rather than add to the styling
    of an application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，例如 `45` 度的角度会将阴影放置在元素的右上角，这会向大脑传达有一个光源在左下方的信息。然而，这种特殊效果看起来不自然，可能会削弱而不是增强应用程序的样式。
- en: Declaring multiple borders
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明多个边框
- en: 'Another simple technique that we can use to make our controls stand out is
    to declare multiple `Border` elements for each control. By declaring one or more
    borders within an outer border, we can give our controls that professional look.
    We''ll see how we can animate these borders differently when the user''s mouse
    cursor is over the button later, but for now, let''s see how we can create this
    effect:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的一种简单技术是，为每个控件声明多个`Border`元素。通过在外边框内声明一个或多个边框，我们可以使我们的控件看起来更专业。我们将在稍后看到，当用户的鼠标光标悬停在按钮上时，我们可以如何使这些边框以不同的方式动画化，但现在，让我们看看我们如何创建这种效果：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we have declared a simple `ControlTemplate` element for our
    `Button` control to demonstrate the double border technique. Note that we would
    typically declare this template in the `Application.Resources` section of the
    `App.xaml` file, so that it could be reused, but we have declared it locally to
    save space here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为我们的`Button`控件声明了一个简单的`ControlTemplate`元素，以演示双边框技术。请注意，我们通常会在这个`App.xaml`文件的`Application.Resources`部分声明此模板，以便它可以被重用，但在这里我们将其局部声明以节省空间。
- en: Note that we need to adjust the corner radius of the inner border to accurately
    fit within the outer border. If we had used the same size for both, they would
    not have correctly fit together. Also, we have set the `SnapsToDevicePixels` property
    to `true` on the two borders to ensure that they are not blurred by anti-aliasing
    artefacts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要调整内边框的圆角半径，以确保它能够准确适应外边框。如果我们使用相同的大小，它们将无法正确地结合在一起。此外，我们已将两个边框的`SnapsToDevicePixels`属性设置为`true`，以确保它们不会被反走样伪影模糊。
- en: One further point to note is that we have used `#7FFFFFFF` as the value for
    the background of the outer border and the border brush of the inner border. The
    alpha channel in this value is set to `7F`, which equates to an opacity value
    of `0.5`. This means that these elements will be partly transparent and so the
    colors from the background will partly show through the border edges.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，我们使用了`#7FFFFFFF`作为外边框和内边框边框刷的背景值。在这个值中，alpha通道被设置为`7F`，相当于不透明度值为`0.5`。这意味着这些元素将部分透明，因此背景颜色将部分透过边框边缘显示。
- en: 'We added our button into a `Grid` panel and set a `LinearGradientBrush` object
    as its background to demonstrate this semi-transparent effect. When rendered,
    our background gradient and button will look like the following image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的按钮添加到一个`Grid`面板中，并将其背景设置为`LinearGradientBrush`对象以演示这种半透明效果。当渲染时，我们的背景渐变和按钮将看起来像以下图像：
- en: '![](img/b436441f-bb8c-4a96-8ccb-ef4f5c39f9b4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b436441f-bb8c-4a96-8ccb-ef4f5c39f9b4.png)'
- en: Reusing composite visuals
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用复合视觉元素
- en: 'The next technique involves defining a particular motif that will be rendered
    in the background of our controls. This could be all or part of a company logo,
    a particular shape, or even just a simple, well-placed curve. This will form the
    bottom most level of our control visuals and can have additional levels of visuals
    on top. Let''s take a look at one way in which we could implement such a design,
    starting with defining some resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术涉及定义将在控件背景中渲染的特定图案。这可能是一个公司标志的全部或部分、一个特定的形状，甚至只是一个简单、位置恰当的曲线。这将成为我们控件视觉的最低层，并且可以在其上方有额外的视觉层。让我们看看我们可以如何实现这种设计，首先从定义一些资源开始：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few elements to this design, so let's take a look at each one individually.
    We started by declaring a `RadialGradientBrush` element with the key `LayeredButtonBackgroundBrush`
    and a `LinearGradientBrush` with a key of `LayeredButtonCurveBrush`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计有几个元素，所以让我们逐个查看。我们首先声明了一个具有键`LayeredButtonBackgroundBrush`的`RadialGradientBrush`元素和一个具有键`LayeredButtonCurveBrush`的`LinearGradientBrush`。
- en: The `RadiusX` and `RadiusY` properties of the `RadialGradientBrush` element
    specify the `X` and `Y` radii of the outermost ellipse that encompasses the radial
    gradient, while the `Center` and `GradientOrigin` properties dictate the center
    and focal point of the radial gradient and enable us to position it precisely
    within our rectangle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadialGradientBrush`元素的`RadiusX`和`RadiusY`属性指定了包含径向渐变的最大椭圆的`X`和`Y`半径，而`Center`和`GradientOrigin`属性决定了径向渐变的中心和焦点，并使我们能够精确地在矩形内定位它。'
- en: The `LinearGradientBrush` element has a `StartPoint` value of `0,0` and an `EndPoint`
    value of `1,1`, which results in a diagonal gradient. With this particular design,
    the idea is to have a sharp contrast between the two gradients at the center and
    to somewhat blend them together at the edges.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearGradientBrush`元素具有`StartPoint`值为`0,0`和`EndPoint`值为`1,1`，这导致了一个对角渐变。在这个特定的设计中，目的是在中心处两个渐变之间有鲜明的对比，并在边缘处将它们稍微混合在一起。'
- en: Next, we declare a `Grid` panel with the key `LayeredButtonBackgroundElements`,
    which contains a `Rectangle` and a `Path` element. The rectangle is stretched
    to fill the panel by default and is painted with the `LayeredButtonBackgroundBrush`
    resource. The `Path` element is painted with the `LayeredButtonCurveBrush` resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个具有键`LayeredButtonBackgroundElements`的`Grid`面板，它包含一个`Rectangle`和一个`Path`元素。默认情况下，矩形被拉伸以填充面板，并用`LayeredButtonBackgroundBrush`资源绘制。`Path`元素用`LayeredButtonCurveBrush`资源绘制。
- en: The `Data` property of the `Path` object is where we define the shape of the
    path. There are a number of ways that we can specify the path data; however, in
    this example, we use a `CombinedGeometry` element with a `GeometryCombineMode`
    value of `Intersect`, which outputs a single shape that represents the intersection
    of the two specified geometry shapes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象的`Data`属性是我们定义路径形状的地方。我们可以用多种方式指定路径数据；然而，在这个例子中，我们使用了一个具有`GeometryCombineMode`值为`Intersect`的`CombinedGeometry`元素，它输出一个代表两个指定几何形状交集的单个形状。'
- en: Inside the `CombinedGeometry` element, we have the `Geometry1` and `Geometry2`
    properties, where we combine the two geometry shapes according to the `Intersect`
    mode specified by the `GeometryCombineMode` property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CombinedGeometry`元素内部，我们有`Geometry1`和`Geometry2`属性，其中我们根据`GeometryCombineMode`属性指定的`Intersect`模式组合这两个几何形状。
- en: Our first shape defines the curve in our design and comes from an `EllipseGeometry`
    element, using the `Center` property to position the ellipse and the `RadiusX`
    and `RadiusY` properties to shape it. The second shape is a rectangle that comes
    from a `RectangleGeometry` element and is defined by its `Rect` property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个形状定义了设计中的曲线，并来自一个`EllipseGeometry`元素，使用`Center`属性定位椭圆，使用`RadiusX`和`RadiusY`属性来塑造它。第二个形状是一个来自`RectangleGeometry`元素的矩形，由其`Rect`属性定义。
- en: The intersection of these two shapes is the result of this path and approximately
    covers the bottom section of our overall shape, up to the curve. The partly obscured
    rectangle element behind this completes the remainder of the overall shape.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个形状的交集是此路径的结果，并大致覆盖了我们整体形状的底部部分，直到曲线。背后部分遮挡的矩形元素完成了整体形状的其余部分。
- en: 'The `Visual` property of the `VisualBrush` element with the `LayeredButtonBackground` key
    is set to the `LayeredButtonBackgroundElements` panel, so any UI element that
    is painted with this brush will now have this design imprinted on it. Once we
    have added these resources to the `Application.Resources` section in the `App.xaml` file,
    we can use them through the `VisualBrush` element, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 具有带有`LayeredButtonBackground`键的`VisualBrush`元素的`Visual`属性被设置为`LayeredButtonBackgroundElements`面板，因此任何用此画笔绘制的UI元素现在都将印有这种设计。一旦我们将这些资源添加到`App.xaml`文件中的`Application.Resources`部分，我们就可以通过`VisualBrush`元素使用它们，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will render the gradients in the button background, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在按钮背景中渲染渐变，如下所示：
- en: '![](img/b2245a20-d18a-4ec1-a932-ade30cc797cd.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2245a20-d18a-4ec1-a932-ade30cc797cd.png)'
- en: In this example, we manually specify the reference to the visual brush to paint
    the `Button` object's background. However, setting the background in this way
    would require the developers that use our application framework to do this each
    time they add a button. A better solution would be to redesign the default button
    template so that the visual brush is automatically applied to each button. We'll
    see an example of this later in this chapter when we pull together a number of
    these techniques.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们手动指定了视觉画笔的引用来绘制`Button`对象的背景。然而，以这种方式设置背景将要求使用我们应用程序框架的开发者在每次添加按钮时都这样做。更好的解决方案是重新设计默认按钮模板，以便视觉画笔自动应用于每个按钮。我们将在本章后面看到这个例子，当我们汇集这些技术时。
- en: Reflecting light
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射光线
- en: 'Another technique involves adding a semi-opaque layer with a gradient that
    fades to transparency over the top of our controls to give the appearance of the
    reflection of a light source. This can easily be achieved using a simple `Border`
    element and a `LinearGradientBrush` instance. Let''s look at how we can accomplish
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是在我们的控件顶部添加一个半透明层，该层具有渐变到透明的效果，以产生光源反射的外观。这可以通过简单的 `Border` 元素和一个 `LinearGradientBrush`
    实例轻松实现。让我们看看我们如何完成这个任务：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When run, this example will produce a button that looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，将生成一个看起来像这样的按钮：
- en: '![](img/489c3568-28ae-42ee-9b59-30c186132bcc.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/489c3568-28ae-42ee-9b59-30c186132bcc.png)'
- en: Let's examine this example. We start by declaring the `Button` element with
    a few style properties. Rather than defining a separate style or control template
    in a resources section, as we would in a real-world application, we again declare
    the template inline to save space here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个示例。我们首先声明具有一些样式属性的 `Button` 元素。与在现实世界应用中定义单独的样式或控件模板不同，我们再次在这里内联声明模板以节省空间。
- en: In the control template, we first declare a `Border` element with a jade green
    background and a `CornerRadius` value of `5`. We again set the `SnapsToDevicePixels`
    property to `true` to ensure that the edges remain sharp.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制模板中，我们首先声明一个具有翡翠绿色背景和 `CornerRadius` 值为 `5` 的 `Border` 元素。我们再次将 `SnapsToDevicePixels`
    属性设置为 `true`，以确保边缘保持锐利。
- en: Inside the border, we define two elements within a `Grid` panel. The first is
    the `Rectangle` element that produces the reflection effect and the second is
    the required `ContentPresenter` object. The rectangle uses a value of `4` in the
    `RadiusX` and `RadiusY` properties and sets the `Margin` property appropriately
    to ensure that there is a tiny gap around the edge of the reflection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在边框内部，我们在 `Grid` 面板中定义了两个元素。第一个是产生反射效果的 `Rectangle` 元素，第二个是所需的 `ContentPresenter`
    对象。矩形使用 `RadiusX` 和 `RadiusY` 属性中的 `4` 值，并适当地设置 `Margin` 属性以确保在反射边缘周围有一个微小的间隙。
- en: It also sets its `SnapsToDevicePixels` property to true to ensure that this
    tiny gap is not blurred. Note that the value for the bottom margin is `7`, because
    we do not want the reflection effect to cover the bottom half of the button. The
    `Fill` property is where the reflection effect is actually created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将其 `SnapsToDevicePixels` 属性设置为 `true`，以确保这个微小的间隙不会被模糊。请注意，底部边距的值为 `7`，因为我们不希望反射效果覆盖按钮的下半部分。`Fill`
    属性实际上是创建反射效果的地方。
- en: In the rectangle's `Fill` property, we define a vertical `LinearGradientBrush`
    element by setting both of the `X` values of the `StartPoint` and `EndPoint` properties
    and the `StartPoint.Y` property to `0` and the `Endpoint.Y` property to `1`; plotting
    these points on a graph will produce a vertical line, and so this produces a vertical
    gradient.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩形的 `Fill` 属性中，我们通过设置 `StartPoint` 和 `EndPoint` 属性的 `X` 值以及 `StartPoint.Y`
    属性为 `0` 和 `Endpoint.Y` 属性为 `1`，定义了一个垂直的 `LinearGradientBrush` 元素；将这些点绘制在图上会产生一条垂直线，因此这产生了一个垂直渐变。
- en: In the `GradientStops` collection of the `LinearGradientBrush` object, we have
    defined two `GradientStop` elements. The first has an offset of zero and is set
    to a white color with a hexadecimal alpha channel value of `BF`, which approximates
    an opacity value of `0.7`. The second has an offset of `0.8` and is set to a white
    color that has a hexadecimal alpha channel value of `00`, which results in a completely
    transparent color and could be replaced with the `Transparent` color.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LinearGradientBrush` 对象的 `GradientStops` 集合中，我们定义了两个 `GradientStop` 元素。第一个元素的偏移量为零，设置为白色，并具有十六进制
    alpha 通道值 `BF`，这大约相当于不透明度值 `0.7`。第二个元素的偏移量为 `0.8`，设置为白色，并具有十六进制 alpha 通道值 `00`，这导致颜色完全透明，可以用
    `Transparent` 颜色替换。
- en: The resulting gradient, therefore, starts slightly transparent at the top and
    is fully transparent at the bottom, which, with the bottom margin and offset values,
    is actually around the middle of the button. As with our other examples, the `ContentPresenter`
    object is declared afterwards so that it is rendered on top of the reflection
    effect.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，生成的渐变从顶部略微透明开始，并在底部完全透明，结合底部边距和偏移值，实际上位于按钮的中间。与我们的其他示例一样，`ContentPresenter`
    对象随后声明，以便它被渲染在反射效果之上。
- en: Creating glowing effects
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发光效果
- en: 'Another effect that we can create for our controls is that of a glowing appearance,
    as if a light were shining outward from inside the control. We''ll need another
    `LinearGradientBrush` instance and UI element to paint it on. A `Rectangle` element
    suits this role well, as it''s very lightweight. We should define these resources
    in the application resources in the `App.xaml` file to enable every View to use
    them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的控件创建另一种效果，即发光外观，就像光线从控件内部向外照射一样。我们需要另一个`LinearGradientBrush`实例和UI元素来绘制它。`Rectangle`元素非常适合这个角色，因为它非常轻量。我们应该在`App.xaml`文件中的应用程序资源中定义这些资源，以使每个视图都能使用它们：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We start off by declaring a `TransformGroup` element that enables us to group
    one or more transform objects together. Inside it, we define a `ScaleTransform`
    element that scales applied elements vertically by the default factor of `1` and
    horizontally by a factor of `1.8`. We specify the center of this transformation
    using its `CenterX` and `CenterY` properties. Next, we declare a `TranslateTransform`
    element that moves applied elements downwards by a small amount.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个`TransformGroup`元素，它使我们能够将一个或多个变换对象组合在一起。在其内部，我们定义一个`ScaleTransform`元素，该元素将应用元素的垂直缩放因子设置为默认值`1`，水平缩放因子设置为`1.8`。我们使用其`CenterX`和`CenterY`属性指定这个变换的中心。接下来，我们声明一个`TranslateTransform`元素，该元素将应用元素向下移动一小段距离。
- en: After this, we define a `RadialGradientBrush` object that will represent the
    glow in our design. We use the `RadiusX` and `RadiusY` properties to shape the
    brush element and specify the `Center` and `GradientOrigin` properties to dictate
    the center and focal point of the radial gradient.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们定义一个`RadialGradientBrush`对象，它将代表我们设计中的发光效果。我们使用`RadiusX`和`RadiusY`属性来塑造画笔元素，并指定`Center`和`GradientOrigin`属性来指定径向渐变的中心和焦点。
- en: We then set the `TransformGroup` element to the `RelativeTransform` property
    of the brush to apply the transforms to it. Note that the three `GradientStop`
    elements all use the same `R`, `G` and `B` values, and just differ in the alpha
    channel, or opacity values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`TransformGroup`元素设置为画笔的`RelativeTransform`属性，以将变换应用到它上面。请注意，三个`GradientStop`元素都使用相同的`R`、`G`和`B`值，只是在透明度通道或不透明度值上有所不同。
- en: Next, we declare the `GlowingButtonStyle` style for type `Button`, setting the
    `SnapsToDevicePixels` property to `true`, to keep its lines crisp and sharp. In
    the `Template` property, we define a `ControlTemplate` element with a white `Border`
    element that has slightly rounded corners.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`GlowingButtonStyle`样式，用于类型`Button`，将`SnapsToDevicePixels`属性设置为`true`，以保持其线条清晰和锐利。在`Template`属性中，我们定义一个包含白色`Border`元素的`ControlTemplate`元素，该`Border`元素具有略微圆滑的角落。
- en: Inside the border, we declare a `Grid` panel containing a `Rectangle` and a
    `ContentPresenter` element. Again, the `RadiusX` and `RadiusY` properties of the
    rectangle are set to a smaller value than that of the `CornerRadius` property
    of the parent border control to ensure that it fits evenly within it. Our `RadialGradientBrush`
    resource is assigned as the rectangle's `Fill` property.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在边框内部，我们声明一个包含`Rectangle`和`ContentPresenter`元素的`Grid`面板。同样，矩形的`RadiusX`和`RadiusY`属性设置为比父边框控件`CornerRadius`属性更小的值，以确保它均匀地适合其中。我们的`RadialGradientBrush`资源被分配为矩形的`Fill`属性。
- en: The `ContentPresenter` object is centered to ensure that the content of the
    button will be rendered in its center. Returning to the `Border` element, we see
    a `DropShadowEffect` is declared within its `Effect` property. However, this element
    is not here to create a shadow effect; this class is multi-functional and can
    also render glowing effects as well as shadow effects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPresenter`对象被居中，以确保按钮的内容将在其中心渲染。回到`Border`元素，我们看到在其`Effect`属性中声明了一个`DropShadowEffect`。然而，这个元素不是为了创建阴影效果；这个类是多功能的，也可以渲染发光效果以及阴影效果。'
- en: The trick is to set its `Color` property to a color other than black and its
    `BlurRadius` property to a larger value than we would typically use when creating
    a shadow effect. In this particular case, we set the `Direction` property to `270`
    and the `ShadowDepth` property to `4` in order to position the glow effect toward
    the bottom of the border, where the light is supposed to be coming from.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧在于将其`Color`属性设置为非黑色，并将`BlurRadius`属性设置为比我们通常在创建阴影效果时使用的更大值。在这种情况下，我们将`Direction`属性设置为`270`，将`ShadowDepth`属性设置为`4`，以便将发光效果定位在边界的底部，即光线应该从那里发出的位置。
- en: 'Unfortunately, this effect does not translate to grayscale and paper well,
    so the glowing effect is somewhat lost when not viewed in color and on screen.
    For readers of the e-book version of this book, here is what the glowing effect
    from our example looks like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种效果并不能很好地转换为灰度或纸张效果，因此在非彩色和屏幕上查看时，发光效果会有所损失。对于本书电子书版本的读者，以下是我们的示例中发光效果的外观：
- en: '![](img/ad149cc5-d086-44df-8589-8152a3b2abfd.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad149cc5-d086-44df-8589-8152a3b2abfd.png)'
- en: Putting it all together
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'While these various effects can improve the look of our controls on their own,
    the biggest improvement can be found when amalgamating a number of them into a
    single design. In this next example, we''ll do just that. We first need to add
    a few more resources to use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些各种效果可以单独改善我们的控件的外观，但最大的改进往往是在将它们合并到单一设计中时实现的。在接下来的例子中，我们将这样做。我们首先需要添加一些额外的资源来使用：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There isn''t anything too complicated here. We simply have a number of colors
    defined with varying levels of transparency and a slightly transparent version
    of our visual brush that references our layered background elements. Let''s move
    on to the encompassing style now:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么太复杂的东西。我们只是定义了具有不同透明度级别的一系列颜色，以及一个稍微透明的视觉笔刷版本，它引用了我们的分层背景元素。现在让我们继续到包含的样式：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Looking at the example XAML, we can see that the `SnapsToDevicePixels` property
    is set to `true`, to avoid anti-aliasing artifacts blurring the edges of the button,
    and the `Cursor` property is set to display the pointing finger cursor when the
    user's mouse is over the button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观察示例XAML，我们可以看到`SnapsToDevicePixels`属性设置为`true`，以避免反走样伪影模糊按钮的边缘，并且`Cursor`属性设置为当用户的鼠标悬停在按钮上时显示指向的手指光标。
- en: Within the control template, we see the two nested `Border` elements. Note that
    the outer border uses the `TransparentBlack` and `TransparentWhite` brush resources
    so that it is semi-transparent. Also, note that the white inner border actually
    comes from the background of the outer border rather than the inner border, which
    sets the `Margin` property to `1` to give the impression of an inner border.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在控件模板中，我们看到两个嵌套的`Border`元素。请注意，外部边框使用`TransparentBlack`和`TransparentWhite`笔刷资源，使其半透明。此外，请注意，白色内部边框实际上来自外部边框的背景，而不是内部边框，这设置了`Margin`属性为`1`，以产生内部边框的印象。
- en: In this example, the inner border element is only responsible for displaying
    the layered button elements from the visual brush and has no displayed border
    of its own. Again, we have adjusted its `CornerRadius` property so that it fits
    neatly within the outer border. We can zoom in on the magnification level in the
    WPF designer to help us to decide what values we should use here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，内部边框元素仅负责从视觉笔刷中显示分层按钮元素，并且它本身没有显示的边框。再次强调，我们已经调整了它的`CornerRadius`属性，使其能够整齐地嵌入外部边框中。我们可以在WPF设计器中放大到放大级别，以帮助我们决定在这里应该使用哪些值。
- en: Inside the inner border, we declare a `Grid` panel, so that we can add both
    the required `ContentPresenter` and the `Rectangle` element that is painted with
    the `GreenGlow` brush from the resources. Again, we set its `IsHitTestVisible`
    property to `false`, so that users cannot interact with it and set the `RadiusX`
    and `RadiusY` properties to match the `CornerRadius` value of the inner border.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部边框内，我们声明了一个`Grid`面板，这样我们就可以添加所需的`ContentPresenter`和用资源中的`GreenGlow`笔刷绘制的`Rectangle`元素。再次强调，我们将它的`IsHitTestVisible`属性设置为`false`，这样用户就不能与之交互，并将`RadiusX`和`RadiusY`属性设置为与内部边框的`CornerRadius`值相匹配。
- en: We use `TemplateBinding` elements to map properties of the `ContentPresenter`
    object to suitable properties from the templated object so that setting properties
    on our button can affect its positioning and content. Next, we set the previously
    displayed `DropShadowEffect` element to the `Effect` property of the outer border
    and that sums up the contained UI elements in the template.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TemplateBinding`元素将`ContentPresenter`对象的属性映射到模板对象的适当属性，以便设置按钮上的属性可以影响其定位和内容。接下来，我们将之前显示的`DropShadowEffect`元素设置为外部边框的`Effect`属性，这样就在模板中总结了包含的UI元素。
- en: To make the template more useful, we have set some `Trigger` objects in the
    `ControlTemplate.Triggers` collection, that will add mouse over effects for our
    button. The first trigger targets the `IsMouseOver` property and sets the background
    of the inner border to the slightly more transparent version of the layered button
    elements visual brush when true.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模板更有用，我们在`ControlTemplate.Triggers`集合中设置了一些`Trigger`对象，这些对象将为我们的按钮添加鼠标悬停效果。第一个触发器针对`IsMouseOver`属性，并在属性为真时将内部边框的背景设置为分层按钮元素视觉画刷的略微透明版本。
- en: The second trigger targets the `IsPressed` property and re-applies the original
    visual brush when the property is true. Note that these two triggers must be defined
    in this order, so that the one that targets the `IsPressed` property will override
    the other when both conditions are true. It is of course, a matter of taste, whether
    the button lights up or goes out when clicked, or perhaps even changes color.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个触发器针对`IsPressed`属性，并在属性为真时重新应用原始视觉画刷。请注意，这两个触发器必须按此顺序定义，以便当两个条件都为真时，针对`IsPressed`属性的触发器将覆盖另一个。当然，按钮在点击时是点亮还是熄灭，或者甚至改变颜色，这完全取决于个人喜好。
- en: 'Note that we omitted the `x:Key` directive on this style so that it will be
    implicitly applied to all `Button` elements that do not have a different style explicitly
    applied to them. We are, therefore, able to declare our `Button` elements without
    specifying the style, like the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这个样式中省略了`x:Key`指令，因此它将隐式应用于所有没有明确应用不同样式的`Button`元素。因此，我们可以在不指定样式的情况下声明我们的`Button`元素，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following visual output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下视觉输出：
- en: '![](img/a290a5d8-c832-4018-8e76-f4f183565601.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a290a5d8-c832-4018-8e76-f4f183565601.png)'
- en: We could take this glowing idea further too, by defining a number of different
    color resources and using data triggers inside a data template to change the color
    of the glow to indicate different states of a data object. This enables us to
    provide further visual information to the users, in addition to the usual textual
    feedback methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过定义多个不同的颜色资源并在数据模板中使用数据触发器来进一步扩展这个发光的想法，以改变发光的颜色来指示数据对象的不同状态。这使我们能够向用户提供额外的视觉信息，除了通常的文本反馈方法之外。
- en: For example, a blue glow on a data Model object could specify an unchanged object,
    while green could signify an object with valid changes and red could highlight
    an object in error. We'll see how we can implement this idea in the next chapter,
    but for now, let's continue looking at different ways to make our applications
    stand out from the crowd.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数据模型对象上的蓝色光芒可以指定未更改的对象，而绿色可以表示有有效更改的对象，红色可以突出显示错误的对象。我们将在下一章中看到如何实现这个想法，但就目前而言，让我们继续探讨不同的方法来使我们的应用脱颖而出。
- en: Moving away from the ordinary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离开常规
- en: The vast majority of business applications in general, look fairly ordinary,
    with various form pages containing banks of standard rectangular form fields.
    Visually appealing applications on the other hand, stand out from the crowd. Therefore,
    in order to create visually appealing applications, we need to move away from
    the ordinary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般商业应用中，大多数看起来相当普通，包含各种包含标准矩形表单字段的表单页面。另一方面，视觉吸引人的应用则脱颖而出。因此，为了创建视觉吸引人的应用，我们需要离开常规。
- en: Whether this means simply adding control templates with rounded corners for
    our controls or something more is up to you. There are many different ways that
    we can enhance the look of our controls and we'll take a look at a number of these
    ideas in this section. Let's start with a refection effect that is best suited
    for use with logos or startup and background images.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为我们的控件添加具有圆角的控件模板，或者更多，这取决于你。我们可以以许多不同的方式增强控件的外观，我们将在本节中探讨这些想法中的许多。让我们从一个最适合与徽标或启动和背景图像一起使用的反射效果开始。
- en: Casting reflections
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投射反射
- en: All `FrameworkElement`-derived classes have a `RenderTransform` property that
    we can utilize to transform their rendered output in a variety of ways. A `ScaleTransform`
    element enables us to scale each object in both horizontal and vertical directions.
    One useful facet about the `ScaleTransform` object is that we can also scale negatively,
    and therefore reverse the visual output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`FrameworkElement`派生类都有一个`RenderTransform`属性，我们可以利用它以各种方式转换它们的渲染输出。一个`ScaleTransform`元素使我们能够同时在水平和垂直方向上缩放每个对象。关于`ScaleTransform`对象的一个有用方面是，我们也可以负向缩放，从而反转视觉输出。
- en: 'One visually pleasing effect that we can create with this particular facet
    is a mirror image, or reflection, of the object. In order to enhance this effect,
    we can use an opacity mask to fade out the reflection as it recedes from the object.
    This can give the visual impression of an object being reflected on a shiny surface,
    as shown in the following image:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个特定的特性创建一个视觉上令人愉悦的效果，即对象的镜像或反射。为了增强这个效果，我们可以使用透明度遮罩来随着反射从对象退去而淡出反射。这可以给视觉上造成一个物体在光滑表面上反射的印象，如下面的图像所示：
- en: '![](img/66ac37ab-3ec6-4727-a887-664fbc9d9344.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66ac37ab-3ec6-4727-a887-664fbc9d9344.png)'
- en: 'Let''s see how we can achieve this result:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这个结果：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we use a `StackPanel` object to position a `TextBlock` element
    above a `Rectangle` element. The text will be the object to reflect and the reflection
    will be generated in the rectangle. The panel's width is constrained to ensure
    that the reflection fits the text element exactly. We start by naming the `TextBlock`
    element and setting some typeface properties, along with the text to output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`StackPanel`对象将`TextBlock`元素放置在`Rectangle`元素之上。文本将是反射的对象，反射将在矩形中生成。面板的宽度被限制以确保反射正好适合文本元素。我们首先命名`TextBlock`元素，并设置一些字体属性，以及要输出的文本。
- en: We've set a `LinearGradientBrush` object as the color for the text to make it
    more interesting, although this plays no part in creating the reflection effect.
    Next, note that the `Rectangle` element is sized and positioned exactly to fit
    the size of the text from the `TextBlock` element. We can of course use this technique
    to reflect anything and are not restricted to just reflecting text elements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个`LinearGradientBrush`对象作为文本的颜色，使其更有趣，尽管这并不参与创建反射效果。接下来，请注意，`Rectangle`元素的大小和位置被精确设置以适应来自`TextBlock`元素的文本大小。我们当然可以使用这种技术来反射任何东西，并不限于仅反射文本元素。
- en: The background of the rectangle is painted with a `VisualBrush` object, where
    the `Visual` property is data bound to the visual output of the `TextBlock` element,
    using the `ElementName` property. Note the `RelativeTransform` property of the
    `VisualBrush` object, enables us to transform the visual in some way and is set
    to an instance of the `ScaleTransform` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的背景是用`VisualBrush`对象绘制的，其中`Visual`属性绑定到`TextBlock`元素的视觉输出，使用`ElementName`属性。注意`VisualBrush`对象的`RelativeTransform`属性，它使我们能够以某种方式变换视觉，并设置为`ScaleTransform`类的实例。
- en: This is one of the most important constituents for creating this effect, as
    this element is what inverts the related visual in the vertical plane. Setting
    the `ScaleY` property to `-1` will invert the visual vertically for us, while
    setting the `ScaleX` property to `-1` would invert the visual horizontally. Note
    that we omit the `ScaleX` property here because we want it set at its default
    value of `1`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的组成部分之一，因为这个元素在垂直平面上反转了相关的视觉。将`ScaleY`属性设置为`-1`将垂直反转视觉，而将`ScaleX`属性设置为`-1`将水平反转视觉。请注意，我们在这里省略了`ScaleX`属性，因为我们希望将其设置为默认值`1`。
- en: Next, we see the `OpacityMask` property, which lets us set a gradient brush
    to be mapped to the opacity of the rectangle. When the alpha channel of the brush
    is `1`, the rectangle will be opaque, when it is `0`, the rectangle will be transparent
    and when it is in between, the rectangle will be semi-transparent. This is the
    other essential part of this effect and creates the fade of the reflected image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到`OpacityMask`属性，它允许我们设置一个渐变画刷来映射到矩形的透明度。当画刷的alpha通道为`1`时，矩形将是完全不透明的，当它为`0`时，矩形将是透明的，当它在两者之间时，矩形将是半透明的。这是这个效果的另一个重要部分，它创建了反射图像的淡出效果。
- en: In our example, we have a vertical gradient that is almost solid black at the
    top and gets increasingly transparent until it reaches four fifths of the way
    down, where it becomes fully transparent. When set as the rectangle's `OpacityMask`,
    only the alpha channel values are used and this results in it being totally visible
    at the top and then fading to invisibility four fifths of the way down, as shown
    in the preceding image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有一个垂直渐变，顶部几乎是纯黑色，并且逐渐变得透明，直到达到四分之四的位置，此时它变得完全透明。当设置为矩形的`OpacityMask`时，只使用alpha通道值，这导致它在顶部完全可见，然后逐渐淡出到四分之四的位置，如前图所示。
- en: Exploring borderless windows
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索无边框窗口
- en: Using WPF, it is possible to create windows without borders, a title bar, and
    the standard minimize, restore and close buttons. It is also possible to create
    irregular shaped windows and windows with transparent areas that display whatever
    lies beneath. Although it would be somewhat unconventional to make our main application
    window borderless, we can still take advantage of this ability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WPF，我们可以创建没有边框、标题栏以及标准最小化、恢复和关闭按钮的窗口。我们还可以创建不规则形状的窗口和具有透明区域的窗口，这些区域可以显示其下方的任何内容。虽然使我们的主应用程序窗口无边框可能有些不寻常，但我们仍然可以利用这一功能。
- en: For example, we could create a borderless window for custom message boxes, or
    perhaps for extended tooltips, or any other popup control that provides information
    to the end user. Creating borderless windows can be achieved in a few simple steps.
    Let's start with the basics and assume that we're adding this to our existing
    application framework.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个无边框窗口用于自定义消息框，或者可能是扩展工具提示，或者任何其他向最终用户提供信息的弹出控件。创建无边框窗口可以通过几个简单的步骤实现。让我们从基础知识开始，并假设我们正在将其添加到现有的应用程序框架中。
- en: In this case, we've already got our `MainWindow` class and need to add an additional
    window. As we saw in [Chapter 6](c60a6db9-4352-4eb3-ac1d-406fd337b1b4.xhtml),
    *Adapting the Built-In Controls*, we can do this by adding a new `UserControl`
    to our project and replacing the word `UserControl` with the word `Window`, *in
    both the XAML file and its associated code behind file*. Failure to change both
    will result in a design time error that complains about mismatched classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经有了一个 `MainWindow` 类，并需要添加一个额外的窗口。正如我们在[第 6 章](c60a6db9-4352-4eb3-ac1d-406fd337b1b4.xhtml)中看到的，*适配内置控件*，我们可以通过向项目中添加一个新的
    `UserControl` 并将 `UserControl` 中的单词替换为 `Window`，*在 XAML 文件及其关联的代码后文件中*来实现这一点。如果未能同时更改这两个文件，将导致设计时错误，并抱怨类不匹配。
- en: Alternatively, we can right click on the start up project and select Add and
    then Window…, and then cut and paste it wherever you want it to reside. Unfortunately,
    Visual Studio provides no other way to add a `Window` control into our other projects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以右键点击启动项目，选择添加，然后点击 Window…，接着将其剪切并粘贴到你希望它所在的位置。不幸的是，Visual Studio 没有提供其他方法将
    `Window` 控件添加到我们的其他项目中。
- en: 'Once we have our `Window` object, all we need to do is to set its `WindowStyle`
    property to `None` and its `AllowsTransparency` property to `true`. This will
    result in the white background of our window appearing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `Window` 对象，我们只需要将其 `WindowStyle` 属性设置为 `None` 并将其 `AllowsTransparency`
    属性设置为 `true`。这将导致窗口的白色背景出现：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, while this removes the default window chrome that we are all used
    to and provides us with a borderless window, it also removes the standard buttons,
    so we are unable to close, resize, or even move the window directly. Luckily,
    making our window moveable is a very simple matter. We just need to add the following
    line of code into our window''s constructor after the `InitializeComponent` method
    is called:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这样做移除了我们所有人都习惯的默认窗口边框，并为我们提供了一个无边框窗口，但它也移除了标准按钮，因此我们无法直接关闭、调整大小或移动窗口。幸运的是，使我们的窗口可移动是一个非常简单的事情。我们只需要在调用
    `InitializeComponent` 方法之后，将以下代码行添加到窗口的构造函数中：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `DragMove` method is declared within the `Window` class and enables us
    to click and drag the window from anywhere within its bounds. We could easily
    recreate the normal window functionality of only being able to move the window
    from the title bar by adding our own title bar and attaching this anonymous event
    handler to that object's `MouseLeftButtonDown` event instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `DragMove` 方法是在 `Window` 类中声明的，它使我们能够从其边界内的任何位置点击并拖动窗口。我们可以轻松地通过添加自己的标题栏并将此匿名事件处理程序附加到该对象的
    `MouseLeftButtonDown` 事件来重新创建仅能从标题栏移动窗口的正常窗口功能。
- en: If we want our borderless window to be resizable, there is a `ResizeMode` property
    in the `Window` class that provides us with a few options. One value that we can
    use with our borderless window is the `CanResizeWithGrip` value. This option adds
    a so-called resize grip, specified by a triangular pattern of dots in the bottom
    right corner of the window, that users can resize the window with.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的无边框窗口可调整大小，`Window` 类中有一个 `ResizeMode` 属性，它为我们提供了一些选项。我们可以用于我们的无边框窗口的一个值是
    `CanResizeWithGrip`。此选项添加了一个所谓的调整大小手柄，由窗口右下角的三角形点图案指定，用户可以使用它来调整窗口大小。
- en: 'If we set the `ResizeMode` property to this value and set the background to
    a color that will contrast with this resize grip, we will end with this visual
    output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `ResizeMode` 属性设置为这个值，并将背景设置为与调整大小控件形成对比的颜色，我们将得到这个视觉输出：
- en: '![](img/7e42ec98-e6ba-4dc9-98a5-522bf0c8ca00.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e42ec98-e6ba-4dc9-98a5-522bf0c8ca00.png)'
- en: However, we still have no way to close the window. For this, we could add our
    own button, or perhaps enable the window to be closed by pressing the escape *Esc*key or
    some other key on the keyboard. Either way, whatever the trigger, closing the
    window is a simple matter of calling the window's `Close` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然没有关闭窗口的方法。为此，我们可以添加自己的按钮，或者也许可以启用通过按键盘上的 escape *Esc* 键或其他键来关闭窗口。无论哪种方式，无论触发器是什么，关闭窗口只是调用窗口的
    `Close` 方法这么简单。
- en: Rather than implementing a replacement window chrome, which could be easily
    achieved with a few borders, let's focus on developing a borderless window with
    an irregular shape, that we could use to popup helpful information for the users.
    Ordinarily, we would need to set the window's background to transparent to hide
    it, but we will be replacing its control template, so we don't need to do this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实现一个带有边框的替代窗口样式，这可以通过几个边框轻松实现，让我们专注于开发一个无边框且形状不规则的窗口，我们可以用它来弹出对用户有用的信息。通常，我们需要将窗口的背景设置为透明来隐藏它，但我们将替换其控件模板，因此我们不需要这样做。
- en: For this example, we don't need a resize grip either, so let's set the `ResizeMode`
    property to `NoResize`. We also have no need to move this callout window by mouse,
    so we don't need to add the anonymous event handler that calls the `DragMove`
    method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们也不需要调整大小控件，因此让我们将 `ResizeMode` 属性设置为 `NoResize`。我们也没有必要通过鼠标移动这个调用窗口，因此不需要添加调用
    `DragMove` 方法的匿名事件处理器。
- en: As this window will only offer information to the user, we should also set a
    few other window properties. One important property to set is the `ShowInTaskbar`
    property, which specifies whether the application icon should appear in the Windows
    Taskbar or not. As this window will be an integral part of our main application,
    we set this property to `false`, so that its icon will be hidden.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个窗口只为用户提供信息，我们还应该设置一些其他窗口属性。一个重要的属性是设置 `ShowInTaskbar` 属性，它指定应用程序图标是否应该出现在
    Windows 任务栏中。由于这个窗口将是我们主应用程序的一个组成部分，我们将此属性设置为 `false`，以便其图标将被隐藏。
- en: 'Another useful property for this situation is the `WindowStartupLocation` property,
    which enables the window to be positioned using the `Window.Top` and `Window.Left`
    properties. In this way, the callout window can be programmatically positioned
    on screen anywhere that it is needed. Before continuing any further, let''s see
    the code for this window:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，另一个有用的属性是 `WindowStartupLocation` 属性，它允许使用 `Window.Top` 和 `Window.Left`
    属性来定位窗口。这样，调用窗口就可以在屏幕上任何需要的位置进行程序化定位。在继续进行之前，让我们看看这个窗口的代码：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While this example is not overly long, there is a lot to discuss here. In order
    to clarify the situation somewhat, let''s also see the code behind before we examine
    this code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例不是很长，但这里有很多东西要讨论。为了澄清情况，在我们检查这段代码之前，让我们也看看它的代码隐藏部分：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code-behind file is simpler than the XAML file, so let's quickly walk through
    it first. We added a static constructor in order to call the `OverrideMetadata`
    method on a few pre-existing Dependency Properties. This enables us to override
    the default settings of these properties, and we do this in a static constructor
    because we want to run this code just once per class and because it is called
    before any other constructor or method in the class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码隐藏文件比 XAML 文件简单，所以让我们先快速浏览一下。我们添加了一个静态构造函数，以便在几个预存在的依赖属性上调用 `OverrideMetadata`
    方法。这使得我们可以覆盖这些属性的默认设置，我们这样做是在静态构造函数中，因为我们希望这个代码在每个类中只运行一次，并且因为它在类中的任何其他构造函数或方法之前被调用。
- en: In this constructor, we override the metadata for the `BorderBrush` property,
    in order to set a default border color for our callout window. We do the same
    for both the `HorizontalContentAlignment` and `VerticalContentAlignment` properties
    to ensure that the window content will be centered by default. By doing this,
    we are re-using these existing properties.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数中，我们覆盖了 `BorderBrush` 属性的元数据，以便为我们的调用窗口设置默认边框颜色。我们也为 `HorizontalContentAlignment`
    和 `VerticalContentAlignment` 属性做了同样的事情，以确保窗口内容默认居中。通过这样做，我们正在重用这些现有属性。
- en: However, we can also totally replace the pre-existing properties. As an example,
    we've replaced the `Background` property to paint our callout background. In this
    case, we declare our own `Background` property, specified by the `new` keyword,
    and set its own default brush color. We then use that to paint the background
    of our callout shape, although we could just as easily add another setter into
    our style to reuse the original `Background` property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以完全替换现有的属性。例如，我们已将 `Background` 属性替换为绘制我们的调用背景。在这种情况下，我们声明了自己的 `Background`
    属性，由 `new` 关键字指定，并设置了其默认画笔颜色。然后我们使用它来绘制调用形状的背景，尽管我们也可以在我们的样式中添加另一个设置器来重用原始的 `Background`
    属性。
- en: Looking at the XAML code now, we can see the `WindowStartupLocation` property
    set in the `Window` declaration, followed by a style in the window's `Resources`
    section. In this style, we set the aforementioned properties and define the window's
    control template. Inside the `ControlTemplate` object, we define a `Grid` panel.
    We'll return to this later, but for now, note that there is a nine pixel margin
    set on the bottom of the panel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看 XAML 代码，我们可以看到在 `Window` 声明中设置了 `WindowStartupLocation` 属性，随后是窗口 `Resources`
    部分中的样式。在这个样式中，我们设置了上述属性并定义了窗口的控制模板。在 `ControlTemplate` 对象内部，我们定义了一个 `Grid` 面板。我们稍后会回到这里，但到目前为止，请注意面板底部设置了九像素的边距。
- en: Next, note that the panel has two star-sized `ColumnDefinition` elements declared,
    one with a width of `*` and another with a width of `5*`. If we add these together,
    we end with a total width of six equal divisions. This means that the first column
    will be one sixth of the total width of the window and the second column will
    take up the remaining five sixths. We will soon see why this is set as it is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意该面板声明了两个星号大小的 `ColumnDefinition` 元素，一个宽度为 `*`，另一个宽度为 `5*`。如果我们把这些加起来，最终得到的总宽度是六个等分。这意味着第一列将是窗口总宽度的六分之一，而第二列将占据剩余的五分之六。我们很快就会看到为什么是这样设置的。
- en: Inside the `Grid` panel, we first declare the `Path` element that is used to
    define the shape of our callout. We set the `Grid.ColumnSpan` property on it to
    `2`, to ensure that it takes all of the space of the parent window. Next, we set
    our new `Background` property to the `Fill` property, so that users of our window
    can set `Background` property and have that brush paint just the background of
    our path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Grid` 面板内部，我们首先声明了用于定义我们调用形状的 `Path` 元素。我们将 `Grid.ColumnSpan` 属性设置为 `2`，以确保它占据父窗口的所有空间。接下来，我们将新的
    `Background` 属性设置为 `Fill` 属性，这样我们的窗口用户就可以设置 `Background` 属性，并且该画笔只绘制路径的背景。
- en: We also set the `Stroke` property of the `Path` element to the overridden `BorderBrush`
    property and although we didn't, we could have exposed the `StrokeThickness` property
    by declaring another Dependency Property. Note that we use `TemplateBinding` elements
    to access the properties of the window, as they are the most efficient in this
    particular case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了 `Path` 元素的 `Stroke` 属性为重写的 `BorderBrush` 属性，尽管我们没有这样做，但我们本可以通过声明另一个依赖属性来公开
    `StrokeThickness` 属性。请注意，我们使用 `TemplateBinding` 元素来访问窗口的属性，因为在这个特定情况下，它们是最有效的。
- en: Take special note of the `Path.Stretch` property, which we have set to `Fill`
    and defines how the shape should fill the space that it is provided with. Using
    this `Fill` value specifies that the content should fill all of the available
    space, rather than preserve its originally defined aspect ratio. However, if we
    want to preserve the aspect ratio, then we can change this property to the `Uniform`
    value instead.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意 `Path.Stretch` 属性，我们将其设置为 `Fill`，并定义了形状应该如何填充它所提供的空间。使用此 `Fill` 值指定内容应填充所有可用空间，而不是保留其最初定义的宽高比。然而，如果我们想保留宽高比，则可以将此属性更改为
    `Uniform` 值。
- en: The most important part of the path is found in the `Path.Data` section. This
    defines the shape of the rendered path and like our layered background example,
    we utilize a `CombinedGeometry` element here to combine two separate geometries.
    Unlike the previous example, here we use a `GeometryCombineMode` value of `Union`,
    which renders the output of both geometry shapes together.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 路径最重要的部分位于 `Path.Data` 部分。这定义了渲染路径的形状，就像我们的分层背景示例一样，我们在这里使用 `CombinedGeometry`
    元素来组合两个独立的几何形状。与前面的示例不同，这里我们使用 `GeometryCombineMode` 的值为 `Union`，这会将两个几何形状的输出一起渲染。
- en: In the `CombinedGeometry.Geometry1` element, we declare a `PathGeometry` object
    with a `PathFigure` element that has a starting point and two `LineSegment` elements.
    Together with the starting point, these two elements form the triangular section
    of our callout, that points to the area on the screen that our window's information
    relates to. Note that this triangle is fifty pixels wide in the path.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CombinedGeometry.Geometry1`元素中，我们声明了一个具有`PathFigure`元素的`PathGeometry`对象，该元素有一个起始点和两个`LineSegment`元素。与起始点一起，这两个元素形成了我们的注释的三角形部分，指向屏幕上与窗口信息相关联的区域。请注意，这个三角形在路径中宽度为五十像素。
- en: In the `CombinedGeometry.Geometry2` element, we declare a `RectangleGeometry`
    object, with its size specified by the `Rect` property and the size of its rounded
    corners being specified by the `RadiusX` and `RadiusY` properties. The rectangle
    is positioned fifty pixels away from the left edge and its width is two hundred
    and fifty pixels wide.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CombinedGeometry.Geometry2`元素中，我们声明了一个`RectangleGeometry`对象，其大小由`Rect`属性指定，其圆角的大小由`RadiusX`和`RadiusY`属性指定。矩形距离左侧边缘五十像素，宽度为二百五十像素。
- en: The overall area taken up by the rectangle and the triangle is therefore three
    hundred pixels. One sixth of three hundred is fifty and this is how wide the triangle
    in our shape is. This explains why our first `Grid` column is set to take one
    sixth of the total space.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，矩形和三角形的总面积是三百像素。三百的六分之一是五十，这就是我们形状中三角形的宽度。这解释了为什么我们的第一个`Grid`列被设置为占据总空间的六分之一。
- en: After the `Path` object, we declare the `ContentPresenter` element that is required
    to output the actual content of the window and set it to be in the second column
    of the panel. In short, this column is used to position the `ContentPresenter`
    element directly over the rectangular section of our shape, avoiding the triangular
    section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Path`对象之后，我们声明了`ContentPresenter`元素，这是输出窗口实际内容所必需的，并将其设置为面板的第二列。简而言之，这一列用于将`ContentPresenter`元素直接定位在我们的形状的矩形部分上方，避免三角形部分。
- en: In the `ContentPresenter` element, we data bind several positional properties
    to the relevant properties of the window using `TemplateBinding` elements. We
    also data bind its `Content` property to the `Content` property of the window
    using another `TemplateBinding` element.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContentPresenter`元素中，我们使用`TemplateBinding`元素将几个位置属性数据绑定到窗口的相关属性。我们还使用另一个`TemplateBinding`元素将其`Content`属性数据绑定到窗口的`Content`属性。
- en: Note that we could have declared our UI controls directly within the `Window`
    control. However, had we done that, then we would not be able to data bind to
    its `Content` property in this way, as setting it externally would replace all
    of our declared XAML controls, including the `ContentPresenter` object. By providing
    a new template, we are totally overriding the default behavior of the window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本来可以直接在`Window`控件中声明我们的UI控件。然而，如果我们那样做了，我们就无法以这种方式将其`Content`属性数据绑定，因为外部设置会替换掉我们声明的所有XAML控件，包括`ContentPresenter`对象。通过提供一个新的模板，我们完全覆盖了窗口的默认行为。
- en: Also note that we have declared a style in the `Resources` section of the `ContentPresenter`
    element. This style has been declared without the `x:Key` directive. This is so
    that it will be implicitly applied to all `TextBlock` objects within scope, specifically
    to affect the `TextBlock` objects that the `ContentPresenter` element will automatically
    generate for `string` values, while not affecting others.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，我们在`ContentPresenter`元素的`Resources`部分中声明了一个样式。这个样式没有使用`x:Key`指令声明。这样做是为了使其隐式应用于作用域内的所有`TextBlock`对象，特别是为了影响`ContentPresenter`元素将自动为`string`值生成的`TextBlock`对象，而不会影响其他对象。
- en: The style sets the `TextBlock.TextWrapping` property to the `Wrap` member of
    the `TextWrapping` enumeration, which has the effect of wrapping long text lines
    onto the following lines. The default setting is `NoWrap`, which would result
    in long strings not being fully displayed in our window.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 样式将`TextBlock.TextWrapping`属性设置为`TextWrapping`枚举的`Wrap`成员，这会将长文本行换行到下一行。默认设置是`NoWrap`，这会导致长字符串在我们的窗口中无法完全显示。
- en: Finally, we come to the end of the XAML example and find a `DropShadowEffect`
    object set as the `Effect` property of the `Grid` panel. As with all shadow effects,
    we set the `Color` property to black and the `Opacity` property to a value less
    or equal to `0.5`. The `Direction` property is set to `270`, which produces a
    shadow that lies directly underneath our callout shape.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了XAML示例的结尾，发现一个`DropShadowEffect`对象被设置为`Grid`面板的`Effect`属性。与所有阴影效果一样，我们将`Color`属性设置为黑色，将`Opacity`属性设置为小于或等于`0.5`的值。`Direction`属性设置为`270`，产生一个直接位于我们的callout形状下方的阴影。
- en: Note that we set the `ShadowDepth` property to a value of `7`. *Now, do you
    remember the bottom margin that was set on the grid?* That was set to a value
    just above this value and was to ensure that enough space was left in the window
    to display our shadow underneath our callout shape. Without this, the shadow would
    sit outside the bounding box of the window and not be displayed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`ShadowDepth`属性设置为`7`。*现在，你还记得在网格上设置的底部边距吗？* 那是设置在这个值之上，以确保在窗口中留出足够的空间来显示我们的阴影在callout形状下方。如果没有这个设置，阴影将位于窗口的边界框之外，并且不会被显示。
- en: 'If we had set a different value for the `Direction` property, then we would
    need to adjust the `Grid` panel''s margin to ensure that it left enough space
    around the window to display the shadow in its new location. Let''s now take a
    look at how we could use our new window:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`Direction`属性设置了不同的值，那么我们需要调整`Grid`面板的边距，以确保在窗口周围留出足够的空间来显示阴影在其新位置。现在让我们看看我们如何使用我们的新窗口：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this code from a suitable location would result in the following rendered
    output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从合适的位置运行此代码会产生以下渲染输出：
- en: '![](img/c2690552-94de-4c3d-a524-ca01581833ae.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2690552-94de-4c3d-a524-ca01581833ae.png)'
- en: In our window-showing code, we set a `string` to the `Content` property of the
    window. However, this property is of type `object`, so we can add any object as
    its value. In the same way that we set our View Model instances to the `Content`
    property of a `ContentControl` earlier in this book, we can also do that with
    our window.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的窗口显示代码中，我们将一个`string`设置到窗口的`Content`属性。然而，这个属性的类型是`object`，因此我们可以将其值设置为任何对象。就像我们在本书前面将我们的视图模型实例设置到`ContentControl`的`Content`属性一样，我们也可以用我们的窗口来做同样的事情。
- en: 'Given a suitable `DataTemplate` that defines some UI for a particular custom
    object type, we could set an instance of that object to our window''s `Content`
    property and have the controls from that template rendered within our callout
    window, so we are not restricted to only using type `string` for content here.
    Let''s use a previous example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个合适的`DataTemplate`，它定义了特定自定义对象类型的UI，我们可以将该对象的实例设置到窗口的`Content`属性，并使该模板中的控件在callout窗口中渲染，这样我们就不限于只使用类型`string`作为内容。让我们使用一个先前的例子：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With a few slight adjustments to our `calloutWindow` dimension properties,
    we would see this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`calloutWindow`的维度属性进行一些轻微的调整，我们会看到以下内容：
- en: '![](img/11b6417d-e6c4-4127-b2d5-b2a60fb2fd38.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11b6417d-e6c4-4127-b2d5-b2a60fb2fd38.png)'
- en: Visualizing data
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据可视化
- en: While there are a number of pre-existing graph controls and third party data
    visualization controls available in WPF, we can create our own relatively easily.
    Expressing data in textual terms alone, while generally acceptable, is not optimal.
    Breaking the norm in an application always makes that application stand out from
    the rest that strictly adheres to the standard.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在WPF中存在许多现成的图形控件和第三方数据可视化控件，但我们可以相对容易地创建自己的。仅用文本术语表达数据，虽然通常是可以接受的，但并不是最佳选择。在应用程序中打破常规，总是能让该应用程序在严格遵守标准的其他应用程序中脱颖而出。
- en: As an example, imagine a simple situation, where we have a dashboard that visualizes
    the number of work tasks that have come in and the number that have been completed.
    We could just output the numbers in a big, bold font, but that would be the normal
    kind of output. *What about if we visualized each number as a shape, with its
    size being specified by the number?*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个简单的情况，我们有一个仪表盘，它可视化了进入的工作任务数量和已完成的工作任务数量。我们只需用大号粗体字输出这些数字，但这将是正常的输出方式。*如果我们把每个数字可视化成一个形状，其大小由数字指定会怎样呢？*
- en: 'Let''s reuse our layering techniques from earlier and design some visually
    appealing spheres, that grow in size depending upon a particular value. To do
    this, we can create another custom control, with a `Value` Dependency Property
    to data bind to. Let''s first look at the code of the `Sphere` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用我们之前的技术，设计一些视觉上吸引人的球体，它们的大小根据特定值增长。为此，我们可以创建另一个自定义控件，具有一个`Value`依赖属性进行数据绑定。让我们首先看看`Sphere`类的代码：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As this class will declare its own `Color` property, we start by adding a `MediaColor` using
    alias directive, which we'll just use as a shortcut to accessing the methods of
    the `System.Windows.Media.Color` class, when declaring the brushes that will be
    used in the `Sphere` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类将声明自己的`Color`属性，我们首先添加一个`MediaColor`使用别名指令，我们将仅将其用作访问`System.Windows.Media.Color`类的方法的快捷方式，当在`Sphere`类中声明将要使用的画笔时。
- en: From the class declaration, we can see that there are two named parts specified
    in `TemplatePartAttribute` attributes. These specify that the two mentioned `Ellipse`
    elements are required in our control's template in the `Generic.xaml` file. Inside
    the class, we define a number of `RadialGradientBrush` resources to paint our
    spheres with.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从类声明中，我们可以看到在`TemplatePartAttribute`属性中指定了两个命名的部分。这指定了在我们的控制模板的`Generic.xaml`文件中需要两个提到的`Ellipse`元素。在类内部，我们定义了多个`RadialGradientBrush`资源来绘制我们的球体。
- en: In the static constructor, we call the `OverrideMetadata` method to let the
    Framework know where our control's default style is. We then see the declaration
    of the `Value` and `Color` Dependency Properties, with the `Color` property's
    related `PropertyChangedCallback` hander method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态构造函数中，我们调用`OverrideMetadata`方法让框架知道我们的控制默认样式在哪里。然后我们看到`Value`和`Color`依赖属性的声明，以及与`Color`属性相关的`PropertyChangedCallback`处理方法。
- en: In this `OnColorChanged` method, we cast the `dependencyObject` input parameter
    to an instance of our `Sphere` class and call its `SetEllipseColors` method. In
    that method, we use the `FrameworkElement.GetTemplateChild` method to access the
    two main `Ellipse` objects from our `ControlTemplate` element.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`OnColorChanged`方法中，我们将`dependencyObject`输入参数转换为我们的`Sphere`类的一个实例，并调用它的`SetEllipseColors`方法。在那个方法中，我们使用`FrameworkElement.GetTemplateChild`方法从我们的`ControlTemplate`元素访问两个主要的`Ellipse`对象。
- en: Remember that we must always check these objects for `null`, as our `ControlTemplate`
    could have been replaced with one that does not contain these ellipse elements.
    If they are not `null`, we set their `Fill` properties to one of our brush resources
    using the ternary operator and depending upon the value of our `Color` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们必须始终检查这些对象是否为`null`，因为我们的`ControlTemplate`可能被替换为一个不包含这些椭圆元素的模板。如果它们不是`null`，我们使用三元运算符并根据我们的`Color`属性值将它们的`Fill`属性设置为我们的画笔资源之一。
- en: 'One alternative for creating this functionality would be to declare a Dependency
    Property of type `Brush` to data bind to each ellipse''s `Fill` property and to
    set the relevant brush resources to these properties, instead of accessing the
    XAML elements directly. Before viewing the control''s default style, let''s see
    the `SphereColor` enumeration that is used by the `Color` property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此功能的一个替代方案是声明一个类型为`Brush`的依赖属性，将其数据绑定到每个椭圆的`Fill`属性，并将相关的画笔资源设置为这些属性，而不是直接访问XAML元素。在查看控制默认样式之前，让我们看看由`Color`属性使用的`SphereColor`枚举：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, this is a simple affair and could be easily extended. Note
    that this enumeration has been declared within the `CustomControls` namespace
    and project, so that the project is self-contained and can be reused in other
    applications without any external dependencies. Let''s take a look at our control''s
    default style from `Generic.xaml` now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一件简单的事情，可以很容易地扩展。请注意，这个枚举是在`CustomControls`命名空间和项目中声明的，这样项目就是自包含的，可以在其他应用程序中重用，而无需任何外部依赖。现在让我们看看我们的控制默认样式从`Generic.xaml`：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When looking at our control's default template, we can see some of resources
    defined in the `ControlTemplate.Resources` section. We first declare a `DropShadowEffect`
    element, similar to our previous uses of this class. Next, we define a vertical
    `LinearGradientBrush` element, to use as a light reflection layer, in a similar
    way to our earlier example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们控制的默认模板时，我们可以看到在`ControlTemplate.Resources`部分定义的一些资源。我们首先声明了一个`DropShadowEffect`元素，类似于我们之前对这个类的使用。接下来，我们定义了一个垂直的`LinearGradientBrush`元素，用作光反射层，与之前的示例类似。
- en: Previously, we saw that the default value of the `GradientStop.Offset` property
    is zero and so, we can omit the setting of this property if that is the value
    that we need to use. In this brush resource, we see that the last `GradientStop`
    element has no `Color` value specified. This is because its default value of this
    property is `Transparent` and that is the value that we need to use here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到 `GradientStop.Offset` 属性的默认值是零，因此，如果我们需要使用这个值，我们可以省略此属性的设置。在这个画笔资源中，我们看到最后一个
    `GradientStop` 元素没有指定 `Color` 值。这是因为该属性的默认值是 `Transparent`，这正是我们需要在这里使用的值。
- en: In the actual markup for our control, we declare three `Ellipse` objects within
    a `Grid` panel. Two of these elements are named and referenced in the control's
    code, while the third ellipse uses the brush from resources to create the "shine"
    on top of the other ellipses. The panel's size properties are data bound to the
    `Value` Dependency Property, using a `TemplatedParent` source.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们控件的实际标记中，我们在 `Grid` 面板内声明了三个 `Ellipse` 对象。其中两个元素在控件的代码中被命名并引用，而第三个椭圆使用资源中的画笔来创建其他椭圆上的“光泽”。面板的大小属性绑定到
    `Value` 依赖属性，使用 `TemplatedParent` 源。
- en: Note that we have used the star-sizing capabilities of the `Grid` panel to both
    position and size our ellipse elements, with the exception of the two pixels in
    the top margin specified on the reflection ellipse. In this way, our control can
    be any size and the positioning of the various layers will remain visually correct.
    Note that we could not achieve this by hard coding exact margin values for each
    element.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `Grid` 面板的星型尺寸功能来定位和调整我们的椭圆元素的大小，除了在反射椭圆上指定的顶部边距的两像素。这样，我们的控件可以是任何大小，而各种层的定位将保持视觉上的正确性。注意，我们无法通过为每个元素硬编码确切的边距值来实现这一点。
- en: 'Let''s see how we could use this in a simple View:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在简单的视图中使用它：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how our example looks when rendered:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例渲染后的样子：
- en: '![](img/4e45b0d9-ac6f-4e99-a95f-dd64c527c422.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e45b0d9-ac6f-4e99-a95f-dd64c527c422.png)'
- en: 'As you can see, WPF is very powerful and enables us to create completely original
    looking controls. However, we can also use it to recreate more commonly seen controls.
    As an example, let''s see how we can create an alternative control to gauge how
    close we may be to our particular target value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，WPF 非常强大，使我们能够创建外观完全独特的控件。然而，我们也可以用它来重新创建更常见的控件。作为一个例子，让我们看看我们如何创建一个替代控件来衡量我们可能接近特定目标值的程度：
- en: '![](img/5665f562-3a70-484b-b46f-7006d54a7373.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5665f562-3a70-484b-b46f-7006d54a7373.png)'
- en: 'This example features a semi-circular arc, which is something that does not
    exist in a form that is usable from XAML, so we''ll first create an `Arc` control
    to use internally within our `Gauge` control. Let''s see how we can achieve this
    by adding a new custom control:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个半圆形弧线，这在 XAML 中不存在可用的形式，所以我们将首先创建一个 `Arc` 控件，用于在我们的 `Gauge` 控件内部使用。让我们看看我们如何通过添加一个新的自定义控件来实现这一点：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we extend the `Shape` class when creating our `Arc` class. We do this
    because it provides us with a wide variety of stroke and fill properties and also
    the apparatus to render our custom shape from a `Geometry` object. Additionally,
    users of our `Arc` control will also be able to take advantage of the `Shape`
    class' transformation abilities through its `Stretch` and `GeometryTransform`
    properties.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在创建 `Arc` 类时扩展了 `Shape` 类。我们这样做是因为它为我们提供了广泛的笔触和填充属性，以及从 `Geometry` 对象渲染自定义形状的设备。此外，我们的
    `Arc` 控件的用户也将能够通过其 `Stretch` 和 `GeometryTransform` 属性利用 `Shape` 类的变换能力。
- en: To draw our arc, we will use the `ArcTo` method of the `StreamGeometryContext`
    class and with it, we need to specify exact `Point` values for its start and end.
    However, in order to reflect the correct value in the size of our arc, it is easier
    to define it using angle values for its start and end.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制我们的弧线，我们将使用 `StreamGeometryContext` 类的 `ArcTo` 方法，并且我们需要为其起始点和终点指定确切的 `Point`
    值。然而，为了在弧线的大小中正确反映值，使用起始点和终点的角度值来定义它更容易。
- en: Therefore, we add `StartAngle` and `EndAngle` Dependency Properties to our `Arc`
    class. Note that these two properties are declared with the `FrameworkPropertyMetadataOptions.AffectsRender`
    member. This notifies the Framework that changes to these properties need to cause
    a new rendering pass, so new values will be accurately represented in the control.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`Arc`类中添加了`StartAngle`和`EndAngle`依赖属性。请注意，这两个属性是用`FrameworkPropertyMetadataOptions.AffectsRender`成员声明的。这通知框架，这些属性的变化需要引起新的渲染过程，因此新值将准确地在控件中表示出来。
- en: After these property declarations, we see the overridden `DefiningGeometry`
    property, that enables us to return a `Geometry` object that defines the shape
    to be rendered. We simply return the result from the `GetArcGeometry` method from
    this property.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些属性声明之后，我们看到重写的`DefiningGeometry`属性，它使我们能够返回一个`Geometry`对象，该对象定义了要渲染的形状。我们只需从这个属性返回`GetArcGeometry`方法的结果即可。
- en: In the `GetArcGeometry` method, we obtain the required start and end `Point`
    elements from the `ConvertToPoint` method, passing in the `StartAngle` and `EndAngle`
    property values. Note that we use the `Min` and `Max` methods of the `Math` class
    here to ensure that the start point is calculated from the smaller angle and the
    end point is calculated from the larger angle.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetArcGeometry`方法中，我们从`ConvertToPoint`方法获取所需的起始和结束`Point`元素，传递`StartAngle`和`EndAngle`属性值。请注意，我们在这里使用`Math`类的`Min`和`Max`方法来确保起点是从较小的角度计算得出的，而终点是从较大的角度计算得出的。
- en: 'Our arc shape''s fill will actually come from the geometric arc''s stroke,
    so we will not be able to add a stroke to it. In WPF, the stroke of a shape with
    a thickness of one pixel will extend no further than the shape''s bounding box.
    However, at the furthest point, strokes with larger thickness values are rendered
    so that their center remains on the line of the bounding box also therefore, half
    of it will extend outside the bounds of the element and half will be rendered
    within the bounds:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们弧形的填充实际上来自几何弧的描边，因此我们无法为其添加描边。在WPF中，厚度为一像素的形状的描边将不会超出形状的边界框。然而，在最远点，厚度更大的描边会被渲染，使得它们的中心保持在边界框的线上，因此，一半的描边会延伸到元素的外部，另一半会在边界框内渲染：
- en: '![](img/085f2c30-a9b1-4bc5-9816-685a724888ae.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/085f2c30-a9b1-4bc5-9816-685a724888ae.png)'
- en: Therefore, we calculate the size of the arc by dividing the `RenderSize` value
    minus the `StrokeThickness` value by two. This will reduce the size of the arc
    so that it remains totally within the bounds of our control. We make use of the
    `Math.Max` method to ensure that the values that we pass to the `Size` class are
    never less than zero and avoid exceptions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过将`RenderSize`值减去`StrokeThickness`值除以二来计算弧的大小。这将减小弧的大小，使其完全位于我们的控件边界内。我们使用`Math.Max`方法确保传递给`Size`类的值永远不会小于零，以避免异常。
- en: When using the `ArcTo` method, we need to specify a value that determines whether
    we want to connect our start and end points with a short arc or a long one. Our
    `isLargeArc` variable therefore determines whether the two specified angles would
    produce an arc of more than one hundred and eighty degrees or not.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`ArcTo`方法时，我们需要指定一个值来决定我们是否希望用短弧或长弧连接我们的起点和终点。因此，我们的`isLargeArc`变量决定了这两个指定的角度是否会产生超过一百八十度的弧。
- en: Next, we create a `StreamGeometry` object and retrieve a `StreamGeometryContext`
    object from its `Open` method, with which to define our geometric shape. Note
    that we could equally use a `PathGeometry` object here, but as we do not need
    its data binding, animation, or other abilities, we use the more efficient `StreamGeometry`
    object instead.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`StreamGeometry`对象，并从其`Open`方法中检索一个`StreamGeometryContext`对象，用其来定义我们的几何形状。请注意，我们在这里同样可以使用`PathGeometry`对象，但由于我们不需要其数据绑定、动画或其他功能，我们使用更高效的`StreamGeometry`对象。
- en: We enter the arc's start point in the `BeginFigure` method and the remaining
    parameters in the `ArcTo` method. Note that we call these methods on our `StreamGeometryContext`
    object from within a `using` statement to ensure that it is closed and disposed
    of properly, once we are finished with it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`BeginFigure`方法中输入弧的起点，并在`ArcTo`方法中输入剩余的参数。请注意，我们在这两个方法上调用我们的`StreamGeometryContext`对象，并在`using`语句内完成，以确保一旦我们完成使用，它就会被正确关闭和释放。
- en: Next, we apply a `TranslateTransform` element to the `Transform` property of
    the `StreamGeometry` object in order to shift the arc so that it is fully contained
    within our control. Without this step, our arc would stick out of the bounding
    box of our control to the upper left, by the amount of half of the `StrokeThickness`
    property value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将一个`TranslateTransform`元素应用到`StreamGeometry`对象的`Transform`属性上，以便将弧线完全包含在我们的控制范围内。如果不进行这一步，我们的弧线将超出控制范围的左上角边界框，超出量等于`StrokeThickness`属性值的一半。
- en: Once we have finished manipulating our `StreamGeometry` object, we call its
    `Freeze` method, which makes it unmodifiable and rewards us with additional performance
    benefits. We'll find out more about this in [Chapter 11](ef8426a1-cec3-4ae0-801a-798557f3fbd4.xhtml),
    *Improving Application Performance, *but for now, let's continue looking through
    this example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了对`StreamGeometry`对象的操作，我们就调用它的`Freeze`方法，这使得它不可修改，并为我们带来额外的性能优势。我们将在第11章中了解更多关于这一点，*提高应用程序性能*，但现在，让我们继续查看这个示例。
- en: Finally, we get to the `ConvertToPoint` method, which converts the values of
    our two angle Dependency Properties into two-dimensional `Point` objects. Our
    first job is to convert each angle from degrees into radians, as the methods of
    the `Math` class that we need to use require radian values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了`ConvertToPoint`方法，该方法将我们的两个角度依赖属性值转换为二维`Point`对象。我们的第一个任务是先将每个角度从度转换为弧度，因为我们需要使用`Math`类的方法，而这些方法需要弧度值。
- en: Next, we calculate the two radii of our arc using half of the `RenderSize` value
    minus the `StrokeThickness` property value, so that the size of the arc does not
    exceed the bounding box of our `Arc` control. Finally, we perform some basic trigonometry
    using the `Math.Cos` and `Math.Sin` methods when calculating the `Point` element
    to return.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`RenderSize`值的一半减去`StrokeThickness`属性值来计算我们的弧线的两个半径，这样弧线的大小就不会超过我们的`Arc`控制边界框。最后，在计算返回`Point`元素时，我们使用`Math.Cos`和`Math.Sin`方法进行一些基本的三角运算。
- en: 'That completes our simple `Arc` control and so now, we can utilize this new
    class in our `Gauge` control. We''ll need to create another new custom control
    for it, so let''s first see the properties and code in our new `Gauge` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的简单`Arc`控制，因此现在我们可以利用这个新类在我们的`Gauge`控制中。我们需要为它创建另一个新的自定义控制，所以让我们首先看看我们新的`Gauge`类中的属性和代码：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As usual, we start by overriding the metadata of the `DefaultStyleKeyProperty`
    for our control type in the static constructor, to help the Framework find where
    its default style is defined. We then declare the internal, read-only `ValueAngle`
    and `RotationAngle` Dependency Properties and the regular public `Value`, `MaximumValue`,
    and `Title` Dependency Properties.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，我们在静态构造函数中重写我们控制类型的`DefaultStyleKeyProperty`的元数据，以帮助框架找到其默认样式定义的位置。然后我们声明了内部的、只读的`ValueAngle`和`RotationAngle`依赖属性以及常规的公共`Value`、`MaximumValue`和`Title`依赖属性。
- en: We declare a `PropertyChangedCallback` hander for the `Value` property, and,
    in that method, we first cast the `dependencyObject` input parameter to an instance
    of our `Gauge` class. If the value of the `MaximumValue` property is zero, then
    we simply set both of the `ValueAngle` and `RotationAngle` properties to `180.0`,
    which results in the arc and needle being displayed in their start positions,
    on the left.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`Value`属性声明了一个`PropertyChangedCallback`处理程序，并在该方法中，我们首先将`dependencyObject`输入参数转换为我们的`Gauge`类的一个实例。如果`MaximumValue`属性的值为零，那么我们只需将`ValueAngle`和`RotationAngle`属性都设置为`180.0`，这样弧线和指针就会显示在其起始位置，即左侧。
- en: If the new value of the data bound `Value` property is more than the value of
    the `MaximumValue` property, then we make the arc and needle display in their
    end, or full, positions to the right. We do this by setting the `ValueAngle` property
    to `0.0` and the `RotationAngle` property to `360.0`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据绑定`Value`属性的新值大于`MaximumValue`属性的值，那么我们将弧线和指针显示在其末端或完全位置，即右侧。我们通过将`ValueAngle`属性设置为`0.0`和将`RotationAngle`属性设置为`360.0`来实现这一点。
- en: If the new value of the `Value` property is valid, then we calculate the `scaledPercentageValue`
    variable. We do this by first dividing the new value by the value of the `MaximumValue`
    property, to get the percentage of the maximum value. We then multiply that figure
    by `180.0`, because our gauge covers a range of one hundred and eighty degrees.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Value`属性的新值有效，那么我们计算`scaledPercentageValue`变量。我们首先将新值除以`MaximumValue`属性的值，以得到最大值的百分比。然后我们乘以`180.0`，因为我们的仪表覆盖了180度的范围。
- en: We then subtract the `scaledPercentageValue` variable value from `180.0` for
    the `ValueAngle` property and add it to `180.0` for the `RotationAngle` property.
    This is because the `ValueAngle` property is used by our arc and needs to be between
    `180.0` and `0.0`, and the `RotationAngle` property is used by our gauge needle
    and needs to be between `180.0` and `360.0`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从`ValueAngle`属性的`scaledPercentageValue`变量值中减去`180.0`，并将其加到`RotationAngle`属性的`180.0`上。这是因为`ValueAngle`属性被我们的弧形使用，需要介于`180.0`和`0.0`之间，而`RotationAngle`属性被我们的仪表指针使用，需要介于`180.0`和`360.0`之间。
- en: 'This will soon be made clearer, so let''s now see how we use these properties
    and the `Arc` control in our `Gauge` control''s default style from the `Generic.xaml`
    file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快就会变得清晰，现在让我们看看我们是如何在`Generic.xaml`文件中从`Gauge`控件的默认样式中使用这些属性和`Arc`控件的：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We start our default style as usual, by specifying the type of our control in
    both the style and the control template. Inside the template, we have two `Grid`
    panels and data bind the `Background` property of the outer panel and the `Margin`
    property of the inner panel to properties of our templated control, so that users
    can set them externally.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始我们的默认样式，通过在样式和控制模板中指定我们的控件类型。在模板内部，我们有两个`Grid`面板，并将外部面板的`Background`属性和内部面板的`Margin`属性数据绑定到模板控件的属性，以便用户可以外部设置它们。
- en: We then define three rows in our inner panel. The control's `Title` property
    is data bound to a horizontally centered `TextBlock` element in the first row.
    In the second row, we declare a horizontally centered `Canvas` panel that contains
    two of our new `Arc` controls and a `Path` object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在我们的内部面板中定义了三行。控件的`Title`属性与第一行中水平居中的`TextBlock`元素的数据绑定。在第二行中，我们声明了一个水平居中的`Canvas`面板，其中包含我们两个新的`Arc`控件和一个`Path`对象。
- en: The first `Arc` control is gray and represents the background track that the
    `Arc` that represents our `Gauge` control's `Value` property sits on. The second
    `Arc` control is colored `OrangeRed` and displays the current value of our `Gauge`
    control's `Value` property, by data binding its `EndAngle` property to the `AngleValue` Dependency
    Property of the `Gauge` control.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Arc`控件是灰色，代表`Gauge`控件`Value`属性所坐的背景轨道。第二个`Arc`控件是橙红色，显示我们的`Gauge`控件`Value`属性当前值，通过将其`EndAngle`属性数据绑定到`Gauge`控件的`AngleValue`依赖属性。
- en: Note that the angles in our `Arc` control follow the common Cartesian coordinate
    system, with an angle of zero degrees falling to the right and increasing values
    moving anti-clockwise. Therefore, to draw a semi-circular arc from left to right,
    we start with an angle of `180` degrees and end at `0` degrees, as demonstrated
    by the background arc in our `Gauge` control.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们`Arc`控件中的角度遵循常见的笛卡尔坐标系，其中零度角指向右侧，值增加时逆时针移动。因此，为了从左到右绘制半圆形弧，我们以`180`度的角度开始，以`0`度结束，正如我们在`Gauge`控件中的背景弧所展示的那样。
- en: Furthermore, our `Arc` controls have the same width and height values, but as
    we don't need their lower halves, we crop them using the height of the canvas
    panel. The `Path` object represents the gauge needle in our control and is painted
    white.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`Arc`控件具有相同的宽度和高度值，但由于我们不需要它们的下半部分，我们使用画布面板的高度来裁剪它们。`Path`对象代表我们的控件中的仪表指针，并涂成白色。
- en: We set the `StrokeLineJoin` property to the `Round` value in order to curve
    the three corners, where the lines of the needle path meet. Note that the needle
    is positioned exactly half way across the width of the canvas and ten pixels above
    the bottom, to enable its center line to lie along the bottom of the canvas.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`StrokeLineJoin`属性设置为`Round`值，以便将针路径线条相遇处的三个角弯曲。注意，指针正好位于画布宽度的中点，并且比底部高十像素，以便其中心线沿着画布底部。
- en: Rather than declaring `PathFigure` and `LineSegment` objects to define the needle,
    we have used the shorthand notation inline in the `Data` property. The `M` specifies
    that we should move to (or start from) point `0,0`, the `L` specifies that we
    want to draw a line to point `125,10` and then from there to point `0,20`, and
    the `Z` means that we want to close the path by joining the first and last points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过声明`PathFigure`和`LineSegment`对象来定义指针，而是在`Data`属性中使用了内联的简写符号。`M`指定我们应该移动到（或从）点`0,0`，`L`指定我们想要画一条线到点`125,10`然后从那里到点`0,20`，而`Z`意味着我们想要通过连接第一个和最后一个点来闭合路径。
- en: We then set the width and height of the path to the same values that were declared
    within `Data` property. Now, the essential part of enabling this needle to point
    to the relevant position to reflect the data bound `Value` property, is the `RotateTransform`
    object that is applied to the path's `RenderTransform` property. Note that its
    center point is set to be the center of the bottom of the needle, as that is the
    point that we want to rotate from.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将路径的宽度和高度设置为在`Data`属性中声明的相同值。现在，使这个指针指向相关位置以反映绑定到`Value`属性的数据的必要部分是应用于路径的`RenderTransform`属性的`RotateTransform`对象。请注意，其中心点被设置为针的底部中心，因为这是我们想要旋转的点。
- en: As the `RotateTransform` object rotates clockwise with increasing `Angle` values,
    we cannot reuse the `AngleValue` Dependency Property with it. Therefore, in this
    particular example, we define the needle pointing to the right and use a range
    of `180.0` to `360.0` degrees in the `RotationAngle` read-only Dependency Property
    with the transform object to match the position of the value arc.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`RotateTransform`对象以增加的`Angle`值顺时针旋转，我们不能与它重用`AngleValue`依赖属性。因此，在这个特定的例子中，我们定义了指向右边的指针，并在`RotationAngle`只读依赖属性中使用`180.0`到`360.0`度的范围，与变换对象匹配值弧的位置。
- en: At the end of the example, we see another horizontally centered `TextBlock`,
    element that outputs the current, unaltered value of the data bound `Value` Dependency
    Property. Note that we use the `StringFormat` value of `N0` to remove the decimal
    places from the value before displaying it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的末尾，我们看到另一个水平居中的`TextBlock`元素，它输出绑定到`Value`依赖属性的当前未修改的值。请注意，我们使用`StringFormat`的`N0`值在显示之前从值中删除小数位。
- en: 'That completes our new `Gauge` control and so, all we need to do now is see
    how we can use it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的新`Gauge`控件，因此我们现在需要做的是看看我们如何使用它：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We could extend our new `Gauge` control to make it more usable in several ways.
    We could add a `MinimumValue` Dependency Property to enable its use with value
    ranges that do not start at zero, or we could expose further properties to enable
    users to color, size, or further customize the control. Alternatively, we could
    rewrite it to enable it to be any size, instead of hard coding sizes as we did
    previously.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式扩展我们的新`Gauge`控件，使其更易于使用。我们可以添加一个`MinimumValue`依赖属性，使其能够与不以零开始的值范围一起使用，或者我们可以公开更多的属性，使用户能够着色、调整大小或进一步自定义控件。或者，我们可以重写它，使其能够是任何大小，而不是像我们之前那样硬编码大小。
- en: Livening up the UI controls
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使UI控件生动起来
- en: In addition to making our UI controls look visually appealing, we can also "*liven
    them up*" by adding user interactivity in the form of mouse over effects. While
    most mouse over effects are created using `Trigger` and `Setter` objects, that
    immediately update the relevant style properties when the related trigger condition
    is met, we can alternatively use animations to produce these effects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使我们的UI控件看起来视觉上吸引人之外，我们还可以通过添加鼠标悬停效果的用户交互来“使它们生动起来”。虽然大多数鼠标悬停效果是通过使用`Trigger`和`Setter`对象创建的，这些对象在满足相关触发条件时立即更新相关样式属性，但我们可以使用动画来产生这些效果。
- en: 'Having even subtle transitions between states, rather than instantly switching,
    can also provide a richer user experience. Let''s reuse our initial double bordered
    example from earlier and add some mouse interactivity animations to it to demonstrate
    this point. We''ll need to add a few more resources into a suitable resource collection
    and adjust a couple of our previously declared resources too:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态之间有细微的过渡，而不是立即切换，也可以提供更丰富的用户体验。让我们重用我们之前提到的初始双边框示例，并添加一些鼠标交互动画来演示这一点。我们需要将一些额外的资源添加到合适的资源集合中，并调整我们之前声明的几个资源：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have declared our semi-transparent `Color` resources, we can adjust
    our earlier brush resources to utilize them:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了半透明的`Color`资源，我们可以调整我们之前的画笔资源以利用它们：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s view our full example now:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在查看我们的完整示例：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While this example might seem quite long, it is actually fairly simple. We start
    with our original control template, albeit with the previously hardcoded brush
    values being replaced by our newly defined resources. The main difference with
    the original example is found in the `ControlTemplate.Triggers` collection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子可能看起来相当长，但实际上相当简单。我们以原始控件模板开始，尽管之前硬编码的画笔值被我们新定义的资源所取代。与原始示例的主要区别在于`ControlTemplate.Triggers`集合。
- en: The first trigger will start its various storyboards when the `IsMouseOver`
    property of the `Button` element is true, or in other words, when the user moves
    the mouse cursor over the button. Our storyboards are split between the `Trigger.EnterActions`
    and `Trigger.ExitActions` collections.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个触发器将在`Button`元素的`IsMouseOver`属性为真时启动其各种故事板，换句话说，当用户将鼠标光标移至按钮上时。我们的故事板在`Trigger.EnterActions`和`Trigger.ExitActions`集合之间分配。
- en: Remember that the storyboards in the `Trigger.EnterActions` collection will
    be started as the mouse enters the bounds of the button, while the storyboards
    in the `Trigger.ExitActions` collection will be started as the mouse leaves the
    bounds of the button. We declare three `BeginStoryboard` objects with their associated
    `Storyboard` objects within each of these `TriggerActionCollection` objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Trigger.EnterActions`集合中的故事板将在鼠标进入按钮边界时启动，而`Trigger.ExitActions`集合中的故事板将在鼠标离开按钮边界时启动。我们在每个`TriggerActionCollection`对象内部声明了三个与相关`Storyboard`对象关联的`BeginStoryboard`对象。
- en: The first animation targets the `BorderBrush` property of the `OuterBorder`
    element. Note that this property is of type `Brush`, but there is no `BrushAnimation`
    class in WPF. Therefore, we need to target the `Color` property of the `SolidColorBrush`
    that is actually applied to this property and use a `ColorAnimation` object instead.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动画目标是`OuterBorder`元素的`BorderBrush`属性。请注意，此属性的类型为`Brush`，但在WPF中没有`BrushAnimation`类。因此，我们需要针对实际应用于此属性的`SolidColorBrush`的`Color`属性，并使用`ColorAnimation`对象。
- en: In order to do this, we need to use indirect targeting to first reference the
    `BorderBrush` property and then to chain to the `Color` property using the syntax `BorderBrush.(SolidColorBrush.Color)`.
    Note that this will only work if we are in fact using a `SolidColorBrush` element,
    as we are in this example.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要使用间接目标首先引用`BorderBrush`属性，然后使用语法`BorderBrush.(SolidColorBrush.Color)`来链接到`Color`属性。请注意，这只有在实际上使用`SolidColorBrush`元素时才会起作用，正如在这个例子中一样。
- en: 'However, if we were using one of the gradient brushes instead of a `SolidColorBrush`
    element, we could target the various colors of its `GradientStop` elements with
    a slightly different syntax. For example, we could target the color of the first
    `GradientStop` element in a gradient brush like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用的是渐变画笔而不是`SolidColorBrush`元素，我们可以使用稍有不同的语法来针对其`GradientStop`元素的各个颜色。例如，我们可以这样针对渐变画笔中的第一个`GradientStop`元素的颜色：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Returning to this example now, the second animation targets the `BorderBrush`
    property of the `InnerBorder` element and follows the syntactical example of the
    first animation. While the third animation also uses indirect targeting to reference
    the `Background` property of the `InnerBorder` element, it is somewhat different
    to the other two animations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这个例子，第二个动画目标是`InnerBorder`元素的`BorderBrush`属性，并遵循第一个动画的语法示例。虽然第三个动画也使用间接目标来引用`InnerBorder`元素的`Background`属性，但它与其他两个动画略有不同。
- en: For this animation, we name the `BeginStoryboard` object `BackgroundFadeIn`
    and set its `HandoffBehavior` property to `Compose`, to enable smoother transitions
    between this and the other animations of this property. The specified name will
    be used later in the example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动画，我们给`BeginStoryboard`对象命名为`BackgroundFadeIn`，并将其`HandoffBehavior`属性设置为`Compose`，以实现与其他动画之间的更平滑过渡。在示例中稍后将会使用指定的名称。
- en: Note that these three `ColorAnimation` objects only have their `To` and `Duration`
    properties set and that the three duration values are slightly different. This
    has the effect of slightly thickening the effect, although synchronizing the times
    also works well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这三个`ColorAnimation`对象只设置了它们的`To`和`Duration`属性，并且三个持续时间值略有不同。这会产生略微加厚效果，尽管同步时间也工作得很好。
- en: We have omitted the `From` values on these animations to avoid situations where
    the current animated colors do not match the `From` values and have to immediately
    jump to the starting values before animating to the `To` values. By omitting these
    values, the animations will start at their current color values and will result
    in smoother transitions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了这些动画的`From`值，以避免当前动画颜色与`From`值不匹配的情况，不得不在动画到`To`值之前立即跳转到起始值。通过省略这些值，动画将从当前颜色值开始，并导致更平滑的过渡。
- en: The three animations in the `Trigger.ExitActions` collection are very similar
    to those in the `EnterActions` collection, albeit animating the colors back to
    their original starting colors, so we can skip their explanation here. However,
    it is worth highlighting the fact that the third animation is also declared in
    a named `BeginStoryboard` that has its `HandoffBehavior` property set to `Compose`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trigger.ExitActions`集合中的三个动画与`EnterActions`集合中的动画非常相似，尽管它们是将颜色动画回原始起始颜色，所以我们在这里可以跳过它们的解释。然而，值得注意的是，第三个动画也是在具有其`HandoffBehavior`属性设置为`Compose`的命名`BeginStoryboard`中声明的。'
- en: The next `Trigger` object will start its associated storyboard when the `IsPressed`
    property of the `Button` element is true, and as it is declared within the `EnterActions`
    collection, it will start when the user presses the mouse button down, rather
    than upon its release.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`Trigger`对象将在`Button`元素的`IsPressed`属性为真时启动其关联的故事板，并且由于它是在`EnterActions`集合中声明的，它将在用户按下鼠标按钮时启动，而不是在其释放时。
- en: This animation also uses indirect targeting to reference the `Background` property
    of the `InnerBorder` element and also has a named `BeginStoryboard` object with
    its `HandoffBehavior` property set to `Compose`. Unlike the other animations,
    this one has an extended duration and also sets the `DecelerationRatio` property
    to `1.0`, which results in quick start and slow end.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画也使用间接目标来引用`InnerBorder`元素的`Background`属性，并且还有一个具有其`HandoffBehavior`属性设置为`Compose`的命名`BeginStoryboard`对象。与其它动画不同，这个动画具有更长的持续时间，并且还将`DecelerationRatio`属性设置为`1.0`，这导致快速开始和缓慢结束。
- en: Finally, we reach the last trigger, which is an `EventTrigger` object that will
    be triggered when the `Button` object is unloaded. In this trigger, we remove
    the three named storyboards, thereby freeing the extra resources that they consume
    when using the `Compose` handoff behavior. This was the sole purpose for naming
    the three `BeginStoryboard` objects that reference the `Background` property.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达最后一个触发器，它是一个`EventTrigger`对象，当`Button`对象卸载时将被触发。在这个触发器中，我们移除了三个命名的故事板，从而释放了它们在使用`Compose`传递行为时消耗的额外资源。这就是为什么给三个引用`Background`属性的`BeginStoryboard`对象命名的原因。
- en: When animating mouse over effects on buttons, we are not restricted to simply
    changing the background and border colors. The more imaginative that we can be,
    the more our applications will stand out from the crowd.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当对按钮上的鼠标悬停效果进行动画处理时，我们不仅限于简单地更改背景和边框颜色。我们越有想象力，我们的应用程序就越能脱颖而出。
- en: 'For example, rather than simply changing the background color of the button,
    we can instead move the focal point of the gradient with the mouse. We''ll need
    to use some code to do this, so we''ll need to create another custom control to
    demonstrate this point. Let''s first take a look at the code from our new custom
    control:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是简单地更改按钮的背景颜色，我们可以用鼠标移动渐变的焦点。为此，我们需要使用一些代码，因此我们需要创建另一个自定义控件来演示这一点。让我们首先看看我们新自定义控件中的代码：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We start as usual, by adding the relevant references and declaring the `PART_RootGrid`
    panel element as being a required part of the control template in the `TemplatePartAttribute`
    attribute. As our custom control is a button, we extend the `ButtonBase` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始，通过添加相关引用并声明`PART_RootGrid`面板元素为`TemplatePartAttribute`属性中控制模板的必需部分。由于我们的自定义控件是一个按钮，我们扩展了`ButtonBase`类。
- en: 'Next, we define the `glowBrush` field and set it to `null`. In the static constructor,
    we call the `OverrideMetadata` method to inform the Framework of where our control''s
    default style is. We then declare a `GlowMode` CLR property of type `GlowMode` and
    set it to the default `FullCenterMovement` member. Let''s see the members of this
    `GlowMode` enumeration now:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`glowBrush`字段并将其设置为`null`。在静态构造函数中，我们调用`OverrideMetadata`方法来通知框架我们的控件默认样式在哪里。然后我们声明一个类型为`GlowMode`的`GlowMode`
    CLR属性并将其设置为默认的`FullCenterMovement`成员。现在让我们看看这个`GlowMode`枚举的成员：
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Returning to our `GlowButton` class, we also declare a `GlowColor` Dependency
    Property and define a default purple color, a property changed handler and some
    CLR property wrappers for it. In the `OnGlowColorChanged` handler method, we cast
    the `dependencyObject` input parameter to our `GlowButton` class and call the
    `SetGlowColor` method, passing in the new `Color` input value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的`GlowButton`类，我们还声明了一个`GlowColor`依赖属性，并定义了一个默认的紫色颜色，一个属性更改处理程序以及一些CLR属性包装器。在`OnGlowColorChanged`处理程序方法中，我们将`dependencyObject`输入参数转换为我们的`GlowButton`类，并调用`SetGlowColor`方法，传入新的`Color`输入值。
- en: Next, we see the `OnApplyTemplate` method that is called when the button element's
    control template has been applied. In this method, we attempt to access the `PART_Root`
    panel element using the `GetTemplateChild` method and check it for `null`. If
    it is not `null`, we do a number of things.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到当按钮元素的控件模板被应用时调用的`OnApplyTemplate`方法。在这个方法中，我们尝试使用`GetTemplateChild`方法访问`PART_Root`面板元素并检查它是否为`null`。如果不是`null`，我们就会做很多事情。
- en: First, we attach the `Grid_MouseMove` event handler method to the grid's `MouseMove`
    event. Note that this is the way to attach event handlers to the UI elements that
    are declared in the `Generic.xaml` file, as it has no related code behind file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`Grid_MouseMove`事件处理方法附加到网格的`MouseMove`事件上。请注意，这是将事件处理程序附加到在`Generic.xaml`文件中声明的UI元素的方法，因为它没有相关的后端代码文件。
- en: Next, we call the grid's `FindResource` method in order to access the `GlowBrush`
    resource from its `Resources` section and set it to our local `glowBrush` field,
    as we will be referencing it regularly. After this, we call the `SetGlowColor`
    method and pass in the current `GlowColor` value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用网格的`FindResource`方法，以便从其`Resources`部分访问`GlowBrush`资源，并将其设置到我们的本地`glowBrush`字段中，因为我们将会经常引用它。之后，我们调用`SetGlowColor`方法并传入当前的`GlowColor`值。
- en: We do this because the `OnApplyTemplate` method is generally called after the
    properties have been set, but we are unable to update the brush resource until
    the template has been applied. When writing custom controls, we often need to
    update properties from this method, once the template has been applied.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为`OnApplyTemplate`方法通常在属性设置之后被调用，但我们无法在模板应用之前更新画笔资源。在编写自定义控件时，我们经常需要在这个方法中更新属性，一旦模板被应用。
- en: Next is the `SetGlowColor` method and in it we first make the set color semi-transparent.
    If the `glowBrush` variable is not `null`, we then access the third `GradientStop`
    element from its `GradientStops` collection and set its `Color` property to the
    value of our `GlowColor` property.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`SetGlowColor`方法，在其中我们首先将设置的颜色设置为半透明。如果`glowBrush`变量不是`null`，然后我们从其`GradientStops`集合中访问第三个`GradientStop`元素并将其`Color`属性设置为`GlowColor`属性的值。
- en: Note that the third `GradientStop` element represents the dominant color in
    this gradient and so in this example, we are only updating this single element,
    in order to save space in this book. This gives the overall impression of a complete
    color change, but anyone that looks carefully will be able to see a dash of purple
    showing through from the other two unchanged `GradientStop` elements. You may
    wish to extend this example to update the whole `GradientStops` collection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第三个`GradientStop`元素代表这个渐变中的主导颜色，因此在这个例子中，我们只更新这个单个元素，以节省这本书的空间。这给人一种整体颜色变化的印象，但任何仔细观察的人都会看到从另外两个未更改的`GradientStop`元素中透出的紫色。你可能希望扩展这个例子以更新整个`GradientStops`集合。
- en: Next, we see the `Grid_MouseMove` event handling method that was attached to
    the `rootGrid` variable in the `OnApplyTemplate` method. In it, we check that
    the mouse is currently over the grid and that the `glowBrush` variable is not
    `null`. If these conditions are true, we call the `GetPosition` method on the
    `MouseEventArgs` input parameter to get the current position of the mouse.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到在`OnApplyTemplate`方法中附加到`rootGrid`变量的`Grid_MouseMove`事件处理方法。在其中，我们检查鼠标是否当前位于网格上，并且`glowBrush`变量不是`null`。如果这些条件成立，我们就在`MouseEventArgs`输入参数上调用`GetPosition`方法以获取鼠标的当前位置。
- en: Using the mouse position and the current value of the `GlowMode` property, we
    determine the movement mode and update the position of the `glowBrush` field's
    `Center` and/or `GradientOrigin` properties.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标位置和当前的`GlowMode`属性值，我们确定移动模式并更新`glowBrush`字段`Center`和/或`GradientOrigin`属性的位置。
- en: 'This has the effect of moving the center and/or the focal point of the gradient
    with the mouse cursor when it is over our glow button. Let''s see the XAML in
    the `Generic.xaml` file now:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得当鼠标悬停在我们的发光按钮上时，渐变的中心点和/或焦点随着鼠标光标移动。现在让我们看看`Generic.xaml`文件中的XAML：
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside this `ControlTemplate`, we see the `Grid` named `PART_Root`, and, inside
    it, we see a number of resources declared in its `Resources` section. Much of
    this XAML is taken up by the same resources that we used in our layered button
    background example, so we can skip their explanation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`ControlTemplate`内部，我们看到名为`PART_Root`的`Grid`，在其内部，我们看到在其`Resources`部分声明了许多资源。大部分这个XAML都是我们用于分层按钮背景示例中的相同资源，因此我们可以跳过它们的解释。
- en: There is however, one new resource of type `RadialGradientBrush` and named `GlowBrush`.
    This is the brush that puts the color into our button. In particular, note that
    its `RelativeTransform` property is set to a `ScaleTransform` element named `ScaleTransform`
    and that its third `GradientStop` object is data bound to the `GlowColor` property
    from our control.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个新的资源类型为`RadialGradientBrush`，命名为`GlowBrush`。这是将颜色放入我们的按钮的画笔。特别是，请注意，它的`RelativeTransform`属性被设置为名为`ScaleTransform`的`ScaleTransform`元素，并且它的第三个`GradientStop`对象与我们的控件中的`GlowColor`属性数据绑定。
- en: In the actual template, we see our double `Border` elements with their `SnapsToDevicePixels`
    properties set to true to ensure a sharp, rendered image. Again, the outer border
    has a larger `CornerRadius` value than the inner border, to ensure their tight
    fit together, and the inner border's background is painted with the `LayeredButtonBackground`
    visual brush that we saw earlier.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际模板中，我们看到我们的双`Border`元素，它们的`SnapsToDevicePixels`属性被设置为true以确保清晰的渲染图像。同样，外边框的`CornerRadius`值比内边框大，以确保它们紧密地结合在一起，内边框的背景是用我们之前看到的`LayeredButtonBackground`视觉画笔绘制的。
- en: Inside the inner border, we have a `Grid` panel that contains a `Rectangle`
    element and the required `ContentPresenter` object. We use the `GlowBrush` resource
    to paint the background of the rectangle and set its `IsHitTestVisible` property
    to `false`, so that it takes no part in user interaction. Note that in this example,
    we set its `Opacity` property to zero to make it initially invisible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部边框内，我们有一个包含一个`Rectangle`元素和所需的`ContentPresenter`对象的`Grid`面板。我们使用`GlowBrush`资源来绘制矩形的背景，并将其`IsHitTestVisible`属性设置为`false`，这样它就不会参与用户交互。请注意，在这个例子中，我们将它的`Opacity`属性设置为零，使其最初不可见。
- en: We data bind the button's `Content` and `Padding` properties to the `Content`
    and `Margin` properties of the `ContentPresenter` element, respectively, and center
    it within the control. That completes the visual markup for our glow button and
    now, we reach the all-important `Grid.Triggers` collection, where we declare three
    `EventTrigger` objects to trigger our mouse over effects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按钮的`Content`和`Padding`属性分别数据绑定到`ContentPresenter`元素的`Content`和`Margin`属性，并在控件内居中。这样就完成了我们的发光按钮的视觉标记，现在，我们到达了至关重要的`Grid.Triggers`集合，在这里我们声明了三个`EventTrigger`对象来触发我们的鼠标悬停效果。
- en: The first trigger starts its associated storyboard when the `MouseEnter` event
    is raised. Its associated `DoubleAnimation` object animates the "glowing" rectangle's
    `Opacity` property to `1.0` over half a second. Note that we omit the `From` property
    here, so that the `Opacity` value will start animating from its current value,
    rather than jumping back to `0.0` each time it starts the animation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个触发器在`MouseEnter`事件被触发时开始其相关的故事板。它相关的`DoubleAnimation`对象将“发光”矩形的`Opacity`属性在半秒内动画化到`1.0`。请注意，我们在这里省略了`From`属性，这样`Opacity`值将从一个当前值开始动画化，而不是每次动画开始时跳回到`0.0`。
- en: The second trigger starts its storyboard when the `MouseLeave` event is raised.
    Its `DoubleAnimation` object animates the rectangle's `Opacity` property back
    to `0.0` over a whole second. Note that we also omit the `From` property here
    so that the `Opacity` value will start animating from its current value, rather
    than jumping to `1.0` each time it starts its animation. This ensures a smoother
    transition.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个触发器在`MouseLeave`事件被触发时开始其故事板。它的`DoubleAnimation`对象将矩形的`Opacity`属性在整整一秒内动画化回`0.0`。请注意，我们在这里省略了`From`属性，这样`Opacity`值将从一个当前值开始动画化，而不是每次动画开始时跳转到`1.0`。这确保了更平滑的过渡。
- en: The third trigger starts its storyboard when the `MouseDown` event is raised
    and it contains two `DoubleAnimation` objects. They animate the `ScaleX` and `ScaleY`
    properties of the `ScaleTransform` object from `10.0` to their usual values over
    one hundred and fifty milliseconds, which produces an interesting effect when
    the user clicks the button.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个触发器在`MouseDown`事件被触发时开始其故事板，并包含两个`DoubleAnimation`对象。它们将`ScaleTransform`对象的`ScaleX`和`ScaleY`属性从`10.0`动画化到它们的正常值，在150毫秒内完成，当用户点击按钮时会产生有趣的效果。
- en: 'Using the `GlowColor` and `GlowMode` properties, we can produce a wide range
    of buttons and interaction effects. After defining the relevant XAML namespace
    in our View, we can use this glow button example in the following way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GlowColor`和`GlowMode`属性，我们可以产生广泛的按钮和交互效果。在我们在视图中定义了相关的XAML命名空间之后，我们可以以下这种方式使用这个发光按钮示例：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When our example is run, it can produce mouse over effects, which vary depending
    on the position of the mouse cursor, as shown in the following examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的示例运行时，它可以产生鼠标悬停效果，这些效果根据鼠标光标的位置而变化，如下面的示例所示：
- en: '![](img/e7db5a27-60f6-4860-bdfc-b8e067842d25.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7db5a27-60f6-4860-bdfc-b8e067842d25.png)'
- en: The top left button illustrates the `HorizontalCenterMovement` mode, the top
    right shows the `FullCenterMovement` mode and the bottom two highlight two mouse
    positions when using the `NoCenterMovement` mode. The top two use the default
    color and the bottom two were rendered using a `GlowColor` of `Red`. This reveals
    the differences between the various `GlowMode` values in our example.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 左上角的按钮展示了`HorizontalCenterMovement`模式，右上角显示了`FullCenterMovement`模式，底部两个按钮在`NoCenterMovement`模式下突出了鼠标的位置。顶部两个使用默认颜色，底部两个使用`GlowColor`的`Red`进行渲染。这揭示了我们在示例中各种`GlowMode`值之间的差异。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we investigated a number of techniques that we can use to improve
    the look of our applications, from simply adding shadows to implementing far more
    complicated layered visuals. We saw the importance of remaining consistent throughout
    our application and how to get that professional look.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种技术，这些技术可以帮助我们改善应用程序的外观，从简单地添加阴影到实现更复杂的分层视觉效果。我们看到了在整个应用程序中保持一致性的重要性，以及如何获得专业的外观。
- en: We then looked at more advanced techniques for making our application stand
    out from the crowd and saw further examples of how to create a variety of custom
    controls. We finished with a look at how we can incorporate animations into our
    everyday controls, in order to bring about a sense of exclusivity to our applications.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了使我们的应用程序脱颖而出的高级技术，并进一步展示了如何创建各种自定义控件。最后，我们探讨了如何将动画融入我们的日常控件中，以给我们的应用程序带来一种独特感。
- en: In the following chapter, we're going to investigate a number of ways that we
    can validate the data in our applications. We'll examine the various validation
    interfaces that are available to us in WPF and work on extending our application
    framework with a complete validation system using data annotations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多种验证应用程序中数据的方法。我们将检查WPF中可用的各种验证接口，并致力于通过使用数据注释扩展我们的应用程序框架，以实现一个完整的验证系统。
