<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>14 Layering and Clean Architecture</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="15">14 Layering and Clean Architecture</h1>

<h2 data-number="15.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file74.png" style="width:10em"/>In this chapter, we explore the inherent concepts behind layering. Layering is a popular way of organizing computer systems by encapsulating major concerns into layers. Those concerns are related to a computer vocation, such as data access, instead of a business concern, such as inventory. Understanding the concepts behind layering is essential, as other concepts were born from layers and are very common.We start this chapter by exploring the initial ideas behind layering. Then, we explore alternatives that can help us solve different problems. We use anemic and rich models and expose their pros <strong/> and cons. Finally, we quickly explore <strong>Clean Architecture</strong>, an evolution of layering, and a way to organize layers.This chapter lays out the evolution of layering, starting with basic, restrictive, and even flawed techniques, then we gradually move toward more modern patterns. This journey should help you understand the concepts and practices behind layering, giving you a stronger understanding than just learning one way of doing things. The key is to understand.In this chapter, we cover the following topics:</p>
<ul>
<li>Introducing layering</li>
<li>Responsibilities of the common layers</li>
<li>Abstract layers</li>
<li>Sharing a model</li>
<li>Clean Architecture</li>
<li>Implementing layering in real life</li>
</ul>
<p>Let’s get started!</p>


<h2 data-number="15.2">Introducing layering</h2>
<p>Now that we’ve explored a few design patterns and played with ASP.NET Core, it is time to jump into layering. In most computer systems, there are layers. Why? Because it is an efficient way to partition and organize units of logic together. We could conceptually represent layers as horizontal software segments, each encapsulating a concern.</p>

<h3 data-number="15.2.1">Classic layering model</h3>
<p>Let’s start by examining a classic three-layer application design:</p>
<figure>
<img alt="Figure 14.1: A classic three-layer application design" src="img/file75.png"/><figcaption aria-hidden="true">Figure 14.1: A classic three-layer application design</figcaption>
</figure>
<p>The <strong>presentation layer</strong> represents any user interface that a user can interact with to reach the <strong>domain</strong>. It could be an ASP.NET Core web application. Anything from WPF to WinForms to Android could be a valid non-web presentation layer alternative.The <strong>domain layer</strong> represents the core logic driven by the business rules; this solves the application’s problem. The domain layer is also called the <strong>business logic layer</strong> (<strong>BLL</strong>).The <strong>data layer</strong> represents the bridge between the data and the application. The layer can store the data in a SQL Server database, a NoSQL database hosted in the cloud, a mix of many data sources, or anything else that fits the business needs. The data layer is also called the <strong>data access layer</strong> (<strong>DAL</strong>) and the <strong>persistence layer</strong>.Let’s jump to an example. Given that a user has been authenticated and authorized, here is what happens when they want to create a book in a bookstore application built using those three layers:</p>
<ol>
<li>The user requests the page by sending a <code>GET</code> request to the server.</li>
<li>The server handles that <code>GET</code> request (<strong>presentation layer</strong>) and then returns the page to the user.</li>
<li>The user fills out the form and sends a <code>POST</code> request to the server.</li>
<li>The server handles the <code>POST</code> request (<strong>presentation layer</strong>) and then sends it to the <strong>domain layer</strong> for processing.</li>
<li>The <strong>domain layer</strong> executes the logic required to create a book, then tells the <strong>data layer</strong> to persist that data.</li>
<li>After unrolling to the presentation layer, the server returns the appropriate response to the user, most likely a page containing a list of books and a message saying the operation was successful.</li>
</ol>
<p>Following a classic layering architecture, a layer can only talk to the next layer in the stack—<strong>presentation</strong> talks to <strong>domain</strong>, which talks to <strong>data</strong>, and so on. The important part is that <strong>each layer must be independent and isolated to limit tight coupling</strong>.In this classic layering model, each layer should own its <strong>model</strong>. For example, the presentation layer should not send its <strong>view models</strong> to the <strong>domain</strong> layer; only <strong>domain objects</strong> should be used there. The opposite is also true: since the <strong>domain</strong> returns its own objects to the <strong>presentation layer</strong>, the <strong>presentation layer</strong> should not leak them to its consumers but organize the required information into <strong>view models</strong> or <strong>DTO</strong> instead.Here is a visual example:</p>
<figure>
<img alt="Figure 14.2: Diagram representing how the layers interact with one another" src="img/file76.png"/><figcaption aria-hidden="true">Figure 14.2: Diagram representing how the layers interact with one another</figcaption>
</figure>
<p>Even if three is probably the most popular number of layers, we can create as many as we need; we are not limited to three layers.Let’s examine the advantages and disadvantages of classic layering, starting with the advantages:</p>
<ul>
<li>Knowing the purpose of a layer makes it easy to understand. For example, guessing that the data layer components read or write some data somewhere is easy.</li>
<li>It creates a cohesive unit built around a single concern. For example, our <strong>data layer</strong> should not render any user interface but stick to accessing data.</li>
<li>It allows us to decouple the layer from the rest of the system (the other layers). You can isolate and work within a layer with limited to no knowledge of the others. For example, suppose you are tasked with optimizing a query in a data access layer. In that case, you don’t need to know about the user interface that eventually displays that data to a user. You only need to focus on that element, optimize it, test it in isolation, and then ship the layer or redeploy the application.</li>
<li>Like any other isolated unit, it should be possible to reuse a layer. For example, we could reuse our <strong>data access layer</strong> in another application that needs to query the same database for a different purpose (a different <strong>domain layer</strong>).</li>
</ul>
<blockquote>
<p><strong>TIP</strong></p>
<blockquote>
<p>Some layers are theoretically easier to reuse than others, and reusability could add more or less value, depending on the software you are building. I have never seen a layer being integrally reused in practice, and I’ve rarely heard or read about such a situation—each time rather ends in a not-so-reusable-after-all situation.</p>
</blockquote>
<blockquote>
<p>Based on my experience, I would strongly suggest not over-aiming at reusability when it is not a precise specification that adds value to your application. Limiting your overengineering endeavors could save you and your employers a lot of time and money. We must not forget that our job is to deliver value.</p>
</blockquote>
<blockquote>
<p>As a rule of thumb, do what needs to be done, not more, but do it well.</p>
</blockquote>
</blockquote>
<p>OK, now, let’s look at the drawbacks:</p>
<ul>
<li>By splitting your software horizontally into layers, each feature crosses all of the layers. This often leads to cascading changes between layers. For example, if we decide to add a field to our bookstore database, we would need to update the database, the code that accesses it (<strong>data layer</strong>), the business logic (<strong>domain layer</strong>), and the user interface (<strong>presentation layer</strong>). With volatile specs or low-budget projects, this can become painful!</li>
<li>Implementing a full-stack feature is more challenging for newcomers because it crosses all layers.</li>
<li>Using layering often leads to or is caused by a separation of responsibilities between the staff. For example, DBAs manage the data layer, backend devs manage the domain layer, and frontend devs manage the presentation layer, leading to coordination and knowledge-sharing issues.</li>
<li>Since a layer directly depends on the layer under it, dependency injection is impossible without introducing an <strong>abstraction layer</strong> or referencing lower layers from the <strong>presentation layer</strong>. For example, if the <strong>domain layer</strong> depends on the <strong>data layer</strong>, changing the data layer would require rewriting all of that coupling from the <strong>domain</strong> to the <strong>data</strong>.</li>
<li>Since each layer owns its entities, the more layers you add, the more copies there are of the entities, leading to minor performance loss and a higher maintenance cost. For example, the <strong>presentation layer</strong> copies a <strong>DTO</strong> to a <strong>domain object</strong>. Then, the <strong>domain layer</strong> copies it to a <strong>data object</strong>. Finally, the <strong>data layer</strong> translates it into SQL to persist it into a <strong>database</strong> (SQL Server, for example). The opposite is also true when reading from the database.</li>
</ul>
<p>We explore ways to combat some of those drawbacks later.I strongly recommend that you don’t do what we just explored. It is an old, more basic way of doing layering. We are looking at multiple improvements to this layering system in this chapter, so keep reading before jumping to a conclusion. I decided to explore layering from the beginning in case you have to work with that kind of application. Furthermore, studying its chronological evolution, fixing some flaws, and adding options should help you understand the concepts instead of just knowing a single way of doing things. Understanding the patterns is the key to software architecture, not just learning how to apply them.</p>


<h3 data-number="15.2.2">Splitting the layers</h3>
<p>Now that we’ve discussed layers and seen them as big horizontal slices of responsibilities, we can organize our applications more granularly by splitting those big slices vertically, creating multiple smaller layers. This can help us organize applications by features or by bounding context, and it could also allow us to compose various user interfaces using the same building blocks, which would be easier than reusing colossal-size layers.Here is a conceptual representation of this idea:</p>
<figure>
<img alt="Figure 14.3: Organizing multiple applications using smaller partially shared layers" src="img/file77.png"/><figcaption aria-hidden="true">Figure 14.3: Organizing multiple applications using smaller partially shared layers</figcaption>
</figure>
<p>We can split an application into multiple features (vertically) and divide each into layers (horizontally). Based on the previous diagram, we named those features as follows:</p>
<ul>
<li>Inventory management</li>
<li>Online shopping</li>
<li>Others</li>
</ul>
<p>So, we can bring in the online shopping domain and data layers to our Shopping web API without bringing everything else with it. Moreover, we can bring the online shopping domain layer to the mobile app and swap its data layer for another that talks to the web API.We could also use our web API as a plain and simple data access application with different logic attached to it while keeping the shopping data layer underneath.We could end up with the following recomposed applications (this is just one possible outcome):</p>
<figure>
<img alt="Figure 14.4: Organizing multiple applications using smaller partially shared layers" src="img/file78.png"/><figcaption aria-hidden="true">Figure 14.4: Organizing multiple applications using smaller partially shared layers</figcaption>
</figure>
<p>These are just examples of what we can conceptually do with layers. However, the most important thing to remember is not how the diagrams are laid out but the specifications of the applications you are building. Only those specs and good analyses can help you create the best possible design for that exact problem. I used a hypothetical shopping example here, but it could have been anything.Splitting huge horizontal slices vertically makes each piece easier to reuse and share. This improvement can yield interesting results, especially if you have multiple frontend apps or plan to migrate away from a monolith.</p>
<blockquote>
<p>A <strong>monolithic application</strong> (or monolith) is a program deployed as a single integrated piece with low modularity. A monolith can leverage layers or not. People often compare monolithic applications to microservices applications because they are antipodes. We explore microservices in <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>, and monoliths in <em>Chapter 20</em>, <em>Modular Monoliths</em>.</p>
</blockquote>


<h3 data-number="15.2.3">Layers versus tiers versus assemblies</h3>
<p>So far in this chapter, we have been talking about layers without talking about making them into code. Before jumping into that subject, I’d like to discuss <strong>tiers</strong>. You may have seen the term <strong>3-tier architecture</strong> somewhere before or heard people talking about <strong>tiers</strong> and <strong>layers</strong>, possibly interchanging them in the same context as synonyms. However, they are not the same.In a nutshell:</p>
<ul>
<li><strong>Tiers</strong> are <strong>physical</strong></li>
<li><strong>Layers</strong> are <strong>logical</strong></li>
</ul>

<h4 data-number="15.2.3.1">What is a Tier?</h4>
<p>We can deploy each <strong>tier</strong> on its own machine. For example, you could have a database server, a server hosting your web API that contains the business logic (the <strong>domain</strong>), and another server that serves an Angular application (<strong>presentation</strong>); these are three tiers (three distinct machines), and each <strong>tier</strong> can scale independently.We look at layers next.</p>


<h4 data-number="15.2.3.2">What is a Layer?</h4>
<p>On the other hand, each <strong>layer</strong> is only the logical organization of code, with concerns organized and divided in a layered fashion. For example, you may create one or more projects in Visual Studio and organize your code into three layers. For example, a Razor Pages application depends on a business logic layer that depends on a data access layer. When you deploy that application, all these layers, including the database, are deployed together on the same server. This would be one tier and three layers. Of course, nowadays, chances are you have a cloud database somewhere, which adds a second tier to that architecture: the application tier (which still has three layers) and database tier.Now that we’ve discussed <strong>layers</strong> and <strong>tiers</strong>, let’s look at a <strong>layer</strong> versus an <strong>assembly</strong>.</p>


<h4 data-number="15.2.3.3">What is an assembly?</h4>
<p><strong>Assemblies</strong> are commonly compiled into <code>.dll</code> or <code>.exe</code> files; you can compile and consume them directly. In most cases, each project of a Visual Studio solution gets compiled into an assembly. You can also deploy them as NuGet packages and consume them from <a href="https://www.nuget.org">nuget.org</a> or a custom NuGet repository of your choosing. But there is no one-to-one relationship between a layer and an assembly or a tier and an assembly; assemblies are only consumable units of compiled code: a library or a program.Moreover, you do not need to split your layers into different assemblies; you can have your three layers residing in the same assembly. It can be easier to create undesirable coupling this way, with all of the code being in the same project, but it is a viable option with some rigor, rules, and conventions. Moving each layer to an assembly does not necessarily improve the application; the code inside each layer or assembly can become mixed up and coupled with other system parts.Don’t get me wrong: you can create an assembly per layer; I even encourage you to do so in most cases, but doing so does not mean the layers are not tightly coupled. A layer is simply a logical unit of organization, so each contributor’s responsibility is to ensure the layer’s code stays healthy.Furthermore, having multiple assemblies let us deploy them to one or more machines, potentially different machines, leading to multiple tiers.Let’s now look at the responsibilities of the most common layers.</p>




<h2 data-number="15.3">Responsibilities of the common layers</h2>
<p>In this section, we explore the most commonly used layers in more depth. We do not dig too deep into each one, but the overview should help you understand the essential ideas behind layering.</p>

<h3 data-number="15.3.1">Presentation</h3>
<p>The <strong>presentation layer</strong> is probably the easiest layer to understand because it is the only one we can see: the user interface. However, the presentation layer can also be the data contracts in case of a REST, OData, GraphQL, or other types of web service. The presentation layer is what the user uses to access your program. As another example, a CLI program can be a presentation layer. You write commands in a terminal, and the CLI dispatches them to its domain layer, executing the required business logic.The key to a maintainable presentation layer is to keep it as focused on displaying the user interface as possible with as little business logic as possible.Next, we look at the <strong>domain layer</strong> to see where these calls go.</p>


<h3 data-number="15.3.2">Domain</h3>
<p>The <strong>domain layer</strong> is where the software’s value resides and where most of the complexity lies. The <strong>domain layer</strong> is the home of your business logic rules.It is easier to sell a <strong>user interface</strong> than a <strong>domain layer</strong> since users connect to the domain through the presentation. However, it is important to remember that the domain is responsible for solving the problems and automating the solutions; the <strong>presentation layer</strong> only links users’ actions to the <strong>domain</strong>.We usually build the domain layer around a domain model. There are two macro points of view on this:</p>
<ul>
<li>Using a <strong>rich model</strong>.</li>
<li>Using an <strong>anemic model</strong>.</li>
</ul>
<blockquote>
<p>You can leverage <strong>Domain-Driven Design</strong> (<strong>DDD</strong>) to build that model and the program around it. DDD goes hand in hand with rich models, and a well-crafted model should simplify the maintenance of the program. Doing DDD is not mandatory, and you can achieve the required level of correctness without it.</p>
</blockquote>
<p>Another dilemma is persisting the domain model directly into the database or using an intermediate data model. We talk about that in more detail in the <em>Data</em> section.Meanwhile, we look at the two primary ways to think about the domain model, starting with the rich domain model.</p>

<h4 data-number="15.3.2.1">Rich domain model</h4>
<p>A rich domain model is more object-oriented, in the “purest” sense of the term, and encapsulates the domain logic as part of the model inside methods. For example, the following class represents the rich version of a minimal <code>Product</code> class that contains only a few properties:</p>
<div><pre><code>public class Product
{
    public Product(string name, int quantityInStock, int? id = null)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
        QuantityInStock = quantityInStock;
        Id = id;
    }
    public int? Id { get; init; }
    public string Name { get; init; }
    public int QuantityInStock { get; private set; }
    public void AddStock(int amount)
    {
        if (amount == 0) { return; }
        if (amount &lt; 0) { 
            throw new NegativeValueException(amount);
        }
        QuantityInStock += amount;
    }
    public void RemoveStock(int amount)
    {
        if (amount == 0) { return; }
        if (amount &lt; 0) { 
            throw new NegativeValueException(amount);
        }
        if (amount &gt; QuantityInStock) { 
            throw new NotEnoughStockException(
                QuantityInStock, amount); 
        }
        QuantityInStock -= amount;
    }
}</code></pre>
</div>
<p>The <code>AddStock</code> and <code>RemoveStock</code> methods represent the domain logic of adding and removing stock for the product inventory. Of course, we only increment and decrement a property’s value in this case, but the concept would be the same in a more complex model.The biggest advantage of this approach is that most of the logic is built into the model, making this very domain-centric with operations programmed on model entities as methods. Moreover, it reaches the basic ideas behind object-oriented design, where behaviors should be part of the objects, making them a virtual representation of their real-life counterparts.The biggest drawback is the accumulation of responsibilities by a single class. Even if object-oriented design tells us to put logic into the objects, this does not mean it is always a good idea. If flexibility is important for your system, hardcoding logic into the domain model may hinder your ability to evolve business rules without changing the code itself (it can still be done). A rich model might be a good choice for your project if the domain is fixed and predefined.A relative drawback of this approach is that injecting dependencies into the domain model is harder than other objects, such as services. This drawback reduces flexibility and increases the complexity of creating the models.A rich domain model can be useful if you are building a stateful application where the domain model can live in memory longer than the time of an HTTP request. Other patterns can help you with that, such as <strong>Model-View-View-Model</strong> (<strong>MVVM</strong>), Model-View-Presenter (MVP), and <strong>Model-View-Update</strong> (<strong>MVU</strong>).If you believe your application would benefit from keeping the data and the logic together, then a rich domain model is most likely a good idea for your project. If you are practicing DDD, I probably don’t have to tell you that a rich model is the way to go. Without DDD notions, achieving a maintainable and flexible rich model is challenging.A rich model can be a good option if your program is built around a complex domain model and persists those classes directly to your database using an <strong>object-relational mapper</strong> (<strong>ORM</strong>). Using Cosmos DB, Firebase, MongoDB, or any other document database can make storing complex models as a single document easier than a collection of tables (this applies to anemic models too).As you may have noticed, there are a lot of “ifs” in this section because I don’t think there is an absolute answer to whether a rich model is better or not, and it is more a question of whether it is better for your specific case than better overall. You also need to take your personal preferences and skills into account.Experience is most likely your best ally here, so I’d recommend coding, coding, and coding more applications to acquire that experience.</p>


<h4 data-number="15.3.2.2">Anemic domain model</h4>
<p>An anemic domain model usually does not contain methods but only getters and setters. Such models must not contain business logic rules. The <code>Product</code> class we had previously would look like this:</p>
<div><pre><code>public class Product
{
    public int? Id { get; set; }
    public required string Name { get; set; }
    public int QuantityInStock { get; set; }
}</code></pre>
</div>
<p>In the preceding code, there is no method in the class anymore, only the three properties with public setters. We can also leverage a record class to add immutability to the mix. As for the logic, we must move it elsewhere, in other classes. One such pattern would be to move the logic to a <strong>service layer</strong>.A <strong>service layer</strong> in front of such an <strong>anemic model</strong> would take the input, mutate the domain object, and update the database. The difference is that the service owns the logic instead of the rich model.With the anemic model, separating the operations from the data can help us add flexibility to a system. However, enforcing the model’s state at any given time can be challenging since external actors (services) are modifying the model instead of the model managing itself.Encapsulating logic into smaller units makes it easier to manage each of them, and it is easier to inject those dependencies into the service classes than injecting them into the entities themselves. Having more smaller units of code can make a system more dreadful for a newcomer as it can be more complex to understand since it has more moving parts. On the other hand, if the system is built around well-defined abstractions, it can be easier to test each unit in isolation.However, the tests can be quite different. In the case of our rich model, we test the rules and the persistence separately. We call this <strong>persistence ignorance</strong>, which allows us to test business rules in isolation. Then we could create integration tests to cover the persistence aspect of the service layer and more unit and integration tests on the data and domain levels. With an anemic model, we test both the business rules and the persistence simultaneously with integration tests at the service layer level or test only the business rules in unit tests that mock the persistence part away. Since the model is just a data bag without logic, there is nothing to test there.All in all, if the same rigorous domain analysis process is followed, the business rules of an anemic model backed by a service layer should be as complex as a rich domain model. The biggest difference should be in which classes the methods are located.An anemic model is a good option for stateless systems, such as RESTful APIs. Since you have to recreate the model’s state for every request, an anemic model can offer you a way to independently recreate a smaller portion of the model with smaller classes optimized for each use case. Stateless systems require a more procedural type of thinking than a purely object-oriented approach, leaving the anemic models as excellent candidates for that.</p>
<blockquote>
<p>I personally love anemic models behind a service layer, but some people would not agree with me. I recommend choosing what you think is best for the system you are building instead of doing something based on what someone else did in another system.</p>
<blockquote>
<p>Another good tip is to let the refactoring flow <em>top-down</em> to the right location. For example, if you feel that a method is bound to an entity, nothing stops you from moving that piece of logic into that entity instead of a service class. If a service is more appropriate, move the logic to a service class.</p>
</blockquote>
</blockquote>
<p>Next, let’s go back to the <strong>domain layer</strong> and explore a pattern that emerged over the years to shield the <strong>domain model</strong> using a <strong>service layer</strong>, splitting the <strong>domain layer</strong> into two distinct pieces.</p>


<h4 data-number="15.3.2.3">Service layer</h4>
<p>The <strong>service layer</strong> shields the domain model and encapsulates domain logic. The service layer orchestrates the complexity of interacting with the model or external resources such as databases. Multiple components can then use the service layer while having limited knowledge of the model:</p>
<figure>
<img alt="Figure 14.5: Service layer relationships with other layers" src="img/file79.png"/><figcaption aria-hidden="true">Figure 14.5: Service layer relationships with other layers</figcaption>
</figure>
<p>The preceding diagram shows that the presentation layer talks to the service layer, which manages the domain model and implements the business logic.The <strong>service layer</strong> contains services, which are classes that interact with other <strong>domain objects</strong>, such as the <strong>domain model</strong> and the <strong>data layer</strong>.We can further divide services into two categories, <strong>domain services</strong>, and <strong>application services</strong>:</p>
<ul>
<li><strong>Domain services</strong> are those services we are talking about so far. They contain domain logic and allow consumers from the presentation layer to read or write data. They access and mutate the domain model.</li>
<li><strong>Application services</strong> like email services are unrelated to the domain and should live elsewhere, like in a shared (why rewrite an email service for every project, right?).</li>
</ul>
<p>As with other layers, your service layer could expose its own model, shielding its consumers from domain model (internal) changes. In other words, the service layer should only expose its contracts and interfaces (keyword: shield). <strong>A service layer is a form of façade.</strong></p>
<blockquote>
<p>We further explore ways to keep copying anemic classes into other anemic classes to a minimum.</p>
</blockquote>
<p>There are many ways to interpret this layer, and I’ll try to illustrate as many as possible in a condensed manner (from simpler to more complex ones):</p>
<ul>
<li>The classes and interfaces of the service layer could be part of the domain layer’s assembly, created in a <em>Services</em> directory, for example. This is less reusable, but it paves the way to sharing services in the future without managing multiple projects at first. It needs rigor to not depend on what you should not.</li>
<li>The service layer could be an assembly containing interfaces and implementation. This is a great compromise between reusability and maintenance time. Chances are you will never need two implementations (see the next point) because the services are tied to the logic; they are the domain. You could even hide the implementation, as we did with the <strong>opaque façade</strong> in <em>Chapter 11</em>, <em>Structural Patterns</em>.</li>
<li>The service layer could be divided into two assemblies -- one containing abstractions (referenced by consumers) and one containing implementations.</li>
<li>The service layer could be an actual web service tier (such as a web API).</li>
</ul>
<p>When writing services code, by convention, people usually suffix a service class with <code>Service</code>, such as <code>ProductService</code> and <code>InventoryService</code>; the same goes for interfaces (<code>IProductService</code> and <code>IInventoryService</code>).No matter which technique you choose, remember that the service layer contains the domain logic and shields the domain model from direct access.The service layer is an amazing addition that shields and encapsulates the logic for manipulating an anemic domain model. It can defeat the purpose of a rich domain model if it’s just a pass-through but can be very useful to handle complex, non-atomic business rules that affect multiple domain objects.The primary decider of whether or not to add a service layer is tied to the complexity of your project’s domain. The more complex, the more it makes sense. The more trivial, the less it makes sense. Here are a few tips:</p>
<ul>
<li>Add a service layer when using an anemic model.</li>
<li>Add a service layer for very complex domains.</li>
<li>Do not add a service layer for low-complexity domains or <em>façade over database</em> applications.</li>
</ul>
<p>Now, let’s look at the data layer.</p>



<h3 data-number="15.3.3">Data</h3>
<p>The <strong>data layer</strong> is where the persistence code goes. In most programs, we need some kind of persistence to store our application data, which is often a database. Several patterns come to mind when discussing the data layer, including the <strong>Unit of Work</strong> and <strong>Repository patterns</strong>, which are very common. We cover these two patterns very briefly at the end of this subsection.We can persist our <strong>domain model</strong> as is or create a <strong>data model</strong> that is more suited to be stored. For example, a many-to-many relationship is not a thing in the object-oriented world, while it is from a relational database standpoint.You can view a <strong>data model</strong> like a <strong>DTO</strong> for the data. The <strong>data model</strong> is how the data is stored in your data store; that is, how you modeled your data or what you have to live with.In a classic layering project, you have no choice but to have a data model. However, we explore better solutions as we continue to explore additional options.</p>
<blockquote>
<p>An <strong>ORM</strong> is a piece of software that translates objects into a database language such as SQL. It allows mutating data, querying data, loading that data into objects, and more.</p>
</blockquote>
<p>Modern data layers usually leverage an <strong>ORM</strong> such as <strong>Entity Framework Core</strong> (<strong>EF Core</strong>), which does a big part of our job, making our lives easier. In the case of <strong>EF Core</strong>, it allows us to choose between multiple providers, from SQL Server to Cosmos DB, passing by the in-memory provider. The great thing about EF Core is that it already implements the <strong>Unit of Work</strong> and the <strong>Repository</strong> patterns for us, among other things. In the book, we use the in-memory provider to cut down setup time and run integration tests.</p>
<blockquote>
<p>If you’ve used EF6 before and dread Entity Framework, know that EF Core is lighter, faster, and easier to test. Feel free to give it a second shot. EF Core’s performance is very high now too. However, if you want complete control over your SQL code, look for Dapper (not to be confused with <strong>Dapr</strong>).</p>
</blockquote>
<p>I don’t want to go into too much detail about these patterns, but they are important enough to deserve an overview. As mentioned, EF Core already implements these patterns, so we don’t have to deal with them. Moreover, using such patterns is not always desirable, can be hard to implement right, and can lead to bloated data access layers, but they can also be very useful when used well.</p>
<blockquote>
<p>I’ve written a multi-part article series about the Repository pattern. See the <em>Further reading</em> section.</p>
</blockquote>
<p>In the meantime, let’s at least study their goals to know what they are for, and if the situation arises where you need to write such components, you know where to look.</p>

<h4 data-number="15.3.3.1">Repository pattern</h4>
<p>The goal of the Repository pattern is to allow consumers to query the database in an object-oriented way. Usually, this implies caching objects and filtering data dynamically. EF Core represents this concept with a <code>DbSet&lt;T&gt;</code> and provides dynamic filtering using LINQ and the <code>IQueryable&lt;T&gt;</code> interface.People also use the term <strong>repository</strong> to represent the <strong>Table Data Gateway pattern</strong>, which is another pattern that models a class that gives us access to a single table in a database and provides access to operations such as creating, updating, deleting, and fetching entities from that database table. Both patterns are from the <em>Patterns of Enterprise Application Architecture</em> and are extensively used.Homegrown custom implementations usually follow the Table Data Gateway pattern more than the Repository pattern. They are based on an interface that looks like the following code and contains methods to create, update, delete, and read entities. They can have a base entity or not, in this case, <code>IEntity&lt;TId&gt;</code>. The <code>Id</code> property can also be generic or not:</p>
<div><pre><code>public interface IRepository&lt;T, TId&gt;
    where T : class, IEntity&lt;TId&gt;
{
    Task&lt;IEnumerable&lt;T&gt;&gt; AllAsync(CancellationToken cancellationToken);
    Task&lt;T?&gt; GetByIdAsync(TId id, CancellationToken cancellationToken);
    Task&lt;T&gt; CreateAsync(T entity, CancellationToken cancellationToken);
    Task UpdateAsync(T entity, CancellationToken cancellationToken);
    Task DeleteAsync(TId id, CancellationToken cancellationToken);
}
public interface IEntity&lt;TId&gt;
{
    TId Id { get; }
}</code></pre>
</div>
<p>One thing that often happens with those table data gateways is that people add a save method to the interface. As long as you update a single entity, it should be fine. However, that makes transactions that cross multiple repositories harder to manage or dependent on the underlying implementation (breaking abstraction). To commit or revert such transactions, we can leverage the Unit of Work pattern, moving the save method from the table data gateway there.For example, when using EF Core, we can use <code>DbSet&lt;Product&gt;</code> (the <code>db.Products</code> property) to add new products to the database, like this:</p>
<div><pre><code>db.Products.Add(new Data.Product
{
    Id = 1,
    Name = "Banana",
    QuantityInStock = 50
});</code></pre>
</div>
<p>For the querying part, the easiest way to find a single product is to use it like this:</p>
<div><pre><code>var product = _db.Products.Find(productId);</code></pre>
</div>
<p>However, we could use LINQ instead:</p>
<div><pre><code>_db.Products.Single(x =&gt; x.Id == productId);</code></pre>
</div>
<p>These are some of the querying capabilities that a <strong>repository</strong> should provide. EF Core seamlessly translates LINQ into the configured provider expectations like SQL, adding extended filtering capabilities.Of course, with EF Core, we can query collections of items, fetching all products and projecting them as domain objects like this:</p>
<div><pre><code>_db.Products.Select(p =&gt; new Domain.Product
{
    Id = p.Id,
    Name = p.Name,
    QuantityInStock = p.QuantityInStock
});</code></pre>
</div>
<p>We can also filter further using LINQ here; for example, by querying all the products that are out of stock:</p>
<div><pre><code>var outOfStockProducts = _db.Products
    .Where(p =&gt; p.QuantityInStock == 0);</code></pre>
</div>
<p>We could also allow a margin for error, like so:</p>
<div><pre><code>var mostLikelyOutOfStockProducts = _db.Products
    .Where(p =&gt; p.QuantityInStock &lt; 3);</code></pre>
</div>
<p>We now have briefly explored how to use the EF Core implementation of the Repository pattern, <code>DbSet&lt;T&gt;</code>. These few examples might seem trivial, but it would require considerable effort to implement custom repositories on par with EF Core’s features.EF Core’s unit of work, the <code>DbContext</code> class, contains the <em>save</em> methods to persist the modifications done to all its <code>DbSet&lt;T&gt;</code> properties (the repositories). Homebrewed implementations often feature such methods on the repository itself, making cross-repository transactions harder to handle and leading to bloated repositories containing tons of operation-specific methods to handle such cases.Now that we understand the concept behind the <strong>Repository pattern</strong>, let’s jump into an overview of the <strong>Unit of Work pattern</strong> before going back to layering.</p>


<h4 data-number="15.3.3.2">Unit of Work pattern</h4>
<p>A <strong>unit of work</strong> keeps track of the object representation of a transaction. In other words, it manages a registry of what objects should be created, updated, and deleted. It allows us to combine multiple changes in a single transaction (one database call), offering multiple advantages over calling the database every time we make a change.Assuming we are using a relational database, here are two advantages:</p>
<ul>
<li>First, it can speed up data access; calling a database is slow, so limiting the number of calls and connections can improve performance.</li>
<li>Second, running a transaction instead of individual operations allows us to roll back all operations if one fails or commit the transaction as a whole if everything succeeds.</li>
</ul>
<p>EF Core implements this pattern with the <code>DbContext</code> class and its underlying types, such as the <code>DatabaseFacade</code> and <code>ChangeTracker</code> classes.Our small applications don’t need transactions, but the concept remains the same. Here is an example of what happens using EF Core:</p>
<div><pre><code>var product = _db.Products.Find(productId);
product.QuantityInStock += amount;
_db.SaveChanges();</code></pre>
</div>
<p>The preceding code does the following:</p>
<ol>
<li>Queries the database for a single entity.</li>
<li>Changes the value of the <code>QuantityInStock</code> property.</li>
<li>Persists the changes back into the database.</li>
</ol>
<p>In reality, what happened is closer to the following:</p>
<ol>
<li>We ask EF Core for a single entity through the <code>ProductContext</code> (a unit of work), which exposes the <code>DbSet&lt;Product&gt;</code> property (the product repository). Under the hood, EF Core does the following:
<ol type="A">
<li>Queries the database.</li>
<li>Caches the entity.</li>
<li>Tracks changes for that entity.</li>
<li>Returns it to us.</li>
</ol></li>
<li>We change the value of the <code>QuantityInStock</code> property; EF Core detects the change and marks the object as <em>dirty</em>.</li>
<li>We tell the unit of work to persist the changes that it tracked, saving the <em>dirty product</em> back to the database.</li>
</ol>
<p>In a more complex scenario, we could have written the following code:</p>
<div><pre><code>_db.Products.Add(newProduct);
_db.Products.Remove(productToDelete);
product.Name = "New product name";
_db.SaveChanges();</code></pre>
</div>
<p>Here, the <code>SaveChanges()</code> method triggers saving the three operations instead of sending them individually. You can control database transactions using the <code>Database</code> property of <code>DbContext</code> (see the <em>Further reading</em> section for more information).Now that we’ve explored the <strong>unit of work</strong> pattern, we could implement one by ourselves. Would that add value to our application? Probably not. If you want to build a custom <strong>unit of work</strong> or a wrapper over EF Core, there are plenty of existing resources to guide you. Unless you want to experiment or need a custom <strong>unit of work</strong> and <strong>repository</strong> (which is possible), I recommend staying away from doing that. Remember: <strong>do only what needs to be done for your program to be correct</strong>.</p>
<blockquote>
<p>Don’t get me wrong when I say <em>do only what needs to be done</em>; wild engineering endeavors and experimentations are a great way to explore, and I encourage you to do so. However, I recommend doing so in parallel so that you can innovate, learn, and possibly even migrate that knowledge to your application later instead of wasting time and breaking things. If you are using Git, creating an experimental branch is a good way of doing this. You can then delete it when your experimentation does not work, merge the branch if it yields positive results, or leave it there as a reference (depending on the team’s policies in place).</p>
</blockquote>
<p>Now that we explored a high-level view of the Repository and Unit of Work patterns, and what those common layers are for, we can continue our journey of using layers.</p>




<h2 data-number="15.4">Abstract layers</h2>
<p>This section looks at abstract layers using an abstract data layer implementation. This type of abstraction can be very useful and is another step closer to <strong>Clean Architecture</strong>. Moreover, you can abstract almost anything this way, which is nothing more than applying the <strong>Dependency Inversion Principle</strong> (<strong>DIP</strong>).Let’s start with some context and the problem:</p>
<ul>
<li>The <strong>domain layer</strong> is where the logic lies.</li>
<li>The <strong>UI</strong> links the user to the <strong>domain</strong>, exposing the features built into that <strong>domain</strong>.</li>
<li>The <strong>data layer</strong> should be an implementation detail that the <strong>domain</strong> blindly uses.</li>
<li>The <strong>data layer</strong> contains the code that knows where the data is stored, which should be irrelevant to the <strong>domain</strong>, but the <strong>domain</strong> directly depends on it.</li>
</ul>
<p>The solution to <strong>break the tight coupling</strong> between the <strong>domain</strong> and the <strong>data</strong> persistence implementations is to create an additional abstract layer, as shown in the following diagram:</p>
<figure>
<img alt="Figure 14.6: Replacing the data (persistence) layer with a data abstraction layer" src="img/file80.png"/><figcaption aria-hidden="true">Figure 14.6: Replacing the data (persistence) layer with a data abstraction layer</figcaption>
</figure>
<p>New rule: <strong>only interfaces and data model classes go into the data abstractions layer</strong>. This new layer now defines our data access API and does nothing but expose a set of interfaces—the contract.Then, <strong>we can create one or more data implementations</strong> based on that abstract layer contract, like using EF Core. The link between the abstractions and implementations is done with dependency injection. The bindings defined in the <strong>composition root</strong> explain the indirect connection between the presentation and the data implementation.The new dependency tree looks like this:</p>
<figure>
<img alt="Figure 14.7: The relationships between layers" src="img/file81.png"/><figcaption aria-hidden="true">Figure 14.7: The relationships between layers</figcaption>
</figure>
<p>The <strong>presentation layer</strong> references a <strong>data implementation layer</strong> for the sole purpose of creating the DI bindings. We need those bindings to inject the correct implementation when creating <strong>domain</strong> classes. Besides, <strong>the presentation layer must not use the data layer’s abstractions or implementations</strong>.I created a sample project that showcases the relationships between the projects and the classes. However, that project would have added pages of code, so I decided not to include it in the book. The most important thing about abstract layers is the dependency flow between the layers, not the code itself.</p>
<blockquote>
<p>The project is available on GitHub (<a href="https://adpg.link/s9HX">https://adpg.link/s9HX</a>).</p>
</blockquote>
<p>In that project, the program injects an instance of the <code>EF.ProductRepository</code> class when a consumer asks for an object that implements the <code>IProductRepository</code> interface. In that case, the consuming class is <code>ProductService</code> and only depends on the <code>IProductRepository</code> interface. The <code>ProductService</code> class is unaware of the implementation itself: it leverages only the interface. The same goes for the program that loads a <code>ProductService</code> class but knows only about the <code>IProductService</code> interface. Here is a visual representation of that dependency tree:</p>
<figure>
<img alt="Figure 14.8: The dependency flow between layers, classes, and interfaces" src="img/file82.png"/><figcaption aria-hidden="true">Figure 14.8: The dependency flow between layers, classes, and interfaces</figcaption>
</figure>
<p>In the preceding diagram, look at how dependencies converge on the <code>Data.Abstract</code> layer. The dependency tree ends up on that abstract data layer.With this applied piece of architectural theory, we are inverting the flow of dependencies on the data layer by following the <strong>DIP</strong>. We also cut out the direct dependency on EF Core, allowing us to implement a new data layer and swap it without impacting the rest of the application or update the implementation without affecting the domain. As I mentioned previously, swapping layers should not happen very often, if ever. Nonetheless, this is an important part of the evolution of layering, and more importantly, we can apply this technique to any layer or project, not just the data layer, so it is imperative to understand how to invert the dependency flow.</p>
<blockquote>
<p>To test the APIs, you can use the Postman collection that comes with the book; visit <a href="https://adpg.link/postman8">https://adpg.link/postman8</a> or GitHub (<a href="https://adpg.link/net8">https://adpg.link/net8</a>) for more info.</p>
</blockquote>
<p>Next, let’s explore sharing and persisting a rich domain model.</p>


<h2 data-number="15.5">Sharing the model</h2>
<p>We have explored strict layering and how to apply the DIP, but we still have multiple models. An alternative to copying models from one layer to another is to share a model between multiple layers, generally as an assembly. Visually, it looks like this:</p>
<figure>
<img alt="Figure 14.9: Sharing a model between all three layers" src="img/file83.png"/><figcaption aria-hidden="true">Figure 14.9: Sharing a model between all three layers</figcaption>
</figure>
<p>Everything has pros and cons, so no matter how much time this can save you at first, it will come back to haunt you and become a pain point later as the project advances and becomes more complex.Suppose you feel that sharing a model is worth it for your application. In that case, I recommend using <strong>view models</strong> or <strong>DTOs</strong> at the presentation level to control and keep the input and output of your application loosely coupled from your model. This way of shielding your lower layers can be represented as follows:</p>
<figure>
<img alt="Figure 14.10: Sharing a model between the domain and data layers" src="img/file84.png"/><figcaption aria-hidden="true">Figure 14.10: Sharing a model between the domain and data layers</figcaption>
</figure>
<p>By doing that, you will save some time initially by sharing your model between your domain and data layers. By hiding that shared model under the presentation layer, you should dodge many problems in the long run, making this a good compromise between quality and development time. Moreover, since your presentation layer shields your application from the outside world, you can refactor your other layers without impacting your consumers.</p>
<blockquote>
<p>This is pretty much how Clean Architecture does it but represented differently. Using that, the model is at the center of the application and is manipulated and persisted. While the layers have different names, the concept remains very similar. More on that later.</p>
</blockquote>
<p><strong>View models</strong> and <strong>DTOs</strong> are key elements to successful programs and developers’ sanity; they should save you many headaches for long-running projects. We revisit and explore the concepts of controlling the input and output later in <em>Chapter 16</em>, <em>Mediator and CQRS Design Patterns</em>, where inputs become <strong>commands</strong> and <strong>queries</strong>.Meanwhile, let’s merge that concept with an abstraction layer. In the previous project, the <strong>data abstraction layer</strong> owned the <strong>data model</strong>, and the <strong>domain layer</strong> owned the <strong>domain model</strong>.In this architectural alternative, we are sharing the model between the two layers. The presentation layer can indirectly use that shared model to dialog with the domain layer without exposing it externally. The objective is to directly persist the <strong>domain model</strong> and skip the copy from the <strong>domain</strong> to the <strong>data layer</strong> while having that data abstraction layer that breaks the tight coupling between the domain logic and the persistence.Here is a visual representation of that:</p>
<figure>
<img alt="Figure 14.11: Diagram representing a shared rich model" src="img/file85.png"/><figcaption aria-hidden="true">Figure 14.11: Diagram representing a shared rich model</figcaption>
</figure>
<p>It is well suited for <strong>rich models,</strong> but we can also do this for anemic models. With a <strong>rich domain model</strong>, you delegate the job of reconstructing the model to the ORM and immediately start calling its methods.The ORM also recreates the anemic model, but those classes just contain data, so you need to call other pieces of the software that contain the logic to manipulate those objects.In the code sample, the <strong>data abstraction layer</strong> now contains only the data access abstractions, such as the repositories, and it references the new <code>Model</code> project that is now the persisted model.Conceptually, it cleans up a few things:</p>
<ul>
<li>The data abstraction layer’s only responsibility is to contain data access abstractions.</li>
<li>The domain layer’s only responsibility is implementing the domain services and the logic that is not part of that rich model.</li>
<li>In the case of an anemic model, the domain layer’s responsibility would be to encapsulate all the domain logic.</li>
<li>The <code>Model</code> project contains the entities.</li>
</ul>
<p>Once again, I skip publishing most of the code here as it is irrelevant to the overall concept. If you think reading the code would help, you can consult and explore the sample on GitHub (<a href="https://adpg.link/9F5C">https://adpg.link/9F5C</a>). Using an IDE to browse the code should help you understand the flow, and as with the abstract layer, the dependencies between the projects, classes, and interfaces are the key to this.Nevertheless, here is the <code>StockService</code> class that uses that shared model so you can peek at some code that directly relates to the explanations:</p>
<div><pre><code>namespace Domain.Services;
public class StockService : IStockService
{
    private readonly IProductRepository _repository;
    public StockService(IProductRepository repository)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
    }</code></pre>
</div>
<p>In the preceding code, we are injecting an implementation of the <code>IProductRepository</code> interface we use in the next two methods. Next, we look at the <code>AddStockAsync</code> method:</p>
<div><pre><code>    public async Task&lt;int&gt; AddStockAsync(int productId, int amount, CancellationToken cancellationToken)
    {
        var product = await _repository.FindByIdAsync(productId, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(productId);
        }
        product.AddStock(amount);
        await _repository.UpdateAsync(product, cancellationToken);
        return product.QuantityInStock;
    }</code></pre>
</div>
<p>The fun starts in the preceding code, which does the following:</p>
<ul>
<li>The repository recreates the product (model) that contains the logic.</li>
<li>It validates that the product exists.</li>
<li>It uses that model and calls the <code>AddStock</code> method (encapsulated domain logic).</li>
<li>It tells the repository to update the product.</li>
<li>It returns the updated product’s <code>QuantityInStock</code> to the consumer of the service.</li>
</ul>
<p>Next, we explore the <code>RemoveStockAsync</code> method:</p>
<div><pre><code>    public async Task&lt;int&gt; RemoveStockAsync(int productId, int amount, CancellationToken cancellationToken)
    {
        var product = await _repository.FindByIdAsync(productId, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(productId);
        }
        product.RemoveStock(amount);
        await _repository.UpdateAsync(product, cancellationToken);
        return product.QuantityInStock;
    }
}</code></pre>
</div>
<p>We applied the same logic as the <code>AddStock</code> method to the <code>RemoveStock</code> method, but it calls the <code>Product.RemoveStock</code> method instead. From the <code>StockService</code> class, we can see the service gating the access to the domain model (the product), fetching and updating the model through the abstract data layer, manipulating the model by calling its methods, and returning domain data (an <code>int</code> in this case, but could be an object).</p>
<blockquote>
<p>This type of design can be either very helpful or undesirable. Too many projects depending on and exposing a shared model can lead to leaking part of that model to consumers, for example exposing properties that shouldn’t be, exposing the whole domain model as output, or the very worst, exposing it as an input and opening exploitable holes and unexpected bugs.</p>
<blockquote>
<p>Be careful not to expose your shared model to the presentation layer consumers.</p>
</blockquote>
</blockquote>
<p>Pushing logic into the model is not always possible or desirable, which is why we are exploring multiple types of domain models and ways to share them. Making a good design is often about options and deciding what option to use for each scenario. There are also tradeoffs to make between flexibility and robustness.The rest of the code is similar to the abstract layer project. Feel free to explore the source code (<a href="https://adpg.link/9F5C">https://adpg.link/9F5C</a>) and compare it with the other projects. The best way to learn is to practice, so play with the samples, add features, update the current features, remove stuff, or even build your own project. Understanding these concepts will help you apply them to different scenarios, sometimes creating unexpected but efficient constructs.Now, let’s look at the final evolution of layering: Clean Architecture.</p>


<h2 data-number="15.6">Clean Architecture</h2>
<p>Now that we’ve covered many layering approaches, it is time to combine them into <strong>Clean Architecture</strong>, also known as Hexagonal Architecture, Onion Architecture, Ports and Adapters, and more. Clean Architecture is an evolution of the layers, a way of organizing the relationships between the layers, yet very similar to what we just built. Instead of presentation, domain, and data (or persistence), Clean Architecture suggests <strong>UI</strong>, <strong>Core</strong>, and <strong>Infrastructure</strong>.As we saw previously, we can design a layer containing abstractions or implementations. When implementations depend only on abstractions, that inverts dependency flow. Clean Architecture emphasizes such layers but with its own guidance about organizing them.We also explored the theoretical concept of breaking layers into smaller ones (or multiple projects), thus creating “fractured layers” that are easier to port and reuse. Clean Architecture leverages that concept at the infrastructure layer level.There are probably as many points of view and variants of this as there are names for it, so I’ll try to be as general as possible while keeping the essence. By doing this, if you are interested in this type of architecture, you can pick a resource and dig deeper into it, following the style you prefer.Let’s take a look at a diagram that resembles what we can find online:</p>
<figure>
<img alt="Figure 14.12: A diagram representing the most basic Clean Architecture layout" src="img/file86.png"/><figcaption aria-hidden="true">Figure 14.12: A diagram representing the most basic Clean Architecture layout</figcaption>
</figure>
<p>From a layering diagram-like standpoint, the preceding diagram could look like this:</p>
<figure>
<img alt="Figure 14.13: A two-layer view of the previous Clean Architecture diagram" src="img/file87.png"/><figcaption aria-hidden="true">Figure 14.13: A two-layer view of the previous Clean Architecture diagram</figcaption>
</figure>
<p>Depending on your chosen method, you can split those layers into multiple other sublayers. One thing that we often see is dividing the <strong>Core</strong> layer into <strong>Entities</strong> and <strong>Use cases</strong>, like this:</p>
<figure>
<img alt="Figure 14.14: Widespread Clean Architecture layout diagram" src="img/file88.png"/><figcaption aria-hidden="true">Figure 14.14: Widespread Clean Architecture layout diagram</figcaption>
</figure>
<p>Since people in the tech industry are creative, there are many names for many things, but the concepts remain the same. From a layering diagram-like standpoint, that diagram could look like this:</p>
<figure>
<img alt="Figure 14.15: A layer-like view of the previous Clean Architecture diagram" src="img/file89.png"/><figcaption aria-hidden="true">Figure 14.15: A layer-like view of the previous Clean Architecture diagram</figcaption>
</figure>
<p>The infrastructure layer is conceptual and can represent multiple projects, such as an infrastructure assembly containing EF Core implementations and a website project representing the web UI. We could also add more projects to the infrastructure layer.The dependency rule of Clean Architecture states that dependencies can only point inward, from the outer layers to the inner layers. This means that abstractions lie inside, and concretions lie outside. Based on the preceding layer-like diagram, inside translates to downward. That means a layer can use any direct or transitive dependencies, which means that infrastructure can depend on use cases and entities.Clean Architecture follows all the principles that we’ve been discussing since the beginning of this book, such as decoupling our implementations using abstractions, dependency inversion, and separation of concerns. These implementations are glued over abstractions using dependency injection (this is not mandatory, but it helps).I’ve always found those circle diagrams a bit confusing, so here is my take on an updated, more linear diagram:</p>
<figure>
<img alt="Figure 14.16: A two-layer view of Clean Architecture’s common elements" src="img/file90.png"/><figcaption aria-hidden="true">Figure 14.16: A two-layer view of Clean Architecture’s common elements</figcaption>
</figure>
<p>Now, let’s revisit our layered application using Clean Architecture, starting with the <strong>core layer</strong>. The core project contains the domain model, the use cases (services), and the interfaces needed to fulfill those use cases. We must not access external resources in this layer: no database calls, disk access, or HTTP requests. This layer contains the interfaces that expose such interaction, but the implementations live in the <strong>infrastructure layer</strong>.The presentation layer was renamed <code>Web</code> and lives in the outer layer with the EF Core implementation. The <code>Web</code> project depends only on the <code>Core</code> project. Once again, since the composition root is in this project, it must load the EF Core implementation project to configure the IoC container.Here is a diagram representing the relation between the shared model and the new Clean Architecture project structure:</p>
<figure>
<img alt="Figure 14.17: From shared project to the Clean Architecture project structure" src="img/file91.png"/><figcaption aria-hidden="true">Figure 14.17: From shared project to the Clean Architecture project structure</figcaption>
</figure>
<p>In the preceding diagram, we took the center of the classic layered solution and merged the layers into a single <code>Core</code> project.</p>
<blockquote>
<p>Here’s the link to this project on GitHub: <a href="https://adpg.link/rT1P">https://adpg.link/rT1P</a>.</p>
</blockquote>
<p>Most of the code is not that relevant since, once again, the most significant aspect is the dependency flow and relationships between projects. Nonetheless, here is a list of changes that I made aside from moving the pieces to different projects:</p>
<ul>
<li>I removed the <code>ProductService</code> class and <code>IProductService</code> interface and used the <code>IProductRepository</code> interface directly from the <code>StockService</code> class (<code>Core</code> project) and the <code>/products</code> endpoint (<code>Web</code> project: <code>Program.cs</code>).</li>
<li>I removed the <code>IStockService</code> interface, and now both the add and remove stocks endpoints (<code>Web</code> project: <code>Program.cs</code>) depend directly on the <code>StockService</code> class.</li>
</ul>
<p>Why use the <code>IProductRepository</code> interface directly, you might wonder? Since the <code>Web</code> project (<strong>infrastructure layer</strong>) depends on the <strong>core layer</strong>, we can leverage the inward dependency flow. It is acceptable to use a repository directly as long as the feature has no business logic. Programming empty shells and pass-through services adds useless complexity. However, when business logic starts to be involved, create a service or any other domain entity you deem necessary for that scenario. Don’t pack business logic into your controllers or minimal API delegates.I removed the <code>IStockService</code> interface since the <code>StockService</code> class contains concrete business rules that can be consumed as is from the infrastructure layer. I know we have emphasized using interfaces since the beginning of the book, but I also often said that principles are not laws. All in all, there is nothing to abstract away: if the business rules change, the old ones won’t be needed anymore. On the other hand, we could have kept the interface.To wrap this up, Clean Architecture is a proven pattern for building applications that is fundamentally an evolution of layering. Many variants can help you manage use cases, entities, and infrastructure; however, we will not cover those here. There are many open-source projects to start with Clean Architecture if you seek organizational guidance.</p>
<blockquote>
<p>I left a few links in the <em>Further reading</em> section.</p>
</blockquote>
<p>If you think this is a great fit for you, your team, your project, or your organization, feel free to dig deeper and adopt this pattern. In subsequent chapters, we explore some patterns, such as CQRS, Publish-Subscribe, and feature-based design, which we can combine with Clean Architecture to add flexibility and robustness. These become particularly useful as your system grows in size and complexity.</p>


<h2 data-number="15.7">Implementing layering in real life</h2>
<p>Now that we covered all of this, it is important to note that on the one hand, there is the theory, and on the other, life is hitting you in the face. Suppose you are working in a big enterprise. In that case, chances are your employer can pour hundreds of thousands or even millions of dollars into a feature to run experiments, spend months designing every little piece, and ensure everything is perfect. Even then, is achieving perfection even possible? Probably not.For companies that don’t have that type of capital, you must build entire products for a few thousand dollars sometimes because they are not trying to resell them but just need that tool built. That is where your architectural skills come in handy. How do you design the least-worst product in a maintainable fashion while meeting stakeholders' expectations? The most important part of the answer is to set expectations upfront. Moreover, never forget that someone needs to maintain and change the software over time; no software does not evolve; there’s always something.</p>
<blockquote>
<p>If you are in a position where you must evaluate the feasibility of products and features in this context, setting expectations lower can be a good way to plan for the unplannable. It is easier to overdeliver than justify why you underdelivered.</p>
</blockquote>
<p>Let’s dig deeper into this and look at a few tricks to help you out. Even if you are working for a larger enterprise, you should get something out of it.</p>

<h3 data-number="15.7.1">To be or not to be a purist?</h3>
<p>In your day-to-day work, you may not always need the rigidity of a <strong>domain layer</strong> to create a wall in front of your data. Maybe you just don’t have the time or the money, or it’s just not worth doing.Taking and presenting the data can often work well enough, especially for simple data-driven applications that are only a user interface over a database, as is the case for many internal tools.The answer to the <em>“To be or not to be a purist?”</em> question is: it depends!</p>
<blockquote>
<p>This section covers layering, but we explore other patterns that are feature-oriented, so I suggest you continue reading and explore using the techniques from <em>Chapter 17</em>, <em>Vertical Slice Architecture</em>, <em>Chapter 18</em>, <em>Request-EndPoint-Response (REPR)</em>, and <em>Chapter 20</em>, <em>Modular Monolith</em>, to improve your design while keeping the design overhead low.</p>
</blockquote>
<p>Here are a few examples of things that the answer depends on, to help you out:</p>
<ul>
<li>The project; for example:
<ul>
<li><strong>Domain-heavy or logic-intensive projects</strong> will benefit from a domain layer, helping you centralize parts for an augmented level of reusability and maintainability.</li>
<li><strong>Data management projects</strong> tend to have less or no logic in them. We can often build them without adding a domain layer as the <strong>domain</strong> is often only a tunnel from the <strong>presentation</strong> to the <strong>data</strong>; a pass-through layer. We can often simplify those systems by dividing them into two layers: <strong>data</strong> and <strong>presentation</strong>.</li>
</ul></li>
<li>Your team; for example, a highly skilled team may tend to use advanced concepts and patterns more efficiently, and the learning curve for newcomers should be easier due to the number of seasoned engineers that can support them on the team. This does not mean that less skilled teams should aim lower; on the contrary, it may just be harder or take longer to start. Analyze each project individually and find the best patterns to drive them accordingly.</li>
<li>Your boss; if the company you work for puts pressure on you and your team to deliver complex applications in record time and nobody tells your boss that it is impossible, you may need to cut corners a lot and enjoy many maintenance headaches with crashing systems, painful deployments, and more. That being said, if it is inevitable for these types of projects, I’d go with a very simple design that does not aim at reusability—aim at low-to-average testability and code stuff that just works.</li>
<li>Your budget; once again, this often depends on the people selling the application and the features. I saw promises that were impossible to keep but delivered anyway with a lot of effort, extra hours, and corner-cutting. The thing to remember when going down that path is that at some point, there is no return from the accumulated <strong>technical debt</strong>, and it will just get worse (this applies to all budgets).</li>
<li>The audience; the people who use the software can make a big difference to how you build it: ask them. For example, suppose you are building a tool for your fellow developers. In that case, you can cut corners that you would not for less technically skilled users (like delivering a CLI tool instead of a full-blown user interface). On the other hand, if you’re aiming your application at multiple clients (web, mobile, and so on), isolating your application’s components and focusing on reusability could be a winning design.</li>
<li>The expected quality; you should not tackle the problem in the same way for building a prototype and a SaaS application. It is acceptable, even encouraged, for a prototype to have no tests and not follow best practices, but I’d recommend the opposite for a production-quality application.</li>
<li>Any other things that life throws at you; yes, life is unpredictable, and no one can cover every possible scenario in a book, so just keep the following in mind when building your next piece of software:
<ul>
<li>Do not over-engineer your applications.</li>
<li>Only implement features that you need, not more, as per the <strong>you aren’t gonna need it</strong> (<strong>YAGNI</strong>) <strong/> principle.</li>
<li>Use your judgment and take the less-worst options; there is no perfect solution.</li>
</ul></li>
</ul>
<p>I hope you found this guidance helpful and that it will serve you in your career.</p>


<h3 data-number="15.7.2">Building a façade over a database</h3>
<p>Data-driven programs are a type of software that I often see in smaller enterprises. Those companies need to support their day-to-day operations with computers, not the other way around. Every company needs internal tools, and many needed them yesterday.The reason is simple; every company is unique. Because it’s unique, due to its business model, leadership, or employees, it also needs unique tools to help with its day-to-day operations. Those small tools are often simple user interfaces over a database, controlling access to that data. In these cases, you don’t need over-engineered solutions, as long as everyone is informed that the tool will not evolve beyond what it is: a small tool.In real life, this one is tough to explain to non-programmers because they tend to see complex use cases as easy to implement and simple use cases as hard to implement. It’s normal; they just don’t know, and we all don’t know something. In these scenarios, a big part of our job is also to educate people. Advising decision-makers about the differences in quality between a small tool and a large business application. Educating and working with stakeholders makes them aware of the situation and make decisions with you, leading to higher project quality that meets everyone’s expectations. This can also reduce the “<em>it’s not my fault</em>” syndrome from both sides.I’ve found that immersing customers and decision-makers in the decision process and having them follow the development cycle helps them understand the reality behind the programs and helps both sides stay happy and grow more satisfied. Stakeholders not getting what they want is no better than you being super stressed over unreachable deadlines.That said, our educational role does not end with decision-makers. Teaching new tools and techniques to your peers is also a major way to improve your team, peers, and yourself. Explaining concepts is not always as easy as it sounds.Nevertheless, data-driven programs may be hard to avoid, especially if you are working for SMEs, so try to get the best out of it. Nowadays, with low-code and no-code solutions and all the open-source libraries, you might be able to save yourself a lot of this kind of trouble, but maybe not all.</p>
<blockquote>
<p>Remember that someday, someone must maintain those small tools. Think of that person as you, and think about how you’d like some guidelines or documentation to help you. I’m not saying to over-document projects, as documentation often gets out of sync with the code and becomes more of a problem than a solution. However, a simple <code>README.md</code> file at the project's root explaining how to build and run the program and some general guidelines could be beneficial. Always think about documentation as if you were the one reading it. Most people don’t like to spend hours reading documentation to understand something simple, so keep it simple.</p>
</blockquote>
<p>When building a <em>façade over a database</em>, you want to keep it simple. Also, you should make it clear that it should not evolve past that role. One way to build this would be to use EF Core as your data layer and scaffold an MVC application as your presentation layer, shielding your database. You can use the built-in ASP.NET Core authentication and authorization mechanism if you need access control. You can then choose role-based or policy-based access control or any other way that makes sense for your tool and allows you to control access to the data the way you need to.</p>
<blockquote>
<p>Keeping it simple should help you build more tools in less time, making everyone happy.</p>
</blockquote>
<p>From a layering standpoint, using my previous example, you will end up having two layers sharing the data model:</p>
<figure>
<img alt="Figure 14.18: A façade-like presentation layer over a database application’s design" src="img/file92.png"/><figcaption aria-hidden="true">Figure 14.18: A façade-like presentation layer over a database application’s design</figcaption>
</figure>
<p>Nothing stops you from creating a <strong>view model</strong> here and there for more complex views, but the key is to keep the logic’s complexity to a minimum. Otherwise, you may discover the hard way that sometimes, rewriting a program from scratch takes less time than trying to fix it. Moreover, nothing stops you from using any other presentation tools and components available to you.Using this data-driven architecture as a temporary application while the main application is in development is also a good solution. It takes a fraction of the time to build, and the users have access to it immediately. You can even get feedback from it, which allows you to fix any mistakes before they are implemented in the real (future) application, working like a living prototype.</p>
<blockquote>
<p>A good database design in these sorts of applications can go a long way.</p>
</blockquote>
<p>Not all projects are that simple, but still, many are; the key is to make the program good enough while ensuring you cut the right corners. The presentation layer in these types of applications could leverage a low-code solution such as Power Apps, for example.</p>



<h2 data-number="15.8">Summary</h2>
<p>Layering is one of the most used architectural techniques when it comes to designing applications. An application is often split into multiple different layers, each managing a single responsibility. The three most popular layers are <strong>presentation</strong>, <strong>domain</strong>, and <strong>data</strong>. You are not limited to three layers; you can split each into smaller layers (or smaller pieces inside the same conceptual layer), leading to composable, manageable, and maintainable applications.Moreover, you can create abstraction layers to invert the flow of dependency and separate interfaces from implementations, as we saw in the <em>Abstract layers</em> section. You can persist the domain entities directly or create an independent model for the data layer. You can also use an anemic model (no logic or method) or a rich model (packed with entity-related logic). You can share that model between multiple layers or have each layer possess its own.Out of layering was born Clean Architecture, which guides organizing your application into concentric layers, often dividing the application into use cases.Let’s see how this approach can help us move toward the <strong>SOLID</strong> principles at app scale:</p>
<ul>
<li><strong>S</strong>: Layering leads us toward splitting responsibilities horizontally, with each layer oriented around a single macro-concern. The main goal of layering is responsibility segregation.</li>
<li><strong>O</strong>: Abstract layers enable consumers to act differently (change behaviors) based on the provided implementation (concrete layer).</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: Splitting layers based on features (or cohesive groups of features) is a way of segregating a system into smaller blocks (interfaces).</li>
<li><strong>D</strong>: Abstraction layers lead directly to the dependency flow’s inversion, while classic layering leads in the opposite direction.</li>
</ul>
<p>In the next chapter, we learn how to centralize the logic of copying objects (models) using object mappers and an open-source tool to help us skip the implementation, also known as productive laziness.</p>


<h2 data-number="15.9">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>When creating a layered application, is it true that we must have presentation, domain, and data layers?</li>
<li>Is a rich domain model better than an anemic domain model?</li>
<li>Does EF Core implement the Repository and Unit of Work patterns?</li>
<li>Do we need to use an ORM in the data layer?</li>
<li>Can a layer in Clean Architecture access any inward layers?</li>
</ol>


<h2 data-number="15.10">Further reading</h2>
<p>Here are a few links to help you build on what we learned in this chapter:</p>
<ul>
<li><strong>Dapper</strong> is a simple yet powerful ORM for .NET, made by the people of Stack Overflow. If you like writing SQL, but don’t like mapping data to objects, this ORM might be for you: <a href="https://adpg.link/pTYs">https://adpg.link/pTYs</a>.</li>
<li>An article that I wrote in 2017, talking about the Repository pattern; that is, « Design Patterns: ASP.NET Core Web API, services, and repositories | Part 5: Repositories, the ClanRepository, and integration testing »: <a href="https://adpg.link/D53Z">https://adpg.link/D53Z</a>.</li>
<li>Entity Framework Core – Using Transactions: <a href="https://adpg.link/gxwD">https://adpg.link/gxwD</a>.</li>
<li>Here are resources about Clean Architecture:
<ul>
<li>Common web application architectures (Microsoft Learn): <a href="https://adpg.link/Pnpn">https://adpg.link/Pnpn</a></li>
<li>Microsoft eShopOnWeb ASP.NET Core Reference Application: <a href="https://adpg.link/dsw1">https://adpg.link/dsw1</a></li>
<li>GitHub—Clean Architecture (Ardalis/Steve Smith)—Solution templates: <a href="https://adpg.link/tpPi">https://adpg.link/tpPi</a></li>
<li>GitHub—Clean Architecture (Jason Taylor)—Solution templates: <a href="https://adpg.link/jxX2">https://adpg.link/jxX2</a></li>
</ul></li>
</ul>


<h2 data-number="15.11">Answers</h2>
<ol>
<li>No, you can have as many layers as you need and name and organize them as you want.</li>
<li>No, both have their place, their pros, and their cons.</li>
<li>Yes. A <code>DbContext</code> is an implementation of the Unit of Work pattern. <code>DbSet&lt;T&gt;</code> is an implementation of the Repository pattern.</li>
<li>No, you can query any system in any way you want. For example, you could use ADO.NET to query a relational database, manually create the objects using a <code>DataReader</code>, track changes using a <code>DataSet</code>, or do anything else that fits your needs. Nonetheless, ORMs can be very convenient.</li>
<li>Yes. A layer can never access outward layers, only inward ones.</li>
</ol>


</body>
</html>
