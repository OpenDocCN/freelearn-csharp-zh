<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Lightweight Concurrency &#x2013; Task Parallel Library (TPL)"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Lightweight Concurrency – Task Parallel Library (TPL)</h1></div></div></div><p>In .NET 4.0, Microsoft delivered what is called the <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>) and answered users' concerns by developing multithreaded applications. TPL allows developers to focus on the functionality that they are trying to <a id="id289" class="indexterm"/>implement and not get bogged down with managing multiple threads, the threadpool, and the number of processing cores available to them.</p><p>So far, we have covered the <code class="literal">BackgroundWorker</code> component and the <code class="literal">Thread</code> class to show ways to accomplish multithreaded functionality in a C#/.NET application. These two ways to perform multithreaded functionality have been around since the very early stages of .NET. The <code class="literal">Thread</code> class was introduced in Version 1.1 of .NET and the <code class="literal">BackgroundWorker</code> in Version 2.0 of .NET. We classify these methods as heavyweight concurrency because they take quite a bit of work from the developer and add to the complexity of the code's design. The developer has to manage the different threads, and to achieve maximum performance, determine the number of processing cores in a machine.</p><p>After completing this chapter you will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Have a complete understanding of the Task Parallel Library and the different classes that make it up</li><li class="listitem" style="list-style-type: disc">Understand how to create and use the <code class="literal">Task</code> class</li><li class="listitem" style="list-style-type: disc">Understand how tasks are managed in .NET and the threadpool</li><li class="listitem" style="list-style-type: disc">Understand the <code class="literal">Parallel</code> class and how to start tasks using it</li><li class="listitem" style="list-style-type: disc">Know the evolution of multithreading from heavyweight to lightweight concurrency</li><li class="listitem" style="list-style-type: disc">Learn when to use tasks instead of <code class="literal">Threads</code></li><li class="listitem" style="list-style-type: disc">Understand task parallelism versus data parallelism</li><li class="listitem" style="list-style-type: disc">Understand concurrent data collection and concurrent data processing</li></ul></div><div class="section" title="Task Parallel Library"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Task Parallel Library</h1></div></div></div><p>The Task Parallel <a id="id290" class="indexterm"/>Library was introduced as part of .NET with the release of Version 4.0. Originally, it was developed under the name Parallel Extensions, which was a joint effort by Microsoft Research and the CLR team. Parallel Extensions consisted of the TPL and <a id="id291" class="indexterm"/>
<span class="strong"><strong>Parallel LINQ</strong></span> (<span class="strong"><strong>PLINQ</strong></span>), which we will cover in a later chapter. TPL is now preferred over threads and <code class="literal">BackgroundWorker</code> components to develop multithreaded applications.</p><p>The idea was to create a managed concurrency library to take the multithreaded capabilities of .NET to the next level. TPL consists of a set of APIs and public types located in the <code class="literal">System.Threading</code> and <code class="literal">System.Threading.Tasks</code> namespaces.</p><p>One of the advantages of using TPL over threads is that .NET can dynamically scale an application to most effectively use the processing cores of the hardware it is running. .NET is smart enough to determine the number of processing cores in a machine and manage the <code class="literal">ThreadPool</code> appropriately. When programming with threads directly, the developer has to handle this work. No longer does the developer have to determine the number of cores and corresponding threads created to achieve maximum performance. If you remember our earlier examples with threads and <code class="literal">BackgroundWorker</code> components, we had to do this in code.</p><p>TPL also manages the <code class="literal">ThreadPool</code> for us. It handles scheduling of threads, cancelation of threads, and state management. This managed <code class="literal">ThreadPool</code> allows .NET to have a higher degree of intelligence in managing tasks versus threads. The <code class="literal">Task.Factory</code> class can be told if a task is a long running one that is not CPU-intensive versus a CPU-intensive task. With this information, it can be managed by the <code class="literal">ThreadPool</code> to create a single thread per core (CPU-intensive tasks) or multiple threads per core (long running tasks that wait on other resources). This is the logic that previously needed to be handled by the developer. Now .NET does it for you.</p><p>Next, we will examine the center of the TPL, the <code class="literal">Task</code> class.</p></div></div>
<div class="section" title="Exploring tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Exploring tasks</h1></div></div></div><p>The Task class <a id="id292" class="indexterm"/>represents some work that can be done atomically in an asynchronous manner. It is an item of work executed and managed on the <code class="literal">ThreadPool</code> by the TPL. It is very similar to a thread but with a higher level of abstraction and functionality built around it. It is the central control of the Task Parallel Library.</p><p>The <code class="literal">Task</code> class has a complete set of methods for status updates, cancelation, exception handling, scheduling, and waiting that allows it to be "lightweight" compared to the thread. It can also make more efficient use of system resources given the functionality that the TPL provides to manage the <code class="literal">ThreadPool</code> behind the scenes.</p><p>Let's start by creating and executing a task. First, we will create a couple of methods that will represent the work to be done. Then we will execute this work using tasks. There are two main ways to accomplish this: <code class="literal">Parallel.Invoke</code> and <code class="literal">Task.Factory.StartNew</code>. Let's take a look at each. We will start with tasks that do not return a value. The next section will look at ways to run tasks that return values.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>How to do it</h2></div></div></div><p>We will start by creating a new console application using Visual Studio 2013. We will name our application, <code class="literal">TaskExample</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will add two <code class="literal">using</code> statements to the <code class="literal">Program.cs</code> file to allow us to work with the TPL classes.<div class="informalexample"><pre class="programlisting">using System.Threading;
using System.Threading.Tasks;</pre></div></li><li class="listitem">Next, let's define <a id="id293" class="indexterm"/>three different <code class="literal">static</code> methods that will represent the work done by three tasks: <code class="literal">WriteNumbers</code>, <code class="literal">WriteWords</code>, and <code class="literal">WriteColors</code>. One will loop through the first 20 numbers and write each one to the console. The other will loop through a sentence and write each word to the console. The final one will loop through an array of colors and write each color to the console. Now, add the following three methods to your <code class="literal">Program.cs</code> file:<div class="informalexample"><pre class="programlisting">        static void WriteNumbers()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Thread 1";

            for (int i = 0; i &lt; 20; i++)
            {
Console.WriteLine("Thread name {0}, Number: {1}", Thread.CurrentThread.Name, i);
                Thread.Sleep(2000);
            }
        }

        static void WriteWords()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Thread 2";

            String localString = "This is an example for using tasks";
            String[] localWords = localString.Split(' ');
            foreach (String s in localWords)
            {
Console.WriteLine("Thread name {0}, Word: {1}", Thread.CurrentThread.Name, s);
                Thread.Sleep(2000);
            }

        }

        static void WriteColors()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Thread 3";

String[] localColors = {"red", "orange", "blue", "green", "yellow", "white", "black"};
            foreach (String s in localColors)
            {
Console.WriteLine("Thread name {0}, Colors: {1}",Thread.CurrentThread.Name, s);
                Thread.Sleep(2000);
            }
        } </pre></div></li><li class="listitem">Finally, we will <a id="id294" class="indexterm"/>add code to run each method as a task:<div class="informalexample"><pre class="programlisting">            //Create the 3 Tasks.
            Task t1 = new Task(() =&gt; WriteNumbers());
            Task t2 = new Task(() =&gt; WriteWords());
            Task t3 = new Task(() =&gt; WriteColors());

            //Run the 3 Tasks.
            t1.Start();
            t2.Start();
            t3.Start();

            Console.ReadLine();</pre></div></li><li class="listitem">Now, compile and run the application and you should see a console window that looks something like this:<div class="mediaobject"><img src="graphics/8321EN_05_01.jpg" alt="How to do it"/></div><p>This is a simple example, but allows you to see the three tasks run in separate threads with each executing a different method. You can see the thread name <a id="id295" class="indexterm"/>of each task and you will notice that the threads do not always run concurrently in sequence.</p></li><li class="listitem">Now, let's replace the code in the <code class="literal">Main</code> method with the following code:<div class="informalexample"><pre class="programlisting">            //Create the 3 Tasks.
            //Task t1 = new Task(() =&gt; WriteNumbers());
            //Task t2 = new Task(() =&gt; WriteWords());
            //Task t3 = new Task(() =&gt; WriteColors());

            //Run the 3 Tasks.
            //t1.Start();
            //t2.Start();
            //t3.Start();
            Parallel.Invoke
            (
                new Action(WriteNumbers),
                new Action(WriteWords),
                new Action(WriteColors)
            );
     Console.ReadLine();</pre></div></li><li class="listitem">Now, rebuild and <a id="id296" class="indexterm"/>run the application again. You should see an identical or almost identical result.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The reason the results may be different is because the three methods are being run in three separate threads on three separate cores. So, depending on performance and other items running on your computer, the three tasks can run with different timings, as a result of which the console output can be in a different order.</p></div></div></li></ol></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>How it works</h2></div></div></div><p>In the previous exercise, you learned two ways to use the <code class="literal">Task</code> class to implement functionality in a separate thread. These examples take methods that do not return a value and instantiate a <code class="literal">Task</code> class to execute the methods.</p><p>The <code class="literal">Task</code> constructor takes an <code class="literal">Action</code> delegate:</p><div class="informalexample"><pre class="programlisting">public delegate void Action&lt;in T&gt;(
   T obj
)</pre></div><p>We use a lambda expression to define the <code class="literal">Action</code> delegate, which encapsulates a method to be performed. Later in this chapter, we will define delegates and lambdas in more detail.</p><p>First, we used the <code class="literal">Task.Start()</code> method to execute the task. This puts the task on the <code class="literal">ThreadPool</code> and lets .NET manage the execution of it. To instantiate the <code class="literal">Task</code> class, we used a lambda expression in the constructor.</p><p>In the second example, we used another class in the TPL and ran the tasks using the <code class="literal">Parallel.Invoke()</code> method. Here, we were able to put all three tasks on the <code class="literal">ThreadPool</code> at once by using this method and the <code class="literal">Action</code> class.</p><p>We use the <code class="literal">Console.ReadLine()</code> command to just hold the command window open after the execution of the threads has completed. This allows us to study the results and control the closing of the <a id="id297" class="indexterm"/>window. To close the window, simply press the <span class="emphasis"><em>Enter</em></span> key; this will complete the <code class="literal">ReadLine</code> statement. The console is waiting to read a line of input.</p></div></div>
<div class="section" title="Tasks with return values"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Tasks with return values</h1></div></div></div><p>Now, we will <a id="id298" class="indexterm"/>take a look at how to start a task that returns a value. In <a id="id299" class="indexterm"/>most cases, if we care about the result of a task or if a task does some work to be consumed by the rest of the program, then we will want the task to return some values for us to use. We will demonstrate this by developing a simple console application that starts three tasks and then prints the return values of these three tasks.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec55"/>How to do it</h2></div></div></div><p>We will start by creating a new console application using Visual Studio 2013. We will name our application, <code class="literal">TaskExampleWithReturnValues</code>.</p><p>Next, place the following code in the <code class="literal">Program</code> class of <code class="literal">Program.cs</code>:</p><div class="informalexample"><pre class="programlisting">class Program
    {
        static void Main(string[] args)
        {
            //Create the 3 Tasks.
            Task&lt;String&gt; t1 = new Task&lt;String&gt;(() =&gt; WriteNumbers());
            Task&lt;String&gt; t2 = new Task&lt;String&gt;(() =&gt; WriteWords());
            Task&lt;String&gt; t3 = new Task&lt;String&gt;(() =&gt; WriteColors());

            //Run the 3 Tasks.
            t1.Start();
            t2.Start();
            t3.Start();

            Console.WriteLine(t1.Result);
            Console.WriteLine(t2.Result);
            Console.WriteLine(t3.Result);

            Console.ReadLine();

        }

        static String WriteNumbers()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Task 1";

            for (int i = 0; i &lt; 20; i++)
            {
Console.WriteLine("Thread name {0}, Number: {1}",Thread.CurrentThread.Name, i);
                Thread.Sleep(2000);
            }

return String.Format("This Task has completed - {0}", Thread.CurrentThread.Name);
        }

        static String WriteWords()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Task 2";

            String localString = "This is an example for using tasks";
            String[] localWords = localString.Split(' ');
            foreach (String s in localWords)
            {
Console.WriteLine("Thread name {0}, Word: {1}", Thread.CurrentThread.Name, s);
                Thread.Sleep(2000);
            }

return String.Format("This Task has completed - {0}", Thread.CurrentThread.Name);
        }

        static String WriteColors()
        {
            //Set thread name.
            Thread.CurrentThread.Name = "Task 3";

String[] localColors = { "red", "orange", "blue", "green", "yellow", "white", "black" };
            foreach (String s in localColors)
            {
Console.WriteLine("Thread name {0}, Colors: {1}",Thread.CurrentThread.Name, s);
                Thread.Sleep(2000);
            }

return String.Format("This Task has completed - {0}", Thread.CurrentThread.Name);
        }
    }</pre></div><p>Finally, let's build <a id="id300" class="indexterm"/>and run our application. Your console window should <a id="id301" class="indexterm"/>look like this:</p><div class="mediaobject"><img src="graphics/8321EN_05_02.jpg" alt="How to do it"/></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec56"/>How it works</h2></div></div></div><p>In this example, we use the <code class="literal">Task&lt;TResult&gt;</code> version of the <code class="literal">Task</code> class, which allows us to specify a return object from the task when it has completed execution. The return value will be placed in the <code class="literal">Task.Result</code> property and will be of the type you define in the declaration. So, in the following line of code, we tell .NET to create an object of type <code class="literal">Task</code> that will execute the <code class="literal">WriteNumbers()</code> method and return a <code class="literal">String</code> value:</p><div class="informalexample"><pre class="programlisting">Task&lt;String&gt; t1 = new Task&lt;String&gt;(() =&gt; WriteNumbers());</pre></div><p>This is very helpful because it allows us to return any object type.</p><p>By using the line <code class="literal">Console.WriteLine(t1.Result);</code>, we automatically tell .NET to block or halt the main thread and wait on the <code class="literal">t1</code> task to complete and return the value <code class="literal">t1.Result</code>. .NET is smart enough to know that we want to wait until a value is present before executing this statement. Otherwise, if it is executed immediately, the value may or may not be there. If it was not there, we would get a null reference error. This is another way to say that <a id="id302" class="indexterm"/>using TPL is easier than using threads. The TPL API handles these details for you, the developer, managing it in the code itself.</p><p>Also, in each method, we set the current thread name, so in our output, we can see that each of the three tasks operate in a different thread.</p><p>Next, we will examine the <a id="id303" class="indexterm"/>API in TPL that allows us to use concurrent collections.</p></div></div>
<div class="section" title="Concurrent collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Concurrent collections</h1></div></div></div><p>Another <a id="id304" class="indexterm"/>namespace that was introduced in .NET 4.0 is <code class="literal">Systems.Collections.Concurrent</code>. This is not directly a part of TPL, but it is often used in conjunction with TPL to provide much of the common parallel design patterns such as producer-consumer that we will discuss in <a class="link" href="ch09.html" title="Chapter 9. Pipeline and Producer-consumer Design Patterns">Chapter 9</a>, <span class="emphasis"><em>Pipeline and Producer-consumer Design Patterns</em></span>.</p><p>
<code class="literal">System.Collections.Concurrent</code> provides a thread-safe version of collection classes in the <a id="id305" class="indexterm"/>
<code class="literal">Systems.Collections</code> namespace. These work very well in conjunction with tasks. This namespace has <code class="literal">ConcurrentBag</code>, which is a collection of objects such as <code class="literal">ConcurrentDictionary</code>, <code class="literal">ConcurrentQueue</code>, <code class="literal">ConcurrentStack</code>, and <code class="literal">BlockingCollection</code> to name the most popular ones.</p><p>All of these concurrent collections implement interfaces for the underlying collection. This essentially wraps the collection and provides a thread-safety mechanism. This is handy for the multithreaded developer because you can use them and not have to design thread-safe logic around them.</p><p>In this section, we will look at the <code class="literal">ConcurrentQueue</code> class and show an example of how to use this with tasks to perform a simple multithreaded example. This will demonstrate the power and simplicity that TPL provides for multithreaded processing. We do not have to worry about locking resources to make them thread-safe. We do not have to worry about the number of processing cores on our hardware. We do not have to worry about race conditions between variables. And we do not have to worry about using global variables in a class to provide thread-safety. All of this is handled for us with the classes. We just have to worry about the logic.</p><p>Having a set of thread-safe collections to be used by many threads makes multithreaded design easy. Notice how fewer things we have to account for than our previous examples. Before we divided up work, we had to know the number of cores to create a thread for. This is handled by <code class="literal">Task</code> and <code class="literal">ThreadPool</code> now. </p><p>We had to divide our dataset into chunks and give each thread a known chunk of the data (that is, in the image-processing example, each thread got a distinct section of the image). Also, we had to come back in the end and reassemble the results from each thread. We no longer have to worry about these three concerns.</p><p>In this project, we will take a list of numbers from 0 to 5000 (that is, 0 + 1 + 2 + 3 + 4 and so on) and sum them up by three different threads. We will not give each thread a range to sum then add the results from the three, like before. We will just use a <code class="literal">ConcurrentQueue</code> <a id="id306" class="indexterm"/>collection with the 5000 numbers in queue and have each of the three threads remove items, sum them up, and add the sum to the overall total.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>How to do it</h2></div></div></div><p>Let's open Visual Studio and create a new console application project named <code class="literal">ConcurrentCollection</code>; then perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Place the following code in the <code class="literal">Program.cs</code> file:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

class ConcurrentCollection
{ 
    static void Main()
    {
        ConcurrentQueue&lt;int&gt; queue = new ConcurrentQueue&lt;int&gt;();

        //Sum of a single thread adding the numbers as we queue them.
        int SingleThreadSum = 0;

        // Populate the queue. 
        for (int i = 0; i &lt; 5000; i++)
        {
            SingleThreadSum += i;
            queue.Enqueue(i);
        }

        //Print the Sum of 0 to 5000.
        Console.WriteLine("Single Thread Sum = {0}", SingleThreadSum);

        //Sum of a multithread adding of the numbers.
        int MultiThreadSum = 0;

        //Create an Action delegate to dequeue items and sum them.
        Action localAction = () =&gt;
        {
            int localSum = 0;
            int localValue;

            while (queue.TryDequeue(out localValue)) localSum += localValue;

            Interlocked.Add(ref MultiThreadSum, localSum);
        };

        // Run 3 concurrent Tasks.
        Parallel.Invoke(localAction, localAction, localAction);

        //Print the Sum of 0 to 5000 done by 3 separate threads.
        Console.WriteLine("MultiThreaded  Sum = {0}", MultiThreadSum);

        Console.ReadLine();
    }
}</pre></div></li><li class="listitem">Now, let's <a id="id307" class="indexterm"/>build and run the application. What do you think the results will be? They should look like the following output:<div class="mediaobject"><img src="graphics/8321EN_05_03.jpg" alt="How to do it"/></div></li></ol></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>How it works</h2></div></div></div><p>In this program, we declare a <code class="literal">ConcurrentQueue</code> object using the following statement:</p><div class="informalexample"><pre class="programlisting">ConcurrentQueue&lt;int&gt; queue = new ConcurrentQueue&lt;int&gt;();</pre></div><p>Then we place into the queue the numbers from 1 to 5000 using the following loop:</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 5000; i++)
        {
            SingleThreadSum += i;
            queue.Enqueue(i);
        }</pre></div><p>Next, we start three parallel tasks that each dequeue items from the queue without having to lock the queue to <a id="id308" class="indexterm"/>protect thread-safety because it is a concurrent queue. They use the following command to take all the items out of the queue:</p><div class="informalexample"><pre class="programlisting">queue.TryDequeue(out localValue)) localSum += localValue;</pre></div><p>By using this <code class="literal">ConcurrentQueue</code> object, .NET handles all of the thread-safety issues and allows all three tasks to just focus on the work to be performed. They all then add their local sums to the <code class="literal">MultiThreadSum</code> value. But notice that this value needs to be locked because it is not thread-safe by default, since three separate tasks are all trying to add to it in parallel.</p><p>So, in the end, no matter how the three independent tasks run, the <code class="literal">MultiThreadSum</code> will always be the same <a id="id309" class="indexterm"/>because each number between 1 and 5000 is taken from the queue only once and added to the overall sum.</p></div></div>
<div class="section" title="Exploring the TaskFactory class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Exploring the TaskFactory class</h1></div></div></div><p>A key class of the <a id="id310" class="indexterm"/>TPL in the <code class="literal">System.Threading.Tasks</code> namespace is the <code class="literal">TaskFactory</code> class. <code class="literal">TaskFactory</code> is used in the creation and scheduling of tasks. The <code class="literal">TaskFactory</code> class has a number of methods that make scheduling and managing tasks very easy. These include starting and continuing methods as well as a series of methods that conform to the asynchronous programming model that we will cover in <a class="link" href="ch11.html" title="Chapter 11. The Asynchronous Programming Model">Chapter 11</a>, <span class="emphasis"><em>The Asynchronous Programming Model</em></span>. Essentially, this class wraps many of the common task design patterns into methods for ease of use and development. This is yet another way that TPL makes multithreaded development "lightweight".</p><p>Most of our work with <code class="literal">TaskFactory</code> will be covered in <a class="link" href="ch06.html" title="Chapter 6. Task-based Parallelism">Chapter 6</a>, <span class="emphasis"><em>Task-based Parallelism</em></span>, and <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <span class="emphasis"><em>Data Parallelism</em></span>, and then again in <a class="link" href="ch11.html" title="Chapter 11. The Asynchronous Programming Model">Chapter 11</a>, <span class="emphasis"><em>The Asynchronous Programming Model</em></span>. But in this chapter, we will perform a simple example to demonstrate how they are used.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>How to do it</h2></div></div></div><p>Let's start by opening up Visual Studio and creating a new console application named <code class="literal">TaskFactoryExample</code>. Now, let's add the following code to our <code class="literal">Program.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace TaskFactoryExample
{
    class TaskFactoryExample
    {

        static TaskFactory TF = new TaskFactory(TaskScheduler.Default);

        static void Main(string[] args)
        {
            List&lt;Task&gt; tasklist = new List&lt;Task&gt;();

            tasklist.Add(TF.StartNew(() =&gt; Worker("Task 1"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default));
            tasklist.Add(TF.StartNew(() =&gt; Worker("Task 2"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default));
            tasklist.Add(TF.StartNew(() =&gt; Worker("Task 3"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default));
            tasklist.Add(TF.StartNew(() =&gt; Worker("Task 4"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default));
            tasklist.Add(TF.StartNew(() =&gt; Worker("Task 5"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default));



            //wait for all tasks to complete.
            Task.WaitAll(tasklist.ToArray());

            //Wait for input before ending program.
            Console.ReadLine();
        }

        static void Worker(String taskName)
        {
            Console.WriteLine("This is Task - {0}", taskName);
        }
    }
}</pre></div><p>Now, let's compile <a id="id311" class="indexterm"/>and run this application. You should see results as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_05_04.jpg" alt="How to do it"/></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>How it works</h2></div></div></div><p>Let's now examine what we just accomplished and why it worked. You can see from the output that we ran five tasks all in different threads and then waited on them to complete. First, we created a static <code class="literal">TaskFactory</code> class to use:</p><div class="informalexample"><pre class="programlisting">static TaskFactory TF = new TaskFactory(TaskScheduler.Default);</pre></div><p>There are several overloads for the <code class="literal">TaskFactory</code> constructor. The one we used just takes a <code class="literal">TaskScheduler</code> object and we chose the default. In the next section of this chapter, we will examine the <code class="literal">TaskScheduler</code> class in more detail.</p><p>Next, we created and ran the five tasks using the <code class="literal">StartNew()</code> method of the <code class="literal">TaskFactory</code> class, as <a id="id312" class="indexterm"/>shown in the following line of code. There are many overloads for this method to allow you to create and start tasks according to your requirements and design pattern. In <a class="link" href="ch06.html" title="Chapter 6. Task-based Parallelism">Chapter 6</a>, <span class="emphasis"><em>Task-based Parallelism</em></span>, and <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <span class="emphasis"><em>Data Parallelism</em></span>, we will examine more of these:</p><div class="informalexample"><pre class="programlisting">TF.StartNew(() =&gt; Worker("Task 1"), CancellationToken.None, TaskCreationOptions.PreferFairness, TaskScheduler.Default)</pre></div><p>Let's take a minute to look at the different parameters passed into the <code class="literal">StartNew()</code> method. We passed it a cancellation token, a task-creation option, and a scheduler. This allows a lot of the thread management of the task to be handled without having to manually do it.</p><p>The cancellation token allows us to tell .NET if the tasks can be canceled or not. It also allows us to set a wait handle that is signaled if the task is canceled. The task creation options allow for the following settings, which give us a lot more control over the task than we had with the thread (referenced from <a class="ulink" href="http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions">http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions</a>):</p><div class="mediaobject"><img src="graphics/8321EN_05_05.jpg" alt="How it works"/></div><p>We also passed the <code class="literal">TaskFactory</code> constructor a lambda expression for the <code class="literal">Action</code> object, which tells it what the <a id="id313" class="indexterm"/>task should execute:</p><div class="informalexample"><pre class="programlisting">() =&gt; Worker("Task 1")</pre></div><p>Finally, we performed a <code class="literal">Task.WaitAll</code> on the list of tasks, so we had to wait for all of the tasks to complete. We will see in the next chapter how we can do this directly with the <code class="literal">TaskFactory</code> object:</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(tasklist.ToArray());</pre></div><p>This is a basic example of using <code class="literal">TaskFactory</code> but you can see the many benefits it provides and how much work is reduced for the developers as compared to using straight threads.</p></div></div>
<div class="section" title="Task schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Task schedulers</h1></div></div></div><p>One of the main <a id="id314" class="indexterm"/>benefits of the Task Parallel Library versus developing using the <code class="literal">Thread</code> class is the <code class="literal">TaskScheduler</code>. This class does a lot of the logic that you had to program into your multithreaded code to achieve maximum performance and efficiency. This is what truly makes using TPL "lightweight" concurrency programming. The main job of the <code class="literal">TaskScheduler</code> class is to handle the work of queuing tasks to threads, or more specifically, the <code class="literal">ThreadPool</code>, and managing the <code class="literal">ThreadPool</code> to best utilize the number of processing cores on the machine it is being executed on.</p><p>One of the best features of the <code class="literal">TaskScheduler</code> is that it is an <code class="literal">abstract</code> class that you can derive your own classes from. The <code class="literal">TaskScheduler</code> allows you to schedule tasks on the <code class="literal">ThreadPool</code> exactly how you need if the default <code class="literal">TaskScheduler</code> does not meet your needs. This gives you the ultimate in flexibility and control.</p><p>Let's talk for a minute about the <code class="literal">ThreadPool</code>. The <code class="literal">ThreadPool</code> consists of a queue (FIFO) of work items for threads in an application domain. Tasks are put on this queue until a thread is available to process them. In .NET 4.0, the <code class="literal">ThreadPool</code> was enhanced to improve performance by essentially making the work queue a <code class="literal">ConcurrentQueue</code> collection object, which eliminates the need for the locking logic to make the queue thread-safe.</p><p>Another point to note is that tasks that are not the children of other tasks are put in a <span class="strong"><strong>global</strong></span> queue, while tasks that are children of other tasks are put in <span class="strong"><strong>local</strong></span> queues of the parent task. So, when a thread is finished processing a work item, it first looks in the task's local queue for more work before going to the global queue. This is another way .NET 4.0 improved the performance of the <code class="literal">ThreadPool</code>. </p><p>The following are four ways that the <code class="literal">TaskScheduler</code> <a id="id315" class="indexterm"/>improves performance of the <code class="literal">ThreadPool</code> and removes work from the developer (referenced from <a class="ulink" href="http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx">http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx</a>):</p><div class="mediaobject"><img src="graphics/8321EN_05_06.jpg" alt="Task schedulers"/></div></div>
<div class="section" title="Introducing the Parallel class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Introducing the Parallel class</h1></div></div></div><p>The last <a id="id316" class="indexterm"/>class we will touch on in this TPL primer is the <code class="literal">Parallel</code> class. This class will be covered in detail in <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <span class="emphasis"><em>Data Parallelism</em></span>, when we discuss data parallelism; but it is worth an introduction here. The <code class="literal">Parallel</code> class is part of the <code class="literal">System.Threading.Tasks</code> namespace and provides functionality for using parallel loops. The two most used methods are <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code>, which allow you to loop through a collection and perform logic on each item of the collection concurrently.</p><p>We briefly saw it earlier in this chapter when we used the <code class="literal">Parallel.Invoke</code> method to run a group of tasks in parallel. But its main use is for data parallelism.</p><p>We can call the <code class="literal">Parallel.For</code> method using a named method, an anonymous method, or a lambda expression.</p><p>The following are examples of the three ways:</p><div class="informalexample"><pre class="programlisting">        // Named method.
        Parallel.For(0, 5, Method);

        //Anonymous method.
        Parallel.For(0, 5, delegate(int i)
        {
            // Do something
        });

        //Lambda expression.
        Parallel.For(0, 5, i =&gt;
        {
            // Do something
        });</pre></div><p>In the named method version, you would need to write a method called <code class="literal">Method</code> that receives an integer parameter and does not return anything. Using <code class="literal">Parallel.For</code> causes .NET to run each <a id="id317" class="indexterm"/>iteration of the loop concurrently. Whether it does this or not depends on the number of processing cores and other work going on at the same time.</p><p>The <code class="literal">Parallel.ForEach</code> <a id="id318" class="indexterm"/>method takes an <code class="literal">IEnumerable</code> data source and an <code class="literal">Action</code> delegate and iterates through the data source and calls the <code class="literal">Action</code> delegate on each item. It also returns a <code class="literal">ParallelLoopResult</code> object with the results for the processing, if there are any. The basic syntax for this is as follows:</p><div class="informalexample"><pre class="programlisting">Parallel.ForEach(IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body)</pre></div><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>How to do it</h2></div></div></div><p>Let's see a simple example. Open Visual Studio, create a new console application named <code class="literal">ParallelForEach</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Place the following code in the <code class="literal">Program.cs</code> file:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
class SimpleForEach
{
    static void Main()
    {
        string[] localStrings = "I am doing a simple example of a Parallel foreach loop".Split(' ');

        Parallel.ForEach(localStrings, currentString =&gt;
                {

                    Console.WriteLine("Current word is - {0}, and the current thread is - {1}", currentString,
                                        Thread.CurrentThread.ManagedThreadId);
                } 
             ); 

        Console.ReadLine();
    }
}</pre></div></li><li class="listitem">Now, let's <a id="id319" class="indexterm"/>compile and run the application. Your results should look like this:<div class="mediaobject"><img src="graphics/8321EN_05_07.jpg" alt="How to do it"/></div></li></ol></div></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>How it works</h2></div></div></div><p>First, we create an <code class="literal">IEnumerable</code> collection by splitting a sentence into an array of strings for each word in the sentence. Then we perform a <code class="literal">Parallel.ForEach</code> looping on each word and simply print the word and current thread ID to the console.</p><p>Something to note here is that you see thread IDs 8, 9, 10, and 11. There is a separate thread for each iteration of the loop and the thread IDs are not starting with 0 or 1. Remember that the TPL uses <code class="literal">ThreadPool</code>. So, the <code class="literal">Action</code> delegate is queued as a separate task to the <code class="literal">ThreadPool</code> for each iteration of the list, which has 11 words. The <code class="literal">TaskScheduler</code> and .NET use the <code class="literal">ThreadPool</code> as efficiently as they can to process these queued tasks concurrently. On my particular machine, there are four processing cores. So, it does split the work out between four threads. But then, based on the rest of the work the computer is <a id="id320" class="indexterm"/>doing, thread 8 handles two of the tasks, thread 9 handles seven of the tasks, and thread 10 and 11 handle one task each.</p><p>But the thing to note here is that we did not have to manage any of this. Using threads directly, we would have had to interrogate the hardware and realize there are four processing cores. Then, break the array into four smaller arrays and hand each of the smaller arrays to a single thread to achieve maximum performance.</p></div></div>
<div class="section" title="Delegates and lambda expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Delegates and lambda expressions</h1></div></div></div><p>In this chapter, we have used delegates and lambda expressions. These two concepts are confusing for <a id="id321" class="indexterm"/>some new developers, so let's take a moment to discuss them in a little more detail.</p><p>Delegates are often used when creating event handlers. A <span class="strong"><strong>delegate</strong></span> defines a reference type that <a id="id322" class="indexterm"/>encapsulates a method with a certain set of parameters and a return type. It functions a lot like a function pointer in C++. It allows us to pass a delegate object that can be used to call a method without having to know the method at compile time.</p><p>In our example, the <code class="literal">Task</code> constructor takes an <code class="literal">Action</code> delegate to define the <span class="emphasis"><em>action</em></span> to be performed by the task. In our example, we set the method for the delegate in the constructor definition, but we do not have to. We can write it like this:</p><div class="informalexample"><pre class="programlisting">            Action task1Method;
            task1Method = new Action(WriteNumbers);
            Task t1 = new Task(task1Method);</pre></div><p>This way, we declare the <code class="literal">Action</code> delegate. Then we instantiate it with the method <code class="literal">WriteNumbers</code>, and finally, we instantiate a <code class="literal">Task</code> object with the delegate. Later in the code, we can always change the method the <code class="literal">Action</code> delegate uses, based on business logic. So, we are not bound for this task to have to execute the <code class="literal">WriteNumbers</code> method, every time the task is performed.</p><p>All we need to know at design time is that we want to execute a method with no parameters and no return type in this task. This gives us a lot of power and flexibility.</p><p>A lambda expression is an anonymous function that can be used to create delegates. In a lambda expression, there is the lambda operator, <code class="literal">=&gt;</code>, and the left- and right-hand side of this operator. The left-hand side contains any input parameters and the right-hand side contains the expression of the code block. Empty parentheses represent zero parameters. Let's look at the following statement:</p><div class="informalexample"><pre class="programlisting">Task t1 = new Task(() =&gt; WriteNumbers());</pre></div><p>In this statement, we are using a lambda expression to represent the delegate that the <code class="literal">Task</code> constructor takes as an input: <code class="literal">() =&gt; WriteNumbers()</code>
</p><p>This lambda expression is telling us that the delegate has no input parameters(<code class="literal">()</code>) and that the code block for the method of the delegate is <code class="literal">WriteNumbers()</code>.</p><p>So, we can see that in <a id="id323" class="indexterm"/>the preceding examples, the <code class="literal">Task</code> constructor takes a <a id="id324" class="indexterm"/>delegate reference type and we use a lambda expression to define that delegate. By doing this, we have flexibility to change at runtime what method a task will execute when it is run. The only constraint at compile time is the parameters passed into the delegate and the return type of the delegate.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we started our journey into the Task Parallel Library and this will be the focus of the rest of the book. You learned about the <code class="literal">Task</code>, <code class="literal">Action</code>, <code class="literal">TaskFactory</code>, <code class="literal">Parallel</code>, and <code class="literal">TaskScheduler</code> classes.</p><p>You also learned what the meaning of lightweight concurrency versus heavyweight concurrency is, and started to see the many benefits for the developer.</p><p>The code examples in this chapter were very simple but designed to get you to start thinking from a TPL mindset and out of the <code class="literal">Thread</code> and <code class="literal">BackgroundWorker</code> mindset. Throughout the rest of this book, we will explore many more detailed features of the TPL classes and several common parallel design patterns and how they are implemented using TPL.</p><p>You should already be able to see just how powerful the TPL is and how much of the complexity to make an application designed for concurrency it handles. When building a multithreaded application, there are usually four considerations that need to be handled by the developer that are not part of a single-threaded application; they are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What pieces of functionality in the application can we process concurrently?</li><li class="listitem" style="list-style-type: disc">How do I manage achieving maximum performance without knowing ahead of time what machine it will be running on and how many processing cores it might have?</li><li class="listitem" style="list-style-type: disc">How do I ensure thread-safety in the data and values that overlap between threads? Or split the data and values to not overlap?</li><li class="listitem" style="list-style-type: disc">How do I manage and coordinate the different threads?</li></ul></div><p>Even though we have only just begun discussing TPL, you can already see how the last three are handled for you unlike doing concurrent programming with threads directly.</p><p>The first one is a design decision and, as we discuss common parallel design patterns, you will see that TPL helps us there as well.</p><p>Now, let's move on to <a class="link" href="ch06.html" title="Chapter 6. Task-based Parallelism">Chapter 6</a>, <span class="emphasis"><em>Task-based Parallelism</em></span>, and start to really become comfortable developing software using the TPL.</p></div></body></html>