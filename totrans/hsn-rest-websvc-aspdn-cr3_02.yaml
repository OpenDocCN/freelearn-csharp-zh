- en: REST 101 and Getting Started with ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, almost all applications rely on web services. A lot of them operate
    using the RESTful method. The resource-centric approach and the simplicity of
    the REST style have become an industry standard. Therefore, it is essential to
    understand the theory behind the REST way of working and why it is important.
    This chapter will introduce you to the **Representational State Transfer** (**REST**)
    method. We will see what the definition of REST is and how to identify REST-compliant
    web services. We will also introduce .NET Core 3.1 and ASP.NET Core, the brand
    new version of the open-source, cross-platform framework provided by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of REST architectural elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the .NET ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why you should choose .NET to build a RESTful web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have an overview of some useful tools and
    IDEs that you can use to start developing on .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover some of the base concepts of .NET Core 3.1 and ASP.NET
    Core. You need to have either Windows, Linux, or macOS installed. The setup process
    will depend on which OS you are using. We'll look at the different tools that
    can be used to develop apps and web services in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is REST? **Representational State Transfer** (**REST**) is usually defined
    as a software architecture style that applies some constraints to a web service.
    It identifies a set of resource-centric rules that describe the roles and the
    interaction between the constraints of a distributed hypermedia system, instead
    of focusing on the implementation of the components. Although it is quite rare
    to find a REST service that does not use HTTP, the definition does not mention
    any of these topics and instead describes REST as media- and protocol-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding definition can be further explained with an example. Consider
    an e-commerce website. When you browse a list of products and click on one them,
    the browser interprets your click as a request to a specific resource; in this
    case, the details of the product you clicked on. The browser makes an HTTP call
    to the URI, which corresponds to the details of the product and asks for a specific
    resource using the URI. This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45c0c1b9-0d12-48e2-8f11-351aa8738e9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The concept of REST is pretty similar: the client asks the server for a specific
    resource, and this allows them to navigate and obtain other information about
    resources stored on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of being REST compliant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss REST, we should understand the importance of web services
    in the modern application development world.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical modern application uses web services to obtain and query data. Any
    company that develop any product or solution uses web services to deliver and
    track information. This is because it can be difficult to replicate all the data
    and every behavior you need for every client who uses your application. Web services
    are also useful for providing access to third-party clients and services. Consider,
    for example, the **Application Programming Interfaces** (**APIs**) of Google Maps
    or Instagram: these platforms expose information through HTTP to share it with
    other companies and services.'
  prefs: []
  type: TYPE_NORMAL
- en: The REST approach to web service architecture became increasingly popular because
    it is straightforward and clear. Unlike some old methods, such as the **Simple
    Object Access Protocol** (**SOAP**) or the **Windows Communication Foundation**
    (**WCF**), REST services provide a clean way of querying data. Different information
    can be obtained using different URIs without the need for adding any overhead
    to requests.
  prefs: []
  type: TYPE_NORMAL
- en: Today, more than ever, our services need to be prepared to scale so that they
    can be adapted to consumers. In a world of different technologies and distributed
    teams around the globe, we should be able to transform our architecture to solve
    complex business challenges. HTTP and REST help us address these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: REST requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Roy Thomas Fielding is the main person behind the formalization of the HTTP
    protocol and the REST style: he described them in his dissertation, *Architectural
    Styles and the Design of Network-based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)).
    Moreover, Fielding''s dissertation clearly defines the constraints of a REST system,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these, apart from code on demand, are essential when we wish to define
    a web service as REST-compliant. To explain these concepts, we will use the APIs
    provided by The New York Times: [https://developer.nytimes.com/](https://developer.nytimes.com/).
    To use these APIs, you need to go through a pre-authentication process. You can
    get an API key for this from the following link: [https://developer.nytimes.com/signup](https://developer.nytimes.com/signup).'
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uniform interface refers to the separation between the client and the server.
    This is advantageous because it means that the two systems are independent. The
    first principle of a uniform interface is that it should be r*esource-based,*
    which means that we should start to think in a *resource-oriented way*. Therefore,
    every object or entity inside our system is a resource and a URI uniquely identifies
    each of them. Furthermore, if we think about the HTTP protocol, each resource
    is presented to the client in the form of XML or JSON to decouple the client from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use The New York Times APIs to understand this topic. Consider the following
    URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains some precise information about the resources we are asking for,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we are getting information from the *archive* section of the newspaper
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific month we are asking for; in this case, June 2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the resource will be serialized using *JSON format*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation of resources through representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take another API request provided by The New York Times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a list of books based on a category; in this case, this category
    is `Hardcover Fiction`. Let''s analyze the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a clear representation of the resource. The client has
    all the required information to process and modify data using APIs (if the APIs
    allow that).
  prefs: []
  type: TYPE_NORMAL
- en: Self-descriptive messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the response of the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, the response is a representation of the data, either
    stored in a data source or obtained from another system. In any case, some information
    is missing: how does the client know the format of the response? This kind of
    information is usually written in the response header. For example, here are all
    the headers of the previous request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *headers* part tells the client that the response should be processed using
    a specific `content-type`*;* in this case, `application/json`*.* It also provides
    information about encoding, caching, and related meta information, such as the
    `age` header, which contains the time in seconds that the object has been in the
    proxy cache.
  prefs: []
  type: TYPE_NORMAL
- en: Hypermedia as the Engine of Application State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services usually deliver a state to clients via body content, response codes,
    and response headers. Above all, *hypermedia-driven services (HATEOAS)* include
    the URI of other resources within their responses. The following example describes
    the concept of HATEOAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous response provides a list of people, together with the URIs that
    specify detailed information of each person. Therefore, the client knows the right
    URI of the request to use in order to get the information regarding each resource.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being stateless is a crucial characteristic of a REST service. Indeed, HTTP,
    as a stateless protocol, doesn't keep track of all the information about the connection
    between the client and the server once the communication ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stateless protocol forces the client to fulfill the request with all the
    required information each time it needs some information from the server. Let''s
    take one of the previous URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The client has to send the *API key* with each request to be authenticated by
    the server. Furthermore, it must store the API key information.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness is very important if we wish to take advantage of REST services.
    Nowadays, with the rise of highly distributed systems, it is difficult to deal
    with stateful services because this requires the states to be managed and replicated
    on different servers. A stateless approach helps delegate state management to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server separation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main aim of REST services is to decouple the server and the client. This
    is very important because it helps keep unique business logic and data storage
    for each client application. Applications are usually distributed across a multitude
    of different clients, including the web, smartphones, smart TVs, and the IoT.
    A REST approach helps us prevent logic replication across clients. This means
    that the client does not have any business logic or storage, and the server does
    not deal with user interfaces or the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of a layered system is strictly related to the structure of the
    infrastructure of our application. RESTful services allow a loosely coupled approach
    because the information is transferred over a protocol – in most cases, HTTP –
    and each server has a single high-level purpose. Proxy servers, web servers, and
    database servers are usually isolated and they cover a purpose in our feature,
    if you have one server that provides all the required features, it is often hard
    to maintain and scale.
  prefs: []
  type: TYPE_NORMAL
- en: Richardson maturity model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Richardson maturity model* is a model that was developed by Leonard Richardson,
    and its purpose is to measure the maturity of APIs by providing some general criteria.
    The model has four classification steps, from **Level 0** to **Level 3**. The
    highest level corresponds to a more compliant service. This model isn''t just
    for theoretical purposes; it also helps us understand some of the recommended
    methods for web service development. Let''s take a look at an overview of these
    different levels. The following diagram shows the structure of the levels in the
    Richardson maturity model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f85cdef-13d5-45cc-a224-12d1f075e2ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A generic service is at **Level 0: The Swamp of Plain Old XML** when ituses
    a generic protocol superficially (in the case of web services, this is HTTP).
    An example of this is a heavy SOAP web service. SOAP implementations use only
    one URI and only one HTTP verb, and they wrap each request message within a massive
    envelope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, thinking in terms of resources is the best way
    to understand and design an API. Therefore, a generic service that''s at **Level
    1** uses multiple URIs associated with different resources. For example, if we
    think about an API of a general store, we could obtain the complete list of product
    categories by calling this sample URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, we can get the details of a single category by calling the
    following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can get a list of products related to a single category
    by calling the following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can obtain different information by calling different URIs.
    There is no envelop, and all the requested information is contained in the URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Level 2, which is related to HTTP verbs, introduces the use of HTTP verbs to
    enhance the information that''s transferred on request. Let''s take the previous
    request URI as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This can produce different results, depending on the HTTP verb. The following
    table shows the meanings of various HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verbs** | **Performed operations** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Retrieves information about a resource |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `POST` | Creates a new item related to the resource |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PUT` | Replaces an item related to the resource |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PATCH` | Updates an item related to the resource |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DELETE` | Deletes an item related to the resource |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Different HTTP verbs correspond to various data operations. As opposed to a
    **Level 0** service, which doesn't use any specifications of HTTP to deliver information,
    a **Level 2** service takes advantage of HTTP specifications to deliver as much
    information as possible. Finally, a system witha **Level 3** service implements
    the concept of HATEOAS. As we discussed in the previous section, a HATEOAS provides
    the resource's URI inside its response. A clear advantage of this approach is
    that the client doesn't need any information on its side to navigate through the
    web service's resources. Most importantly, if our web service adds the resource's
    URI, the client immediately has all the information they need.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing this book, .NET Core 3.1 is the **LTS** (short for **Long
    Term Support**) version of the framework powered by Microsoft and the community.
    ASP.NET Core is the highly modular web framework that runs over the .NET Core
    platform: it can be used to develop a wide range of web solutions, such as web
    applications, web assembly client applications and web API projects.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn about some of the basic concepts of ASP.NET Core, we need to understand
    the **Model View Controller** (**MVC**) pattern that is implemented in ASP.NET
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: MVC separates our web application by grouping implementations into three different
    areas. In a web environment, the starting point is usually a web request that's
    made by a client or a generic user. The request passes through a middleware pipeline,
    and the controller then handles it. The controllers also perform some logic operations
    and populate our *model*.
  prefs: []
  type: TYPE_NORMAL
- en: The model is the representation of the state of the application. When it is
    associated with a view, it is called a **view model**. Once the model is populated,
    the controller returns a specific view, depending on the request. The purpose
    of the views is to present data through HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a web API stack, which is the typical way of building web services
    in ASP.NET Core, the process is the same except for the view part. Instead of
    this, the controller serializes the model in the response.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how ASP.NET Core helps developers build web services, let's go
    through the history of the ASP.NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of ASP.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of ASP.NET was released in 2002 when Microsoft decided to
    invest in web development. They released ASP.NET Web Forms, which is a set of
    UI components that we can use to build web interfaces. The core idea of this approach
    was to provide a very high-level abstraction tool that can produce a GUI for the
    web. Providing this level of abstraction was a good idea because developers were
    not familiar with the web. However, ASP.NET Web Forms came with a lot of downsides.
    First of all, developers had limited control over HTML, and components had to
    store information in a *v**iew state,* which was transferred and updated between
    the client and the server. Furthermore, the components were not correctly separated,
    and developers tended to mix the presentation code with the business logic code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to improve the experience of developing web applications, Microsoft
    announced the arrival of ASP.NET MVC in 2007\. This new development platform ran
    on the ASP.NET framework and used concepts from other development platforms that
    implemented MVC patterns, such as Ruby on Rails. The ASP.NET MVC framework still
    had some points of weakness. It was built on ASP.NET, which means it had to maintain
    its retro compatibility with old web forms and web services frameworks such as
    WCF. Furthermore, it only ran on Windows servers combined with **Internet Information
    Services** (**IIS**).
  prefs: []
  type: TYPE_NORMAL
- en: The latest web framework to be developed by Microsoft is ASP.NET Core. It runs
    on .NET Core, which is cross-platform and open source. With ASP.NET Core, Microsoft
    made the choice to release a new lightweight framework that does not have any
    back-compatibility components derived from previous versions of ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: The new .NET ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an overview of the .NET ecosystem to understand the different
    frameworks that act as the foundations of ASP.NET Core. Some of the information
    provided here may sound obvious, but it is essential to clarify the differences
    between different runtimes and frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7274e7a2-f816-46bc-a757-727e6661ce84.png)'
  prefs: []
  type: TYPE_IMG
- en: The first block is related to **Desktop Packs**, which provides the tools for
    the development of desktop applications starting from **.NET Core 3.0**. We will
    not use these tools in this book since they are strictly related to desktop development.
  prefs: []
  type: TYPE_NORMAL
- en: The second block is related to the cross-platform part of .NET Core. This set
    of tools allows developers to build applications on the **WEB**, **DATA**, and
    **AI/ML** domain. The **WEB** section refers to ASP.NET Core, which is a collection
    of libraries that comes with .NET Core. Usually, ASP.NET Core is combined with
    the **DATA** access part. Later in this book, we will see how we can use **EF
    Core** to access the database layer. Finally, the **AI/ML** section, which will
    not be discussed in this book, provides useful tools in the machine learning domain.
    At the bottom of the preceding diagram, we have a common layer, that is, **.NET
    STANDARD**. It allows developers to build third-party libraries that can be used
    by the **Desktop Packs** and by the **WEB**, **DATA**, and **AI/ML** parts.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the new .NET ecosystem can be used by any developer, including
    cloud developers, web developers, and desktop developers. As we mentioned previously,
    it also runs anywhere and on any platform. In this book, all of our examples will
    be based on .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: .NET STANDARD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**.NET STANDARD** was introduced along with .NET Core. The aim of the **.NET
    STANDARD** is to provide a common API surface for .NET Core and .NET Framework.
    It works as a unique **Base Class Library** (**BCL**) for our applications in
    both .NET Framework and .NET Core. The release of .NET Standard 2.0 has introduced
    32,000 compatible APIs and supports the following framework versions:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.6.1 +
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 2.0 +
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono 5.4 +
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently, Microsoft introduced .NET Standard 2.1\. This new version provides
    new APIs that were introduced as part of the open-source development of .NET Core
    3.0\. .NET Standard 2.1 will be the common point between the new versions of .NET
    Core, starting from the 3.0 version, and the other versions of the upcoming frameworks,
    such as Mono.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to choose the .NET Standard for different reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To build third-party libraries that are compatible with both .NET Core and .NET
    Framework. In that case, your package will target .NET Standard 2.0\. Eventually,
    if you want to use the newly optimized APIs that we described previously, it is
    possible to use multi-targeting to target both .NET Standard 2.0 and .NET Standard
    2.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To migrate your .NET Framework codebase gradually by isolating logic on .NET
    Standard projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, consider a class library project which is used by different versions
    of .NET. The library may run on either .NET Core or .NET Framework. To avoid maintainability
    pitfalls, the library package can be compiled for multiple versions of .NET Standard
    and it can be used by both a *.NET Core* and a *.NET Framework* solution*.*
  prefs: []
  type: TYPE_NORMAL
- en: Why use ASP.NET Core to build RESTful web services?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a massive choice of web frameworks that allow developers to build
    REST web services. One such framework is ASP.NET Core on .NET Core 3.1\. .NET
    Core 3.1 provides a new, lightweight, cross-platform and opensource way to build
    web applications. Most importantly, it is designed to be cloud-ready: the framework
    is no longer part of the server, unlike in .NET Framework; instead, it is shipped
    with the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key point is that .NET Core maintains a *high level of modularity*,
    which adheres to the Unix philosophy and allows you to use only what you need
    in tailored applications. ASP.NET Core also introduces two new hosting solutions
    for web applications and web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kestrel**: The default HTTP server for ASP.NET Core. It supports HTTPS and
    web sockets, and it runs on Windows, Linux, and macOS. *Kestrel* is usually combined
    with a *reverse-proxy,* such as NGINX, IIS, or Apache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP.sys**: A Windows-only HTTP server that can be used as an alternative
    to Kestrel on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core and .NET Core are developed by Microsoft and the community, and
    they are *open source projects*. In the case of ASP.NET Core, open source isn''t
    just a buzzword; all the features are community-driven, and the ASP.NET team streams
    a community standup video on YouTube every week, in which they discuss roadmaps,
    deadlines, and issues. All the .NET Core code is available on GitHub at the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Core**: The repository of .NET Core ([https://github.com/dotnet/core](https://github.com/dotnet/core))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core**: Contains all the references to ASP.NET Core projects ([https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the repositories usually come with a roadmap and some contributing guidelines.
    It is possible to open issues and contribute to the code base. Microsoft has also
    founded the .NET foundation, an independent organization that fosters open development
    and collaboration around the .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET Core team is also focused on the performance of the framework.
    All the benchmark results are available on GitHub: [https://github.com/aspnet/benchmarks](https://github.com/aspnet/benchmarks).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to set up your development environment
    so that you can develop web services using ASP.NET Core. As we mentioned previously,
    .NET Core is cross-platform, so it can run on the most common OSes. We will also
    look at how to interact with the .NET Core CLI, which is the starting point for
    building, running, developing, and testing our services.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's start by downloading .NET Core 3.1 from [https://www.microsoft.com/net/download/](https://www.microsoft.com/net/download/).
    In our case, we'll install the SDK version, which contains all the components
    that are required for our development environment, including ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the .NET framework, .NET Core provides an easy to use CLI that exposes
    all the necessary functionalities we can use to build applications and services.
    Once .NET Core is installed on your machine, run the `dotnet --help` command.
    You will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is the version of .NET Core, which is the version
    of .NET Core, that is, `.NET Core SDK (3.1.100)`, followed by a list of **Software
    Development Kit** (**SDK**) commands. This contains the commands that are commonly
    executed during the development stage, such as `dotnet build`, `dotnet restore`,
    and `dotnet run`. These are used to build our projects, restore the NuGet dependencies,
    and run our project, respectively. Another relevant section is a*dditional tools,*
    which contain all the third-party CLI packages we will require, such as EF Core.
    In fact, the .NET Core CLI allows you to extend its functionality by adding specific
    tools in the form of NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: IDEs and development tools in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Core CLI is a base upon which higher-level tools such as IDEs, code editors,
    and **continuous integration** (**CI**) tools can be placed. Even though .NET
    Core is a cross-platform framework, there are various tools that can be used to
    build web applications and services on different platforms. The following table
    provides a recap of the different IDEs and editors that can be used to build ASP.NET
    Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Softwares** | **Windows** | **Linux** | **macOS X** |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Studio 2019 (Community, Pro, and Enterprise) | Supported | - | - |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Studio Code and OmniSharp | Supported | Supported | Supported |'
  prefs: []
  type: TYPE_TB
- en: '| Rider | Supported | Supported | Supported |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Studio for Mac | - | - | Supported |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see, it is possible to use different IDEs and code editors for different
    platforms. The choice you make usually depends on different factors. Let''s look
    at an overview of the different editors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio 2019 (Community, Pro, and Enterprise)**: An editor that is
    well-known to anyone who has already developed on the .NET ecosystem. The community
    version of this product is totally free, and you can find it at [https://visualstudio.microsoft.com/it/downloads/](https://visualstudio.microsoft.com/it/downloads/).Visual
    Studio 2019 is the most comfortable choice if you wish to start building on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code and OmniSharp**: A popular and open source editor powered
    by Microsoft and the community. It is cross-platform and built on Electron. OmniSharp
    is a useful third-party package for Visual Studio Code and other code editors
    that provides some integration with .NET Core projects. It also provides an IntelliSense
    feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rider**: A brand new IDE powered by JetBrains and based on the IntelliJ platform
    and ReSharper. It is compatible with every platform, but it is not free. I''ve
    tried it in large projects, and it works well, primarily to provide the ReSharper
    integration out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio for Mac**: A new IDE powered by Microsoft. It is only compatible
    with macOS and provides a few functionalities we can use to write C# or F# code
    in the .NET Core ecosystem. This IDE is still at an early stage, but it has a
    lot of advanced features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, tools such as Visual Studio 2019, Rider, and Visual Studio for
    Mac provide a great experience when combined with .NET Core. On the other hand,
    Visual Studio Code is the lightest and fastest editor. In the upcoming chapters
    and code demonstrations, I will use the .NET Core CLI to reproduce the same steps
    in different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken an overview of the REST style by considering
    some concrete some concrete examples. We also learned about some of the basic
    concepts of the .NET ecosystem, including how it is structured and why ASP.NET
    Core is an excellent choice if we wish to build web services. We also looked at
    an overview of the .NET Core CLI and the IDEs and code editors related to the
    .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The topics we covered in this chapter provide a good understanding of what REST
    means and why is important to follow this kind of principle when we develop a
    web service. Furthermore, we also looked at the fundamentals for setting up .NET
    Core in our local environment.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on ASP.NET Core and ASP.NET Core MVC. You'll learn
    how to set up a project using the .NET CLI and explore some of the fundamentals
    concepts of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
