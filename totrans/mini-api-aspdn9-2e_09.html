<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-114">
    <a id="_idTextAnchor143">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-115">
    <a id="_idTextAnchor144">
    </a>
    
     Object Relational Mapping with Entity Framework Core and Dapper
    
   </h1>
   <p>
    
     In the previous chapter, we used direct connections to SQL and NoSQL databases to create and retrieve data, a staple of
    
    
     
      most APIs.
     
    
   </p>
   <p>
    
     In reality, a large segment of APIs based on .NET favor the use of
    
    <strong class="bold">
     
      Object Relation Mapping
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ORM
     
    </strong>
    
     ) to
    
    <a id="_idIndexMarker323">
    </a>
    
     converse with databases over the direct connection method.
    
    
     This is because ORMs offer another layer of abstraction over the underlying data, promoting SOLID design principles while being conducive to scalability and easy
    
    
     
      long-term maintenance.
     
    
   </p>
   <p>
    
     In this chapter, we are going to explore two of the mainstream ORM frameworks – Entity Framework Core and Dapper.
    
    
     With these two technologies, we will be able to map the entities in our database and manage them as if the data was contained within the classes that make up our minimal
    
    
     
      API project.
     
    
   </p>
   <p>
    
     We will cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Introduction
     
     
      
       to ORMs
      
     
    </li>
    <li>
     
      Configuring Dapper in minimal
     
     
      
       API projects
      
     
    </li>
    <li>
     
      Performing CRUD operations
     
     
      
       with Dapper
      
     
    </li>
    <li>
     
      Configuring Entity Framework in minimal
     
     
      
       API projects
      
     
    </li>
    <li>
     
      Performing CRUD operations with
     
     
      
       Entity Framework
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-116">
    <a id="_idTextAnchor145">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You will need the following software to be installed on
    
    
     
      your machine:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio 2022 or Visual
     
     
      
       Studio Code
      
     
    </li>
    <li>
     
      Microsoft SQL Server 2022
     
     
      
       Developer Edition
      
     
    </li>
    <li>
     
      Microsoft SQL Server
     
     
      
       Management Studio
      
     
    </li>
   </ul>
   <p>
    
     You will need to create a database in SQL Server (
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     ).
    
    
     The SQL to create the required
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table was provided in the previous chapter, but I will also include it in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     The code for this chapter is available in the GitHub repository
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor146">
    </a>
    
     Introduction to ORMs
    
   </h1>
   <p>
    
     ORMs were first
    
    <a id="_idIndexMarker324">
    </a>
    
     introduced in the 1990s to address the
    
    <a id="_idIndexMarker325">
    </a>
    
     mismatch between the way data is modeled in relational databases such as SQL
    
    <a id="_idIndexMarker326">
    </a>
    
     and
    
    <strong class="bold">
     
      Object-Oriented Programming
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OOP
     
    </strong>
    
     ) languages, often referred to as the
    
    
     <strong class="bold">
      
       Impedance Mismatch
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Data in a
    
    <em class="italic">
     
      relational database
     
    </em>
    
     is laid out in a series of tables, each with a number of columns defining the property of each record, which in turn is represented by a row in the table.
    
    
     The relationships between entities in a relational database are represented by
    
    <em class="italic">
     
      foreign keys
     
    </em>
    
     and
    
    <em class="italic">
     
      join
     
    </em>
    
     operations that occur during
    
    
     
      a query.
     
    
   </p>
   <p>
    
     In contrast, data in an
    
    <em class="italic">
     
      OOP language
     
    </em>
    
     is represented as objects that have fields, properties, and operational logic such as methods and functions that can act on the data.
    
    
     Relationships between objects in OOP are more abstract, represented by pointer references and concepts such as inheritance
    
    
     
      and polymorphism.
     
    
   </p>
   <p>
    
     An ORM bridges the gap between these two paradigms by providing a means of mapping the data, which allows us to work with database records as if they were objects.
    
    
     This provides a layer of abstraction that simplifies the complexities of SQL, making it easier to
    
    <a id="_idIndexMarker327">
    </a>
    
     perform
    
    <strong class="bold">
     
      Create
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Read
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Update
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Delete
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       CRUD
      
     </strong>
    
    
     
      ) operations.
     
    
   </p>
   <p>
    
     There are many, widely used ORMs on offer for various OOP languages and frameworks.
    
    
     The first widely used ORM
    
    <a id="_idIndexMarker328">
    </a>
    
     was
    
    <strong class="bold">
     
      TopLink
     
    </strong>
    
     .
    
    
     Developed in 1994, it was designed to provide mapping for Java applications, influencing many of the ORM technologies we take for granted today, such as the two we will be exploring in this chapter – Dapper and
    
    
     
      Entity Framework.
     
    
   </p>
   <p>
    
     ORMs are a significant accelerator to any project, but particularly to minimal API projects.
    
    
     They reduce boilerplate code in ASP.NET because they can be easily installed as a package, and configuration can be achieved centrally, with queries and commands requiring less ceremony than direct SQL connections that use classes such as
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       SqlCommand
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     One of the most powerful aspects of ORMs is the ability for them to manage the schema of the underlying database.
    
    
     Objects can be of course mapped from an existing database, but ORMs provide the ability to manage the database structure in the same way classes are configured in code..
    
    
     This makes schema management really simple and more efficient because developers would be altering class structures anyway.
    
    
     It prevents
    
    <em class="italic">
     
      double keying
     
    </em>
    
     , taking advantage of the work that has already been done in code to automate the dependent changes in
    
    
     
      the database.
     
    
   </p>
   <p>
    
     If you read the previous chapter, you’ll remember that we created a database called
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     to use as an example for connecting directly from our API.
    
    
     We will continue to use this
    
    <a id="_idIndexMarker329">
    </a>
    
     database, but instead, we will map the objects within it using ORMs.
    
    
     Let’s first do this using the
    
    
     
      ORM, Dapper.
     
    
   </p>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor147">
    </a>
    
     Configuring Dapper in minimal API projects
    
   </h2>
   <p>
    
     I’m starting with
    
    <a id="_idIndexMarker330">
    </a>
    
     Dapper
    
    <a id="_idIndexMarker331">
    </a>
    
     because it is an ORM that is
    
    <a id="_idIndexMarker332">
    </a>
    
     often referred to as a
    
    <em class="italic">
     
      Micro-ORM
     
    </em>
    
     when compared to Entity Framework.
    
    
     The reason for this is that it does away with a lot of ORM features such as result caching, change tracking, lazy loading, and database migrations.
    
    
     Instead, Dapper focuses on simplicity and performance.
    
    
     Being a more lightweight solution means that it could be preferable to Entity Framework, depending on the needs of your
    
    
     
      minimal API.
     
    
   </p>
   <p>
    
     Dapper is a good starting point for learning ORMs because it still uses SQL queries, making it the perfect middle-ground between the direct connection method shown in the previous chapter and the more verbose ORM feature set provided by
    
    
     
      Entity Framework.
     
    
   </p>
   <p class="callout-heading">
    
     Database migrations and Dapper
    
   </p>
   <p class="callout">
    
     The last differentiating feature (database migrations) is an important one because it relates to the ability to change the schema of a database.
    
    
     We will talk about migrations later in the chapter when we explore Entity Framework, but for now, know that database migrations change the database schema from our code, and Dapper does not support this via migrations.
    
    
     However, you can still change the table schema by sending SQL commands through Dapper.
    
    
     This is outside of the scope of
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Dapper works with many database providers, including SQL Server, Oracle, SQLite, MySQL, and PostgreSQL.
    
    
     It uses ADO.NET, meaning that it will work with any database platform that has a provider using ADO.NET.
    
    
     Because we are using the database we created in the previous chapter, we will be connecting to a SQL
    
    
     
      Server database.
     
    
   </p>
   <p>
    
     Let’s create a new (empty) ASP.NET project in Visual Studio so that we have a clean slate to
    
    
     
      work on.
     
    
   </p>
   <p>
    
     Once you have created the project, navigate to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , which should have the template
    
    <strong class="source-inline">
     
      Hello
     
    </strong>
    
     <strong class="source-inline">
      
       World
      
     </strong>
    
    
     
      example.
     
    
   </p>
   <p>
    
     To start with, we need a database to connect to.
    
    
     If you followed along with the previous chapter, you will have installed a SQL Server instance and created a database called
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     .
    
    
     If you haven’t done this already, install SQL Server and create the database within SQL Server
    
    
     
      Management Studio.
     
    
   </p>
   <p>
    
     Once you have
    
    <a id="_idIndexMarker333">
    </a>
    
     a
    
    <a id="_idIndexMarker334">
    </a>
    
     database, if
    
    <a id="_idIndexMarker335">
    </a>
    
     you don’t yet have the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table, you can use the following SQL to
    
    
     
      create one:
     
    
   </p>
   <pre class="source-code">
CREATE TABLE dbo.Employees
    (
    Id int NOT NULL IDENTITY (1, 1),
    Name varchar(MAX) NOT NULL,
    Salary decimal(10, 2) NOT NULL,
    Address varchar(MAX) NOT NULL,
    City varchar(50) NOT NULL,
    Region varchar(50) NOT NULL,
    Country varchar(50) NOT NULL,
    Phone varchar(200) NOT NULL
    PostalCode varchar(50) NOT NULL,
)</pre>
   <p>
    
     Dapper uses providers to facilitate the connection to the target database platform.
    
    
     For SQL Server, the required providers are the same as for direct connections to SQL Server from
    
    
     
      C#:
     
    
    
     <strong class="source-inline">
      
       Microsoft.Data.SqlClient
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Install
    
    <strong class="source-inline">
     
      Microsoft.Data.SqlClient
     
    </strong>
    
     , either from the
    
    <strong class="source-inline">
     
      NuGet
     
    </strong>
    
     package manager GUI or in the Package Manager Console by running
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
Install-Package Microsoft.Data.SqlClient</pre>
   <p>
    
     While we’re installing
    
    <strong class="source-inline">
     
      NuGet
     
    </strong>
    
     packages, we also need to install the
    
    <strong class="source-inline">
     
      Dapper
     
    </strong>
    
     package.
    
    
     You can do this in the package manager console by running
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
Install-Package Dapper</pre>
   <p>
    
     We could technically start writing queries now, directly within our minimal API endpoints, but for consistency and good practice, we should create a new service specifically for Dapper and register it for dependency injection.
    
    
     Create a class called
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     .
    
    
     As we did in the previous chapter for
    
    <strong class="source-inline">
     
      SQLService
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      MongoDbService
     
    </strong>
    
     , we will register this class as a singleton in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     .
    
    
     Ensure you register the service
    
    
     
      before
     
    
    
     <strong class="source-inline">
      
       app.Run();
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
builder.Services.AddSingleton&lt;DapperService&gt;();</pre>
   <p>
    
     We have now configured the project to use Dapper on a SQL Server database using dependency injection
    
    <a id="_idIndexMarker336">
    </a>
    
     with
    
    <a id="_idIndexMarker337">
    </a>
    
     the
    
    <a id="_idIndexMarker338">
    </a>
    
     relevant provider, and we have created a database to work with, meaning that we can proceed with performing our first CRUD operations from our
    
    
     
      minimal API.
     
    
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor148">
    </a>
    
     Performing CRUD operations with Dapper
    
   </h2>
   <p>
    
     Let’s work our
    
    <a id="_idIndexMarker339">
    </a>
    
     way
    
    <a id="_idIndexMarker340">
    </a>
    
     through each of the aspects of CRUD in Dapper with some examples.
    
    
     First of all, let’s create
    
    
     
      an employee.
     
    
   </p>
   <h3>
    
     Creating an Employee record
    
   </h3>
   <p>
    
     First, we will
    
    <a id="_idIndexMarker341">
    </a>
    
     create an endpoint
    
    <a id="_idIndexMarker342">
    </a>
    
     that creates an employee.
    
    
     That means we’ll be using the
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <ol>
    <li>
     
      Go to
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      and map a POST endpoint to the
     
     <strong class="source-inline">
      
       employees
      
     </strong>
     
      route.
     
     
      It should accept an
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      as a parameter, and it should
     
     
      
       inject
      
     
     
      <strong class="source-inline">
       
        DapperService
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
app.MapPost(
    "/employees",
    (Employee employee,
    [FromServices] DapperService dapperService) =&gt;
{
});</pre>
    </li>
    <li>
     
      Next, we can create a method within
     
     <strong class="source-inline">
      
       DapperService
      
     </strong>
     
      that handles the creation of the employee in the database (this is where we get to
     
     
      
       use Dapper).
      
     
    </li>
    <li>
     
      Open
     
     <strong class="source-inline">
      
       DapperService.cs
      
     </strong>
     
      and
     
     <a id="_idIndexMarker343">
     </a>
     
      create
     
     <a id="_idIndexMarker344">
     </a>
     
      a method
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        AddEmployee
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public async Task AddEmployee(Employee employee)
{
}</pre>
     <p class="list-inset">
      
       Like the direct connection examples from the previous chapter, Dapper uses
      
      <strong class="source-inline">
       
        SqlConnection
       
      </strong>
      
       to connect to a SQL Server.
      
      
       Inside the scope of that connection, you need to write the appropriate query for the action you want to take.
      
      
       Because we’re creating an
      
      <strong class="source-inline">
       
        employee
       
      </strong>
      
       , we will be adding a new record to the database and so we will write an
      
      
       <strong class="source-inline">
        
         INSERT
        
       </strong>
      
      
       
        statement.
       
      
     </p>
    </li>
    <li>
     
      Make a
     
     <strong class="source-inline">
      
       using
      
     </strong>
     
      statement to hold the connection to the database (remember,
     
     <strong class="source-inline">
      
       using
      
     </strong>
     
      statements allow the connection to be automatically disposed of) and add the connection string to
     
     
      
       your database.
      
     
    </li>
    <li>
     
      Follow this up by defining a string that represents the
     
     
      <strong class="source-inline">
       
        INSERT
       
      </strong>
     
     
      
       statement:
      
     
     <pre class="source-code">
using (var sqlConnection = new
    SqlConnection("YOURCONNECTIONSTRING"))
{
    var sql = "INSERT INTO Employees " +
               (Name, Salary, Address, City, " +
               Region, "Country, Phone) VALUES " +
               (@Name, @Salary, @Address, @City, " +
               @Region, @Country, @Phone)";
}</pre>
     <p class="list-inset">
      
       Notice how the
      
      <strong class="source-inline">
       
        INSERT
       
      </strong>
      
       statement must contain all the relevant columns and values as parameters for
      
      
       
        those columns.
       
      
     </p>
    </li>
    <li>
     
      Next, we
     
     <a id="_idIndexMarker345">
     </a>
     
      will use Dapper to
     
     <a id="_idIndexMarker346">
     </a>
     
      commit the database transaction against the instantiated
     
     <strong class="source-inline">
      
       SqlConnection
      
     </strong>
     
      .
     
     
      We can use
     
     <strong class="source-inline">
      
       ExecuteAsync()
      
     </strong>
     
      , a Dapper extension method that will execute the statement while mapping the properties from the
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      object that we passed into this the
     
     
      <strong class="source-inline">
       
        AddEmployee()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
await sqlConnection.ExecuteAsync(sql, new
{
    employee.PostalCode,
    employee.Name,
    employee.Salary,
    employee.Address,
    employee.City,
    employee.Region,
    employee.Country,
    employee.Phone
});</pre>
     <p class="list-inset">
      
       We now have a method on
      
      <strong class="source-inline">
       
        DapperService
       
      </strong>
      
       that can receive an
      
      <strong class="source-inline">
       
        Employee
       
      </strong>
      
       parameter
      
      <a id="_idIndexMarker347">
      </a>
      
       and commit it to
      
      <a id="_idIndexMarker348">
      </a>
      
       the database via Dapper, as
      
      
       
        shown here:
       
      
     </p>
     <pre class="source-code">public class DapperService
{
    public async Task AddEmployee(Employee employee)
    {
        using (var sqlConnection = new
            SqlConnection("YOURCONNECTIONSTRING"))
        {
            var sql = "INSERT INTO Employees " +
                (Name, Salary, Address, City, " +
                Region, Country, Phone) VALUES " +
                (@Name, @Salary, @Address, " +
                @City, @Region, @Country, @Phone)";
            await sqlConnection.ExecuteAsync(sql, new
            {
                employee.PostalCode,
                employee.Name,
                employee.Salary,
                employee.Address,
                employee.City,
                employee.Region,
                employee.Country,
                employee.Phone
            });
        }
    }
}</pre>
    </li>
    <li>
     
      All that remains now is to call this method in the
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      endpoint we started writing in
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      , before returning an
     
     <strong class="source-inline">
      
       HTTP 201 CREATED
      
     </strong>
     
      status code to
     
     
      
       the client:
      
     
     <pre class="source-code">
app.MapPost(
    "/employees",
    async (Employee employee,
           [FromServices] DapperService dapperService)
           =&gt;
{
    await dapperService.AddEmployee(employee);
    return Results.Created();
});</pre>
    </li>
   </ol>
   <p>
    
     That’s
    
    <a id="_idIndexMarker349">
    </a>
    
     taken
    
    <a id="_idIndexMarker350">
    </a>
    
     care of the
    
    <em class="italic">
     
      Create
     
    </em>
    
     part
    
    
     
      of CRUD.
     
    
   </p>
   <p class="callout-heading">
    
     Storing and referencing connection strings
    
   </p>
   <p class="callout">
    
     In the previous chapter, I demonstrated how you can follow best practices by storing connection strings in a configuration file and then referencing them
    
    
     
      via
     
    
    
     <strong class="source-inline">
      
       IConfiguration.
      
     </strong>
    
   </p>
   <p class="callout">
    
     If you haven’t already done so, please refer to this in the previous chapter so that you can implement it for Dapper and Entity
    
    
     
      Framework usage.
     
    
   </p>
   <p>
    
     Let’s move on to the
    
    <em class="italic">
     
      Read
     
    </em>
    
     
      part now.
     
    
   </p>
   <h3>
    
     Reading an Employee record
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker351">
    </a>
    <em class="italic">
     
      Read
     
    </em>
    
     part
    
    <a id="_idIndexMarker352">
    </a>
    
     will entail having a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint on top of a
    
    <strong class="source-inline">
     
      SELECT
     
    </strong>
    
     query on
    
    
     
      the database:
     
    
   </p>
   <ol>
    <li>
     
      Start by adding a
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      endpoint to
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      , mapped to the
     
     <strong class="source-inline">
      
       Employees
      
     </strong>
     
      route.
     
     
      It should have a route parameter called
     
     <strong class="source-inline">
      
       id
      
     </strong>
     
      that is passed through the body of the lambda expression inside the endpoint, and it should
     
     
      
       inject
      
     
     
      <strong class="source-inline">
       
        DapperService
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
app.MapGet(
    "/employees/{id}",
    (int id,
     [FromServices] DapperService dapperService) =&gt;
{
});</pre>
    </li>
    <li>
     
      Next, we’re going to take the same approach we took in the last example by making a new function in
     
     <strong class="source-inline">
      
       DapperService
      
     </strong>
     
      , but this time, instead of inserting, it will run a
     
     <strong class="source-inline">
      
       SELECT
      
     </strong>
     
      query to get the employee for the specified
     
     <strong class="source-inline">
      
       id
      
     </strong>
     
      , before returning it to
     
     
      
       the endpoint:
      
     
     <pre class="source-code">
        public async Task&lt;Employee&gt;
            GetEmployeeById(int id)
        {
            using (var sqlConnection = new
                SqlConnection("YOURCONNECTIONSTRING"))
            {
                var sql = "SELECT * FROM Employees
                    WHERE Id = @employeeId";
                var result = await sqlConnection
                    .QuerySingleAsync&lt;Employee&gt;(
                        sql, new { employeeId = id });
                return result;
            }
        }</pre>
     <p class="list-inset">
      <strong class="source-inline">
       
        QuerySingleAsync&lt;Employee&gt;()
       
      </strong>
      
       is where the Dapper code comes in.
      
      
       Like before, this is a Dapper extension method that allows us to execute a SQL query, with the expectation that one record will be returned, that record being
      
      
       
        an employee.
       
      
     </p>
    </li>
    <li>
     
      Notice the parameters being sent in.
     
     
      We passed the SQL query, but then we passed a new instance of an object array.
     
     
      This is the value for the
     
     <strong class="source-inline">
      
       @employeeId
      
     </strong>
     
      parameter that we declared in the SQL query.
     
     
      Dapper expects us to pass our parameter values in as an array of objects so that their values can be mapped to
     
     <a id="_idIndexMarker353">
     </a>
     
      the relevant
     
     <a id="_idIndexMarker354">
     </a>
     
      parameters in
     
     
      
       the query.
      
     
    </li>
    <li>
     
      We also called a specific extension method –
     
     <strong class="source-inline">
      
       QuerySingleAsync()
      
     </strong>
     
      .
     
     
      The reason for this is obvious – we only want one record.
     
     
      If you want more, there are functions such as
     
     <strong class="source-inline">
      
       Query()
      
     </strong>
     
      that will return an
     
     <strong class="source-inline">
      
       IEnumerable
      
     </strong>
     
      containing
     
     
      
       many records.
      
     
    </li>
    <li>
     
      Finally, we once again simply call the function in
     
     <strong class="source-inline">
      
       DapperService
      
     </strong>
     
      from the endpoint, returning the result to
     
     
      
       the client:
      
     
     <pre class="source-code">
app.MapGet(
    "/employees/{id}",
    async (int id,
           [FromServices] DapperService dapperService)
           =&gt;
{
     return Results.Ok(
         await dapperService.GetEmployeeById(id));
});</pre>
    </li>
   </ol>
   <p>
    
     Next, let’s look
    
    <a id="_idIndexMarker355">
    </a>
    
     at how we can
    
    <em class="italic">
     
      update
     
    </em>
    
     an
    
    <a id="_idIndexMarker356">
    </a>
    
     
      employee record.
     
    
   </p>
   <h3>
    
     Updating an Employee record
    
   </h3>
   <p>
    
     We’re two
    
    <a id="_idIndexMarker357">
    </a>
    
     letters into CRUD now.
    
    
     Let’s
    
    <a id="_idIndexMarker358">
    </a>
    
     take a look now at
    
    <strong class="source-inline">
     
      Update
     
    </strong>
    
     by taking the same approach – creating a
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     endpoint and connecting it
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       DapperService:
      
     </strong>
    
   </p>
   <pre class="source-code">
app.MapPut(
    "/employees",
     async (Employee employee,
            [FromServices] DapperService dapperService) =&gt;
{
    await dapperService.UpdateEmployee(employee);
    return Results.Ok();
});</pre>
   <p>
    
     Then, we create a function that performs the update against
    
    
     
      the database:
     
    
   </p>
   <pre class="source-code">
        public async Task UpdateEmployee (
            Employee employee)
        {
            using (var sqlConnection = new
                SqlConnection("YOURCONNECTIONSTRING"))
            {
                var sql = "UPDATE Employees SET Name = " +
                @Name, Salary = @Salary, Address = " +
                @Address, City = @City, " +
                Region = @Region WHERE Id = @id";
                var parameters = new
                {
                    employee.Id,
                    employee.Name,
                    employee.Salary,
                    employee.Address,
                    employee.City,
                    employee.Region
                };
                await sqlConnection.ExecuteAsync(
                    sql, parameters);
        }
        }</pre>
   <p>
    
     Notice how the code we’ve added to update the record in
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     is similar to the code we
    
    <a id="_idIndexMarker359">
    </a>
    
     added to create a record.
    
    
     The main difference is the SQL string.
    
    
     Otherwise, we’re
    
    <a id="_idIndexMarker360">
    </a>
    
     still passing in an
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object and mapping its properties to the record in the database
    
    
     
      via Dapper.
     
    
   </p>
   <h3>
    
     Deleting an Employee record
    
   </h3>
   <p>
    
     Finally, we’ve
    
    <a id="_idIndexMarker361">
    </a>
    
     reached the final
    
    <a id="_idIndexMarker362">
    </a>
    
     section of CRUD –
    
    
     <strong class="source-inline">
      
       Delete
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We’ll follow the same principle we’ve applied in all the operations up to this point, but this time I’m going to start by adding the functionality to
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     for deleting a record
    
    
     
      by ID:
     
    
   </p>
   <pre class="source-code">
        public async Task DeleteEmployeeById(int id)
        {
            using (var sqlConnection = new
                SqlConnection("YOURCONNECTIONSTRING"))
            {
                var sql = "DELETE FROM Employees WHERE Id =
                    @employeeId";
                await sqlConnection.ExecuteAsync(
                    sql,
                    new { employeeId = id }
                );
            }
        }</pre>
   <p>
    
     Now, we can add an endpoint to use the service for record deletion, returning a
    
    <strong class="source-inline">
     
      NO CONTENT
     
    </strong>
    
     result
    
    <a id="_idIndexMarker363">
    </a>
    
     to
    
    <a id="_idIndexMarker364">
    </a>
    
     the client
    
    
     
      on success:
     
    
   </p>
   <pre class="source-code">
            app.MapDelete(
                "/employees/{id}",
                async (int id,
                       [FromServices] DapperService
                       dapperService) =&gt;
            {
                await dapperService.DeleteEmployeeById(id);
                return Results.NoContent();
            });</pre>
   <p>
    
     We’ve covered enough of Dapper that you should now be able to use it to perform basic simple CRUD operations on SQL databases through this powerful yet lightweight (micro) ORM.
    
    
     You could also try swapping out the SQL provider for one that supports another database, such as MySQL or PostgreSQL, to improve your experience of using Dapper to manage data in SQL for incoming requests on your
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     Dapper has its place, but Entity Framework is a more feature-rich alternative that is used for not only transacting data but also to manage the SQL database structure
    
    
     
      from code.
     
    
   </p>
   <p>
    
     Let’s take a
    
    <a id="_idIndexMarker365">
    </a>
    
     look
    
    <a id="_idIndexMarker366">
    </a>
    
     at how we can build the same functionality we’ve explored in the section, using
    
    
     
      Entity Framework.
     
    
   </p>
   <h2 id="_idParaDest-120">
    <a id="_idTextAnchor149">
    </a>
    
     Configuring Entity Framework in minimal API projects
    
   </h2>
   <p>
    
     Firstly, we
    
    <a id="_idIndexMarker367">
    </a>
    
     need
    
    <a id="_idIndexMarker368">
    </a>
    
     to use
    
    <a id="_idIndexMarker369">
    </a>
    
     Microsoft’s Entity Framework packages to configure the connection, referred to hereafter as
    
    <a id="_idIndexMarker370">
    </a>
    
     the
    
    <strong class="bold">
     
      context
     
    </strong>
    
     .
    
    
     This wording already creates a layer of abstraction from the database as we start to consider our data as members of
    
    
     
      this context.
     
    
   </p>
   <p>
    
     Start by installing the following packages via the package manager console in
    
    
     
      Visual Studio:
     
    
   </p>
   <pre class="console">
Install-Package Microsoft.EntityFrameworkCore
Install-Package Microsoft.EntityFrameworkCore.SqlServer
Install-Package Microsoft.EntityFrameworkCore.Tools</pre>
   <p>
    
     This ensures that all the libraries required to interact with SQL Server through Entity Framework are
    
    
     
      in place.
     
    
   </p>
   <p>
    
     Next, we
    
    <a id="_idIndexMarker371">
    </a>
    
     will
    
    <strong class="bold">
     
      scaffold
     
    </strong>
    
     the existing
    
    <strong class="source-inline">
     
      MyCompany
     
    </strong>
    
     database, again from the package manager console, using the connection string for
    
    
     
      the database:
     
    
   </p>
   <pre class="console">
Scaffold-DbContext "Your_Connection_String" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Context MyCompanyContext</pre>
   <p>
    <strong class="bold">
     
      Scaffolding
     
    </strong>
    
     means
    
    <a id="_idIndexMarker372">
    </a>
    
     that Entity Framework looks at the schema of the database and maps the tables to objects in your code.
    
    
     The result is a
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     , which wraps all of the different entities in the context.
    
    
     A series of models will also be created that are classes representing each of the entities.
    
    
     These are placed in the folder specified by the
    
    <strong class="source-inline">
     
      OutputDir
     
    </strong>
    
     switch used by the
    
    
     
      console command.
     
    
   </p>
   <p>
    
     Because I stated that I want the context to be called
    
    <strong class="source-inline">
     
      MyCompanyContext
     
    </strong>
    
     , a new class called
    
    <strong class="source-inline">
     
      MyCompanyContext
     
    </strong>
    
     has been generated in the
    
    
     <strong class="source-inline">
      
       Models
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p>
    
     In this class, you can see that a
    
    <strong class="source-inline">
     
      DbSet&lt;Employee&gt;
     
    </strong>
    
     called
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     has been added.
    
    
     A
    
    <strong class="source-inline">
     
      DbSet
     
    </strong>
    
     represents all the current records in a given database table.
    
    
     This is a collection representing each of the records in
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     , and by adding to, retrieving from, updating, or removing from this collection, we can indirectly change the corresponding SQL table.
    
    
     Let’s look at the generated code to further understand what is
    
    
     
      happening here.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      MyCompanyContext
     
    </strong>
    
     is a class derived from
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     .
    
    
     It represents the data source in use and provides a means of interacting with this source at a higher level of abstraction.
    
    
     When the class is instantiated,
    
    <strong class="source-inline">
     
      DbContextOptions
     
    </strong>
    
     is injected into it, which is then
    
    <a id="_idIndexMarker373">
    </a>
    
     passed
    
    <a id="_idIndexMarker374">
    </a>
    
     to
    
    <a id="_idIndexMarker375">
    </a>
    
     the base
    
    
     <strong class="source-inline">
      
       DbContext
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
public partial class MyCompanyContext : DbContext
{
    public MyCompanyContext()
    {
    }
    public MyCompanyContext(
        DbContextOptions&lt;MyCompanyContext&gt; options)
        : base(options)
    {
    }
    public virtual DbSet&lt;Employee&gt; Employees { get; set; }</pre>
   <p>
    
     Entity Framework then generates the code required to build the context, mapping business objects to tables in the database, allowing a model to
    
    
     
      be created:
     
    
   </p>
   <pre class="source-code">
    protected override void OnConfiguring(
        DbContextOptionsBuilder optionsBuilder) =&gt;
# warning To protect potentially sensitive information in
# your connection string, you should move it out of source
# code. You can avoid scaffolding the connection string by
# using the Name= syntax to read it from configuration –
# see https://go.microsoft.com/fwlink/?linkid=2131148. For
# more guidance on storing connection strings, see
# https://go.microsoft.com/fwlink/?LinkId=723263.</pre>
   <p>
    
     Entity Framework
    
    <a id="_idIndexMarker376">
    </a>
    
     is
    
    <a id="_idIndexMarker377">
    </a>
    
     instructed
    
    <a id="_idIndexMarker378">
    </a>
    
     in this example to use SQL Server with the specified connection string to model the entities based on the
    
    
     
      database schema:
     
    
   </p>
   <pre class="source-code">
       optionsBuilder.UseSqlServer("YOURCONNECTIONSTRING");
    protected override void OnModelCreating(
        ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;Employee&gt;(entity =&gt;
        {
            entity.HasNoKey();
            entity.Property(e =&gt; e.Address)
                .IsUnicode(false);
            entity.Property(e =&gt; e.City)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e =&gt; e.Country)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e =&gt; e.Id)
                .ValueGeneratedOnAdd();
            entity.Property(e =&gt; e.Name).IsUnicode(false);
            entity.Property(e =&gt; e.Phone)
                .HasMaxLength(200)
                .IsUnicode(false);
            entity.Property(e =&gt; e.PostalCode)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e =&gt; e.Region)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e =&gt; e.Salary)
                .HasColumnType("decimal(10, 2)");
        });
        OnModelCreatingPartial(modelBuilder);
    }
    partial void OnModelCreatingPartial(
        ModelBuilder modelBuilder);
}</pre>
   <p>
    
     Before we start
    
    <a id="_idIndexMarker379">
    </a>
    
     looking at communicating with the database through Entity Framework from the API endpoints, we have another piece of configuration
    
    
     
      to explore.
     
    
   </p>
   <p>
    
     It’s important to understand
    
    <a id="_idIndexMarker380">
    </a>
    
     how
    
    <strong class="bold">
     
      migrations
     
    </strong>
    
     are used by Entity Framework to change the database schema.
    
    
     A migration is a set of instructions to follow to make specific changes to a database.
    
    
     Whether to add a column to a table, add a new table, or remove a column, it can usually be done via
    
    
     
      a migration.
     
    
   </p>
   <p>
    
     Migrations keep Entity Framework as the single source of truth for your data by outlining how a database’s structural change should be managed, in addition
    
    
     
      to data.
     
    
   </p>
   <p>
    
     Let’s explore migrations by making a change to our
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table.
    
    
     We’re going to add a
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     column to the table.
    
    
     First, open the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     model that was generated in the
    
    <strong class="source-inline">
     
      Models
     
    </strong>
    
     folder and add
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     as a
    
    
     <strong class="source-inline">
      
       string
      
     </strong>
    
    
     
      property:
     
    
   </p>
   <pre class="source-code">
  public string Title { get; set; }</pre>
   <p>
    
     Then, we head back to the package manager console to input a command to add the migration.
    
    
     This command asks Entity Framework to look for any changes to any of the
    
    <strong class="source-inline">
     
      DbSet
     
    </strong>
    
     objects in the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     .
    
    
     It will then generate C# code that will eventually run SQL on the database to commit
    
    
     
      the changes.
     
    
   </p>
   <p>
    
     Use the
    
    <strong class="source-inline">
     
      Add-Migration
     
    </strong>
    
     command in the package manager console, followed by a string
    
    <a id="_idIndexMarker381">
    </a>
    
     that
    
    <a id="_idIndexMarker382">
    </a>
    
     gives
    
    <a id="_idIndexMarker383">
    </a>
    
     the migration
    
    
     
      a name:
     
    
   </p>
   <pre class="console">
PM&gt; Add-Migration "Add_title_to_employees_table"</pre>
   <p class="callout-heading">
    
     Migration names
    
   </p>
   <p class="callout">
    
     When naming a migration, it is good practice to provide a summary of the changes these migrations make – for
    
    
     
      example,
     
    
    
     <strong class="source-inline">
      
       changed_datatype_of_salary_column_to_decimal
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Entity Framework will then build the project and add a new class for the migration in the
    
    <strong class="source-inline">
     
      Migrations
     
    </strong>
    
     folder, creating the folder if it does not
    
    
     
      yet exist:
     
    
   </p>
   <pre class="source-code">
public partial class add_title_field_to_employees :
    Migration
{
    /// &lt;inheritdoc /&gt;
    protected override void Up(
        MigrationBuilder migrationBuilder)
    {
        migrationBuilder.AddColumn&lt;string&gt;(
            name: "Title",
            table: "Employees",
            type: "nvarchar(max)",
            nullable: false,
            defaultValue: "");
    }
    /// &lt;inheritdoc /&gt;
    protected override void Down(
        MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropColumn(
            name: "Title",
            table: "Employees");
    }
}</pre>
   <p>
    
     You can see that
    
    <a id="_idIndexMarker384">
    </a>
    
     the migration specifies that a column is to be added
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       Title
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     To commit this to the database, we can
    
    <a id="_idTextAnchor150">
    </a>
    
     write another simple command in the package
    
    
     
      manager console:
     
    
   </p>
   <pre class="console">
Update-Database</pre>
   <p>
    
     If all went as expected, you’ll see that the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     table in the database has a
    
    
     <strong class="source-inline">
      
       Title
      
     </strong>
    
    
     
      column.
     
    
   </p>
   <p>
    
     Now that we’ve covered the basics of its configuration, let’s update the endpoints in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     to
    
    <a id="_idIndexMarker385">
    </a>
    
     use
    
    <a id="_idIndexMarker386">
    </a>
    
     
      Entity
     
    
    
     <a id="_idIndexMarker387">
     </a>
    
    
     
      Framework.
     
    
   </p>
   <h1 id="_idParaDest-121">
    <a id="_idTextAnchor151">
    </a>
    
     Performing CRUD operations with Entity Framework
    
   </h1>
   <p>
    
     We have a
    
    <a id="_idIndexMarker388">
    </a>
    
     new dependency in the form
    
    <a id="_idIndexMarker389">
    </a>
    
     of the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     .
    
    
     We should register it within the
    
    <strong class="source-inline">
     
      Main
     
    </strong>
    
     method in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     for use during
    
    
     
      a request:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddScoped&lt;MyCompanyContext&gt;();
var app = builder.Build();</pre>
   <p>
    
     As we did in the previous examples using Dapper, we will create a new service for managing CRUD operations for
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     objects.
    
    
     This time, we will be more specific with the naming, and call
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       EmployeeService
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     , start by adding a constructor, to which we can pass the
    
    
     
      registered context:
     
    
   </p>
   <pre class="source-code">
public class EmployeeService
{
    private MyCompanyContext _companyContext;
    public EmployeeService(
        MyCompanyContext myCompanyContext)
    {
        _companyContext = myCompanyContext;
    }</pre>
   <p>
    
     Then, define all the
    
    <a id="_idIndexMarker390">
    </a>
    
     functions
    
    <a id="_idIndexMarker391">
    </a>
    
     that will be needed for CRUD operations
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       MyCompanyContext
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
    public async Task AddEmployee(Employee employee)
    {
        await _companyContext.Employees
            .AddAsync(employee);
        await _companyContext
            .SaveChangesAsync();
    }
    public async Task&lt;Employee&gt; GetEmployeeById(int id)
    {
        var result =  await _companyContext.Employees
            .FirstOrDefaultAsync(x =&gt; x.Id == id);
        if(result == null)
        {
            throw new EmployeeNotFoundException(id);
        }
        return result;
    }
    public async Task UpdateEmployee(Employee employee)
    {
        var employeeToUpdate = await GetEmployeeById(
            employee.Id);
        _companyContext.Employees.Update(employeeToUpdate);
        await _companyContext.SaveChangesAsync();
    }
    public async Task DeleteEmployee(Employee employee)
    {
        _companyContext.Remove(employee);
        await _companyContext.SaveChangesAsync();
    }
}</pre>
   <p>
    
     Finally, we’ll create a customer exception called
    
    <strong class="source-inline">
     
      EmployeeNotFoundException
     
    </strong>
    
     , which can we throw in
    
    <a id="_idIndexMarker392">
    </a>
    
     the
    
    <a id="_idIndexMarker393">
    </a>
    
     event a requested employee is not present in the
    
    
     
      data source:
     
    
   </p>
   <pre class="source-code">
public class EmployeeNotFoundException : Exception
{
    public EmployeeNotFoundException(int id)
        : base(
            $"Employee with id {id} could not be found")
    {
    }
}</pre>
   <p>
    
     In each of these new functions within
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     , we are interacting with the database via the
    
    <strong class="source-inline">
     
      Employees
     
    </strong>
    
     collection sitting within
    
    <strong class="source-inline">
     
      MyCompanyContext
     
    </strong>
    
     .
    
    
     We are then committing the changes we have made to this collection to the database
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       SaveChangesAsync();
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Take note of the reusability of one of the functions,
    
    <strong class="source-inline">
     
      GetEmployeeById
     
    </strong>
    
     .
    
    
     In most CRUD operations, we need to be able to target the affected
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object, and we can reuse this function for this.
    
    
     To guard against the potential of an employee not being found in the collection, there is a custom exception that can be thrown.
    
    
     This is useful for the API endpoint because it means it can cater its response to a specific exception if it occurs, in this case, returning a
    
    <strong class="source-inline">
     
      404 NOT FOUND
     
    </strong>
    
     status code
    
    
     
      if necessary.
     
    
   </p>
   <p>
    
     We’ve established that in Entity Framework, interacting with a database table means interacting with a collection in C#.
    
    
     This is apparent in
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     , where LINQ queries are used in place of the SQL queries that would have been used in a direct SQL connection or a micro-ORM such
    
    
     
      as Dapper.
     
    
   </p>
   <p>
    
     With the establishment of
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     , the API endpoints in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     can be altered to use Entity Framework rather than the previously used Dapper.
    
    
     But to what extent do they need to
    
    
     
      be changed?
     
    
   </p>
   <p>
    
     The answer to
    
    <a id="_idIndexMarker394">
    </a>
    
     this
    
    <a id="_idIndexMarker395">
    </a>
    
     is – not very much at all, thanks to the abstraction we’ve created in the form of
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     .
    
    
     We’ve used an injected dependency to manage the database interaction, with the functions within having the same name or
    
    <strong class="bold">
     
      signature
     
    </strong>
    
     as each other, meaning that we can just swap out the injected
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     for the new
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     that uses
    
    
     
      Entity Framework.
     
    
   </p>
   <p>
    
     Head back to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     and register
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     for
    
    
     
      dependency injection:
     
    
   </p>
   <pre class="source-code">
    var builder = WebApplication.CreateBuilder(args);
    builder.Services.AddScoped&lt;MyCompanyContext&gt;();
    builder.Services.AddScoped&lt;EmployeeService&gt;();
    var app = builder.Build();</pre>
   <p>
    
     Double-click the parameter that currently passes in
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     to any of the mapped endpoints.
    
    
     In Visual Studio, you can rename this object
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     by holding
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     and pressing the
    
    <em class="italic">
     
      R
     
    </em>
    
     
      key twice.
     
    
   </p>
   <p>
    
     After renaming, all other occurrences will also be updated.
    
    
     You shouldn’t have any errors as long as the functions called by each endpoint have the same signature regardless of whether you’re using
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       EmployeeService
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The following code shows the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint for creating an
    
    <strong class="source-inline">
     
      employee
     
    </strong>
    
     after it has been updated to
    
    
     
      use
     
    
    
     <strong class="source-inline">
      
       EmployeeService
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
    app.MapPost(
        "/employees",
        async (Employee employee,
               [FromServices] EmployeeService
               employeeService) =&gt;
    {
        await employeeService.AddEmployee(employee);
        return Results.Created();
    });</pre>
   <p>
    
     This was a rather whirlwind introduction to Entity Framework, which has a great deal more in the way of features.
    
    
     However, the main focus is on a minimal API’s interaction with databases in
    
    <a id="_idIndexMarker396">
    </a>
    
     an
    
    <a id="_idIndexMarker397">
    </a>
    
     abstracted manner, and this example is enough to get you started on your
    
    
     
      ORM journey.
     
    
   </p>
   <p>
    
     Let’s review the things we’ve learned about Dapper and Entity Framework in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-122">
    <a id="_idTextAnchor152">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     This chapter has introduced the use of Dapper and Entity Framework to provide an abstraction layer between minimal API endpoints and
    
    
     
      relational databases.
     
    
   </p>
   <p>
    
     We opened with an introduction to ORMs, defining their role in simplifying database interactions in minimal APIs, before providing an overview of the various features available for interaction with
    
    
     
      data sources.
     
    
   </p>
   <p>
    
     We then stepped through the configuration of Dapper, adding the relevant libraries and providing a dedicated
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     that could be used on minimal API endpoints with dependency injection.
    
    
     Once we had configured Dapper, we created the SQL queries in
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     and linked the endpoints to the service to provide an end-to-end link between API and database
    
    
     
      via Dapper.
     
    
   </p>
   <p>
    
     Having established CRUD operations on the database with Dapper, we contrasted this by configuring Entity Framework, and then performed the equivalent setup of a service for completing
    
    
     
      CRUD operations.
     
    
   </p>
   <p>
    
     Finally, the original
    
    <strong class="source-inline">
     
      DapperService
     
    </strong>
    
     was swapped out for the new
    
    <strong class="source-inline">
     
      EmployeeService
     
    </strong>
    
     using Entity Framework, demonstrating the versatility of injecting an abstraction as a dependency for
    
    
     
      data management.
     
    
   </p>
   <p>
    
     There’s no doubt that integrating data sources via ORMs is a significant aspect of building a minimal API.
    
    
     When managing data, depending on the way the data is requested, the potential for bottlenecks in performance can be significant.
    
    
     We will explore this concept and ways that these bottlenecks can be mitigated in the
    
    
     
      next chapter.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-123" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor153">
    </a>
    
     Part 3 - Optimal Minimal APIs
    
   </h1>
   <p>
    
     To build high-performing, scalable APIs, it’s essential to fine-tune your system’s performance and take advantage of advanced programming techniques.
    
    
     This part covers how to identify bottlenecks, employ asynchronous programming, and implement caching strategies to improve efficiency and
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B20968_10.xhtml#_idTextAnchor154">
      <em class="italic">
       
        Chapter 10
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Profiling and Identifying Bottlenecks
      
     </em>
    </li>
    <li>
     <a href="B20968_11.xhtml#_idTextAnchor165">
      <em class="italic">
       
        Chapter 11
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Utilizing Asynchronous Programming for Scalability
      
     </em>
    </li>
    <li>
     <a href="B20968_12.xhtml#_idTextAnchor174">
      <em class="italic">
       
        Chapter 12
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Caching Strategies for Enhanced Performance
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>