- en: Native Libraries in .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的原生库
- en: In this chapter, we are going to learn about ncurses native libraries and how
    to extend console capabilities in .NET Core on Linux. We will also learn how to
    Interop with existing native code. This chapter will introduce the ncurses native
    library and Interop with existing native and Mono libraries. We will build a sample
    native library in C++ and we will also learn how to create an application that
    implements the new library and ncurses. The purpose of this chapter is to get
    an understanding of Interop with existing libraries, and the ability to extend
    console capabilities through implementing ncurses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习ncurses原生库以及如何在Linux上扩展.NET Core的控制台功能。我们还将学习如何与现有的原生代码进行互操作。本章将介绍ncurses原生库以及与现有原生和Mono库的互操作。我们将构建一个示例原生库（C++），并学习如何创建一个实现新库和ncurses的应用程序。本章的目的是了解与现有库的互操作，以及通过实现ncurses扩展控制台功能的能力。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to ncurses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ncurses简介
- en: Interop with existing native and Mono libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有原生和Mono库的互操作
- en: Building a sample native library (C++)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建示例原生库（C++）
- en: A sample application to implement the new library and ncurses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现新库和ncurses的示例应用程序
- en: Introduction to ncurses
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ncurses简介
- en: '**New curses** (**ncurses**) is an openly distributable library of functions
    that deals with an application''s **user interface** (**UI**) in text mode. It
    creates a wrapper over terminal abilities. ncurses is a free software, it is not
    an open source. It provides functions to make imaginary screen windows for logical
    calculations, print windows, and so on. Libraries for panels, menus, and forms
    use the ncurses library and extend the basic functionality of ncurses as required.
    We can make applications that contain numerous windows, menus, panels, and forms;
    windows can be overseen autonomously, can give scrollability, and can even be
    covered up.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**新curses**（**ncurses**）是一个公开可分发的函数库，用于处理文本模式下的应用程序的用户界面（**UI**）。它为终端功能创建了一个包装器。ncurses是免费软件，但它不是开源的。它提供了创建用于逻辑计算的虚拟屏幕窗口、打印窗口等功能。用于面板、菜单和表单的库使用ncurses库并扩展了ncurses的基本功能。我们可以创建包含多个窗口、菜单、面板和表单的应用程序；窗口可以自主管理，可以提供可滚动性，甚至可以覆盖。'
- en: Menus give the client a simple order determination choice, forms permit the
    formation of easy−to−use information sections and show windows, and panels stretch
    out the abilities of ncurses to manage covering and stacked windows. These are
    a portion of the essential things we can do with ncurses. As we progress, we will
    see how to build a native library using C++.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单为客户提供简单的顺序确定选择，表单允许形成易于使用的信息部分并显示窗口，面板扩展了ncurses管理覆盖和堆叠窗口的能力。这些都是我们可以使用ncurses完成的基本操作之一。随着我们的进展，我们将看到如何使用C++构建原生库。
- en: 'ncurses comes with the Visual Studio Code installation and we can download `ncurses-6.0.tar.gz`,
    from [http://ftp.gnu.org/pub/gnu/ncurses/](http://ftp.gnu.org/pub/gnu/ncurses/).
    After downloading, unzip and install ncurses 6.0 (the latest version at the time
    of writing this book):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ncurses随Visual Studio Code安装提供，我们可以从[http://ftp.gnu.org/pub/gnu/ncurses/](http://ftp.gnu.org/pub/gnu/ncurses/)下载`ncurses-6.0.tar.gz`（本书编写时的最新版本）。下载后，解压并安装ncurses
    6.0：
- en: '![](img/f3c379ea-c508-4e74-8fca-3099a47b75fc.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3c379ea-c508-4e74-8fca-3099a47b75fc.png)'
- en: 'Open the Terminal from the folder, `ncurses-6.0`, and run the following commands
    to install ncurses:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ncurses-6.0`文件夹打开终端，并运行以下命令安装ncurses：
- en: '`./configure`: Configure the build according to your environment'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./configure`：根据您的环境配置构建'
- en: '`make`: Make it'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make`：使其完成'
- en: '`su root`: Become root'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`su root`：成为root用户'
- en: '`make install`: Install it'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make install`：安装它'
- en: 'Let''s start with a simple application, `"Welcome to .NET Core 2.0"`, to understand
    how to start, use, alter, and close ncurses:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的应用程序`"Welcome to .NET Core 2.0"`开始，了解如何启动、使用、修改和关闭ncurses：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Write a function called `WelcomeMessage()` which returns void, and call it
    from `main,` as shown in the example. Let''s try to understand each function that
    we called inside the `WelcomeMessage` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`WelcomeMessage()`的函数，它返回void，并在`main`中调用它，如下例所示。让我们尝试理解在`WelcomeMessage`函数内部调用的每个函数：
- en: '`Initscr()`: This function initiates the Terminal in curses mode. It is typically
    the main curses method to call while introducing a program. A couple of uncommon
    methods, once in a while, should be called before it; these are `slk_init()`,
    `channel()`, `ripoffline()`, and `use_env()`. For different Terminal applications,
    `newterm()` might be called before `initscr()`. The `initscr()` code decides the
    Terminal sort and instates all curses data structures. `initscr()` likewise makes
    the main call, `refresh(),` to clear the screen. On the off chance that errors
    arise, `initscr()` composes an error message to standard error and exits; otherwise,
    a pointer comes back to stdscr. A program that yields to more than one Terminal
    should utilize the `newterm()` routine for every Terminal, rather than `initscr()`.
    The method `newterm()` ought to be called once for every Terminal.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Initscr()`：这个函数在 curses 模式下初始化终端。通常在介绍程序时，这是主要的 curses 方法。偶尔，应该在其之前调用一些不常用的方法；这些是
    `slk_init()`、`channel()`、`ripoffline()` 和 `use_env()`。对于不同的终端应用程序，`newterm()`
    可能会在 `initscr()` 之前被调用。`initscr()` 代码决定终端排序并建立所有 curses 数据结构。`initscr()` 同样执行主要的调用，`refresh()`，以清除屏幕。如果出现错误，`initscr()`
    会将错误信息写入标准错误并退出；否则，会返回到 `stdscr`。如果一个程序需要响应多个终端，则应该为每个终端使用 `newterm()` 例程，而不是
    `initscr()`。`newterm()` 方法应该为每个终端调用一次。'
- en: '`printw("Welcome to .NET Core 2.0")`: This prints `" Welcome to .NET Core 2.0"`
    on the screen. `printw()` is a class of functions:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printw("Welcome to .NET Core 2.0")`：这个函数会在屏幕上打印 `"Welcome to .NET Core 2.0"`。`printw()`
    是一类函数：'
- en: '**`printw()`**: This function works similar to `printf()` with the exception
    that it prints the information on a window called stdscr and with the added capability
    of printing at any position on the screen at the current (*y, x*) coordinates.
    If the cursor is at coordinates (0,0), the string is printed at the left corner
    of the window.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`printw()`**：这个函数与 `printf()` 类似，不同之处在于它将信息打印在名为 stdscr 的窗口上，并增加了在任何屏幕位置（当前
    (*y, x*) 坐标）打印的能力。如果光标位于坐标 (0,0)，字符串将打印在窗口的左上角。'
- en: '`mvprintw()`: This function can be used to move the cursor to a position and
    then print. If you want to move the cursor first and then print using the `printw()`
    function, use `move()` first and then use `printw()`. I think instead of using
    `move()` and `printw()`, using `mvprintw()` is better, because you get the flexibility
    to manipulate.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvprintw()`：这个函数可以用来移动光标到某个位置然后打印。如果你想先移动光标然后使用 `printw()` 函数打印，先使用 `move()`
    函数，然后使用 `printw()`。我认为使用 `mvprintw()` 比使用 `move()` 和 `printw()` 更好，因为它提供了更多的灵活性。'
- en: '**`wprintw()`** and **`mvwprintw()`**:These two functions are similar to the
    preceding two functions, except that they print in the corresponding window given
    as an argument.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`wprintw()`** 和 **`mvwprintw()`**：这两个函数与前面两个函数类似，不同之处在于它们在作为参数给出的相应窗口中打印。'
- en: '`vwprintw()`: This function is similar to `vprintf()`. This can be used when
    a variable number of arguments are to be printed.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vwprintw()`：这个函数类似于 `vprintf()`。当需要打印可变数量的参数时，可以使用此函数。'
- en: The earlier program demonstrates how easy it is to use `printw`. You just feed
    the message to be shown on the screen, then it does what you want. When we call `printw`,
    the information is really composed for an imaginary window, which isn't refreshed
    on the screen yet. The activity of `printw` is to refresh a couple of banners
    and information structures and compose the information to a support as compare
    to `stdscr()`. With a specific end goal of demonstrating it on the screen, we
    have to call `refresh()`, and advise the curses framework to dump the substance
    on the screen. The logic behind this is to enable the software engineer to do
    different updates on the imaginary screen or windows, and do a revive once all
    his/her screen refresh is finished.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的程序演示了使用 `printw` 的简便性。你只需将要在屏幕上显示的消息传递给函数，然后它就会按照你的意愿执行。当我们调用 `printw` 时，信息实际上是为一个虚拟窗口编写的，这个窗口还没有在屏幕上刷新。`printw`
    的活动是刷新一些横幅和信息结构，并将信息写入支持文件而不是 `stdscr()`。为了在屏幕上显示它，我们必须调用 `refresh()`，并通知 curses
    框架将内容输出到屏幕。背后的逻辑是允许软件开发者对虚拟屏幕或窗口进行不同的更新，并在完成所有的屏幕刷新后进行一次刷新。
- en: All these functions take the *y* coordinate first and after that, *x* in their
    arguments. A typical slip up by beginners is to pass *x*,*y* in a specific order.
    In the event that you are doing an excess amount of manipulations of (*y*, *x*)
    coordinates, consider isolating the screen into windows and control every one
    independently.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '所有这些函数首先传递*y*坐标，然后是*x*坐标。初学者常见的错误是按照特定的顺序传递*x*、*y*。如果你在进行大量的(*y*，*x*)坐标操作，考虑将屏幕隔离成窗口并独立控制每一个。 '
- en: '`Move(row,col)`: The function `move()` moves the cursor to the desired position
    by passing row and column values.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Move(row,col)`: 该函数`move()`通过传递行和列值将光标移动到所需位置。'
- en: '**`Addch(ch | A_attribute)`:** This function is utilized to print a character
    at the current cursor position on the stdscr window. We can pass attributes to
    print characters based on the attribute, for instance, `addch(ch |A_Bold |A_underline)` will
    print characters in bold and underlined. The following specified attributes characterized
    in `<ncurses.h>` can be passed to functions `attron()`, `attroff()`, and the `attrset()`
    , `attron()` functions turn on the attribute, and correspondingly `attoff()` turns
    off the attribute. To set the quality for a window, we should utilize `attrset(),`
    for instance, in the event that we compose `attrset(A_NORMAL)`, it sets a typical
    show with no feature for a window, and it turns off all attributes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Addch(ch | A_attribute)`:** 此函数用于在stdscr窗口的当前光标位置打印一个字符。我们可以传递属性来根据属性打印字符，例如，`addch(ch
    |A_Bold |A_underline)`将打印加粗和下划线的字符。以下在`<ncurses.h>`中指定的属性可以传递给`attron()`、`attroff()`和`attrset()`、`attron()`函数，`attron()`函数打开属性，相应地`attoff()`关闭属性。要设置窗口的质量，我们应该使用`attrset()`，例如，如果我们编写`attrset(A_NORMAL)`，它将设置一个没有特征的普通显示窗口，并关闭所有属性。'
- en: 'We can use multiple attributes at the same time using `OR` `(|)` with the characters
    passed to `addch()`. They are as shown in the following table:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`OR` `(|)`与传递给`addch()`的字符同时使用多个属性。如下表所示：
- en: '| **Sr. No.** | **Attribute name** | **Attribute use** |'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **序号** | **属性名称** | **属性用途** |'
- en: '| 1 | `A_NORMAL` | Normal display (no highlight) |'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | `A_NORMAL` | 正常显示（无高亮） |'
- en: '| 2 | `A_UNDERLINE` | Underlining |'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | `A_UNDERLINE` | 下划线 |'
- en: '| 3 | `A_BOLD` | Extra bright or bold |'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | `A_BOLD` | 额外的明亮或粗体 |'
- en: '| 4 | `A_PROTECT` | Protected mode |'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | `A_PROTECT` | 保护模式 |'
- en: '| 5 | `A_INVIS` | Invisible or blank mode |'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | `A_INVIS` | 不可见或空白模式 |'
- en: '| 6 | `A_ALTCHARSET` | Alternate character set |'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 6 | `A_ALTCHARSET` | 替代字符集 |'
- en: '| 7 | `A_CHARTEXT` | Bit-mask to extract a character |'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 7 | `A_CHARTEXT` | 提取字符的位掩码 |'
- en: '| 8 | `A_DIM` | Half bright |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 8 | `A_DIM` | 半亮度 |'
- en: '| 9 | `A_BLINK` | Blinking |'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 9 | `A_BLINK` | 闪烁 |'
- en: '| 10 | `A_REVERSE` | Reverse video |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 10 | `A_REVERSE` | 反转视频 |'
- en: '| 11 | `A_STANDOUT` | Best highlighting mode of the Terminal |'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11 | `A_STANDOUT` | 终端的最佳高亮模式 |'
- en: '| 12 | `COLOR_PAIR(n)` | Color-pair number *n* |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 12 | `COLOR_PAIR(n)` | 颜色对编号 *n* |'
- en: 'If we want to print a character in a specific location or cursor position,
    we can use the following functions, instead of using the `move()` and `addch()` functions:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想在特定位置或光标位置打印一个字符，可以使用以下函数，而不是使用`move()`和`addch()`函数：
- en: '`mvaddch()`: This function is used to print characters at the desired location
    by passing the cursor location, for example, `` `mvaddch(row,col,ch)` ``'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvaddch()`: 此函数通过传递光标位置来打印所需位置的字符，例如，`mvaddch(row,col,ch)`'
- en: '`waddch()`: This function is useful for printing characters at the present
    cursor location in a specified window'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waddch()`: 此函数用于在指定窗口中打印当前光标位置的字符'
- en: '`mvwaddch()`: This function is used to print characters at a definite cursor
    location in a specific window by passing row, column, character, and window'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvwaddch()`: 此函数通过传递行、列、字符和窗口来在特定窗口中打印确定的光标位置的字符'
- en: '`refresh()`: This function checks the window and updates only the bit which
    has been changed. This improves execution and offers more significant flexibility.
    A beginners'' common error is to not call `refresh()` after they did some refreshing
    through the `printw()` class of functions.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh()`: 此函数检查窗口并仅更新已更改的位。这提高了执行效率并提供了更大的灵活性。初学者常见的错误是在通过`printw()`类函数进行一些刷新操作后没有调用`refresh()`。'
- en: '**`getch()`:** This function sits tight for the client to press a key, unless
    you stipulated a timeout, and when the client presses a key, the matching integer
    number gets returned. At that point, we can check that the value came back with
    the constants characterized in `curses.h`, to compare against the keys you need.
    On the off chance that it is a normal character, the integer number value will
    be equal to the character, otherwise it restores a number which can be coordinated
    with the constants characterized in `curses.h`. For instance, if the client presses
    *F1*, the number returned is `265`. This can be checked utilizing the full scale
    `KEY_F()`, characterized in `curses.h`. This makes reading keys convenient and
    simple to oversee.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`getch()`:** 这个函数会等待客户端按键，除非你指定了超时时间，当客户端按下按键时，会返回相应的整数编号。此时，我们可以检查返回的值是否与
    `curses.h` 中定义的常量相符，以比较所需的按键。如果是一个普通字符，整数编号将等于该字符，否则将恢复一个可以与 `curses.h` 中定义的常量相对应的数字。例如，如果客户端按下
    *F1*，返回的数字是 `265`。这可以通过 `curses.h` 中定义的 `KEY_F()` 完成检查。这使得读取按键变得方便且易于管理。'
- en: '`endwin()`: This function ends the curses mode, else our Terminal may behave unusually
    after the program stops. `endwin()` frees up the memory taken by the curses subsystem
    and its data structures, and puts the Terminal in normal mode. This function must
    be called when we are finished with the curses mode.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endwin()`: 这个函数用于结束 curses 模式，否则程序停止后我们的终端可能会出现异常行为。`endwin()` 释放了 curses
    子系统和其数据结构占用的内存，并将终端置于正常模式。当完成 curses 模式时，必须调用此函数。'
- en: A program should reliably call `endwin()` before quickly leaving or closing
    curses mode. This function restores `tty` modes, moves the cursor to the lower
    left-hand corner of the screen, and resets the Terminal into the best non-visual
    mode. Calling `revive()` or `doupdate()` after a short escape, makes the program
    go to visual mode. The `isendwin()` routine returns `TRUE` if `endwin()` has been
    called with no subsequent calls to `wrefresh()`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序应该在快速离开或关闭 curses 模式之前可靠地调用 `endwin()`。此函数恢复 `tty` 模式，将光标移动到屏幕的左下角，并将终端重置为最佳的非视觉模式。在短暂的逃避之后调用
    `refresh()` 或 `doupdate()`，程序将进入视觉模式。`isendwin()` 例程在未调用 `wrefresh()` 的后续调用之后调用
    `endwin()` 时返回 `TRUE`。
- en: 'To run this program in Ubuntu, ncurses should be installed on the system, otherwise
    during compilation, we will get an error stating `ncurses.h:no such file or directory` and
    compilation will terminate. Use the following command to install ncurses:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '要在 Ubuntu 上运行此程序，系统上必须安装 ncurses，否则在编译时，我们将得到一个错误，指出 `ncurses.h: no such file
    or directory`，并且编译将终止。使用以下命令安装 ncurses：'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command installs the latest version of the ncurses library onto
    the system. Once installation is done, open Visual Studio Code, go to File, and click
    on New File—it opens up a new untitled page. Write code as in the earlier example
    and save it at your desired location. Rename the file and give it an extension
    of `.c` or whatever suits your requirements. In this example, we created a file
    called `IntoToNcurses.c`. Run the following command to execute this program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将最新版本的 ncurses 库安装到系统中。一旦安装完成，打开 Visual Studio Code，转到文件，然后点击新建文件——它将打开一个新未命名的页面。按照前面的例子编写代码，并将其保存到您希望的位置。重命名文件，并给它一个
    `.c` 扩展名或任何适合您需求的扩展名。在这个例子中，我们创建了一个名为 `IntoToNcurses.c` 的文件。运行以下命令来执行此程序。
- en: 'To compile a program, we use the following command syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序，我们使用以下命令语法：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出可以在以下屏幕截图中看到：
- en: '![](img/b037ef46-6dba-4c53-bd93-403e5e7f6ec8.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b037ef46-6dba-4c53-bd93-403e5e7f6ec8.png)'
- en: In the preceding example, we are passing our C program with the extension `.c`.
    After the `-o` command, we pass the output, or rather the compiled filename. Here,
    we can give it any name we want, as we did with `ExampleOfNcurses` in this example.
    To include the ncurses library, we have to link it during compilation using `-lncurses,`
    otherwise the compilation will fail with the error `undefined reference to functions`,
    as those functions are ncurses functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们传递了具有 `.c` 扩展名的 C 程序。在 `-o` 命令之后，我们传递输出，或者更确切地说，是编译后的文件名。在这里，我们可以给它任何我们想要的名称，就像在这个例子中我们给
    `ExampleOfNcurses` 一样。为了包含 ncurses 库，我们必须在编译时使用 `-lncurses` 链接它，否则编译将因错误 `undefined
    reference to functions` 而失败，因为这些函数是 ncurses 函数。
- en: 'Once compilation is successful, it creates an output file, as shown in the
    following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译成功，它将创建一个输出文件，如下面的屏幕截图所示：
- en: '![](img/257ab9c4-5ba4-4ebc-bb17-0e90e7e41d14.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/257ab9c4-5ba4-4ebc-bb17-0e90e7e41d14.png)'
- en: 'We can run our program after the compilation is successful and the output file
    is created in the same folder. On the Terminal, pass the output filename as `./hello`
    to execute the program, as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成功并在同一文件夹中创建输出文件后，我们可以运行我们的程序。在终端中，将输出文件名作为`./hello`传递以执行程序，如下面的截图所示：
- en: '![](img/0e2b053c-8ba4-45c0-8dd6-54a28ec32d60.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e2b053c-8ba4-45c0-8dd6-54a28ec32d60.png)'
- en: Interop with existing native and Mono libraries
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与现有的原生和Mono库进行互操作
- en: Code reusability is one of the key principles in programming. For example, in
    an application we may use a certain functionality multiple times, so we keep it
    in a useful place and refer it from that place, whenever we need it in our application.
    Now, suppose our application implemented some common functionality which we can
    use in other applications, in this case, instead of writing the same logic again,
    we can create a library. It is easily distributable and reusable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用是编程中的关键原则之一。例如，在一个应用程序中，我们可能需要多次使用某个功能，所以我们将其保存在一个有用的位置，并在需要时从该位置引用它。现在，假设我们的应用程序实现了一些可以在其他应用程序中使用的通用功能，在这种情况下，我们不必再次编写相同的逻辑，我们可以创建一个库。它易于分发和重用。
- en: Asp.NET Core supports cross-platform programming, so any Linux user who has
    built many reusable libraries, API-like console support, and filesystem access,
    and wants to use them while writing code in ASP.NET Core, can access them. In
    this section, we will see how to access these native libraries (`.dll`) and Mono
    libraries (`.so`) in the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Asp.NET Core支持跨平台编程，因此任何已经构建了许多可重用库、类似API的控制台支持和文件系统访问的Linux用户，在编写ASP.NET Core代码时想要使用它们，都可以访问它们。在本节中，我们将了解如何在程序中访问这些原生库（`.dll`）和Mono库（`.so`）。
- en: '**Common Language Infrastructure** (**CLI**) helps to interoperate with existing
    code. We need to handle three basic problems to get things to work. First, where
    and how to specify the library, second, determining which function we want to
    invoke, and third, passing parameters. **Common Language Runtime** (**CLR**) provides
    Platform Invocation services—we call it P/Invoke. It enables managed code to call
    C, C++ functions in native libraries (DLLs). Let''s discuss what Platform Invoke
    is and how to use it.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用语言基础设施**（**CLI**）有助于与现有代码进行互操作。我们需要处理三个基本问题才能使事情正常工作。首先，在哪里以及如何指定库，其次，确定我们想要调用的函数，第三，传递参数。**通用语言运行时**（**CLR**）提供平台调用服务——我们称之为P/Invoke。它使托管代码能够调用原生库（DLLs）中的C、C++函数。让我们讨论一下平台调用是什么以及如何使用它。'
- en: Platform Invoke (P/Invoke)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台调用（P/Invoke）
- en: P/Invoke allows us to access structures and functions of unmanaged libraries
    from our managed code ASP.NET Core 2.0\. To use P/Invoke API, we use the `System.Runtime.InteropServices`
    namespace. This namespace allows us to access attributes the way we want, to use
    them with native components. The `DllImport` attribute is used for the declaration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke允许我们从我们的托管代码ASP.NET Core 2.0中访问未管理库的结构和函数。要使用P/Invoke API，我们使用`System.Runtime.InteropServices`命名空间。此命名空间允许我们以我们想要的方式访问属性，与原生组件一起使用。`DllImport`属性用于声明。
- en: If you want to dig more into the details, online resources are available at: [http://www.pinvoke.net](http://www.pinvoke.net/) .
    It has all the functions which are widely used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解细节，可以在以下在线资源找到更多信息：[http://www.pinvoke.net](http://www.pinvoke.net/)。它包含了所有广泛使用的函数。
- en: 'For example: `AllowSetForegroundWindow (user32)`—this enables the mentioned
    process to set the foreground window by utilizing the `SetForegroundWindow` method;
    the only condition is that the calling process should be able to set the foreground
    window. In C# code, we will write it as: `[DllImport("user32.dll")]`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`AllowSetForegroundWindow (user32)`—这通过利用`SetForegroundWindow`方法使提到的进程能够设置前台窗口；唯一条件是调用进程应该能够设置前台窗口。在C#代码中，我们将它写成：`[DllImport("user32.dll")]`
- en: '`static extern bool AllowSetForegroundWindow(int dwProcessId);`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`static extern bool AllowSetForegroundWindow(int dwProcessId);`'
- en: 'The following diagram demonstrates where Interop stands between native and
    managed code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了互操作在原生和托管代码之间的位置：
- en: '![](img/f12b02b9-a90e-4bb3-b0ec-de0e6266c45e.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f12b02b9-a90e-4bb3-b0ec-de0e6266c45e.png)'
- en: 'For example, if we want to use the `AnyPopup()` method of `user32.dll`, we
    use it as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用`user32.dll`中的`AnyPopup()`方法，我们将如下使用它：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this program, we used the `DllImport` attribute which calls the **dynamic-link
    library** (**DLL**), and we can use all these methods inside this DLL which is
    decorated with the `_declspec(dllexport)` keyword or `extern "c"`. We will discuss
    more about the import and export of methods from the library in the following
    section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了`DllImport`属性来调用**动态链接库**（**DLL**），我们可以使用此DLL中的所有方法，该DLL被`_declspec(dllexport)`关键字或`extern
    "c"`装饰。我们将在下一节中更详细地讨论从库中导入和导出方法。
- en: DLLImport attribute
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DLLImport属性
- en: 'The attribute, `[DllImport()]`, falls under the `DllImportAttribute` class.
    It provides the information required to call a function exported from an unmanaged
    DLL. The minimum prerequisite is that we should pass the name of the DLL which
    contains the entry point. We can apply this attribute straightforwardly to C#
    and C++ function definitions. Let''s check what the `DllImport` attribute has
    inside it. In the code window, click on `DllImport` and press the *F12* key (referred
    to as the go-to definition). This key is bound to the de-compile command in Visual
    Studio and will de-compile the selected type, if it can. Upon de-compilation,
    Visual Studio will display the de-compiled code in a new window. In the de-compiled
    code of `DllImport`, we can see each and every parameter. The code is very well
    commented and self-explanatory, as can be seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`[DllImport()]`属于`DllImportAttribute`类。它提供了调用从非托管DLL导出的函数所需的信息。最低先决条件是我们应该传递包含入口点的DLL的名称。我们可以直接将此属性应用于C#和C++函数定义。让我们来看看`DllImport`属性内部有什么。在代码窗口中，点击`DllImport`并按*F12*键（称为转到定义）。此键绑定到Visual
    Studio中的反编译命令，如果可以的话，将反编译选定的类型。在反编译后，Visual Studio将在新窗口中显示反编译的代码。在`DllImport`的反编译代码中，我们可以看到每个参数。代码注释非常详细，易于理解，如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can characterize the following attributes with the DLL name:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用DLL名称来描述以下属性：
- en: '`ThrowOnUnmappableChar`: This field is `False` by default, which means the `ThrowOnUnmappableChar` field
    is disabled. Best-fit mapping empowers the Interop marshaler to give a nearby
    coordinating character when no correct match exists, every time the Interop marshaler
    changes over an unmappable character. For example, the marshaler changes over
    the Unicode character into `c` for unmanaged techniques that acknowledge ANSI
    characters. A few characters do not have a best-fit portrayal; these are called
    unmappable characters. These unmappable characters are typically changed over
    to the default `?` ANSI character.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThrowOnUnmappableChar`：此字段默认为`False`，这意味着`ThrowOnUnmappableChar`字段被禁用。最佳匹配映射使Interop封装器能够在没有正确匹配时提供一个附近的协调字符，每次Interop封装器转换不可映射字符时都会这样做。例如，封装器将Unicode字符转换为`c`，以便于接受ANSI字符的非托管技术。一些字符没有最佳匹配表示；这些被称为不可映射字符。这些不可映射字符通常被转换为默认的`?`
    ANSI字符。'
- en: '`SetLastError`: By default, `SetLastError` is set to false, but in Visual Basic
    it is set to true by default. `GetLastError` is called by runtime marshaler and
    it caches the return value so it is not overwritten by other API calls. You can
    recover the error code by calling `GetLastWin32Error`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLastError`：默认情况下，`SetLastError`设置为false，但在Visual Basic中默认设置为true。`GetLastError`由运行时封装器调用，并缓存返回值，因此它不会被其他API调用覆盖。你可以通过调用`GetLastWin32Error`来恢复错误代码。'
- en: '`ExactSpelling`: The `ExactSpelling` field, as the name suggests, impacts the
    behavior of the `CharSet` field to figure out the exact entry point name to invoke.
    If the `ExactSpelling` field is set to `False`, Platform Invoke looks for the
    unmangled alias first; if the unmangled alias is not found, then it will look
    for the mangled name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExactSpelling`：正如其名所示，`ExactSpelling`字段会影响`CharSet`字段的行为，以确定要调用的确切入口点名称。如果`ExactSpelling`字段设置为`False`，平台调用首先查找未改名的别名；如果未找到未改名的别名，则它将查找改名的名称。'
- en: '`BestFitMapping`: By default, the `BestFitMapping` field is true. On the off
    chance that this field is true, it overrides any level settings for `System.Runtime.InteropServices.BestFitMappingAttribute`.
    Best-fit mapping empowers the Interop marshaler to give a nearby matching character
    when no correct match exists. For instance, the marshaler changes over the Unicode
    copyright character to `c` for unmanaged functions that acknowledge ANSI characters.
    A few characters do not have a best-fit representation, and these characters are
    called unmappable. Unmappable characters are generally changed over to the default
    `?` ANSI character.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestFitMapping`: 默认情况下，`BestFitMapping`字段为true。如果此字段为true，则覆盖`System.Runtime.InteropServices.BestFitMappingAttribute`的任何级别设置。最佳匹配映射允许Interop打包器在没有正确匹配的情况下提供一个接近匹配的字符。例如，打包器将Unicode版权字符转换为`c`，用于接受ANSI字符的未管理函数。一些字符没有最佳匹配表示，这些字符被称为不可映射字符。不可映射字符通常转换为默认的`?`
    ANSI字符。'
- en: '`CallingConvention`: Specifies the calling convention required to call methods
    implemented in unmanaged code. It is defined as an enumeration. The values of
    this enumeration are used to specify the calling conventions. This determines
    how a function is called, for example, the argument passing order behaviour is
    set to right to left, or stack maintenance responsibility such as the Calling
    function pops the arguments from the stack, and so on. There are fundamentally
    five calling convention fields: `Cdecl`, `StdCall`, `FastCall`, `ThisCall`, and
    `Winapi`. The default is `StdCall` for unmanaged functions with P/Invoke. More
    about this can be read at: [https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallingConvention`: 指定调用未管理代码中实现的方法所需的调用约定。它被定义为枚举类型。枚举值的用途是指定调用约定。这决定了函数是如何被调用的，例如，参数传递顺序行为设置为从右到左，或者堆栈维护责任，例如调用函数从堆栈中弹出参数，等等。基本上有五个调用约定字段：`Cdecl`、`StdCall`、`FastCall`、`ThisCall`和`Winapi`。对于使用P/Invoke的未管理函数，默认值为`StdCall`。更多关于此信息可以在以下链接中阅读：[https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx)。'
- en: '`StdCall`: The callee cleans the stack. To call unmanaged functions with Platform
    Invoke, this is the default convention.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StdCall`: 被调用方清理堆栈。要使用平台调用调用未管理函数，这是默认约定。'
- en: '`Cdecl`: This empowers calling functions with variable `args`, which means
    it is good to use for functions that use a variable number of parameters, for
    example, on the Windows platform, the `System.Runtime.InteropServices.CallingConvention.Cdecl`
    convention will act as: Argument-passing order | right to left'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cdecl`: 这允许调用具有可变`args`的函数，这意味着它适用于使用可变数量参数的函数，例如，在Windows平台上，`System.Runtime.InteropServices.CallingConvention.Cdecl`约定将作为：参数传递顺序
    | 从右到左'
- en: '`Winapi`: This part isn''t really a calling convention, rather it utilizes
    the default platform calling convention. For instance, in Windows, the default
    is `StdCall`, and on Windows CE .NET, it is `Cdecl`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Winapi`: 这部分实际上不是一个调用约定，而是使用默认平台调用约定。例如，在Windows中，默认的是`StdCall`，而在Windows
    CE .NET中是`Cdecl`。'
- en: '`ThisCall`:The primary parameter is the pointer and is put away in register
    ECX. Other parameters are pushed on the stack. This calling convention is utilized
    to call functions on classes exported from an unmanaged DLL.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThisCall`: 主要参数是指针，并存储在寄存器ECX中。其他参数被推送到堆栈上。这种调用约定用于调用从未管理DLL导出的类中的函数。'
- en: '`CharSet`: It determines the marshaling conduct of string parameters and is
    useful for indicating which entry point name to invoke (the correct name given
    or a name finishing with `net` or `As`). The default list part for C# is `CharSet.Ansi`
    and the default count part for C++ is `CharSet`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharSet`: 它确定字符串参数的打包行为，并有助于指示要调用的入口点名称（给出的正确名称或以`net`或`As`结尾的名称）。C#的默认列表部分为`CharSet.Ansi`，而C++的默认计数部分为`CharSet`。'
- en: '`Entrypoint`: You can determine the entry point name by providing a string
    showing the name of the DLL containing the entry point, or you can recognize the
    entry point by its ordinal. Ordinals are prefixed with the `#` sign. We can utilize
    the `DllImportAttribute.EntryPoint` field to indicate a DLL function by name or
    ordinal. On the off chance that the name of the function in your function definition
    is the same as the entry point in the DLL, you don''t need to expressly recognize
    the function with the `EntryPoint` field. Utilize syntax to demonstrate a name
    or ordinal:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entrypoint`：你可以通过提供一个显示包含入口点的 DLL 名称的字符串来确定入口点名称，或者你可以通过其序数来识别入口点。序数前带有 `#`
    符号。我们可以利用 `DllImportAttribute.EntryPoint` 字段通过名称或序数来指示 DLL 函数。如果函数定义中的函数名称与 DLL
    中的入口点相同，则不需要使用 `EntryPoint` 字段明确识别函数。使用语法来表示名称或序数：'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that you should prefix an ordinal with the pound sign (`#`). To know
    the entry point of DLL, we can use `DUMPBIN.exe` also. Just open the Developer
    Command Prompt and go to the DLL location and type the command, `DUMPBIN /EXPORTS
    ExampleDLL.dll`. Running this command returns information about the entry point
    and functions of DLL, shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该在序数前加上井号（`#`）。要了解 DLL 的入口点，我们也可以使用 `DUMPBIN.exe`。只需打开开发者命令提示符并转到 DLL 位置，然后输入命令，`DUMPBIN
    /EXPORTS ExampleDLL.dll`。运行此命令会返回有关 DLL 入口点和函数的信息，如下所示：
- en: '![](img/ad8257f3-195f-4b89-9120-cab4079bb6c6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad8257f3-195f-4b89-9120-cab4079bb6c6.png)'
- en: 'It gives all the information about DLL such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了有关 DLL 的所有信息，例如：
- en: It has one ordinal base
  id: totrans-99
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个序数基数
- en: It has three functions
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有三个函数
- en: The names of functions and their ordinal value
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称及其序数值
- en: There are many commands which we can use to get information about DLL. To find
    out all the commands, enter the following command, `Dumpbin.exe`. It gives us
    a list of commands that we can use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用许多命令来获取有关 DLL 的信息。要找出所有命令，请输入以下命令，`Dumpbin.exe`。它给出了我们可以使用的命令列表。
- en: Certain Unicode characters are changed over to risky characters, for example,
    the oblique punctuation line `\` character, which can unintentionally change a
    way. By setting the `ThrowOnUnmappableChar` field to genuine, you can flag the
    nearness of an unmappable character to the guest by tossing a special case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 Unicode 字符会被转换为危险字符，例如斜杠线 `\` 字符，这可能会无意中改变方式。通过将 `ThrowOnUnmappableChar`
    字段设置为真实值，你可以通过抛出特殊案例来标记对客机的不可映射字符的接近。
- en: You can't change the default values given by the `BestFitMapping` and `ThrowOnUnmappableChar`
    fields when passing a managed array whose components are ANSI characters or LPSTRs
    to an unmanaged safe exhibit. Best-fit mapping is constantly empowered and no
    special case is tossed. Know that this blend can trade-off your security information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当将包含 ANSI 字符或 LPSTR 的组件的托管数组传递给非托管安全展示时，你不能更改 `BestFitMapping` 和 `ThrowOnUnmappableChar`
    字段提供的默认值。最佳匹配映射始终启用，并且不会抛出特殊案例。了解这种混合可能会牺牲你的安全信息。
- en: Interop with existing native libraries with example
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例与现有本地库进行互操作
- en: Let's create DLL and create a header file (`.h`) inside it using C++, and we
    will see how we can consume it in our .NET Core application. In the following
    example, we created a DLL project for example, calling it `ExampleDLL`. Create
    a source `.cpp` file and a header file. Open the header file and write the following
    code, which returns the sum of two values. To consume public data and functions
    in class, we have to add the keyword `_declspec(dllexport)` before the public
    member which we want to consume from outside. While creating a DLL, we usually
    add the header file which contains the function or class prototype and we can
    export this using the `__declspec(dllexport)` keyword, while doing a declaration
    in the header file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 DLL 并在它内部使用 C++ 创建一个头文件（`.h`），然后我们将看到我们如何在 .NET Core 应用程序中消费它。在以下示例中，我们创建了一个名为
    `ExampleDLL` 的 DLL 项目。创建一个源 `.cpp` 文件和一个头文件。打开头文件并编写以下代码，该代码返回两个值的和。为了消费类中的公共数据和方法，我们必须在想要从外部消费的公共成员之前添加关键字
    `_declspec(dllexport)`。在创建 DLL 时，我们通常添加包含函数或类原型的头文件，我们可以使用 `__declspec(dllexport)`
    关键字来导出它，同时在头文件中进行声明。
- en: 'The named header file is `Calculate`, and the method name is `Sum` which takes
    two variables, integer `a` and integer `b`. Build this solution and open the project
    location. We can find DLL inside the debug folder:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的头文件是 `Calculate`，方法名称是 `Sum`，它接受两个变量，整数 `a` 和整数 `b`。构建此解决方案并打开项目位置。我们可以在调试文件夹中找到
    DLL：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the preceding code in the `Calculate.h` file, as shown in the following
    screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码添加到 `Calculate.h` 文件中，如图所示：
- en: '![](img/7dce40fb-ed0c-4507-9eab-4db64ceb5352.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dce40fb-ed0c-4507-9eab-4db64ceb5352.jpg)'
- en: 'This DLL is created inside the debug folder of the `ExampleDLL` project:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此 DLL 是在 `ExampleDLL` 项目的调试文件夹中创建的：
- en: '![](img/389d5c6e-5080-4021-9a4e-cc334ac57841.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/389d5c6e-5080-4021-9a4e-cc334ac57841.jpg)'
- en: 'Now we have our C++ DLL ready to be consumed from C# code. For example, I am
    creating a C# console application and we just need three lines of code to consume
    C++ DLL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备从 C# 代码中消费的 C++ DLL。例如，我正在创建一个 C# 控制台应用程序，我们只需要三行代码来消费 C++ DLL：
- en: Add namespace using `System.Runtime.InteropServices;`
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `System.Runtime.InteropServices;` 添加命名空间
- en: Add attribute using `[DllImport(@"<DLL Location>")]`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `[DllImport(@"<DLL Location>")]` 添加属性
- en: Add `static extern` functions with a compatible signature in your C# code, `public
    static extern int Sum(int a, int b);`
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 C# 代码中添加具有兼容签名的 `static extern` 函数，例如 `public static extern int Sum(int
    a, int b);`
- en: 'The C# script for the same is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 C# 脚本如下：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/916def90-ccea-4a10-a8f0-c75c82d9b46f.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/916def90-ccea-4a10-a8f0-c75c82d9b46f.jpg)'
- en: In the preceding section, we saw how to consume native libraries in a DLL. In
    this section, let's take the example of a Mono library. We will create a `.so`
    file in Ubuntu and will consume it from .NET Core. We will see the backward compatibility
    of .NET Core.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何在 DLL 中使用原生库。在本节中，让我们以 Mono 库为例。我们将在 Ubuntu 中创建一个 `.so` 文件，并从 .NET
    Core 中使用它。我们将看到 .NET Core 的向后兼容性。
- en: Mono is an open source development platform in light of the .NET Framework;
    it enables engineers to fabricate cross-platform applications with enhanced designer
    efficiency. Mono's .NET execution depends on the **Ecma** (**Ecma International—European
    association for standardizing information and communication systems**) norms for C# and
    the Common Language Infrastructure. Mono incorporates both engineer devices and
    the foundation expected to run .NET customer and server applications. Mono works
    cross platform, and runs on Linux, Microsoft Windows, and many others. All Mono
    dialects take advantage from many highlights of the runtime, similar to programmed
    memory administration, reflection, generics, and threading. Its highlights enable
    us to focus on composing your application, as opposed to composing framework foundation
    code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 是一个基于 .NET Framework 的开源开发平台；它使工程师能够以增强的设计师效率构建跨平台应用程序。Mono 的 .NET 执行依赖于
    Ecma（Ecma International—欧洲标准化信息和通信系统的协会）为 C# 和公共语言基础设施制定的规范。Mono 包含了运行 .NET 客户端和服务器应用程序所需的工程师设备和基础。Mono
    跨平台运行，可在 Linux、Microsoft Windows 和许多其他操作系统上运行。所有 Mono 方言都利用了运行时的许多亮点，例如程序内存管理、反射、泛型和线程。其特性使我们能够专注于编写应用程序，而不是编写框架基础代码。
- en: In this example, we are creating a simple library which displays an integer
    value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个简单的库，该库显示一个整数值。
- en: 'The code is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following command in the Terminal to create the `.so` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令以创建 `.so` 文件：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding command, `-shared -o` creates an (`.o`) object file and from
    the object file creates a `.so` file. `-fPIC` is used to declare a flag for the
    position independent code.`-fPIC` generates position-independent code which can
    be loaded from any memory location at runtime, so we can access static or global
    variables and methods at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`-shared -o` 创建了一个（`.o`）对象文件，并从对象文件创建了一个 `.so` 文件。`-fPIC` 用于声明一个表示位置无关代码的标志。`-fPIC`
    生成位置无关代码，可以在运行时从任何内存位置加载，因此我们可以在运行时访问静态或全局变量和方法。
- en: 'The preceding command can be seen in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令可以在以下屏幕截图中看到：
- en: '![](img/21d4bd6a-44e1-4271-9abe-e8fa39fb7967.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21d4bd6a-44e1-4271-9abe-e8fa39fb7967.png)'
- en: Now we will see how to consume this `.so` file in C# code. We created a C# file
    and added the namespace, `system.Runtime.InteropServices`, and gave the path of
    the `.so` file inside the `DLLImport` attribute.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何在 C# 代码中消费这个 `.so` 文件。我们创建了一个 C# 文件，并添加了命名空间 `system.Runtime.InteropServices`，并在
    `DLLImport` 属性中给出了 `.so` 文件的路径。
- en: 'The code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when we are done with the code and `DLLImport`, let''s discuss Mono, which
    we will use to create our executable and run this application. Mono is an open
    source tool which is created by the Microsoft subsidiary, Xamarin. It is a tool
    which makes the Linux developer''s life easy if they want to run Microsoft .NET
    applications on Linux or on any other cross platform. The latest version at the
    time of writing this book is Mono 5.4.0, which was released in October 2017\.
    This version supports the Core API of .NET Framework and also C# 7.0\. Mono provides
    several command line utilities, a few of the main useful commands are:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们完成代码和 `DLLImport` 后，让我们讨论 Mono，我们将使用它来创建我们的可执行文件并运行此应用程序。Mono 是一个由微软子公司
    Xamarin 创建的开源工具。如果 Linux 开发者想在 Linux 或任何其他跨平台上运行 Microsoft .NET 应用程序，它会使他们的生活变得容易。本书撰写时的最新版本是
    Mono 5.4.0，该版本于 2017 年 10 月发布。这个版本支持 .NET Framework 的 Core API 和 C# 7.0。Mono 提供了多个命令行实用程序，其中一些主要的常用命令是：
- en: '**Mono**: It is a **just-in-time** (**JIT**) compiler and it supports both
    32-bit and 64-bit types of systems. It also supports multiple platforms such as
    Microsoft Windows, Sun Solaris, Android, Apple iOS, macOS, Linux, Sony PlayStation,
    and so on. Mono runtime offers Code Execution, Garbage Collection, Code Generation,
    Exception Handling, OS interface, Thread management, Console access, and Security
    System, Program isolation using AppDomain. It allows a project to be extended
    in C# by reusing all existing C, C++ code libraries. As we said earlier, it is
    a JIT compiler. Since we have `ngen.exe` in Microsoft.NET to generate a pre-compiled
    code, which reduces the start up time, we use the following command with Mono
    to compile assemblies:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono**: 它是一个 **即时编译** (**JIT**) 编译器，它支持 32 位和 64 位系统类型。它还支持多个平台，如 Microsoft
    Windows、Sun Solaris、Android、Apple iOS、macOS、Linux、Sony PlayStation 等。Mono 运行时提供代码执行、垃圾回收、代码生成、异常处理、操作系统接口、线程管理、控制台访问和安全系统、使用
    AppDomain 的程序隔离。它允许项目通过重用所有现有的 C、C++ 代码库在 C# 中扩展。正如我们之前所说的，它是一个 JIT 编译器。由于我们在
    Microsoft.NET 中有 `ngen.exe` 来生成预编译代码，这可以减少启动时间，所以我们使用以下命令与 Mono 编译程序集：'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding command, `-O=all` instructs to enable all optimizations, then
    the Mono command tells Mono to compile the code to native code, `--aot` for a
    precompiled image
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`-O=all` 指示启用所有优化，然后 Mono 命令告诉 Mono 将代码编译为本地代码，`--aot` 用于预编译映像
- en: '**MCS:** It''s a C# compiler. Though many versions of compiler are available
    which are specific to the version, for example, `gmcs` compiler targets 2.0 mscorelib,
    `smcs` targets 2.1 mscorelib and moonlight applications (Silverlight implementation
    for mainly Linux), while `dmcs` targets 4.0 mscorlib. Now, the new compiler version
    MCS is present which takes the latest version by default. We can also specify
    which version we want to use. MCS runs with Mono runtime on a Linux machine, and
    with both .NET and Mono runtime on a Windows machine.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MCS**: 它是一个 C# 编译器。尽管有多个特定于版本的编译器版本可用，例如，`gmcs` 编译器针对 2.0 mscorelib，`smcs`
    针对的是 2.1 mscorelib 和 Moonlight 应用程序（主要针对 Linux 的 Silverlight 实现），而 `dmcs` 针对的是
    4.0 mscorlib。现在，新的编译器版本 MCS 已经出现，默认使用最新版本。我们也可以指定要使用哪个版本。MCS 在 Linux 机器上使用 Mono
    运行时，在 Windows 机器上使用 .NET 和 Mono 运行时。'
- en: '**Global Assembly Cache tool (Gacutil)**:This tool is used for maintaining
    versions of assemblies in a system''s global assembly cache.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局程序集缓存工具 (Gacutil)**: 此工具用于维护系统全局程序集缓存中的程序集版本。'
- en: '**XSP**:The web service and web application server of Mono.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSP**: Mono 的 Web 服务和 Web 应用程序服务器。'
- en: '**mono-config**: The format configuration of Mono runtime.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mono-config**: Mono 运行时的格式配置。'
- en: 'Install Mono using the following command. When we use `mcs`, it will install
    the latest version:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装 Mono。当我们使用 `mcs` 时，它将安装最新版本：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile this C# program in Visual Studio Code using the following command;
    it creates an `.exe` file at the same location from where we opened the Terminal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在 Visual Studio Code 中编译此 C# 程序；它从我们打开终端的位置创建一个 `.exe` 文件：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, it''s time to run and check if it is displaying the value `15`, which
    we have passed in our `.so` file, as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候运行并检查它是否显示我们传递到 `.so` 文件中的值 `15`，如下面的截图所示：
- en: '![](img/8483ac96-68eb-4044-bbf8-f0dbb761914d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8483ac96-68eb-4044-bbf8-f0dbb761914d.png)'
- en: 'To run `helloNative.exe`, use the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 `helloNative.exe`，请使用以下命令：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When not to use P/Invoke
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不应使用 P/Invoke 的情况
- en: 'Utilizing P/Invoke isn''t fitting for all C-style methods in DLLs. Let''s take
    an example where we create a string in a C++ program and display it in a C# application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DLL 中使用 P/Invoke 并不适合所有 C 风格的方法。让我们以一个在 C++ 程序中创建字符串并在 C# 应用程序中显示它的例子来说明：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, using P/Invoke, pass the library in the `DllImport` attribute:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 P/Invoke，通过 `DllImport` 属性传递库：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The trouble here is that we can't erase the memory for the unmanaged string
    returned by `msg`. Different methods called through P/Invoke restore a pointer
    and do not need to be deallocated by the client. For this situation, utilizing
    the marsheling is a more suitable approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们无法删除由 `msg` 返回的非托管字符串的内存。通过 P/Invoke 调用的不同方法恢复指针，并且不需要客户端释放。对于这种情况，使用
    marshaling 是一个更合适的方法。
- en: Building a sample native library (C++)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例原生库 (C++)
- en: 'In the previous section, we learned about cross-platform implementation, and
    how to Interop with existing native and Mono libraries. To demonstrate interoperability,
    we created small sample applications. Let''s start with building our first native
    library in C++. Follow these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了跨平台实现以及如何与现有的原生和 Mono 库进行互操作。为了展示互操作性，我们创建了小型示例应用程序。让我们从在 C++ 中构建我们的第一个原生库开始。按照以下步骤操作：
- en: 'Open Visual Studio and select Windows Desktop under Visual C++ and select the
    project type Dynamic-Link Library (DLL). In this example, we name the project
    `ExampleDLL` and provide the location where we want to create the project:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并在 Visual C++ 下选择 Windows 桌面，然后选择项目类型为动态链接库 (DLL)。在这个例子中，我们命名项目为
    `ExampleDLL` 并提供我们想要创建项目的位置：
- en: '![](img/7233f757-5e61-4390-93cf-684fba40b11f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7233f757-5e61-4390-93cf-684fba40b11f.png)'
- en: 'Right-click on the header files folder and create a new header file. In this
    example, we named it `Calculate.h`. The `Calculate` header file contains mathematical
    operations such as the summation of two integer numbers, multiplication, and division:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击头文件文件夹并创建一个新的头文件。在这个例子中，我们将其命名为 `Calculate.h`。`Calculate` 头文件包含数学运算，例如两个整数的求和、乘法和除法：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we defined a header called `Calculate`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为 `Calculate` 的头文件。
- en: '`extern "C"` is used to instruct that the compiler will use the C function
    naming convention, not C++. Most code uses this directive because C function names
    are clearer to understand than C++. `__declspec(dllexport)` is utilized for export.
    In Microsoft''s new versions of compiler, we can export data, functions, classes,
    or class member functions from a DLL utilizing this keyword, `__declspec(dllexport),`
    the export directive to the object file, so we don''t have to utilize a `.def`
    record. This accommodation is most obvious when endeavoring to export decorated
    C++ function names. Since there is no standard specification for name decoration,
    the name of an exported function may change between compiler versions. To export
    functions, the `__declspec(dllexport)` keyword must appear to the left side of
    the calling-convention keyword, if a keyword is indicated, for instance: `` `__declspec(dllexport)int
    Sum(int a, int b).` ``'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extern "C"` 用于指示编译器将使用 C 函数命名约定，而不是 C++。大多数代码使用此指令，因为 C 函数名称比 C++ 函数名称更容易理解。`__declspec(dllexport)`
    用于导出。在 Microsoft 编译器的新版本中，我们可以使用此关键字 `__declspec(dllexport)`、对象文件的导出指令从 DLL 中导出数据、函数、类或类成员函数，因此我们不需要使用
    `.def` 记录。这种便利性在尝试导出装饰过的 C++ 函数名称时最为明显。由于没有标准规范名称装饰，导出函数的名称可能在编译器版本之间发生变化。要导出函数，`__declspec(dllexport)`
    关键字必须出现在调用约定关键字左侧，如果指定了关键字，例如：`__declspec(dllexport)int Sum(int a, int b)`。'
- en: 'To export all public data members and functions in a class, the keyword must
    appear to the left side of the class name, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出类中的所有公共数据成员和函数，关键字必须出现在类名左侧，如下所示：
- en: '`Class __declspec(dllexport)int Calculations : public CPPObj { Class definition};`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class __declspec(dllexport)int Calculations : public CPPObj { 类定义 };`。'
- en: 'When building your DLL, we normally make a header file that contains the function
    models, as well as classes we are trading, and include `__declspec(dllexport)`
    to the announcements in the header file. To make our code more intelligible, we
    can define a macro for `__declspec(dllexport)` and use the macro with each symbol
    we are sending out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 DLL 时，我们通常创建一个包含函数模型以及我们要交换的类的头文件，并在头文件中包含 `__declspec(dllexport)`。为了使我们的代码更易于理解，我们可以为
    `__declspec(dllexport)` 定义一个宏，并使用该宏与每个我们发送出去的符号：
- en: '`# define DLLExplort __declspec(dllexport)`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`# define DLLExport __declspec(dllexport)`：'
- en: '![](img/2f169b8a-4b47-4e95-a204-d5c040fea205.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f169b8a-4b47-4e95-a204-d5c040fea205.png)'
- en: 'In the preceding example, we created a sample native library, and now we will
    see how we can access it. In the preceding code, we used `__declspec(dllexport)`;
    to acccess this DLL, we will use `DllImport`. Click on Add | New Project; under
    C#, select .NET Core Console Application. In this example, we called it `InteropWithCS`.
    Open the solution and add the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个示例原生库，现在我们将看到我们如何访问它。在前面的代码中，我们使用了 `__declspec(dllexport)`；要访问此
    DLL，我们将使用 `DllImport`。点击“添加 | 新项目”；在 C# 中选择 .NET Core 控制台应用程序。在这个例子中，我们称之为 `InteropWithCS`。打开解决方案并添加以下代码：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we are using `ExampleDLL` and doing our calculations, taking
    input for `number1` and `number2` values. The user can select an operation—sum,
    multiply, or divide by pressing the corresponding number. On option number input,
    we check the user option, use switch case, and display the result:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `ExampleDLL` 进行计算，并获取 `number1` 和 `number2` 的输入值。用户可以通过按相应的数字选择操作——求和、乘法或除法。在选项数字输入时，我们检查用户选项，使用
    switch case 并显示结果：
- en: '![](img/06576ed6-91ce-4006-9ac1-05013bf779ae.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06576ed6-91ce-4006-9ac1-05013bf779ae.png)'
- en: This simple application gives us an understanding of how to create our own native
    library in C or C++, and how to set functions which can be exported and accessed
    from other languages, such as C#. The intention of making it simple and using
    small functions, such as sum, and multiplication, for example, is to make you
    aware of the functionality, so that the user won't get distracted with the heavy
    logic of functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序让我们了解如何创建自己的 C 或 C++ 原生库，以及如何设置可以导出并从其他语言（如 C#）访问的函数。使其简单并使用小函数，例如求和和乘法，目的是让您了解功能，这样用户就不会被函数的复杂逻辑所分散。
- en: A sample application to implement new library and ncurses
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新库和 ncurses 的示例应用程序
- en: Now that we know the fundamentals, let's start building a sample application
    which implements ncurses. We will create a C# application which imports a C library
    or we can say `.so` file. This library has implemented ncurses functions. P/Invoke
    allows us to use those ncurses functions in our C# application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，让我们开始构建一个实现 ncurses 的示例应用程序。我们将创建一个 C# 应用程序，该程序导入一个 C 库，或者我们可以说是
    `.so` 文件。这个库实现了 ncurses 函数。P/Invoke 允许我们在 C# 应用程序中使用这些 ncurses 函数。
- en: 'First, we will create a C program which implements ncurses functions using
    an ncurses header. Let''s create an application which takes an input character;
    this character will be printed in a window, based on the number of rows and columns
    the user enters from the application where we will import this library. The function
    `drawCharOnWindow()` prints the character, based on the number of rows and columns
    present in the window; it takes character, row, and column as input parameters.
    We get the size of the window using the ncurses function, `getmaxyx(),` and if
    the user enters `q`, it quits the printing of the character. Open Visual Studio
    Code and write the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 C 程序，该程序使用 ncurses 头文件实现 ncurses 函数。让我们创建一个应用程序，该程序接受一个输入字符；这个字符将根据用户在应用程序中输入的行数和列数在一个窗口中打印。函数
    `drawCharOnWindow()` 根据窗口中存在的行数和列数打印字符；它接受字符、行和列作为输入参数。我们使用 ncurses 函数 `getmaxyx()`
    获取窗口的大小，如果用户输入 `q`，则退出字符的打印。打开 Visual Studio Code 并编写以下代码：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a library using the following command. It will create a `.so` file at
    the location from where the Terminal is open, and we run this command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个库。它将在终端打开的位置创建一个 `.so` 文件，我们运行此命令：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will use this library from the C# program using Mono. The following
    example application takes input from the user for the character we will print
    and its location, row, and column value. To use the library which implemented
    ncurses and to use it in C# , we need to use the namespace, `System.Runtime.InteropServices`
    and import DLL, using the `DllImport` attribute:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个库从 C# 程序中，以下示例应用程序从用户那里获取我们将打印的字符及其位置、行和列值。为了使用实现了 ncurses 的库并在 C#
    中使用它，我们需要使用命名空间 `System.Runtime.InteropServices` 并导入 DLL，使用 `DllImport` 属性：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To create the `.exe` file, use the following Mono command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `.exe` 文件，请使用以下 Mono 命令：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To run the program in Mono, use the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mono 中运行程序，请使用以下命令：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We learned how to create an executable using Mono and run it; now, we will
    see how to create a .NET Core 2.0 console application. Open Visual Studio Code
    and set the location on the Terminal where we want to create the application,
    and run the following command for the console application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Mono 创建一个可执行文件并运行它；现在，我们将看到如何创建一个 .NET Core 2.0 控制台应用程序。打开 Visual
    Studio Code 并设置在终端中我们想要创建应用程序的位置，然后运行以下命令以创建控制台应用程序：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the creation of the application, use the preceding code. Run this code
    using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序之后，使用前面的代码。使用以下命令运行此代码：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will take the input parameter, the character to print, row, and column location,
    and it will print that character in the window at the specified location, as shown
    here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它将获取输入参数，要打印的字符，行和列的位置，并在指定位置窗口中打印该字符，如图所示：
- en: '![](img/54a52beb-b049-4595-886e-52542d4f95fa.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54a52beb-b049-4595-886e-52542d4f95fa.png)'
- en: 'After passing this detail, it prints the character at the specified row and
    column on the screen, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过这个细节之后，它会在屏幕上打印出指定行和列的字符，如下所示：
- en: '![](img/b7ef9286-dc44-4944-9dec-ddf1b0c9bb73.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7ef9286-dc44-4944-9dec-ddf1b0c9bb73.png)'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the ncurses library and how to use this library
    in C or C++ programs. Also, we learned about how to reuse libraries created in
    Ubuntu or on a Linux machine which implemented ncurses in a .NET Core 2.0 application,
    using P/Invoke. We have seen how Mono works efficiently with a Linux machine and
    makes programming easy in .NET Core 2.0, using C# for Linux user. The next chapter
    will be very interesting, and it will be where we will build our first game, Tic-Tac-Toe,
    using .NET Core and we will learn about its compilation, building, and testing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 ncurses 库以及如何在 C 或 C++ 程序中使用这个库。我们还学习了如何在 .NET Core 2.0 应用程序中重用 Ubuntu
    或 Linux 机器上创建的库，使用 P/Invoke。我们看到了 Mono 如何高效地与 Linux 机器协同工作，使得在 .NET Core 2.0 中使用
    C# 进行 Linux 用户编程变得容易。下一章将非常有趣，我们将在这里使用 .NET Core 构建我们的第一个游戏，井字棋（Tic-Tac-Toe），我们将学习其编译、构建和测试。
