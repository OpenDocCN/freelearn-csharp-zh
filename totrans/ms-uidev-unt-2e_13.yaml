- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: UI Text and TextMeshPro
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 文本和 TextMeshPro
- en: We’ve spent some time with UI Text objects already as they are the one of most
    basic graphical UI elements. We discussed them briefly in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085)
    because it was pretty hard to start laying out UI without having anything to display
    visually. Text objects are also always children of new Buttons, which we discussed
    in the previous chapter. However, we haven’t explored the properties of Text objects
    or how to work with them in code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花费了一些时间与 UI 文本对象一起工作，因为它们是最基本的图形 UI 元素之一。我们在[*第 6 章*](B18327_06.xhtml#_idTextAnchor085)中简要讨论了它们，因为在不显示任何可视内容的情况下开始布局
    UI 是相当困难的。文本对象也是新按钮的子对象，我们在上一章中讨论了它们。然而，我们还没有探索文本对象的属性或如何在代码中与它们一起工作。
- en: In this chapter, we will explore **UI Text** objects more thoroughly. We will
    also discuss **Text-TextMeshPro** objects and how they allow for even more control
    of the text in our game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨 **UI 文本**对象。我们还将讨论 **Text-TextMeshPro** 对象以及它们如何允许我们在游戏中对文本有更多的控制。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Using UI Text objects and setting their properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 文本对象并设置它们的属性
- en: Using TextMeshPro -Text objects and setting their properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TextMeshPro - 文本对象和设置它们的属性
- en: Working with fonts and font assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与字体和字体资产一起工作
- en: Using markup format with UI Text objects and style sheets with TextMeshPro objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记格式与 UI 文本对象以及样式表与 TextMeshPro 对象
- en: Making Text that animates as if it’s being typed out
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建看起来像在逐字输入的动画文本
- en: Developing a system that allows for easy Text translation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个允许轻松文本翻译的系统
- en: Creating a custom font to be used with UI Text objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 UI 文本对象创建一个自定义字体
- en: Creating Text that wraps along a curve and renders with a gradient
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建沿曲线环绕并带有渐变的文本
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples shown in this section can be found within the Unity project
    provided in this book’s code bundle. They can be found within the **Chapter10**
    scene.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中显示的所有示例都可以在本书中提供的 Unity 项目中找到。它们可以在 **Chapter10** 场景中找到。
- en: Each example image has a caption stating the example number within the scene.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例图像都有一个标题，说明场景中的示例编号。
- en: In the scene, each example is on its own Canvas, and some of the Canvases have
    been deactivated. To view an example on a deactivated Canvas, simply select the
    checkbox next to the Canvas’ name in the **Inspector**. Each Canvas has also been
    given its own Event System. This will cause errors if you have more than one Canvas
    activated at a time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中，每个示例都在自己的画布上，其中一些画布已被禁用。要查看禁用画布上的示例，只需在 **检查器** 中选择画布名称旁边的复选框。每个画布也都有自己的事件系统。如果你同时激活多个画布，这将会导致错误。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2010)
- en: UI Text GameObject
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 文本 GameObject
- en: 'You can create a new UI Text object using **+** | **UI** | **Text**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **+** | **UI** | **Text** 创建一个新的 UI 文本对象：
- en: '![Figure 10.1: The UI Text GameObject Inspector](img/B18327_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：UI 文本 GameObject 检查器](img/B18327_10_01.jpg)'
- en: 'Figure 10.1: The UI Text GameObject Inspector'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：UI 文本 GameObject 检查器
- en: The UI Text GameObject contains the **Rect Transform** and **Canvas Renderer**
    components, as well as the **Text** component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UI 文本 GameObject 包含 **Rect Transform** 和 **Canvas Renderer** 组件，以及 **Text**
    组件。
- en: The UI Text component gives the object it is attached to a non-interactive text
    display. This component does not allow you to create all types of text you may
    be interested in, but it does allow most basic text displays.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: UI 文本组件为附加到其上的对象提供了一个非交互式的文本显示。这个组件不能创建你可能感兴趣的所有类型的文本，但它允许显示大多数基本的文本。
- en: The Text and Character properties
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本和字符属性
- en: The **Text** property changes the text that will be displayed. Whatever is typed
    within this box will be displayed within the Text object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本**属性会改变将要显示的文本。在这个框内输入的任何内容都会在文本对象中显示。'
- en: Below the **Text** property is a group of **Character** properties. These properties
    allow you to change the properties of the individual characters within the **Text**
    property’s field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**文本**属性下方是一组**字符**属性。这些属性允许您更改**文本**属性字段中单个字符的属性。
- en: The **Font** property determines which font is used for the entire block of
    text. By default, the **Font** is set to **Arial**. To use any other font, you
    must import the font into your **Asset** folder. Refer to the *Working with fonts*
    section to learn how to bring in additional fonts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体**属性决定了整个文本块使用的字体。默认情况下，**字体**设置为**Arial**。要使用任何其他字体，您必须将字体导入到您的**资产**文件夹中。有关如何导入额外字体的信息，请参阅*处理字体*部分。'
- en: '**Font Style** provides a dropdown list of available font styles that come
    with the provided font. The possible styles are **Normal**, **Bold**, **Italic**,
    and **Bold** **And Italic**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体样式**提供了一个下拉列表，列出了与提供的字体一起提供的字体样式。可能的样式有**正常**、**粗体**、**斜体**和**粗体和斜体**：'
- en: '![Figure 10.2: The UI Text component’s Font Style options](img/B18327_10_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：UI Text组件的字体样式选项](img/B18327_10_02.jpg)'
- en: 'Figure 10.2: The UI Text component’s Font Style options'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：UI Text组件的字体样式选项
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that not all fonts will support all the listed font styles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，并非所有字体都支持列出的所有字体样式。
- en: '**Font Size** determines the size of the text, whereas **Line Spacing** represents
    the vertical spacing between each line of text.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体大小**决定了文本的大小，而**行间距**表示文本每行之间的垂直间距。'
- en: If the **Rich Text** property is selected, you can include markup tags within
    the **Text** property field and they will appear with **Rich Text** styling rather
    than as typed. If this property is not selected, the text will display exactly
    as typed. Refer to the *Markup format* section for more information concerning
    writing with **Rich Text**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择**富文本**属性，你可以在**文本**属性字段中包含标记标签，并且它们将以**富文本**样式显示，而不是以输入的样式显示。如果此属性未选择，文本将显示为输入的样式。有关使用**富文本**的更多信息，请参阅*标记格式*部分。
- en: The Paragraph properties
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 段落属性
- en: The next set of properties – the **Paragraph** properties (*Figure 10**.1*)
    – allow you to determine how the text will display within (or outside of) the
    Rect Transform’s bounds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性集——**段落**属性（*图10**.1*）——允许您确定文本如何在（或超出）Rect Transform的边界内显示。
- en: 'The **Alignment** property determines where the text will align based on the
    Rect Transform bounds. You can choose both horizontal and vertical alignment options.
    The buttons represent the position relative to the Rect Transform bounds, so the
    left horizontal alignment will have the text pushed up to the edge of the Rect
    Transform’s left bound:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**对齐**属性决定了文本将根据Rect Transform边界对齐的位置。您可以同时选择水平和垂直对齐选项。按钮代表相对于Rect Transform边界的位置，因此左对齐将使文本推到Rect
    Transform左边界的外边缘：'
- en: '![Figure 10.3: The UI Text component’s Alignment options](img/B18327_10_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：UI Text组件的对齐选项](img/B18327_10_03.jpg)'
- en: 'Figure 10.3: The UI Text component’s Alignment options'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：UI Text组件的对齐选项
- en: The **Align by Geometry** property aligns the text as if the glyphs or characters
    are cropped down to their opaque area rather than the area they cover. This cropping
    is based on their character map. This can give a tighter alignment but might also
    cause things to overlap.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**按几何对齐**属性将文本对齐，好像字符或字符被裁剪到它们的不透明区域而不是它们覆盖的区域。这种裁剪基于它们的字符映射。这可以提供更紧密的对齐，但也可能导致重叠。'
- en: 'The **Horizontal Overflow** property determines what happens to text if it
    is too wide for the Rect Transform area. There are two options: **Wrap** and **Overflow**.
    **Wrap** will cause the text to continue on the next line, whereas **Overflow**
    will cause the text to expand past the rectangular area:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**水平溢出**属性决定了文本如果太宽而超出Rect Transform区域时会发生什么。有两个选项：**换行**和**溢出**。**换行**会使文本继续在下一行，而**溢出**会使文本扩展到矩形区域之外：'
- en: '![Figure 10.4: Horizontal Overflow Example in the Chapter10 scene](img/B18327_10_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：第10章场景中的水平溢出示例](img/B18327_10_04.jpg)'
- en: 'Figure 10.4: Horizontal Overflow Example in the Chapter10 scene'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：第10章场景中的水平溢出示例
- en: 'The **Vertical Overflow** property determines what happens to text if it is
    too long for the Rect Transform area. There are two options: **Truncate** and
    **Overflow**. **Truncate** will cut off all text outside of the rectangular area,
    whereas **Overflow** will cause the text to expand past the rectangular area.
    In the following figure, both Text boxes have the same text, but **Truncate**
    removes the last two lines of text due to them being outside of the rectangular
    area, while **Overflow** allows it to go outside the box:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**垂直溢出**属性决定了当文本长度超出矩形变换区域时文本的处理方式。有两种选项：**截断**和**溢出**。**截断**会将矩形区域外的所有文本截断，而**溢出**则会导致文本扩展到矩形区域之外。在下面的图中，两个文本框具有相同的文本，但**截断**移除了最后两行文本，因为它们位于矩形区域之外，而**溢出**允许文本超出框外：'
- en: '![Figure 10.5: Vertical Overflow Example in the Chapter10 scene](img/B18327_10_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：第10章场景中的垂直溢出示例](img/B18327_10_05.jpg)'
- en: 'Figure 10.5: Vertical Overflow Example in the Chapter10 scene'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：第10章场景中的垂直溢出示例
- en: 'The **Best Fit** property attempts to resize the text so that all of it fits
    within the rectangular area. When you select the **Best Fit** property, two new
    properties will become available: **Min Size** and **Max Size**. These properties
    allow you to specify the range the font size can maintain.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳适配**属性尝试调整文本大小，使其全部适合矩形区域。当你选择**最佳适配**属性时，将出现两个新的属性：**最小尺寸**和**最大尺寸**。这些属性允许你指定字体大小可以保持的范围。'
- en: Keep in mind that depending on the text you have written, the **Horizontal Overflow**
    property may cause this to work slightly differently than you’d expect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据你写的文本，**水平溢出**属性可能会导致其工作方式与你的预期略有不同。
- en: '![Figure 10.6: Best Fit Example in the Chapter10 scene](img/B18327_10_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：第10章场景中的最佳适配示例](img/B18327_10_06.jpg)'
- en: 'Figure 10.6: Best Fit Example in the Chapter10 scene'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：第10章场景中的最佳适配示例
- en: For example, the two Text boxes in *Figure 10**.6* have **Best Fit** selected,
    but the first has **Horizontal Overflow** set to **Wrap**, while the second has
    it set to **Overflow**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图*10**.6*中的两个文本框都选择了**最佳适配**，但第一个将**水平溢出**设置为**换行**，而第二个设置为**溢出**。
- en: The Color and Material properties
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色和材质属性
- en: The **Color** and **Material** properties allow you to adjust the appearance
    of the Text’s font. The **Color** property will set the base rendering color of
    the Text and is the quickest way to change the font’s color. By default, this
    property is set to a very dark (not fully black) gray. The **Material** property
    allows you to assign a material to your font. This gives you more control over
    the look of the font and also allows you to apply specific shaders. By default,
    this property is set to **None**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色**和**材质**属性允许你调整文本字体的外观。**颜色**属性将设置文本的基本渲染颜色，并且是更改字体颜色的最快方式。默认情况下，此属性设置为非常暗（不是全黑）的灰色。**材质**属性允许你为字体分配材质。这为你提供了更多控制字体外观的能力，并允许你应用特定的着色器。默认情况下，此属性设置为**无**。'
- en: The Raycast and Maskable properties
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线投射和可遮罩属性
- en: The **Raycast Target** property determines whether the object’s Rect Transform
    area will block raycasts or not. If this property is selected, clicks will not
    register on UI objects behind it. If it is not selected, items behind the object
    can be clicked. If you’d like for the Text to block raycasts, but not over its
    entire area, you can adjust the area with the various **Raycast** **Padding**
    properties.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**光线投射目标**属性决定了对象的矩形变换区域是否会阻止光线投射。如果此属性被选中，则点击不会在它后面的UI对象上注册。如果没有选中，则可以点击对象后面的项目。如果你希望文本阻止光线投射，但不是在整个区域上，你可以使用各种**光线投射****填充**属性调整区域。'
- en: The last property, **Maskable**, determines if the Text can be masked. We will
    discuss this in [*Chapter 12*](B18327_12.xhtml#_idTextAnchor328).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个属性，**可遮罩**，决定了文本是否可以被遮罩。我们将在[*第12章*](B18327_12.xhtml#_idTextAnchor328)中讨论这一点。
- en: Text-TextMeshPro
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本-TextMeshPro
- en: There is a bit of a limitation to what you can do with UI Text. If you find
    yourself wanting to accomplish some formatting with your text that you are unable
    to do with UI Text, you may be able to accomplish it with a TextMeshPro GameObject.
    For example, if you want to use underlined text, I recommend using a TextMeshPro
    GameObject. TextMeshPro assets allow for significantly more text control. Additionally,
    its rendering allows text to appear crisp at more resolutions and point sizes
    than what’s possible with the standard UI Text.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 文本方面，你可以做的事情有一些限制。如果你发现自己想要使用文本完成一些 UI 文本无法完成的格式化，你可能可以使用 TextMeshPro GameObject
    来完成。例如，如果你想使用带下划线的文本，我建议使用 TextMeshPro GameObject。TextMeshPro 资产允许进行显著更多的文本控制。此外，它的渲染允许文本在比标准
    UI 文本更多的分辨率和点大小上清晰显示。
- en: 'TextMeshPro used to be a paid asset in the Unity Asset Store, but it was adopted
    by Unity around March 2017 and is now available for free. However, to use TextMeshPro
    assets, you have to download the necessary resources. To download the TextMeshPro
    resources, attempt to add a TextMeshPro - Text to your scene by going to **+**
    | **UI** | **Text - TextMeshPro**; you will see the following popup:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TextMeshPro 以前是 Unity Asset Store 中的付费资产，但大约在 2017 年 3 月被 Unity 采用，现在免费提供。然而，要使用
    TextMeshPro 资产，你必须下载必要的资源。要下载 TextMeshPro 资源，请尝试通过前往 **+** | **UI** | **Text -
    TextMeshPro** 将 TextMeshPro - Text 添加到场景中；你将看到以下弹出窗口：
- en: '![Figure 10.7: The TMP Importer](img/B18327_10_07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7：TMP 导入器](img/B18327_10_07.jpg)'
- en: 'Figure 10.7: The TMP Importer'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：TMP 导入器
- en: Select **Import TMP Essentials** to get all the necessary assets. I also recommend
    selecting **Import TMP Examples &** **Extras**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **导入 TMP Essentials** 以获取所有必要的资产。我还建议选择 **导入 TMP 示例 &** **附加内容**。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Selecting any of the TextMeshPro GameObjects from the UI menu (Text - TextMeshPro,
    Button - TextMeshPro, Dropdown - TextMeshPro, or Input Field - TextMeshPro) will
    bring up the popup from the preceding screenshot and allow you to download the
    necessary assets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从 UI 菜单中选择任何 TextMeshPro GameObject（文本 - TextMeshPro、按钮 - TextMeshPro、下拉列表 -
    TextMeshPro 或输入字段 - TextMeshPro）将弹出先前的截图，并允许你下载必要的资源。
- en: Once you’ve downloaded it, you will not have to do so again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，你将不再需要这样做。
- en: 'Due to the robustness of TextMeshPro, I sadly can’t cover everything you can
    do with it within this chapter. Instead, I will provide a broad overview of its
    functionality. Luckily, the TextMeshPro asset comes with many examples and good
    documentation, which can be found here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TextMeshPro 的强大功能，我很遗憾不能在本章中涵盖你所能用它做的所有事情。相反，我将提供一个关于其功能的广泛概述。幸运的是，TextMeshPro
    资产附带许多示例和良好的文档，可以在以下位置找到：
- en: '[https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.xhtml)'
- en: 'When you create a new **TextMeshPro - Text** GameObject, you will see a GameObject
    with the following component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的 **TextMeshPro - Text** GameObject 时，你将看到一个具有以下组件的 GameObject：
- en: '![Figure 10.8: The TextMeshPro - Text component](img/B18327_10_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8：TextMeshPro - Text 组件](img/B18327_10_08.jpg)'
- en: 'Figure 10.8: The TextMeshPro - Text component'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：TextMeshPro - Text 组件
- en: You can also create Text-TextMeshPro GameObjects outside of Unity’s UI system
    via **GameObject** | **3D Object** | **Text-TextMeshPro**. This will render the
    text independent of the UI and without a Canvas.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 **GameObject** | **3D Object** | **Text-TextMeshPro** 在 Unity 的 UI 系统之外创建
    Text-TextMeshPro GameObject。这将使文本独立于 UI 和 Canvas 渲染。
- en: The GameObject itself will be named **Text (TMP)** and, for simplicity’s sake,
    is how I will reference it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GameObject 本身将被命名为 **Text (TMP)**，为了简便起见，这就是我将如何引用它的方式。
- en: As with all other UI objects, a **Rect Transform** and a **Canvas Renderer**
    component are attached to the GameObject as well. The graphic display of the **Text
    (TMP)** GameObject is controlled by the **TextMeshPro - Text (****UI)** component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他 UI 对象一样，GameObject 上也附加了 **Rect Transform** 和 **Canvas Renderer** 组件。**Text
    (TMP)** GameObject 的图形显示由 **TextMeshPro - Text (****UI)** 组件控制。
- en: Let’s investigate the properties of the **TextMeshPro – Text (****UI)** component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查 **TextMeshPro – Text (****UI)** 组件的属性。
- en: Text Input properties
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本输入属性
- en: 'You can enter the text you wish to display within the **Text** **Input** section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **Text** **Input** 部分输入你希望显示的文本：
- en: '![Figure 10.9: The TextMeshPro - Text component’s Text Input settings](img/B18327_10_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9：TextMeshPro - Text 组件的文本输入设置](img/B18327_10_09.jpg)'
- en: 'Figure 10.9: The TextMeshPro - Text component’s Text Input settings'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：TextMeshPro - 文本组件的文本输入设置
- en: 'The **Enable RTL Editor** property allows you to create text that will display
    from right to left which is necessary for some languages. When you select it,
    the text will appear in a second area in its right-to-left order:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用RTL编辑器**属性允许您创建从右到左显示的文本，这对于某些语言是必要的。当您选择它时，文本将以从右到左的顺序出现在第二个区域：'
- en: '![Figure 10.10: The TextMeshPro - Text component’s RTL Text Input setting](img/B18327_10_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：TextMeshPro - 文本组件的RTL文本输入设置](img/B18327_10_10.jpg)'
- en: 'Figure 10.10: The TextMeshPro - Text component’s RTL Text Input setting'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：TextMeshPro - 文本组件的RTL文本输入设置
- en: 'The **Text Style** setting lets you specify a style for the text. You’ll see
    multiple pre-defined options from the dropdown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本样式**设置允许您指定文本的样式。您将在下拉菜单中看到多个预定义选项：'
- en: '![Figure 10.11: The TextMeshPro - Text component’s Text Style settings](img/B18327_10_11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：TextMeshPro - 文本组件的文本样式设置](img/B18327_10_11.jpg)'
- en: 'Figure 10.11: The TextMeshPro - Text component’s Text Style settings'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：TextMeshPro - 文本组件的文本样式设置
- en: We’ll look at how to use this more thoroughly in the *Style sheets* section
    of this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的*样式表*部分更详细地探讨如何使用它。
- en: Main Settings
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主设置
- en: 'The **Main Settings** section allows you to adjust all the properties of the
    text:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**主设置**部分允许您调整文本的所有属性：'
- en: '![Figure 10.12: The TextMeshPro - Text component’s Main Settings section](img/B18327_10_12.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：TextMeshPro - 文本组件的主设置部分](img/B18327_10_12.jpg)'
- en: 'Figure 10.12: The TextMeshPro - Text component’s Main Settings section'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：TextMeshPro - 文本组件的主设置部分
- en: The `LiberationSans SDF (TMP_Font Asset)`. I want to point out that fonts and
    font assets are two different things. Fonts are used in UI Text GameObjects, whereas
    font assets are used in TextMeshPro GameObjects. I’ll discuss these differences,
    as well as how to import new fonts and create new font assets, in the *Working
    with* *fonts* section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiberationSans SDF (TMP_Font Asset)`。我想指出，字体和字体资产是两回事。字体用于UI文本游戏对象，而字体资产用于TextMeshPro游戏对象。我将在*与字体*
    *一起工作* *部分讨论这些差异，以及如何导入新字体和创建新字体资产。'
- en: 'The **Font Asset** property needs a material to render. Any material that contains
    the name of the font asset will appear in the **Material Preset** list. You can
    create your own material, but when you create a new font asset, it comes with
    a default material. Whichever material is selected here will also appear at the
    bottom of the component, below the **Extra Settings**. From this area, you can
    also select the material’s shader:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体资产**属性需要一个材质来渲染。任何包含字体资产名称的材质都将出现在**材质预设**列表中。您可以创建自己的材质，但创建新字体资产时，它将附带一个默认材质。此处选择的任何材质也将出现在组件底部的**额外设置**下方。从此区域，您还可以选择材质的着色器：'
- en: '![Figure 10.13: The TextMeshPro - Text’s material properties](img/B18327_10_13.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13：TextMeshPro - 文本的材质属性](img/B18327_10_13.jpg)'
- en: 'Figure 10.13: The TextMeshPro - Text’s material properties'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：TextMeshPro - 文本的材质属性
- en: The **Font Style** property allows you to create basic formatting for your text.
    You can select from **Bold**, **Italic**, **Underline**, **Strikethrough**, **Lowercased**,
    **Uppercased**, or **Small Caps**. You can choose any combination of the first
    four settings; however, you can only choose between **Lowercase**, **Uppercase**,
    or **Small Caps**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体样式**属性允许您为文本创建基本格式。您可以从**粗体**、**斜体**、**下划线**、**删除线**、**小写**、**大写**或**小写字母**中选择。您可以选择前四个设置中的任何组合；然而，您只能选择**小写**、**大写**或**小写字母**。'
- en: 'The **Font Size** property works as you would expect, but you also have the
    option to select **Auto Size**. The **Auto Size** property will attempt to fit
    the text within the bounding box of the Rect Transform as best as it can based
    on the properties you specify:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体大小**属性按您预期的功能工作，但您还可以选择**自动大小**。**自动大小**属性将尝试根据您指定的属性，尽可能地将文本适应Rect Transform的边界框内：'
- en: '![Figure 10.14: The TextMeshPro - Text component’s Font Size properties](img/B18327_10_14.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14：TextMeshPro - 文本组件的字体大小属性](img/B18327_10_14.jpg)'
- en: 'Figure 10.14: The TextMeshPro - Text component’s Font Size properties'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：TextMeshPro - 文本组件的字体大小属性
- en: You can specify the minimum (**Min**) and maximum (**Max**) font size along
    with the **WD%** and **Line** properties. The **WD%** property allows you to squeeze
    text horizontally to make the characters taller, whereas the **Line** property
    allows you to specify line height.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定最小（**Min**）和最大（**Max**）字体大小，以及**WD%**和**行**属性。**WD%**属性允许您水平挤压文本以使字符更高，而**行**属性允许您指定行高。
- en: 'You can change the color of the text using either the **Vertex Color** property
    or the **Color** **Gradient** property:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**顶点颜色**属性或**颜色****渐变**属性来更改文本的颜色：
- en: '![Figure 10.15: The TextMeshPro - Text component’s color properties](img/B18327_10_15.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15：TextMeshPro - Text组件的颜色属性](img/B18327_10_15.jpg)'
- en: 'Figure 10.15: The TextMeshPro - Text component’s color properties'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：TextMeshPro - Text组件的颜色属性
- en: An example of using the `<color>` markup tags.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<color>`标记标签的示例。
- en: You can set the spacing between **Characters**, **Words**, **Lines**, and **Paragraphs**
    in the **Spacing** **Options** area.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**间距****选项**区域设置**字符**、**单词**、**行**和**段落**之间的间距。
- en: You also have significantly more **Alignment** options available to you in TextMeshPro-Text
    than you do with the standard UI Text.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在TextMeshPro-Text中，您可用的**对齐**选项比标准UI Text多得多。
- en: 'Just as with UI Text, you can enable or disable **Wrapping**. You have significantly
    more **Overflow** options, however, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像UI Text一样，您可以选择启用或禁用**换行**。然而，您有更多的**溢出**选项，如下面的截图所示：
- en: '![Figure 10.16: The TextMeshPro - Text component’s Overflow options](img/B18327_10_16.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16：TextMeshPro - Text组件的溢出选项](img/B18327_10_16.jpg)'
- en: 'Figure 10.16: The TextMeshPro - Text component’s Overflow options'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：TextMeshPro - Text组件的溢出选项
- en: '**Overflow** and **Truncate** work similarly to those on the UI Text objects.
    Of the other options, the only one I want to mention at this time is the **Ellipsis**
    option. It will truncate the text to the text box area but add an ellipsis (…):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**溢出**和**截断**与UI Text对象上的功能类似。在其他选项中，我只想提到当前的**省略号**选项。它将文本截断到文本框区域，但会添加省略号（…）：'
- en: '![Figure 10.17: Text Mesh Pro Overflow Example in the Chapter10 scene](img/B18327_10_17.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17：第10章场景中的Text Mesh Pro溢出示例](img/B18327_10_17.jpg)'
- en: 'Figure 10.17: Text Mesh Pro Overflow Example in the Chapter10 scene'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：第10章场景中的Text Mesh Pro溢出示例
- en: 'The **Horizontal Mapping** and **Vertical Mapping** properties allow you to
    affect the way a texture is displayed across the text:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**水平映射**和**垂直映射**属性允许您影响纹理在文本上的显示方式：'
- en: '![Figure 10.18: The TextMeshPro - Text component’s Horizontal Mapping options](img/B18327_10_18.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18：TextMeshPro - Text组件的水平映射选项](img/B18327_10_18.jpg)'
- en: 'Figure 10.18: The TextMeshPro - Text component’s Horizontal Mapping options'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：TextMeshPro - Text组件的水平映射选项
- en: Most of the work you do to customize your font will be done in the **Text Input**
    section and the **Main Settings** section, but let’s look at some more nuanced
    settings that you will adjust with your fonts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您在**文本输入**部分和**主要设置**部分所做的大部分自定义字体工作，但让我们看看一些更细致的设置，您将使用字体进行调整。
- en: Extra Settings
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外设置
- en: 'The **Extra Settings** menu has to be expanded to be visible. It allows you
    to adjust some less-common settings of the font:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外设置**菜单必须展开才能可见。它允许您调整字体的一些不太常见的设置：'
- en: '![Figure 10.19: The TextMeshPro - Text Extra Settings section](img/B18327_10_19.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19：TextMeshPro - Text额外设置部分](img/B18327_10_19.jpg)'
- en: 'Figure 10.19: The TextMeshPro - Text Extra Settings section'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：TextMeshPro - Text额外设置部分
- en: The most notable properties in this menu are the ability to add **Margins**
    and the ability to enable **Raycast Target**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜单中，最显著的属性是添加**边距**和启用**射线投射目标**的能力。
- en: Lastly, you can specify whether or not you want to **Enable Kerning** or allow
    **Extra Padding**. Selecting **Kerning** will use the kerning data provided by
    the font file. Selecting **Extra Padding** will add a little padding around the
    glyphs of the sprite on its sprite atlas.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以指定是否要**启用字距调整**或允许**额外填充**。选择**字距调整**将使用字体文件提供的字距调整数据。选择**额外填充**将在精灵的精灵图集上的字符周围添加一些填充。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn about any of the properties I glossed over or skipped here: [https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解我略过或跳过的任何属性：[https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/TMPObjectUIText.xhtml)。
- en: TextMeshPro Project Settings
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextMeshPro 项目设置
- en: 'In addition to being able to adjust the individual settings of each TextMeshPro
    object you have within your scene via their components, you can also adjust TextMeshPro
    project-wide settings via the **Project Settings** (**Edit** > **Project Settings**):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过组件调整场景中每个 TextMeshPro 对象的个别设置外，您还可以通过 **项目设置**（**编辑** > **项目设置**）调整 TextMeshPro
    的项目级设置：
- en: '![Figure 10.20: The TextMeshPro – Project Settings](img/B18327_10_20.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20: TextMeshPro – 项目设置](img/B18327_10_20.jpg)'
- en: 'Figure 10.20: The TextMeshPro – Project Settings'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20：TextMeshPro – 项目设置
- en: These let you set the various defaults for newly created TextMeshPro objects.
    You can learn more about each property at [https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置允许您为新创建的 TextMeshPro 对象设置各种默认值。您可以在[https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/Settings.xhtml)了解更多关于每个属性的信息。
- en: Working with fonts
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与字体一起工作
- en: It’s extremely likely that you won’t want to use the default **Arial (UI Text)**
    or **Liberation Sans (TMP Text)** fonts and will want to bring a custom font into
    your project. Let’s explore how you can both find these text resources and use
    them in your project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 极有可能您不会想使用默认的 **Arial (UI 文本**) 或 **Liberation Sans (TMP 文本**) 字体，而希望将自定义字体引入到您的项目中。让我们来探讨如何找到这些文本资源并在您的项目中使用它们。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You do not have to install a font onto your computer (to use within programs
    outside of Unity) to use the font within Unity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要在计算机上安装字体（用于 Unity 之外的程序）即可在 Unity 中使用该字体。
- en: Importing new fonts
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入新字体
- en: 'The font file formats accepted by Unity are `.tff` (TrueType) and `.otf` (OpenType).
    You can get these files in multiple places. My favorite places to find fonts are
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 接受的字体文件格式是 `.tff` (TrueType) 和 `.otf` (OpenType)。您可以从多个地方获取这些文件。我最喜欢的寻找字体的地方如下：
- en: '*Google* *Fonts*: [https://fonts.google.com/](https://fonts.google.com/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google* *Fonts*: [https://fonts.google.com/](https://fonts.google.com/)'
- en: '*DaFont*: [http://www.dafont.com/](http://www.dafont.com/)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DaFont*: [http://www.dafont.com/](http://www.dafont.com/)'
- en: '*Font* *Squirrel*: [https://www.fontsquirrel.com/](https://www.fontsquirrel.com/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字体* *Squirrel*: [https://www.fontsquirrel.com/](https://www.fontsquirrel.com/)'
- en: All the fonts on *Google Fonts* are open source and are free for personal or
    commercial use (at least at the time of writing this book), but the fonts on *Font
    Squirrel* and *DaFont* have varying licensing options. Ensure that any font you
    get has a licensing agreement that meets your needs before you use it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Google Fonts* 上的所有字体都是开源的，并且可以免费用于个人或商业用途（至少在撰写本书时是这样），但 *Font Squirrel*
    和 *DaFont* 上的字体有不同的许可选项。在使用之前，请确保您获得的字体具有满足您需求的许可协议。
- en: Once you’ve downloaded the font of your choice, simply drag the font into your
    project’s `Assets` folder. I highly recommend that you create a folder called
    `Fonts` within your `Assets` folder in which you place all of your font files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下载您选择的字体后，只需将字体拖放到您项目中的 `Assets` 文件夹。我强烈建议您在 `Assets` 文件夹内创建一个名为 `Fonts` 的文件夹，并将所有字体文件放置其中。
- en: 'Then, you can adjust the font’s import properties in the **Inspector** if you
    so choose. The following screenshot shows the import settings of the **BungeeShade-Regular**
    font, which has been downloaded from Google Fonts:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您选择，可以在 **检查器**中调整字体的导入属性。以下截图显示了从 Google Fonts 下载的 **BungeeShade-Regular**
    字体的导入设置：
- en: '![Figure 10.21: The Inspector of the Bungee Shade-Regular font](img/B18327_10_21.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21：Bungee Shade-Regular 字体的检查器](img/B18327_10_21.jpg)'
- en: 'Figure 10.21: The Inspector of the Bungee Shade-Regular font'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21：Bungee Shade-Regular 字体的检查器
- en: Here, you can adjust quite a few of the settings concerning how the font will
    be handled by the engine.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以调整许多有关字体如何被引擎处理的设置。
- en: Font Size
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体大小
- en: The **Font Size** setting determines how large the font will appear on its Unity-created
    texture atlas. Increasing or decreasing the **Font Size** setting will change
    the size of the various glyphs on the texture atlas. If your font appears fuzzy
    in your game, adjusting the **Font Size** setting may improve its appearance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体大小**设置决定了字体在其Unity创建的纹理图集中的显示大小。增加或减少**字体大小**设置将改变纹理图集中各种字符的大小。如果你的字体在游戏中看起来模糊，调整**字体大小**设置可能会改善其外观。'
- en: Rendering Mode
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染模式
- en: The **Rendering Mode** settings tell Unity how the glyphs will be smoothed.
    The possible options are **Smooth**, **Hinted Smooth**, **Raster**, and **OS Default**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染模式**设置告诉Unity如何平滑字符。可能的选项有**平滑**、**提示平滑**、**光栅**和**OS默认**。'
- en: The **Smooth** rendering mode is the fastest rendering mode. It uses anti-aliased
    rendering, which means it will smooth out jagged, pixelated edges. The **Hinted
    Smooth** rendering mode will also smooth out edges, but it will use the “hints”
    contained within the font’s data files to determine how to fill in those jagged
    edges. This is a slower rendering mode than **Smooth** but will likely look crisper
    and be easier to read than **Smooth**. The **Hinted Raster** rendering mode does
    not provide anti-aliasing and instead provides aliased or jagged edges. This is
    the crispest and the quickest of the rendering modes. **OS Default** will default
    to whatever the operating system’s preferences are set to on Windows or Mac OS.
    This will select from **Smooth** or **Hinted Smooth**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**平滑**渲染模式是最快的渲染模式。它使用抗锯齿渲染，这意味着它会平滑掉锯齿状、像素化的边缘。**提示平滑**渲染模式也会平滑边缘，但它将使用字体数据文件中包含的“提示”来确定如何填充这些锯齿边缘。这比**平滑**渲染模式慢，但可能看起来更清晰，更容易阅读。**提示光栅**渲染模式不提供抗锯齿，而是提供带锯齿或锯齿状的边缘。这是最清晰且最快的渲染模式。**OS默认**将默认为Windows或Mac
    OS上操作系统的偏好设置。这将从**平滑**或**提示平滑**中选择。'
- en: Character
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符
- en: 'The **Character** property determines which character set of the font will
    be imported into the font texture atlas. There are six options: **Dynamic**, **Unicode**,
    **ASCII default set**, **ASCII upper case**, **ASCII lower case**, and **Custom
    set**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符**属性决定了哪个字体字符集将被导入到字体纹理图集中。有六个选项：**动态**、**Unicode**、**ASCII默认集**、**ASCII大写**、**ASCII小写**和**自定义集**：'
- en: Setting the **Character** property to **Dynamic** (which is the default) will
    only include the characters that are needed. This reduces the texture size needed
    for the font and, in turn, the download size of the game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将**字符**属性设置为**动态**（默认值）将只包括所需的字符。这减少了字体所需的纹理大小，从而减少了游戏的下载大小。
- en: '**Unicode** is used for languages that have characters that are not supported
    in an ASCII character set. So, for example, if you want to display text in Japanese,
    you will want to use **Unicode**.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unicode**用于那些在ASCII字符集中不支持的语言。例如，如果你想显示日语文本，你将需要使用**Unicode**。'
- en: If you’d like to include **Unicode** characters in your scripts, you need to
    save them with UTF-16 encoding. This will allow you to type **Unicode** characters
    directly in your code as strings so that they can display in your Text objects
    on screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在脚本中包含**Unicode**字符，你需要用UTF-16编码保存它们。这将允许你直接在代码中以字符串形式输入**Unicode**字符，以便它们可以在屏幕上的Text对象中显示。
- en: The *Noto fonts* provided by *Google Fonts* provide support for many languages
    and can be very helpful if you want to create a game that is translated into multiple
    languages. The *Noto fonts* can be found at [https://www.google.com/get/noto/](https://www.google.com/get/noto/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由**Google Fonts**提供的**Noto字体**支持多种语言，如果你想要创建一个被翻译成多种语言的游戏，这些字体会非常有帮助。**Noto字体**可以在[https://www.google.com/get/noto/](https://www.google.com/get/noto/)找到。
- en: '**American Standard Code for Information Interchange** (**ASCII**) is a set
    of characters from the English-language character set. The three variations of
    **ASCII** character sets allow you to choose between the full set, only uppercase,
    or only lowercase characters. You can find a list of the **ASCII** characters
    at [http://ascii.cl/](http://ascii.cl/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**美国信息交换标准代码**（**ASCII**）是一组来自英语字符集的字符。**ASCII**字符集的三种变体允许你在完整集、仅大写或仅小写字符之间进行选择。你可以在[http://ascii.cl/](http://ascii.cl/)找到**ASCII**字符列表。'
- en: A **Custom set** character will allow you to import your own texture atlas for
    your own custom font. I find this most commonly used when developers want beautified
    text with an extremely limited character set, such as numbers only.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义集**字符将允许您导入您自己的纹理图集以用于您自己的自定义字体。我发现这通常在开发者想要具有极小字符集的美化文本时最常用，例如仅数字。'
- en: Ascent Calculation Mode
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上升计算模式
- en: 'The **ascent** of a font is the distance between the font’s baseline and the
    highest glyph point. There is no standard for how this supposed *highest glyph
    point* is determined, so different modes are available in Unity to choose from,
    each determining a different *highest glyph point*. The **Ascent Calculation Mode**
    property determines how the ascent will be calculated. There are three options
    for how this calculation will be chosen: **Legacy version 2 mode (glyph bounding
    boxes)**, **Face ascender metric**, and **Face bounding box metric**. The method
    chosen may affect the vertical alignment of the font.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 字体的**上升**是指字体基线与最高字形点之间的距离。这个所谓的**最高字形点**的确定没有标准，因此Unity提供了不同的模式供选择，每种模式确定不同的**最高字形点**。**上升计算模式**属性确定上升将如何计算。有三种选择来决定这种计算方式：**旧版2模式（字形边界框）**、**面上升度量**和**面边界框度量**。选择的方法可能会影响字体的垂直对齐。
- en: '**Legacy version 2 mode (glyph bounding boxes)** measures the ascent using
    the highest point reached by any one of the font’s glyphs listed within its character
    set as the height. This only uses those listed in the character set, and not all
    glyphs may be included within that set. **Face ascender metric** uses the face
    ascender value that is defined to measure the ascent, whereas **Face bounding
    box metric** uses the face bounding box to measure the ascent.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧版2模式（字形边界框）**使用字体字符集中列出的任何字形的最高点作为高度来测量上升。这仅使用字符集中列出的字形，并且并非所有字形都可能包含在该集中。**面上升度量**使用定义来测量上升的面上升值，而**面边界框度量**使用面边界框来测量上升。'
- en: Typography is a lot more complicated than many people realize, and it’s too
    complicated to fully cover in this book – not to mention I am no typography expert.
    If you’d like to learn more about glyph metrics, a good introduction can be found
    at [https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml](https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字体排印比许多人想象的要复杂得多，而且在这个书中完全涵盖它也太复杂了——更不用说，我并不是字体排印专家。如果您想了解更多关于字形度量信息，可以在[https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml](https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.xhtml)找到一篇很好的介绍。
- en: Dynamic font settings
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态字体设置
- en: 'When you import your font with a dynamic character set, two new settings are
    made available: **Include Font Data** and **Font Names**.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用动态字符集导入您的字体时，将提供两个新的设置：**包含字体数据**和**字体名称**。
- en: '**Include Font Data** builds the font file with the game. If this is not selected,
    the game will assume that the player has the font installed on their machine.
    If you are using a font you have downloaded from the web, it is a pretty safe
    bet that the end user will not have the font installed and you should leave **Include
    Font** **Data** selected.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含字体数据**会在游戏中构建字体文件。如果不选择此选项，游戏将假定玩家已经在他们的机器上安装了字体。如果您正在使用从网络上下载的字体，那么最终用户很可能没有安装该字体，您应该选择**包含字体数据**。'
- en: '**Font Names** is the list of names of fonts that Unity will fall back on if
    it cannot find the font. It will need to fall back on this font name if the font
    doesn’t include the requested glyph or the **Incl. Font Data** property was deselected
    and the user does not have the font installed on their machine. If Unity cannot
    find the font, it will search the game’s project folder or the user’s machine
    for a font matching one of the names listed in **Font Names**. Once the fonts
    have been typed into **Font Names**, the appropriate fonts will be listed in the
    **References to other fonts in** **project** section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体名称**是Unity在找不到字体时将回退到的字体名称列表。如果字体不包含请求的字形或**包含字体数据**属性未选中且用户没有在他们的机器上安装字体，它将需要回退到这个字体名称。如果Unity找不到字体，它将在游戏的项目文件夹或用户的机器上搜索与**字体名称**中列出的名称之一匹配的字体。一旦字体被输入到**字体名称**中，适当的字体将在**项目中的其他字体引用**部分列出：'
- en: '![Figure 10.22: The Inspector of the Roboto-Regular font](img/B18327_10_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22：Roboto-Regular字体的检查器](img/B18327_10_22.jpg)'
- en: 'Figure 10.22: The Inspector of the Roboto-Regular font'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：Roboto-Regular字体的检查器
- en: If Unity cannot find one of the fonts listed, it will use a font provided in
    a predefined list of fallback fonts hard-coded within Unity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Unity 找不到列出的字体之一，它将使用 Unity 中预定义的回退字体列表中提供的字体。
- en: Some platforms don’t have built-in fonts in their system or can’t access built-in
    fonts. These platforms include WebGL and some console systems. When building to
    these platforms, Unity will always include fonts, regardless of the setting chosen
    for **Include** **Font Data**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台在其系统中没有内置字体，或者无法访问内置字体。这些平台包括 WebGL 和一些控制台系统。当构建到这些平台时，Unity 将始终包含字体，无论选择的“包含”**字体数据**设置如何。
- en: Importing font styles
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入字体样式
- en: 'If you bring in a font that has multiple styles (that is, bold, italic, or
    bold and italic), you must bring in all the font styles for them to appear properly.
    Bringing the fonts into your project may not be sufficient for the font to recognize
    which fonts should be used when the **Bold**, **Italic**, and **Bold and Italic**
    font styles are selected, however. For example, the following screenshot shows
    the **Roboto-Regular** Google Font with the **Bold and Italic** **Font Style**
    on the top line of text and the **Roboto-BoldItalic** Google Font with the **Normal**
    **Font Style** on the bottom line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您引入了一个具有多种样式（即粗体、斜体或粗体和斜体）的字体，您必须引入所有字体样式，以便它们能够正确显示。将字体引入您的项目可能不足以让字体识别在选择了**粗体**、**斜体**和**粗体和斜体**字体样式时应该使用哪种字体。例如，以下截图显示了顶行文本上的**Roboto-Regular**
    Google 字体和**粗体和斜体****字体样式**，以及底行文本上的**Roboto-BoldItalic** Google 字体和**正常****字体样式**：
- en: '![Figure 10.23: Styles of the Roboto font](img/B18327_10_23.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23：Roboto字体的样式](img/B18327_10_23.jpg)'
- en: 'Figure 10.23: Styles of the Roboto font'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23：Roboto 字体的样式
- en: 'If the **Font Style** property were working correctly, the two lines should
    match. However, as you can see, they do not. To make the fonts appear correctly,
    select the regular font, retype the **Font Name** property to make all the appropriate
    ones appear in the font list (as shown in *Figure 10**.22*), and hit **Apply**.
    After doing so, the two fonts should appear the same:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**字体样式**属性工作正常，两行应该匹配。然而，如您所见，它们并不匹配。要使字体正确显示，请选择常规字体，重新输入**字体名称**属性，使所有适当的字体都出现在字体列表中（如图*图
    10.22*所示），然后按**应用**。完成此操作后，两个字体应该看起来相同：
- en: '![Figure 10.24: Styles of the Roboto font applied correctly](img/B18327_10_24.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24：正确应用Roboto字体的样式](img/B18327_10_24.jpg)'
- en: 'Figure 10.24: Styles of the Roboto font applied correctly'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24：正确应用Roboto字体的样式
- en: Now that we’ve reviewed how to import fonts, let’s look at how to create custom
    fonts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何导入字体，让我们看看如何创建自定义字体。
- en: Custom fonts
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义字体
- en: 'You can create a custom font by selecting **Create** | **Custom Font** from
    the project window. To use a custom font, you will need a font material and font
    texture. How to do this is covered in the *Examples* section of this chapter.
    Once you create your custom font, you will be given the following properties to
    set:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从项目窗口中选择**创建** | **自定义字体**来创建自定义字体。要使用自定义字体，您将需要一个字体材质和字体纹理。如何做到这一点在本章的*示例*部分中有所说明。一旦您创建了您的自定义字体，您将获得以下属性来设置：
- en: '![Figure 10.25: A custom font’s Inspector](img/B18327_10_25.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25：自定义字体的检查器](img/B18327_10_25.jpg)'
- en: 'Figure 10.25: A custom font’s Inspector'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25：自定义字体的检查器
- en: The **Line Spacing** property specifies the distance between each line of text.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**行间距**属性指定了每行文本之间的距离。'
- en: The `0`, which is ASCII index `48`. Therefore, you would set the `48`, indicating
    the first character in this font’s character set is the character 0\. You can
    determine the ASCII index number for individual characters at [http://ascii.cl/](http://ascii.cl/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数字“0”，它是 ASCII 索引“48”。因此，您可以将“48”设置为表示该字体字符集中的第一个字符是数字 0。您可以在 [http://ascii.cl/](http://ascii.cl/)
    确定单个字符的 ASCII 索引号。
- en: The **Tracking** property represents the spacing between characters for a full
    line of text. It allows the spacing between all characters to be uniform.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tracking** 属性表示一行文本中字符之间的间距。它允许所有字符之间的间距保持一致。'
- en: The **Kerning** property has been replaced with the **Tracking** property. **Tracking**
    and **Kerning** are both properties related to spacing between characters, but
    they are different. For more information, check out [http://www.practicalecommerce.com/Typography-101-The-Basics](http://www.practicalecommerce.com/Typography-101-The-Basics).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kerning** 属性已被 **Tracking** 属性所取代。**Tracking** 和 **Kerning** 都是关于字符间间距的属性，但它们是不同的。更多信息，请参阅
    [http://www.practicalecommerce.com/Typography-101-The-Basics](http://www.practicalecommerce.com/Typography-101-The-Basics)。'
- en: '**Character Spacing** is the amount of space between characters, whereas **Character
    Padding** is the amount of padding surrounding individual characters before the
    spacing.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Character Spacing** 是字符间的空间量，而 **Character Padding** 是在间距之前围绕单个字符的填充量。'
- en: 'The **Character Rects** property determines how many total characters are in
    your font. Changing the number from 0 to any positive number will provide a list
    of **Elements** that can be expanded:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**Character Rects** 属性确定字体中总共有多少个字符。将数字从 0 更改为任何正数将提供一个可以展开的 **Elements** 列表：'
- en: '![Figure 10.26: The Character Rects of a custom font](img/B18327_10_26.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.26：自定义字体的字符矩形](img/B18327_10_26.jpg)'
- en: 'Figure 10.26: The Character Rects of a custom font'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26：自定义字体的字符矩形
- en: Each element represents a character on your character set. The **Index** is
    the ASCII index of the specified character.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素代表字符集中的一个字符。**Index** 是指定字符的 ASCII 索引。
- en: The `.2` and the `.5`. This should be consistent throughout all of your characters.
    The **X** and **Y** values are determined by multiplying the **W** and **H** values
    by the column or row that the character is located in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`.2` 和 `.5`。这应该适用于你所有的字符。**X** 和 **Y** 值是通过将 **W** 和 **H** 值乘以字符所在的列或行来确定的。'
- en: The `50` and `-50`, respectively. To be perfectly honest, I am not exactly sure
    why the height property is always negative and I can’t seem to find the answer.
    I suspect that it has something to do with the fact that this uses texture coordinates.
    The **X** and **Y** values of **Vert** represent a shift in position, where these
    numbers can be negative or positive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`50` 和 `-50`，分别。坦白说，我并不完全清楚为什么高度属性总是负数，我也似乎找不到答案。我怀疑这与它使用纹理坐标有关。**Vert** 的
    **X** 和 **Y** 值代表位置的变化，这些数字可以是负数或正数。'
- en: The **Advance** setting represents the pixel distance between the specific character
    and the next character.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Advance** 设置表示特定字符与下一个字符之间的像素距离。'
- en: The **Flipped** setting indicates if the glyph is flipped of how it should be
    displayed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flipped** 设置指示字形是否翻转以及应该如何显示。'
- en: Please refer to the *Examples* section for an example of calculating the **UV**,
    **Vert**, and **Advance** values of a custom font.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 *示例* 部分，了解如何计算自定义字体的 **UV**、**Vert** 和 **Advance** 值。
- en: At the time of writing, not all the properties for custom fonts are fully defined
    within Unity’s documentation and a few of these properties are a bit ambiguous.
    For example, **Convert Case** used to be a dropdown menu, and it is unclear to
    me how it is now used since it only accepts a number input. Perhaps, in the future,
    these properties will be better defined and the manual will be updated to reflect
    the new changes made, at [https://docs.unity3d.com/Manual/class-Font.xhtml](https://docs.unity3d.com/Manual/class-Font.xhtml).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Unity 的文档中并未完全定义自定义字体的所有属性，其中一些属性有些模糊不清。例如，**Convert Case** 以前是一个下拉菜单，现在我并不清楚它现在是如何使用的，因为它只接受数字输入。也许在未来，这些属性将得到更好的定义，手册也将更新以反映所做的新的更改，请参阅
    [https://docs.unity3d.com/Manual/class-Font.xhtml](https://docs.unity3d.com/Manual/class-Font.xhtml)。
- en: Font assets
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体资源
- en: Recall that TextMeshPro objects need to use font assets, not fonts. So, if you’ve
    downloaded some fonts for your project, you won’t see them as possible font options
    with a TextMeshPro object. If you’ve imported the TextMeshPro examples, you may
    have few options other than Liberation Sans available to you. To use a different
    font in a TextMeshPro GameObject, you cannot simply drag a new font into the **Font
    Asset** slot; you must create a Font Asset via the **Font** **Asset Creator**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，TextMeshPro 对象需要使用字体资源，而不是字体。所以，如果你为你的项目下载了一些字体，你不会在 TextMeshPro 对象中看到它们作为可能的字体选项。如果你已经导入了
    TextMeshPro 示例，你可能除了 Liberation Sans 之外没有其他选项。要在 TextMeshPro GameObject 中使用不同的字体，你不能简单地拖动一个新的字体到
    **Font Asset** 槽中；你必须通过 **Font** **Asset Creator** 创建一个字体资源。
- en: 'To access the **Font Asset Creator**, select **Window** | **TextMeshPro - Font
    Asset Creator**. This will allow you to convert a font file into a font asset
    that can be used by TextMeshPro:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问**字体资产创建器**，请选择**窗口** | **TextMeshPro - 字体资产创建器**。这将允许您将字体文件转换为 TextMeshPro
    可以使用的字体资产：
- en: '![Figure 10.27: The Font Asset Creator window](img/B18327_10_27.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.27：字体资产创建器窗口](img/B18327_10_27.jpg)'
- en: 'Figure 10.27: The Font Asset Creator window'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27：字体资产创建器窗口
- en: There are quite a few settings that can be controlled via the **Font Asset Creator**.
    You can find a breakdown of these settings at https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsCreator.xhtml?q=font%20asset%20creator.
    I will cover the process of creating a font asset in the *Examples* section of
    this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多设置可以通过**字体资产创建器**来控制。您可以在 https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsCreator.xhtml?q=font%20asset%20creator
    找到这些设置的详细说明。我将在本章的**示例**部分介绍创建字体资产的过程。
- en: Exploring the markup format
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标记格式
- en: HTML-like markup language can be included within the text field of the `<tag>the
    text you wish to format</tag>` format, where you replace `tag` with the appropriate
    tag. These tags can be nested, just as they can in HTML.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 HTML 的标记语言可以包含在 `<tag>您想要格式化的文本</tag>` 格式的文本字段中，其中您将 `tag` 替换为适当的标签。这些标签可以嵌套，就像在
    HTML 中一样。
- en: To use markup format on a **Text** object, you must first select the **Rich
    Text** property within the **Text** component. By default, it works within a **TextMeshPro**
    object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**文本**对象上使用标记格式，您必须首先在**文本**组件中选择**富文本**属性。默认情况下，它适用于**TextMeshPro**对象。
- en: 'This formatting allows you to change the font style, font color, and font size.
    The following chart lists the tags necessary to perform the specified formatting:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式化允许您更改字体样式、字体颜色和字体大小。以下图表列出了执行指定格式化所需的标签：
- en: '| **Format** | **Tag** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **Format** | **Tag** |'
- en: '| `Bold` | `b` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `Bold` | `b` |'
- en: '| `Italic` | `i` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `Italic` | `i` |'
- en: '| `Color` | `color` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `Color` | `color` |'
- en: '| `Size` | `size` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `Size` | `size` |'
- en: 'Table 10.1: Formats and their tags'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1：格式及其标签
- en: Now, let’s look at how to change the style of a font with markup.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用标记来更改字体的样式。
- en: Font style
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体样式
- en: You can change the font style of text using the bold and italic tags.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用加粗和斜体标签来更改文本的字体样式。
- en: To add a bold font style to text, add the `<b></b>` tags around the text you
    wish to bold. To add an italic font style to text, add the `<i></i>` tags around
    the text you wish to italicize.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要给文本添加加粗字体样式，请将 `<b></b>` 标签添加到您想要加粗的文本周围。要给文本添加斜体字体样式，请将 `<i></i>` 标签添加到您想要斜体的文本周围。
- en: '![](img/Table_10.2.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_10.2.jpg)'
- en: 'Table 10.2: Examples of formatting tags'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2：格式化标签示例
- en: Now, let’s look at how to change the color of a font with markup.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用标记来更改字体的颜色。
- en: Font color
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体颜色
- en: 'You can change the color of your font with either the hex value representation
    of a number or using the color name. To change the color of the text, add `<color=value></color>`
    around the text you wish to color, where you place either the hex value (following
    a #) or the color name where the word value appears.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用数字的十六进制值表示或使用颜色名称来更改字体颜色。要更改文本颜色，请将 `<color=value></color>` 添加到您想要着色的文本周围，其中您放置十六进制值（后跟一个
    #）或颜色名称，其中出现单词 value。'
- en: Only a limited set of colors have names that can replace the hex values. The
    color names that are recognized are black, blue, brown, cyan, darkblue, green,
    grey, lightblue, lime, magenta, maroon, navy, olive, orange, purple, red, silver,
    teal, white, and yellow. You can also use aqua in place of cyan and fuchsia in
    place of magenta.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 只有有限的颜色名称可以替换十六进制值。可识别的颜色名称包括黑色、蓝色、棕色、青色、深蓝色、绿色、灰色、浅蓝色、黄绿色、洋红色、栗色、海军蓝、橄榄绿、橙色、紫色、红色、银色、青绿色、白色和黄色。您还可以用青色代替青色，用品红色代替洋红色。
- en: When using the color tag, any text not surrounded by the color tag will be colored
    based on the **Color** property selected.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用颜色标签时，任何未用颜色标签包围的文本将根据所选的**颜色**属性进行着色。
- en: 'The following table shows how to use the color tag:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了如何使用颜色标签：
- en: '![](img/Table_10.3.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_10.3.jpg)'
- en: 'Table 10.3: Color formatting tag examples'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3：颜色格式化标签示例
- en: Now, let’s look at how to change the size of a font with markup.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用标记来更改字体的大小。
- en: Font size
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体大小
- en: 'To change the font size, add the `<size=#></size>` tags around the text you
    wish to resize. Any text not within the tag will be sized based on the `size`
    tag:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字体大小，请将 `<size=#></size>` 标签添加到您想要调整大小的文本周围。任何不在标签内的文本都将根据 `size` 标签的大小进行调整：
- en: '![](img/Table_10.4.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_10.4.jpg)'
- en: 'Table 10.4: Examples of multiple font size tags'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4：多个字体大小标签的示例
- en: So far, we’ve looked at the ways we can format fonts with markup. Now, let’s
    look at how to format a font using a style sheet.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了我们可以使用标记格式化字体的方式。现在，让我们看看如何使用样式表来格式化字体。
- en: Using style sheets
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式表
- en: 'In addition to the markup tags described in the preceding section, TextMeshPro
    objects can also use style sheet tags. As you may recall from *Figure 10**.9*,
    the **TextMeshPro - Text (UI)** component has a property labeled **Text Style**
    with ten options in its dropdown. From there, you can select any one of the styles
    shown in the following figure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中描述的标记标签之外，TextMeshPro对象还可以使用样式表标签。如您从*图10**.9*中回忆的那样，**TextMeshPro - Text
    (UI)**组件有一个标记为**Text Style**的属性，在其下拉菜单中有十个选项。从那里，您可以选择以下图中显示的任何一种样式：
- en: '![Figure 10.28: The various default styles from the default style sheet](img/B18327_10_28.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图10.28：默认样式表中的各种默认样式](img/B18327_10_28.jpg)'
- en: 'Figure 10.28: The various default styles from the default style sheet'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：默认样式表中的各种默认样式
- en: All of these styles are pre-defined by the **Default Style Sheet** option that’s
    assigned for the **TextMeshPro Settings** within the **Project Settings** (as
    we discussed in the *TextMeshPro Project* *Settings* section).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些样式都是由分配给**Project Settings**中的**TextMeshPro Settings**的**Default Style Sheet**选项预定义的（正如我们在*TextMeshPro
    Project* *Settings*部分所讨论的）。
- en: '![Figure 10.29: The Default Style Sheet setting from the Project Settings](img/B18327_10_29.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图10.29：项目设置中的默认样式表设置](img/B18327_10_29.jpg)'
- en: 'Figure 10.29: The Default Style Sheet setting from the Project Settings'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：项目设置中的默认样式表设置
- en: 'Clicking on the `Default Style Sheet (TMP_Style Sheet)` object within the `Default
    Style Sheet` within the `Assets` folder:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中的`Default Style Sheet`内的`Default Style Sheet (TMP_Style Sheet)`对象上单击：
- en: '![Figure 10.30: The Default Style Sheet asset within Resources](img/B18327_10_30.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图10.30：资源中的默认样式表资产](img/B18327_10_30.jpg)'
- en: 'Figure 10.30: The Default Style Sheet asset within Resources'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：资源中的默认样式表资产
- en: 'You can then view the `Default Style Sheet` asset’s **Inspector** and see how
    each of the default style sheet tags are defined:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看`Default Style Sheet`资产的**Inspector**，并查看每个默认样式表标签是如何定义的：
- en: '![Figure 10.31: The Default Style Sheet properties](img/B18327_10_31.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图10.31：默认样式表的属性](img/B18327_10_31.jpg)'
- en: 'Figure 10.31: The Default Style Sheet properties'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31：默认样式表的属性
- en: You are free to change the names and properties of any of these tags by editing
    this asset. You can add and remove tags.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编辑此资产来更改这些标签的名称和属性。您可以添加和删除标签。
- en: You can also create a whole new style sheet and make it the default style sheet.
    To create a new style sheet, right-click within the `Assets` folder and select
    **Create** | **TextMeshPro** | **Style Sheet**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个新的样式表并将其设置为默认样式表。要创建一个新的样式表，在`Assets`文件夹内右键单击并选择**Create** | **TextMeshPro**
    | **Style Sheet**。
- en: 'You can apply these styles via the dropdown, as I demonstrated at the beginning
    of this section, or you can assign them to portions of the text via markup format
    using the `<style>` tag. For example, if you wanted to display the text shown
    in *Figure 10**.32*, you could do so by typing `Here''s <style="Title">how</style>
    to use styles <style="Link">in-line</style>!` into the **Text** field:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过下拉菜单应用这些样式，就像我在本节开头所演示的那样，或者您可以通过使用`<style>`标签以标记格式将它们分配给文本的某些部分。例如，如果您想显示*图10**.32*中显示的文本，您可以通过在**Text**字段中输入`Here's
    <style="Title">how</style> to use styles <style="Link">in-line</style>!`来实现：
- en: '![Figure 10.32: Styles used in-line in a markup fashion](img/B18327_10_32.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图10.32：以标记方式内联使用的样式](img/B18327_10_32.jpg)'
- en: 'Figure 10.32: Styles used in-line in a markup fashion'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32：以标记方式内联使用的样式
- en: Now that we’ve reviewed the how to format fonts and with markup, let’s move
    on to explore how you can use the various Text component properties, with translations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何使用标记格式化字体，接下来让我们探索如何使用各种Text组件属性，并进行翻译。
- en: Translating text
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译文本
- en: Odds are, if you are creating a game with text in it, you might want to translate
    that text. To make sure your games are easily translatable, there are a few key
    things that you can do to make the transition to different languages easier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建包含文本的游戏，您可能希望翻译这些文本。为了确保您的游戏易于翻译，您可以通过执行一些关键操作来简化不同语言之间的转换。
- en: You want to make sure that the text you plan to translate will still fit within
    the necessary area if it gets longer or shorter when translated. You can accomplish
    this by using the **Align By Geometry** and **Best Fit** properties of the **Text**
    component. This will make the text fit within the required space. You could also
    use the Content Size Fitter (which we discussed in [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106))
    to make sure any Panels around the text will shrink or expand to fit perfectly
    around the text. You can use the first option if you don’t mind the font size
    varying across languages. You can use the second if you want the font size to
    remain consistent across languages. Keep in mind that some languages can render
    a single phrase in a very small amount of space, while others will render it in
    a very large amount of space.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你计划翻译的文本在翻译后如果变长或变短，仍然可以适应必要的区域。你可以通过使用**文本组件**的**根据几何对齐**和**最佳匹配**属性来实现这一点。这将使文本适应所需的空间。你也可以使用内容大小适配器（我们在[*第7章*](B18327_07.xhtml#_idTextAnchor106)中讨论过）来确保围绕文本的任何面板都会收缩或扩展以完美地围绕文本。如果你不介意字体大小在不同语言间变化，可以使用第一个选项。如果你希望字体大小在不同语言间保持一致，可以使用第二个选项。请记住，一些语言可以在非常小的空间内渲染一个短语，而其他语言则会在非常大的空间内渲染。
- en: 'Use fonts that can support the languages you will be translating to. If possible,
    a single font that works across all languages will be preferred as it will maintain
    a consistent style across all translations. You spent so much time picking the
    perfect font! You don’t want all that to be thrown out the window when you translate
    your game and the font won’t render all the glyphs of the language! It’s not a
    glamorous or particularly stylish font, but one that will translate into *many*
    languages is the Noto Sans font family. If you know you’ll be translating into
    a lot of languages, you might want to consider it: [https://fonts.google.com/noto/fonts](https://fonts.google.com/noto/fonts).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可以支持你将要翻译的语言的字体。如果可能，一个适用于所有语言的单一字体将是首选，因为它将在所有翻译中保持一致的风格。你花了那么多时间挑选完美的字体！你不想在翻译你的游戏时所有这些都付诸东流，而字体无法渲染该语言的全部符号！这不是一个华丽或特别时尚的字体，但一个可以翻译成*许多*语言的字体是Noto
    Sans字体家族。如果你知道你将翻译成很多语言，你可能想要考虑它：[https://fonts.google.com/noto/fonts](https://fonts.google.com/noto/fonts).
- en: If you plan to translate into a language that renders right-to-left, such as
    Arabic, you will need to use a TextMeshPro object, rather than a Text object,
    as it will let you render text from RTL.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划翻译成从右到左渲染的语言，例如阿拉伯语，你需要使用TextMeshPro对象，而不是Text对象，因为它将允许你从RTL渲染文本。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'At the time of writing, TextMeshPro, while able to render text from right-to-left,
    does not fully support right-to-left languages. If you’d like to display Arabic,
    Farsi, and/or Hebrew in your game’s UI, I recommend the following package: [https://github.com/pnarimani/RTLTMPro](https://github.com/pnarimani/RTLTMPro).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，虽然TextMeshPro能够从右到左渲染文本，但它并不完全支持从右到左的语言。如果你想在你游戏的UI中显示阿拉伯语、波斯语和/或希伯来语，我推荐以下包：[https://github.com/pnarimani/RTLTMPro](https://github.com/pnarimani/RTLTMPro).
- en: 'You may also appreciate the following tutorial on rendering right-to-left text:
    [https://allcorrectgames.com/insights/unity-from-right-to-left/](https://allcorrectgames.com/insights/unity-from-right-to-left/).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你也许还会欣赏以下关于渲染从右到左文本的教程：[https://allcorrectgames.com/insights/unity-from-right-to-left/](https://allcorrectgames.com/insights/unity-from-right-to-left/).
- en: 'The following is also an extremely helpful resource as it breaks down how to
    architect a localization solution for your project and also discusses right-to-left
    text translation: [https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/](https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是一个非常有用的资源，因为它分解了如何为你的项目构建本地化解决方案，并讨论了从右到左的文本翻译：[https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/](https://phrase.com/blog/posts/localizing-unity-games-official-localization-package/).
- en: In the *Examples* section, I provide a small example that focuses on the UI
    layout and font aspects of translation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例*部分，我提供了一个小型示例，重点关注翻译的UI布局和字体方面。
- en: Examples
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: In this chapter, we’ll expand on the scene we’ve been building further and also
    add a new scene that occurs between our start screen and our main game screen.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步扩展我们一直在构建的场景，并添加一个位于我们的起始屏幕和主游戏屏幕之间的新场景。
- en: Creating animated text
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画文本
- en: 'First, we will create a new scene that acts like a *cut scene* between our
    start screen and our gameplay scene. It will include our cat introducing itself.
    The text will animate as if it is being typed, and the user will have the option
    to speed it up by pressing a button. Once the text is fully displayed, pressing
    that same button will either show the next block of text or go to the gameplay
    scene. The text windows will appear as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的场景，它将作为我们的起始屏幕和游戏场景之间的*场景过渡*。它将包括我们的猫自我介绍。文本将以类似打字的方式动画化，用户可以通过按按钮来加快速度。一旦文本完全显示，按下相同的按钮将显示下一个文本块或转到游戏场景。文本窗口将如下所示：
- en: '![Figure 10.33: The end result of our animated text box](img/B18327_10_33.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图10.33：我们的动画文本框的最终结果](img/B18327_10_33.jpg)'
- en: 'Figure 10.33: The end result of our animated text box'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33：我们的动画文本框的最终结果
- en: Let’s start by creating a prefab to save us some development time.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个预制件以节省我们一些开发时间。
- en: Creating a Background Canvas prefab and a new scene
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建背景画布预制件和新的场景
- en: Before we can start making animated text, we need to build out our scene. In
    both the scenes we have created so far, we used `Background Canvas` to display
    the background image, and we will use it again in a new scene.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始制作动画文本之前，我们需要构建我们的场景。在我们迄今为止创建的两个场景中，我们都使用了`背景画布`来显示背景图像，我们将在新的场景中再次使用它。
- en: Since we will use this `Background Canvas` multiple times, we should create
    a `Background Canvas` prefab. As we learned in a previous chapter, a **prefab**
    is a reusable GameObject. Using a prefab in a scene creates an instance of the
    prefab within the scene. If you make a change to the saved prefab, the change
    will be reflected in all unbroken prefab instances across all scenes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将多次使用这个`Background Canvas`，我们应该创建一个`Background Canvas`预制件。正如我们在前一章中学到的，**预制件**是一个可重复使用的GameObject。在场景中使用预制件会在场景中创建预制件的实例。如果你对保存的预制件进行了更改，更改将反映在所有未断开的预制件实例中，这些实例位于所有场景中。
- en: 'To create a reusable `Background Canvas` prefab GameObject, complete the following
    steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可重复使用的`Background Canvas` prefab GameObject，请完成以下步骤：
- en: Open the `Chapter9-Examples` scene.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter9-Examples`场景。
- en: Drag the `Background Canvas` GameObject from the Hierarchy into the `Prefabs`
    folder within the `Background Canvas` should now be blue in the **Hierarchy**
    (symbolizing that it is a prefab).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Background Canvas` GameObject从层次结构拖动到`背景画布`文件夹内的`预制件`文件夹中。现在在**层次结构**中`Background
    Canvas`应该显示为蓝色（表示它是一个预制件）。
- en: Let’s create a new scene in which we will use this `Background Canvas` prefab.
    Create a new scene called `Chapter10-Examples-IntroScene` and save it in the `Scenes`
    folder.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的场景，我们将在这个场景中使用这个`Background Canvas`预制件。创建一个名为`Chapter10-Examples-IntroScene`的新场景，并将其保存在`Scenes`文件夹中。
- en: Drag the `Background Canvas.prefab` into the new scene from the **Project**
    view.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图中将`Background Canvas.prefab`拖动到新场景中。
- en: Assign the `Main Camera` to the `Background Canvas` and make sure that **Sorting
    Layer** is set to **Background**.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`主摄像机`分配给`背景画布`，并确保**排序层**设置为**背景**。
- en: Now, we can start setting up the windows that will hold our animated text.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始设置将包含我们的动画文本的窗口。
- en: Laying out the text box windows
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局文本框窗口
- en: 'To create the text box windows that will display our text, complete the following
    steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建将显示我们的文本的文本框窗口，请完成以下步骤：
- en: 'Create a new UI Canvas and name it `Text Canvas`. Set its **Canvas** and **Canvas
    Scalar** properties, as shown here:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的UI画布，并将其命名为`文本画布`。设置其**画布**和**画布缩放器**属性，如图所示：
- en: '![Figure 10.34: The Text Canvas Inspector](img/B18327_10_34.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图10.34：文本画布检查器](img/B18327_10_34.jpg)'
- en: 'Figure 10.34: The Text Canvas Inspector'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34：文本画布检查器
- en: Create a new UI Image and name it `TextHolder1`. Set its anchor and pivot to
    `uiElements_10` to the **Source Image**, and then select **Set Native Size** to
    cause the image’s size to be set to 223 x 158.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的UI Image，并将其命名为`TextHolder1`。将它的锚点和支点设置为`uiElements_10`到**源图像**，然后选择**设置原生大小**以使图像的大小设置为223
    x 158。
- en: 'This Panel will hold an image of our cat, some text, and a continue button.
    Utilizing anchors, pivots, and stretching, lay out the UI objects as children
    of `TextHolder1` so that they appear as illustrated:![Figure 10.35: TextHolder1
    and its children](img/B18327_10_35.jpg)'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此面板将包含我们的猫的图像、一些文本和一个继续按钮。利用锚点、支点和拉伸，将UI对象作为`TextHolder1`的子对象布局，以便它们看起来如图所示：![图10.35：TextHolder1及其子对象](img/B18327_10_35.jpg)
- en: 'Figure 10.35: TextHolder1 and its children'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.35：TextHolder1及其子对象
- en: Note that in the preceding screenshot, the `Text` child’s Rect Transform does
    not stretch all the way across the image of `TextHolder1`. That way, the text
    won’t cross over the white area of the window.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在前面的屏幕截图中，`Text`子组件的Rect Transform并没有延伸到`TextHolder1`图像的全宽。这样，文本就不会跨越窗口的白色区域。
- en: We’ll want to be able to turn this window on and off, so add a `TextHolder1`.
    Leave the settings at their default values.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够打开和关闭这个窗口，所以添加一个`TextHolder1`。保留默认设置。
- en: Now, let’s change the font. Go to https://www.dafont.com/milky-coffee.font and
    download the font named *Milky Coffee*.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更改字体。访问https://www.dafont.com/milky-coffee.font并下载名为*Milky Coffee*的字体。
- en: Add the `Milky Coffee` font to your `Assets/Fonts` folder and then drag it into
    the `Text` object’s **Text** component.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Milky Coffee`字体添加到`Assets/Fonts`文件夹中，然后将其拖放到`Text`对象的**Text**组件中。
- en: Change the font `18`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体更改为`18`。
- en: Duplicate `TextHolder1` and name the duplicate `TextHolder2`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`TextHolder1`并将其命名为`TextHolder2`。
- en: Replace the text on the `Text` child of `TextHolder1` with `"Hello there!"`
    and the text on the `Text` child of `TextHolder2` with `"I'm a cat and, for some
    reason, I'm` `collecting food!"`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextHolder1`的`Text`子组件上的文本替换为`"Hello there!"`，并将`TextHolder2`的`Text`子组件上的文本替换为`"I'm
    a cat and, for some reason, I'm` `collecting food!"`。
- en: Let’s hide and disable `TextHolder2` by disabling `0` on the **Canvas** **Group**
    component.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过禁用**Canvas** **Group**组件上的`0`来隐藏和禁用`TextHolder2`。
- en: Now, we’re ready to start animating our text!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始对文本进行动画处理了！
- en: Animating the text box text
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画文本框文本
- en: Now that we have our layout set up, we can animate our text. To do this, we
    will need to create a new script. This script will control the animation of the
    text, as well as load the next scene after all the text has been displayed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了布局，我们可以对文本进行动画处理。为此，我们需要创建一个新的脚本。这个脚本将控制文本的动画，并在所有文本显示完毕后加载下一个场景。
- en: 'To create animated text that looks like it’s typing out, complete the following
    steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建看起来像在打字的动画文本，请完成以下步骤：
- en: 'There are three things we want to group to create the animated text box: the
    Panel that holds the text, the text object that will display the message, and
    the string that we want to display. So, to group them all, we will need to create
    a class. Create a new class called `DialogueBox`.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要将以下三个元素组合起来创建动画文本框：包含文本的面板、将显示消息的文本对象以及我们想要显示的字符串。因此，为了将它们全部组合起来，我们需要创建一个类。创建一个名为`DialogueBox`的新类。
- en: 'Update the script so that it does not inherit from `MonoBehaviour` and looks
    as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新脚本，使其不继承自`MonoBehaviour`，并如下所示：
- en: '[PRE0]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ve used `[System.Serializable]` so that we will be able to see these values
    in the Inspector. Remember we need to use the `UnityEngine.UI` namespace whenever
    we use a `Text` type.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我使用了`[System.Serializable]`，这样我们就能在检查器中看到这些值。记住，每次我们使用`Text`类型时，都需要使用`UnityEngine.UI`命名空间。
- en: Create a new C# script called `DialogueSystem.cs`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DialogueSystem.cs`的新C#脚本。
- en: 'We will be writing code that implements scene loading and uses various `System`
    methods and collections. Therefore, we need to include the following namespaces
    at the top of our new script:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写实现场景加载并使用各种`System`方法和集合的代码。因此，我们需要在脚本顶部包含以下命名空间：
- en: '[PRE1]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s begin our variable declaration. First, we will create a list of
    `DialogueBox` objects called `dialogueBoxes`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始变量声明。首先，我们将创建一个名为`dialogueBoxes`的`DialogueBox`对象列表：
- en: '[PRE2]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `private` variable that will hold the name of the scene that loads
    after the text is done animating:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将保存动画后加载的场景名称的`private`变量：
- en: '[PRE3]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I marked it with the `SerializeField` attribute so that it can be assigned via
    the Inspector while still being private.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我用`SerializeField`属性标记了它，这样我们就可以通过检查器分配它，同时它仍然是私有的。
- en: 'Before we proceed, let’s assign these variables in the Unity Editor. Attach
    the `DialogueSystem.cs` script to the `Text Canvas` GameObject. You should see
    the following:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们在Unity编辑器中分配这些变量。将`DialogueSystem.cs`脚本附加到`Text Canvas`游戏对象上。你应该会看到以下内容：
- en: '![Figure 10.36: The Dialogue System component](img/B18327_10_36.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图10.36：对话系统组件](img/B18327_10_36.jpg)'
- en: 'Figure 10.36: The Dialogue System component'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36：对话系统组件
- en: 'Press the plus sign at the bottom of the `DialogueBox` class serializable,
    we should see the following:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DialogueBox`类序列化可编辑的底部按下加号，我们应该会看到以下内容：
- en: '![Figure 10.37: The Dialogue System component with two Elements](img/B18327_10_37.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图10.37：带有两个元素的对话系统组件](img/B18327_10_37.jpg)'
- en: 'Figure 10.37: The Dialogue System component with two Elements'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37：具有两个元素的对话系统组件
- en: Now, let’s drag the appropriate elements into the appropriate fields. Drag `TextHolder1`
    into `TextHolder2` into **Element 1**’s **Text Holder**.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将适当的元素拖放到相应的字段中。将`TextHolder1`拖放到`TextHolder2`拖放到**元素1**的**文本持有者**。
- en: Drag the `Text` child object of `TextHolder1` into `Text` child object of `TextHolder2`
    into **Element 1**’s **Text** **Display Box**.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextHolder1`的`Text`子对象拖放到`TextHolder2`的`Text`子对象拖放到**元素1**的**文本****显示框**。
- en: Now, update the `Hello there!` and `I'm a cat and, for some reason, I'm collecting
    food!` respectively. We will be generating the text within the text boxes via
    code. In the previous subsection, we added the text to the text boxes that we
    placed in the scene. However, due to the code we will write, that step will be
    rendered unnecessary. It was helpful adding the text to those text boxes, though,
    because we were able to see exactly how it will display.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`Hello there!`和`I'm a cat and, for some reason, I'm collecting food!`。我们将通过代码在文本框中生成文本。在先前的子节中，我们将文本添加到了场景中放置的文本框中。然而，由于我们将编写的代码，这一步将变得不再必要。尽管如此，将文本添加到这些文本框中是有帮助的，因为我们能够看到它将如何显示。
- en: 'The last thing we need to do in the Editor, for now, is assign the scene that
    the game will navigate to once the dialogue has completed. We’ll create a scene
    called `Chapter10-Examples` later, but, for now, let’s just assign the `Chapter9-Examples`
    scene to the `Chapter9-Examples`. Your completed component should look as follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，在编辑器中我们需要做的最后一件事是为对话完成后游戏将导航到的场景分配。我们稍后会创建一个名为`Chapter10-Examples`的场景，但，目前，让我们将`Chapter9-Examples`场景分配给`Chapter9-Examples`。您完成后的组件应如下所示：
- en: '![Figure 10.38: The Dialogue System component with all its properties filled
    out](img/B18327_10_38.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图10.38：填充了所有属性的对话系统组件](img/B18327_10_38.jpg)'
- en: 'Figure 10.38: The Dialogue System component with all its properties filled
    out'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38：填充了所有属性的对话系统组件
- en: 'Now, we can go back to our `DialogueSystem.cs` script. We aren’t quite done
    with our variable declaration. We need two variables that will track the string
    in our dialogue we wish to display, as well as which character within that specific
    string we are displaying. Add the following variable declaration to your script:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的`DialogueSystem.cs`脚本。我们的变量声明还没有完成。我们需要两个变量来跟踪我们想要显示的对话中的字符串，以及我们正在显示的特定字符串中的哪个字符。将以下变量声明添加到您的脚本中：
- en: '[PRE4]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that these two variables are not public or serialized and thus cannot be
    adjusted in the Inspector. Their values will be adjusted by the script. The `whichText`
    variable will allow us to switch between displaying the first string in the dialogue
    list and the second. The code we will write will easily be extendable to more
    strings. The `positionInString` variable will keep track of which character is
    being typed out by the animation. We want to keep track of this so that we can
    tell whether the text is being sped up by the user or if they have already read
    the whole text and just want to proceed to the next part.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这两个变量不是公共的或序列化的，因此不能在检查器中调整。它们的值将由脚本调整。`whichText`变量将允许我们在显示对话列表中的第一个字符串和第二个字符串之间切换。我们将编写的代码将很容易扩展到更多的字符串。`positionInString`变量将跟踪动画正在输入的哪个字符。我们想要跟踪这一点，以便我们可以判断文本是否被用户加速，或者他们是否已经阅读了整个文本，只想继续到下一部分。
- en: 'We will use a coroutine to animate our text one letter at a time. Coroutines
    work very well for timed and scheduled events. The last variable we need to declare
    will allow us to reference our coroutine so that we can easily stop it. Declare
    the following variable:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个协程来逐字动画化我们的文本。协程非常适合处理定时和计划事件。我们需要声明的最后一个变量将允许我们引用我们的协程，这样我们就可以轻松地停止它。声明以下变量：
- en: '[PRE5]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The coroutine that will control the text animation is as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制文本动画的协程如下：
- en: '[PRE6]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code finds the current string in the current dialogue box using the `whichText`
    variable and loops through all of its characters. With each step of the loop,
    the text property of the UI Text object is updated to display the first `i` characters
    of the string, where `i` represents the current step of the loop. It then increases
    the `positionInString` variable and waits a tenth of a second to display the next
    character by proceeding to the next step in the loop.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码使用`whichText`变量在当前对话框中查找当前字符串，并遍历其所有字符。在循环的每一步中，UI Text对象的文本属性被更新以显示字符串的前`i`个字符，其中`i`代表循环的当前步骤。然后增加`positionInString`变量，并等待十分之一秒来显示下一个字符，通过继续循环的下一步来实现。
- en: 'Before the preceding code will do anything, we need to start our coroutine.
    In the process of starting it, I also want to assign the `textPusher` variable.
    Add the following to the `Start()` function:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码执行任何操作之前，我们需要启动我们的协程。在启动的过程中，我还想分配`textPusher`变量。将以下内容添加到`Start()`函数中：
- en: '[PRE7]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you play your game now, you should see the *Hello there!* text type out within
    your scene.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你应该会看到场景中的*Hello there!*文本逐字出现。
- en: 'Currently, the coroutine only loops through the string in the first `DialogueBox`.
    We need to make it proceed to `DialogueBox` in the list by increasing the `whichText`
    variable. We also need to add functionality to allow players to show all the text
    so that they don’t have to wait for it to fully animate if they’re impatient.
    Let’s create a function that will be called by the press of our buttons. We’ll
    also create a function that compartmentalizes the enabling and disabling of a
    Canvas Group:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，协程只遍历第一个`DialogueBox`中的字符串。我们需要通过增加`whichText`变量使其继续遍历列表中的`DialogueBox`。我们还需要添加功能，允许玩家显示所有文本，这样他们就不必等待文本完全动画化，如果他们不耐烦的话。让我们创建一个函数，该函数将在按钮按下时被调用。我们还将创建一个函数，用于封装Canvas
    Group的启用和禁用：
- en: '[PRE8]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When a button is pressed, the code first determines whether the whole string
    has been displayed using the `positionInString` variable. If the `positionInString`
    variable is smaller than the total characters in the current string, it displays
    the complete string; otherwise, it proceeds.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按钮被按下时，代码首先使用`positionInString`变量确定是否已经显示了整个字符串。如果`positionInString`变量小于当前字符串中的总字符数，它将显示完整的字符串；否则，它将继续执行。
- en: When the `positionInString` variable is less than the total characters in the
    current string, the coroutine is stopped early with `StopCoroutine(textPusher)`.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`positionInString`变量小于当前字符串中的总字符数时，协程会通过`StopCoroutine(textPusher)`提前停止。
- en: The `text` property of the `textDisplayBox` is updated to display the full string,
    and the `positionInString` is set to the length of the string; that way, if the
    button is clicked again, this function will know that it can proceed to the next
    step.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`textDisplayBox`的`text`属性被更新以显示整个字符串，并将`positionInString`设置为字符串的长度；这样，如果按钮再次被点击，这个函数将知道它可以继续到下一步。'
- en: When the `positionInString` variable is not less than the total characters in
    the current string, the current Canvas Group is deactivated, and then the `whichText`
    variable is increased. Once this variable is increased, the code checks whether
    any more text boxes need animating. If there are not, the next scene loads. If
    more text boxes need animating, the `positionInString` variable is reset to `0`,
    so the very first character in the string will be displayed first. The new Canvas
    Group is now activated, and the `textPusher` variable is reassigned so that the
    coroutine loop will play again.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`positionInString`变量不小于当前字符串中的总字符数时，当前Canvas Group被禁用，然后`whichText`变量增加。一旦这个变量增加，代码会检查是否还有其他文本框需要动画化。如果没有，则加载下一个场景。如果有更多文本框需要动画化，则将`positionInString`变量重置为`0`，这样字符串中的第一个字符将首先显示。新的Canvas
    Group现在被激活，`textPusher`变量被重新分配，以便协程循环再次播放。
- en: Now that our code is done, we just need to hook up our buttons to perform the
    function described in the previous step. For both buttons on both `TextHolder`
    objects, set the `ProceedText()` function in the `DialogueSystem` script attached
    to the `Text Canvas`. Now, when you play the game, clicking on the button when
    the text isn’t finished typing will cause it to fully display, and clicking on
    the button when the text has fully displayed will display the next dialogue or
    the next scene.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了代码，我们只需要将我们的按钮连接到执行之前步骤中描述的功能。对于两个 `TextHolder` 对象上的所有按钮，将 `DialogueSystem`
    脚本中的 `ProceedText()` 函数设置到 `Text Canvas` 上。现在，当你玩游戏时，当你点击按钮而文本尚未完全输入时，它将完全显示，当你点击按钮而文本已经完全显示时，将显示下一个对话或下一个场景。
- en: To improve on this, you can also create a prefab of the `TextHolder` object
    and write code that instantiates into the scene based on `Dialogue List`. I recommend
    implementing this change if you will be making a more complicated dialogue system.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这一点，你也可以创建一个 `TextHolder` 对象的预制体，并编写代码根据 `Dialogue List` 在场景中实例化。如果你将要制作一个更复杂的对话系统，我建议实施这个更改。
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code example provided in this book’s code bundle includes code comments
    not shown here as it was too cluttered to display in this text.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码包中提供的代码示例包括一些代码注释，这里没有显示，因为它们太拥挤，无法在此文本中显示。
- en: Translating the dialogue
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译对话
- en: Let’s expand upon our animated text example so that it includes translations.
    This is a basic example to demonstrate how to access certain properties of Text
    components and isn’t necessarily architected in a way that would be sustainable
    for a large project.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的动画文本示例，使其包括翻译。这是一个基本示例，用于演示如何访问文本组件的某些属性，并且不一定是以适合大型项目的方式架构的。
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please note that I used Google Translate to obtain these translations, so they
    may not be fully accurate:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用了 Google Translate 来获取这些翻译，因此它们可能不完全准确：
- en: '![](img/B18327_10_39.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18327_10_39.jpg)'
- en: 'Figure 10.39: Google Translate'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 10.39: Google Translate'
- en: 'To add translation to the animated text example we completed previously, complete
    the following steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要将翻译添加到我们之前完成的动画文本示例中，请完成以下步骤：
- en: 'Open the `DialogueBox.cs` script and add the following namespace to the top
    of the script:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DialogueBox.cs` 脚本，并将以下命名空间添加到脚本顶部：
- en: '[PRE9]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s add a subclass to this script that will group all the translations with
    the appropriate settings. We’ll use this subclass to hold information about not
    only the translated text but the appropriate font:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向此脚本添加一个子类，该子类将根据适当的设置分组所有翻译。我们将使用此子类来存储有关翻译文本以及适当字体的信息：
- en: '[PRE10]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `languageKey` string will be used as a key to finding the appropriate translation.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`languageKey` 字符串将用作键来查找适当的翻译。'
- en: 'Now, add a list that will hold all of the translations:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个列表来存储所有翻译：
- en: '[PRE11]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your `DialogueSystem` component should now be updated to look like the following:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 `DialogueSystem` 组件现在应该更新为以下样子：
- en: '![](img/B18327_10_40.jpg)'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18327_10_40.jpg)'
- en: 'Figure 10.40: The Dialogue System component with translations'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 10.40: The Dialogue System component with translations'
- en: 'Let’s add a few translations to the `translations` list. We’ll use the ISO
    639-1 two-digit codes as keys for each language. Add the following four key codes
    to the translation list to indicate Spanish, Japanese, Simplified Chinese, and
    Korean:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `translations` 列表中添加一些翻译。我们将使用 ISO 639-1 双数字代码作为每种语言的键。将以下四个键代码添加到翻译列表中，以表示西班牙语、日语、简体中文和韩语：
- en: '![Figure 10.41: The translation keys filled out on the Dialogue Boxes](img/B18327_10_41.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.41: The translation keys filled out on the Dialogue Boxes](img/B18327_10_41.jpg)'
- en: 'Figure 10.41: The translation keys filled out on the Dialogue Boxes'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 10.41: The translation keys filled out on the Dialogue Boxes'
- en: To save yourself time with entering these keys, copy this list by right-clicking
    on the word `I'm a cat and, for some reason, I'm collecting food!` element, paste
    this list to its **Translations** by right-clicking and selecting **Paste**.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省输入这些键的时间，通过右键单击“**I'm a cat and, for some reason, I'm collecting food!**”元素，通过右键单击并选择**粘贴**来复制此列表，并将其粘贴到其**翻译**中。
- en: 'Now, let’s enter the translations. Enter the following data into the **Translated**
    **String** properties:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始翻译。将以下数据输入到 **Translated** **String** 属性中：
- en: '| **Key** | **Hello there!** | **I’m a cat and, for some reason, I’m** **collecting
    food!** |'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **Key** | **Hello there!** | **I’m a cat and, for some reason, I’m** **collecting
    food!** |'
- en: '| es | ¡Hola! | ¡Soy un gato y, por alguna razón, estoy recolectando comida!
    |'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| es | ¡Hola! | ¡Soy un gato y, por alguna razón, estoy recolectando comida!
    |'
- en: '| ja | こんにちは！ | 私は猫で、なぜか食べ物を集めています！ |'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ja | こんにちは！ | 私は猫で、なぜか食べ物を集めています！ |'
- en: '| zh | 你好呀！ | 我是一只猫，出于某种原因，我正在收集食物！ |'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| zh | 你好呀！ | 我是一只猫，出于某种原因，我正在收集食物！ |'
- en: '| ko | 안녕! | 나는 고양이고, 왠지 모를 음식을 모으고 있다! |'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ko | 안녕! | 나는 고양이고, 왠지 모를 음식을 모으고 있다! |'
- en: 'Table 10.5: The translation strings to enter'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表 10.5：需要输入的翻译字符串
- en: You’ll notice that the Unity Engine is capable of rendering these languages
    in the Inspector.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到 Unity 引擎能够在检查器中渲染这些语言。
- en: 'We now need to assign some fonts to each language. The current font, `Milky
    Coffee`*,* does not support these four languages. If we try to replace the text
    with one of these translations, the engine will render any non-supported glyph
    in a font that does support it but render all supported glyphs (such as punctuation)
    in the `Milky Coffee` font. This will result in an inconsistent style that honestly
    doesn’t look great. For example, as shown in the following figure, the comma and
    exclamation point are not in the same font as the rest of the text:![Figure 10.42:
    The dialogue box with the Korean text rendering in two fonts](img/B18327_10_42.jpg)'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要为每种语言分配一些字体。当前的字体 `Milky Coffee`* 不支持这四种语言。如果我们尝试用这些翻译中的任何一个替换文本，引擎将使用支持它的字体渲染任何非支持符号，但将所有支持符号（如标点符号）渲染在
    `Milky Coffee` 字体中。这将导致风格不一致，实际上看起来并不好。例如，如图所示，逗号和感叹号与文本的其余部分不在同一字体中：![图 10.42：使用两种字体渲染韩文文本的对话框](img/B18327_10_42.jpg)
- en: 'Figure 10.42: The dialogue box with the Korean text rendering in two fonts'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.42：使用两种字体渲染韩文文本的对话框
- en: Therefore, we’ll want to change the font whenever the translation occurs to
    one that we specifically choose. I will use the `ZCOOL KuaiLe` font for the Simplified
    Chinese translation and `RocknRoll One` for all the others.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，每当发生翻译时，我们希望更改字体为我们特别选择的字体。我将使用 `ZCOOL KuaiLe` 字体进行简体中文翻译，而其他所有语言则使用 `RocknRoll
    One` 字体。
- en: 'Download the fonts from the following locations and add them to your `Assets/Fonts`
    folder:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下位置下载字体并将其添加到你的 `Assets/Fonts` 文件夹：
- en: '[https://fonts.google.com/specimen/ZCOOL+KuaiLe](https://fonts.google.com/specimen/ZCOOL+KuaiLe)'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://fonts.google.com/specimen/ZCOOL+KuaiLe](https://fonts.google.com/specimen/ZCOOL+KuaiLe)'
- en: '[https://fonts.google.com/specimen/RocknRoll+One](https://fonts.google.com/specimen/RocknRoll+One)'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://fonts.google.com/specimen/RocknRoll+One](https://fonts.google.com/specimen/RocknRoll+One)'
- en: 'Assign the correct fonts to each of the translations. Your two elements in
    your **Dialogue Boxes** list should look as follows:![Figure 10.43: The two dialogue
    boxes with all properties completed](img/B18327_10_43.jpg)'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正确的字体分配给每个翻译。你的 **Dialogue Boxes** 列表中的两个元素应如下所示：![图 10.43：两个对话框，所有属性已完成](img/B18327_10_43.jpg)
- en: 'Figure 10.43: The two dialogue boxes with all properties completed'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.43：两个对话框，所有属性已完成
- en: I’ve included the option to change the font style, but I’m going to leave them
    all at **Normal** for this example.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经包括了更改字体样式的选项，但在这个例子中，我将它们都设置为 **正常**。
- en: Let’s write the code that will translate our text. Add the following variable
    declaration to the top of the `DialogueSystem.cs` script so that it will be the
    first variable declaration. This will be used to determine which language our
    game should display at runtime.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写将翻译我们的文本的代码。将以下变量声明添加到 `DialogueSystem.cs` 脚本顶部，使其成为第一个变量声明。这将用于确定游戏在运行时应该显示哪种语言。
- en: '[PRE12]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following method to the bottom of the script:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到脚本底部：
- en: '[PRE13]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method will find which of the translations have the key designated by the
    `currentLanguage` variable. It will then change the `dialogue` variable, the `font`,
    and the `fontStyle` to the appropriate values. If the `currentLanguage` variable
    is not found in any of the `languageKey`s, `index` will equal `-1` and no changes
    will be implemented.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将找到具有 `currentLanguage` 变量指定的键的翻译之一。然后，它将更改 `dialogue` 变量、`font` 和 `fontStyle`
    为适当的值。如果 `currentLanguage` 变量在任何 `languageKey` 中找不到，则 `index` 将等于 `-1`，并且不会实施任何更改。
- en: 'To make sure the translation happens, we need to call the method from the `Awake()`
    method. Add the following above your `Start()` method:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保翻译发生，我们需要从 `Awake()` 方法中调用该方法。在你的 `Start()` 方法上方添加以下内容：
- en: '[PRE14]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Go back to the Editor and enter `es` into the **Current Language** slot. You’ll
    see that the dialogue now translates and changes font when you press play. However,
    there is a problem displaying the text. You’ll notice that the text gets cut off
    in the second Panel:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器并将 `es` 输入到 **Current Language** 槽中。你会看到当你按下播放时，对话框现在会翻译并更改字体。然而，显示文本存在问题。你会注意到文本在第二个面板中被截断：
- en: '![Figure 10.44: The Spanish translation getting cut off](img/B18327_10_44.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图10.44：西班牙语翻译被截断](img/B18327_10_44.jpg)'
- en: 'Figure 10.44: The Spanish translation getting cut off'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.44：西班牙语翻译被截断
- en: Recall, from the *Translating text* section, that you should not only make sure
    that your font will render the text but that your text boxes will have enough
    room for the translated text, which may be much longer (especially when rendered
    in a different font)! The easiest way to fix this is to use the `Text` objects
    in the Hierarchy and then select the **Best Fit** setting from their **Text**
    components.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，从*翻译文本*部分，你应该确保你的字体不仅能渲染文本，而且文本框有足够的空间来容纳翻译后的文本，这可能会更长（尤其是在渲染为不同字体时）！最简单的方法是使用层次结构中的`Text`对象，然后从它们的**文本**组件中选择**最佳匹配**设置。
- en: After selecting the `18`. This will stop the text from getting too large.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`18`后，这将阻止文本变得过大。
- en: A downside to using **Best Fit** in this example is the font size changes as
    the text animates. It’s not ideal. But, to maintain the text box size, we didn’t
    have much choice – for now! After we learn about Scroll Rects and Masks in [*Chapter
    12*](B18327_12.xhtml#_idTextAnchor328), we can maintain the font size while scrolling
    through the text.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中使用**最佳匹配**的一个缺点是，随着文本的动画，字体大小会发生变化。这并不理想。但是，为了保持文本框大小，我们别无选择——目前是这样！在我们学习了[*第12章*](B18327_12.xhtml#_idTextAnchor328)中的滚动矩形和遮罩之后，我们可以在滚动文本时保持字体大小。
- en: Custom font
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义字体
- en: 'Let’s take a step away from building out our scenes for a moment to explore
    making a custom font. We won’t be using this custom font in the scenes we’ve been
    working on, but the process of creating a custom font is still important to cover.
    We’ll create a custom font that displays the numbers 0 through 9 using the following
    sprites:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放下构建场景的工作，来探索制作自定义字体的过程。我们不会在我们一直在工作的场景中使用这个自定义字体，但创建自定义字体的过程仍然很重要。我们将使用以下精灵来创建一个显示数字0到9的自定义字体：
- en: '![Figure 10.45: The custom font we will create](img/B18327_10_45.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图10.45：我们将创建的自定义字体](img/B18327_10_45.jpg)'
- en: 'Figure 10.45: The custom font we will create'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.45：我们将创建的自定义字体
- en: The sprites used to create the font are modified from the free art asset found
    at [https://opengameart.org/content/shooting-gallery](https://opengameart.org/content/shooting-gallery).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字体的精灵是从[https://opengameart.org/content/shooting-gallery](https://opengameart.org/content/shooting-gallery)找到的免费艺术资产中修改的。
- en: To create an evenly spaced sprite sheet for this font, I used the TexturePacker
    program, along with Photoshop. The process can be done entirely with a photo editing
    software such as Photoshop, but TexturePacker simplifies the process. TexturePacker
    can be found at [https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个均匀分布的精灵表，我使用了TexturePacker程序和Photoshop。这个过程可以用像Photoshop这样的照片编辑软件完全完成，但TexturePacker简化了过程。TexturePacker可以在[https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker)找到。
- en: The process of creating a custom font is time-consuming and kind of a pain.
    To create a custom font, you have to put in coordinate locations for each character
    you plan on rendering with the font, so I don’t recommend it for anything other
    than numbers or a very limited character set.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义字体的过程既耗时又有点痛苦。要创建自定义字体，你必须为每个你打算用该字体渲染的字符输入坐标位置，因此我不建议用于除了数字或非常有限的字符集之外的其他任何东西。
- en: If you want a custom font with a more robust character set, check out the Unity
    asset store for various options on streamlining the bitmap font process.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个具有更丰富字符集的自定义字体，请查看Unity资产商店中关于简化位图字体过程的多种选项。
- en: 'To create the custom font displayed in the preceding figure, complete the following
    steps:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前面图中显示的自定义字体，请完成以下步骤：
- en: Create a new folder called `Custom Fonts` within your `Assets/Fonts` folder.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Assets/Fonts`文件夹中创建一个名为`Custom Fonts`的新文件夹。
- en: 'Find the `customFontSpriteSheet.png` file within the code bundle and drag the
    file into the folder you created in *Step 1*. The sprite sheet appears as follows:![Figure
    10.46: The custom sprite sheet](img/B18327_10_46.jpg)'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码包中找到`customFontSpriteSheet.png`文件，并将其拖放到你在*步骤1*中创建的文件夹中。精灵表看起来如下所示：![图10.46：自定义精灵表](img/B18327_10_46.jpg)
- en: 'Figure 10.46: The custom sprite sheet'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.46：自定义精灵表
- en: When manually creating a custom font, your characters must be spaced evenly.
    This will make your life significantly easier while entering the settings of the
    individual characters. You can leave the sprite sheet’s import settings at the
    defaults of **Sprite (2D and UI) Texture Type** and **Single** **Sprite Mode**.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当手动创建自定义字体时，你的字符必须均匀分布。这将使你在输入单个字符设置时生活变得更加容易。你可以将精灵图集的导入设置保留在**精灵（2D和UI）纹理类型**和**单精灵模式**的默认值。
- en: A custom font requires a material to render. Create a new material by right-clicking
    in your `Custom Fonts` folder and selecting `CustomFontMaterial`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义字体需要一个材质来渲染。通过在`Custom Fonts`文件夹中右键单击并选择`CustomFontMaterial`来创建一个新的材质。
- en: 'Select `CustomFontMaterial` to bring up its `customFontSpriteSheet.png` into
    the square next to **Albedo** in **Main Maps**. Once you do so, the material’s
    preview image should update:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`CustomFontMaterial`以将其`customFontSpriteSheet.png`拖放到**主贴图**中**Albedo**旁边的方形中。一旦这样做，材质的预览图像应该会更新：
- en: '![Figure 10.47: The custom font material](img/B18327_10_47.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图10.47：自定义字体材质](img/B18327_10_47.jpg)'
- en: 'Figure 10.47: The custom font material'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47：自定义字体材质
- en: 'Now, we need to change the material’s shader. There are a few different options
    you can use for the shader: you can use **UI** | **Default** or any of the unlit
    or unlit UI options. My preference is to use **GUI** | **Text Shader** as I tend
    to have the best luck with it rendering correctly, and I prefer the way it displays
    in the **Project** view:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更改材质的着色器。你可以使用几种不同的着色器选项：你可以使用**UI** | **默认**或任何无光照或无光照UI选项。我的偏好是使用**GUI**
    | **文本着色器**，因为我通常在正确渲染方面运气最好，并且我更喜欢它在**项目**视图中的显示方式：
- en: '![Figure 10.48: The custom font material updated](img/B18327_10_48.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图10.48：自定义字体材质更新](img/B18327_10_48.jpg)'
- en: 'Figure 10.48: The custom font material updated'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.48：自定义字体材质更新
- en: Now, we can create our custom font. Within the `Custom Fonts` folder, right-click
    and select `CustomFont`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的自定义字体。在`Custom Fonts`文件夹中，右键单击并选择`CustomFont`。
- en: Select `CustomFont` and assign `CustomFontMaterial` to the **Default** **Material**
    slot.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`CustomFont`并将`CustomFontMaterial`分配给**默认材质**槽。
- en: 'The properties under `1` for now. We will change it to `10` once we have the
    properties that will repeat for all characters entered. When you set the `1`,
    you should see the properties of **Element** **0** appear:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前在`1`下的属性。一旦我们有了所有字符将重复的属性，我们将将其更改为`10`。当你设置`1`时，你应该看到**元素0**的属性出现：
- en: '![Figure 10.49: The Character Rects of the custom font](img/B18327_10_49.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图10.49：自定义字体的字符矩形](img/B18327_10_49.jpg)'
- en: 'Figure 10.49: The Character Rects of the custom font'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.49：自定义字体的字符矩形
- en: 'The first properties that repeat for all characters are **UV** **W** and **UV**
    **H**. These values represent the percentage of the sprite’s total width and total
    height that the individual character takes up. Since our characters are all evenly
    spaced in our sprite sheet, these values will be the same for all characters.
    If your characters are evenly sized, you can calculate these values as follows:![Figure
    10.50: Calculating the UV W and UV H values](img/B18327_10_50.jpg)'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有字符重复的第一个属性是**UV W**和**UV H**。这些值表示单个字符占据精灵总宽度和总高度的百分比。由于我们的字符在精灵图中均匀分布，这些值对所有字符都相同。如果你的字符大小均匀，你可以按以下方式计算这些值：![图10.50：计算UV
    W和UV H值](img/B18327_10_50.jpg)
- en: 'Figure 10.50: Calculating the UV W and UV H values'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.50：计算UV W和UV H值
- en: There are a total of five columns of characters. Therefore, each sprite takes
    up one-fifth of the width of the sprite. One-fifth is equal to 20% or 0.2 as a
    decimal. We need to put `0.2` in the `1/5` in the `0.2` decimal.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总共有五列字符。因此，每个精灵占据精灵宽度的一半。五分之一等于20%或0.2作为小数。我们需要在`0.2`的`1/5`处放入`0.2`。
- en: There are a total of two rows of characters. Therefore, each sprite takes up
    one-half of the height of the sprite; one-half is equal to 50% or 0.5 as a decimal.
    Typing `1/2` in the `0.5` in the slot.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总共有两行字符。因此，每个精灵占据精灵高度的一半；一半等于50%或0.5作为小数。在槽中的`0.5`处键入`1/2`。
- en: The next values that repeat for each character are the `50` in the `-57` in
    the **H** slot. Remember that the **H** value will always be negative!
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个字符重复的下一个值是**H**槽中的`-57`中的`50`。记住，**H**值始终是负数！
- en: The last property that remains consistent throughout all the characters is the
    `51`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有字符中保持一致性的最后一个属性是`51`。
- en: 'After completing *Steps 9* through *11*, your **Element 0** character should
    have the following properties:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在完成 *步骤 9* 至 *11* 后，你的 **元素 0** 角色应具有以下属性：
- en: '![Figure 10.51: Element 0 with its values filled in](img/B18327_10_51.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.51：已填写值的元素 0](img/B18327_10_51.jpg)'
- en: 'Figure 10.51: Element 0 with its values filled in'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.51：已填写值的元素 0
- en: 'Now that we have placed all the repeated properties, we can increase the `10`.
    You’ll see that once we do this, the properties of **Element 0** are repeated
    in **Element 1** through **Element 9**:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经放置了所有重复的属性，我们可以增加 `10`。你会看到一旦我们这样做，**元素 0** 的属性就会在 **元素 1** 到 **元素 9**
    中重复：
- en: '![Figure 10.52: Element 0 duplicated through Element 10](img/B18327_10_52.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.52：通过元素 10 复制的元素 0](img/B18327_10_52.jpg)'
- en: 'Figure 10.52: Element 0 duplicated through Element 10'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.52：通过元素 10 复制的元素 0
- en: 'Now, we need to specify the ASCII index of each element. This will tie the
    typed text to the correct sprite. Without this, the font wouldn’t know that typing
    the number 0 should show the first sprite in the sheet. The following table indicates
    that the numbers 0 to 9 are the ASCII numbers 48 to 57: [http://www.ascii.cl/](http://www.ascii.cl/).'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要指定每个元素的 ASCII 索引。这将把输入的文本与正确的精灵绑定起来。没有这个，字体不知道输入数字 0 应该显示图集中的第一个精灵。以下表格表明数字
    0 到 9 是 ASCII 数字 48 到 57：[http://www.ascii.cl/](http://www.ascii.cl/).
- en: Therefore, we should enter the `48` through `57` in `0`
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们应该在 `0` 中输入 `48` 到 `57`。
- en: '`1`'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`2`'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2`'
- en: '`3`'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`3`'
- en: '`4`'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`4`'
- en: '`5`'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`5`'
- en: '`6`'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`6`'
- en: '`7`'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`7`'
- en: '`8`'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`8`'
- en: '`9`'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`9`'
- en: '`48`'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`48`'
- en: '`49`'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`49`'
- en: '`50`'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`51`'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`51`'
- en: '`52`'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`52`'
- en: '`53`'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`53`'
- en: '`54`'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`54`'
- en: '`55`'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`55`'
- en: '`56`'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`56`'
- en: '`57`'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`57`'
- en: 'Table 10.6: The index values of each element'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.6：每个元素的索引值
- en: 'The next step is to specify the **UV** **X** and **Y** values. This is the
    part of creating custom fonts that takes up the most time. These values represent
    the UV coordinate position of the characters in the sprite sheet. These numbers
    are calculated based on the row and column numbers that the character lies in.
    The row and column numbers start at 0 and start in the bottom-left corner:![Figure
    10.53: The rows and columns of the sprite sheet](img/B18327_10_53.jpg)'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是指定 **UV** **X** 和 **Y** 值。这是创建自定义字体花费时间最多的部分。这些值代表字符在精灵图中的 UV 坐标位置。这些数字基于字符所在的行和列号计算得出。行和列号从
    0 开始，从左下角开始：![图 10.53：精灵图的行和列](img/B18327_10_53.jpg)
- en: 'Figure 10.53: The rows and columns of the sprite sheet'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.53：精灵图的行和列
- en: 'To calculate the **UV** **X** and **UV** **Y** values, use the following formulas:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要计算 **UV** **X** 和 **UV** **Y** 值，请使用以下公式：
- en: '![Figure 10.54: Calculating UV X and UV Y](img/B18327_10_54.jpg)'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.54：计算 UV X 和 UV Y](img/B18327_10_54.jpg)'
- en: 'Figure 10.54: Calculating UV X and UV Y'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.54：计算 UV X 和 UV Y
- en: Remember that since our characters are evenly spaced, our **UV** **W** and **UV**
    **H** values are the same for each character.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，由于我们的字符均匀分布，我们的 **UV** **W** 和 **UV** **H** 值对每个字符都是相同的。
- en: So, if we look at `0`. Its `0.5`.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，如果我们看 `0`，它的 `0.5`。
- en: 'The following chart represents the **UV** **X** and **UV** **Y** values that
    should be entered for each character:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下表表示每个字符应输入的 **UV** **X** 和 **UV** **Y** 值：
- en: '| **Element** | **UV X** | **UV Y** |'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **元素** | **UV X** | **UV Y** |'
- en: '| `0` | `0` | `0.5` |'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `0` | `0` | `0.5` |'
- en: '| `1` | `0.2` | `0.5` |'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `1` | `0.2` | `0.5` |'
- en: '| `2` | `0.4` | `0.5` |'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `2` | `0.4` | `0.5` |'
- en: '| `3` | `0.6` | `0.5` |'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `3` | `0.6` | `0.5` |'
- en: '| `4` | `0.8` | `0.5` |'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `4` | `0.8` | `0.5` |'
- en: '| `5` | `0` | `0` |'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `5` | `0` | `0` |'
- en: '| `6` | `0.2` | `0` |'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `6` | `0.2` | `0` |'
- en: '| `7` | `0.4` | `0` |'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `7` | `0.4` | `0` |'
- en: '| `8` | `0.6` | `0` |'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `8` | `0.6` | `0` |'
- en: '| `9` | `0.8` | `0` |'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `9` | `0.8` | `0` |'
- en: 'Table 10.7: The UV X and UV Y properties of the font'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表 10.7：字体的 UV X 和 UV Y 属性
- en: 'The following figure provides a more visual representation of the coordinate
    pattern:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图提供了坐标模式的更直观表示：
- en: '![Figure 10.55: The coordinates of the sprite sheet](img/B18327_10_55.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.55：精灵图坐标](img/B18327_10_55.jpg)'
- en: 'Figure 10.55: The coordinates of the sprite sheet'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.55：精灵图坐标
- en: 'Now, we can test our font to see whether it works. Within any of your scenes,
    create a new `Custom Font Text`. I have created a new scene called `Chapter10-Examples-CustomFont`
    on which I have my test fonts. Change the `0123456789` and drag the `CustomFont`
    into the **Font** slot. You should see something like the following:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的字体，看看它是否工作。在任何场景中，创建一个新的 `自定义字体文本`。我创建了一个名为 `Chapter10-Examples-CustomFont`
    的新场景，其中包含我的测试字体。更改 `0123456789` 并将 `CustomFont` 拖到 **字体** 槽中。你应该会看到以下内容：
- en: '![Figure 10.56: The custom font as it should be displayed after Step 15](img/B18327_10_56.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图10.56：步骤15后应显示的自定义字体](img/B18327_10_56.jpg)'
- en: 'Figure 10.56: The custom font as it should be displayed after Step 15'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.56：步骤15后应显示的自定义字体
- en: 'To make it display correctly, expand the size of the text box to accommodate
    all the characters and change the text color to white:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要正确显示，请扩展文本框的大小以容纳所有字符，并将文本颜色更改为白色：
- en: '![Figure 10.57: The custom font after adjusting some properties](img/B18327_10_57.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图10.57：调整了一些属性后的自定义字体](img/B18327_10_57.jpg)'
- en: 'Figure 10.57: The custom font after adjusting some properties'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.57：调整了一些属性后的自定义字体
- en: Now that we’ve completed importing our custom font, let’s look at adjusting
    it further.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了自定义字体的导入，让我们看看如何进一步调整它。
- en: Adjusting the character spacing and changing the font size
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整字符间距和更改字体大小
- en: 'In our example, all the numbers are evenly spaced and the font size cannot
    be changed. You will likely want your numbers to be closer together or of a different
    font size. Let’s alter our custom font so that the sprites are closer together.
    The following figure shows our font after the adjustments versus the original
    we created in the last part of this example:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，所有数字都是均匀间隔的，字体大小不能更改。你可能会希望数字更靠近或使用不同的字体大小。让我们修改我们的自定义字体，使精灵更靠近。以下图显示了调整后的字体与我们在本例最后一部分创建的原始字体的对比：
- en: '![Figure 10.58: The custom font with and without spacing adjustment](img/B18327_10_58.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图10.58：带和不带间距调整的自定义字体](img/B18327_10_58.jpg)'
- en: 'Figure 10.58: The custom font with and without spacing adjustment'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.58：带和不带间距调整的自定义字体
- en: 'To change the spacing of the characters, complete the following steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字符间距，请完成以下步骤：
- en: Duplicate the `CustomFont` with *Ctrl* + *D* and rename the duplicate `CustomFontTight`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`CustomFont`，使用*Ctrl* + *D*并重命名副本为`CustomFontTight`。
- en: Open the Inspector of `CustomFontTight`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CustomFontTight`的检查器。
- en: 'If you’d like the numbers to be closer together, you simply have to change
    the **Advance** property for the specific elements. The **Advance** property represents
    the pixels from the start of the sprite to the start of the next sprite. So, if
    we wanted the number 2 to appear closer to the number 1, we could change the **Advance**
    property of **Element 1** to something smaller, as shown here:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望数字更靠近，你只需更改特定元素的**Advance**属性。**Advance**属性表示从精灵开始到下一个精灵开始的像素数。因此，如果我们想让数字2看起来更靠近数字1，我们可以将**Element
    1**的**Advance**属性更改为更小的值，如下所示：
- en: '![Figure 10.59: The 1 glyph spacing problem](img/B18327_10_59.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图10.59：1符号间距问题](img/B18327_10_59.jpg)'
- en: 'Figure 10.59: The 1 glyph spacing problem'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.59：1符号间距问题
- en: Note
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can change the settings on your custom font while previewing the results
    in the scene. To get the text to refresh in the scene after making a change to
    your custom font, you have to save the scene first.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在场景中预览结果的同时更改自定义字体的设置。为了在更改自定义字体后使场景中的文本刷新，你必须首先保存场景。
- en: Adjust the `0`
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`0`
- en: '`1`'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`2`'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2`'
- en: '`3`'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`3`'
- en: '`4`'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`4`'
- en: '`5`'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`5`'
- en: '`6`'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`6`'
- en: '`7`'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`7`'
- en: '`8`'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`8`'
- en: '`9`'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`9`'
- en: '`38`'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`38`'
- en: '`30`'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`30`'
- en: '`35`'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`35`'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`35`'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`35`'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`35`'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`35`'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: '`38`'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`38`'
- en: '`35`'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`35`'
- en: 'Table 10.8: Advance properties of the custom font'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.8：自定义字体的**Advance**属性
- en: 'The font should now appear as follows:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字体现在应该如下所示：
- en: '![Figure 10.60: All the glyphs of the font displayed](img/B18327_10_60.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图10.60：显示字体的所有符号](img/B18327_10_60.jpg)'
- en: 'Figure 10.60: All the glyphs of the font displayed'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.60：显示字体的所有符号
- en: 'There is still a bit too much spacing between the 0 and the 1; however, if
    you try to reduce the **Advance** property on the 0 to bring the 1 closer, other
    numbers will overlap the 0 if they follow the 0\. The following example shows
    what will happen if the **Advance** property of **Element 0** were reduced to
    35; the 1 looks good following 0, but the 9 overlaps it:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0和1之间的间距仍然有点大；然而，如果你尝试减少0的**Advance**属性以使1更靠近，如果其他数字跟在0后面，它们将会与0重叠。以下示例显示了如果将**Element
    0**的**Advance**属性减少到35会发生什么；1看起来在0后面很好，但9与之重叠：
- en: '![Figure 10.61: Different Advance settings on the 0 glyph](img/B18327_10_61.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![图10.61：0符号的不同Advance设置](img/B18327_10_61.jpg)'
- en: 'Figure 10.61: Different Advance settings on the 0 glyph'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.61：0符号的不同Advance设置
- en: Keeping that in mind, we need to bring 1 closer in our scenario. To move the
    1 closer, we need to change the `-3` to shift it left just a smidge. This will
    give the character a more favorable spacing.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住这一点，我们需要在我们的场景中将1号位置靠近一些。为了将1号位置靠近，我们需要将`-3`改为向左稍微移动一点。这将给字符带来更合适的间距。
- en: Now, if you’d like to adjust the font size, you cannot change the size of a
    custom font by changing the `0.5`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想调整字体大小，您不能通过改变`0.5`来改变自定义字体的大小。
- en: As I mentioned earlier, we probably won’t be using this font to build our master
    example scene, but the process of creating a custom font is still a useful exercise.
    Now, let’s move on to creating some other common UI assets – health bars and progress
    bars.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们可能不会使用这个字体来构建我们的主示例场景，但创建自定义字体的过程仍然是一个有用的练习。现在，让我们继续创建一些其他常见的UI资产——生命条和进度条。
- en: TextMeshPro - Warped Text with Gradient
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextMeshPro - 带渐变的扭曲文本
- en: 'The banner of our `Pause Panel` looks a bit bare currently. Now that we’ve
    covered using TextMeshPro - Text, we can create a nice curved text with a gradient
    that lines up well with our banner:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前暂停面板的横幅看起来有点单调。现在我们已经介绍了使用TextMeshPro - 文本，我们可以创建一个与横幅很好地对齐的漂亮弯曲文本和渐变：
- en: '![Figure 10.62: The banner text with a gradient and warp](img/B18327_10_62.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![图10.62：带有渐变和扭曲的横幅文本](img/B18327_10_62.jpg)'
- en: 'Figure 10.62: The banner text with a gradient and warp'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.62：带有渐变和扭曲的横幅文本
- en: 'To create the curved text shown in the preceding screenshot, complete the following
    steps:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前面截图所示的弯曲文本，请完成以下步骤：
- en: Duplicate the `Chapter 9``-Examples` scene and name the new scene `Chapter 10``-Examples`.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`Chapter 9-Examples`场景，并将新场景命名为`Chapter 10-Examples`。
- en: Select the `Pause Banner` UI Image and give it a child Text (TMP) object by
    right-clicking on it in the Hierarchy and selecting `Paused TMP`.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击层次结构中的`Pause Banner` UI图像，并选择`Paused TMP`以给它添加一个子Text (TMP)对象。
- en: If you have not done so already, select **Import TMP Essentials** and **Import
    TMP Examples & Extras** when the popup prompts you to do so. If you previously
    only imported TMP Essentials, but not the examples, go to **File | Project Settings**
    | **TextMeshPro** and select **Import TMP Examples &** **Extras.**
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，当弹出提示时，选择**导入TMP Essentials**和**导入TMP Examples & Extras**。如果您之前只导入了TMP
    Essentials，但没有导入示例，请转到**文件 | 项目设置** | **TextMeshPro**并选择**导入TMP Examples & Extras**。
- en: In the `Paused`.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Paused`状态下。
- en: Set the **Font Style** to **Bold**.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**字体样式**设置为**粗体**。
- en: Center-align the text horizontally and vertically.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平垂直居中文本。
- en: Set the `43`.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`43`。
- en: Change the font to `Roboto-Bold`. (Note this **Font Asset** will only be available
    if you imported the TMP Examples.)
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体更改为`Roboto-Bold`。（注意，这个**字体资产**只有在您导入了TMP示例后才会可用。）
- en: 'Adjust the Rect Transform so that the text is centered more within the banner.
    Your text should appear as follows:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整Rect Transform，使文本在横幅中居中。您的文本应该如下所示：
- en: '![Figure 10.63: The banner text’s placement](img/B18327_10_63.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图10.63：横幅文本的位置](img/B18327_10_63.jpg)'
- en: 'Figure 10.63: The banner text’s placement'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.63：横幅文本的位置
- en: Now, let’s give the text a gradient fill. Select the checkbox next to **Color
    Gradient** in the **TextMeshPro - Text (****UI)** component.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们给文本添加渐变填充。在**TextMeshPro - 文本（UI）**组件中，选中**颜色渐变**旁边的复选框。
- en: To achieve the desired look, we will leave the top-left and top-right colors
    white. Select the white rectangle at the bottom left to bring up the Color picker.
    Select the eye dropper at the top of the Color picker and then move your mouse
    over the tan area of the `Pause Panel` image. When you close the Color picker
    window, the tan color will be in the bottom-left slot.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了达到预期的效果，我们将保持左上角和右上角的颜色为白色。选择左下角的白色矩形以打开颜色选择器。在颜色选择器的顶部选择吸管，然后将鼠标移到`Pause
    Panel`图像的米色区域。当您关闭颜色选择器窗口时，米色将出现在左下角的槽中。
- en: '![Figure 10.64: Using the eye dropper tool to get the text color](img/B18327_10_64.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图10.64：使用吸管工具获取文本颜色](img/B18327_10_64.jpg)'
- en: 'Figure 10.64: Using the eye dropper tool to get the text color'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.64：使用吸管工具获取文本颜色
- en: Right-click on the color in the bottom-left slot and select **Copy**.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左下角的槽中的颜色上右键点击并选择**复制**。
- en: Right-click on the white square in the bottom-right slot and select **Paste**.
    Now, the two top colors should be white and the two bottom colors should be tan.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右下角的空白方块上右键点击并选择**粘贴**。现在，上面两个颜色应该是白色，下面两个颜色应该是米色。
- en: '![Figure 10.65: The Color Gradient properties completed](img/B18327_10_65.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图10.65：完成颜色渐变属性](img/B18327_10_65.jpg)'
- en: 'Figure 10.65: The Color Gradient properties completed'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.65：完成颜色渐变属性
- en: In the `0.25`.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.25`。
- en: The last thing to do is curve the text. TextMeshPro has made this pretty easy
    for us by providing an example script that curves text at runtime. To view the
    changes, you have to play the game, and they are not represented in the Scene
    view. Select the **Add Component** button and choose **Scripts** | **TMPro.Examples**
    | **Warp** **Text Example**.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是弯曲文本。TextMeshPro通过提供一个在运行时弯曲文本的示例脚本，使我们能够轻松地完成这项工作。要查看更改，您必须播放游戏，它们在场景视图中不会显示。选择**添加组件**按钮，然后选择**脚本**
    | **TMPro.Examples** | **Warp Text Example**。
- en: '![Figure 10.66: The Warp Text Example component](img/B18327_10_66.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![图10.66：Warp Text Example组件](img/B18327_10_66.jpg)'
- en: 'Figure 10.66: The Warp Text Example component'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.66：Warp Text Example组件
- en: Select the wavy green line in the **Vertex Curve** slot to bring up the curve
    editor. Select the option on the far left – that is, the flat line.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**顶点曲线**槽中选择波浪形绿色线以打开曲线编辑器。选择最左侧的选项——即平坦的线条。
- en: '![Figure 10.67: Selecting a flat curve for the Vertex Curve](img/B18327_10_67.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![图10.67：选择顶点曲线的平坦曲线](img/B18327_10_67.jpg)'
- en: 'Figure 10.67: Selecting a flat curve for the Vertex Curve'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.67：选择顶点曲线的平坦曲线
- en: Right-click on the green line at the `0.5` mark and select **Add Key**.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.5`标记处的绿色线上右键单击并选择**添加关键帧**。
- en: Select that new key and drag it upward to a little below `1.3`.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新键并将其向上拖动到`1.3`稍下方。
- en: '![Figure 10.68: The final version of the Vertex Curve](img/B18327_10_68.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图10.68：顶点曲线的最终版本](img/B18327_10_68.jpg)'
- en: 'Figure 10.68: The final version of the Vertex Curve'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.68：顶点曲线的最终版本
- en: Play the game from this scene and press the *P* key to view the `Pause Panel`.
    The text should now appear as it did at the beginning of this example.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此场景开始游戏并按**P**键查看`Pause Panel`。文本现在应该像本例开头那样显示。
- en: To view the entire flow, Start Screen, Intro Scene, and this scene with the
    updated `Pause Panel`, we’ll need to update some old scenes. Open `Chapter10-Examples-IntroScene`
    and change the `Text Canvas`’ `Chapter9-Examples` to `Chapter10-Examples`.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看整个流程，包括起始屏幕、简介场景以及带有更新`Pause Panel`的此场景，我们需要更新一些旧场景。打开`Chapter10-Examples-IntroScene`并将`Text
    Canvas`的`Chapter9-Examples`更改为`Chapter10-Examples`。
- en: Duplicate the scene called `Chapter9-Examples-StartScreen` and name it `Chapter10-Examples-StartScreen`.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制名为`Chapter9-Examples-StartScreen`的场景并将其命名为`Chapter10-Examples-StartScreen`。
- en: Open the new scene and select the `Play Button` child of the `Button Canvas`.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新场景并选择`Button Canvas`下的`Play Button`子项。
- en: Change the `Chapter10-Examples-IntroScene`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Chapter10-Examples-IntroScene`。
- en: 'Open the **Build Settings** and update the **Scenes in Build** to the following:![Figure
    10.69: The Build Settings with all the appropriate scenes](img/B18327_10_69.jpg)'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Build Settings**并更新**构建中的场景**到以下内容：![图10.69：包含所有适当场景的Build Settings](img/B18327_10_69.jpg)
- en: 'Figure 10.69: The Build Settings with all the appropriate scenes'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.69：包含所有适当场景的Build Settings
- en: You can remove unnecessary scenes by right-clicking on them and removing them.
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过右键单击并删除它们来删除不必要的场景。
- en: With the `Chapter10-Examples-StartScreen` scene open, press the play button
    in the Editor and watch the game’s flow complete.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter10-Examples-StartScreen`场景打开的情况下，按编辑器中的播放按钮并观看游戏流程完成。
- en: Note
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’d like to point out that, while I am duplicating and renaming each scene with
    each new chapter, you do not have to do so. I am doing it to maintain an easy-to-view
    progression log of what is happening to our scenes for this book, but admittedly,
    your project is probably getting a bit cluttered if you’ve been doing it, too.
    So, if you are wondering “Why can’t I just keep adding to my scenes instead of
    starting a new one each time?” you can!
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，虽然我在每个新章节中复制并重命名每个场景，但您不必这样做。我这样做是为了保持一个易于查看的进度日志，记录这本书中场景的变化，但诚然，如果您也这样做，您的项目可能已经有点杂乱了。所以，如果您想知道“为什么我不能继续添加到我的场景中，而不是每次都创建一个新的场景？”您当然可以！
- en: And that’s it for creating a wrapped text using TextMeshPro!
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TextMeshPro创建包裹文本就到这里了！
- en: Summary
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! I bet you thought, *how much can you really say about text?* when this
    chapter started and didn’t expect to be faced with the longest chapter so far!
    And I almost made it longer by adding more examples! Alas, as much as I would
    like to provide even more examples, I have a page limit I have to adhere to –
    even though I have already blown past it. If you are hankering for even more examples
    concerning UI Text and Text-TextMeshPro, I strongly recommend you review the various
    examples linked within this chapter, as well as the example scenes that you downloaded
    with the TextMesh – Pro examples.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我敢打赌，当你开始这一章时，你可能会想，“关于文本你能说多少呢？”而且你没想到会面对迄今为止最长的章节！我几乎通过添加更多示例来让它变得更长！然而，尽管我非常愿意提供更多示例，但我必须遵守页面限制——尽管我已经超过了这个限制。如果你渴望更多关于UI文本和Text-TextMeshPro的示例，我强烈建议你回顾这一章中链接的各种示例，以及你与TextMesh
    – Pro示例一起下载的示例场景。
- en: In the next chapter, we’ll do a deep dive into UI Images and Effects.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨UI图像和效果。
