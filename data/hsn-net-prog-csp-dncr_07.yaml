- en: Generating Network Requests in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 中生成网络请求
- en: So, now we've got a deep and complete understanding of the nature of networks.
    We understand the demands that networks place on the design and implementation
    of the software and hardware that is meant to be deployed on those networks. But
    what are we supposed to do with this knowledge? In this chapter, we'll finally
    explore the most common paradigms for leveraging network resources in .NET Core.
    We'll be looking at the common interface for implementing the request/response
    transaction model on the internet (the most ubiquitous network with which you'll
    work), and examine some of the specific implementations of it. Along the way,
    we'll take a look at what happens under the hood by taking apart some of the source
    code for the .NET classes that we'll be using.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们对网络的本质有了深入和完整的理解。我们理解了网络对部署在那些网络上的软件和硬件的设计和实现提出的要求。但我们应该用这些知识做什么呢？在本章中，我们将最终探讨在
    .NET Core 中利用网络资源的最常见范例。我们将查看在互联网上实现请求/响应事务模型的通用接口（您将与之工作的最普遍的网络），并检查其一些具体实现。在这个过程中，我们将通过拆解我们将要使用的
    .NET 类的一些源代码来查看底层的操作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic structure of the `WebRequest` class, and what functionality each of
    its sub-classes is assured to expose through their methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebRequest` 类的基本结构，以及每个子类通过其方法保证暴露的功能'
- en: How to leverage different sub-classes of the `WebRequest` class, based on different
    use cases you may encounter, and understanding the distinct operations that they
    provide
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据您可能遇到的不同用例利用 `WebRequest` 类的不同子类，并理解它们提供的不同操作
- en: The internal phases of request execution as implemented by C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 实现的请求执行的内部阶段
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code for this chapter is available at the GitHub repository for this
    book at [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    5](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%205).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%205](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%205)。
- en: As mentioned before, all of the code in this chapter can be read, manipulated,
    built, and deployed with Visual Studio Code or Visual Studio Community Edition
    (or Visual Studio for macOS, for those of you on a macOS system). The specific
    source control editor you use is typically a matter of opinion, but I assure you
    that whatever you use to work with the code in this chapter will be sufficient
    for all of the code throughout the rest of this book. I'd encourage you to stick
    with that decision and take some time to familiarize yourself with it. I expect
    most of the readers of this book will already have some deeply entrenched opinions
    about the best environment for .NET Core development. If you don't, however, I
    encourage you to pick whichever one feels most comfortable for you (either the
    feature-richness of Visual Studio Community Edition, or the lightweight, multiplatform
    friendliness of Visual Studio Code). Once you do, make sure you take a significant
    amount of time to familiarize yourself with the tools of that environment. Learn
    the keyboard shortcuts and set your auto-formatting options. Make it yours; once
    you do, you'll be ready to begin.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本章中的所有代码都可以使用 Visual Studio Code 或 Visual Studio Community Edition（或者对于
    macOS 系统上的用户，是 Visual Studio for macOS）进行阅读、操作、构建和部署。您使用的具体源代码控制编辑器通常是个人观点的问题，但我向您保证，您用于处理本章代码的任何工具都足以满足本书其余部分的所有代码。我鼓励您坚持这个决定，并花些时间熟悉它。我预计本书的大多数读者对
    .NET Core 开发的最佳环境已经有了根深蒂固的看法。如果您还没有，我鼓励您选择您感觉最舒适的一个（无论是功能丰富的 Visual Studio Community
    Edition，还是轻量级、多平台友好的 Visual Studio Code）。一旦您做出了选择，请确保您花大量时间熟悉该环境中的工具。学习键盘快捷键并设置您的自动格式化选项。让它成为您的专属；一旦您做到了，您就可以开始学习了。
- en: One class to rule them all – the WebRequest abstract class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切尽在一类——`WebRequest` 抽象类
- en: As any software craftsman will tell you, if you want to understand how to leverage
    a library or toolset provided to you by another developer, just look at the public
    interface. If the interface is designed well enough, it will be obvious as to
    how that tool shouldbe used. A good interface design communicates a lot about
    the limits and original intentions for the use of a piece of library software,
    and that's what we'll be looking at in this section. The `WebRequest` abstract
    class of the `System.Net` namespace is the public interface for creating and working
    with general-purpose network requests that are meant to be sent over the internet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件工匠都会告诉你，如果你想了解如何利用其他开发者提供的库或工具集，只需查看公共接口。如果接口设计得足够好，那么如何使用该工具就会一目了然。良好的接口设计能够传达大量关于某块库软件使用限制和原始意图的信息，这正是本节将要探讨的内容。`System.Net`命名空间中的`WebRequest`抽象类是创建和操作旨在通过互联网发送的通用网络请求的公共接口。
- en: The interface or abstract class
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口或抽象类
- en: I've been describing the abstract `WebRequest` base class as providing an interfacefor
    how Microsoft intends developers to interact with network operations. However,
    I must admit that this isn't entirely accurate; `WebRequest` is, technically,
    an abstractclass. For those readers who are unfamiliar with the distinction, it's
    actually quite trivial for our purposes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在描述抽象的`WebRequest`基类，它提供了如何让微软希望开发者与网络操作交互的接口。然而，我必须承认这并不完全准确；从技术上讲，`WebRequest`是一个抽象类。对于那些对这种区别不熟悉的读者，对我们来说这实际上是非常微不足道的。
- en: Abstract classes do, in fact, define an interfacefor working with their implementations.
    The relevant distinction between the two is that, with an abstract class, any
    given method provided as part of the interface will typically have a default implementation
    defined within the abstract base class itself. So, the methods provided by an
    abstract class still define the interface through which you, as a consumer of
    the concrete classes, will interact with the implementations of the class. It's
    really just a distinction of where the obligation falls to define the expected
    behavior for that interface. Since you can't instantiate an abstract class any
    more than you can instantiate an interface definition, the difference is entirely
    trivial. Unless, of course, you choose to inherit from the `WebRequest` class
    yourself (which we will do at the end of this chapter). For now, though, let's
    just review the specification provided by `WebRequest`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类实际上确实定义了一个与其实现一起工作的接口。两者之间的相关区别在于，使用抽象类时，接口中提供的任何给定方法通常在抽象基类本身中定义了一个默认实现。因此，抽象类提供的方法仍然通过接口定义了作为具体类消费者的你将如何与类的实现交互。这实际上只是定义该接口预期行为义务所在的一个区别。既然你不能像实例化接口定义一样实例化抽象类，所以这种区别完全是微不足道的。除非，当然，你选择从`WebRequest`类继承（我们将在本章末尾这样做）。不过，现在，让我们先回顾一下`WebRequest`提供的规范。
- en: The interface
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: With any type of abstract class or interface definition, their proper use can
    best be understood through two distinct lenses. The shapeof the abstraction is
    made clear by the properties of the interface. This gives users a concrete idea
    of the proper context in which instances of the interface should be used. It should
    clearly convey the domain around which the abstraction should operate. Meanwhile,
    the scope of the abstraction is conveyed by the classes' method signatures. This
    is what tells users howthe class operates over the domain, as defined by its shape
    or properties.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型的抽象类或接口定义，它们恰当的使用方式可以通过两个不同的视角来理解。抽象的形状通过接口的属性变得清晰。这使用户对接口实例应该使用的适当上下文有一个具体的概念。它应该清楚地传达抽象应该操作的领域。同时，抽象的范围通过类的`方法签名`传达。这是告诉用户类如何在其形状或属性定义的领域内操作的。
- en: An interface of well-named methods should give clear boundaries to the limits
    of the usefulness of the class. If an interface is well defined, as with the `WebRequest` base
    class, its properties and method signatures should make it clear exactly when
    it should, and should not be used. What's more, if it should be used, well-named
    and well-scoped method signatures will tell users exactly how to use the method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命名良好的接口应该为类的有用性界限提供清晰的界限。如果一个接口定义良好，就像`WebRequest`基类一样，它的属性和方法签名应该清楚地表明何时应该使用，以及何时不应该使用。更重要的是，如果应该使用，命名良好且范围明确的函数签名将告诉用户如何使用该方法。
- en: So, with that perspective in mind, let's take a look at what is in the base
    definition of the `WebRequest` class. This specification will tell us how it is
    meant to be used and how to extend or implement it for ourselves. And what better
    place to start than with the constructors?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带着这个观点，让我们来看看`WebRequest`类的基定义中有什么。这个规范将告诉我们它应该如何使用，以及我们如何为自己扩展或实现它。那么，从构造函数开始不是更好吗？
- en: The constructors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: '`WebRequest` defines only two base constructors for its sub-classes. The first
    is the default  parameter-less constructor. The second allows developers to specify
    an instance of the `SerializationInfo` and `StreamingContext` classes to more
    narrowly define the scope of valid use cases for the newly-created instance of
    the class. So, our constructor signatures will look like the following code block:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebRequest`只为它的子类定义了两个基构造函数。第一个是默认的无参数构造函数。第二个允许开发者指定`SerializationInfo`和`StreamingContext`类的实例，以便更精确地定义新创建的类实例的有效用例范围。因此，我们的构造函数签名将类似于以下代码块：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far this is pretty straightforward, but why use the second constructor at
    all? What is so common about using `SerializationInfo` and `StreamingContext` in
    `WebRequest` instances that the base class defines a constructor which accepts
    instances of those classes?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当直接，但为什么要使用第二个构造函数呢？在`WebRequest`实例中使用`SerializationInfo`和`StreamingContext`有什么如此普遍的地方，以至于基类定义了一个接受这些类实例的构造函数？
- en: We'll look more closely at streaming contexts in later chapters, but we did
    briefly discuss the need for reliably serialized data in the previous chapter,
    and this is a good place to consider the concept more fully. Every request or
    response payload will need to be serializedprior to transport, and deserializedupon
    arrival at the destination machine. As we discussed before, this is the process
    of taking unordered, locally-addressed chunks of data and converting it into ordered
    strings of zeros and ones. Specifically, it must be ordered in such a way that
    the same strings can be traversed in order and used to compose locally-addressed
    in-memory objects by the recipient machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地研究流上下文，但在上一章中我们简要讨论了可靠序列化数据的需求，这是一个更全面考虑该概念的好地方。每个请求或响应的有效负载在传输之前都需要进行序列化，在到达目标机器后进行反序列化。正如我们之前讨论的，这是一个将无序、本地寻址的数据块转换为有序的零和一字符串的过程。具体来说，它必须以这种方式排序，以便相同的字符串可以按顺序遍历，并由接收机器用来组合本地寻址的内存对象。
- en: 'So, while our software might store an ordered list of integers as an array
    of contiguous memory addresses, this is an implementation detail that is fundamentally
    independent of the data structure it represents. The only key details are that
    the list is ordered, and that it is a list of integers. It could just as easily
    be represented as a linked list under the hood, with each node in the list containing
    the integer stored at that node, as well as the address of the next node in the
    list, which may or may not be contiguous. In memory, these two data structures
    are significantly different:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们的软件可能将有序整数列表存储为一个连续内存地址的数组，但这是一种与表示的数据结构基本无关的实现细节。唯一的关键细节是列表是有序的，并且它是一个整数列表。它同样可以表示为一个底层的链表，其中列表中的每个节点包含存储在该节点的整数，以及列表中下一个节点的地址，这些地址可能连续也可能不连续。在内存中，这两个数据结构有显著的不同：
- en: '![](img/1c8afb08-4fb0-4f04-af71-38a5fc678881.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c8afb08-4fb0-4f04-af71-38a5fc678881.png)'
- en: 'However, as long as the proper serialization information is given for how those
    two lists should be represented, they should look the same to any recipient receiving
    those lists as the payload to a request or response over the network. They should
    be nothing more than a well-delimited list of the integers. If your serialization
    mechanism is in the typical **Javascript Object-Notation** (**JSON**) format,
    both of those implementations would serialize the same output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要为如何表示这两个列表提供了适当的序列化信息，它们对于接收这些列表作为请求或响应负载的任何接收者来说应该看起来是相同的。它们应该只是整数的一个良好分隔的列表。如果你的序列化机制是典型的**JavaScript对象表示法**（**JSON**）格式，这两个实现都会序列化相同的输出：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Often, you'll find that `WebRequest` and `WebResponse` instances are instantiated
    and leveraged over and over again for the same kinds of messages, and their payloads
    should be serialized in the same way each and every time. Being able to provide
    `SerializationInfo` as a constructor input gives you the flexibility to define
    your serialization rules and details once, and then leverage them for a theoretically
    infinite number of requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现`WebRequest`和`WebResponse`实例经常被用于相同类型的消息，并且它们的负载应该以相同的方式进行序列化。能够将`SerializationInfo`作为构造函数的输入参数，这给了你一次定义你的序列化规则和细节，然后可以在理论上无限数量的请求中利用它们的灵活性。
- en: The same goes for the `StreamingContext` parameter. As most network software
    is written to facilitate the same sorts of operations that are being executed
    in the same way over the lifespan of the software, it's unlikely that in a given
    application, your requests will need to leverage different kinds of I/O streams.
    Later on, we'll look more closely at the different kinds of streams available
    to you. It's a dense topic; however, for now, just know that this input parameter
    gives you the same flexibility as the `SerializationInfo` parameter. It allows
    you to define your streaming context once, and use it over and over again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`StreamingContext`参数也是如此。由于大多数网络软件都是编写来促进在软件的生命周期中以相同方式执行的操作，因此在一个特定的应用程序中，你的请求不太可能需要利用不同类型的I/O流。稍后，我们将更详细地查看可用的不同类型的流。这是一个密集的主题；然而，现在，只需知道这个输入参数给你与`SerializationInfo`参数相同的灵活性。它允许你一次定义你的流上下文，然后重复使用它。
- en: And with only those two signatures, we've covered the only constructors explicitly
    defined by the `WebRequest` base class. This should give you a pretty clear idea
    of how the writers of this library anticipated it would likely be used. Of course,
    if you wanted to, you could write a sub-class that accepted HTTP verbs and default
    header values, and all sorts of other aspects of a given request that you will
    likely need to define before you can send the request. But at its most basic,
    these constructor signatures tell you that this is a class that is meant to provide
    **reliable serialization** of data over a **reliable data stream**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过这两个签名，我们就涵盖了`WebRequest`基类中明确定义的所有构造函数。这应该给你一个相当清晰的想法，即这个库的编写者预计它可能会如何被使用。当然，如果你想的话，你可以编写一个子类，它接受HTTP动词和默认的头部值，以及你发送请求之前可能需要定义的给定请求的所有其他方面。但就其最基本的形式而言，这些构造函数签名告诉你，这是一个旨在提供**可靠序列化**的**可靠数据流**的类的实例。
- en: Class properties
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: So, your constructors give you a clear idea of the context in which the classes
    are expected to be used, and your properties define the overall shape of a request.
    They define the clearest and most unambiguous description of what the class actuallyis.
    What can we learn about `WebRequest`, based on its properties? Well, let's take
    a closer look.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的构造函数清楚地说明了类预期在什么上下文中使用，而你的属性定义了请求的整体形状。它们定义了类实际是什么的最清晰和最无歧义性的描述。我们可以从`WebRequest`的属性中学到什么？好吧，让我们更仔细地看看。
- en: 'According to the base class specification, the public properties of the class
    are in alphabetical order ( as they''re listed in the Microsoft documentation,
    here: [https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0)),
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基类规范，类的公共属性按字母顺序排列（正如它们在Microsoft文档中列出，这里：[https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0)），如下所示：
- en: '`AuthenticationLevel`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationLevel`'
- en: '`CachePolicy`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CachePolicy`'
- en: '`ConnectionGroupName`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionGroupName`'
- en: '`ContentLength`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentLength`'
- en: '`ContentType`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentType`'
- en: '`Credentials`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Credentials`'
- en: '`DefaultCachePolicy`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultCachePolicy`'
- en: '`DefaultWebProxy`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultWebProxy`'
- en: '`Headers`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Headers`'
- en: '`ImpersonationLevel`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImpersonationLevel`'
- en: '`Method`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Method`'
- en: '`PreAuthenticate`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreAuthenticate`'
- en: '`Proxy`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proxy`'
- en: '`RequestUri`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestUri`'
- en: '`Timeout`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timeout`'
- en: '`UseDefaultCredentials`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseDefaultCredentials`'
- en: So, what does this tell us about instances derived from this abstract class?
    Well, the obvious information is that it encapsulates common aspects of requests
    made over any protocol leveraged on the internet. `Headers`, `Method` (that is,
    the specific protocol method, such as a `GET`, `POST`, or `PUT` HTTP method),
    and `RequestUri` are all that you would expect from a utility class. Others, though,
    such as `ImpersonationLevel`, `AuthenticationLevel`, and `CachePolicy` indicate
    that more than simply encapsulating a request payload, the `WebRequest` class
    is truly meant to encapsulate an operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这告诉我们从该抽象类派生的实例有什么信息呢？显然的信息是，它封装了在互联网上使用的任何协议中进行的请求的常见方面。`Headers`、`Method`（即特定的协议方法，如`GET`、`POST`或`PUT`
    HTTP方法）和`RequestUri`都是您从实用程序类中期望得到的。然而，其他如`ImpersonationLevel`、`AuthenticationLevel`和`CachePolicy`等属性表明，`WebRequest`类不仅仅是封装请求负载，而是真正旨在封装一个操作。
- en: The actions of authenticating and caching responses fall outside of the responsibility
    of the simple-request payload and fall more into the segment of your software
    responsible for brokering requests and responses between your application and
    external resources. The presence of these methods indicates to us that this class
    (and its sub-classes) is intended to be the broker of requests and responses network
    resources. Its definition makes clear that it can handle the nitty-gritty details
    of connecting to remote hosts, authenticating itself, and, by extension, your
    application, serializing payloads, deserializing responses, and providing all
    of this through a clean and simple interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和缓存响应的操作超出了简单请求负载的责任范围，更多地属于负责在您的应用程序和外部资源之间进行请求和响应代理的软件部分。这些方法的存在表明，此类（及其子类）旨在成为请求和响应网络资源的代理。其定义清楚地表明，它可以处理连接到远程主机、验证自身以及通过扩展，您的应用程序的细微细节，序列化负载，反序列化响应，并通过干净简单的接口提供所有这些。
- en: With the `ContentType` and `ContentLength` properties, it provides a clean way
    to access and set the values for the most commonly required headers for any request
    with a payload. The specification is telling you to just give me that package,
    tell me where you want to send it, and let me handle the rest*.* It even gives
    you an interface for lumping similar operations together in a connection group
    through the `ConnectionGroupName` property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ContentType`和`ContentLength`属性，它提供了一种干净的方式来访问和设置任何带有负载的请求最常用的头值。规范告诉您：“就给我这个包，告诉我你想把它发送到哪里，剩下的交给我处理。”它甚至提供了一个接口，通过`ConnectionGroupName`属性将类似的操作组合在一起，在连接组中进行批量处理。
- en: Imagine that you have multiple requests to the same external RESTful API living
    at `https://financial-details.com/market/api`, and there are a dozen different
    endpoints that your application accesses over the course of its runtime. Meanwhile,
    you also have a handful of requests that need to be routed to `https://real-estate-details.com/market/api`.
    You can simply associate all of the requests made to the financial details API
    under one connection group name, and the real estate details API requests under
    another. Doing so allows .NET to more reliably manage connections to a single
    `ServicePoint` instance. This allows multiple requests to a single endpoint to
    be routed over the same active connection, improving performance and reducing
    the risk of what's known as connection pool starvation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有多个请求同一个外部RESTful API，该API位于`https://financial-details.com/market/api`，并且您的应用程序在其运行期间访问了十几个不同的端点。同时，您还有少量请求需要路由到`https://real-estate-details.com/market/api`。您可以简单地关联所有针对财务详情API的请求到一个连接组名称下，并将房地产详情API请求关联到另一个。这样做允许.NET更可靠地管理对单个`ServicePoint`实例的连接。这允许将多个请求路由到单个端点，通过相同的活跃连接，提高性能并降低所谓的连接池饥饿的风险。
- en: Whenever possible, make sure you're using `ConnectionGroupName` to associate
    requests to a single endpoint through a single connection. There is a finite number
    of active connections that you can hold at a given time in any .NET Core application,
    and without `ConnectionGroupName` tying requests to a single connection, each
    request will be given its own connection from the .NET Core runtime's pool of
    available connections. In applications with high network traffic or frequent external
    requests, this can lead to thread-starvation and unreliable performance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，确保你使用 `ConnectionGroupName` 来将请求关联到单个端点，并通过单个连接进行。在任何 .NET Core 应用程序中，你可以在给定时间内保持有限数量的活动连接，如果没有
    `ConnectionGroupName` 将请求绑定到单个连接，每个请求都将从 .NET Core 运行时的可用连接池中分配其自己的连接。在具有高网络流量或频繁外部请求的应用程序中，这可能导致线程饥饿和不稳定的性能。
- en: 'Implementing this feature is quite trivial, but it can save you a mountain
    of time in performance tuning and chasing bugs. Simply define a static constant
    name for each connection group that you want to leverage, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能相当简单，但它可以在性能调整和调试错误时为你节省大量时间。只需为每个你想要利用的连接组定义一个静态常量名称，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, whenever you need to instantiate a new request for the target endpoint,
    you can simply specify the connection group name through the assignment, and under
    the hood, the `ServicePoint` instance that is associated with the `WebRequest` instance
    will check for any connections that share the group name, and, if one is discovered,
    leverage the connection for your new request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次你需要为目标端点实例化一个新的请求时，你只需通过赋值指定连接组名称，然后底层 `ServicePoint` 实例将检查任何共享组名称的连接，如果发现了一个，就会为你的新请求利用该连接：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And just like that, your request will take advantage of any established connections
    to that same external resource. If there are no other requests associated with
    the specified `ConnectionGroupName` property, then .NET Core will create a connection
    in its connection pool, and associate your request as the first in the connection
    group. This is especially useful if a set of requests are targeting a resource
    that requires access credentials, as the connection is established with those
    access credentials once, and then shared with the subsequent requests!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你的请求将利用到与相同外部资源建立的任何连接。如果没有其他请求与指定的 `ConnectionGroupName` 属性相关联，那么 .NET
    Core 将在其连接池中创建一个连接，并将你的请求作为连接组中的第一个关联。这对于一组请求针对需要访问凭证的资源特别有用，因为连接一旦建立，就会与后续请求共享，这些请求使用相同的访问凭证！
- en: 'Once the connection is established, we''ll need to know what to do with the
    responses for that request. For that, we have the `CachePolicy` property. This
    specifies how your requests should handle the availability of a cached response
    from your remote resource. This property gives us granular control over exactly
    how and when we should rely on a cached response, if at all. So, for example,
    if we have a dataset that is updated almost constantly, and we always want the
    most up-to-date response, we could avoid the cache entirely, by setting the policy
    accordingly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了连接，我们就需要知道如何处理该请求的响应。为此，我们有 `CachePolicy` 属性。该属性指定了你的请求应该如何处理远程资源缓存的响应的可用性。该属性为我们提供了对何时以及如何依赖缓存响应的精确控制，如果确实需要的话。例如，如果我们有一个几乎不断更新的数据集，并且我们始终希望获得最新的响应，我们可以通过相应地设置策略来完全避免缓存：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And just like that, the request will ignore any available cached responses,
    and likewise, it won't cache whatever response it receives from the external resource
    itself. As you can see, the property expects an instance of a `RequestCachePolicy`
    object, which is typically initialized with a value from the `RequestCacheLevel`
    enum definition found in the `System.Net.Cache` namespace (as indicated by its
    inclusion at the top of the code block).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，请求将忽略任何可用的缓存响应，同样，它也不会缓存从外部资源接收到的任何响应。正如你所看到的，该属性期望一个 `RequestCachePolicy`
    对象的实例，通常使用 `System.Net.Cache` 命名空间中找到的 `RequestCacheLevel` 枚举定义的值进行初始化（如代码块顶部的包含所示）。
- en: This is another instance where familiarizing yourself with the IntelliSense
    tools of Visual Studio can give you a clear idea of what values are available
    in that enum. Of course, if you're using something such as Visual Studio Code
    or another source code editor, you can always look up the source code or the documentation
    for it on the manufacture's website. No matter which editor you use, in the case
    of properties or methods whose use is not easy to infer, make a habit of looking
    up implementation details and notes on Microsoft's documentation. But with something
    as obvious and straightforward as an enum defining cache policies, Visual Studio's
    autocomplete and IntelliSense functionality can save you the time and mental energy
    of context-switching away from your IDE to look up valid values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个熟悉 Visual Studio 的 IntelliSense 工具可以给你一个清晰想法的例子，了解那个枚举中可用的值。当然，如果你使用的是
    Visual Studio Code 或其他源代码编辑器，你总是可以在制造商的网站上查找它的源代码或文档。无论你使用哪个编辑器，对于使用起来不易推断的属性或方法，养成查阅实现细节和
    Microsoft 文档上的注释的习惯。但是，对于像定义缓存策略的枚举这样明显直接的东西，Visual Studio 的自动完成和 IntelliSense
    功能可以节省你从 IDE 转移注意力去查找有效值的时间和精力。
- en: In the same way that you define the behavior around cached or cache-able responses,
    you can use the public properties of the `WebRequest` instance to define and specify
    the expected behavior for authentication of your application and any expectations
    you have of the remote resource to authenticate. This is exposed through the `AuthenticationLevel`
    property and behaves much the same way as the `CachePolicy` property that we just
    looked at.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你定义围绕缓存或可缓存的响应的行为一样，你可以使用 `WebRequest` 实例的公共属性来定义和指定应用程序的认证行为以及你对远程资源认证的期望。这是通过
    `AuthenticationLevel` 属性暴露的，其行为与我们刚刚查看的 `CachePolicy` 属性非常相似。
- en: Suppose, for instance, that your software depends on a remote resource that
    is explicitly configured to work with only your software. The remote server would
    need to authenticate requests to ensure that they are generated from valid instances
    of your software. Likewise, you will want to make sure that you are communicating
    directly with the properly configured server, and not some man-in-the-middle agent
    looking to swipe your valuable financial and real-estate details. In that case,
    you would likely want to ensure that every request is mutually authenticated*, *and
    I'm sure you can already see where I'm about to go with this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你的软件依赖于一个明确配置为仅与你的软件一起工作的远程资源。远程服务器需要认证请求以确保它们是由你的软件的有效实例生成的。同样，你也会想确保你是在直接与正确配置的服务器通信，而不是某个中间人代理试图窃取你的宝贵财务和房地产细节。在这种情况下，你可能会想确保每个请求都是**双向认证**的，我相信你已经能预见我接下来要说什么了。
- en: 'Since the `WebRequest` class is designed to encapsulate the entire operation
    of interacting with remote resources, we should expect that we can configure our
    instance of that class with the appropriate authentication policies, and not have
    to manage it ourselves. And that''s exactly what we can do. Building on our earlier
    example, we can define the `AuthenticationLevel` property to enforce the policy
    we want to use once, and then let the `WebRequest` instance take it from there:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `WebRequest` 类旨在封装与远程资源交互的整个操作，我们应该期望能够使用适当的认证策略来配置该类的实例，而不必自己管理它。这正是我们可以做到的。基于我们之前的例子，我们可以定义
    `AuthenticationLevel` 属性来强制执行我们想要使用的策略，然后让 `WebRequest` 实例接管：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the inclusion of the `System.Net.Security` namespace in our `using` directives.
    This is where the `AuthenticationLevel` enum is defined. This makes sense, as
    authentication is one-half of the authentication and authorization security components
    of most network software. But we'll get more into that later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们在 `using` 指令中包含了 `System.Net.Security` 命名空间。这就是 `AuthenticationLevel` 枚举被定义的地方。这很有道理，因为认证是大多数网络软件认证和授权安全组件的一半。但我们会稍后再深入探讨这一点。
- en: As you can guess, getting your own software authenticated will likely require
    some credentials.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，获取你自己的软件认证可能需要一些凭证。
- en: 'Assigning credentials is as easy to do as defining your authentication or caching
    policies. In the `WebRequest` class definition, the `Credentials` property is
    an instance of the `ICredentials` interface from the `System.Net` namespace, typically
    implemented as an instance of the `NetworkCredential` class. Again, the full scope
    of implementing reliable security for network requests will be covered later in
    this book, but for now, let''s take look at how we might add some credentials
    to our mutually- authenticated web requests. It uses the `System.Net` namespace,
    so no additional `using` statements are required. Instead, we can simply set the
    property to a new instance of `NetworkCredential` and move on, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分配凭据就像定义你的身份验证或缓存策略一样简单。在 `WebRequest` 类定义中，`Credentials` 属性是 `System.Net` 命名空间中的
    `ICredentials` 接口的一个实例，通常实现为 `NetworkCredential` 类的一个实例。同样，实现网络请求可靠安全性的完整范围将在本书的后面部分进行讨论，但就目前而言，让我们看看我们如何向我们的相互认证的
    Web 请求添加一些凭据。它使用 `System.Net` 命名空间，因此不需要额外的 `using` 语句。相反，我们可以简单地将属性设置为 `NetworkCredential`
    的新实例，然后继续，如下所示：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We should actually be storing the password as `SecureString`, but this constructor
    is valid, and as I said, we'll look closer at security in later chapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们应该将密码存储为 `SecureString`，但这个构造函数是有效的，正如我所说的，我们将在后面的章节中更详细地探讨安全性。
- en: With this short, straightforward example, we can clearly see how the class properties
    of `WebRequest` define the expected use case for instances of the concrete sub-classes
    that implement and extend it. Now that we understand the shape and scope of the
    operations `WebRequest` intends to abstract away for us, let's take a look at
    the actual execution of those operations through the public methods exposed by
    the class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '通过这个简短、直接的示例，我们可以清楚地看到 `WebRequest` 类的属性如何定义了实现和扩展它的具体子类的预期使用场景。现在我们了解了 `WebRequest`
    想要为我们抽象的操作的形状和范围，让我们看看通过类公开的方法来实际执行这些操作。 '
- en: The class methods
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: 'Now that we have a sufficiently complete picture of the shape of the `WebRequest`
    class, let''s explore its scope, or proper use. Let''s take a look at its public
    methods. Understanding what''s available through the base class will give you
    everything you need to leverage any concrete implementation in the vast majority
    of your use cases, with perhaps only minor modifications. So, just as we did with
    the class properties, let''s take look at the following list of public methods
    and see what we can infer about how the class is meant to be used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `WebRequest` 类的形状有了足够完整的了解，让我们来探索它的范围或适当的使用。让我们看看它的公共方法。了解基类中可用的功能将为你提供在大多数使用场景中利用任何具体实现所需的一切，可能只需要进行一些小的修改。因此，就像我们查看类属性一样，让我们看看以下公共方法列表，并看看我们可以推断出关于如何使用该类的哪些信息：
- en: '`Abort()`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abort()`'
- en: '`BeginGetRequestStream(AsyncCallback, Object)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginGetRequestStream(AsyncCallback, Object)`'
- en: '`BeginGetResponse(AsyncCallback, Object)`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginGetResponse(AsyncCallback, Object)`'
- en: '`Create(string)`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create(string)`'
- en: '`Create(Uri)`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create(Uri)`'
- en: '`CreateDefault(Uri)`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateDefault(Uri)`'
- en: '`CreateHttp(string)`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateHttp(string)`'
- en: '`EndGetRequestStream(IAsyncResult)`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndGetRequestStream(IAsyncResult)`'
- en: '`EndGetResponse(IAsyncResult)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndGetResponse(IAsyncResult)`'
- en: '`GetObjectData(SerializationInfo, StreamingContext)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetObjectData(SerializationInfo, StreamingContext)`'
- en: '`GetRequestStream()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRequestStream()`'
- en: '`GetRequestStreamAsync()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRequestStreamAsync()`'
- en: '`GetResponse()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetResponse()`'
- en: '`GetResponseAsync()`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetResponseAsync()`'
- en: '`GetSystemWebProxy()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetSystemWebProxy()`'
- en: '`RegisterPrefix(string, IWebRequestCreate)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterPrefix(string, IWebRequestCreate)`'
- en: I only included the methods specific to the `WebRequest` class, and left out
    the public methods inherited from parent classes, such as `MarshalByRefObject`
    and `Object`, since those aren't relevant to our purpose. However, with this basic
    list of operations, the utility of the class should be pretty obvious.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我只包括了针对 `WebRequest` 类的特定方法，并省略了从父类继承的公共方法，例如 `MarshalByRefObject` 和 `Object`，因为那些与我们目的无关。然而，有了这个基本的操作列表，该类的实用性应该相当明显。
- en: The first thing that likely stands out is that the class should be used asynchronously.
    All of the `Begin` and `End` methods, as well as the `Async` suffix on a number
    of other methods, tell you that the class supports fine-grained control of the
    lifetime of your requests through the asynchronous features of .NET Core. Now,
    if you've never done async programming (as I often find to be the case with newer
    programmers just starting out of school, or programmers new to web development)
    we'll be covering that mental leap in much greater detail in the next chapter.
    It's not always intuitively obvious how best to leverage the features of async,
    or what's going on behind the scenes; so, for now, just think of it as deferring
    the actual execution of the method until later. Just like all those methods suggest,
    you `Begin` doing a task, and whenever you're ready to, you `End` it and look
    at your result.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最可能引起注意的第一件事是，这个类应该异步使用。所有的 `Begin` 和 `End` 方法，以及许多其他方法上的 `Async` 后缀，都告诉你这个类通过
    .NET Core 的异步特性支持对请求生命周期的精细控制。现在，如果你从未做过异步编程（正如我经常发现的那样，对于刚刚从学校毕业的新程序员，或者对网络开发新手来说），我们将在下一章中更详细地介绍这个心理飞跃。如何最好地利用异步功能，或者幕后发生了什么，并不总是直观明了；所以，现在就把它想成是推迟方法的实际执行直到以后。就像所有那些方法所暗示的那样，你
    `Begin` 执行一个任务，然后当你准备好时，你 `End` 它并查看你的结果。
- en: The methods in this class can be broken up into two conceptual groups. There
    are methods for state management and methods for request execution. The state
    management methods allow you to modify or further define the state of your instance
    of the `WebRequest` utility class. Leveraging them to further configure and define
    the behavior of your instance is similar to setting any of the public properties
    on the class as we did in the last section on *Class properties*. The reason there
    are methods to do this, instead of simply having more settable properties, is
    because doing so involves at least some non-trivial logic or circumstance-specific
    details that are applied with each invocation of the methods. Meanwhile, the request
    execution functions allow you to define, invoke, and resolve web requests using
    the behavior of your instance. They're the workhorse methods that make all of
    the earlier configuration worthwhile. So, let's take a look at each of these sets
    of methods in turn and fully crystalize our understanding of this class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的方法可以分为两个概念组。有用于状态管理的方法和用于请求执行的方法。状态管理方法允许你修改或进一步定义 `WebRequest` 实用类实例的状态。利用它们进一步配置和定义实例的行为，类似于我们在上一节“类属性”中设置的任何公共属性。之所以有执行此操作的方法，而不是简单地有更多可设置的属性，是因为这样做至少涉及一些非平凡的逻辑或特定情况下的细节，这些细节在每个方法调用时都会应用。同时，请求执行函数允许你使用实例的行为来定义、调用和解决网络请求。它们是那些使所有早期配置变得有价值的“工作马”。因此，让我们依次查看这些方法集，并完全明确我们对这个类的理解。
- en: State management methods
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理方法
- en: I'd encourage you to try to sort the methods I've listed into the two categories
    I'm about to describe for you. And in the future, I'd encourage you to try to
    categorize interfaces and public class definitions in this way. Doing so will
    improve your ability to read and internalize new software features quickly, and
    leverage them efficiently, instead of copying code snippets from [StackOverflow.com](https://stackoverflow.com/) until
    you find something that works. That said, let's take a look at the state management
    functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试将我列出的方法分类到我将要为你描述的两个类别中。将来，我也鼓励你尝试以这种方式对接口和公共类定义进行分类。这样做将提高你快速阅读和吸收新软件功能的能力，并有效地利用它们，而不是从
    [StackOverflow.com](https://stackoverflow.com/) 复制代码片段，直到你找到可以工作的事情。话虽如此，让我们来看看状态管理函数。
- en: 'First, we have the `Create` methods. Each of these methods will return a usable
    instance of a concrete `WebRequest` sub-class. They''re all static, and so can
    be invoked from the class definition without first needing to create an instance
    of it (for obvious reasons; why would you need to create an instance of a class
    to then create an instance of a class?). Depending on the specific method used,
    this sets up an instance of the default sub-class for the given scheme specified
    in the URI supplied to the method. So, if we wanted instances of `WebRequest`
    for accessing data from a RESTful HTTP service, collecting files from a designated
    FTP server, and reading data from a remote file system, we could do all of this
    with a simple call to `Create(uriString)`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `Create` 方法。这些方法中的每一个都将返回一个可用的具体 `WebRequest` 子类实例。它们都是静态的，因此可以在不首先创建其实例的情况下从类定义中调用它们（显然的原因；为什么您需要创建一个类的实例然后创建另一个类的实例呢？）。根据使用的方法，这将为方法提供的
    URI 中指定的给定方案设置默认子类的实例。因此，如果我们想要访问 RESTful HTTP 服务中的数据、从指定的 FTP 服务器收集文件以及从远程文件系统中读取数据，我们可以通过简单调用
    `Create(uriString)` 来完成所有这些操作：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may recognize this code from the `SubmitRealEstateRequest` sample method
    we wrote in the *Class properties* section. I didn't explain it until now, but
    because the class is so clearly and simply defined, I expect you were able to
    infer its use just fine from my code without this explanation. But in case you
    were wondering why it seemed like I was creating an instance of an abstract class
    (a compile-time error in C#), that's why. I was actually requesting an instance
    of an appropriate sub-class from the abstract base-classes, static definition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经从我们在 *类属性* 部分编写的 `SubmitRealEstateRequest` 示例方法中认出了这段代码。我之前没有解释它，但因为这个类定义得如此清晰简单，我预计您能够从我的代码中很好地推断出它的用途，而无需这种解释。但以防您想知道为什么它看起来像是在创建一个抽象类的实例（C#
    中的编译时错误），那就是原因。我实际上是从抽象基类中请求适当的子类实例，这是一个静态定义。
- en: Those three use cases in the preceding code block cover just about everything
    you can do with `Create()` out of the box, but that certainly doesn't mean those
    are the only use cases `Create()` can apply to. The functionality uses common
    protocol prefixes for URIs to determine default sub-classes to instantiate. So,
    simply passing [http://test-domain.com](http://test-domain.com) to the method
    is all the default implementation needs to then return an instance of the `HttpWebRequest`
    class. The same logic that allows the `Uri` class to parse the preceding string
    is used to tell `WebRequest` which protocol it should be creating a sub-class
    for.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块中的三个用例涵盖了您可以使用 `Create()` 方法直接完成的大部分操作，但这当然并不意味着 `Create()` 只能应用于这些用例。该功能使用
    URI 的通用协议前缀来确定要实例化的默认子类。因此，只需将 [http://test-domain.com](http://test-domain.com)
    传递给该方法，默认实现就足以返回 `HttpWebRequest` 类的实例。用于解析前面字符串的相同逻辑也用于告诉 `WebRequest` 应为哪个协议创建子类。
- en: 'As I said, though, the default behavior is only defined for a limited set of
    use cases out of the box. There are four specific protocols whose concrete sub-classes
    are preregistered with the `WebRequest` class at runtime; they are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，但是，默认行为仅针对有限的一组用例进行了定义。有四个特定的协议，它们的具体子类在运行时已预先注册到 `WebRequest` 类中；它们如下所示：
- en: '`http://`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://`'
- en: '`https://`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://`'
- en: '`ftp://`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftp://`'
- en: '`file://`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file://`'
- en: So, any URI string given to the `Create` method with any of these four prefixes
    as the first characters in the string will be reliably handled by the `WebRequest` base
    class. And since the base class provides a sufficient interface for executing
    the core operations of its sub-classes, you don't even have to know specifically
    what sub-class was returned. Thanks to type inheritance, you can just declare
    your instance as being of type `WebRequest`, and use it accordingly, just like
    I did in the sample method from earlier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何以这四个前缀之一作为字符串首字符的 URI 字符串，都将被 `WebRequest` 基类可靠地处理。由于基类为其子类提供了执行核心操作所需足够接口，因此您甚至不需要知道具体返回了哪个子类。多亏了类型继承，您只需将您的实例声明为
    `WebRequest` 类型，并相应地使用它，就像我在之前的示例方法中所做的那样。
- en: But what if you don't want to work with one of these four preregistered types?
    What if you wrote your own custom `WebRequest` sub-class specifically for working
    with a **WebSocket** (**WS**) protocol, and you'd like to get the same support
    from `WebRequest` just by passing in a URI with the WebSocket prefix of `ws://`?
    Well, that exact use case leads us to another state management method: `RegisterPrefix(string,
    IWebRequestCreate)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不想使用这四种预注册的类型之一怎么办？如果你编写了自己的自定义`WebRequest`子类，专门用于处理**WebSocket**（**WS**）协议，并且你希望通过传递一个带有WebSocket前缀`ws://`的URI来从`WebRequest`获得相同支持？那么，这种确切的使用场景就引出了另一种状态管理方法：`RegisterPrefix(string,
    IWebRequestCreate)`。
- en: '`RegisterPrefix` is a powerful new tool that supports what''s known as **pluggable
    protocols**. It''s basically a way for you to incorporate custom implementations
    and sub-classes of the `WebRequest` and `WebResponse` base classes into the runtime
    of your application. When done properly, your custom code can be treated as a
    first-class citizen in the `System.Net` namespace, being appropriately delegated
    to by system types and methods, and having full access to the network stack, just
    like the native library classes you''ll be learning about next.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterPrefix`是一个强大的新工具，支持所谓的**可插拔协议**。它基本上是一种让你将自定义实现和`WebRequest`和`WebResponse`基类的子类纳入应用程序运行时的方式。当正确完成时，你的自定义代码可以被视为`System.Net`命名空间中的第一类公民，由系统类型和方法适当委派，并能够完全访问网络堆栈，就像你接下来将要学习的原生库类一样。'
- en: The scope and depth of fully implementing a custom protocol handler are beyond
    this chapter, and will be explored in more detail later in this book. For now
    though, just know that once the work of writing a custom protocol handler is completed,
    wiring it in is as simple as calling `RegisterPrefix`. That's why this falls under
    the domain of state management methods; because it's about configuring the working
    conditions of `WebRequest` for the duration of your application's runtime.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完全实现自定义协议处理器的范围和深度超出了本章的内容，将在本书的后续章节中更详细地探讨。不过，现在只需知道，一旦完成编写自定义协议处理器的任务，将其连接起来就像调用`RegisterPrefix`一样简单。这就是为什么这属于状态管理方法范畴；因为它关乎为应用程序运行时配置`WebRequest`的工作条件。
- en: 'The method returns a `bool` to indicate the success or failure of your attempt
    to register your custom protocol, and throw or process exceptions accordingly.
    So, while the process of setting up a pluggable protocol is outside the scope
    of this chapter, for now just trust that, once the work is done, configuring it
    as part of the valid state of the `WebRequest` class is a straightforward affair:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`bool`来指示你尝试注册自定义协议的成功或失败，并相应地抛出或处理异常。因此，虽然设置可插拔协议的过程超出了本章的范围，但在此阶段，只需相信一旦这项工作完成，将其配置为`WebRequest`类有效状态的一部分是一个简单直接的事情：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And with that, we have every tool we need to properly configure and initialize
    network requests. State management is complete, and all that's left is to begin
    submitting requests and processing responses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就拥有了配置和初始化网络请求所需的所有工具。状态管理已经完成，剩下的就是开始提交请求和处理响应。
- en: Request execution methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求执行方法
- en: As I said before, most of these methods are designed to be leveraged asynchronously,
    but at least a few of them have synchronous, or blocking, counterparts. While
    we'll talk more about async programming later, what's important now is to note
    that there are two primary operations or tasks around which the `WebRequest` class
    is focused. The first is accessing the actual request data stream, and the second
    is accessing the response returned by the remote resource.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，这些方法中的大多数都是设计用来异步使用的，但至少有少数几个有同步的或阻塞的对应方法。虽然我们稍后会更多地讨论异步编程，但重要的是现在要注意，围绕`WebRequest`类有两个主要操作或任务。第一个是访问实际请求数据流，第二个是访问远程资源返回的响应。
- en: With a `WebRequest` instance, the `RequestStream` is .NET's representation of
    the open connection. Think of it as the wire over which you can transmit your
    signal. Anytime you want to pass data through a `WebRequest` instance, you'll
    first need to access that wire. Once you have it, you can start passing data through
    that stream, and trust that the `WebRequest` class is going to broker its transmission
    accordingly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WebRequest`实例，`RequestStream`是.NET中表示的开放连接。把它想象成你可以传输信号的电线。任何时候你想通过`WebRequest`实例传递数据，你首先需要访问这条电线。一旦你拥有了它，你就可以开始通过这条流传递数据，并相信`WebRequest`类会相应地处理其传输。
- en: 'Bear in mind that writing to a stream typically requires the raw byte array
    for a given object (this is where serialization comes into play), so once we have
    our stream, writing to it isn''t as simple as passing our objects or messages
    directly over the wire, although it''s not prohibitively complicated either. In
    practice, however you choose to access the request stream for an active instance
    of `WebRequest`, writing to it will typically look similar to the following code
    block:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，向流写入通常需要给定对象的原始字节数组（这就是序列化的作用所在），因此一旦我们有了流，写入它并不像直接通过线缆传递我们的对象或消息那样简单，尽管它也不是特别复杂。在实践中，无论你选择如何访问`WebRequest`活动实例的请求流，写入它通常看起来像以下代码块：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And that's all there is to it. There are some nuances with this method in some
    of the common sub-classes of `WebRequest`, but the basic principle will always
    apply.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。在`WebRequest`的一些常见子类中，这种方法有一些细微差别，但基本原理始终适用。
- en: That, right there, accounts for about half of the request execution methods.
    The `BeginGetRequestStream()/EndGetRequestStream()`, `GetRequestStream()`, and `GetRequestStreamAsync()` methods
    are three different ways of accessing the same logical component of your network
    transaction. They simply provide varying degrees of control over the synchronization
    of the operation. For example, the `BeginGetRequestStream()/EndGetRequestStream()`
    method provides an opportunity for the user to cancel the request before it has
    completed transmission by explicitly calling the `Abort()` method. Meanwhile,
    the `GetRequestStreamAsync()` method doesn't provide the opportunity to explicitly
    abort the operation, but it does perform the operation asynchronously. Circumstances
    will dictate what method or methods you should be using, but if handled correctly
    and resolved properly by the underlying connection, the result object is the same.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这解释了请求执行方法的一半左右。`BeginGetRequestStream()/EndGetRequestStream()`、`GetRequestStream()`和`GetRequestStreamAsync()`方法是以不同方式访问网络事务相同逻辑组件的三种不同方法。它们只是提供了不同级别的操作同步控制。例如，`BeginGetRequestStream()/EndGetRequestStream()`方法为用户提供了一个在完成传输之前通过显式调用`Abort()`方法取消请求的机会。同时，`GetRequestStreamAsync()`方法不提供显式中止操作的机会，但它确实以异步方式执行操作。具体情况将决定你应该使用哪种方法或哪些方法，但如果处理得当并由底层连接正确解决，结果对象是相同的。
- en: Finally, we can look at the response processing methods, and it should be no
    surprise to you that in the request/response pattern that is typical of most network
    transactions, the response handlers match, almost exactly, with the request handler
    method signatures. So, where the act of retrieving a request stream from the `WebRequest`
    instance was exposed through four different methods with various levels of granular
    control over the synchronization of the operations, so too is response processing.
    The methods we have available to us are `BeginGetResponse()/EndGetResponse()`
    (the processing for which cannot be interrupted by `Abort()`, however), `GetResponseAsync()`,
    and of course, `GetResponse()`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看看响应处理方法，对于大多数网络事务典型的请求/响应模式，响应处理程序几乎与请求处理程序方法签名完全匹配。因此，在`WebRequest`实例中检索请求流通过四个不同方法暴露，并具有不同级别的操作同步粒度控制，响应处理也是如此。我们可用的方法有`BeginGetResponse()/EndGetResponse()`（其处理不能被`Abort()`中断），`GetResponseAsync()`，当然还有`GetResponse()`。
- en: Understanding the shape of a given response will depend on the specific protocol
    over which it was received. Just as the `WebRequest` class has protocol-specific
    sub-classes, so too does the `WebResponse` base class. We'll explore each of them
    in their respective chapters, and look at how their responses can be handled more
    concretely. But for now, it is sufficient to say that the `WebResponse` class
    provides us with a reliable enough interface to meaningfully interact with whatever
    we get back from our request.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理解给定响应的形状将取决于它所接收的具体协议。正如`WebRequest`类有特定协议的子类一样，`WebResponse`基类也是如此。我们将在各自的章节中探讨它们，并查看如何更具体地处理它们的响应。但到目前为止，可以说`WebResponse`类为我们提供了一个足够可靠的接口，可以有意义地与请求返回的任何内容进行交互。
- en: So, by now, you should have an extremely clear understanding of exactly what
    problem the `WebRequest` class was written to solve. You should understand its
    scope and the limits of its use cases, and hopefully, you will know exactly how
    to tune it so that you can fully leverage it for any scenario in which it could
    save you time and effort. With this understanding in mind, let's take a look at
    some of the most common ways the base class is explicitly leveraged through some
    of the sub-classes provided as part of the .NET Standard.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对`WebRequest`类旨在解决的确切问题有极其清晰的理解。你应该了解其范围和使用案例的限制，并且希望你能确切地知道如何调整它，以便在它能节省你时间和精力的任何场景中充分利用它。带着这种理解，让我们看看一些最常见的方式，即通过.NET标准提供的子类，明确地利用基类。
- en: The sub-classes of the WebRequest class
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRequest类的子类
- en: For a lot of typical use cases, you can rely on the basic functionality provided
    by the underlying `WebRequest` class. However, you'll never actually be using
    instances of it directly in your code (you can't... it's abstract, remember?),
    so now is the time to look at what other functionality or features exist when
    you're using common concrete instances of it. We'll look at each of the sub-classes
    for which `WebRequest` has a default, preregistered handler.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多典型用例，你可以依赖底层`WebRequest`类提供的基本功能。然而，你实际上永远不会直接在你的代码中使用它的实例（你不能……它是抽象的，记得吗？），所以现在是时候看看当你使用它的常见具体实例时，还有哪些其他功能或特性存在。我们将查看`WebRequest`具有默认、预先注册处理器的所有子类。
- en: A note on obsolete sub-classes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于已弃用子类的一个说明
- en: Here, it's important to note that the `WebRequest` class is primarily a tool
    for creating lower-level, protocol agnostic request/response transactions with
    other resources on your network. The .NET Standard provided sub-classes that,
    while not explicitly deprecated, have been made mostly obsolete by slightly more
    robust client classes, such as the `HttpClient` or `WebClient` classes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是要注意，`WebRequest`类主要是用于与网络上其他资源创建低级、协议无关的请求/响应事务的工具。.NET标准提供的子类，虽然并未明确弃用，但已被稍微更健壮的客户端类，如`HttpClient`或`WebClient`类，所取代。
- en: As a matter of fact, Microsoft recently released a recommendation for always
    using the newer client classes over any of the slightly older sub-classes that
    I'm about to discuss. That's precisely why so little of this chapter is dedicated
    to the concrete classes. The important aspects of the request/response model are
    still handled by .NET's `WebRequest` and `WebResponse` classes under the hood
    of the new `WebClient` class. More importantly, those base classes are the most
    basic building blocks from which you can build your own custom protocol handlers.
    That's why it's so important to understand, especially for readers new to any
    sort of web or network programming, how and why the `WebRequest` class is written
    the way it is. However, as is often the case with software, times are changing,
    and so the extent that this lesson will remain useful as a practical guide for
    specific implementation of common patterns will only diminish with time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，微软最近发布了一项建议，即始终使用较新的客户端类，而不是我即将讨论的任何稍微老旧的子类。这正是为什么本章如此少地致力于具体类的原因。请求/响应模型的重要方面仍然由.NET的`WebRequest`和`WebResponse`类在新的`WebClient`类的底层处理。更重要的是，这些基类是你构建自己的自定义协议处理器的最基本构建块。这就是为什么理解`WebRequest`类是如何以及为什么被编写成这样，对于任何初学网络或网络编程的读者来说如此重要的原因。然而，正如软件通常的情况一样，时代在变化，因此，作为对特定实现常见模式的实用指南，本课程的有用程度将随着时间的推移而逐渐降低。
- en: That being said, it is worth examining what is different about those classes
    and how they can be used to build up a network request from scratch, so let's
    take a brief look.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，考察这些类之间的不同之处以及它们如何从头开始构建网络请求是值得的，让我们简要地看一下。
- en: HttpWebRequest
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpWebRequest
- en: The `HttpWebRequest` class is interesting in that until very recently, it wasthe workhorse
    class of network programming in .NET. This is evident in the huge explosion of
    the class specification when compared to the relative simplicity of the `WebRequest`
    class. There are properties for each standard HTTP header that could be defined
    for a given payload, as well as a headers property inherited from the base class
    for specifying custom or non-standard headers. There are properties to specify
    the transport details, such as the `TransferEncoding`, or whether or not to send
    data in chunked segments. There are properties to specify how to handle exceptional
    behaviors from the remote host, such as the `MaximumResponseHeadersLength` and
    `MaximumAutomaticRedirections` properties. All of these properties allowed you
    to build a complete and strong payload for an HTTP request from scratch. As you
    can imagine, though, it was often tedious, error-prone, and verbose to do this
    for every request to every HTTP resource. Often, developers would hand-roll custom
    HTTP client classes of their own to isolate that aspect of their application in
    a write once, use everywhere approach. This degree of granularity is why the engineers
    at Microsoft decided to write a more robust and easy-to-use client for brokering
    common HTTP requests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpWebRequest`类很有趣，因为在最近非常长的一段时间里，它是.NET网络编程中的工作马。这一点从类规范的大量爆炸性增长与`WebRequest`类相对简单性的比较中可以明显看出。对于给定的有效负载，有每个标准HTTP头可能定义的属性，以及从基类继承的headers属性，用于指定自定义或非标准头。有属性用于指定传输细节，例如`TransferEncoding`，或者是否以分块段的形式发送数据。有属性用于指定如何处理来自远程主机的异常行为，例如`MaximumResponseHeadersLength`和`MaximumAutomaticRedirections`属性。所有这些属性都允许你从头开始构建一个完整的、强大的HTTP请求有效负载。然而，正如你可以想象的那样，对于每个HTTP资源的每个请求，这样做通常是繁琐的、容易出错的、冗长的。通常，开发者会手动编写自定义HTTP客户端类，以将应用程序的这一方面隔离在“一次编写，到处使用”的方法中。正是这种粒度级别使得微软的工程师决定编写一个更健壮、更易于使用的客户端来处理常见的HTTP请求。'
- en: It isinteresting to note, however, that if you look at class specifications
    side by side, the method signatures exposed by `HttpWebRequest` are exactly the
    same as those exposed by `WebRequest`. The only meaningful distinction between
    the two is the context-specific configurations that `HttpWebRequest` provides
    as class properties. This further highlights the elegance of the design of `WebRequest`.
    By taking a straightforward, generic approach to the problem, it can serve all
    possible specific use cases using the same patterns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，如果你并排查看类规范，`HttpWebRequest`公开的方法签名与`WebRequest`公开的方法签名完全相同。这两者之间唯一有意义的区别是`HttpWebRequest`作为类属性提供的上下文特定配置。这进一步突显了`WebRequest`设计的优雅。通过采用直接、通用的方法来解决问题，它可以使用相同的模式服务于所有可能的特定用例。
- en: FtpWebRequest
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FtpWebRequest
- en: The `FtpWebRequest` class provides many of the same properties as the `HttpWebRequest`
    class. The distinction comes in the form of a few specific properties for configuring
    reliable behavior when processing potentially large files over a potentially unreliable
    or slow connection. To that end, it provides the `ReadWriteTimeout` property that
    specifies the maximum amount of time allowed for processing the file stream. There's
    also the FTP-specific `UsePassive` property that allows a user to specify the
    use of the passive transfer process, leaving an open listening connection on the
    server for clients to access files accordingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`FtpWebRequest`类提供了与`HttpWebRequest`类许多相同的属性。区别在于一些特定的属性，用于在处理可能通过不可靠或慢速连接传输的潜在大文件时配置可靠行为。为此，它提供了`ReadWriteTimeout`属性，该属性指定处理文件流允许的最大时间量。还有FTP特定的`UsePassive`属性，允许用户指定使用被动传输过程，在服务器上留下一个开放的监听连接，以便客户端相应地访问文件。'
- en: There's also the explicit `EnableSsl` parameter, which you might have noticed
    was not a property of `HttpWebRequest`. Interestingly, this is necessary for the
    `FtpWebRequest` class but not the `HttpWebRequest` class because the use of **Secure
    Sockets Layer** (**SSL**) in HTTP is actually specified in the protocol component
    of the URI (that is, HTTP versus HTTPS); whereas with FTP, that feature must be
    enabled explicitly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个显式的`EnableSsl`参数，你可能已经注意到它不是`HttpWebRequest`的属性。有趣的是，这对于`FtpWebRequest`类是必要的，但对于`HttpWebRequest`类则不是，因为HTTP中**安全套接字层（SSL**）的使用实际上是在URI的协议组件中指定的（即HTTP与HTTPS之间的区别）；而FTP，该功能必须显式启用。
- en: Once again, the actual use of the `FtpWebRequest` class is exactly the same
    as with the `WebRequest` base class. Once the protocol-specific settings are properly
    configured through the class properties, FTP is ultimately just another request/response
    protocol for accessing remote resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`FtpWebRequest`类的实际使用与`WebRequest`基类完全相同。一旦通过类属性正确配置了特定协议的设置，FTP最终只是另一种用于访问远程资源的请求/响应协议。
- en: FileWebRequest
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileWebRequest
- en: The `FileWebRequest` is probably the least commonly used sub-class of them all.
    Its signature almost perfectly matches that of the `WebRequest` base class. Its
    purpose is to expose the same reliable request/response pattern for accessing
    resources on the local file system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWebRequest`可能是所有子类中最不常用的。它的签名几乎完美地匹配`WebRequest`基类。它的目的是暴露相同的可靠请求/响应模式，用于访问本地文件系统上的资源。'
- en: At this point, you may be wondering why on earth such a class would ever be
    useful. Well, like any good engineer, we'll eventually want to be able to do a
    unit and integration test on our network software. However, that won't always
    be feasible, since remote resources that we can expect to be available to our
    production environment might not always be available to our development environment.
    In that case, you'd want to be able to access your mock resources on your local
    system. Thanks to the shared parent class of the `WebRequest` class, it's a trivial
    matter to swap out an instance of `FileWebRequest` and `HttpWebRequest` in your
    development and production environments, respectively. Since each of these sub-classes
    is only ever instantiated through the `Create()` method on the `WebRequest` class,
    doing so is as easy as changing the URI of the remote resource stored in your
    application's configuration files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么这样一个类会有任何用处。好吧，像任何优秀的工程师一样，我们最终都希望能够对我们的网络软件进行单元和集成测试。然而，这并不总是可行的，因为我们期望在生产环境中可用的远程资源可能并不总是可用在我们的开发环境中。在这种情况下，你将想要能够访问你本地系统上的模拟资源。多亏了`WebRequest`类的共享父类，替换开发环境和生产环境中的`FileWebRequest`和`HttpWebRequest`实例是一件微不足道的事情。由于每个子类都仅通过`WebRequest`类上的`Create()`方法实例化，这样做就像更改应用程序配置文件中存储的远程资源URI一样简单。
- en: The power of the `FileWebRequest` class comes from the consistency of its interface.
    So, while there are no special properties or methods associated with this instance
    of the class, extending the behavior of `WebRequest` to local file access is really
    what makes this class valuable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWebRequest`类的强大之处在于其接口的一致性。因此，尽管与这个类的实例没有特殊属性或方法相关联，但将`WebRequest`的行为扩展到本地文件访问实际上才是这个类有价值的地方。'
- en: And with that, our crash-course on the building blocks of network interactions
    is complete.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们对网络交互构建块的基础速成课程就完成了。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a thorough look at the `WebRequest` utility class,
    and how it can be used to handle a wide variety of common network operations within
    the context of a .NET application. We used the public interface of the class definition
    to infer the proper use and use cases for the class, as well as identifying the
    limits of its scope and operations. We considered the proper use and invocation
    of each of the public properties and methods defined on the base class, and wrote
    out some broadly applicable examples to demonstrate the simplicity and utility
    of the class and its children. Then, we considered the three most common concrete
    sub-classes of `WebRequest`. We examined some of the nuances between each of them
    and looked at how they facilitate the specific details of the protocols they were
    designed to operate over. Now we're ready to look at how to process the results
    of those requests in the most optimal way for the .NET runtime. It's time we looked
    at data stream processing, multi-threading, and asynchronous programming, which
    we'll explore in the next chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面审视了`WebRequest`实用类，以及它如何在.NET应用程序的上下文中处理各种常见的网络操作。我们通过类的公共接口来推断类的适当使用和用例，以及确定其作用域和操作的局限性。我们考虑了在基类上定义的每个公共属性和方法的适当使用和调用，并编写了一些广泛适用的示例来展示该类及其子类的简单性和实用性。然后，我们考虑了`WebRequest`的三个最常见的具体子类。我们考察了它们之间的细微差别，并研究了它们如何促进它们设计要操作的特定协议的细节。现在，我们准备探讨如何以最优化方式处理这些请求的结果，以适应.NET运行时。是时候研究数据流处理、多线程和异步编程了，这些内容将在下一章中探讨。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the valid values for the `CachePolicy` property of the `WebRequest`
    class, and where can they be found?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebRequest` 类的 `CachePolicy` 属性的有效值有哪些，它们可以在哪里找到？'
- en: What is the method used to associate the custom sub-classes of the `WebRequest`
    class with requests to the associated protocol for that custom sub-class?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于将 `WebRequest` 类的定制子类与该定制子类关联的协议的请求关联的方法是什么？
- en: What property is used to associate multiple requests to the same connection
    in the .NET connection pool?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET 连接池中，用于关联多个请求到同一连接的属性是什么？
- en: What are the four preregistered protocols for which the `WebRequest` class is
    configured to return a valid sub-class from the `Create(uri)` method?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `WebRequest` 类配置为从 `Create(uri)` 方法返回有效子类的四个预注册协议是什么？
- en: What is the difference between `BeginGetRequestStream()`, `GetRequestStreamAsync()`,
    and `GetRequestStream()`?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BeginGetRequestStream()`、`GetRequestStreamAsync()` 和 `GetRequestStream()`
    之间的区别是什么？'
- en: Name some of the ways the `HttpWebRequest` class differs from the default behavior
    of the `WebRequest` class?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举一些 `HttpWebRequest` 类与 `WebRequest` 类默认行为不同的方式？
- en: Why is it important to always leverage `ConnectionGroupName` whenever possible?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在可能的情况下始终利用 `ConnectionGroupName` 非常重要？
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For additional reading on this subject, or to expand your horizons once you've
    conquered the realm of network programming, check out *Building Microservices
    with .NET Core*,* Gaurav Aroraa, Lalit Kale, and Kanwar Manish*, available through
    Packt Publishing at [https://www.packtpub.com/web-development/building-microservices-net-core](https://www.packtpub.com/web-development/building-microservices-net-core).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的进一步阅读，或者在你征服了网络编程领域之后拓展视野，可以查看由 Packt Publishing 出版的 *Building Microservices
    with .NET Core*，作者为 Gaurav Aroraa, Lalit Kale 和 Kanwar Manish，[https://www.packtpub.com/web-development/building-microservices-net-core](https://www.packtpub.com/web-development/building-microservices-net-core)。
- en: 'Additionally, I''d recommend checking out *C# 7 and .NET: Designing Modern
    Cross-platform Applications, Mark J. Price and Ovais Mehboob Ahmed Khan, Packt
    Publishing,* for some solid advice for practical applications of the concepts
    discussed here. You can find this book at [https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications](https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我还建议查看 Packt Publishing 出版的 *C# 7 and .NET: Designing Modern Cross-platform
    Applications*，作者为 Mark J. Price 和 Ovais Mehboob Ahmed Khan，以获取关于此处讨论的概念在实际应用中的实用建议。你可以在这本书的[https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications](https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications)找到这本书。'
