- en: '*Chapter 10*: Designing and Implementing Microsoft DevOps Solutions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the key characteristics of modern
    web solutions. We also explored the project structure of the three main frontend
    frameworks and provided a quick comparison. We then learned the three hosting
    options in Azure and how to choose the best hosting approach for our solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to effectively plan and manage **DevOps**
    processes while building Microsoft solutions. Azure DevOps offers a set of modern
    tools that allow us to plan smarter and develop a product faster. It also provides
    solid collaboration between the team members to deliver better quality products.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Exploring agile planning with **Azure Boards**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about source control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Git repositories, along with branching and pull requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know **Azure Artifacts**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the logic behind the CI/CD practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have learned how to make use of DevOps to
    build, test, and deploy our applications using modern software development practices.
    Moreover, we will know about Work Items, and we will have learned about **Git**
    and its main capabilities. We will have also explored how to manage packages using
    Azure Artifacts, and also understood the **continuous integration**/**continuous
    development** (**CI**/**CD**) practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the key characteristics of modern web solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Agile planning with Azure Boards
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Boards is a service provided by **Microsoft** as part of the Azure DevOps
    service. It provides a set of features and capabilities for managing the entire
    life cycle of the software project. It includes tools for managing **Work Items**,
    **Sprints**, and **Backlogs**. Moreover, it provides end-to-end predefined and
    customizable dashboards, allowing us to dig deeper into the big picture of the
    project's activities, alongside essential **KPIs** and metrics, to understand
    how the project is progressing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring the core features of Azure Boards.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Work Items
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Work Items** are the core components in Azure DevOps and can help our Agile
    team manage their daily work, organize Sprints, and prioritize tasks in Backlogs.
    A Work Item can be a general task, an issue, or a requirement. The following screenshot
    shows the landing page of **Work Items**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Work Items landing page](img/Figure_10.01_B17366.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Work Items landing page'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot represents the home page of all **Work Items**, where
    we can filter items based on specific criteria. We can also assign items, add
    new items, and manage existing ones. This page provides every person that's working
    on the project with a complete view of the progress, along with the status of
    each item and who is doing what. We can filter to see tasks that were planned
    to be delivered in the next **Sprints**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify the dependencies between the items to break large tasks
    down into smaller, more manageable items, as well as create queries and save them
    for later use. A query is a filtered view of all the **Work Items**. For example,
    we can create a query to display the active tasks, or a query to display tasks
    that have been assigned to a particular team member.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to create a new Work Item. As shown in the following screenshot,
    we just need to click on **New Work Item** and then choose the type; that is,
    **Epic**, **Issue**, or **Task**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Action menu for creating a new Work Item](img/Figure_10.02_B17366.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Action menu for creating a new Work Item'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'In the action menu, we can see three main types of Work Items:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Epic**: This represents a large item that''s required for the product to
    function. It can be broken down into smaller user stories. A user story is a specific
    Work Item within **Epic**. For example, let''s assume we have received a request
    to implement a login mechanism for an e-commerce website. In this case, the Epic
    represents this request. The user stories here could be **Login with Email**,
    **Login with Google**, **Login with Facebook**, and **Forgot password**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature**: This represents the bulk of the functionality that fulfils users''
    needs. A **Feature** is a collection of user stories that delivers business value
    and the context of the software product.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role-feature-benefit` template: as a (*user role*), I want (*an action/or
    goal*) so that (*a benefit/or reason*); for example: as a (*customer*), I want
    (*a shopping cart functionality*) so that (*I can buy items and pay online*).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue**: This represents bugs, code defects, and software issues that we
    may capture while developing the product.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task**: This represents a Work Item that has been planned as part of building
    the product. This can be either a result of an issue or requirements, including
    requirement analysis, development, or testing.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the details page of a sample Work Item:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: A bug item details page](img/Figure_10.03_B17366.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: A bug item details page'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: On the details page, we can see that every Work Item has a title with a unique
    ID, status, and iteration, along with the steps to reproduce if it is a defect,
    or an item description if it is a requirement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the comments that are attached to the Work Item. These represent
    the discussion happening between the team members about this Work Item. We can
    follow a Work Item to receive notifications whenever there is an update. We can
    also assign it to a team member, as well as link it to another Work Item by, for
    example, linking an issue to a task or Epic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use Work Items to report and organize
    work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Boards, Backlogs, and Sprints
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about Work Items, so let's learn how to
    use them in Boards, Backlogs, and Sprints to organize and track team deliverables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a sample board that was associated with a project
    upon its creation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Sample Kanban Board](img/Figure_10.04_B17366.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Sample Kanban Board'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Every time we create a new project, there is a preconfigured **Kanban Board**
    that is created and linked to the project so that we can visualize the progress
    of work items. This board is fully customizable. We can drag and drop items from
    one category to another to reflect the current situation of the project. We can
    also organize tasks by status, ownership, Sprints, or any other criteria.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Backlogs** help us keep things organized according to priorities. As shown
    in the following screenshot, Backlogs provide a flat view of the Work Items, while
    Boards display them as cards:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Backlogs list view](img/Figure_10.05_B17366.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Backlogs list view'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The product backlog should reflect the plan and roadmap of what we plan to deliver
    in the upcoming Sprints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, **Sprints** are the heartbeat of DevOps as they represent the iterations
    of an Agile project. A Sprint has its own **Capacity** planning and **Taskboard**.
    It should be short in terms of duration, typically between 1 to 4 weeks; during
    this period, there must be a set of Work Items that should be accomplished by
    the team. The following screenshot shows a sample **Sprint** view:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Sprint view](img/Figure_10.06_B17366.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Sprint view'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see how the tasks are organized in the **Taskboard**
    area to reflect the plan of a **Sprint**. We can drag and drop items between the
    different categories, and we can check the overall progress of the team in this
    **Sprint**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft documentation for learning about and understanding everything
    related to Azure Boards can be found at [https://docs.microsoft.com/en-us/azure/devops/boards/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/boards/?view=azure-devops).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to define the project roadmap and plan Work
    Items. This helps our team break down complex solutions into manageable workloads
    by using a robust platform from Azure DevOps. In the next section, we will learn
    about source control in Azure DevOps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with source control
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Source control** (also known as **version control**) is an essential part
    of DevOps. It is a collaboration platform that can be used by the development
    team to track and manage changes in the source code. It provides a historical
    version of each source code file in the project. It also helps resolve conflicts
    when merging changes from multiple developers. **Azure Repos** is a set of version
    control tools that we can use to manage our code.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of source control benefits:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Ability to create multiple workflows for development, production, and testing.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of collaboration that must be done by the development team to
    deliver the product, especially at the source code level, to maintain a common
    repository when multiple developers are working on the same project.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control supports us tracking and managing all the changes that have been
    made to the code by multiple team members. This is very important, especially
    when we need to resolve conflicts when multiple developers try to modify the same
    file.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintains a history of changes by allowing us to retrieve the complete history
    of every file in the repository.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to label the source code to keep track of the product version, especially
    when we have multiple releases. We can also create branches to manage the development
    activities between the production and development environments.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Repos provides two types of version control:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Team Foundation Version Control** (**TFVC**): The code history is centralized
    on the server and team members need to be connected to check in.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: The code history is distributed on each team member''s machine, where
    they can commit changes locally.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling Git for enterprise DevOps
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is one of the most essential version control systems that is adopted by
    development teams and companies. Git is a distributed version control system,
    which means the local copy of the source code that's stored on each machine represents
    a complete version control repository.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn more about Git and how to structure repositories,
    manage branches, and collaborate with pull requests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Git repos
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of repositories that we can use with Git:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Mono-repo**: More than one project is stored in a single repository'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-repo**: Each project has its own repository'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mono versus multi; *what''s the right approach?* There is no direct answer
    that would recommend a particular approach. The strategy that we choose to use
    in order to structure our repositories is totally based on our way of managing
    projects; both types have their advantages and disadvantages. However, it is good
    to mention that **Facebook** and **Google** use mono-repos to manage their projects.
    Here are some key points to help you decide which strategy to follow:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Mono-repo facilitates managing dependencies that may be complex if we use multi-repo.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With mono-repo, we may face some performance drawbacks in the case of a large
    code base. This is not a problem in multi-repo.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's noticeable that enforcing common practices and standards is easier in mono-repo
    than in multi-repo.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-repo allows us to work efficiently by enabling each microservice team
    to work independently to finish their work faster. This allows us to grant developers
    access to the repositories they need to access.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategy with Git
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git branches are effective references to a snapshot of the code changes. A branch
    provides a way to isolate changes related to a new feature or a hotfix from the
    main branch of the code. Code changes that are committed to one branch don't affect
    the other branches automatically, unless we merge changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to adopt a branching strategy and make it simple by following
    these three concepts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Create a new branch for every feature or set of features of a particular release.
    This is also applicable in the case of releasing hotfixes after fixing defects.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sub-branches into the main branch by using pull requests. Never merge
    code into the main branch unless the code had been tested properly, and also ensure
    that the affected functionalities are working well and certified.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the main branch up to date and never modify code directly inside it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how all the sub-branches merge their updates into
    the main branch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Merging sub-branches into the main branch](img/Figure_10.07_B17366.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Merging sub-branches into the main branch'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many branching strategies that you can implement. The most important
    part is to separate the development activities from the production code by creating
    two separate branches. One of the strategies that we can follow is the **trunk-based
    branching** strategy, as shown in the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Trunk-based branching strategy](img/Figure_10.08_B17366.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Trunk-based branching strategy'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see the two main branches: development (**Dev**)
    and production (**Main**). The concept here is that we never write code directly
    into the **Main** branch. Instead, we need to create a branch for hotfixes; at
    the same time, the hotfixes should be merged with **Dev** after proper testing.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: As for the **Release** branch, it is usually created from the development branch.
    After development and proper testing, it is merged with both the production and
    development branches. This way, we make sure that the **Main** branch contains
    the production version of the code, while the **Dev** branch contains the development
    branches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Git branches are inexpensive to create and maintain. Therefore, as shown in
    the preceding diagram, we created a separate branch. Even small fixes and changes
    should have their own feature branches, which should simplify reviewing the history
    of the changes. When creating a new branch, it is important to provide descriptive
    information about the branch and link it to a Work Item.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating with pull requests in Azure repos
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pull requests** are robust mechanisms for notifying the team leader or the
    code reviewer that the development of a new feature or a bug fix has been completed,
    and that the code must be reviewed before it''s merged into the main branch. Avoid
    merging code to the main branch without a pull request, which enforces a code
    review process. This is essential for improving the code''s quality.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'It is noticeable that if the feedback that was received after the review process
    is good and up to standards, it may improve the code''s quality. Therefore, it
    is recommended that you provide high-quality feedback. Here are some key suggestions
    for successful pull requests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Having the right people to review the pull request and provide feedback is a
    key factor for better reviews.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to have two reviewers as an optimal number for the review
    process.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving actionable and constructive feedback is very essential.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to reply to comments promptly to accelerate the pull request
    process, especially if you have a large number of requests in the queue.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing enough details in the branch description helps the reviewer understand
    the purpose of the changes.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to combine the code review sessions, if you have them in place,
    with the pull request process to avoid duplicating the effort.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the structuring options that we can use in
    Git repositories and how to choose between them. We also explored some recommendations
    for a better branching strategy and discussed the benefits of the pull request
    process. We then highlighted some key factors for improving this process. In the
    next section, we are going to learn how to set a good dependency management strategy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Managing packages with Azure Artifacts
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Artifacts** is an extension in Azure DevOps that provides a set of
    capabilities to create and manage packages with **NuGet**, **npm**, and **Maven**.
    This can help us manage the dependencies in our code base and group them into
    feeds. Each feed that''s created in Azure Artifacts has its own URL that we can
    consume from **Visual Studio** to install the packages into our solution; the
    development team can also use the same feed URL to publish private packages.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Artifacts is free as long as the size of the packages and artifacts is
    less than **2 GB**. Everything above 2 GB will be billed according to the subscription
    plan. The following page on Azure Artifacts can be found in the left-hand side
    menu, next to the arrow depicted in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Packages feed within Azure Artifacts](img/Figure_10.09_B17366.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Packages feed within Azure Artifacts'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have a feed called **CMSArtifacts**. In this
    feed, we can see a group of packages that were added to this container. The purpose
    here is to organize the public and private packages that we are using in our solutions
    into a feed that can be consumed by the development team.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: With Azure Artifacts, we can create views of the feed. For instance, we can
    create a view for the packages that are used in the development environment and
    another view for the production version of the product.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows three different views of the same feed; that
    is, **Local**, **Prerelease**, and **Release**. Each view holds a particular version
    of the packages, and it is being used for a particular work environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Feed views](img/Figure_10.10_B17366.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Feed views'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are three views in the preceding screenshot. These views
    were created alongside the feed. We can still add new views or modify an existing
    one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Upstream source**, as shown in the preceding screenshot, allows us to group
    the packages that we create along with the packages that we consume from the remote
    feeds in one place. The following screenshot shows the interface we can use to
    create an upstream. Notice that we can specify the type of **View** that we want
    to use for the upstream:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Adding an upstream source with a specific view](img/Figure_10.11_B17366.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Adding an upstream source with a specific view'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Each upstream source is linked to one view, and that's how we can make use of
    the views in Visual Studio through upstream sources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we introduced Azure Artifacts, which supports the multiple
    feeds approach. We can make use of it to organize and group the packages that
    we are consuming in our projects. For more technical information on how to create
    and manage Azure Artifacts, please refer to the Microsoft documentation: [https://docs.microsoft.com/en-us/azure/devops/artifacts/overview?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/artifacts/overview?view=azure-devops).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore continuous integration with **Azure Pipelines**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Exploring CI/CD with Azure pipelines
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration**, **continuous delivery**, and **continuous deployment**
    (or **CI**/**CD**) are the main pillars of building, testing, and deploying robust
    applications using modern software development techniques in DevOps. These practices
    allow us to release new features and fixes quickly through automated processes.
    Let''s get to know each of these practices.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is the nucleus practice in DevOps. It allows
    us to frequently integrate all source code modifications coming from multiple
    developers into the main repository. It is an automated process that can be configured
    in Azure DevOps. When this capability is enabled, every time a developer commits
    their code, the CI will be verified by starting an automated build process to
    verify that the project contains no build errors. After that, an automated testing
    process is triggered to confirm that the newly committed code is stable. This
    approach is very helpful for identifying errors quickly and easily.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous delivery** is a practice that automates the delivery step that
    comes after the building and testing phase. Whenever we have a successful build
    and tests, an automated process is triggered to deploy the artifacts to the desired
    environment. This can be staging or production. Note that in this practice, shipping
    the code from staging to production is completed through manual intervention.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous deployment** has a lot in common with continuous delivery. The
    main difference is that this practice automates the entire life cycle of the release
    process, and the artifacts are automatically deployed to production.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the steps of each practice:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: CI/CD steps](img/Figure_10.12_B17366.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: CI/CD steps'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, neither the **Continuous Delivery** nor **Continuous
    Deployment** processes can start unless the **Continuous Integration** process
    is completed. The steps between **Continuous Delivery** and **Continuous Deployment**
    are almost the same; however, in **Continuous Delivery**, the deployment to production
    is done through a manual job, while in **Continuous Deployment**, it is an automatic
    process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: To implement a build strategy, we need to make use of the pipelines in Azure
    DevOps. A pipeline is an automated service that's used to verify a build and make
    it ready for deployment. The usage of the pipeline will reduce the manual work
    needed from the developer to merge the code, build it, and test the changes, along
    with the affected features. It is important to mention that the pipelines are
    used in continuous delivery and continuous deployment to automate their steps.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fundamental procedures of Agile planning in
    Azure DevOps. We also learned about Azure Boards, along with related components,
    such as Work Items, Backlogs, and Sprints. Then, we discussed source control and
    explained the difference between TFVC and Git.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored Git and how it can version source code, before learning
    about branching and pull requests. Later, we learned about the packages that are
    available in Azure Artifacts, along with CI/CD, which help automate the steps
    related to building, testing, and deploying our code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished reading this book, your mind is probably filled with
    a lot of different ideas since you've dived deep into the everyday aspects of
    solution architecture. I suggest that you start by measuring where you are on
    your journey toward becoming an effective solution architecture. A good solution
    architect helps build high-quality products that fit the existing environment,
    along with the clients' requirements. To achieve this, a solution architect must
    learn about each part of the business model and how these parts work together.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We covered many topics in this book. However, it is a good practice that we
    develop a learning mindset by frequently researching and getting to know new techniques
    and patterns in solution architectures, and also focus on the cloud services offered
    by Azure for building modern solutions. At the same time, it is essential to always
    improve our soft skills, especially if we want to become effective leaders. I
    hope that you have enjoyed reading this book as much as I enjoyed writing it and
    sharing my thoughts and experiences. I wish you every success in all your .NET
    projects!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了众多主题。然而，经常进行研究和了解解决方案架构中的新技术和模式，培养一种学习心态，以及专注于Azure提供的云服务以构建现代解决方案，这是一种良好的实践。同时，不断提高我们的软技能至关重要，尤其是如果我们想成为有效的领导者。我希望您阅读这本书的乐趣与我写作和分享我的想法和经验一样多。祝您在所有.NET项目中取得成功！
