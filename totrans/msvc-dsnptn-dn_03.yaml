- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Synchronous Communication between Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的同步通信
- en: In the previous chapter, we learned about aggregator patterns and how they help
    us scope our storage considerations for our microservices. Now, we will focus
    on how our services communicate with each other during the application’s runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了聚合器模式以及它们如何帮助我们为微服务定义存储考虑因素。现在，我们将关注服务在应用程序运行时如何相互通信。
- en: We have already established that microservices should be autonomous and should
    handle all operations relating to tranches of the domain operations that are to
    be completed. Even though they are autonomous by design, the reality is that some
    operations require input from multiple services before an end result can be produced.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定微服务应该是自治的，并且应该处理所有与要完成的领域操作片段相关的操作。尽管它们在设计上是自治的，但现实情况是，某些操作在产生最终结果之前需要从多个服务中获取输入。
- en: At that point, we need to consider facilitating communication, where one service
    will make a call to another, wait on a response, and then take some action based
    on that said response.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个阶段，我们需要考虑促进通信，其中一个服务将调用另一个服务，等待响应，然后根据该响应采取一些行动。
- en: 'After reading this chapter, we will be able to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们将能够做到以下几点：
- en: Understand why microservices need to communicate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么微服务需要通信
- en: Understand synchronous communication with HTTP and gRPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用HTTP和gRPC的同步通信
- en: Understand the disadvantages of microservice communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务通信的缺点
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在GitHub上的项目仓库中找到，该仓库托管在[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03)。
- en: Use cases for synchronous communication
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步通信的使用案例
- en: Considering everything that we have covered so far regarding service independence
    and isolation, you are probably wondering why we need to cover this topic. The
    reality is that each service covers a specific tranche of our application’s procedures
    and operations. Some operations have multiple steps and parts that need to be
    completed by different services, and for this reason, it is important to properly
    scope which service might be needed, when it will be needed, and how to best implement
    communication between the services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们迄今为止关于服务独立性和隔离性的所有讨论，你可能想知道为什么我们需要涵盖这个主题。现实情况是，每个服务覆盖了我们应用程序流程和操作的一个特定部分。一些操作有多个步骤和部分需要由不同的服务完成，因此，正确界定可能需要的服务、何时需要以及如何最佳地实现服务之间的通信是很重要的。
- en: Interservice communication needs to be efficient. Given that we are talking
    about a number of small services interacting to complete an activity, we need
    to ensure that the implementation is also robust, fault-tolerant, and generally
    effective.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间的通信需要高效。鉴于我们讨论的是多个小服务相互作用以完成一项活动，我们需要确保实现也是健壮的、容错的，并且通常有效。
- en: '*Figure 3.1* gives an overview of synchronous communication between microservices:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*概述了微服务之间的同步通信：'
- en: '![Figure 3.1 – One request might require several follow-up calls to additional
    services ](img/Figure_3.1_B19100.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 一个请求可能需要几个后续调用到其他服务](img/Figure_3.1_B19100.jpg)'
- en: Figure 3.1 – One request might require several follow-up calls to additional
    services
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 一个请求可能需要几个后续调用到其他服务
- en: Now that we understand why services need to communicate, let us discuss the
    different challenges that surround interservice communication.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了为什么服务需要通信，让我们讨论围绕服务间通信的不同挑战。
- en: Challenges of microservice communication
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务通信的挑战
- en: At this point, we need to accept that we are building a far more complex and
    distributed system than a monolith would permit. This comes with its own challenges
    when navigating the general request-response cycle of a web service call, the
    appropriate protocols to be used, and how we handle failures or long-running processes.
    Generally speaking, we have two broad categories of communication in *synchronous*
    and *asynchronous* communication. Beyond that, we need to scope the nature of
    the operation and make a call accordingly. If the operation requires an immediate
    response, then we use synchronous techniques, and for long-running processes that
    don’t necessarily need a response immediately, we make it asynchronous.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要接受我们正在构建一个比单体架构更为复杂和分布式的系统。在导航网络服务调用的一般请求-响应周期、适当的协议以及如何处理故障或长时间运行的过程时，这会带来它自己的挑战。一般来说，我们在**同步**和**异步**通信中有两种广泛的通信类别。除此之外，我们需要确定操作的性质并据此做出调用。如果操作需要立即响应，那么我们使用同步技术；对于不需要立即响应的长时间运行过程，我们将其异步化。
- en: 'As mentioned before, we need to ensure that our interservice operations boast
    of the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要确保我们的服务间操作具有以下特点：
- en: '**Performance**: Performance is always something we have in the back of our
    minds while developing a solution. Individually, we need each service to be as
    performant as possible, but this requirement extends to communication scenarios,
    too. We need to ensure that when one service calls another, the call is done using
    the most efficient method possible. Since we are predominantly using *REST APIs*,
    *HTTP* communication will be the go-to method. Additionally, we can consider using
    *gPRC*, which allows us to call a REST API with the benefit of higher throughput
    and less latency.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：在开发解决方案时，性能总是我们心中所考虑的事情。个别来说，我们需要每个服务尽可能高效，但这种要求也扩展到通信场景。我们需要确保当一个服务调用另一个服务时，调用是使用最有效的方法进行的。由于我们主要使用**REST
    API**，**HTTP**通信将是首选方法。此外，我们可以考虑使用**gRPC**，这允许我们以更高的吞吐量和更低的延迟调用REST API。'
- en: '**Resilient**: We need to ensure that our service calls are done via durable
    channels. Remember that hardware can fail, or there can be a network outage at
    the same time as the service call is being executed. So, we need to consider two
    patterns that will make our services resilient, *Retry* and *Circuit Breaker*:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：我们需要确保我们的服务调用是通过耐用通道完成的。记住，硬件可能会失败，或者当服务调用正在执行时，可能会出现网络中断。因此，我们需要考虑两种将我们的服务变得弹性的模式：**重试**和**断路器**：'
- en: '**Retry pattern**: Transient failures are common and temporary failures can
    derail an operation’s completion. However, they tend to go away by themselves,
    and we would prefer to retry the operation a few times, as opposed to failing
    the application’s operation completely. Using this pattern, we retry our service
    call a few times, based on a configuration, and should we not have any success,
    trigger a timeout. For operations that augment the data, we will need to be a
    bit more careful since the request might get sent and a transient failure might
    prevent a response from being sent. This doesn’t mean that the operation wasn’t
    actually completed, and retrying might lead to unwanted outcomes.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试模式**：瞬态故障很常见，暂时的故障可能会阻碍操作完成。然而，它们往往会自行消失，我们更愿意尝试操作几次，而不是完全失败应用程序的操作。使用这种模式，我们根据配置重试我们的服务调用几次，如果没有成功，则触发超时。对于增强数据的操作，我们需要更加小心，因为请求可能会被发送，瞬态故障可能会阻止响应被发送。这并不意味着操作实际上没有完成，重试可能会导致不希望的结果。'
- en: '**Circuit breaker pattern**: This pattern is used to limit the number of times
    that we try to make the service call. Multiple calls might fail because of how
    long a transient failure takes to resolve itself, or the number of requests going
    to the service might cause a bottleneck in the available system resources and
    allocations. So, with this pattern, we could configure it to limit the amount
    of time we spend trying to call one service.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器模式**：这种模式用于限制我们尝试调用服务次数的次数。多次调用可能会因为瞬态故障解决所需的时间过长，或者服务请求的数量可能导致可用系统资源和分配出现瓶颈。因此，使用这种模式，我们可以配置它来限制我们尝试调用一个服务所花费的时间。'
- en: '**Traced and monitored**: We have established that a single operation can span
    multiple services. This brings another challenge in monitoring and tracing activities
    through all the services, from one originating point. At this point, we need to
    ensure that we are using an appropriate tool that can handle distributed logging
    and aggregate them all into a central place for easier perusal and issue tracking.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪和监控**：我们已经确定单个操作可以跨越多个服务。这给通过所有服务进行监控和跟踪活动带来了另一个挑战，从单一源头开始。此时，我们需要确保我们使用的是一款能够处理分布式日志并将它们全部聚合到中央位置以便于查阅和问题跟踪的适当工具。'
- en: Now that we have a clearer picture of why we need to communicate and what challenges
    we might face, we will look at practical situations for synchronous communication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚地了解了为什么我们需要进行通信以及我们可能会面临哪些挑战，我们将探讨同步通信的实际应用场景。
- en: Implementing synchronous communication
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现同步通信
- en: Synchronous communication means that we make a direct call from one service
    to another and wait for a response. Given all the fail-safes and retry policies
    that we could implement, we still evaluate the success of the call based on us
    receiving a response to our call.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同步通信意味着我们从一项服务直接调用另一项服务并等待响应。考虑到我们可以实施的所有安全措施和重试策略，我们仍然根据是否收到对调用响应来评估调用的成功。
- en: In the context of our hospital management system, a simple query from the frontend
    will need to be done synchronously. If we need to see all the doctors in the system
    to present a list to the user, then we need to invoke a direct call to the doctors’
    API microservice, which fetches the records from the database and returns the
    data with, more than likely, a 200 response that depicts success. Of course, this
    needs to happen as quickly and efficiently as possible, as we want to reduce the
    amount of time the user spends waiting on the results to be returned.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的医院管理系统背景下，前端的一个简单查询需要同步执行。如果我们需要查看系统中的所有医生以向用户展示列表，那么我们需要直接调用医生的API微服务，该服务从数据库中检索记录并返回数据，很可能会以200响应表示成功。当然，这需要尽可能快和高效地完成，因为我们希望减少用户等待结果返回的时间。
- en: There are several methods that we can use to make an API call, and HTTP is the
    most popular. Support for HTTP calls exists in most languages and frameworks,
    with C# and .NET not being exceptions. Some of the advantages of HTTP come through
    standardized approaches to reporting; the ability to cache responses or use proxies;
    standard request and response structures; and standards for response payloads.
    The payload of an HTTP request is, generally, in JSON. While other formats can
    be used, JSON has become a de facto standard for HTTP payloads given its universal,
    flexible, and easy-to-use structure for data representation. RESTful API services
    that adhere to HTTP standards will represent information available in the form
    of resources. In our hospital management system, a resource can be a *Doctor*
    or *Patient*, and these resources can be interacted with using standard HTTP verbs
    such as `GET`, `POST`, `PUT`, or `DELETE`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法来发起API调用，其中HTTP是最受欢迎的。大多数语言和框架都支持HTTP调用，C#和.NET也不例外。HTTP的一些优势体现在标准化的报告方法；能够缓存响应或使用代理；标准的请求和响应结构；以及响应负载的标准。HTTP请求的负载通常在JSON格式。虽然可以使用其他格式，但由于其通用、灵活且易于使用的数据表示结构，JSON已成为HTTP负载的事实标准。遵循HTTP标准的RESTful
    API服务将以资源的形式表示可用信息。在我们的医院管理系统中，资源可以是**医生**或**病人**，这些资源可以通过使用标准的HTTP动词（如`GET`、`POST`、`PUT`或`DELETE`）进行交互。
- en: Now that we can visualize how synchronous HTTP communication happens in a microservice,
    let us take a look at some coding techniques that we can use in .NET to facilitate
    communication.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以可视化微服务中同步HTTP通信的过程，让我们来看看在.NET中可以使用的编码技巧，以促进通信。
- en: Implementing HTTP synchronous communication
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现HTTP同步通信
- en: In this section, we will be looking at some code examples of HTTP communication
    for when we want to call an API in a .NET application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些示例代码，展示如何在.NET应用程序中调用API时进行HTTP通信。
- en: The current standard for HTTP-based API communication is **REST** (**Representational
    State Transfer**). RESTful APIs expose a set of methods that allow us to access
    underlying functionality via standard HTTP calls. Typically, a call or *request*
    consists of a URL or endpoint, a verb or method, and some data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**URL or endpoint**: The URL of the request is the address or the API and the
    resource that you are trying to interact with.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` (to retrieve data), `POST` (to create a record), `PUT` (to update data),
    and `DELETE` (to delete data).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` request to the booking microservice would need to have the details of
    the booking that needs to be created.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next major part of this conversation comes in the form of a response or
    HTTP status code. HTTP defines standard status codes that we use to interpret
    the success or failure of our request. The categories of status codes are listed
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx (Informational)**: This communicates protocol-level information.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2xx (Success)**: This indicates that the request was accepted, and no errors
    occurred during processing.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3xx (Redirection)**: This indicates that an alternative route needs to be
    taken in order to complete the original request.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4xx (Client Error)**: This is the general range for errors that arise from
    the request, such as poorly formed data (400) or a bad address (404).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5xx (Server Error)**: These are errors that indicate that the server failed
    to complete the task for some unforeseen reason. When constructing our services,
    it is important that we properly document how requests should be formed, as well
    as ensure that our responses are in keeping with the actual outcomes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `appsettings.json`, and then we can have a class of constants, where we define
    the behaviors or resources for the service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `appsettings.json` file would be decorated with the following block, which
    allows us to access the service address values from anywhere in our app:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The values per service configuration will be relative to the published address
    of the corresponding web service. This could be a localhost address for development,
    a published address on a server, or a container instance. We will use that base
    address along with our endpoint, which we can define in our static class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have consistency in our code, we can implement baseline code for
    making and handling HTTP requests and responses. By making the code generic, we
    pass in our expected class type, the URL, and whatever additional data might be
    needed. This code looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The HttpClient class can be injected into any class and used on the fly, in
    any ASP.NET Core application. We create a generic HTTP API client factory class
    as a wrapper around the `HttpClient` class in order to standardize all RESTful
    API calls that will originate from the application or microservice. Any microservice
    that will need to facilitate RESTful communication with another service, can implement
    this code and use it accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of how we handle calls through HTTP methods, we can
    review how we set up gRPC communication between our services.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何通过HTTP方法处理调用有了概念，我们可以回顾一下我们如何在服务之间设置gRPC通信。
- en: Implementing gRPC synchronous communication
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现gRPC同步通信
- en: At this point, we should be comfortable with REST and the HTTP methods of communicating
    with and between our microservices. Now, we will pivot into exploring gRPC in
    a bit more detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该对REST以及与我们的微服务进行和之间通信的HTTP方法感到舒适。现在，我们将转向更详细地探索gRPC。
- en: RPC is short for **Remote Procedure Call**, and it allows us to call another
    service in a manner that resembles making a method call in code. For this reason,
    using gRPC in a distributed system works well. Communications can happen much
    quicker, and the entire framework is lightweight and performant from the jump.
    This is not to say that we should wholly swap all REST methods for gRPC. We know
    by now that we simply choose the best tool for our context and make it work accordingly,
    but it is good to know that gRPC is best used for scenarios where efficiency is
    paramount.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RPC代表**远程过程调用**，它允许我们以类似于在代码中调用方法的方式调用另一个服务。因此，在分布式系统中使用gRPC效果很好。通信可以更快地发生，整个框架从一开始就轻量级且性能出色。这并不是说我们应该完全用gRPC替换所有REST方法。我们现在知道我们只是选择最适合我们情况的工具并相应地使其工作，但了解gRPC在效率至关重要的场景中是最佳选择是很好的。
- en: Indeed, gRPC is fully supported by ASP.NET Core, and this makes it a great candidate
    for use in our .NET Core-based microservices solution. Given its contract-based
    nature, it naturally enforces certain standards and expectations that we try to
    emulate when creating our own REST API service classes with interfaces. It starts
    with a file called a **proto**, which is the contract file. This contract outlines
    the properties and behaviors that are available and is exposed by the server (or
    broadcasting microservice).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，gRPC完全由ASP.NET Core支持，这使得它成为我们.NET Core基于的微服务解决方案的一个很好的候选者。鉴于其基于合同的本质，它自然地强制执行某些标准和期望，我们在创建自己的REST
    API服务类时尝试模仿这些标准和期望。它从一个名为**proto**的文件开始，这是一个合同文件。这个合同概述了服务器（或广播微服务）提供的属性和行为。
- en: 'The code snippets are as follows (parts have been omitted for brevity):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些代码片段（为了简洁起见，部分内容已被省略）：
- en: // Protos/document-search-service.proto
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: // Protos/document-search-service.proto
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `proto` class defines some methods that we want to allow for the document
    management service. We have defined a method to retrieve all documents, and another
    that will retrieve a document based on the provided ID value. Now that we have
    our `proto` defined, we will need to implement our methods in an actual service
    class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`proto`类定义了一些我们希望允许文档管理服务的方法。我们定义了一个检索所有文档的方法，以及一个基于提供的ID值检索文档的方法。现在我们已经定义了`proto`，我们将在实际的服务类中实现我们的方法：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In each method, we can carry out the actions needed to complete the operation,
    which, in this context, will be our database query and potential data transformation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法中，我们可以执行完成操作所需的操作，在这个上下文中，这将是我们数据库查询和潜在的数据转换。
- en: 'Next, we need to ensure that the calling service has a representation of the
    contract and that it knows how to make the calls. The following is a sample of
    how we would connect to the gRPC service at its address, create a client, and
    make a request for information:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保调用服务有一个合同表示，并且知道如何进行调用。以下是我们如何连接到gRPC服务地址、创建客户端以及请求信息的示例：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have seen some code examples of gRPC, let us look at a head-to-head
    comparison of HTTP REST and gRPC.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些gRPC的代码示例，让我们来比较一下HTTP REST和gRPC的面对面比较。
- en: HTTP versus gRPC communication
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP与gRPC通信对比
- en: We have seen examples of how we can interact with our services via the HTTP
    or RESTful methods and the gRPC protocol. Now, we need to have a clearer picture
    of when we would choose one method over the other.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过HTTP或RESTful方法和gRPC协议与我们的服务进行交互的示例。现在，我们需要更清楚地了解在什么情况下我们会选择一种方法而不是另一种方法。
- en: 'The benefits of using REST include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST的好处包括以下内容：
- en: '**Uniformity**: REST provides a uniform and standard interface for exposing
    functionality to subscribers.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：REST提供了一个统一和标准的接口，用于向订阅者公开功能。'
- en: '**Client-server independence**: There is clear independence between the client
    and the server applications. The client only interacts with URIs that have been
    exposed or are needed for functionality. The server is oblivious to which clients
    might be subscribing.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器独立性**：客户端和服务器应用程序之间存在明显的独立性。客户端仅与已公开或为功能所需的服务器URI进行交互。服务器对可能订阅的客户端一无所知。'
- en: '**Stateless**: The server does not retain information about the requests being
    made. It just gets a request and produces a response.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：服务器不保留有关正在进行的请求的信息。它只是接收请求并生成响应。'
- en: '**Cacheable**: API resources can be cached to allow for faster storage and
    retrieval of information per request.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：API资源可以被缓存，以便允许按请求更快地存储和检索信息。'
- en: 'Note that gRPC does have its merits as to why it is being touted as a viable
    alternative to REST communication. Some of these merits include the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，gRPC确实有其优点，这就是为什么它被吹捧为REST通信的可行替代品。以下是一些优点：
- en: '**Protocol buffers**: Protocol buffers (or protobufs for short) serialize and
    deserialize data as binary, leading to higher data transmission speeds and smaller
    message sizes, given the much higher compression rate.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议缓冲区**：协议缓冲区（或简称为protobuf）以二进制形式序列化和反序列化数据，由于压缩率更高，因此导致数据传输速度更快，消息大小更小。'
- en: '**HTTP2**: HTTP2, unlike HTTP 1.1, supports the expected request-response flow,
    as well as bidirectional communication. So, if a service receives multiple requests
    from multiple clients, it can achieve multiplexing by serving many requests and
    responses simultaneously.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP2**：与HTTP 1.1不同，HTTP2支持预期的请求-响应流，以及双向通信。因此，如果一个服务从多个客户端接收多个请求，它可以通过同时处理多个请求和响应来实现多路复用。'
- en: You can see the obvious and not-so-obvious advantages of using either method
    for web service creation and communication. Some developers have deemed gRPC the
    future, given its lighter weight and more efficient nature. However, REST APIs
    remain far more popular, are easier to implement, and have more third-party tool
    support for code generation and documentation. Most microservice architecture-based
    projects are built using REST APIs, and quite frankly, unless you have specific
    requirements that lead to a gRPC implementation, it might be a risk to adopt gRPC
    at a larger scale at this stage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到使用任何一种方法进行网络服务创建和通信的明显和非明显的优势。一些开发者认为gRPC是未来，鉴于其轻量级和更高效的特点。然而，REST API仍然更为流行，更容易实现，并且有更多的第三方工具支持代码生成和文档。大多数基于微服务架构的项目都是使用REST
    API构建的，坦白说，除非你有特定的需求导致采用gRPC实现，否则在这个阶段大规模采用gRPC可能是一种风险。
- en: Given that we have explored so much about synchronous communication and the
    most common methods that are used to facilitate it, let us look at some of the
    disadvantages that surround having our microservices talk to each other.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了关于同步通信及其最常用的促进方法，让我们来看看围绕我们的微服务之间进行同步通信的一些不利因素。
- en: Disadvantages of synchronous communication between microservices
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间同步通信的不利因素
- en: While it is the go-to method for service-to-service communication, it might
    not always be the best option at that moment. Most cases might even prove that
    it is not the best idea to begin with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它是服务间通信的首选方法，但并不总是那个时刻的最佳选择。大多数情况甚至可能证明，一开始就选择这种方法并不是最好的主意。
- en: Do remember that our users will be waiting on the result of a service-to-service
    call to manifest itself to them on the user interface. That means, for however
    long this communication is occurring, we have a user or users sitting and waiting
    on the interface to continue loading and furnish a result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的用户将等待服务间调用的结果在用户界面上显现出来。这意味着，无论这种通信持续多长时间，我们都有用户或用户坐在界面上等待，以便继续加载并提供结果。
- en: From an architectural point of view, we are violating one of the key principles
    of microservice design, which is having services that stand on their own, without
    knowing much, or preferably, anything, about each other. By having two services
    speak, there is knowledge about another service and implementation details being
    defined, which have very little to do with the service’s core functionality. Also,
    this introduces an undesirable level of tight coupling between services, which
    increases exponentially for each service that needs to speak to another service.
    Now a change to one service can have undesired functionality and maintenance effects
    on the others.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we end up with a chain of service calls, this will make it more
    difficult to track and catch any errors that occur along the calls. Imagine that
    we implement a form of *Chain of Responsibility* with our service calls where
    one service calls another, and the result is used to call another, and so on.
    If we have three service calls happening back-to-back and the first one fails,
    we will get back an error and won't be able to determine at which point this error
    occurred. Another issue could be that we had successful calls, and the first error
    breaks the chain, thus wasting the usefulness of what has transpired in the chain
    before that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: It is always good to understand the pros and cons of the techniques that we
    employ. I do agree that synchronous communication is sometimes necessary, but
    we must also be aware of the additional development effort, in both the short
    and long term, that will be needed as a result of its employment. At this point,
    we begin to think of alternatives such as asynchronous communication and event-driven
    programming.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored quite a few things. We sought to understand what
    synchronous communication between web resources is, the protocols that are most
    commonly used, and the potential pros and cons of these techniques. We looked,
    in detail, at how HTTP communication occurs and can be implemented using C# and
    compared that with gRPC techniques. Additionally, we compared the two to ensure
    that we know when the best time would be to use either.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore asynchronous communication between services,
    the best practices, and what problems could be solved through this service-to-service
    communication method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
