- en: Implementing the Domain Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on the logic layer of the catalog web service. As previously
    discussed, the logic will be encapsulated in the `Catalog.Domain` project. The
    chapter shows how to implement the application logic using the service classes
    approach. The aim of these classes is to perform the mapping logic between the
    requests and the effective entities used on the data source layer and to provide
    all the additional logic needed by our application. Moreover, we will also see
    how to test the implemented code in order to verify the behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement the service classes for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement request DTOs and the related validation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply tests to verify the implemented logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in the following chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's proceed with the concrete part of the chapter by implementing the service
    classes. This layer of abstraction will define the methods that query the data
    layer, including the `IItemRepository` interface, and map the resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, our service implementation will use DTO classes in
    order to pass the data through the stack. First of all, let''s define the request
    classes needed by our service. To do that, we can start by creating a new `Requests/Item`
    folder structure in the `Catalog.Domain` project, and by adding a new `AddItemRequest.cs`
    file in the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the add item request. The class is very similar to
    the `Item` entity class, except that the `Id` field, the `Artist` field, and the
    `Genre` field are not present. Furthermore, the `Id` field will be generated by
    the EF Core implementation, and the `Artist` and `Genre` fields are handled by
    the ORM in order to represent the relationship between the entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we can proceed by defining the `EditItemRequest` class in
    the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in the preceding snippet, the class contains the same fields used by the
    `Item` entity, except for the `Artist` and `Genre` fields, for the same reason
    described earlier. As you can understand from the class name, it represents the
    update item operation. The same approach can be taken for the get item operation
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It may seem a little bit redundant, defining a request class for a single field.
    Despite that, we should consider that the HTTP requests received by our service
    may vary over time. Therefore, this approach guarantees us being able to evolve
    our requests without adding tons of parameters to the methods of the service class.
    On top of that, representing our incoming requests as classes provides an easy
    way to version the different request types evolving over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by also defining the response classes used by our service classes.
    Also, in the case of the response classes, it is essential to understand that
    this approach guarantees us a way to avoid exposing all the fields to the client
    of our web service. As a first step, we need to define a new `Responses` folder
    in the `Catalog.Domain` project, and create the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For brevity, I''ve defined the implementation of the `PriceResponse`, `GenreResponse`,
    and `ArtistResponse` classes in a unique snippet of code. Those classes define
    the field used by the same entity classes we use on the database side. On top
    of that, we will also define an `ItemReposonse` class, which represents the response
    of our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemResponse` class refers to the other response classes in order to avoid
    a mismatch between the response data contained in the related entities. Furthermore,
    the `IItemRepository` implementation will load all the data of the related entities
    using the `Include` extension method we looked at in the previous chapter, and,
    as we will see later, the data will be mapped into the response types.
  prefs: []
  type: TYPE_NORMAL
- en: The service class interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have defined all the requests and response types needed by our service,
    we are now able to proceed by defining the `IItemService` interface and its implementation.
    As a first step, we can create a new `Services` folder in the `Catalog.Domain`
    project and proceed by defining the following `IItemService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding definition exposes the methods needed by our application. First
    of all, we should notice that all the functions return a `Task<T>` generic type.
    We can also see that all the methods end with the `Async` prefix, which suggests
    that the implementation will be asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the mapping layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection and the following one describe the implementation of two mapping
    approaches we can use in our application: the *manual approach* and the *reflection
    approach*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *manual approach* involves the definition and implementation of our own
    mapper classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines an `IItemMapper` interface, which provides two methods
    to map `AddItemRequest` and `EditItemRequest` in the `Item` type. In addition,
    it also defines the mapping method signature to convert an `Item` type into an
    `ItemResponse` instance. This strategy can be implemented with the following `ItemMapper`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Please notice that, for brevity, I''ve omitted all the fields of the entity
    defined in the mapping, you can find the full mapper class file in the following
    repository [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog).
    Both the `IItemMapper` interface and the `ItemMapper` class are located in a `Mappers`
    folder in the `Catalog.Domain` project. The `ItemMapper` implementation requires
    a bit of overhead in terms of development, but it performs exactly what you need
    without any runtime costs, such as reflection. On top of that, the logic is encapsulated
    in separate classes. The same approach can be applied to the `ItemResponse` mapping
    â€“ in this case, we will also need to create some isolated mappers for the `Artist`
    and the `Genre` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For brevity reasons, I''ve included the interface and the concrete implementation
    in a unique snippet of code. `IArtistMapper` exposes a method called `Map`, which
    initializes a new `ArtistResponse` given an `Artist` entity class. This approach
    will be the same for the `Genre` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in this case, we define `Genre` as `GenreResponse` mapping. Both these
    mapping classes can be used independently or referred by other mappers. Once we
    have implemented the `Artist` and `Genre` mapping logic, we can refer them into
    `IItemMapper` in order to define the implementation of the `ItemReponse Map(Item
    item)` mapping method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the `ItemMapper` implementation class and we have combined the
    dependencies with the `IArtistMapper` and `IGenreMapper` interfaces. Furthermore,
    we can use the `Map` method we've just defined to create `ItemResponse` instances
    based on the `Item` entities. You may have noticed that I haven't implemented
    the mapping class for `PriceResponse`. This is because an entity such as `Price`
    is unlikely to change. Another crucial part to notice is that we are missing the
    initialization of the dependency injection between the mapper interfaces and their
    implementation; this part will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I want to specify that this is not the only way to implement the mapping
    layer in our application. In fact, there are also other patterns, for example,
    using extension methods. Let''s take as an example, `Artist` to `ArtistResponse`
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a new `MappingExtensions` static class, which can
    be used as a container for all the extension methods we need for the mapping logic.
    Furthermore, it is possible to define a `MapToResponse` extension method that
    can be applied to the `Artist` entity in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The extension methods approach can be applied to all the entities of the domain
    model. Although it seems a lot more immediate, it doesn't highlight the dependency
    between the services classes and the mapping logic. Therefore, I prefer implementing
    mapping through the use of separate classes because it provides a better way to
    understand the dependency flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping logic using Automapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An alternative way is to implement the mapping using the `Automapper` NuGet
    package. As mentioned in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, this approach uses the reflection system
    provided by .NET in order to match and to map the fields of our classes. It is
    possible to add the `Automapper` package to the `Catalog.Domain` project using
    the following CLI instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Automapper uses a profile-based structure in order to define the mapping behaviors
    of our classes. Let''s proceed by defining a new `CatalogProfile` class in the
    `Mappers` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding profile will be used by the dependency injection engine to define
    the lists of mapping behaviors. The `CreateMap` method provided by the `Profile`
    base class matches two generic types: `TSource` and `TDestination`. It will be
    possible to also perform the reverse process by chaining the `ReverseMap()` extension
    method. This can be applied for every request and response type we define in the
    application. In order to use the mapping logic in our methods, it is necessary
    to inject the `IMapper` type into the target class and execute the `Map` method
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to notice that the `Map` method will throw a runtime exception
    in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the source and the destination of the mapping don't correspond
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The corresponding source and destination mapping is not explicitly defined in
    a profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some unmapped members in the entities (this prevents accidental `null`
    fields in the destination of the mapping)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Automapper also requires initialization using the dependency injection
    of .NET Core. We will see how to add `Automapper` in the DI engine later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The service class implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the mapper layer is completed, we can proceed by implementing the service
    layer. Let''s start by defining the `ItemService.cs` file in the `Services` folder
    of the `Catalog.Domain` project. The following code describes the implementation
    of the constructor method and the reading operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we can see that the class refers to both the `IItemRepository`
    and the `IItemMapper` interfaces, which are injected using the constructor injection
    technique. The snippet also describes the implementation of the `GetItemsAsync`
    and `GetItemAsync` functions. Both methods use the `IItemRepository` interface
    to retrieve data from the data source, and the `IItemMapper` interface to perform
    the mapping between the `Item` entity and `ItemResponse`. The same approach can
    be taken by the writing operations, which are implemented with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Also, in the case of the writing operations, they use the `IItemMapper` instance
    to map the request's type with the `Item` entity type and to retrieve the `ItemResponse`
    type. In addition, they perform the operations by calling the `IItemRepository`
    instance, and subsequently, they call the `SaveChangesAsync` method to apply those
    changes to the database. Once we have implemented the service layer, we can proceed
    by testing the class and verifying the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the testing of the service layer part implemented previously.
    As we did in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building
    the Data Access Layer*, we need to set up a mock catalog context that provides
    the data necessary for testing the service classes. The `Catalog.Infrastructure`
    project already has its own implementation of the `TestCatalogContext` class and
    the `ModelBuilderExtensions` class. Furthermore, we can use the same two classes
    to implement the tests for the service layer. What we need is just a bit of refactoring
    and optimization on the `Catalog.Infrastructure` project.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring testing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After implementing the `ItemsRepositoryTests` type, in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, you might notice that we are using a recurring
    pattern in the `ItemRepositoryTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet has been replicated in every test method written up to
    now. It is possible to improve our test code by extracting the implementation
    in a different type. The `xunit` framework provides a way to share test contexts
    between test methods of the same test class by providing an interface called `IClassFixture`.
  prefs: []
  type: TYPE_NORMAL
- en: '`IClassFixture` is a generic type that constitutes a single test context and
    shares it among all the test methods in the class. Hence, the `xunit` framework
    cleans up the fixture after all the tests in the class have completed. The `IClassFixture`
    interface we are going to implement will be used by both the `Catalog.Infrastructure.Tests`
    project and the `Catalog.Domain.Tests` project. Therefore, we can commonize the
    implementation in a unique `Catalog.Fixtures` project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by creating the new project in the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding instructions create a new `Catalog.Fixtures` project and add
    it to the solution. After that, we can proceed by adding the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can move all the classes previously implemented in the `Catalog.Infrastructure.Tests`
    project into the new `Catalog.Fixtures` project just created: `TestCatalogContext.cs`,
    `Extensions/ModelBuilderExtensions.cs`, and all `.json` files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by creating a new `CatalogContextFactory` class, which will
    be referred by the `IClassFixture` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `CatalogContextFactory` class defines a new instance of `TestCatalogContext`
    using the previously assigned `contextOptions` object. It is necessary to notice
    that we are building `ContextOptions` using `Guid.NewGuid().ToString()` property
    as a database name in order to provide a new, clean in-memory instance for each
    test class. In addition, the class also initializes the three attributes of type
    `IGenreMapper`, `IArtistMapper`, and `IItemMapper` which will be used by the service
    layer tests in order to perform the mapping of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, therefore, possible to access the instance of the factory class in our
    tests by using the following constructor injection approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `IClassFixture` interface contains the reference to the factory class just
    created. The dependency will be resolved at runtime through the constructor of
    the test class. Note that the entire instance is shared between each unique test
    class. Therefore, each test method in the test class will share the same database
    snapshot with the other method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can refactor the `ItemRepositoryTests` class in order to use the
    new `CatalogContextFactory` implementation. For example, if we take as reference
    the `should_add_new_item` test method, we can proceed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `_sut` class attribute is used to perform the actual operation we want to
    test. For example, in the test case above, we are verifying the `Add` method exposed
    by the `ItemRepository` class. The `_context` attribute is used to verify the
    result. This approach guarantees the reusability of our test code between the
    different test classes by providing the tests with better maintainability. All
    the data is provided by the `CatalogContextFactory` type, which uses the in-memory
    database technique provided by ASP.NET Core to store data in memory and simulates
    the data operation on a real database.
  prefs: []
  type: TYPE_NORMAL
- en: As we did for the `ItemRepositoryTests` class, we will also see how to use the
    `CatalogContextFactory` class in the service layer tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this section is available in the following GitHub repository: [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ItemService tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue by implementing the `ItemService` test part. As a first step,
    we should proceed by creating a new `Catalog.Domain.Tests` project in the `tests`
    folder using the following CLI instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates a new `Catalog.Domain.Tests` project in the `tests`
    folder. Therefore, we can proceed by adding the new project to the solution using
    the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the test project has some dependencies. Furthermore, we can proceed
    by adding the reference using the following command to the `Catalog.Domain.Tests`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we create a new `ItemServiceTests.cs` file with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code tests the implementation of the reading operations of the
    `ItemService` class. The `ItemServiceTests` class uses the `CatalogContextFactory`
    type to initialize and get the base data used by the service. Each test method
    uses the `_itemRepository` class property and the `_mapper` instance to initialize
    a new `ItemService` and verify the `GetItemAsync` and the `GetItemsAsync` methods
    provided by the service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we can use the same technique to implement the writing operation
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `additem_should_add_the_entity` and `edititem_should_edit_the_entity` methods
    are verifying both the `IItemMapper` logic implementation and also the `IItemService`
    implementation. This approach can be used to test the logic of the service classes
    layer. In this case, the mapping logic is not so complex. Besides, I suggest also
    implementing separate tests in the case of a more complex mapping logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run the test cases we''ve just implemented by executing the
    `dotnet test` CLI instruction in the solution folder, or by using our preferred
    IDE test runner. The CLI result should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43a9d778-e29d-47e7-92c4-d90d8836bdde.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding report lists all the tests executed by the `dotnet test` command,
    and it provides an overview of the successful and failed tests. Furthermore, it
    is also possible to specify the verbosity of the test by appending the `-v` option
    next to the `dotnet test -v <q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]>`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing request model validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Catalog.Domain` project also owns the validation logic of our request models*.*
    In this section, we will see how to implement the request validation logic part,
    which will be also used by our controllers in order to validate the incoming data.
    Here, I usually rely on the `FluentValidation` package, which provides a really
    readable way to perform validation checks on every type of object and data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add the `FluentValidation` package to our `Catalog.Domain` project,
    we can execute the following commands in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FluentValidation` package exposes the `AbstractValidation` class, which
    can be extended to implement our custom validation criteria for a request model
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These validator classes are located in the `Requests/Item/Validators` path.
    Let''s proceed by analyzing some of the validation criteria implemented in the
    `AddItemRequestValidator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GenreId` and `ArtistId` fields are required because a vinyl always has
    this kind of information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class uses the same `NotEmpty` method on the `Name`, `ReleaseDate`, and
    `Price` fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Amount` field of the `Price` class should always be greater than 0\. The
    validator class uses the `Must` method to apply this rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same approach is taken for the `EditItemRequestValidator` class, except
    for the `Id` field, which is defined as required for the updated process of an
    entity. The fluent way of working is really useful for different reasons: it is
    ready to read, easy to maintain, and really helpful when we want to test logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing request model validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, the `FluentValidation` package provides an excellent way to test
    our validation criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddItemRequestValidator` and `EditItemRequestValidator` classes implement
    elementary checks. Furthermore, it may be useful to cover them with some tests
    to document the logic implemented in these classes. `FluentValidation` provides
    a `TestHelper` class that provides the assertion conditions necessary to verify
    the behavior of our validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to do some unit tests for the `AddItemRequestValidator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The test class defined in the preceding code verifies that `AddItemRequestValidator`
    triggers a validation error if the `GenreId` or `ArtistId` fields are null. It
    uses the `ShouldHaveValidationErrorFor` extension method exposed by the `TestHelper`
    class to verify the behavior. The `ShouldHaveValidationErrorFor` method also exposes
    an `IEnumerable` of `ValidationError`, which can be used to check the details
    of each message of type `ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen how to implement mapper classes, validators,
    and service classes. All these types work together using the dependency injection
    of .NET Core. Dependency registration usually happens through the use of extension
    methods that group the registered classes by following some criteria. In this
    case, I will group the registered classes in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Services refer to all the service interfaces and classes defined in the `Catalog.Domain`
    project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mappers refer to all the mapper classes defined in the `Catalog.Domain` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validations refer to all the fluent validation requirements and dependencies
    used by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined the logic behind the separation of dependency registration,
    we can proceed by defining a new `DependencyRegistration` static class in the
    `Extensions` folder in the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines three extension methods, one for each group: `AddMappers`,
    `AddServices`, and `AddValidation`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AddMappers` extension method registers the mapper instances using a *singleton*
    life cycle, therefore, the mappers do not have any kind of dependency and they
    don't perform any request-related operation. On the other side, the `AddServices`
    extension method uses a scoped life cycle because the service classes depend on
    the repositories that perform I/O operations on the database. Finally, the `AddValidation`
    extension method is chained with `IMvcBuilder` and is strictly dependent on the
    MVC stack.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it uses the `AddFluentValidation` method provided by the `FluentValidation`
    package in order to register all the validation classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, we can register the dependencies of our application in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we can now verify the implementations written during this chapter by
    again running a `dotnet test` command in the solution folder, or by executing
    the test runner of our preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Catalog.Domain` project now contains the core logic of the entire application.
    Although the logic implemented in the `Domain` project is still quite simple,
    later on in this book, it will become more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter included some of the concepts related to
    the domain logic implementation of a web service: how to implement the service
    and the mapping classes, how to implement the request validation process using
    a fluent approach, and finally, how to test our code using some unit testing techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look into all the HTTP parts of the application. Furthermore,
    we will focus on the `Catalog.API` project, and how to put together the data access,
    the service, and the API layers.
  prefs: []
  type: TYPE_NORMAL
