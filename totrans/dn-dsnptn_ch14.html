<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>14. A Road Ahead</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;14.&#160;A Road Ahead">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch14"></a>Chapter&#160;14.&#160;A Road Ahead</h1>
            </div>
          </div>
        </div>
        <p>It has been a whirlwind journey on various topics through our book. If you have reached this point, you might have come across some new concepts, or might have had a fresh look at some things that you already knew. Broadly speaking, the theme of this book can be divided into the following four sections:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Putting patterns into perspective (Chapter 1 and 2)</li>
            <li class="listitem" style="list-style-type: disc">GoF in action (Chapter 3 through 7)</li>
            <li class="listitem" style="list-style-type: disc">Object/functional programming (Chapter 8 to 10)</li>
            <li class="listitem" style="list-style-type: disc">(Functional) reactive programming (Chapter 11, 12, and 13)</li>
          </ul>
        </div>
        <p>Patterns are an interesting topic, and they have helped software developers to address complex business problems by providing proven and time-tested solutions. It has also improved communication between developers and their stakeholders. By learning patterns, as a developer, you get distilled knowledge and experience of those master programmers who cataloged these patterns. But there are some more topics that you should know in your journey as a developer or an architect. The authors of this book consider the following four topics of great interest to a professional (as a continuation of the topics covered in this book):</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Polyglot programming and design (multi paradigm programming)</li>
            <li class="listitem" style="list-style-type: disc">Domain-specific languages</li>
            <li class="listitem" style="list-style-type: disc">Ontology</li>
            <li class="listitem" style="list-style-type: disc">AntiPatterns</li>
          </ul>
        </div>
        <div class="section" title="Polyglot programming and design">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch14lvl1sec98"></a>Polyglot programming and design</h1>
              </div>
            </div>
          </div>
          <p>Modern applications are complex to develop as they might have the following:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Service layer with a database for persistence ( SQL or NoSQL)</li>
              <li class="listitem" style="list-style-type: disc">The UI code has to be responsive and calibrated for different form factor devices</li>
              <li class="listitem" style="list-style-type: disc">The frontend code is mostly based on some kind of <span class="strong"><strong>Single Page Architecture</strong></span> (<span class="strong"><strong>SPA</strong></span>) architecture</li>
              <li class="listitem" style="list-style-type: disc">In some cases, there can be desktop and mobile native frontends</li>
            </ul>
          </div>
          <p>A developer who has been hired for such a project should have the following skills:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Java, C#, PHP, Ruby, or Grails for writing service layers (skills in one or more)</li>
              <li class="listitem" style="list-style-type: disc">For writing UI code, they&#160;should be familiar with CSS libraries and JavaScript (e.JQuery)</li>
              <li class="listitem" style="list-style-type: disc">For web-based responsive frontend, TypeScript/JavaScript using Angular, ReactJs, or any other JavaScript-based framework</li>
              <li class="listitem" style="list-style-type: disc">For writing desktop applications, the choices are C#, C++, Objective C/C++, Python, or Java</li>
              <li class="listitem" style="list-style-type: disc">For mobile application development (native), choices are C#, Java, or Objective C/Swift</li>
            </ul>
          </div>
          <p>The bottom line here is that one should be comfortable with at least more than half a dozen programming languages to be in a position to work with modern projects. If you add skills in PowerShell, Bash shell, JSP/HTML/template engines, XML, JSON, and so on, we are indeed living in a world where a person has to be really conversant in as many languages as possible.</p>
          <p>Let us trace the evolution of this state of affairs by quickly chronicling the history of development under the PC platform. The programming landscape has changed quite a lot in the last decade. When the GoF pattern book was written, programming languages such as Java and C# had not been born. The dominant object-oriented programming language in those days, for all practical purpose was C++. Even for C++, the ANSI standards were not ratified (it happened only in 1998). Other than C++, languages such as Delphi (Object Pascal),Visual Basic, PowerBuilder, and various xBase dialects (Clipper, FoxPro, and the like) were widely used by programmers of that era. Platforms such as Microsoft Windows were just evolving. Various flavors of UNIX and MS-DOS were the primary platforms (even GNU Linux had not reached a critical mass in those times!).</p>
          <p>Even in the early years of programming, it was realized that one cannot build solutions using a single programing language. We need to mix and match programming languages that are apt for the context. At one point in time, most numerical libraries were written in Fortran, and those libraries were interfaced with the C language for writing systems, which are numerically intensive. In the early years of programming, people used to write code in a high-level language, and interface their code with routines written in C and assembler. Thus, a programmer needs to know a high-level language, C programing language, and the syntax of the assembly language of the environment in which the program was developed and deployed. The process of developing a large system using different programming languages for writing different subsystems and composing them to create a larger system is called polyglot programming. Designing such systems, where there is a multitude of programming languages and technology stacks, is called polyglot design. To design such a system, developers should be able to think in a language-and-platform-agnostic manner.</p>
          <p>The movement towards polyglot programming started in the early years of programming on the IBM PC platform. Polyglot programming was mostly an affair of interfacing routines written in the C programming language to a high-level language chosen for writing the system.</p>
          <div class="section" title="Polyglot programming with C/C++">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a id="ch14lvl2sec65"></a>Polyglot programming with C/C++</h2>
                </div>
              </div>
            </div>
            <p>When people programmed in various languages other than C/C++, there were options available for interfacing with C/C++, code packaged as DLLs or <code class="literal">.so</code> in Windows and Unix/Linux, respectively. In MS-DOS, all xBase languages offered an interface mechanism to interact with the native code written in C/C++ and Assembler/. In the Microsoft Windows platform, Visual Basic offered a mechanism to call routines written in C/C++/. Using this mechanism, people consumed a vast amount of Windows API functions provided by Microsoft. People began to program Windows using Visual Basic and Visual C++. The visual development environments such as Delphi and PowerBuilder also provided similar mechanisms to consume code written in C/C++. This can be considered as the beginning of programming systems using multiple languages, and is nowadays called Polyglot programming.</p>
            <p>With the advent of the Java programming language, the promise of platform-neutral programming became a buzzword in the Industry. The <span class="strong"><strong>write once, run everywhere</strong></span> (<span class="strong"><strong>WORE</strong></span>) mantra came to the fore, and it did not prevent the implementers of Java to give a mechanism to interact with native code written in C/C++. The interface was called <span class="strong"><strong>Java Native Interface</strong></span> (<span class="strong"><strong>JNI</strong></span>). Using this mechanism, people wrote wrappers around technologies such as Direct3D and OpenGL to create libraries like Java 3D. The popular computer vision system, OpenCV, is interfaced with Java software using JNI.</p>
            <p>The .NET platform was unveiled in the year 2001, and it gave two interfaces to interface with the native code. The first one was PInvoke, a mechanism to interface with Win2/Win64 calls exported out of DLLs. Microsoft also gave a mechanism to call C++-based COM components called COM interoperability. They named it COM callable wrapper. To demonstrate the use of P/Invoke, here is a small C/C++ code snippet (compiled into a DLL) interfaced with C# code:</p>
            <pre class="programlisting">    #include &lt;stdio.h&gt; 
    #include &lt;cstring&gt; 
    #include &lt;Windows.h&gt; 
 
    using namespace std; 
    //A C/C++ Windows DLL which exports a Function 
    //ListOfSquares to be consumed from C# programming 
    //language. The DLL is compiled using Minimalist 
    //GNU for Windows (MINGW),which is freely downloadable 
    // 
    //Compile and Link 
    //---------------- 
    //  gcc -c -o add_basic.o cpp_code.cpp 
    //  gcc -o add_basic.dll -s -shared add_basic.o -Wl, 
    //  --subsystem,windows 
    // 
 
    extern "C" __declspec(dllexport) void __stdcall 
    ListOfSquares( 
      long (__stdcall  *square_callback) (int rs) ) 
 
    { 
      for (int i = 0; i&lt;10; ++i) {  
        //---- Call the C# routine which handles the  
        //---- integer and returns square.  
        //---- This is a blocking call! 
 
        double ret = (*square_callback)(i); 
        printf("Printing from C/C++ ... %g\n", ret); 
      } 
    } 
</pre>
            <p>We can compile the preceding code using the Visual C++ compiler or MinGW compiler (GCC under Windows ) to create a DLL. We have used the MinGW 32-bit compiler to generate the Win32 DLL. The DLL can be interfaced with C# code written using Visual Studio or Mono compiler under Windows. If you know how to build a shared library (<code class="literal">.so</code>) under Mac OS X or GNU Linux, we can run the code on those platforms as well. The C# code can be used to invoke the DLL written previously:</p>
            <pre class="programlisting">    using System; 
    using System.Collections.Generic; 
    using System.Linq; 
    using System.Runtime.InteropServices; 
    using System.Text; 
    using System.Threading.Tasks; 
 
    namespace entrypoint 
    { 
      class Program 
      { 
        //--- Now you know, a C/C++ Function Pointer 
        //--- is indeed a delegate! 
        public delegate long CallBack(int i); 
        //--- Declare the Function Prototype of the Function 
        //--- We are planning to call from C/C++ 
        [DllImport("D:\\DLL_FOR_DEMO\\add_basic.dll")] 
        private static extern long ListOfSquares(CallBack a); 
 
        public static long SpitConsole(int i) 
        { 
          Console.WriteLine("Printing from C# {0}", i * i); 
          return i * i; 
        } 
 
        static void Main(string[] args) 
        { 
          ///////////////////////////// 
          // CallBack Demo 
          // Will print Square from C# and C++ 
          ListOfSquares(SpitConsole); 
        } 
      } 
    } 
</pre>
          </div>
          <div class="section" title="The polyglot web programming">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a id="ch14lvl2sec66"></a>The polyglot web programming</h2>
                </div>
              </div>
            </div>
            <p>The <span class="strong"><strong>World Wide Web</strong></span> (<span class="strong"><strong>WWW</strong></span>) reached critical mass roughly in the year 1995, and the programming landscape changed all of a sudden. People who learned to program desktop systems using Windows API and X/Windows API found themselves in a position of great difficulty, forced to grapple with the complexities of the <span class="strong"><strong>Common Gateway Interface</strong></span> (<span class="strong"><strong>CGI</strong></span>), NSAPI, and ISAPI programming model to generate dynamic web pages. The languages of choice were Perl and TCL for CGI, and C/C++ for NSAPI/ISAPI.</p>
            <p>The situation continued for some time, and it all changed all of a sudden when Microsoft brought out <span class="strong"><strong>Active Server Pages</strong></span> (<span class="strong"><strong>ASP</strong></span>) for creating dynamic web pages. Soon, Sun Microsystems came up with Java Servlet API. The Servlet API was a low-level API like C++-based ISAPI, and Sun soon brought out <span class="strong"><strong>JavaServer Pages</strong></span> (<span class="strong"><strong>JSP</strong></span>), a technology that embedded Java code inside markups. The JSPs were converted to Servlet code on the fly using the Java Compiler system available on the executing machine. There were technologies such as ColdFusion, which leveraged custom markups to write extensible applications, and had the capacity to interact with code written in Java. The Web programming model mandated people to learn C++, Java, Visual Basic, and ASP to write dynamic web pages. On the Microsoft platform, people began to write VBScript code interspersed with calls to COM/ActiveX objects written in C++ and Visual Basic. In fact, the emergence of web-based application delivery forced programmers to become a true polyglot.</p>
            <div class="section" title="The JavaScript evolution">
              <div class="titlepage">
                <div>
                  <div>
                    <h3 class="title"><a id="ch14lvl3sec12"></a>The JavaScript evolution</h3>
                  </div>
                </div>
              </div>
              <p>The emergence of JavaScript was another thing that forced developers to learn yet another language to add a bit of interactivity to their web pages. In those times, people were mostly comfortable with statically typed languages, and found JavaScript to be a weird language. JavaScript remained in relative obscurity for a long time, until someone found out a clever way to mix JavaScript with IE ActiveX plugin. In the early years of the twenty-first century, people began to write user interfaces by embedding browser controls inside a desktop container, and used JavaScript as a glue language to interact with the ActiveX controls embedded in those pages. JavaScript picked up momentum, and people began to consider it as a first class programming language after the advent of Google's V8 engine and the Node.js platform. Another shot in the arm was the support for functional style programming using the JavaScript language, and the emergence of libraries such as JQuery, Angular, ReactJS, and the like. In the last decade, knowledge of the JavaScript programming language became essential for all programmers, whether they wrote server code or client code. JavaScript is another language that programmers were forced to learn.</p>
            </div>
            <div class="section" title="Dynamic/scripting languages">
              <div class="titlepage">
                <div>
                  <div>
                    <h3 class="title"><a id="ch14lvl3sec13"></a>Dynamic/scripting languages</h3>
                  </div>
                </div>
              </div>
              <p>The emergence of Perl, Python, PHP, Ruby, TCL, and Groovy for writing command line, GUI, and web applications forced developers to master some of them in their day-to-day job. PERL is still widely used for writing CGI applications, automation scripts, and even GUI applications (Perl/TK) all across the world. The Python programming language is the de-facto programming language for writing (or at least learning) machine learning programs because of the libraries available in that language, and they are widely used for writing web applications with some MVC frameworks.</p>
              <p>Both Ruby on Rails and Groovy and Grails ushered in a rapid development lifecycle era to make their penetration in the start-up ecosystem. PHP is the most popular web development system in the world, and it is especially suited for writing front-facing applications. The sheer number of content management systems available with the platform is another attraction. Architecting solutions with PHP for front-facing pages, Java for Service logic, and Silverlight for frontend (for interactive parts) became popular in some circles! The popularity of the REST paradigm has made writing the server-side logic to be in whatever language one chooses to. As long as the URI is consistent, the routing system makes sure that it resolves the correct handler logic to get executed.</p>
            </div>
            <div class="section" title="Emergence of functional programming">
              <div class="titlepage">
                <div>
                  <div>
                    <h3 class="title"><a id="ch14lvl3sec14"></a>Emergence of functional programming</h3>
                  </div>
                </div>
              </div>
              <p>As mentioned in the first chapter, Herb Sutter's seminal article titled, <span class="emphasis"><em>The Free Lunch Is Over</em></span>, rekindled interest in functional programming, which was mostly relegated to academic circles. The FP model was well suited for exploiting the many-core processing world. The stateless computation model of the FP helps to scale an application from a single core to dozens of cores without any additional programming effort. The emergence of Scala, F#, Clojure, Haskell (in some niche areas), and so on, and the availability of them in the JVM and CLR world made them a viable choice for writing some applications. In the Microsoft world, people began to write code in C# and F#, to bundle the code inside the same system. Learning a functional language (one or more) became absolutely essential for modern-day programmers. Another excuse to become a polyglot!</p>
            </div>
            <div class="section" title="Mobile revolution">
              <div class="titlepage">
                <div>
                  <div>
                    <h3 class="title"><a id="ch14lvl3sec15"></a>Mobile revolution</h3>
                  </div>
                </div>
              </div>
              <p>Some competence in mobile application development is necessary for every software developer in the world. Apple's iOS, Google's Android, and Microsoft's Windows Phone are the leading platforms in this arena. Unfortunately, native application development languages in these platforms are Objective C/Swift (iOS), Java (Android), and C# (Windows Phone). A .NET developer has to learn Java, Objective C, or Swift to write native applications for these platforms. If you want to avoid this, you might have to use hybrid application development with JavaScript as a programming language. Anyway, you need to be a Polyglot!
</p>
            </div>
          </div>
          <div class="section" title="A quick note on polyglot persistence">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a id="ch14lvl2sec67"></a>A quick note on polyglot persistence</h2>
                </div>
              </div>
            </div>
            <p>For a long time, the <span class="strong"><strong>Relational database management systems</strong></span> (<span class="strong"><strong>RDBMSs</strong></span>) became the backbone of every business application ever developed. The Oracle Server, Microsoft SQL Server, MYSQL, and Postgres systems were the de-facto choice for persisting data. The emergence of the NoSQL movement gave us different types of databases suitable for distributed programs, which should scale well. They are listed as follows:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist">
                <li class="listitem" style="list-style-type: disc">Columnar databases</li>
                <li class="listitem" style="list-style-type: disc">Key/value databases</li>
                <li class="listitem" style="list-style-type: disc">Document databases</li>
                <li class="listitem" style="list-style-type: disc">Graph databases</li>
              </ul>
            </div>
            <p>NoSQL is a vast and varied topic, and the reader is expected to search Google to understand it, as a fair treatment of it warrants many books. So, a modern web-based application might store data in various persistence technologies available, based on the application context. A typical use case could be any one of the following:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist">
                <li class="listitem" style="list-style-type: disc">An RDBMS for storing transactional data</li>
                <li class="listitem" style="list-style-type: disc">A key/value database for storing master data (for faster lookup)</li>
                <li class="listitem" style="list-style-type: disc">A graph database for storing relationship between entities</li>
                <li class="listitem" style="list-style-type: disc">A columnar database for data that is part of analytical queries</li>
              </ul>
            </div>
            <p>By choosing the appropriate backend technologies, the application can ensure throughput and scalability for large-scale applications development. The process of using different persistence technologies in an application is called <span class="strong"><strong>polyglot persistence</strong></span>. A developer should be really familiar with this paradigm along with polyglot programming.</p>
          </div>
          <div class="section" title="How to become a polyglot programmer?">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a id="ch14lvl2sec68"></a>How to become a polyglot programmer?</h2>
                </div>
              </div>
            </div>
            <p>From a programming paradigm perspective, there are only three types of programming languages in this world, which are as follows:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist">
                <li class="listitem" style="list-style-type: disc">Functional languages (based on lambda calculus)</li>
                <li class="listitem" style="list-style-type: disc">Logic languages (based on predicate logic)</li>
                <li class="listitem" style="list-style-type: disc">Imperative languages (based on Turing machines)</li>
              </ul>
            </div>
            <p>To be a contemporary developer, one needs to master a couple of languages from each family. To be competent in FP, the language options available are F#, Clojure, and Scala. The logic programming languages are Prolog and Datalog. Learning them will help on improving design skills, especially in building hierarchical data structures. The type inference algorithm available with F#, Scala, and C# uses the unification algorithm, which forms the backbone of the Prolog language. Thus, understanding the Prolog machine model helps you to appreciate and exploit the rich type systems available with the modern programming languages. Most of the popular languages are imperative in nature, and mastering a couple of object/functional languages (such as C#, Java 8, and Scala) really helps. Once you learn a representative language from each of the aforementioned families, you have made the cognitive leap to understanding every programming language ever created or going to be created in the near future!</p>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Domain-specific languages">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch14lvl1sec99"></a>Domain-specific languages</h1>
            </div>
          </div>
        </div>
        <p>A language developed for expressing solutions to problems that are specific to a domain such as finance, payroll, electronic circuit design, parser generators, input validations, and so on is called a <span class="strong"><strong>domain-specific language</strong></span> (<span class="strong"><strong>DSL</strong></span>). Two common examples that are familiar to most programmers are <span class="strong"><strong>Structured Query Language</strong></span> (<span class="strong"><strong>SQL</strong></span>) and <span class="strong"><strong>regular expression</strong></span> (<span class="strong"><strong>RE</strong></span>). If we were to write imperative code for retrieving data from a database, it would have been a difficult task and error prone. SQL gives you a declarative language to achieve the same objective, and it has solid mathematical foundations. While searching strings, RE helps us to give complicated patterns to match against a string. It helps to avoid writing tedious logic for searching complicated string matches.</p>
        <p>As a concrete example of a DSL, which is quite popular in the .NET and Java world, we are pasting here a specification given to the <span class="strong"><strong>ANTLR</strong></span> tool to write a very simple arithmetic evaluator. The tool generates a lexical analyzer and parser automatically from this specification. Please consult the ANTLR documentation to understand the semantics of the following script:</p>
        <pre class="programlisting">    grammar Evaluator; 
 
    options { 
      language=CSharp3; 
    } 
 
    @lexer::namespace{AntlrExample} 
    @parser::namespace{AntlrExample} 
   
    public addop 
    : mulop (( '+' | '-' ) mulop)*; 
  
    mulop 
    : INTEGER (( '*' | '/' ) INTEGER)*; 
    /* 
      * Lexical Analysis Rules 
    */ 
 
    INTEGER : '0'..'9'+; 
    WS :  (' '|'\t'|'\r'|'\n')+ {Skip();} ; 
</pre>
        <p>The ANTLR tool will generate a lexical analyzer, a parser module, and even a tree walker to process the expression. We can write parsers for C#, Java, and even C/C++ using this tool. In the Unix and the Windows native programming world, the tool Lex (GNU Flex) and Yacc (GNU Bison) is used for the same purpose.</p>
        <p>As another case in point, authors worked in a DSL project, which evaluated a spreadsheet for consistency. A code snippet from the turing complete DSL generated for the project is given here:</p>
        <pre class="programlisting">    Boolean range_flag; 
    NUMERIC sum_value; 
 
    BEGIN  
 
    //--- See whether B3 cell in the CONTROL worksheet 
    //--- present in the Relational database 
    VALIDATE  LOOKUP($(CONTROL.B3), 
    @(EI_SEGMENT_MAPPING.EI_SEGMENT_CODE))==TRUE; 
 
    //---- The Sum of Range should be 100 or Zero 
    range_flag = SUM_RANGE($(HOURLY_DISTRIBUTION.C2), 
    $(HOURLY_DISTRIBUTION.C25))  == 100.0; 
    range_flag =  range_flag || 
    SUM_RANGE($(HOURLY_DISTRIBUTION.C2), 
    $(HOURLY_DISTRIBUTION.C25)) == 0.0; 
 
    //--- If false throw exception 
    VALIDATE range_flag; 
 
    EXCEPTION 
    //----- on Exception execute this 
    ErrorString = "FAILED WHILE VALIDATING CONTROL Sheet Or" 
    ErrorString = ErroString +  
    " WorkSheet Error in the range C2-C25"; 
    WRITELOG  ErrorString; 
    bResult = false; 
 
    END 
</pre>
        <p>The preceding code snippet was parsed using a hand-coded recursive descent parser, and an <span class="strong"><strong>abstract syntax tree</strong></span> (<span class="strong"><strong>AST</strong></span>) was generated. The tree was traversed in a depth-first manner to generate a .NET IL code to generate a .NET assembly (DLL). The resulting assembly was consumed as if the logic were written in C#!</p>
        <p>The <span class="strong"><strong>Extensible Stylesheet Language</strong></span> (<span class="strong"><strong>XSL</strong></span>) is another domain-specific language, which is very much familiar to most programmers. A small XSL snippet is given here for the sake of completeness, and readers are expected to master this language for generating sites with variant layouts:</p>
        <pre class="programlisting">    &lt;?xml version="1.0"?&gt; 
    &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    version="1.0"&gt; 
      &lt;xsl:output method="xml"/&gt; 
      &lt;xsl:template match="*"&gt; 
        &lt;xsl:element name="{name()}"&gt; 
          &lt;xsl:for-each select="@*"&gt; 
            &lt;xsl:element name="{name()}"&gt; 
              &lt;xsl:value-of select="."/&gt; 
            &lt;/xsl:element&gt; 
          &lt;/xsl:for-each&gt; 
          &lt;xsl:apply-templates select="*|text()"/&gt; 
        &lt;/xsl:element&gt; 
        &lt;/xsl:template&gt;  
    &lt;/xsl:stylesheet&gt; 
</pre>
        <p>The other popular DSLs are VHDL and Verilog (Digital Hardware Description Language), CSS, and template languages available with different technology stacks, JBoss Drools, and so on.</p>
        <p>Writing and designing one's own DSL is a very vast topic, which cannot be covered in a short chapter. Some things that one needs to take care of are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Designing an object model, which mimics domain concerns</li>
            <li class="listitem" style="list-style-type: disc">Designing a linguistic abstraction and associated key words for arriving at language elements and rules for composing elements to form compound elements</li>
            <li class="listitem" style="list-style-type: disc">Mapping language elements to the object model created</li>
            <li class="listitem" style="list-style-type: disc">Deciding whether the DSL should be internal or external?</li>
            <li class="listitem" style="list-style-type: disc">Deciding whether the DSL should be turing complete or not</li>
          </ul>
        </div>
        <p>The topic is well covered by Debasish Ghosh and Martin Fowler/Rebecca Parsons in their wonderful books. Please consult the following books for a thorough understanding of the same:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>DSLs in Action</em></span> by Debashish Ghosh ( Manning)</li>
            <li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Domain-Specific Languages</em></span> by Martin Fowler and Rebecca Parsons (Addison Wesley Martin Fowler signature series)</li>
          </ul>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Ontology">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch14lvl1sec100"></a>Ontology</h1>
            </div>
          </div>
        </div>
        <p>In software engineering parlance, Ontology is the art, craft, and science of describing entities (types), attributes (properties), and relationships that exist in a particular domain of discourse. It can also be considered as a model for describing entities, attributes, their relationship, and even standard behavior. An ontology really helps to come up with a ubiquitous language (as in <span class="strong"><strong>Domain-Driven Design</strong></span> (<span class="strong"><strong>DDD</strong></span>)), where all stakeholders agree, and which eases communication. It avoids confusion while developing multi-domain software systems. An ontology defines and represents the basic terms and relations that exist in a software engineering context.</p>
        <p>From an information processing perspective, the following points are to be noted:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">The propositional and predicate logic gives the rules of inference and formal structures to encode facts</li>
            <li class="listitem" style="list-style-type: disc">The ontology defines and helps to represent entities, their attributes, and the relationship between the entities in an unambiguous manner</li>
            <li class="listitem" style="list-style-type: disc">The computation helps to implement ontologies on a computer-it helps us go beyond the philosophical ontology (first two steps)</li>
          </ul>
        </div>
        <p>To write non-trivial knowledge processing systems, a software engineer should acquire skills in defining and interpreting ontologies. He should also be able to encode the ontology and its associated rules on a computer to create working computation models of the ontology in question. In software engineering, a well-defined ontology helps in the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Sharing knowledge between stakeholders about problem/solutions domain using a common terminology</li>
            <li class="listitem" style="list-style-type: disc">Filtering the ontology to create models and meta models for application development (projections of an ontology)</li>
            <li class="listitem" style="list-style-type: disc">Computation using the elements defined in the ontology</li>
          </ul>
        </div>
        <p>There are different ways by which we can encode an ontology. All of them share common elements, which are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Classes, types, or concepts</li>
            <li class="listitem" style="list-style-type: disc">Relations, roles, or properties</li>
            <li class="listitem" style="list-style-type: disc">Formal rules or axioms</li>
            <li class="listitem" style="list-style-type: disc">Instances</li>
          </ul>
        </div>
        <p>The W3C Semantic Web has created an XML-based language called <span class="strong"><strong>Web Ontology Language</strong></span> (<span class="strong"><strong>OWL</strong></span>) for describing ontologies in a structured manner. The OWL embeds <span class="strong"><strong>Resource Description Format</strong></span> (<span class="strong"><strong>RDF</strong></span>) tags to define standard ontologies. A transportation ontology from an IBM site goes as follows. These OWL markups specify that there are three classes:</p>
        <pre class="programlisting">    &lt;owl:Class rdf:ID="Winery"/&gt;  
    &lt;owl:Class rdf:ID="Region"/&gt;  
    &lt;owl:Class rdf:ID="ConsumableThing"/&gt; 
 
    &lt;owl:Class rdf:ID="PotableLiquid"&gt; 
      &lt;rdfs:subClassOf rdf:resource="#ConsumableThing" /&gt; 
    &lt;/owl:Class&gt; 
 
    &lt;owl:Class rdf:ID="Wine"&gt;  
      &lt;rdfs:subClassOf rdf:resource="&amp;food;PotableLiquid"/&gt;  
      &lt;rdfs:label xml:lang="en"&gt;wine&lt;/rdfs:label&gt;  
      &lt;rdfs:label xml:lang="fr"&gt;vin&lt;/rdfs:label&gt;  
    &lt;/owl:Class&gt;  
 
    &lt;owl:Thing rdf:ID="CentralCoastRegion" /&gt;  
    &lt;owl:Thing rdf:about="#CentralCoastRegion"&gt; 
      &lt;rdf:type rdf:resource="#Region"/&gt;  
    &lt;/owl:Thing&gt; 
 
    &lt;owl:Class rdf:ID="WineDescriptor" /&gt; 
    &lt;owl:Class rdf:ID="WineColor"&gt; 
      &lt;rdfs:subClassOf rdf:resource="#WineDescriptor" /&gt; 
    &lt;/owl:Class&gt; 
 
    &lt;owl:ObjectProperty rdf:ID="hasWineDescriptor"&gt; 
      &lt;rdfs:domain rdf:resource="#Wine" /&gt; 
      &lt;rdfs:range  rdf:resource="#WineDescriptor" /&gt; 
    &lt;/owl:ObjectProperty&gt; 
 
    &lt;owl:ObjectProperty rdf:ID="hasColor"&gt; 
      &lt;rdfs:subPropertyOf rdf:resource="#hasWineDescriptor" /&gt; 
      &lt;rdfs:range rdf:resource="#WineColor" /&gt; 
    &lt;/owl:ObjectProperty&gt; 
</pre>
        <p>This section was written to kindle interest in ontology for readers of this book. The DDD is a topic very closely related to ontology, and people who have written object-oriented systems can relate to them very fast. To get into the ontology-based software development method, we would like to recommend a wonderful book written by John Sowa, titled, <span class="emphasis"><em>Knowledge Representation: Logical, Philosophical and Computational Foundations</em></span>.&#160;Chapter 2 of that book&#160;deals with ontology as applied to software engineering. Also learn about the semantic web initiative by the W3C, by visiting their site.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="AntiPatterns">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch14lvl1sec101"></a>AntiPatterns</h1>
            </div>
          </div>
        </div>
        <p>An AntiPattern is a solution to a problem that seems to produce gain initially, but turns out to be counterproductive eventually. As patterns are named solutions, it might not be fit for certain kind of scenarios, and end up being an AntiPattern. The context in which we apply patterns is very important. AntiPatterns occur in various scenarios of a software development life cycle. They are broadly classified into these three categories:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Software development AntiPatterns</li>
            <li class="listitem" style="list-style-type: disc">Architectural AntiPatterns</li>
            <li class="listitem" style="list-style-type: disc">Management (process) AntiPatterns</li>
          </ul>
        </div>
        <p>
<span class="emphasis"><em>AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis</em></span> by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J. Mowbray is a seminal work on the AntiPattern.</p>
        <p>For the sake of kick-starting the discussion, we would like to cover some of the AntiPatterns that are ubiquitous and to which the readers of this book might be able to relate in their context:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Blob AntiPattern</strong></span>: This often happens when people from a procedural programming language background design object-oriented systems. They create a big class, which contains most of the logic, and the associated classes are just containers of data. This AntiPattern results in making a class take a lion's share of the responsibility, while the other classes execute trivial logic. The solution is to refactor the class and distribute responsibilities.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Lave Flow AntiPattern</strong></span>: This is also called dead code, and is often found in systems that started out as POC, and incrementally morphed into a production system. In this transformation, a lot of code is not used or never reached.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functional Decomposition AntiPattern</strong></span>: An AntiPattern that emerges in scenarios where primary designers of systems come from procedural languages such as C or Fortran, and try to fit their time-tested techniques to an OOP paradigm. Even after twenty years of OOP becoming mainstream, this is a recurring pattern.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Poltergeist (aka Gypsy)</strong></span>: In the OOP context, sometimes, developers create classes that have a short life cycle to kick-start the processing by core classes, which have long duration. This can be eliminated by refactoring the code to include the logic of these ghost classes to the hierarchy of classes created for the solution of the problem.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Golden Hammer</strong></span>: This AntiPattern emerges in the context where the primary designers of the system might have a favorite technology, technique, or methodology while solving problems. The old adage, <span class="emphasis"><em>For a person with hammer, everything appears to be a nail</em></span> clearly summarizes this mindset. The favorite tool is unleashed in a context where it might fit remotely. As anecdotal evidence, one of the author knows a person who will try to solve every problem through SNMP, where an ordinary TCP/IP program would have done the job.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Dead End</strong></span>: This often happens where a team might have leveraged a custom control written by an ISV to speed up the development process. While in production, the vendor might go bankrupt, or the product might not be supported by the company that acquired the vendor. By this time, the code base could get coupled with the custom control in question. Writing an isolation layer with interfaces meant for the same could avert this problem. The authors have come across dozens of such systems.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resume-Driven Design</strong></span>: The majority of developers, especially in the software services industry across the world, put their resume in front of the problem they are trying to solve. The presence or absence of certain buzzword technologies determines their compensation, and they use the latest technologies for situations where it is not warranted. This is so common that it is very easy to detect, as some simple scenarios will contain all the technologies currently in the hype cycle. One of the authors found himself in a situation where the code base happened to have an m framework, NoSQL database (a text file would have done the trick), a plugin architecture based on Microsoft <span class="strong"><strong>Managed Extensibility Framework</strong></span> (<span class="strong"><strong>MEF</strong></span>), a messaging system, and a cache manager for a system that&#160;would have taken thirty lines of a transaction-script like code. The current trend of converting projects that are running in production well to Angular 2/Typescript is another case of resume-driven design.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Spaghetti Code</strong></span>: This is an emergent phenomena in most systems, even in systems that were well defined initially. There was a mistaken notion that Spaghetti code was found only in procedural programming code base and COBOL. In OOP systems, as the system evolves and initial developers move away, the new developers who might not have much clue about the whole system, might end up writing code in a spaghetti style. Recently, authors found a Silverlight application, which used the MVVM pattern, and that had more spaghetti style code than a mainframe COBOL program!</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cut and Paste Programming</strong></span>: This often happens in large systems where a new developer who is given a tight deadline tries to leverage code written elsewhere to speed up his development time. The developer cuts and pastes a large block of code that implements similar functionality, and makes the necessary changes. In the process, some residual code gets executed unnecessarily in the new content. One of the authors, who worked with a large electronic CAD software, found performance issues in the code as the developers resorted to the <span class="emphasis"><em>Cut and Paste</em></span> model development, leading to some nested loops running unnecessarily. Because of the Spaghetti code acquired over a period of time, it happened at multiple places.</li>
            <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The StovePipe System</strong></span>: In most enterprises, because of the evolutionary nature of application development, software systems are integrated in an ad hoc manner. Some software might use resource tier integration (using relational databases), some might use transaction scripts (using a batch job engine) , point-to-point integration using REST/SOAP services, and applications run on multiple technology stacks through multiple messaging systems based on JMS and MSMQ protocol. Due to mergers and acquisitions, and lack of unified enterprise strategy, the whole scenario becomes a maintenance nightmare. By having an enterprise integration strategy and internal standards, we can reduce the complexity of integration.</li>
          </ul>
        </div>
        <p>The other popular AntiPatterns are Vendor Lock-in, Design by Committee, Warm Bodies, Architecture by Implication, Intellectual Violence, Analysis Paralysis, Smoke and Mirrors, and so on.</p>
        <p>AntiPatterns are a topic that is as important as the patterns. While patterns give you time-trusted named solutions to common problems, AntiPatterns and their solutions avoid pitfalls in your software engineering life cycle. This topic warrants a book of its own. We have just given some brief descriptions here.
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch14lvl1sec102"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>The chapter dealt with some pointers for the readers to further their study of software engineering techniques. The topics covered include polyglot programming, DSL, ontology, and AntiPatterns. We could only mention these topics briefly, as these topics require multiple books to do justice to them. There is indeed good material available on these topics in the form of YouTube videos, white papers, and books. Also try to understand more about various pattern catalogs mentioned in the first chapter of this book to have a solid foundation for architecting future systems.</p>
      </div>
    </div>
</body>
</html>