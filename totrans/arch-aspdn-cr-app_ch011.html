<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>10 Logging patterns</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="11">10 Logging patterns</h1>

<h2 data-number="11.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file46.png" style="width:10em"/></p>
<p>This chapter covers a .NET-specific feature and closes the <em>Designing for ASP.NET Core</em> section. The logging feature that comes with a few patterns is another building block that most applications need: built-in ASP.NET Core. We explore the system hands-on while not trying to master every aspect.Logging is a crucial aspect of application development and serves various purposes, such as debugging errors, tracing operations, analyzing usage, and more.The logging abstractions we explore here are another improvement of .NET Core over .NET Framework. Instead of relying on third-party libraries, the new, uniform system offers clean interfaces backed by a flexible and robust mechanism that helps implement logging into our applications.At the end of this chapter, you will understand what logging is and how to write application logs.In this chapter, we cover the following topics:</p>
<ul>
<li>About logging</li>
<li>Writing logs</li>
<li>Log levels</li>
<li>Logging providers</li>
<li>Configuring logging</li>
<li>Structured logging</li>
</ul>
<p>Let’s start by exploring what logging is.</p>


<h2 data-number="11.2">About logging</h2>
<p>Logging is the practice of writing messages into a log and cataloging information for later use. That information can be used to debug errors, trace operations, analyze usage, or any other reason we can come up with. Logging is a cross-cutting concern, meaning it applies to every piece of your application. We talk about layers in <em>Chapter 14</em>, <em>Layering and Clean Architecture</em>, but until then, let’s just say that a cross-cutting concern affects all layers and cannot be centralized in just one; it affects a bit of everything.A log is made up of log entries. We can view each log entry as an event that happened during the program’s execution. Those events are then written to the log. This log can be a file, a remote system, <code>stdout</code>, or a combination of multiple destinations.When creating a log entry, we must also think about the severity of that log entry. In a way, this severity level represents the type of message or the level of importance that we want to log. We can also use it to filter those logs. <code>Trace</code>, <code>Error</code>, and <code>Debug</code> are examples of log entry levels. Those levels are defined in the <code>Microsoft.Extensions.Logging.LogLevel</code> enum.Another important aspect of a log entry is how it is structured. You can log a single string. Everyone on your team could log single strings in their own way. But what happens when someone searches for information? Chaos ensues! There’s the stress of not finding what that person is looking for and the displeasure of the log’s structure, as experienced by that same person. One way to fix this is by using structured logging. It is simple yet complex; you must create a structure the program follows for all log entries. That structure could be more or less complex or be serialized into JSON. The important part is that the log entries are structured. We won’t get into this subject here, but if you must decide on a logging strategy, I recommend digging into structured logging first. If you are part of a team, then chances are someone else already did. If that’s not the case, you can always bring it up. Continuous improvement is a key aspect of life.We could write a whole book on logging, best logging practices, structured logging, and distributed tracing, but this chapter aims to teach you how to use .NET logging abstractions.</p>


<h2 data-number="11.3">Writing logs</h2>
<p>First, the logging system is provider-based, meaning we must register one or more <code>ILoggerProvider</code> instances if we want our log entries to go somewhere. By default, when calling <code>WebApplication.CreateBuilder(args)</code>, it registers the Console, Debug, EventSource, and EventLog (Windows only) providers, but we can modify this list. You can add and remove providers if you need to. The required dependencies for using the logging system are also registered as part of this process.Before we look at the code, let’s learn how to create log entries, which is the objective behind logging. To create an entry, we can use one of the following interfaces: <code>ILogger</code>, <code>ILogger&lt;T&gt;</code>, or <code>ILoggerFactory</code>. Let’s take a look at them in more detail:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Interface</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>ILogger</code></td>
<td>Base type that allows us to perform logging operations.</td>
</tr>
<tr class="odd">
<td><code>ILogger&lt;T&gt;</code></td>
<td>Base type that allows us to perform logging operations. Inherit from the ILogger interface. The system uses the generic parameter <code>T</code> as the log entry’s <em>category</em> .</td>
</tr>
<tr class="even">
<td><code>ILoggerFactory</code></td>
<td>A factory interface that allows creating <code>ILogger</code> objects and specifying the category name manually as a string.</td>
</tr>
</tbody>
</table>
Table 10.1: the logging interfaces.
<p>The following code represents the most commonly used pattern, which consists of injecting an <code>ILogger&lt;T&gt;</code> interface and storing it in an <code>ILogger</code> field before using it, like this:</p>
<div><pre><code>public class Service : IService
{
    private readonly ILogger _logger;
    public Service(ILogger&lt;Service&gt; logger)
    {
        _logger = logger;
    }
    public void Execute()
    {
        _logger.LogInformation("Service.Execute()");
    }
}</code></pre>
</div>
<p>The preceding <code>Service</code> class has a private <code>_logger</code> field. It takes an <code>ILogger&lt;Service&gt; </code>logger as a parameter and stores it in that field. It uses that field in the <code>Execute</code> method to write an information-level message to the log.The <code>IService</code> interface is very simple and only exposes a single <code>Execute</code> method for testing purposes:</p>
<div><pre><code>public interface IService
{
    void Execute();
}</code></pre>
</div>
<p>I loaded a small library I created to test this out, providing additional logging providers for testing purposes. With that, we are creating a generic host (<code>IHost</code>) since we don’t need a <code>WebApplication</code> in our tests, then we configure it:</p>
<div><pre><code>namespace Logging;
public class BaseAbstractions
{
    [Fact]
    public void Should_log_the_Service_Execute_line()
    {
        // Arrange
        var lines = new List&lt;string&gt;();
        var host = Host.CreateDefaultBuilder()
            .ConfigureLogging(loggingBuilder =&gt;
            {
                loggingBuilder.ClearProviders();
                loggingBuilder.AddAssertableLogger(lines);
            })
            .ConfigureServices(services =&gt;
            {
                services.AddSingleton&lt;Service&gt;();
            })
            .Build();
        var service = host.Services.GetRequiredService&lt;Service&gt;(); 
        // Act
        service.Execute();
        // Assert
        Assert.Collection(lines,
            line =&gt; Assert.Equal("Service.Execute()", line)
        );
    }
    // Omitted other members
}</code></pre>
</div>
<p>In the <code>Arrange</code> phase of the test, we create some variables, configure <code>IHost</code>, and get an instance of the <code>Service</code> class that we want to use to test the logging capabilities that we programmed.The highlighted code removes all providers using the <code>ClearProviders</code> method. Then it uses the <code>AddAssertableLogger</code> extension to add a new provider. The extension method comes from the library that we loaded. We could have added a new provider if we wanted, but I wanted to show you how to remove existing providers so we can start from a clean slate. That’s something you might need someday.</p>
<blockquote>
<p>The library that I loaded is available on NuGet and is named <code>ForEvolve.Testing.Logging</code>, but you do not need to understand any of this to understand logging abstractions and examples.</p>
</blockquote>
<p>In the <code>Act</code> phase, we call the <code>Execute</code> method of our service. This method logs a line to the <code>ILogger</code> implementation that is injected upon instantiation. Then, we assert that the line was written in the <code>lines</code> list (that’s what <code>AssertableLogger</code> does; it writes to a <code>List&lt;string&gt;</code>). In an ASP.NET Core application, all that logging goes to the console by default. Logging is a great way to know what is happening in the background when running the application.The <code>Service</code> class is a simple consumer of an <code>ILogger&lt;Service&gt;</code>. You can do the same for any class you want to add logging support to. Change <code>Service</code> by that class name to have a logger configured for your class. That generic argument becomes the logger's category name when writing log entries.Since ASP.NET Core uses a <code>WebApplication</code> instead of a generic <code>IHost</code>, here is the same test code using that construct:</p>
<div><pre><code>[Fact]
public void Should_log_the_Service_Execute_line_using_WebApplication()
{
    // Arrange
    var lines = new List&lt;string&gt;();
    var builder = WebApplication.CreateBuilder();
    builder.Logging.ClearProviders()
        .AddAssertableLogger(lines);
    builder.Services.AddSingleton&lt;IService, Service&gt;();
    var app = builder.Build();
    var service = app.Services.GetRequiredService&lt;IService&gt;();
    // Act
    service.Execute();
    // Assert
    Assert.Collection(lines,
        line =&gt; Assert.Equal("Service.Execute()", line)
    );
}</code></pre>
</div>
<p>I highlighted the changes in the preceding code. In a nutshell, the extension methods used on the generic host have been replaced by <code>WebApplicationBuilder</code> properties like <code>Logging</code> and <code>Services</code>. Finally, the <code>Create</code> method creates a <code>WebApplication</code> instead of an <code>IHost</code>, exactly like in the <code>Program.cs</code> file.To wrap this up, these test cases allowed us to implement the most commonly used logging pattern in ASP.NET Core and add a custom provider to ensure we logged the correct information. Logging is essential and adds visibility to production systems. Without logs, you don’t know what is happening in your system unless you are the only one using it, which is very unlikely. You can also log what is happening in your infrastructure and run real-time security analysis on those log streams to quickly identify security breaches, intrusion attempts, or system failures. These subjects are out of the scope of this book, but having strong logging capabilities at the application level can only help your overall logging strategy.Before moving on to the next subject, let’s explore an example that leverages the <code>ILoggerFactory</code> interface. The code sets a custom category name and uses the created <code>ILogger</code> instance to log a message. This is very similar to the previous example. Here’s the whole code:</p>
<div><pre><code>namespace Logging;
public class LoggerFactoryExploration
{
    private readonly ITestOutputHelper _output;
    public LoggerFactoryExploration(ITestOutputHelper output)
    {
        _output = output ?? throw new ArgumentNullException(nameof(output));
    }
    [Fact]
    public void Create_a_ILoggerFactory()
    {
        // Arrange
        var lines = new List&lt;string&gt;();
        var host = Host.CreateDefaultBuilder()
            .ConfigureLogging(loggingBuilder =&gt; loggingBuilder
                .AddAssertableLogger(lines)
                .AddxUnitTestOutput(_output))
            .ConfigureServices(services =&gt; services.AddSingleton&lt;Service&gt;())
            .Build()
        ;
        var service = host.Services.GetRequiredService&lt;Service&gt;();
        // Act
        service.Execute();
        // Assert
        Assert.Collection(lines,
            line =&gt; Assert.Equal("LogInformation like any ILogger&lt;T&gt;.", line)
        );
    }
    public class Service
    {
        private readonly ILogger _logger;
        public Service(ILoggerFactory loggerFactory)
        {
            ArgumentNullException.ThrowIfNull(loggerFactory);
            _logger = loggerFactory.CreateLogger("My Service");
        }
        public void Execute()
        {
            _logger.LogInformation("LogInformation like any ILogger&lt;T&gt;.");
        }
    }
}</code></pre>
</div>
<p>The preceding code should look very familiar. Let’s focus on the highlighted lines, which relate to the current pattern:</p>
<ol>
<li>We inject the <code>ILoggerFactory</code> interface into the <code>Service</code> class constructor (instead of an <code>ILogger&lt;Service&gt;</code>).</li>
<li>We create an <code>ILogger</code> instance with the <code>"</code> <code>My Service"</code> category name.</li>
<li>We assign the logger to the <code>_logger</code> field.</li>
<li>We then use that <code>ILogger</code> from the <code>Execute</code> method.</li>
</ol>
<p>As a rule of thumb, I recommend using the <code>ILogger&lt;T&gt;</code> interface by default. If impossible, or if you need a more dynamic way of setting the category name for your log entries, leverage the <code>ILoggerFactory</code> instead. By default, when using <code>ILogger&lt;T&gt;</code>, the category name is the T parameter, which should be the name of the class creating log entries. The <code>ILoggerFactory</code> interface is more of an internal piece than something made for us to consume; nonetheless, it exists and satisfies some use cases.</p>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>In the preceding example, the <code>ITestOutputHelper</code> interface is part of the <code>Xunit.Abstractions</code> assembly. It allows us to write lines as <em>standard output</em> to the test log. That output is available in the Visual Studio Test Explorer.</p>
</blockquote>
</blockquote>
<p>Now that we have covered how to write log entries, it's time to learn how to manage their severity.</p>


<h2 data-number="11.4">Log levels</h2>
<p>In the previous examples, we used the <code>LogInformation</code> method to log information messages, but there are other levels as well, shown in the following table:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Level</strong></td>
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
<td><strong>Production</strong></td>
</tr>
<tr class="even">
<td>Trace</td>
<td><code>LogTrace</code></td>
<td>This is used to capture detailed information about the program, instrument execution speed, and debugging. You can also log sensitive information when using traces.</td>
<td>Disabled.</td>
</tr>
<tr class="odd">
<td>Debug</td>
<td><code>LogDebug</code></td>
<td>This is used to log debugging and development information.</td>
<td>Disabled unless troubleshooting.</td>
</tr>
<tr class="even">
<td>Information</td>
<td><code>LogInformation</code></td>
<td>This is used to track the flow of the application. Normal events that occur in the system are often information-level events, such as the system started, the system stopped, and a user has signed in.</td>
<td>Enabled.</td>
</tr>
<tr class="odd">
<td>Warning</td>
<td><code>LogWarning</code></td>
<td>This is used to log abnormal behavior in the application flow that does not cause the program to stop, but that may need to be investigated; for example, handled exceptions, failed network calls, and accessing resources that do not exist.</td>
<td>Enabled.</td>
</tr>
<tr class="even">
<td>Error</td>
<td><code>LogError</code></td>
<td>This is used to log errors in the application flow that do not cause the application to stop. Errors must usually be investigated. Examples include the failure of the current operation and an exception that cannot be handled.</td>
<td>Enabled.</td>
</tr>
<tr class="odd">
<td>Critical</td>
<td><code>LogCritical</code></td>
<td>This is used to log errors that require immediate attention and represent a catastrophic state. The program is most likely about to stop, and the integrity of the application might be compromised; for example, a hard drive is full, the server is out of memory, or the database is in a deadlocked state.</td>
<td>Enabled with some alerts that could be configured to trigger automatically.</td>
</tr>
</tbody>
</table>
Table 10.2: log entry levels
<p>As described in the preceding table, each log level serves one or more purposes. Those log levels tell the logger what severity a log entry is. Then, we can configure the system to log only entries of at least a certain level so we don’t fill out production logs with traces and debug entries, for example. In a project I led, we benchmarked multiple ways to log simple and complex messages using ASP.NET Core to build clear and optimized guidelines around that. We could not reach a fair conclusion when the messages were logged due to a large time variance between benchmark runs. However, we observed a constant trend when messages were not logged (<em>trace</em> logs with the minimum logging level configured to <em>debug</em>, for example).Based on that conclusion, I recommend logging the <code>Trace</code> and <code>Debug</code> messages using the following construct instead of interpolation, <code>string.Format</code>, or other means. That may sound strange to optimize for <em>not logging something</em>, but if you think about it, those log entries will be skipped in production, so optimizing them will save your production app a few milliseconds of computing time here and there. Moreover, it's not harder or longer to do, so it's just a good habit.Let’s look at the fastest way to <em>not write log entries</em>:</p>
<div><pre><code>_logger.LogTrace("Some: {variable}", variable);
// Or
_logger.LogTrace("Some: {0}", variable);</code></pre>
</div>
<p>When the log level is disabled, such as in production, you only pay the price of a method call because no processing is done on your log entries. On the other hand, if we use interpolation, the processing is done, so that one argument is passed to the <code>Log[Level]</code> method, leading to a higher cost in processing power for each log entry.Here’s an example of interpolation (a.k.a. what not to do):</p>
<div><pre><code>_logger.LogTrace($"Some: {variable}");</code></pre>
</div>
<p>For warning and higher levels, you can keep the good habit and use the same technique or other methods because we know those lines will be logged anyway. Therefore, using interpolation in the code or letting the logger do it later should yield a similar result.</p>
<blockquote>
<p>One last note. I suggest you don’t try to over-optimize your code before there is a need for that. The action of investing a lot of effort in optimizing something that does not need optimizing is known as <strong>premature optimization</strong>. The idea is to optimize just enough upfront and fix the performance when you find real issues.</p>
</blockquote>
<p>Now that we know the log levels that .NET offers us, let’s look at the logging providers.</p>


<h2 data-number="11.5">Logging providers</h2>
<p>To give you an idea of the possible built-in logging providers, here is a list from the official documentation (see the <em>Further reading</em> section at the end of this chapter):</p>
<ul>
<li>Console</li>
<li>Debug</li>
<li>EventSource</li>
<li>EventLog (Windows only)</li>
<li>ApplicationInsights</li>
</ul>
<p>The following is a list of third-party logging providers, also from the official documentation:</p>
<ul>
<li>elmah.io</li>
<li>Gelf</li>
<li>JSNLog</li>
<li>KissLog.net</li>
<li>Log4Net</li>
<li>NLog</li>
<li>PLogger</li>
<li>Sentry</li>
<li>Serilog</li>
<li>Stackdriver</li>
</ul>
<p>Now, if you need any of those or your favorite logging library is part of the preceding list, you know you can use it. If it is not, maybe it supports ASP.NET Core but was not part of the documentation when I consulted it.Next, let’s learn how to configure the logging system.</p>


<h2 data-number="11.6">Configuring logging</h2>
<p>As with most features of ASP.NET Core, we can configure logging. The default <code>WebApplicationBuilder</code> that do a lot for us, but in case we want to tweak the defaults, we can. On top of that, the system loads the <code>Logging</code> section of the configuration. That section is present, by default, in the <code>appsettings.json</code> file. Like all configurations, it is cumulative, so we can redefine part of it in another file or configuration provider.We won’t dig too deep into customization, but it is good to know that we can customize the minimum level of what we are logging. We can also use transformation files (such as <code>appsettings.Development.json</code>) to customize those levels per environment.For example, we can define our defaults in <code>appsettings.json</code>, then update a few for development purposes in <code>appsettings.Development.json</code>, change production settings in <code>appsettings.Production.json</code>, then change the staging settings in <code>appsettings.Staging.json</code>, and add some testing settings in <code>appsettings.Testing.json</code>.Before we move on, let’s take a peek at the default settings:</p>
<div><pre><code>{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  }
}</code></pre>
</div>
<p>We can define default levels (using <code>Logging:LogLevel:Default</code>) and a custom level for each category (such as <code>Logging:LogLevel:Microsoft</code>) representing base namespaces. For example, from that configuration file, the minimum level is <code>Information</code>, while every item part of the <code>Microsoft</code> or <code>Microsoft.*</code> namespaces have a minimum level of <code>Warning</code>. That allows for removing noise when running the application. We can also leverage these configurations to debug certain parts of the application by lowering the log level to <code>Debug</code> or <code>Trace</code> for only a subset of items (items from one or more namespaces, for example).We can also filter what we want to log on a provider basis, using configuration or code. In the configuration file, we can change the default level of the console provider to <code>Trace</code>, like this:</p>
<div><pre><code>{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    },
    "Console": {
      "LogLevel": {
        "Default": "Trace"
      }
    }
  }
}</code></pre>
</div>
<p>We kept the same default values but added the <code>Logging:Console</code> section (see highlighted code) with a default <code>LogLevel</code> set to <code>Trace</code>. We can define as many settings as we need.Instead of configurations, we can use the <code>AddFilter</code> extension methods, as shown in the following experimental test code, or in conjunction with configurations.Here is the consumer class that logs data:</p>
<div><pre><code>public class Service
{
    private readonly ILogger _logger;
    public Service(ILogger&lt;Service&gt; logger)
    {
        _logger = logger;
    }
    public void Execute()
    {
        _logger.LogInformation("[info] Service.Execute()");
        _logger.LogWarning("[warning] Service.Execute()");
    }
}</code></pre>
</div>
<p>The preceding class is like other classes we used during the chapter but logs messages using two different levels: <code>Information</code> and <code>Warning</code>. Here is a test case in which we leverage the <code>AddFilter</code> method:</p>
<div><pre><code>[Fact]
public void Should_filter_logs_by_provider()
{
    // Arrange
    var lines = new List&lt;string&gt;();
    var host = Host.CreateDefaultBuilder()
        .ConfigureLogging(loggingBuilder =&gt;
        {
            loggingBuilder.ClearProviders();
            loggingBuilder.AddConsole();
            loggingBuilder.AddAssertableLogger(lines);
            loggingBuilder.AddxUnitTestOutput(_output);
            loggingBuilder
                .AddFilter&lt;XunitTestOutputLoggerProvider&gt;(
                    level =&gt; level &gt;= LogLevel.Warning
                );
        })
        .ConfigureServices(services =&gt;
        {
            services.AddSingleton&lt;Service&gt;();
        })
        .Build();
    var service = host.Services.GetRequiredService&lt;Service&gt;();
    // Act
    service.Execute();
    // Assert
    Assert.Collection(lines,
        line =&gt; Assert.Equal("[info] Service.Execute()", line),
        line =&gt; Assert.Equal("[warning] Service.Execute()", line)
    );
}</code></pre>
</div>
<p>We created a generic host in the preceding test code and added three providers: the console and two test providers—one that logs to a list and another to the xUnit output. Then, we told the system to filter out everything that is not at least a <code>Warning</code> from <code>XunitTestOutputLoggerProvider</code> (see highlighted code); other providers are unaffected by that code.</p>
<blockquote>
<p>In the code, the <code>_output</code> member is a field of type <code>ITestOutputHelper</code>.</p>
</blockquote>
<p>We now know of two options to set the minimum logging levels:</p>
<ul>
<li>Code</li>
<li>Configuration</li>
</ul>
<p>We can tweak the way we configure our logging policies as needed. Code can be more testable, while configurations can be updated at runtime without redeploying. Moreover, with the cascading model, which allows us to override configuration, we can cover most use cases using configurations. The biggest downside of configuration is that writing strings in a JSON file is more error-prone than writing code (assuming you are not reverting to using strings there either).I usually stick with configurations to set those values, as they do not change often. If you prefer code, I’m unaware of any drawbacks, and it’s just a matter of preference; the configuration becomes code at some point.Next, let’s look at a brief example of structured logging.</p>


<h2 data-number="11.7">Structured logging</h2>
<p>As stated at the beginning, structured logging can become very important and open opportunities. Querying a data structure is always more versatile than querying a single line of text. That is even more true if there is no clear guideline around logging, whether a line of text or a JSON-formatted data structure.To keep it simple, we leverage a built-in formatter (highlighted line below) that serializes our log entries into JSON. Here is the <code>Program.cs</code> file:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Logging.AddJsonConsole();
var app = builder.Build();
app.MapGet("/", (ILoggerFactory loggerFactory) =&gt;
{
    const string category = "root";
    var logger = loggerFactory.CreateLogger(category);
    logger.LogInformation("You hit the {category} URL!", category);
    return "Hello World!";
});
app.Run();</code></pre>
</div>
<p>That transforms the console to logging JSON. For example, every time we hit the <code>/</code> endpoint, the console displays the following JSON:</p>
<div><pre><code>{
  "EventId": 0,
  "LogLevel": "Information",
  "Category": "root",
  "Message": "You hit the root URL!",
  "State": {
    "Message": "You hit the root URL!",
    "category": "root",
    "{OriginalFormat}": "You hit the {category} URL!"
  }
}</code></pre>
</div>
<p>Without that formatter, the usual output would have been:</p>
<div><pre><code>info: root[0]
      You hit the root URL!</code></pre>
</div>
<p>Based on that comparison, it is more versatile to query the JSON logs programmatically than the <code>stdout</code> line.The biggest benefit of structured logging is improved searchability. You can run more precise queries at scale with a predefined data structure.Of course, if you are setting up a production system, you would probably want more information attached to such log items like the correlation ID of the request, optionally some information about the current user, the server’s name on which the code is running, and possibly more details depending on the application.You may need more than the out-of-the-box features to utilize structured logging fully. Some third-party libraries like Serilog offer those additional capabilities. However, defining the way to send plain text to the logger could be a start.Each project should dictate the needs and depth of each feature, including logging. Moreover, structured logging is a broader subject that merits studying independently. Nonetheless, I wanted to touch on this subject a bit, and hopefully, you learned enough about logging to get started.</p>


<h2 data-number="11.8">Summary</h2>
<p>In this chapter, we delved into the concept of logging. We learned that logging is the practice of recording messages into a log for later use, such as debugging errors, tracing operations, and analyzing usage. Logging is essential, and ASP.NET Core offers us various ways to log information independently of third-party libraries while allowing us to use our favorite logging framework. We can customize the way the logs are written and categorized. We can use zero or more logging providers. We can also create custom logging providers. Finally, we can use configurations or code to filter logs and much more.Here is the default logging pattern to remember:</p>
<ol>
<li>Inject an <code>ILogger&lt;T&gt;</code>, where <code>T</code> is the type of the class into which the logger is injected. <code>T</code> becomes the category.</li>
<li>Save a reference of that logger into a <code>private readonly ILogger</code> field.</li>
<li>Use that logger in your methods to log messages using the appropriate log level.</li>
</ol>
<p>The logging system is a great addition to .NET Core compared to .NET Framework. It allows us to standardize the logging mechanism, making our systems easier to maintain in the long run. For example, suppose you want to use a new third-party library or even a custom-made one. In that case, you can load the provider into your <code>Program</code>, and the entire system will adapt and start using it without any further changes as long as you depend only on the logging abstractions. This is a good example of what well-designed abstractions can bring to a system.<strong>Here are a few key takeaways</strong>:</p>
<ul>
<li>Logging is a cross-cutting concern, affecting all layers of an application.</li>
<li>A log comprises many log entries representing an event that occurred at runtime during the program's execution.</li>
<li>The severity of a log entry is important for filtering and prioritization.</li>
<li>The severity levels are Trace, Debug, Information, Warning, Error, and Critical.</li>
<li>We can configure the logging system to log only certain messages based on the severity level of each entry.</li>
<li>Structured logging can help maintain consistency and ease of searching within logs.</li>
<li>The logging system in .NET is provider-based, allowing us to customize the default providers.</li>
<li>We can use interfaces like ILogger, ILogger&lt;T&gt;, or ILoggerFactory to create log entries.</li>
</ul>
<p>This chapter closes the second section of this book with ASP.NET Core at its center. We explore design patterns to create flexible and robust components in the next few chapters.</p>


<h2 data-number="11.9">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Can we write log entries to the console and a file at the same time?</li>
<li>Is it true that we should log the trace- and debug-level log entries in a production environment?</li>
<li>What is the purpose of structured logging?</li>
<li>How can we create a log entry in .NET?</li>
</ol>


<h2 data-number="11.10">Further reading</h2>
<p>Here is a link to build upon what we learned in the chapter:</p>
<ul>
<li>[Official docs] <em>Logging in .NET Core and ASP.NET Core</em>: <a href="https://adpg.link/MUVG">https://adpg.link/MUVG</a></li>
</ul>


<h2 data-number="11.11">Answers</h2>
<ol>
<li>Yes, you can configure as many providers as you want. One could be for the console, and another could append entries to a file.</li>
<li>No, you should not log trace-level entries in production. You should only log debug-level entries when debugging an issue.</li>
<li>Structured logging maintains a consistent structure across all log entries, making searching and analyzing logs easier.</li>
<li>We can create a log entry using interfaces like <code>ILogger</code>, <code>ILogger&lt;T&gt;</code>, and <code>ILoggerFactory</code>.</li>
</ol>


</body>
</html>
