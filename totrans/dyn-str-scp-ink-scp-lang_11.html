<html><head></head><body><div><div><h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor137"/>Chapter 9</em>: Story API – Observing and Reacting to Story Events</h1>
			<p>In this chapter, we will explore how changes in a running ink story can trigger events in Unity. We will learn how the <code>ObserveVariable()</code> and <code>ObserveVariables()</code> methods of the Story API, as provided by the ink-Unity Integration plugin, allow you to prepare functions to react to future events in Unity. We will begin by observing a single variable and then move on to learn how to watch multiple values. </p>
			<p>In <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, the focus was on controlling an ink story by calling its functions and changing its values from Unity. This chapter reverses the emphasis between the two systems. In this chapter, we will explore how narrative events, such as variables changing because of a player's choices, can be used to control what information is presented in Unity.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Listening for variable changes</li>
				<li>Dynamically responding to ink stories</li>
				<li>Observing multiple ink values</li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Technical requirements</h1>
			<p>The examples used in this chapter, in the <code>*.ink</code> files, can be found on GitHub at <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9</a>.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Listening for variable changes</h1>
			<p>Variables in ink are <a id="_idIndexMarker355"/>global. Once they are created, they can be accessed at any point in the story. In <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, we learned how this functionality can be used with the <code>variablesState</code> property to access or change their values. However, instead of directly interfering in a running ink from Unity, we can also wait for something to happen in ink and then react in Unity. The verb used for this type of approach, as part of the Story API, is called <em class="italic">observing</em>.</p>
			<p>When we observe an ink variable, we can write our own rules regarding what should happen when its value changes or meets a certain threshold. We are merely <em class="italic">observing</em> its value. What we do because of this observance is up to the developer.</p>
			<p>In this topic, we will explore the <code>ObserveVariable()</code> method.</p>
			<p class="callout-heading">Recommendation</p>
			<p class="callout">It is recommended that you create a new Unity 2D project for this topic. Instructions regarding how to create a new Unity project and import the ink-Unity Integration plugin can be found in <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink Unity Plugin.</em></p>
			<p>We will perform the following steps:</p>
			<ol>
				<li>In a new Unity project, using the 2D template with the ink-Unity Integration plugin imported, create a new, empty game object and name it <code>InkStory</code>. This game object will hold the <code>script</code> component and react to changes in the Ink code.</li>
				<li>Create a new Ink file and name it <code>InkStoryStepCounter.ink</code>.</li>
				<li>Open <code>InkStoryStepCounter.ink</code> for editing in Inky and update its contents to <code>Example 1 (InkStoryStepCounter.ink).</code></li>
				<li>Create a new <code>script</code> component inside the <code>InkStory</code> game object. Name the created file <code>InkStoryScript.cs</code>.</li>
				<li>Open <code>InkStoryScript.cs</code> for editing in Visual Studio.<p>Update <code>InkStoryScript.cs</code> to <code>Example 1 (InkStoryScript.cs)</code>.</p><p>The <code>ObserveVariable()</code> method<a id="_idIndexMarker356"/> is a new method introduced in this chapter and accepts two parameters. The first parameter is the name of a variable to observe and the second is a function or a method to call.</p><p>The code used in this example also incorporates a C# concept known as a <code>ObserveVariable()</code> method watches a variable in ink. If its value changes at any point, the lambda expression will run. This operates outside the normal flow.</p></li>
				<li>Associate the compiled Ink JSON file.</li>
				<li>Run the project.</li>
			</ol>
			<p>When the project is run, the <code>ObserveVariable()</code> method, and the third will be the text produced as the first option chosen:</p>
			<div><div><img src="img/Figure_9.1_B17597.jpg" alt="Figure 9.1 – The Text output is shown in order of execution in Unity" width="608" height="251"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The Text output is shown in order of execution in Unity</p>
			<p>The reason why the second message shows the value before the third text of the option is because of the execution order. Within the running ink story, the <code>ObserveVariable()</code> method occurs <em class="italic">before</em> the text output is produced for the option and returned to Unity. The use of the delegated lambda expression occurs outside the normal flow of execution in this way. Whenever the value of the observed variable changes, the function is immediately called, regardless of any other code happening<a id="_idIndexMarker358"/> around it at the same time.</p>
			<p>In the next section, we will build on this pattern. Often, there are contexts in which Unity should only be told a variable has been changed when it happens. This frees up the execution time for other tasks in Unity and allows a developer to write more reactive code that only runs when needed.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Dynamically responding to ink stories</h1>
			<p>In Unity, multiple <a id="_idIndexMarker359"/>methods are called as part of the normal execution cycle when a project runs. Often, methods such as <code>Update()</code>, a common part of behavior scripts in Unity, include many lines of code. Even a method such as <code>FixedUpdate()</code>, called at the end of the physics calculations for each cycle in a running project, might include multiple parts. Any code that depends on other systems, such as those communicating with ink, can also add extra time per cycle.</p>
			<p>The use of the <code>ObserveVariable()</code> method allows data from ink to only update Unity when needed. Because the Story API will only call the delegated function when necessary, Unity will also only get the data when there is a change it needs to know about when it needs to know about it. This will also happen outside the use of an <code>Update()</code> method or even a <code>FixedUpdate()</code> method in Unity.</p>
			<p>In this section, we will examine how the <code>ObserveVariable()</code> method operates outside of other methods as part of Unity. It will only call the delegated function when a value changes allowing a dynamic response in Unity.</p>
			<p>Return to the project created in the previous section, and perform the following steps:</p>
			<ol>
				<li value="1">Update the <code>InkStoryScript.cs</code> file to <code>Example 2 (InkStoryScript.cs)</code>.</li>
				<li>Within the <code>Update()</code> method, four different actions are taking place. <p>The <em class="italic">first</em> is the increase in the variable time with the most recent <code>Time.deltaTime</code>, which is the number of milliseconds between cycles as measured in a decimal (float) number. The <em class="italic">second</em> is a conversion between its float value into an integer. This operation removes the decimal part of the number. The <em class="italic">third</em> action is a<a id="_idIndexMarker360"/> mathematical operation called <code>%</code>, can be used to find the remainder from division. This operation is called <em class="italic">modulo</em>. However, many programming languages also use the term <em class="italic">remainder operator</em>. When this operation is performed, it will determine how many times one number can be divided into another. In this case, using the remainder of <code>60</code>, the <code>seconds</code> variable will always be equal to the number of seconds that have passed since the project began, as divided by the <code>time</code> variable.</p><p>The <em class="italic">fourth</em> action within the <code>Update()</code> method is the assignment of the <code>seconds</code> variable to the number of seconds, as defined by the previously explained actions. In every cycle in Unity, this number will be updated, and the <code>seconds</code> variable will always be up to date.</p><p>One final action takes place in the delegated function, that is, the use of the <code>Destroy()</code> method. Within the code, once the value of the <code>steps</code> ink variable is equal to <code>3</code>, as determined by Unity, it will remove a button from the scene. This helps to keep the control of the button connected to a value changed outside of Unity. Once the ink variable changes and is reported to Unity, the button is removed.</p><p>On the last line of the <code>Start()</code> method, a button is given a listener function for its <code>onClick</code> event. When the button is clicked on, any functions associated with the listeners will be called. In this example, clicking on the button will call the new <code>TakeStep()</code> method. This will load the next text content up to the next weave encountered in the ink code and then choose the first (<code>0</code>) option within the weave. This will cause the ink code to loop internally.</p><p>With the code created, two more steps are required before the project can be played. First, a new <code>Button</code> game object needs to be added to the project. Then, once the <code>Button</code> game object exists, it must be associated with the <code>InkStory</code> property <a id="_idIndexMarker362"/>as part of the new code.</p></li>
				<li>Create a new <code>Button</code> game object in Unity.</li>
				<li>Associate the <code>Button</code> game object with the <code>Button Step</code> property.</li>
				<li>Play the project.</li>
				<li>The created <code>Button</code> game object appears at the bottom of the scene. Clicking on the <code>Button</code> game object four times will cause it to disappear, and a message will appear in the <strong class="bold">Console</strong> window:<div><img src="img/Figure_9.2_B17597.jpg" alt="Figure 9.2 – A message in the Console window generated by a delegated function&#13;&#10;" width="457" height="137"/></div><p class="figure-caption">Figure 9.2 – A message in the Console window generated by a delegated function</p></li>
				<li>Stop the project.</li>
			</ol>
			<p>When the project first started, the <code>Update()</code> method of the code was called during each cycle. Internally, it updated the <code>time</code> and <code>seconds</code> variables in the Unity code. Whenever the <code>Button</code> game object was clicked on, it progressed the ink code, which looped itself internally. Because of the use of the <code>ObserveVariable()</code> method, any time the ink variable steps were updated, it called the delegated function and tested the new value passed to it. Once it reached <code>3</code> (based on a total of four clicks to move it from <code>0</code> to <code>3</code>), the delegated function created a message in the <code>Button</code> game object.</p>
			<p>The example used in this section follows a common pattern where Unity performs its own calculations as part of a method, such as <code>Update()</code>, and dynamically responds to changes in an ink story as they happen. Instead of potentially checking the <code>steps</code> ink variable as part of the <code>variablesState</code> property every cycle, and wasting time if the value has not changed, the delegated function allows Unity to only act when needed. For more complicated projects, this is the preferred approach, and generally, it produces faster projects.</p>
			<p>More than a single variable can be observed in ink. Depending on the complexity of design, a Unity<a id="_idIndexMarker363"/> project might be interested in observing multiple ink values and updating onscreen areas with information on story progression or the current statistics of the player. For these contexts, a different method is needed: <code>ObserveVariables()</code>. In the next section, we will demonstrate how to work with this method.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Observing multiple ink values</h1>
			<p>Along with<a id="_idIndexMarker364"/> the <code>ObserveVariable()</code> method is a sister method named <code>ObserveVariables()</code>. However, while the <code>ObserveVariable()</code> method accepts the name of a variable and a delegate function, the <code>ObserveVariables()</code> method accepts an <code>IList&lt;string&gt;</code> of variable names and a delegate function. Instead of responding when a single variable is changed, its delegate function is called when any of the variables passed as a list to the method are changed. While slightly more complicated to set up, the <code>ObserveVariables()</code> method provides the functionality to observe multiple ink variables.</p>
			<p class="callout-heading">Recommendation</p>
			<p class="callout">It is recommended that you create a new Unity 2D project for this section. Instructions regarding how to create a new Unity project and import the ink-Unity Integration plugin can be found in <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">In a new Unity 2D project with the ink-Unity Integration plugin imported, create a new, empty game object and name it <code>InkStory</code>. This game object will hold the <code>Script</code> component and react to any changes in the ink code.</li>
				<li>Create a new ink file and name it <code>InkStoryPlayerStatistics.ink</code>.</li>
				<li>Open the <code>InkStoryPlayerStatistics.ink</code> file for editing in Inky and update its content to <code>Example</code> <code>3</code> <code>(InkStoryPlayerStatistics.ink)</code>.</li>
				<li>Create a<a id="_idIndexMarker365"/> new <code>script</code> component inside the <code>InkStory</code> game object. Name the created file <code>InkStoryPlayerStatisticsScript.cs</code>.</li>
				<li>Open the created <code>InkStoryPlayerStatisticsScript.cs</code> file in Visual Studio. Update it to <code>Example</code> <code>3</code> <code>(</code> <code>InkStoryPlayerStatisticsScript.cs)</code>.<p>The updated code begins by setting up the Story API. It does this by creating a new object based on the <code>Story</code> class. Next, a <code>List&lt;string&gt;</code> is created. This is used as a <em class="italic">list</em> of the variable names based on their string values. After creating the list, two values are added to it in an order, based on the names of the <code>mental_health</code> and <code>physcial_health</code> ink variables. This created list is then passed to the <code>ObserveVariables()</code> method, and a second parameter, that is, a delegated function in the form of a lambda expression, is used.</p><p>The <code>Start()</code> method ends with a call to the created <code>ProgressStory()</code> method. Inside this created method, the story is progressed programmatically by using the <code>ContinueMaximally()</code> and <code>ChooseChoiceIndex()</code> methods. The first method loads all of the text content up to the first weave, while the second method selects the first (<code>0</code>) option in the weave. The final, second use of the <code>ContinueMaximally()</code> method loads the resulting text within the Ink code and is needed to cause the variable to change.</p></li>
				<li>Associate the compiled Ink JSON file with the <code>InkStory</code> game object.</li>
				<li>Run the project.<p>When the project starts, it will programmatically progress the ink story used within this section. As a result, it will produce a message in the <code>List&lt;string&gt;</code> that was passed to the <code>ObserveVariables()</code> method. However, only one of them was changed because of the ink story progression. As a result, the variable changed, and its new value was passed back to Unity. When the change happened, the delegated function was called with the second parameter, the name of the variable (<code>variableName</code>), and its new value (<code>newValue</code>).</p><p>The <code>ObserveVariables()</code> method works similarly to its sister <code>ObserveVariable()</code> method. Both respond with the name of the variable and the changed value as soon as they happen in ink. The major difference between them is in their first parameter. The <code>ObserveVariables()</code> method accepts the name of a single variable name in ink, and the <code>ObserveVariables()</code> method is a list of which variables to observe and then respond to using the delegated function.</p></li>
				<li>Stop the project.</li>
			</ol>
			<p>This section focused on the use of the <code>ObserveVariables()</code> method, echoing the pattern in the previous section where we used the <code>ObserveVariable()</code> sister method. In general, either approach offers a way to control how Unity reacts to ink, shifting the control of information between the two systems. Along with the <code>variablesState</code> property, the different approaches in this chapter, as covered in <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, provide access to the variables in ink. They can be used in a project, depending on the needs of the developer, to either <a id="_idIndexMarker367"/>drive a Unity project more from the ink side or directly change values on the ink side from the Unity code as needed.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Summary</h1>
			<p>In this chapter, we explored multiple examples. First, we started with the <code>ObserveVariable()</code> method and watched only one variable. In the second section, we dynamically responded to ink stories in Unity. Using delegated functions, we learned how parts of a piece of code will only be called when an ink variable changes. In the third section, we looked at the use of the <code>ObserveVariables()</code> method to watch multiple variables specified by name.</p>
			<p>In <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a>, <em class="italic">Dialogue Systems with ink</em>, we will move away from the individual properties and methods of the Story API and start to combine functionality into more complex use cases. Combining parts of the Unity API introduced in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, along with the <code>ObserveVariable()</code> method covered in this chapter, we will examine how to create different dialogue systems.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Questions</h1>
			<ol>
				<li value="1">What is the action of <em class="italic">observing</em>, and how does it apply to the methods provided by the <code>Story</code> class?</li>
				<li>What roles do delegated functions serve when working with the <code>ObserveVariable()</code> and <code>ObserveVariables()</code> methods?</li>
				<li>What is the difference between the <code>ObserveVariable()</code> method and the <code>ObserveVariables()</code> method?</li>
				<li>What is the difference between accessing ink variables using the <code>variablesState</code> property and using the <code>ObserveVariable()</code> method or the <code>ObserveVariables()</code> method?</li>
			</ol>
		</div>
	</div></body></html>