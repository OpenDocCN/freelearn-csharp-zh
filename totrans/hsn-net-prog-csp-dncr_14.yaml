- en: The Transport Layer - TCP and UDP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层 - TCP和UDP
- en: In previous chapters, we've looked at the interactions of different application
    layer protocols and how to program those interactions in .NET Core. In this chapter,
    we'll go one step closer to the hardware and start looking at transport layer
    protocols with **Transmission Control Protocol** (**TCP**) and **User Datagram
    Protocol** (**UDP**). We'll look at the connection-based and connectionless communication
    patterns that each implements, and we'll look at the strengths and weaknesses
    inherent to each approach. In addition, we'll examine how to write and interact
    with a software client that implements each protocol and use that to extend the
    functionality of our networked applications with custom behavior. Finally, we'll
    look at some of the advanced features of transport layer protocols, such as multicasting,
    for interacting with several hosts simultaneously to improve the performance of
    our network software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们研究了不同应用层协议的交互以及如何在.NET Core中编程这些交互。在本章中，我们将更接近硬件，开始研究传输层协议，即**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。我们将查看每个协议实现的基于连接和无连接通信模式，并查看每种方法固有的优点和缺点。此外，我们将研究如何编写和交互实现每个协议的软件客户端，并使用它来扩展我们的网络应用程序的功能，添加自定义行为。最后，我们将查看传输层协议的一些高级功能，例如多播，以同时与多个主机交互，从而提高我们网络软件的性能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Which responsibilities are delegated to the transport layer and how this layer
    meaningfully differs from the application layer and HTTP/SMTP/FTP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些责任被委派给了传输层，以及这个层如何与应用层、HTTP/SMTP/FTP有意义的区别
- en: The distinction between connection-based and connectionless protocols and the
    challenges they seek to solve
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于连接和无连接协议之间的区别以及它们试图解决的问题
- en: How to initiate a TCP connection and send and receive TCP requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何初始化TCP连接以及发送和接收TCP请求
- en: How to establish and leverage UDP communication in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中建立并利用UDP通信
- en: How to leverage multi-casting to improve performance in our TCP client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用多播来提高我们的TCP客户端的性能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We'll be using sample applications available in the GitHub repo for the book
    here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    11](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2011).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用书中GitHub仓库中可用的示例应用程序：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2011](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2011).
- en: Check out the following video to see the code in action: [http://bit.ly/2HY61eo](http://bit.ly/2HY61eo)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HY61eo](http://bit.ly/2HY61eo)
- en: We'll also be continuing to leverage the tools we used in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml), *Sockets
    and Ports*. Specifically, if you haven't already done so, I recommend installing
    Postman, from here: [https://www.getpostman.com/apps](https://www.getpostman.com/apps)
     Or you can install the Insomnia REST client, which can be found here: [https://insomnia.rest/](https://insomnia.rest/)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将继续使用我们在第8章中使用的工具，即[第8章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)，*套接字和端口*。具体来说，如果你还没有安装，我建议从以下链接安装Postman：[https://www.getpostman.com/apps](https://www.getpostman.com/apps)
    或者你可以安装Insomnia REST客户端，可以在以下链接找到：[https://insomnia.rest/](https://insomnia.rest/)
- en: The transport layer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层
- en: As we start to examine the intricacies of the transport layer, it's important
    to remember one of the most fundamental distinctions between the protocols of
    the transport layer and the protocols of the application layer; specifically,
    the distinction between what kinds of interactions each layer is concerned with. The
    protocols of the application layer are concerned with the communication between
    business objects. They should only deal with the high-level representations of
    your application's domain entities, and how those entities move through your system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始检查传输层的复杂性时，记住传输层协议与应用层协议之间最基本的一个区别是很重要的；具体来说，就是每一层所关心的交互类型。应用层的协议关注的是业务对象之间的通信。它们应该只处理你应用程序领域实体的高级表示，以及这些实体如何通过你的系统移动。
- en: Meanwhile, with transport layer protocols, the concern is around **atomic network
    packets**, which are used to transmit context-agnostic data packets as well as
    to establish and negotiate connections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在传输层协议中，关注的是**原子网络数据包**，这些数据包用于传输与上下文无关的数据包，以及建立和协商连接。
- en: The objectives of the transport layer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层的目标
- en: In all of the application layer protocols we've examined thus far, we've been
    able to make some generous assumptions about the network requests we were transmitting.
    We just assumed that provided our **Uniform Resource Identifier** (**URI**) was
    correct and the remote host was active, we could establish a **connection** to
    our target system. Additionally, we could assume that the connection we established
    was a **reliable** one and that any requests we transmitted would be delivered,
    in their entirety, in such a way as to be readable by the remote host's listening
    application. We could comfortably assume that if an error occurred in transit,
    we would get sufficient information to identify the nature of the error and attempt
    to **correct** it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止所检查的所有应用层协议中，我们都能对所传输的网络请求做出一些宽泛的假设。我们只是假设，只要我们的**统一资源标识符**（**URI**）是正确的，并且远程主机是活跃的，我们就能与目标系统建立**连接**。此外，我们可以假设所建立的连接是**可靠的**，并且我们发送的任何请求都将完整地以可由远程主机监听应用程序读取的方式传递。我们可以舒适地假设，如果在传输过程中发生错误，我们会获得足够的信息来识别错误的性质并尝试**纠正**它。
- en: Let's review if any of these assumptions can also be applied to the transport
    layer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，这些假设是否也可以应用于传输层。
- en: Establishing a connection
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立连接
- en: In the transport layer, we can't make assumptions about an existing connection,
    because that's the layer at which the connections are established in the first
    place. Transport layer protocols are what expose specific ports on the local machine
    and negotiate the delivery of a packet to the designated port of a remote machine.
    If that connection requires a session to be maintained for the duration of the
    interaction, it's the transport layer protocol that's responsible for maintaining
    the state of that session (we'll see more about this when we explore connection-based
    communication).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层，我们不能对现有连接做出假设，因为这是连接最初建立的层。传输层协议是暴露本地机器上的特定端口并协商将数据包传递到远程机器指定端口的协议。如果该连接需要在交互期间保持会话，那么负责维护该会话状态的是传输层协议（我们将在探讨基于连接的通信时了解更多关于这一点）。
- en: Ensuring reliability
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保可靠性
- en: When it comes to reliability, the stable and consistent delivery of network
    packets, and the acceptance of response packets, this the job of the transport
    layer. If a session is broken due to a break in the chain of communication between
    two hosts, transport layer protocols are responsible for attempting to re-establish
    a connection and resume the network session based on its previous state. Transport
    protocols that guarantee successful delivery of packets must accept the responsibility
    of communicating with the transport layer of the remote host to validate that
    the application layer data was received successfully.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到可靠性，即网络数据包的稳定和一致交付以及响应数据包的接受时，这是传输层的职责。如果一个会话由于两个主机之间通信链路的断裂而中断，传输层协议负责尝试重新建立连接并基于其先前状态恢复网络会话。保证数据包成功交付的传输协议必须承担与远程主机传输层通信的责任，以验证应用层数据是否成功接收。
- en: This is especially important for application layer software that treats an open
    connection like a serial data stream. The notion of incoming data being processed
    in order requires that it can be read in order. That means the transport layer
    must have some mechanism for ensuring reliable, same-order delivery of network
    packets.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于将开放连接视为串行数据流的软件层尤为重要。 incoming data being processed in order 的概念要求它可以按顺序读取。这意味着传输层必须有一些机制来确保网络数据包的可靠、顺序交付。
- en: Error correction
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误纠正
- en: 'This reliability is also key to another responsibility of the transport layer:
    error correction. This includes being able to fix discrepancies in data received
    due to complications or interruptions at the network layer of the interaction.
    And, make no mistake, there are a lot of opportunities for potential interference,
    manipulation, or loss of the content of a network packet. The transport layer
    is responsible for mitigating these eventualities and re-requesting a fresh packet
    in the event of corruption. This data correction is usually accomplished with
    a simple `checksum` value, which can give a reliable indicator of any change being
    made to the data in transit.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可靠性也是传输层另一个职责的关键：错误纠正。这包括能够修复由于交互中网络层的复杂或中断引起的数据接收差异。而且，不要误解，网络数据包内容受到干扰、操纵或丢失的机会有很多。传输层负责减轻这些可能性，并在数据损坏的情况下重新请求新的数据包。这种数据校正通常通过简单的`校验和`值来完成，它可以提供一个可靠的指标，表明正在对传输中的数据进行更改。
- en: Error handling should also be present to ensure the reliable ordering of packets.
    Because physical network infrastructure can, and often does, route multiple requests
    from one single host to another over multiple available network connections, and
    through multiple different switches, it's not uncommon for a packet that was sent
    later in the stream to arrive before packets that were sent earlier. The transport
    layer must have some way of identifying when that has happened, and be able to
    re-request the missing packet or re-arrange the received packets into their proper
    ordering.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理也应该存在，以确保数据包的可靠顺序。因为物理网络基础设施可以，并且经常这样做，将来自单个主机的多个请求通过多个可用的网络连接，以及通过多个不同的交换机路由到另一个主机，因此，在流中发送较晚的数据包先于较早发送的数据包到达并不罕见。传输层必须有一种方法来识别这种情况何时发生，并且能够重新请求丢失的数据包或重新排列接收到的数据包以恢复其正确的顺序。
- en: Managing traffic
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理流量
- en: It might not be obvious initially, but when we talk about thousands of ports
    being available to listen on a given machine, those thousands of ports exist only
    virtually. Obviously, there aren't 65, 536 wires plugged into the motherboard
    of your PC. Those ports are just a way for your (usually only one) network adapter
    to route traffic to the appropriate process currently running on your operating
    system. All incoming and outgoing network traffic has to pass through that single
    network adapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能并不明显，但当我们谈论在给定的机器上可用的数千个端口用于监听时，这些数千个端口仅存在于虚拟上。显然，你的PC主板并没有插入65,536根线。这些端口只是你的（通常只有一个）网络适配器将流量路由到当前正在操作系统上运行的适当进程的一种方式。所有传入和传出的网络流量都必须通过这个单一的网络适配器。
- en: While it's the network layer software that manages direct traffic control, it
    typically does so by only provisioning access to the physical connection in short
    segments of uptime for the transport layer. It's the job of the transport layer
    software to manage a queue of incoming, unprocessed data, as well as one for outbound
    requests, and provision their delivery to the network layer when the resources
    are made available to do so. This use of resources with limited, intermittent
    availability can be a major boost to performance when done well, and a major bottleneck
    when implemented poorly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网络层软件负责管理直接流量控制，但它通常只通过为传输层提供在短暂的上时间段内访问物理连接的方式来这样做。传输层软件的职责是管理一个待处理的传入数据队列，以及一个传出请求队列，并在资源可用时将它们交付给网络层。这种使用有限、间歇性可用的资源的方法，如果做得好，可以大幅提升性能，如果实施不当，则可能成为性能瓶颈。
- en: Segmentation of data
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分段
- en: As I mentioned when I discussed this topic in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml),
    *Communication Protocols*, the large, contiguous objects that are used to encapsulate
    data at the application layer are unsuitable for transport over a network. If
    you tried to block your network adapter for the duration of the transport of a
    20 MB file, or a 13 GB file for that matter, the impact on the performance of
    any other network-dependent software on your machine would be absolutely unacceptable.
    Attempting to do so would block operations for any outgoing or incoming requests
    for far too long.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)“通信协议”中讨论这个主题时提到的，用于在应用层封装数据的庞大、连续的对象不适合在网络中传输。如果你试图在传输20
    MB文件或13 GB文件期间阻塞你的网络适配器，那么对机器上任何其他依赖网络的软件性能的影响将是绝对不可接受的。这样做会阻塞任何传入或传出的请求，时间过长。
- en: While application layer protocols can send massive payloads with all of their
    requests and just assume they'll be delivered correctly, the same cannot be said
    of transport layer packets. There is no other intermediary between the transport
    layer and the network adapter, so it's the responsibility of the transport layer
    to decompose large request payloads into smaller, discrete network packets that
    are suitable for transport over the network layer. This means that transport layer
    protocols have the added responsibility of applying sufficient context for the
    decomposed packets of an application layer payload to be reconstructed by the
    recipient machine, regardless of delivery order, typically accomplished with packet
    headers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用层协议可以在所有请求中发送大量有效载荷并假设它们会被正确交付，但传输层的数据包却不能这么说。在传输层和网络适配器之间没有其他中介，因此传输层的责任是将大型请求有效载荷分解成更小、离散的网络数据包，以便在网络层传输。这意味着传输层协议还承担了应用层有效载荷分解数据包的附加责任，以便接收机器能够重建这些数据包，无论交付顺序如何，通常通过数据包头部完成。
- en: This isn't typically something you'll be implementing yourself with a language
    as high-level as C#, but understanding that it is going on behind the scenes will
    make concepts such as packet-sniffing and network-tracing much easier to grasp
    down the line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在像C#这样的高级语言中，这通常不是你自己实现的内容，但了解幕后发生的事情将使得理解诸如数据包嗅探和网络跟踪等概念变得更加容易。
- en: The classes of transport layer protocols
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层协议的类别
- en: While we just discussed a number of responsibilities that transport layer protocols
    might assume, not every protocol at the transport layer implements every one of
    these features. Since it's important to understand what optional features will
    be available in a given implementation, standards organizations have defined a
    classification system for connection mode protocols based on the features they
    implement. According to this classification scheme, there are five different classes
    of connection mode (or transport layer) protocols, with each implementing different
    combinations of the list of services that a transport protocol might implement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚讨论了传输层协议可能承担的许多责任，但并非每个传输层的协议都实现了这些功能中的每一个。由于了解给定实现中可用的可选功能很重要，因此标准组织根据它们实现的特性定义了一个连接模式协议的分类系统。根据这个分类方案，存在五种不同的连接模式（或传输层）协议类别，每个类别实现传输协议可能实现的服务列表的不同组合。
- en: Defining the classification scheme for different implementation classes of transport
    protocols was actually a joint effort between standards organizations. The **International
    Organization for Standardization** (**ISO**), along with the **International Telecommunication
    Union** (**ITU**), issued recommendation X.224 for this exact purpose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 定义传输协议不同实现类的分类方案实际上是标准组织的一项联合努力。**国际标准化组织**（**ISO**）和**国际电信联盟**（**ITU**）共同发布了X.224建议，用于此特定目的。
- en: The list of classifications is zero-indexed, from class `0` to class `4`, and
    they are described as follows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 分类列表从零索引，从类`0`到类`4`，它们的描述如下。
- en: Class 0 – Simple class
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单类
- en: This is described as providing the simplest type of transport connection, with
    sufficient data segmentation. It is explicitly described in the standard as being
    suitable only for network connections with acceptable residual error rate and
    an acceptable rate of signaled errors. Basically, given the simplicity of the
    protocol, it is only suitable for use on highly reliable local networks with nearly
    guaranteed error-free connections between hosts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这被描述为提供最简单的传输连接类型，具有足够的数据分段。标准中明确指出，它仅适用于具有可接受残余错误率和可接受信号错误率的网络连接。
- en: Class 1 – Basic recovery class
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本恢复类
- en: Protocols that fall under class `1` are specified to provide basic transport
    connection with minimal overhead. However, what distinguishes class `1` from class
    `0` is that class `1` protocols are expected to recover from signaled errors,
    or errors that are immediately detectable, such as a network disconnection or
    a network reset. Protocols of this class are sufficient for use on networks with
    an acceptable residual error rate, but an unacceptable rate of signaled errors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类 `1` 的协议被指定提供具有最小开销的基本传输连接。然而，将类 `1` 与类 `0` 区分开来的是，类 `1` 协议预计可以从信号错误中恢复，或立即可检测到的错误，例如网络断开或网络重置。此类协议适用于具有可接受残余错误率的网络，但信号错误率不可接受。
- en: Class 2 – Multiplexing class
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类 `2` – 复用类
- en: The defining characteristic of class `2` protocols is their ability to multiplex
    several transport connections on to a single network connection. It's designed
    to work on the same exceptionally reliable networks as class `0` protocols. Because
    of the potential for multiple network connections to be leveraged over a single
    transport layer protocol, protocols within this classification may end up leveraging
    explicit flow control for the optimized use of the network layer resources. However,
    that explicit flow control is not a guaranteed property of class `2` protocols.
    In fact, it may be avoided in cases where multiplexing isn't necessary, as not
    managing flow control explicitly can reduce the overhead applied to packets in
    transit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `2` 协议的标志性特征是它们能够在单个网络连接上复用多个传输连接。它旨在与类 `0` 协议一样，在极其可靠的网络环境中工作。由于可能利用单个传输层协议上的多个网络连接，此类分类中的协议最终可能会利用显式的流量控制来优化网络层资源的利用。然而，这种显式的流量控制并不是类
    `2` 协议的保证属性。实际上，在不需要复用的情况下可能会避免使用它，因为不显式管理流量控制可以减少传输中的数据包开销。
- en: Class 3 – Error recovery and the multiplexing class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类 `3` – 错误恢复和复用类
- en: The multiplexing class is, essentially, a combination of classes `1` and `2`.
    Protocols in class `3` introduce the performance benefits (or packet overhead)
    of the class `2` multiplexing functionality into a protocol with sufficient error
    recovery for a network with less-reliable signaled error rates, where class `1`
    would otherwise be preferred.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 复用类本质上是由类 `1` 和 `2` 组合而成的。类 `3` 的协议将类 `2` 复用功能（或数据包开销）的性能优势引入到具有足够错误恢复能力的协议中，适用于信号错误率较低且类
    `1` 可能更受欢迎的网络。
- en: Class 4 – Detecting errors and recovery class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类 `4` – 检测错误和恢复类
- en: 'Class `4` protocols are by far the most robust of any protocol. They are explicitly
    stated to be suitable for networks with an unacceptable residual error rate and
    an unacceptable signal error rate, which is to say, basically, any large-scale
    distributed network with a high probability of interference of interruption of
    service. Given the suitability of a class `4` protocol for use on such an unreliable
    network, it should come as no surprise that class `4` protocols are expected to
    both detect, and recover from, errors on the network. The errors for which a class
    `4` protocol should provide recovery include, but are not limited to, the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `4` 协议是所有协议中最稳健的。它们明确指出，适用于具有不可接受的残余错误率和信号错误率（即，基本上是任何具有高干扰或服务中断概率的大规模分布式网络）的网络。鉴于类
    `4` 协议适用于在如此不可靠的网络中使用，因此预期类 `4` 协议能够检测并从网络错误中恢复。类 `4` 协议应提供恢复的错误包括但不限于以下内容：
- en: Data packet loss
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包丢失
- en: Delivery of a data packet out of sequence in a data stream
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流中数据包的顺序错误
- en: Data packet duplication
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包重复
- en: Data packet corruption
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包损坏
- en: Protocols in class `4` are also expected to provide the highest degree of resiliency
    against network failure, as well as increased throughput by way of improved multiplexing
    and packet segmentation. Needless to say, this is also the class of transport
    layer protocols with the highest amount of per-packet overhead introduced with
    each transaction over the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `4` 的协议还预期提供对网络故障的最高程度弹性，以及通过改进的复用和分段提高的吞吐量。不用说，这也是在每次网络事务中引入每数据包开销最高的传输层协议类别。
- en: Interestingly, the classification of a protocol only determines the minimum
    set of services you should expect the protocol to implement. That doesn't preclude
    that protocol from implementing a broader set of services than specified by its
    classification. Such is the case with TCP, which actually provides a handful of
    additional services that might be provisioned by software higher up in the network
    stack under more rigid implementations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，协议的分类仅决定了你应该期望该协议实现的最低服务集。这并不排除该协议实现比其分类指定的更广泛的服务集。TCP 就是这种情况，它实际上提供了一些额外的服务，这些服务可能在网络堆栈更高层的软件中提供更严格的实现。
- en: 'Class `4` captures both TCP/IP, which is broadly considered the most robust
    (or at least the most complex/complicated) transport layer protocol in wide use
    today, as well as UDP, which is its connectionless peer in terms of broad support
    and adoption. These are the classes of transport layer protocols you''ll be interacting
    with directly when working in C#. To that end, let''s look at perhaps the biggest
    distinction between TCP and UDP: their connection-based and connectionless communication
    patterns. In doing so, we''ll have a much better idea of when and how to leverage
    each protocol.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `4` 捕获了 TCP/IP，这被广泛认为是目前广泛使用的最稳健（或者至少是最复杂/复杂的）传输层协议，以及 UDP，它在广泛支持和采用方面是 TCP
    的无连接对等。这些是你在使用 C# 工作时将直接交互的传输层协议类别。为此，让我们来看看 TCP 和 UDP 之间可能的最大区别：它们的基于连接和无连接通信模式。通过这样做，我们将对何时以及如何利用每个协议有一个更好的了解。
- en: Connection-based and connectionless communication
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于连接和无连接的通信
- en: There are two primary transport layer protocols we'll be working with in C#.
    The first is the TCP. Commonly called TCP/IP due to its prevalent use on the internet-based
    network software and tight coupling with the **Internet Protocol** (**IP**), TCP
    is the transport layer protocol underlying all of the application layer protocols
    we've looked at so far. The second protocol we'll be looking at is the  UDP. It
    stands as an alternative approach to TCP with respect to transport layer implementations,
    aiming to provide better performance in more tightly constrained use cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，我们将使用两种主要的传输层协议。第一个是 TCP。由于它在基于互联网的网络软件中的普遍使用以及与**互联网协议**（**IP**）的紧密耦合，通常被称为
    TCP/IP，TCP 是我们迄今为止查看的所有应用层协议背后的传输层协议。我们将查看的第二种协议是 UDP。它作为 TCP 在传输层实现方面的替代方法，旨在在更严格的用例中提供更好的性能。
- en: The primary distinction between these two protocols, however, is that TCP operates
    in what's known as a **connection-based communication mode**, whereas UDP operates
    in what's called a **connectionless communication mode**. So, what exactly are
    these communication modes?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种协议的主要区别在于，TCP 在所谓的**基于连接的通信模式**下运行，而 UDP 在所谓的**无连接通信模式**下运行。那么，这些通信模式究竟是什么？
- en: Connection-based communication
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于连接的通信
- en: It may seem obvious what connection-based communication is at first glance.
    By its name, you might conclude it's just any communication that leverages a connection
    between two hosts. But what exactly do we mean when we say *connection*? It can't
    simply be some physical route between two hosts. After all, under that definition,
    how could two hosts communicate without connecting in some way? How would data
    travel between two machines if not over a connection?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，基于连接的通信可能看起来很明显。从其名称来看，你可能会得出结论，它只是利用两个主机之间连接的任何通信。但当我们说“连接”时，我们究竟指的是什么？它不能仅仅是两个主机之间的一些物理路径。毕竟，根据那个定义，两个主机如果不能以某种方式连接，它们如何进行通信？如果不在连接上，数据如何在两台机器之间传输？
- en: The shortcomings of such a definition become even more obvious when you consider
    that connectionless communication is a valid mode of communication. With that
    point in mind, it's apparent that a connection, in this context, must refer to
    more than a simple channel between two hosts for data to travel across. So, then,
    what exactly is a connection? How do connection-based modes of communication leverage
    it?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑到无连接通信是一种有效的通信模式时，这种定义的不足之处变得更加明显。考虑到这一点，很明显，在这个上下文中，“连接”必须指的不仅仅是两个主机之间用于数据传输的简单通道。那么，究竟什么是连接？基于连接的通信模式是如何利用它的？
- en: Connections to establish sessions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立会话的连接
- en: For the purposes of clarity and understanding, I think we would benefit from
    thinking of a connection as a session*.* In connection-oriented protocols, a session
    must first be established between the two hosts prior to any meaningful work being
    done. That session must be negotiated with a handshake between the two hosts,
    and it should coordinate the nature of the pending data transfer. The session
    allows the two hosts to determine what, if any, orchestration must happen between
    the two machines over the lifetime of the request to fulfill the request reliably.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰和易于理解，我认为我们将连接视为一个会话会很有帮助。在面向连接的协议中，在执行任何有意义的操作之前，必须在两个主机之间建立会话。这个会话必须通过两个主机之间的握手来协商，并且应该协调待传输数据传输的性质。会话允许两个主机确定在请求的生命周期内，两台机器之间是否需要发生任何协调，以确保可靠地完成请求。
- en: Once the session is established, the benefits of a connection-based communication
    mechanism can be realized. This includes a guarantee of the ordered delivery of
    data, as well as the reliable re-transmission of lost data packets. This can happen
    because the session context gives both machines an interaction mechanism that
    will allow them to communicate when a message has been delivered and received.
    This shared, active context is important for our understanding of connection-based
    protocols, so let's look at how that session context is provisioned by the underlying
    network layer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了会话，就可以实现基于连接的通信机制的好处。这包括保证数据按顺序交付，以及可靠地重传丢失的数据包。这是因为会话上下文为两台机器提供了一个交互机制，允许它们在消息被发送和接收时进行通信。这种共享的、活跃的上下文对于我们理解基于连接的协议非常重要，所以让我们看看底层网络层是如何提供会话上下文的。
- en: Circuit-switched versus packet-switched connections
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路交换与分组交换连接
- en: There are two ways that a session is provided for two hosts wanting to establish
    a connection. The first is to establish the session by way of a direct, hardware
    circuit link between hosts. This is what's known as a **circuit-switched connection**.
    The data needs no routing information applied to the header because it travels
    over a closed circuit between the two devices. This physical circuit connection
    is how public telephone networks were set up to establish connections. If you've
    ever seen old photographs of telephone operators using quarter-inch cables to
    connect two different ports in a gigantic circuit board, you've seen this exact
    routing mechanism in action (albeit in a very primitive implementation).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为想要建立连接的两个主机提供会话有两种方式。第一种是通过主机之间的直接硬件电路链路来建立会话。这就是所谓的**电路交换连接**。数据不需要在头部应用路由信息，因为它在两个设备之间的闭合电路中传输。这种物理电路连接是公共电话网络建立连接的方式。如果你曾经见过老照片中电话操作员使用四分之一英寸的电缆连接巨大电路板上的两个不同端口，你就已经看到了这种精确的路由机制在起作用（尽管是一种非常原始的实现）。
- en: Establishing exclusive, direct, physical connections between two hosts has a
    lot of benefits. It guarantees that all packets will arrive in constant time since
    there's no downtime for intermediary routers and switches to parse the addressing
    information of the packet, or to wait for an opening in the data channel. It also
    guarantees the ordering of packets, since each one will travel across the same
    channel exactly ahead of the next packet transmitted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个主机之间建立专有的、直接的物理连接有很多好处。它保证了所有数据包将在恒定的时间内到达，因为没有中间路由器和交换机需要解析数据包的寻址信息，或者等待数据通道的空闲。它还保证了数据包的顺序，因为每个数据包将正好在下一个传输的数据包之前通过相同的通道传输。
- en: The downside to this kind of connection-based communication, of course, is that
    it is incredibly costly to implement. There must be a mechanism at every possible
    intersection on the network to establish a dedicated circuit between any two other
    connections without interfering with other possible connections that may pass
    through that same intersection. Separately, it is incredibly costly to manage
    the mechanical switching necessary to engage and disengage a specific circuit
    as connections are established and closed. Thus, these kinds of physical networks
    haven't been in wide use for computational networks in decades.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种基于连接的通信方式的缺点是，其实施成本非常高。必须在网络上的每个可能交点处有一个机制，以建立任何两个其他连接之间的专用电路，而不会干扰可能通过该交点的其他连接。另外，在连接建立和关闭时，管理连接和断开特定电路所需的机械交换成本也非常高。因此，这类物理网络在几十年来都没有在计算网络中得到广泛应用。
- en: The alternative approach is what's known as a **packet-switched connection**.
    These connections are established through the use of hardware switches and software
    deployed on routing devices that virtualize the behavior or a circuit-switched
    connection. With connection mode, routers and switches set up an in-memory circuit
    that manages a queue of all inbound requests for a target location. Those devices
    parse the addressing information of each incoming packet and pass it into the
    queue for the appropriate circuit accordingly, and then forward along messages
    from those queues, in order, as soon as the physical resources become available.
    In doing so, the expectations for the behavior of a physical circuit-switched
    connection are maintained. So, for any software that is written to leverage a
    connection-based communication scheme, there's no functional difference between
    a circuit-switched connection or a packet-switched connection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是所谓的**分组交换连接**。这些连接是通过在路由设备上使用硬件交换机和部署的软件来虚拟化电路交换连接的行为来建立的。在连接模式下，路由器和交换机设置一个内存中的电路，管理所有针对目标位置的入站请求队列。这些设备解析每个入站数据包的寻址信息，并相应地将其传递到队列中，然后一旦物理资源可用，就按顺序从队列中转发消息。通过这样做，保持了物理电路交换连接的行为预期。因此，对于任何编写以利用基于连接的通信方案的软件，电路交换连接和分组交换连接之间没有功能上的区别。
- en: With this virtualization, the costs of implementing circuit-switched connection
    functionality at a physical level are mitigated. Of course, by mitigating the
    physical costs of a circuit-switch setup, we pay for it in performance costs.
    With packet-switched connections, there's added overhead with each connection
    because each packet must be parsed by each switch in the network path between
    the two hosts. Moreover, unless there is no other traffic on a given network switch,
    there is undoubtedly going to be downtime for a packet-switched connection every
    time the packets associated with that connection are put into a queue to wait
    for physical resources to be made available. However, as most of these operations
    are implemented at a firmware level, the total time cost for any given connection
    is actually reasonably small. This model of a packet-switched network describes
    almost all modern **Wide-area networks** (**WAN**), including the internet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种虚拟化，物理层面上实现电路交换连接功能的开销得到了缓解。当然，通过减轻电路交换设置的物理成本，我们在性能成本上做出了补偿。在分组交换连接中，每个连接都会增加额外的开销，因为每个数据包必须由两个主机之间网络路径上的每个交换机进行解析。此外，除非给定网络交换机上没有其他流量，否则每次将与此连接相关的数据包放入队列等待物理资源可用时，分组交换连接无疑将出现停机时间。然而，由于这些操作大多在固件级别实现，任何给定连接的总时间成本实际上相当小。这种分组交换网络的模型几乎描述了所有现代**广域网**（**WAN**），包括互联网。
- en: TCP as a connection-oriented protocol
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为面向连接的协议，TCP
- en: Establishing a connection is one of the most important functions a TCP implementation
    provides for application-layer software that is leveraging it. When the TCP layer
    breaks up a request into packets and applies its headers, it does so on the assumption
    that the packets will be sent over a packet-switched network.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接是TCP实现为利用它的应用层软件提供的重要功能之一。当TCP层将请求分解成数据包并应用其头部信息时，它是基于假设这些数据包将通过分组交换网络发送的。
- en: 'That means it must be certain that switches and routers along the network path
    have provisioned a virtual circuit for each payload between the two hosts. This
    certainty is provided by a multi-step handshake between the two hosts. The specific
    details of the handshake are a bit more complicated, but it can be boiled down
    to three fundamental transactions for each step in the process:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着网络路径上的交换机和路由器必须为两个主机之间的每个有效载荷预先配置一个虚拟电路。这种确定性是通过两个主机之间多步骤握手来提供的。握手的具体细节稍微复杂一些，但可以简化为过程中每一步的三个基本事务：
- en: '**SYN**: This stands for **synchronization** and is a request sent from the
    client to the server indicating a desire to establish a connection. The synchronization
    happens because the client generates a random integer, *n,* and transmits it along
    in the SYN request as a sequence number, which the server uses to establish that
    the appropriate message was received.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SYN**：这代表**同步**，是客户端发送给服务器的请求，表明希望建立连接。同步发生是因为客户端生成一个随机整数，*n*，并将其作为序列号传输在SYN请求中，服务器使用这个序列号来确认接收到了适当的消息。'
- en: '**SYN-ACK**: This stands for **synchronization and acknowledgment** and is
    the response a server sends to an initial SYN request. To acknowledge that the
    request was received in the same state it was sent, the server increments and
    then returns the random synchronization integer it received from the client, *n+1*,
    as the acknowledgment message. It also sends a random integer of its own, *m,*
    as the sequence number.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SYN-ACK**：这代表**同步和确认**，是服务器对初始SYN请求的响应。为了确认请求是以发送时的相同状态接收的，服务器增加并返回它从客户端接收到的随机同步整数，*n+1*，作为确认消息。它还发送它自己的随机整数，*m*，作为序列号。'
- en: '**ACK**: At this point, the client acknowledges that its own synchronization
    request was sent and received correctly, and confirms the same for the server
    by sending a payload setting the sequence number to the acknowledgment value it
    received from the server, *n+1*, and then incrementing and returning the sequence
    number from the server as its own acknowledgment value, *m+1*.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ACK**：在这个时候，客户端确认其同步请求已被正确发送和接收，并通过发送一个设置序列号为从服务器接收到的确认值，*n+1*，然后增加并返回服务器的序列号作为它自己的确认值，*m+1*，来确认服务器的同步请求也被正确接收。'
- en: Once these three signals have been sent and received accordingly, the connection
    has been established and data transfer can proceed accordingly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些三个信号已经发送并相应接收，连接就已经建立，数据传输可以相应进行。
- en: Having this agreement between two hosts prior to data transmission is what allows
    TCP to achieve the resiliency that sets it apart from UDP. Since the host knows
    to expect an ordered sequence of packets, it can re-arrange packets that were
    received out of order once they arrive to ensure they are delivered in the appropriate
    order to the higher-level protocols that are expecting them. Moreover, if it doesn't
    receive all of the packets it's expecting, it can identify the missing packets
    based on the missing sequence numbers, and request re-transmission of exactly
    what was lost. Finally, this initialization of a connection gives the server an
    opportunity to communicate information about its processing capability and maximum
    throughput. By telling the client how much data can be processed at any given
    time, the client can throttle its own output to minimize data loss and network
    congestion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据传输之前，两个主机之间达成这种协议是TCP能够实现其与UDP区别开来的弹性的原因。由于主机知道要期待一个有序的包序列，它可以在包到达后重新排列那些顺序错误的包，以确保它们以适当的顺序传递给期待它们的上层协议。此外，如果它没有收到它所期待的包，它可以基于缺失的序列号识别出缺失的包，并请求重新传输丢失的部分。最后，这种连接的初始化给了服务器一个机会来传达其处理能力和最大吞吐量的信息。通过告诉客户端在任何给定时间内可以处理多少数据，客户端可以调节自己的输出以最小化数据丢失和网络拥塞。
- en: The obvious downside, of course, is that all of these steps to establishing
    and leveraging a connection-parsing sequence of numbers and re-ordering data streams
    accordingly, and re-transmitting data, incurs a major time cost for the interactions.
    When such reliability is necessary (and in most enterprise network software, it
    is), you have no other choice but to leverage TCP or similarly resilient protocols.
    However, when the nature of your software, or the network infrastructure supporting
    it, can support less reliability, you have many high-performing alternatives for
    transport-layer protocols.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些步骤的缺点是，为了建立和利用连接解析数字序列、相应地重新排序数据流以及重新传输数据，这些步骤会为交互带来重大的时间成本。当这种可靠性是必要的（在大多数企业网络软件中，它确实是必要的）时，你别无选择，只能利用TCP或类似健壮的协议。然而，当你的软件或支持它的网络基础设施的性质可以支持更低的可靠性时，你有许多高性能的传输层协议替代方案。
- en: Connectionless communication
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无连接通信
- en: 'As we previously established, a connection in transport-layer communication
    can be thought of instead as a session for communication. Thus, **connectionless
    communication** is a mode of communication in which data is transmitted without
    first establishing a mutual session between hosts. Instead, packets are sent out
    with their appropriate addressing information, and the responsibility of ensuring
    delivery falls entirely to the lower layers of the network stack. This obviously
    introduces the risk of a failed delivery being undetected: since, without any
    acknowledgment expected from the server, the client wouldn''t know the packet
    delivery failed and required re-transmission, whereas without synchronizing a
    session first, the server wouldn''t know to expect an inbound message. So, why
    is this mechanism used, and when is this sort of risk acceptable?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所确定的，传输层通信中的连接可以被视为一个会话。因此，**无连接通信**是一种通信模式，其中数据在首先在主机之间建立相互会话之前被传输。相反，数据包会带有适当的寻址信息被发送出去，确保交付的责任完全落在网络堆栈的底层。这显然引入了交付失败未被检测到的风险：因为没有期望从服务器那里得到任何确认，客户端不会知道数据包交付失败并需要重传，而如果没有首先同步会话，服务器也不会知道期待一个传入的消息。那么，为什么这种机制会被使用，何时这种风险是可以接受的？
- en: Stateless protocols
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态协议
- en: Without any session to manage, connectionless protocols are typically described
    as being stateless. Without a state to manage, each transaction happens without
    any broader context telling the recipient how an individual packet fits into the
    wider stream of incoming packets. As such, there is almost no ability to determine
    and ensure the proper sequencing of packets for re-construction by the recipient.
    Without that ability, connectionless protocols are typically leveraged in cases
    where packets can be wholly self-contained, or where the information lost in a
    dropped packet can be reconstructed by the recipient application based on the
    next packet received.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有任何会话需要管理，无连接协议通常被描述为无状态的。没有状态需要管理，每个事务都发生在一个更广泛的上下文中，这个上下文不会告诉接收者单个数据包如何适合到更广泛的接收数据包流中。因此，几乎无法确定并确保数据包的正确顺序，以便接收者可以重新构建。没有这种能力，无连接协议通常用于数据包可以完全自包含，或者丢失的数据包中丢失的信息可以根据接收到的下一个数据包由接收应用程序重建的情况。
- en: In the latter case, we can account for the statelessness of the protocol with
    state management in our applications. For example, imagine your server hosting
    an application that keeps track of a deterministic state. Now let's say that state
    is updated by a remote client, and those updates are sent in real time, with minimum
    latency, over a connectionless protocol, such as UDP. Because the state of the
    application is deterministic, if a single packet is lost, the server may still
    be able to determine which update was made based on the next packet received if
    its own update could only be reached from a specific state set in the lost packet.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，我们可以通过在我们的应用程序中实现状态管理来解释协议的无状态性。例如，想象一下你的服务器托管一个跟踪确定状态的应用程序。现在假设这个状态是由远程客户端更新的，并且这些更新通过无连接协议（如UDP）以最小延迟实时发送。由于应用程序的状态是确定的，如果丢失单个数据包，服务器仍然可以根据接收到的下一个数据包确定是哪个更新，前提是它自己的更新只能从丢失数据包中设置的具体状态到达。
- en: Using this architecture, there would be a time cost incurred by the application,
    as every time a packet was lost, some processing would need to happen to deduce
    the value of the lost packet and update its internal state accordingly. However,
    in cases where the network is reliable enough that packet loss is an infrequent
    occurrence, the reduced latency of a connectionless communication mode can more
    than make up for the occasional processing cost of a dropped packet over the lifetime
    of the application. So, on a reliable enough connection, the trade-off could prove
    extremely worthwhile. While less common in business applications, these protocols
    are frequently leveraged in high-throughput, low-latency interactive applications
    such as networked multiplayer video games.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构，应用程序会因每次数据包丢失而产生时间成本，因为需要一些处理来推断丢失数据包的值并相应地更新其内部状态。然而，在网络足够可靠，数据包丢失是罕见事件的情况下，无连接通信模式的降低延迟可以远远弥补应用程序生命周期中偶尔丢失数据包的处理成本。因此，在足够可靠的连接上，这种权衡可能证明极其有价值。虽然这些协议在商业应用中不太常见，但它们在需要高吞吐量和低延迟的交互式应用中，如网络多人视频游戏，经常被利用。
- en: Broadcasting over connectionless communication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在无连接通信中进行广播
- en: One of the benefits of this lack of shared state being managed between two hosts
    is the ability of connectionless communication to multicast. In this way, a single
    host can transmit the same packet out to multiple recipients simultaneously, as
    the outbound port isn't bound by a single active connection with a single other
    host. This multicasting, or broadcasting, is especially useful for services such
    as a live video stream or feed, where a single source server is transmitting to
    an arbitrary number of potential consumers simultaneously. With the already-low
    overhead of connectionless packet transmission, this can allow high throughput
    of data to a broad spectrum of consumers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏在两个主机之间共享状态管理的优点之一是，无连接通信能够进行多播。通过这种方式，单个主机可以同时向多个接收者发送相同的数据包，因为出站端口不受与单个其他主机单一活跃连接的限制。这种多播或广播对于像实时视频流或数据源这样的服务特别有用，其中单个源服务器可以同时向任意数量的潜在消费者发送数据。由于无连接数据包传输的低开销，这可以允许向广泛的消费者提供高吞吐量的数据。
- en: Establishing connections over connectionless communication
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在无连接通信中建立连接
- en: If you're anything like me, you probably noticed a bit of a chicken-and-egg
    problem with connection-based communication modes as I initially described them.
    Specifically, how can you establish a session between two hosts that rely on connection-based
    communication without first having a session between those two hosts?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你可能注意到了我最初描述的基于连接的通信模式中存在一点鸡生蛋的问题。具体来说，在没有两个主机之间的会话的情况下，如何在这两个主机之间建立基于连接的会话？
- en: Of course, the obvious answer is that connections are established by way of
    an initial, connectionless communication request. The initial SYN message of a
    TCP connection request is sent over the connectionless communication IP. In this
    way, you could say that connection-based communication is built on the back of
    connectionless communication. In fact, in the case of TCP, the connection-based
    interactions are so dependent on the connectionless interactions of IP that the
    two are typically lumped together and identified as the TCP/IP suite.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最初的答案是，通过初始的无连接通信请求来建立连接。TCP连接请求的初始SYN消息是通过无连接通信IP发送的。通过这种方式，可以说基于连接的通信建立在无连接通信的基础上。事实上，在TCP的情况下，基于连接的交互如此依赖于IP的无连接交互，以至于这两个通常被合并并标识为TCP/IP套件。
- en: UDP as a connectionless communication protocol
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP作为无连接通信协议
- en: Just as TCP is the connection-based communication protocol of choice on the
    internet, UDP often serves as the connectionless communication protocol of choice.
    UDP exhibits all of the expected traits of a connectionless protocol, including
    the lack of any handshake or session negotiation prior to data transfer, and minimal
    error-checking and error correction techniques. So, what are the contexts in which
    UDP is useful?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像TCP是互联网上首选的基于连接的通信协议一样，UDP通常作为首选的无连接通信协议。UDP表现出所有预期无连接协议的特性，包括在数据传输之前没有任何握手或会话协商，以及最小化的错误检查和错误纠正技术。那么，UDP在哪些情况下是有用的呢？
- en: The need for such speed and the acceptability of intermittent packet loss is
    perfectly suited to low-level network operations to send out notifications or
    basic queries of other devices on the network. It's for that reason that UDP is
    the protocol of choice for **Domain Name System** (**DNS**) lookups and the **Dynamic
    Host Configuration Protocol** (**DHCP**). In both of these contexts, the requesting
    host needs an immediate response to a single, simple query. In the case of DNS
    lookup, the request is for each IP address registered for a given domain name.
    The UDP packet can simply address the DNS server directly, and can contain only
    the domain name of the resource being looked up. Once that information is received,
    the DNS server can respond with addressing information on its own time, trusting
    that whichever application requested the IP addresses will likely be listening
    for the response. Once the DNS lookup request is initially sent out by the client,
    if there's been no response after a given timeout period, an identical packet
    will be transmitted from the client. This way, in the off-chance of a lost packet,
    there's a mechanism for error recovery (the timeout period); meanwhile, in the
    far-more-likely scenario that the packet is successfully transmitted, the query
    result will be returned substantially faster than if a connection were established
    first.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种速度的需求以及可接受的间歇性数据包丢失，非常适合低级网络操作，用于发送通知或对网络中其他设备的基本查询。这就是为什么UDP是域名系统（**DNS**）查找和动态主机配置协议（**DHCP**）的首选协议。在这两种情况下，请求主机需要立即对单个简单查询做出响应。在DNS查找的情况下，请求是针对给定域名注册的每个IP地址。UDP数据包可以直接指向DNS服务器，并且只包含正在查找的资源域名。一旦收到这些信息，DNS服务器可以在自己的时间响应，相信请求IP地址的应用程序可能会监听响应。一旦客户端最初发送DNS查找请求，如果在给定超时期间没有收到响应，客户端将发送一个相同的包。这样，在数据包丢失的情况下，有一个错误恢复机制（超时期）；同时，在数据包成功传输的更可能的情况下，查询结果将比首先建立连接返回得更快。
- en: This same behavior is what enables a DHCP request to be satisfied in near-real
    time. When a new network device requests an IP address from the DHCP server, it
    has no specific information about the other devices on its own network. Therefore,
    it must broadcast out a DHCP request and hope that an adjacent node is available
    to act as the DHCP server and provision an IP address for the device. These needs,
    for low-latency and the need to broadcast packets, mean that DHCP requests are
    the ideal use case for a connectionless protocol such as UDP.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的行为使得DHCP请求能够在近乎实时的情况下得到满足。当一个新网络设备从DHCP服务器请求IP地址时，它对自己的网络中其他设备没有任何具体信息。因此，它必须广播一个DHCP请求，并希望相邻的节点可以作为DHCP服务器并为该设备分配一个IP地址。这些需求，对于低延迟和广播数据包的需求，意味着DHCP请求是UDP等无连接协议的理想用例。
- en: Detecting errors in connectionless protocols
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测无连接协议中的错误
- en: I have discussed at length that connectionless transport layer protocols are
    far more susceptible to errors, as there is no mechanism inherent to the protocol
    for detecting errors. I've already discussed how we can detect and even correct
    for errors in a connectionless transport layer protocol from the application layer
    that's leveraging it. However, at least within UDP, there is at least one simple
    error-detection mechanism transmitted with each packet, and that is a **checksum**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经详细讨论过，无连接传输层协议更容易出错，因为协议本身没有检测错误的机制。我已经讨论了如何从利用它的应用层检测和纠正无连接传输层协议中的错误。然而，至少在UDP中，每个数据包至少包含一个简单的错误检测机制，那就是**校验和**。
- en: If you've never heard the term before, a checksum is similar to a hash function
    where each input will provide a drastically different output. In UDP packets,
    the checksum input is essentially the entirety of the headers and body of the
    packet. Those bytes are sent through a standard algorithm for generating the checksum.
    Then, once the packet is received, the recipient puts the content of the packet
    through the same checksum algorithm as the client, and validates that it received
    the same response as was delivered. If there is even a minor discrepancy, the
    recipient can be certain that some data was modified in transit and an error has
    occurred.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未听说过这个术语，校验和类似于哈希函数，其中每个输入都会提供一个截然不同的输出。在 UDP 数据包中，校验和输入基本上是数据包的整个头部和主体。这些字节通过一个标准的生成校验和的算法发送。然后，一旦数据包被接收，接收方将数据包的内容通过与客户端相同的校验和算法进行校验，并验证它接收到的响应与发送的是否相同。如果存在任何微小的差异，接收方可以确信在传输过程中某些数据被修改，并且发生了错误。
- en: Responding to, or correcting, this error is outside the scope of the error-handling
    mechanisms of UDP. Typically, if the value of the packet was critical for continued
    operation of the recipient system, that system may request re-transmission of
    the packet. However, in most cases, a mismatched checksum simply indicates to
    the recipient that the packet is invalid and can be discarded from the processing
    queue.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对此错误进行响应或纠正超出了 UDP 错误处理机制的范畴。通常情况下，如果数据包的值对于接收方系统的持续运行至关重要，该系统可能会请求重新传输数据包。然而，在大多数情况下，不匹配的校验和仅仅表明接收方数据包无效，可以从处理队列中丢弃。
- en: TCP in C#
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的 TCP
- en: So, now that we've explored in-depth the objectives, functions, and limitations
    of various transport layer protocols, let's take a look at how we can interact
    with those protocols in C#. We'll start by taking a close look at the classes
    and features exposed by .NET Core for implementing TCP requests directly from
    our application code. We'll see how stepping down in the network stack gives us
    a degree of flexibility and control over our network operations that wasn't previously
    available in the application layer protocols we've explored in previous chapters.
    To do this, we'll be creating two applications, as we did in [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml),
    *HTTP in .NET*. One of the applications will be our TCP client, and one will be
    the listening TCP server. We'll see the results from each request and response,
    confirming the expected behavior of our software, by writing to the standard output
    for each of our two applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经深入探讨了各种传输层协议的目标、功能和限制，让我们看看我们如何在 C# 中与这些协议交互。我们将首先仔细研究 .NET Core 提供的类和功能，以便直接从我们的应用程序代码中实现
    TCP 请求。我们将通过为我们的两个应用程序中的每一个写入标准输出，查看每个请求和响应的结果，以确认我们软件的预期行为。这两个应用程序就像我们在第 9 章
    [HTTP in .NET](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml) 中所做的那样。其中一个应用程序将是我们的
    TCP 客户端，另一个将是监听 TCP 服务器。我们将通过写入标准输出，查看每个请求和响应的结果，以确认我们软件的预期行为。
- en: Initializing a TCP server
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 TCP 服务器
- en: 'Let''s first create our `TCP` client, the same as we have with every application
    before, by creating a directory for it, and then using the CLI to create a console
    app:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的 `TCP` 客户端，就像我们在之前每个应用程序中做的那样，通过为其创建一个目录，然后使用 CLI 创建一个控制台应用程序：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, within the same directory, we''ll create our `TCP` server application
    with the same command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个目录下，我们将使用相同的命令创建我们的 `TCP` 服务器应用程序：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we're ready to start setting up our interactions. When we were last interacting
    directly with sockets exposing a port back in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)*,
    Sockets and Ports*, we were using Postman to generate HTTP requests against a
    given endpoint. Now, however, since we'll be writing our own TCP messages directly
    in code, we won't be constrained to processing the standardized HTTP headers generated
    by Postman. We can define our own mechanism for interactions between hosts. For
    ease of processing, we'll just let our client and server work with simple string
    messages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始设置我们的交互。当我们上一次直接与在 [第 8 章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)
    *套接字和端口* 中暴露端口的套接字交互时，我们使用 Postman 生成针对给定端点的 HTTP 请求。然而，现在，由于我们将直接在代码中编写自己的 TCP
    消息，我们不会受到 Postman 生成的标准化 HTTP 头部的限制。我们可以定义主机之间交互的自己的机制。为了便于处理，我们将让我们的客户端和服务器仅使用简单的字符串消息进行交互。
- en: 'To start these interactions, we''ll set up a listening server. We need to do
    this to know what port our client will be connecting to. So, navigating to the
    `Main()` method of your `SampleTcpServer` application, we''ll start by defining
    our listening ports, and then starting up an instance of the `TcpListener` class,
    like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这些交互，我们需要设置一个监听服务器。我们需要这样做是为了知道客户端将连接到哪个端口。因此，导航到你的 `SampleTcpServer` 应用程序的
    `Main()` 方法，我们首先定义我们的监听端口，然后启动 `TcpListener` 类的一个实例，如下所示：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `TcpListener` class is a custom wrapper around a bare `Socket` instance.
    With the constructor, we designate the port and IP we want to listen on for incoming
    requests. If we had used a bare socket, we'd have to process and either respond
    to or discard every single incoming network request that ran against our designated
    port. With the `TcpListener` instance, though, we won't have to respond to any
    requests that aren't sent via TCP. We'll take a look at this once we set up our
    client class, but this is immensely useful when you're listening for such low-level
    network requests on an open port.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpListener` 类是一个围绕裸 `Socket` 实例的定制包装器。通过构造函数，我们指定我们想要监听传入请求的端口和 IP。如果我们使用裸套接字，我们就必须处理并响应或丢弃针对我们指定的端口的每个传入网络请求。然而，通过
    `TcpListener` 实例，我们不需要响应任何不是通过 TCP 发送的请求。一旦我们设置了客户端类，我们将会看到这一点，但当你在一个开放的端口上监听这种低级网络请求时，这非常有用。'
- en: 'The constructor we used accepts an instance of the `IPAddress` class, and any
    `int` that designates a valid port (so nothing negative, and nothing above 65,535).
    So, for this project, we''ll be using port `54321` to listen for incoming TCP
    requests. For our `IPAddress` instance, we''re using the `Any` static `IPAddress`
    instance that is exposed by the class. By doing this, we''ll see and be able to
    respond to any TCP request whose target host IP address or domain name would resolve
    to our host machine. If we didn''t do this, and instead specified an individual
    IP address, we wouldn''t respond to any requests whose IP address didn''t match
    that exactly, even if the address resolved to the same machine. So, we would do
    this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的构造函数接受 `IPAddress` 类的实例以及任何指定有效端口的 `int`（所以没有负数，也没有超过 65,535 的数）。因此，对于这个项目，我们将使用端口
    `54321` 来监听传入的 TCP 请求。对于我们的 `IPAddress` 实例，我们使用由类公开的 `Any` 静态 `IPAddress` 实例。通过这样做，我们将能够看到并响应任何目标主机
    IP 地址或域名解析到我们的主机机器的 TCP 请求。如果我们没有这样做，而是指定了一个单独的 IP 地址，那么即使地址解析到同一台机器，我们也不会响应任何
    IP 地址不与之完全匹配的请求。因此，我们会这样做：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After doing so, we could send a TCP request to `tcp://0.0.0.0:54321`, and you
    wouldn't see any request register on our `TcpListener` instance. You might expect
    that our request would be detected, since the `0.0.0.0` IP addresses and `127.0.0.1`
    both resolve to the same local machine, but because, in this example, we designated
    our `TcpListener` to only listen for requests to the `127.0.0.1` IP address, that's
    exactly what it does. Meanwhile, our request to `0.0.0.0` goes unresolved. So,
    unless you're writing distinct listeners for distinct IP addresses held by your
    host machine, (or by a series of host machines your application might be deployed
    across), I would recommend using `IPAddress.Any` wherever possible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之后，我们可以向 `tcp://0.0.0.0:54321` 发送一个 TCP 请求，但你不会在我们的 `TcpListener` 实例上看到任何请求注册。你可能预期我们的请求会被检测到，因为
    `0.0.0.0` 和 `127.0.0.1` 这两个 IP 地址都解析到同一台本地机器，但在这个例子中，我们指定我们的 `TcpListener` 只监听
    `127.0.0.1` IP 地址的请求，这正是它所做的事情。同时，我们的 `0.0.0.0` 请求没有得到解决。因此，除非你为你的主机机器上持有的不同 IP
    地址编写不同的监听器（或者你的应用程序可能部署的一系列主机机器），否则我建议尽可能使用 `IPAddress.Any`。
- en: 'Now we have to set up our server to run and listen for requests against that
    port. First, we''ll start the server, and then we''ll set up a context where we
    listen indefinitely for incoming requests. This is typically done with an intentionally
    infinite loop. Now, if you''ve ever accidentally found yourself stuck inside an
    infinite loop, you know it''s something you should only ever start when you mean
    to. However, since we want our application to listen indefinitely, the simplest
    and most reliable way to do so is to prevent our `Main()` method from resolving
    by encapsulating our primary business logic in a simple infinite loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须设置我们的服务器以运行并监听对该端口的请求。首先，我们将启动服务器，然后我们将设置一个上下文，在那里我们无限期地监听传入的请求。这通常是通过一个故意无限循环来完成的。现在，如果你曾经意外地发现自己陷入了一个无限循环中，你知道这应该只在你真正打算这么做的时候才开始。然而，由于我们希望我们的应用程序无限期地监听，最简单且最可靠的方法是防止我们的`Main()`方法解析，通过将我们的主要业务逻辑封装在一个简单的无限循环中来做到这一点：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you compile and build what we've written so far, you'll see the two console
    statements print to the screen, and then your application will look as if it's
    hanging for quite some time, and that's exactly what you would hope to see. What's
    happening behind the scenes is that you've initiated the `TcpListener` instance
    by calling `Start()` on it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并构建到目前为止我们所写的代码，你将看到两个控制台语句打印到屏幕上，然后你的应用程序看起来就像挂了一段时间，这正是你所希望看到的。幕后发生的事情是，你已经通过调用`Start()`初始化了`TcpListener`实例。
- en: This will cause the instance to accept incoming requests on its designated port
    until either you explicitly call the `Stop()` method on the class, or it receives
    a total number of connections greater than the `MaxConnections` property of the
    `SocketOptionName` enum (which is set to over two billion, so it's unlikely that
    limit will be reached in our little local TCP server).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致实例在其指定的端口上接受传入的请求，直到你明确地在类上调用`Stop()`方法，或者它接收到的连接总数超过`SocketOptionName`枚举的`MaxConnections`属性（该属性设置为超过二十亿，因此在我们的小型本地TCP服务器中，这个限制不太可能达到）。
- en: Once our server is listening, we start our listening loop and check to see whether
    our socket has received any pending requests. If it hasn't (and we haven't logged
    it since the last request), we indicate as much with a simple console log, and
    then move along, continuing with the `while` loop until we have something to process.
    For now, we shouldn't see anything in the pending state, so let's set up our client
    project to change that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的服务器开始监听，我们就启动我们的监听循环，并检查我们的套接字是否收到了任何挂起的请求。如果没有（并且自上次请求以来我们没有记录它），我们通过简单的控制台日志来表明这一点，然后继续，通过`while`循环继续，直到我们有东西要处理。目前，我们不应该看到任何挂起状态，所以让我们设置我们的客户端项目来改变这一点。
- en: Initializing a TCP client
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化TCP客户端
- en: Now we'll need to initialize our TCP client application in much the same way
    as we did with our server. Instead of using the `TcpListener` class, though, we'll
    be using the `TcpClient` class to create connections with our server that we can
    write to and read from within our project. The difference between the two in our
    case is that, when we created a `TcpListener`, we needed to initialize it with
    the address and port on which it would be listening. There is no default constructor,
    because without a port on which to listen, the class can't perform its most basic
    functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要以与我们的服务器相同的方式初始化我们的TCP客户端应用程序。不过，我们将使用`TcpClient`类而不是`TcpListener`类来与我们的服务器建立连接，这样我们就可以在我们的项目中写入和读取这些连接。在我们这个例子中，两者之间的区别在于，当我们创建一个`TcpListener`时，我们需要用它将监听的地址和端口来初始化它。没有默认构造函数，因为没有监听端口的类无法执行其最基本的功能。
- en: 'With an instance of the `TcpClient`, however, we don''t need to initialize
    it with an address or port specification. The client instance could feasibly be
    used to connect to multiple, distinct remote processes (ports on a single remote
    host) or hosts (different IP addresses altogether). As such, we only need to specify
    our connection target when we attempt to make a connection. For now, let''s just
    establish the connection to confirm that our server responds to listening requests
    appropriately:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`TcpClient`实例，我们不需要用地址或端口规范来初始化它。客户端实例可以合理地用于连接到多个不同的远程进程（单个远程主机上的端口）或主机（完全不同的IP地址）。因此，当我们尝试建立连接时，我们只需要指定我们的连接目标。现在，让我们只是建立连接来确认我们的服务器能够适当地响应监听请求：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we specified IP address `127.0.0.1`, but, as I said before, we could have
    specified any alias IP address that would resolve to our local machine. Once we've
    created our client, we can use it to connect to the port we designated as listening
    on our server application. Then, just to confirm that the connection was established
    and that our client knows about it, we write a simple log statement, sleep the
    thread for `10` seconds to observe the message in our console, and then terminate
    the program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了IP地址 `127.0.0.1`，但正如我之前所说的，我们本可以指定任何解析到我们本地机器的别名IP地址。一旦我们创建了客户端，我们就可以使用它来连接到我们在服务器应用程序上指定的监听端口。然后，为了确认连接已经建立，并且客户端知道这一点，我们写入一个简单的日志语句，让线程休眠`10`秒以观察控制台中的消息，然后终止程序。
- en: In order to see this succeed, start your server application first, so that it's
    started and listening on the designated port. Then, once you see the messages
    show up in your console window indicating that the server is waiting for a pending
    request, start your client application. You should see the We've connected...
    message in your client window, and the Pending TCP request... message in your
    server window. Once you see both messages, you know your connections are being
    established, and you can terminate both applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一成功，首先启动你的服务器应用程序，确保它已经启动并监听指定的端口。然后，一旦你在控制台窗口中看到消息表明服务器正在等待挂起请求，启动你的客户端应用程序。你应该在你的客户端窗口中看到“我们已连接...”消息，在你的服务器窗口中看到“挂起的TCP请求...”消息。一旦你看到这两条消息，你就知道你的连接正在建立，然后你可以终止这两个应用程序。
- en: And, here, let's consider why we use the `loggedPending` flag. It should be
    pretty obvious why we used the `loggedNoRequest` flag to prevent us from printing
    out the log messages every time we stepped through our loop until we received
    an incoming request. However, the reason we have to do the same thing when we
    have a pending request is the server will hold the `Pending` state until its inbound
    message queue has been read from and flushed. So, since our server doesn't yet
    read from and empty the incoming request stream if we didn't have that check,
    and we connected to our server, our console would quickly overflow with Pending
    TCP request... messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们考虑一下为什么我们使用`loggedPending`标志。为什么我们使用`loggedNoRequest`标志来防止我们在收到传入请求之前每次遍历循环时打印日志消息应该是相当明显的。然而，我们必须在存在挂起请求时做同样的事情，因为服务器会保持`Pending`状态，直到其入站消息队列被读取并刷新。所以，由于我们的服务器在没有那个检查的情况下还没有读取并清空传入请求流，并且我们连接到了服务器，我们的控制台会很快因为挂起的TCP请求...消息而溢出。
- en: Connection information without data transfer
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无数据传输的连接信息
- en: Before we get to the work of building and parsing TCP requests in our projects,
    I just want to take a moment to note the benefit of the connection-based approach,
    and how .NET Core leverages it to give engineers fine-tuned control over their
    network transactions. Note that once we send the connection request from our client,
    we get an immediate notification from the server that a connection was established.
    No message was actually sent, and no response was received by the server. In fact,
    the connection remains open even if the server is synchronously locked and prevented
    from actively transmitting anything. This is the handshake interaction of TCP
    at work, and gives us access to a lot of information about the state of the connection
    prior to actually sending a message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在项目中构建和解析TCP请求之前，我想花一点时间来指出基于连接的方法的好处，以及.NET Core如何利用它来让工程师对他们的网络事务有精细的控制。请注意，一旦我们从客户端发送连接请求，服务器就会立即通知我们连接已经建立。实际上并没有发送消息，服务器也没有收到任何响应。事实上，即使服务器同步锁定并阻止主动传输任何内容，连接仍然保持打开。这是TCP的握手交互在起作用，并为我们提供了关于连接状态的大量信息，这些信息是在实际发送消息之前获得的。
- en: What's especially nice for application developers, though, is that the connection
    is established and managed by the `TcpClient` class itself. With only a single
    call to the `Connect(IPAddress, int)` method, the TcpClient library notified our
    server that we wished to establish a connection, await the acknowledgment, and
    finally acknowledge the server's response to open the connection. This is one
    of the greatest strengths of .NET Core; the ease of use of a high-level application
    programming language, coupled with access to, and control over, low-level network
    interactions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序开发者来说，特别令人高兴的是，连接的建立和管理是由`TcpClient`类本身完成的。只需调用一次`Connect(IPAddress, int)`方法，TcpClient库就会通知我们的服务器我们希望建立连接，等待确认，并最终确认服务器的响应以打开连接。这是.NET
    Core最伟大的优势之一；高级应用程序编程语言的易用性，以及访问和控制低级网络交互的能力。
- en: Transmitting data on an active connection
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在活动连接上传输数据
- en: Now that we've established a connection, our server can decide what to do with
    that connection, and the requests transmitted across it. However, before we change
    gears back to our server, let's generate a message from our client for the server
    to process in the first place. We'll be using something of a mutation test to
    confirm that all of our data is being processed and returned by the server accordingly.
    So, at each step of the way, we'll be modifying our initial message and logging
    the results. Each step of the way, our message should look different than the
    last system that wrote it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了连接，我们的服务器可以决定如何处理该连接以及通过它传输的请求。然而，在我们回到服务器之前，让我们首先生成一个客户端的消息供服务器处理。我们将使用一种突变测试来确认所有数据都被服务器相应地处理和返回。因此，在每一步，我们都会修改我们的初始消息并记录结果。每一步，我们的消息都应该与最后写入它的系统不同。
- en: If you've never heard the term **mutation test**, it's a simple way of tracking
    that changes to your system are detected by the tests that validate your system.
    The idea is that you make a change or a mutation somewhere in your code, and confirm
    that somewhere downstream, usually in your unit tests, that change has an impact,
    typically by failing a previously passing unit test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未听说过**突变测试**这个术语，它是一种简单的方法，用于跟踪对系统所做的更改是否被验证系统（测试）检测到。想法是在你的代码中某个地方进行更改或突变，并确认在下游某个地方，通常是在单元测试中，该更改产生了影响，通常是通过使之前通过的单位测试失败。
- en: 'We''ll start by writing a message with a header and a payload. This will just
    be a simple greeting for our server, and a message we expect our server to return
    to us, unchanged, as part of its response. We''ll separate the two messages with
    a simple `|` delimiter. Then we''ll convert it to a byte array that''s suitable
    for transmission over our connection, and send the request. So, let''s set that
    up before moving on to the server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个带有标题和有效负载的消息开始。这将是针对我们服务器的简单问候，以及我们期望服务器返回给我们的消息，作为其响应的一部分，且不改变。我们将使用简单的`|`分隔符将两个消息分开。然后我们将它转换为适合通过我们的连接传输的字节序列，并发送请求。所以，在我们继续到服务器之前，让我们设置一下：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `requestStream` variable we created is an instance of the `NetworkStream`
    class created to write and read data over an open socket. With this, we'll be
    able to send our initial message, and then, eventually, read the response from
    the server. But, first, let's take a look at how to use our `TcpListener` instance
    to accept and parse an incoming request.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`requestStream`变量是`NetworkStream`类的一个实例，用于在打开的套接字上写入和读取数据。有了这个，我们将能够发送我们的初始消息，然后，最终，从服务器读取响应。但是，在我们改变方向回到服务器之前，让我们看看如何使用我们的`TcpListener`实例来接受和解析传入的请求。
- en: Accepting an incoming TCP request on the server
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上接受传入的TCP请求
- en: 'Now that our client is actually sending a readable message, let''s listen for
    the request on our pending connection. To do that, we''ll actually get another
    instance of the `TcpClient` class directly from our listener. This is simply the
    class is used to interact with the open connection, so once we accept it, we''ll
    be reading from and writing to that open connection in much the same way that
    our sample client program has been. First, though, we''ll have to accept the pending
    connection, using the thread-blocking `AcceptTcpClient()` call. Since we''re now
    responding to our pending request, we can get rid of our log message and replace
    it with our new code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的客户端实际上正在发送一个可读的消息，让我们在我们的待处理连接上监听请求。为此，我们将直接从我们的监听器获取另一个`TcpClient`类的实例。这个类是用来与打开的连接交互的，所以一旦我们接受它，我们将以与我们的示例客户端程序相同的方式从该打开连接中读取和写入。首先，我们必须使用线程阻塞的`AcceptTcpClient()`调用接受待处理连接。由于我们现在正在响应我们的待处理请求，我们可以删除我们的日志消息并用我们的新代码替换它：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting our server, we should see in our server log that it's listening for
    pending connection requests. Then, once we run our client, we should see our request
    message from the client logged to the server's console, followed by another indicator
    that the server has started listening for incoming requests again. If we run the
    client again, we'll see the same sequence of events until we eventually shut down
    the server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们的服务器后，我们应该在我们的服务器日志中看到它正在监听待处理的连接请求。然后，一旦我们运行我们的客户端，我们应该看到客户端的请求消息被记录到服务器的控制台，随后还有一个指示器表明服务器再次开始监听传入的请求。如果我们再次运行客户端，我们将看到相同的序列事件，直到我们最终关闭服务器。
- en: The request/response model on the server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器上的请求/响应模型
- en: 'To finish the request/response interaction, we''ll generate a new message,
    using the payload of the original request, and return it to our client. As we
    complete these two applications, we''ll have the client drive the interactions
    with the server from here on out. So, our server will be up and running, returning
    responses that echo the payload of the requests, until it receives a signal message
    indicating it should shut itself down. Meanwhile, our client will send intermittent
    requests with new payloads, until eventually sending the termination signal to
    our server. To serve that purpose, we''ll add the following lines to our server
    application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成请求/响应交互，我们将生成一个新的消息，使用原始请求的有效负载，并将其返回给我们的客户端。随着这两个应用程序的完成，从现在开始，客户端将驱动与服务器之间的交互。因此，我们的服务器将保持运行状态，返回响应，这些响应会回显请求的有效负载，直到它收到一个指示它应该自行关闭的信号。同时，我们的客户端将发送带有新有效负载的间歇性请求，直到最终向我们的服务器发送终止信号。为了实现这个目的，我们将向我们的服务器应用程序添加以下行：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll use this as a signal that we should stop listening for requests and
    terminate the server. Next, we''ll add the following conditional code to our server''s
    listening loop:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个信号来表示我们应该停止监听请求并终止服务器。接下来，我们将添加以下条件代码到我们服务器的监听循环中：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our response transmission code will go inside the `else` statement in that
    conditional block, and so our loop will simply continue logging the request message,
    and then appending the payload to the response, until the terminating signal is
    received, at which point the loop is broken and we''ll shut our server down. So,
    lastly, we''ll modify our `while` loop to check for the value of our `done` condition
    instead of running in an infinite loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的响应传输代码将放在那个条件块中的`else`语句内，因此我们的循环将简单地继续记录请求消息，然后将有效负载附加到响应中，直到接收到终止信号，此时循环被打破，我们将关闭我们的服务器。所以，最后，我们将修改我们的`while`循环，检查`done`条件的值而不是运行无限循环：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let''s go ahead and parse the message for its payload, using our delimiter
    to separate the two components of our message, and then apply the result to our
    server''s response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解析消息以获取其有效负载，使用我们的分隔符来分隔消息的两个组件，然后将结果应用于服务器的响应：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, on the line after the closing brace for our listening loop, let''s
    shut down our server, and if you''re running the application in Debug-mode from
    Visual Studio, allow our program to end after a brief delay to check the log results:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的监听循环的闭合花括号之后的一行，让我们关闭我们的服务器，如果你正在使用Visual Studio的调试模式运行应用程序，允许我们的程序在短暂的延迟后结束以检查日志结果：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And, with that, our `SampleTcpServer` application is complete. It will stay
    active and listen for requests until it's explicitly instructed to terminate itself.
    And the whole time, it will log each request it receives and return its own custom
    response. You can use the source code in the GitHub repository for this chapter
    to check your implementation against my own, but, as always, I'd encourage you
    to modify it on your own and start investigating what other methods are available.
    And, as you do so, always be thinking about how you could use this code in your
    own custom networking software.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的 `SampleTcpServer` 应用程序就完成了。它将保持活跃状态并监听请求，直到明确地指示它终止自己。在整个过程中，它将记录它接收到的每个请求并返回它自己的自定义响应。您可以使用本章
    GitHub 仓库中的源代码来检查您的实现与我的实现是否一致，但就像往常一样，我鼓励您自己修改它并开始调查其他可用的方法。在这样做的时候，始终思考您如何在自己的自定义网络软件中使用此代码。
- en: Finalizing the TCP client
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成TCP客户端
- en: Our server is designed and written to remain active and listening for any potential
    incoming requests. A client, on the other hand, should only ever be set up for
    a single purpose, execute on that purpose, and then close its connection, freeing
    up the resources of the server for any other consumers that may need to access
    it. For this reason, we won't be writing any persistent listening loops. Instead,
    we will simply process each of a handful of request/response round trips before
    terminating the server and then shutting down our own application. However, to
    create a slightly more realistic simulation of multiple clients accessing our
    TCP server, we'll be dropping and recreating our `TcpClient` instance for each
    subsequent request, and injecting a random delay in between each request.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器被设计和编写成保持活跃并监听任何潜在的传入请求。另一方面，客户端应该只为单一目的而设置，执行该目的，然后关闭其连接，以便服务器可以为可能需要访问它的其他消费者释放资源。因此，我们不会编写任何持久的监听循环。相反，我们将在终止服务器并关闭我们自己的应用程序之前简单地处理几个请求/响应往返。然而，为了创建一个稍微更现实的模拟，多个客户端访问我们的
    TCP 服务器，我们将为每个后续请求丢弃并重新创建我们的 `TcpClient` 实例，并在每个请求之间注入随机延迟。
- en: 'The first order of business, though, is accepting the response from our server.
    So, inside our `SampleTcpClient` application, we''ll be adding a few lines to
    create a new byte array for use as a message buffer for the response and then
    reading our `requestStream` into our buffer for processing and logging. So, let''s
    add that code and then we''ll see how we can extend it to finish our simulation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首要任务是接受来自我们服务器的响应。因此，在我们的 `SampleTcpClient` 应用程序中，我们将添加几行代码来创建一个新的字节数组，用作响应的消息缓冲区，然后将我们的
    `requestStream` 读取到我们的缓冲区中进行处理和记录。所以，让我们添加这段代码，然后我们将看到我们如何扩展它来完成我们的模拟：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I would think none of this is surprising at this point. We're essentially executing
    the exact same thing as the server, but in reverse order. Where as on the server,
    we were reading from the stream, and then writing *to* the stream, in the client
    code, we're first writing *to* the stream, and then reading from the stream. Mechanically
    though, this is the same sort of interaction we've seen since we first looked
    at how to interact with raw C# Stream objects back in [Chapter 4](9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml)*,
    Packets and Streams.* Hopefully, by now, you're starting to see the value in the
    incremental, brick-by-brick approach we've taken to building a foundation for
    network programming up to this point (assuming you haven't already).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为到目前为止，这一切都不足为奇。我们实际上执行的是与服务器完全相同的事情，但顺序相反。在服务器上，我们是读取流，然后写入流，而在客户端代码中，我们首先写入流，然后从流中读取。然而，从机械上讲，这是我们自从在第四章
    [9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml]*，数据包和流* 中首次查看如何与原始 C# Stream 对象交互以来所看到的相同类型的交互。希望到现在为止，您已经开始看到我们迄今为止在构建网络编程基础时采用的逐步、砖块式方法的价值（假设您还没有这样做）。
- en: 'At any rate, let''s modify our client to transmit a handful of pre-defined
    messages before finally sending the termination signal. To do that, let''s build
    out a short array of the messages we''ll be sending to the server so that we can
    easily increment through them in our code, sending distinct messages with each
    outbound request:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们修改我们的客户端，在最终发送终止信号之前发送一些预定义的消息。为此，让我们构建一个包含我们将发送到服务器的消息的简短数组，这样我们就可以在我们的代码中轻松地遍历它们，在每个出站请求中发送不同的消息：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s wrap the request/response transactions in a `while` loop (not
    an active listening loop as we saw with our server, but a simple incremental loop).
    We''ll use an iterator variable, starting at zero, to move through the our messages,
    checking its value against the length of our messages array to determine when
    to break out of our loop and let our application terminate:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将请求/响应事务包裹在一个 `while` 循环中（不是像我们的服务器那样看到的活跃监听循环，而是一个简单的增量循环）。我们将使用一个迭代变量，从零开始，遍历我们的消息，将其值与我们的消息数组长度进行比较，以确定何时跳出循环并让我们的应用程序终止：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because our `TcpClient` instance is created by the `using` statement within
    our `while` loop, the variable goes out of scope with each iteration. We thus
    create a new connection every time we step back through the beginning of the loop.
    Next, we have to change the code that builds our request message byte-array to
    iterate through the `messages` string array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `TcpClient` 实例是在 `while` 循环内的 `using` 语句中创建的，因此每次迭代变量都会超出作用域。因此，我们每次回到循环的开始时都会创建一个新的连接。接下来，我们必须更改构建我们的请求消息字节数组的代码，使其迭代
    `messages` 字符串数组：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, at the end of our `while` loop, we''ll sleep our thread for a random
    amount of time between `2` and `10` seconds, logging the `sleepDuration` each
    time:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `while` 循环的末尾，我们将线程休眠一个介于 `2` 到 `10` 秒之间的随机时间，每次都记录 `sleepDuration`：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, if you're running in Debug-mode, you'll want to throw in one last `Thread.Sleep()`
    for good measure, after the `while` loop, to ensure we have enough time to examine
    the results of our requests before our application shuts down.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在调试模式下运行，你可能会在 `while` 循环之后添加一个最后的 `Thread.Sleep()`，以确保在我们应用程序关闭之前有足够的时间检查我们请求的结果。
- en: 'After completing the client and running both applications, my terminals logged
    exactly the messages that I hoped they would:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成客户端并运行这两个应用程序后，我的终端记录了我希望它们记录的确切消息：
- en: '![](img/50954a2a-67e4-4336-85d4-5f4c2da42e86.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50954a2a-67e4-4336-85d4-5f4c2da42e86.png)'
- en: And, with this, we've written our own custom TCP server and clients. While this
    example was fairly trivial in its function, I hope you can see the high degree
    of flexibility these .NET classes open up for you with respect to custom TCP implementations.
    With these two sample applications, you have all the tools at your disposal necessary
    to write your own custom application layer protocol with a custom TCP server optimized
    to support it. Or you could write applications whose network interactions side-step
    the application layer protocol overhead altogether! The problems you encounter
    in your personal or professional projects will dictate how you choose to use this
    toolset, but now, hopefully, you'll be ready to leverage it when you need to.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，通过这种方式，我们已经编写了自己的自定义 TCP 服务器和客户端。虽然这个示例在功能上相当简单，但我希望你能看到这些 .NET 类为你提供的自定义
    TCP 实现的高度灵活性。通过这两个示例应用程序，你拥有了编写自己的自定义应用层协议所需的全部工具，该协议由一个针对它优化的自定义 TCP 服务器支持。或者，你可以编写绕过应用层协议开销的网络的交互应用程序！你在个人或专业项目中遇到的问题将决定你如何选择使用这个工具集，但现在，希望你能准备好在需要时利用它。
- en: UDP in C#
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的 UDP
- en: Now that we've looked at how to implement TCP in C#, let's take a look at its
    connectionless counterpart in the suite of transport layer protocols, UDP. By
    its very nature, the sample client and server we'll be writing will be a fair
    bit simpler than the TCP in terms of setup code, but we'll be using the same pattern
    we used in the previous section for defining the behavior of our sample application.
    So, we'll be transmitting requests and accepting and logging responses between
    a client and a server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 C# 中实现 TCP，接下来让我们看看传输层协议套件中与之对应的无连接协议 UDP。根据其本质，我们将编写的示例客户端和服务器在设置代码方面将比
    TCP 简单得多，但我们将使用之前章节中用于定义示例应用程序行为的相同模式。因此，我们将在客户端和服务器之间传输请求并接受和记录响应。
- en: The difference here, however, is that both the client and the server will be
    implemented in the exact same way. This is because there is no `UdpListener` class,
    because UDP doesn't actively listen for connections. Instead, a UDP server simply
    accepts in bound packets whenever it is set up to look for a new one. For this
    reason, we'll only be looking at the client application's implementation, and
    I'll leave the server source code for you to pull down from GitHub and use to
    test and validate the behavior of the client.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的区别是客户端和服务器将以完全相同的方式进行实现。这是因为没有 `UdpListener` 类，因为 UDP 不主动监听连接。相反，UDP 服务器只是在设置好寻找新的数据包时接受传入的数据包。因此，我们将只查看客户端应用程序的实现，我将把服务器源代码留给你从
    GitHub 上下载并使用来测试和验证客户端的行为。
- en: Initializing a UDP client
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 UDP 客户端
- en: 'We''ll start by creating a new console app that will serve as our `UDP` client:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的控制台应用程序，它将作为我们的 `UDP` 客户端：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then inside our project, the first thing we'll want to do is define a well-known
    IP endpoint that our client will be interacting with. We'll be working against
    localhost once again, with an arbitrary port exposed, just as we did in the previous
    section about TCP. Once we have that defined, though, we're just about ready to
    start generating requests. The beauty of a connection-less protocol is that we
    don't have to first establish any sort of interaction with our remote host. Provided
    we know what the address of the host is, we can simply send out our datagrams.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的项目中，我们首先想要做的是定义一个已知的 IP 端点，我们的客户端将与之交互。我们将再次使用 localhost，并暴露一个任意端口，就像我们在上一节关于
    TCP 的部分中所做的那样。一旦我们定义了它，我们就可以准备开始生成请求。无连接协议的美丽之处在于我们不需要首先与我们的远程主机建立任何形式的交互。只要我们知道主机的地址，我们就可以简单地发送我们的数据报。
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And, just like that, if you run the server application and then run the client,
    you'll see your message logged to the server's console! So, what exactly is going
    on here, and what are we doing when we initialize our `UdpClient`?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，如果你运行服务器应用程序，然后运行客户端，你将看到你的消息被记录在服务器的控制台上！那么，这里到底发生了什么，当我们初始化我们的 `UdpClient`
    时我们在做什么呢？
- en: The first thing we do is initialize our `UdpClient` with a port number. If we
    intend to use this client to receive incoming UDP datagrams (which we eventually
    will), it will be accepting them on the port it was initialized with. So, our
    client will be listening on port `34567`. Next, we take the time to define the
    explicit `IPEndPoint` that we would be sending our datagrams to.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先用端口号初始化我们的 `UdpClient`。如果我们打算使用这个客户端来接收传入的 UDP 数据报（我们最终会这样做），它将在这个初始化时指定的端口上接受它们。因此，我们的客户端将监听端口
    `34567`。接下来，我们花时间定义我们打算发送数据报的显式 `IPEndPoint`。
- en: This isn't technically necessary, as you can define your request target with
    their hostname and port as part of the `SendAsync()` method using an overloaded
    method signature. However, since we'll be extending this method to also accept
    responses, it's easier for our purposes to explicitly define the `IPEndPoint`
    instance once at the start of the method. Finally, we build our datagram as an
    array of bytes representing the characters of our message string, just as we did
    in the previous section, and send the message along with the help of our newly
    initialized `UdpClient`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上不是必需的，因为你可以使用重载的方法签名，在 `SendAsync()` 方法中定义你的请求目标，包括它们的域名和端口。然而，由于我们将扩展这个方法以接受响应，在我们的目的中，在方法开始时显式定义
    `IPEndPoint` 实例更容易。最后，我们像上一节那样构建我们的数据报，将其作为表示消息字符串字符的字节数组，并借助我们新初始化的 `UdpClient`
    发送消息。
- en: The send/receive paradigm
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送/接收范式
- en: One thing you might have noticed about using a `UdpClient`, as opposed to the
    more robust `TcpClient` class, is that UDP doesn't leverage streams at all. With
    no underlying connection for a `Stream` to represent, and the potential for UDP
    data to be lost, or delivered out of order, there is no direct correlation between
    the behavior of a UDP request and the abstraction provided by a `Stream` instance.
    Because of this, the `UdpClient` class provided by .NET Core implements a simple
    call/response mechanism through its `Send` and `Receive` methods. Neither of these
    two methods requires a prior communication or interaction with the remote host
    to execute. Instead, they behave as more of a fire-and-forget trigger for some
    events to happen on the network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，与更健壮的`TcpClient`类相比，使用`UdpClient`时没有利用流。由于没有底层连接来表示流，以及UDP数据可能丢失或顺序错误的潜在可能性，UDP请求的行为与`Stream`实例提供的抽象之间没有直接关联。正因为如此，.NET
    Core提供的`UdpClient`类通过其`Send`和`Receive`方法实现了一个简单的请求/响应机制。这两个方法中的任何一个都不需要与远程主机进行先前的通信或交互即可执行。相反，它们更像是在网络上触发某些事件发生的“触发器”。
- en: Interestingly, though, when you want to leverage the `SendAsync()` method, which
    doesn't block your application's thread, you *can* choose to first establish a
    connection with your remote host. Keep in mind, though, that this isn't quite
    the same as establishing a connection in TCP. Instead, this simply configures
    your `UdpClient` so that it attempts to send all outgoing packets to the specific
    remote host to which it is connected.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管如此，当你想利用`SendAsync()`方法时，这个方法不会阻塞你的应用程序线程，你可以选择首先与你的远程主机建立连接。但请记住，这并不完全等同于TCP中的建立连接。相反，这仅仅配置了你的`UdpClient`，使其尝试将所有发出的数据包发送到它连接的特定远程主机。
- en: The connection in this context is only a logical one and it only exists within
    the application it's established in. So, while an established TCP connection was
    detectable from both our client and server applications simultaneously, the same
    is not true in our UDP application. While running our UDP client and server simultaneously,
    the server application has no way of detecting the connection established by the
    client.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，连接仅是逻辑上的，并且它只存在于建立它的应用程序中。因此，虽然一个建立的TCP连接可以从我们的客户端和服务器应用程序同时检测到，但在我们的UDP应用程序中并非如此。当同时运行我们的UDP客户端和服务器时，服务器应用程序无法检测到客户端建立的连接。
- en: Once we've connected our `UdpClient` to a given `IPEndPoint`, every `SendAsync()`
    call is assumed to be configured for the connected endpoint. If you want to send
    a message to an arbitrary endpoint while your `UdpClient` instance is connected
    to a different endpoint, you'll have to disconnect your client first, or explicitly
    pass the new endpoint as a parameter for your `SendAsync()` call. In the context
    of our sample application, this won't come up as an issue, but it could come up
    fairly quickly in real-world contexts, so it's important you keep that in mind
    as you define your send/receive patterns for a given application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`UdpClient`连接到特定的`IPEndPoint`，每个`SendAsync()`调用都假定是为连接的端点配置的。如果你想在`UdpClient`实例连接到不同端点时发送消息，你必须首先断开客户端的连接，或者明确地将新端点作为参数传递给`SendAsync()`调用。在我们的示例应用程序中，这不会成为问题，但在实际环境中，这个问题可能会很快出现，因此当你为特定应用程序定义发送/接收模式时，请记住这一点。
- en: 'With that understanding in mind, let''s prepare to receive the response from
    our UDP server application. First, though, we''ll modify our application to connect
    to our remote endpoint at the outset. Next, to demonstrate how to establish a
    connection with a `UdpClient` instance, we''ll remove the endpoint parameter from
    our `SendAsync()` call. Finally, we''ll listen for a message with `ReceiveAsync()`.
    At that point, we''ll be handling the packet''s buffer object just as we have
    with every byte-array buffer before:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种理解，让我们准备接收我们的UDP服务器应用程序的响应。首先，我们将修改我们的应用程序，使其一开始就连接到我们的远程端点。接下来，为了演示如何使用`UdpClient`实例建立连接，我们将从`SendAsync()`调用中移除端点参数。最后，我们将使用`ReceiveAsync()`监听消息。到那时，我们将像处理之前的每个字节数组缓冲区一样处理数据包的缓冲区对象：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And, with that, we've got our UDP client wired up to send a packet and await
    a response from our server.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经将UDP客户端连接好，可以发送数据包并等待服务器的响应。
- en: You may have deduced this from our discussions about connectionless communication
    throughout this chapter, but whenever you're sending a message using UDP (or any
    other connectionless protocol), it is an inherently non-blocking operation. This
    is due to the lack of any sort of acknowledgment from the server. So, from our
    application's perspective, once a UDP packet has reached our network card for
    transmission, its delivery is out of our hands.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从本章关于无连接通信的讨论中推断出了这一点，但无论何时你使用UDP（或任何其他无连接协议）发送消息，它本质上是非阻塞操作。这是由于服务器没有提供任何形式的确认。因此，从我们的应用程序角度来看，一旦UDP数据包到达我们的网络卡进行传输，其交付就不再在我们手中。
- en: Meanwhile, the `Receive()` operation in UDP is inherently blocking*.* Since
    there's no established connection or stream buffer to hold an incoming message
    until our server or client is ready to process the packet, any software we right
    that must accept and receive UDP packets will have to be very explicit about when
    and how long it is acceptable to block our execution while we wait for a packet
    that may never arrive. The asynchronous versions of the transmission methods provide
    some flexibility, but, ultimately, it's a limitation of the protocol that we can't
    escape. Given that, it's in your best interest to be mindful of that limitation
    and design your UDP software around it from the start.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，UDP中的`Receive()`操作本质上是阻塞的*.* 由于没有建立连接或流缓冲区来存储传入的消息，直到我们的服务器或客户端准备好处理数据包，因此我们编写的任何必须接受和接收UDP数据包的软件都必须非常明确地说明在等待可能永远不会到达的数据包时，何时以及多长时间可以阻塞我们的执行。传输方法的异步版本提供了一些灵活性，但最终，这是协议的限制，我们无法规避。鉴于这一点，最好是从一开始就注意这个限制，并围绕它设计你的UDP软件。
- en: Multicasting packets
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多播数据包
- en: Perhaps one of the single greatest advantages of using connectionless communication,
    such as UDP, is the ability to send out packets to a large number of recipients
    in a single transaction. This is commonly called **multicasting**, or **broadcasting**,
    and it enables everything from network device discovery and host registration
    to most live television or video streams broadcast over the internet. It's a somewhat
    niche feature that, if I had to guess, most of the people reading this will never
    have a good reason to leverage, but it is certainly worth understanding. With
    that said, let's look at how to enable this feature in our .NET Core apps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无连接通信，例如UDP，最大的单一优势之一可能是能够在单次事务中向大量接收者发送数据包。这通常被称为**多播**，或**广播**，它使得从网络设备发现和主机注册到大多数通过互联网直播的电视或视频流都能实现。这是一个相对小众的功能，如果我要猜测的话，大多数阅读这篇文章的人可能永远不会找到一个很好的理由去利用它，但它确实值得理解。话虽如此，让我们看看如何在我们的.NET
    Core应用程序中启用此功能。
- en: Multicasting in .NET
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的多播
- en: With most of the packet transmissions we've looked at so far, we've been addressing
    a specific port on a specific machine, addressed via host name or IP address.
    However, this obviously won't suit our needs if our goal is to send the same packet
    to as many IP addresses as can listen for it. And it certainly won't work if we're
    trying to discover devices on our network and aren't even sure of their IP addresses
    in the first place. Instead, most network devices will listen for requests to
    their specific IP addresses as well as a special range of IP addresses designed
    specifically to catch broadcast packets from other devices on their network (typically,
    that multicast IP address is going to be `255.255.255.255`, but not necessarily).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止查看的大多数数据包传输中，我们一直在针对特定机器上的特定端口进行操作，通过主机名或IP地址进行寻址。然而，如果我们目标是向尽可能多的可以监听它的IP地址发送相同的数据包，这显然不会满足我们的需求。如果我们试图发现网络上的设备，甚至不确定它们的IP地址，这肯定也不会起作用。相反，大多数网络设备将监听针对它们特定IP地址的请求，以及专门设计来捕获来自其网络上其他设备广播数据包的特殊IP地址范围（通常，该多播IP地址将是`255.255.255.255`，但不一定是）。
- en: If you want to multicast a number of packets out of a single port from your
    host, you can do so simply by configuring your `UdpClient` instance to allow multiple
    clients to access an open port with the `ExclusiveAddressUse` boolean property.
    By setting that property to `false`, you enable multiple `UdpClient` to leverage
    the same port at the same time, giving your application the ability to transmit
    messages to as many remote hosts as you have clients configured to interact with
    them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从你的主机的一个端口中多播多个数据包，你可以通过配置你的`UdpClient`实例，使其通过`ExclusiveAddressUse`布尔属性允许多个客户端访问一个开放的端口来实现。通过将该属性设置为`false`，你可以使多个`UdpClient`同时利用相同的端口，从而让你的应用程序能够向配置了与之交互的客户端数量一样多的远程主机传输消息。
- en: Separately, if you want to listen for multicast packets, you can set up a `UdpClient`
    to be a part of a `MulticastGroup` by applying the appropriate `MulticastGroupOptions`
    settings to your client or socket. Doing so sets your client to listen along with
    any other registered listeners to packets being multicast by a single transmitting
    host.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你想监听多播数据包，你可以通过将适当的`MulticastGroupOptions`设置应用于你的客户端或套接字，将一个`UdpClient`设置为`MulticastGroup`的一部分。这样做会将你的客户端设置为与其他已注册的监听器一起监听单个发送主机正在多播的数据包。
- en: As I said at the start of this section, multicasting and listening for multicast
    packets is an incredibly niche operation, and it's unlikely you'll find yourself
    needing to account for it in your daily work. As such, I won't be spending any
    more time on the subject. However, if you're curious, I would strongly encourage
    you to plumb the documentation for it online. For now, though, I just wanted to
    make sure you had at least some exposure to the concept and understood that there
    were features available to you in the `UdpClient` class that you could leverage
    to achieve or listen for multicast data transmission. For now, though, I think
    it's time we transition to a much more ubiquitously used transport layer protocol.
    And so, let's get our hands dirty with the internet protocol. It's time we explored
    IP.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头所说，多播和监听多播数据包是一项非常专业的操作，你不太可能在日常工作中需要考虑它。因此，我不会在这个主题上花费更多的时间。然而，如果你对此感兴趣，我强烈建议你在线查阅相关的文档。不过，现在，我只是想确保你对这个概念至少有一些了解，并理解`UdpClient`类中提供了哪些功能，你可以利用这些功能来实现或监听多播数据传输。不过，现在，我认为是时候转向一个更广泛使用的传输层协议了。因此，让我们深入探讨互联网协议。现在是时候研究IP了。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter served as a major paradigm shift for our understanding of network
    programming. We looked at how the responsibilities of the transport layer are
    wholly distinct from those of the application layer and we took an extremely close
    look at just what those transport layer responsibilities are. We learned that
    the **Internet Engineering Task Force** (**IETF**) has classified the various
    approaches to transport layer responsibilities based around the services and features
    a protocol might support, and how we can use those classifications to determine
    the best circumstances in which to employ a given transport layer protocol.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们理解网络编程提供了一个重大的范式转变。我们研究了传输层的责任与应用层的责任完全不同，我们非常仔细地审视了传输层的具体责任。我们了解到，**互联网工程任务组**（**IETF**）根据协议可能支持的服务和功能，对传输层责任的各种方法进行了分类，并且我们学习了如何使用这些分类来确定使用特定传输层协议的最佳情况。
- en: Next, we learned how connection-based protocols, such as TCP, use preliminary
    handshakes between clients and servers to establish an active connection, or session,
    between two hosts prior to the transmission of any data between the two. We saw
    how these sessions enable connection-based communication protocols to provide
    reliable interactions between the hosts, with substantial error-detection and
    error-correction support. Then we considered how connectionless protocols provide
    a number of advantages in their own right, including low-overhead and low-latency
    interactions between hosts over sufficiently reliable networks. Then we took a
    look at some of the strategies that can be employed by connectionless protocols,
    or the application layer protocols on top of them, to mitigate the unreliability
    of connectionless communication.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用TCP等基于连接的协议，在客户端和服务器之间进行初步握手，以在数据传输之前在两个主机之间建立活跃的连接或会话。我们看到了这些会话如何使基于连接的通信协议能够在主机之间提供可靠的交互，并具有大量的错误检测和错误纠正支持。然后我们考虑了无连接协议本身提供的一些优点，包括在足够可靠的网络上主机之间低开销和低延迟的交互。然后我们查看了一些无连接协议或其上层的应用层协议可以采用的策略，以减轻无连接通信的不可靠性。
- en: Finally, with this perspective in our minds, we were able to dive head-first
    into implementing both connection-based and connectionless clients and servers
    in C# and .NET using some incredibly simple libraries provided by the framework.
    We used a client and server designed to simulate interactions over TCP and UDP,
    and, in doing so, saw how the designers of .NET Core have conceptualized some
    of the characteristics of each protocol and implemented those characteristics
    in code. And now that we have such an in-depth understanding of both of these
    transport layer protocols, we're ready to fully examine the intricacies and nuances
    of the most ubiquitous transport layer protocol of all, the **Internet Protocol**.
    And that's exactly what we'll be doing in the next chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，带着这种观点，我们能够一头扎进使用C#和.NET框架提供的某些极其简单的库来实现基于连接和无连接的客户端和服务器。我们使用了设计用来模拟TCP和UDP交互的客户端和服务器，并在这个过程中看到了.NET
    Core的设计者如何概念化每个协议的一些特性，并在代码中实现这些特性。现在，我们对这两种传输层协议都有了深入的了解，我们准备全面检查最普遍的传输层协议——**互联网协议**的复杂性和细微差别。这正是我们将在下一章中做的事情。
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the four classifications of transport layer protocols?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输层协议的四种分类是什么？
- en: What are the primary functions and responsibilities of transport layer protocols?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输层协议的主要功能和职责是什么？
- en: What is meant by a connection in connection-based communication modes?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于连接的通信模式中，“连接”是什么意思？
- en: What does TCP stand for? Why is it typically referred to as TCP/IP?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP代表什么？为什么通常被称为TCP/IP？
- en: Describe the handshake process used to establish a connection over TCP.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述用于在TCP上建立连接的手动过程。
- en: What does UDP stand for? What are some of the advantages of UDP?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UDP代表什么？UDP有哪些优点？
- en: What are the biggest drawbacks of connectionless communication?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无连接通信的最大缺点是什么？
- en: What is multicasting? What is broadcasting, and how is it enabled in UDP?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多播是什么？广播是什么，如何在UDP中启用？
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For additional information about TCP, UDP, and the transport layer generally,
    I recommend reading *Understanding TCP/IP* by Alena Kabelová and Libor Dostálek,
    available from Packt Publishing at the following link:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TCP、UDP和传输层的一般信息，我建议阅读Alena Kabelová和Libor Dostálek所著的《Understanding TCP/IP》，可在以下链接从Packt
    Publishing获取：
- en: '[https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip).'
