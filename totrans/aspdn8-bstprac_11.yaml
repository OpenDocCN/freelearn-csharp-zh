- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code, every language has its nuances and standards. .NET is no
    different when it comes to general guidelines. One example is that placing a bracket
    at the end of a method signature is better than placing the bracket on the next
    line or placing a return immediately on the same line as an `if` statement. This
    is more of a personal preference. Programming guidelines give developers a way
    to stay between guardrails while writing code. These programming guidelines are
    used throughout the industry as standard practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the appendix, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The guidelines discussed in the following sections are commonly used in the
    industry. They give developers direction and provide guardrails as to how one
    should structure and write code not only for themselves, but also for other developers
    and peers in the future (including our future selves).
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we’ll review some programming guidelines such as the DRY,
    YAGNI, and KISS principles, along with separation of concerns, the concept of
    SOLID, and how refactoring is a process and not a one-time quick fix. We’ll finish
    the appendix by looking at recommended ways of organizing .NET projects and folder
    structures, and where code resides based on their function.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only technical requirement for the appendix is access to your editor since
    we’ll be covering general programming guidelines. While we will have snippets
    of code along the way, they don’t justify their own code repository. They’re only
    meant to solidify the understanding of the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Programming guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, I recommend various intermediate and advanced techniques
    of writing code pertaining to a particular topic or technology. While these techniques
    are meant to give developers a balance between requirements and technologies,
    there is also a need to provide common programming guidelines to follow certain
    patterns, making it easier for colleagues and peers to understand a code base.
    Successful developers think about these guidelines while writing and maintaining
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review the DRY, YAGNI, KISS, and SOLID principles along
    with understanding separation of concerns, and how refactoring is a process.
  prefs: []
  type: TYPE_NORMAL
- en: DRY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first acronym we’ll review is probably one of the simplest guidelines to
    follow. The **DRY** principle stands for **don’t** **repeat yourself**.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple methods performing the same task in different locations
    of your application, it may be time to refactor and consolidate the code.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next common acronym is **YAGNI** (pronounced yag-nee), which stands for
    **you aren’t gonna** **need it**.
  prefs: []
  type: TYPE_NORMAL
- en: Also referred to as “building the bridge to nowhere,” the concept behind this
    acronym is to let developers know they should only write code when there is a
    requirement for it. They shouldn’t add code for a possible future enhancement
    that may not come to fruition.
  prefs: []
  type: TYPE_NORMAL
- en: KISS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this next acronym has so many meanings, we’ll try to keep it simple (hence
    the name). **KISS** stands for **keep it** **simple, stupid**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep your units of code simple enough to understand. This can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller methods** – The smaller the method, the easier it is to read and
    understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language enhancements** – Based on .NET’s C# language improvements over the
    years, there may be a better (and shorter) way to write code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing complexity** – When reducing complexity, systems become more testable
    and can be a possible candidate for automated testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to build more value by creating a better code base for peers and
    colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you started writing your own application, running it and seeing it execute
    on the screen for the first time was a huge achievement.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the application required a database. Then it required email capabilities.
    Then logging. Then authentication. The requirements grew and so on and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The separation of concerns concept pertains to how you logically partition
    an application into distinct layers. For example, if an application requires an
    email module, it would be a separate project in the solution called `MyApplication.EmailModule`.
    This email module would provide the following benefits to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmailModule` could be reused in another application if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailModule` doesn’t require any outside dependencies; it’s self-contained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailModule`, unit testing (and possibly integration testing) becomes easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailModule` as opposed to the entire application. When focusing on one particular
    section, it doesn’t require the knowledge of the entire application. The knowledge
    of the project is all that’s required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the concepts heard in the industry is “Big Ball of Mud.” This concept
    pertains to all of the application code contained in one project, which is an
    unmaintainable code base. This is a similar concept to a “monolith,” where the
    application is hard to maintain because of its size. Consequently, concepts in
    the application aren’t broken out into modular units of work. If everything in
    the application is coupled together…everywhere, the system is brittle. If a developer
    modifies code in one location, it may fix the current issue but it will introduce
    errors in other locations, causing a ripple effect throughout the entire code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns is something that experienced developers should share
    with their peers through code reviews to improve software on a larger scale and
    provide healthy discussions on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring as a process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While refactoring is a fundamental concept for developers, there are various
    levels of effort involved in refactoring a code base.
  prefs: []
  type: TYPE_NORMAL
- en: One simple example could be the renaming of a method. Once a developer renames
    a method, the developer has to change all of the references to that method in
    the code base. A more advanced example is the refactoring of a business rules
    engine to create more flexibility. While both are refactoring, one is easier than
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring should be a process. One process I’ve used over the years is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get it functional** – Write functional code that works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get it tested** – Create tests to confirm the code behaves as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get it refactored** – Refactor and optimize the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code you write should (usually) have tests (see the “100% Test Coverage”
    myth in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163)).
  prefs: []
  type: TYPE_NORMAL
- en: With that said, if you’re going to refactor code, *it will be beneficial to
    have tests in place* to confirm your refactoring efforts aren’t in vain. Once
    you have tests in place, you are free to refactor and modify as much code as needed
    to achieve your intended goal.
  prefs: []
  type: TYPE_NORMAL
- en: The business rules engine was an example in my career where the code was functional
    and a lot of tests were in place (~700 passed). However, the team ran into an
    issue where the code required a more flexible approach and it had to be refactored.
    Two team members took three days to refactor the code. Once they finished the
    refactoring, they ran the final unit tests and found only two failed unit tests.
    The two failed unit tests were because they didn’t rename a method name properly.
    Imagine this refactoring without the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring can be as complex or as simple as the code base allows. Always keep
    in mind that refactoring is a multi-step process and requires tests to confirm
    the refactored code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Book recommendation
  prefs: []
  type: TYPE_NORMAL
- en: One book I would highly recommend is *Refactoring with C#, Matt Eland, Packt
    Publishing*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SOLID** principles provide even deeper guidelines for writing code. SOLID
    is an acronym and was created back in 2000 by Robert C. Martin.'
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the SOLID principles have become a standard for writing quality
    software, and give developers a way to gauge their code based on whether it meets
    each principle’s criteria. Developers may disagree with what constitutes SOLID
    code, but again, these discussions should be had with peers or in a team meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **single responsibility principle** (**SRP**) dictates that a class should
    have one and only one reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code violates the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class has two properties: `Name` and `Email`. However, we have extra
    methods performing other responsibilities: an `IsValid()` method and a `Save()`
    method. Our `User` class is doing more than it should. We should create two new
    classes: one called `UserValidation` for validation, and one called `UserService`
    or `UserRepository` for database operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two additional classes but provided better software composition.
    If we add a new property to the `User` class and it requires validation, the developer
    only needs to make a change in one place: the `UserValidation` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **open/closed principle** describes how software components should be open
    for extension but closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: Most violations of the open/closed principle are usually indicated by long branching
    statements (such as long `if..then` or `switch` statements).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this `ComicBook` class, we have three properties called `Title`, `Issue`,
    and `Grading`. One of the requirements for our class is to return the grading
    name based on the `Grading` property. This violates the open/closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Even though we already have the complete list of grades, the `GetGradeName()`
    method and add a new grade and name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation to support the open/closed principle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While it looks like we simply moved the `switch` statement, we did something
    else. We created a `Grade` class.
  prefs: []
  type: TYPE_NORMAL
- en: With a `Grade` class created, we can assign any type of grade to the `ComicBook`
    class. If a new grade type is created, we can easily add it to our list without
    modifying the `ComicBook` class. We also implemented a factory pattern in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Before, we were comparing a string based on a decimal value. Now, if additional
    properties are required for a grade, we can extend our `Grade` class to include
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: Open for extension, closed to modification.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** explains that any derived type can be
    replaced with its base types. The concept behind the Liskov substitution is based
    on inherited types and/or interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with our comic book example, the following code shows a simple
    `BasePublisher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `BasePublisher` class contains the name and address of a publisher. When
    we create a new publisher (such as the preceding `MyNewPublisher` class), we’ll
    have access to everything available in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to replace a `BasePublisher` class with a `MyNewPublisher` class
    would be an example of the Liskov substitution principle.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **interface segregation principle** explains that clients shouldn’t be forced
    to implement unnecessary methods they won’t use.
  prefs: []
  type: TYPE_NORMAL
- en: With every interface created in an application, each method and property defined
    should be implemented in a concrete class. The defined interfaces should not go
    to waste in an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have an interface for our `ComicBook` class. The
    interface and implementation code are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Everything in our `ComicBook` class is justified except for the `SaveToDatabase()`
    method. Creating a new `ComicBook` instance suggests we’ll be using the database
    every time. This violates the interface segregation principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation would be splitting the database access out into an
    `IComicBookWriter` with a `SaveToDatabase()` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The example code shows how inheriting from the `IComicBookWriter` gives the
    `ComicBook` class a way to persist the data.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the interface segregation principle is to avoid including methods
    in an interface that you won’t use.
  prefs: []
  type: TYPE_NORMAL
- en: This example is also a violation of the SRP since this class is also accessing
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **dependency inversion principle** explains that we should depend on abstractions
    and not on concrete implementations. With .NET, dependency injection is available
    out of the box. With dependency injection automatically available, this satisfies
    half of our dependency inversion principle.
  prefs: []
  type: TYPE_NORMAL
- en: While we can dependency-inject concrete classes into constructors, a better
    implementation would be to create an interface for the concrete implementation.
    Using interfaces encourages loose coupling throughout our code base.
  prefs: []
  type: TYPE_NORMAL
- en: For example, back in [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114) with Entity
    Framework, we created a simple interface for our `DbContext`s for this very reason.
    Instead of registering a concrete implementation of a `DbContext`, we could use
    its interface instead.
  prefs: []
  type: TYPE_NORMAL
- en: We registered our abstraction (interface) to support our dependency inversion
    principle.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, the terms DRY, YAGNI, and KISS, along with what separation
    of concerns means and how refactoring is a process and not a single task. We finished
    the section by learning each SOLID practice, namely the single responsibility,
    open/closed, Liskov substitution, interface segregation, and dependency inversion
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn about folder organization based on project
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163), on testing,
    folder structures can reveal an application’s intent and provide documentation
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn about folder structures with ASP.NET web applications.
    We’ll also learn where to place code based on intent, such as where to place API
    code or Entity Framework code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every project has its own structure based on its type. For example, a **Razor
    Page** project layout is different from a **Model-View-Controller** (**MVC**)
    project or an API project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine what folders are in these common projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the following is an example of an ASP.NET Razor Page project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Common folder structure of a Razor Page project](img/B19493_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Common folder structure of a Razor Page project
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is an example of an ASP.NET MVC project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 - Common folder structure of an MVC project](img/B19493_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 - Common folder structure of an MVC project
  prefs: []
  type: TYPE_NORMAL
- en: As we move through each project, we’ll explain what each folder does and its
    purpose in the application.
  prefs: []
  type: TYPE_NORMAL
- en: wwwroot folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In either of the preceding project types, the `wwwroot` folder contains all
    of our static content used on the website. Any folder added to this directory
    is static content and visible to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example is an images folder. If we added an images folder to the `wwwroot`
    folder, the URL to that images folder would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For JavaScript frameworks (such as Angular, React, etc.), a folder called `source`
    or `src` should be created under the `wwwroot` folder to hold your client-side
    source code. The JavaScript framework should be transpiled to another folder of
    your choosing, such as a `js` or `app` folder for public browser consumption.
    We touched on these folders in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)
    when we were building our client-side tasks using a task runner.
  prefs: []
  type: TYPE_NORMAL
- en: Pages folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Razor Page project, the `Pages` folder is where server-side pages are found.
    Every folder created is a path to a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we created a `Setup` folder and added an `Index.cshtml` file,
    the URL to execute and view that page would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Other folders created under the `Pages` directory would follow the same path,
    as shown in *Figure 11**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Folder structure for a MenuManager page](img/B19493_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Folder structure for a MenuManager page
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the directory structure in *Figure 11**.3*, the URL to **MenuManager**
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The simpler the folder structure, the easier it is to locate a page and identify
    page functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Shared folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Shared` folder is used for common components such as layout pages, `ViewComponents`,
    partials, `EditorTemplates`, and `DisplayTemplates`. These shared components are
    accessible through web pages in the `Pages` folder (if it’s a Razor Pages project)
    or the `Views` folder (if it’s an MVC project).
  prefs: []
  type: TYPE_NORMAL
- en: Controllers folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVC projects always contain a `Controllers` folder and are the traffic cops
    of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC web model uses a “convention over configuration” concept where the name
    of the controller is the path and the methods inside the controller class are
    the page names.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the aforementioned `Controllers` folder, we have a class called
    `HomeController`. If we look in `HomeController`, we’ll see a method called `Index()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of a `HomeController` class tells us three things:'
  prefs: []
  type: TYPE_NORMAL
- en: We will have a `/Home` URL with an `Index()` method for a default page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Home` folder is located under the `/``Views` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is an `Index()` method in `HomeController`, there should be an `Index.cshtml`
    in the `/``Views/Home` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Index()` method tells us when the `https://localhost:xxx/Home` URL is called.
    It will automatically hit this `Index()` method and, by default, look for the
    Index view in the `/``Views/Home` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Feature folders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the secrets of an MVC application is the ability to move controllers
    around to any folder inside the application. On initial startup, the ASP.NET framework
    locates all of the controllers available throughout the application and creates
    a routing table for incoming web requests. Based on this approach, developers
    in the community have created **feature folders**.
  prefs: []
  type: TYPE_NORMAL
- en: Feature folders are usually contained in a folder called `/Features` off the
    root with folders underneath to identify the feature implemented. While a `/Features`
    folder is the most common, developers have the ability to name the folder anything
    they want. They can also place controllers under any folder in the project. ASP.NET
    can locate all of the controllers on startup.
  prefs: []
  type: TYPE_NORMAL
- en: These folders usually contain a minimum of a controller, a ViewModel, and a
    View. They can also contain supporting classes related to the feature. The folder
    is named based on the feature being implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if there was an image viewing feature in your MVC application,
    it would look like *Figure 11**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Example of an ImageViewer feature folder](img/B19493_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Example of an ImageViewer feature folder
  prefs: []
  type: TYPE_NORMAL
- en: 'This folder structure provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus** – Each feature is isolated so team members can build the feature
    without causing merge issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consolidation** – Instead of moving from one folder to another throughout
    the entire project, features are confined to one folder, making the coding process
    more efficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Features/AccountsReceiveable` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In MVC, the View path can be modified to fit your needs. In this case, defining
    a custom path to your views provides even more flexible configurations for your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The `Features` folder technique is becoming a more viable option for creating
    scalable, feature-based web applications by offering vertical slicing. Vertical
    slicing is the process of writing code for an entire feature across all layers
    (presentation, domain, and data access). Feature folders simplify this process
    and convey isolated features in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Models folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Models` folder contains all of the models used for your Views. This is
    different from a ViewModel. The difference between Models and ViewModels is that
    ViewModels are passed into the View and can contain models to support the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a ViewModel is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A ViewModel is sent to the View (`IndexViewModel`) where a Model can be data
    supporting the ViewModel (`ProductDto`).
  prefs: []
  type: TYPE_NORMAL
- en: Two common practices include either creating a `ViewModels` directory under
    the `Models` folder, or a `ViewModels` directory in the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Views folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an MVC project, the `Views` folder is the equivalent of the `Pages` folder
    in a Razor Pages project. It contains the same folder structure as a Razor Pages
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating project layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a new web application, the default web project contains the bare
    essentials to run in a browser. But how do you segment the application so you
    don’t have a huge pile of unmanageable code?
  prefs: []
  type: TYPE_NORMAL
- en: A layer, or tier, is a segment of the application broken up into modules or
    projects designed to perform in a certain way. A presentation layer contains the
    user interface of how the user interacts with the website, while a data access
    layer retrieves data for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying project layers can be a bit of a daunting task, but the best way
    is to create application layers based on their functionality. Each project will
    have a consistent naming convention based on its function.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the following are recommended project layers and names, architect and
    team suggestions may overrule these choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<ProjectName>.Domain` or `<ProjectName>.Core`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ProjectName>.Web` or `<ProjectName>.UI`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ProjectName>.Data` or `<ProjectName>.Infrastructure`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api`) or contained in a separate project called `<ProjectName>.Api`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Infrastructure` project, the amount of code in an infrastructure project can
    become overwhelming. A services project could provide an alternative to the `Infrastructure`
    project. Services could include a `MailService` or `<Entity>Service`. These projects
    are usually named `<ProjectName>.Services`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These code layers provide the best layout when organizing your project. Each
    project name describes the intent and gives developers a clear representation
    of the solution as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we learned the DRY, YAGNI, and KISS principles, along with
    separation of concerns, the concept of SOLID, and how refactoring is a process
    and not a one-time quick fix.
  prefs: []
  type: TYPE_NORMAL
- en: We proceeded to look at how two common ASP.NET web applications were structured
    and what each folder represented. Once we understood a project’s folder structure,
    we examined where code would reside based on its intent, such as Entity Framework
    or service classes.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Best practices are considered to be what is correct, common, and accepted by
    others in the field. The best practices contained in this book are a combination
    of observations, experience, and feedback over the years from my peers, mentors,
    and the developer community.
  prefs: []
  type: TYPE_NORMAL
- en: I hope these best practices serve as a reference for your ASP.NET development
    career and that you can achieve the same level of excitement as I do when I experience
    a new programming technique or technology.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for your readership!
  prefs: []
  type: TYPE_NORMAL
- en: Code on, developers... code on!
  prefs: []
  type: TYPE_NORMAL
