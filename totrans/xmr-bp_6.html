<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Building a Chat Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Chat Application</h1></div></div></div><p>In this chapter, we will be moving back into Xamarin native. Our user interface will move away from an MVVM design and follow a new paradigm called <span class="strong"><strong>Model-View-Presenter</strong></span> (<span class="strong"><strong>MVP</strong></span>). We will also step further into the backend and setup a SignalR hub and client to simulate a chat service, which data will be sent between the server and clients instantly as the messages become available. Another key topic of focus is project architecture, spending time on separating the project into modules, and creating a nicely tiered structure that will maximize code sharing across different platforms.</p><p>The following knowledge is expected:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some understanding of Xamarin native (iOS and Android)</li><li class="listitem" style="list-style-type: disc">Visual Studio</li><li class="listitem" style="list-style-type: disc">Some understanding of the OWIN specification</li><li class="listitem" style="list-style-type: disc">Some understanding of OAuth</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Model-View-Presenter (MVP) pattern</li><li class="listitem" style="list-style-type: disc">Architecture</li><li class="listitem" style="list-style-type: disc">SignalR</li><li class="listitem" style="list-style-type: disc">Starting with Open Web Interface for .NET (OWIN)</li><li class="listitem" style="list-style-type: disc">Creating an authorization server using OWIN OAuth 2.0</li><li class="listitem" style="list-style-type: disc"><code class="literal">OAuthAuthorizationServerProvider</code></li><li class="listitem" style="list-style-type: disc">Authorization server providers</li><li class="listitem" style="list-style-type: disc"><code class="literal">UseOAuthBearerAuthentication</code></li><li class="listitem" style="list-style-type: disc">Setting up the Authentication Repository</li><li class="listitem" style="list-style-type: disc">Configuring the Web API</li><li class="listitem" style="list-style-type: disc">Building the AccountController</li><li class="listitem" style="list-style-type: disc">Configuring OAuth Authentication with our Web API</li><li class="listitem" style="list-style-type: disc">Building the SignalR Hub</li><li class="listitem" style="list-style-type: disc">Setting up mobile projects</li><li class="listitem" style="list-style-type: disc">Creating the <code class="literal">SignalRClient</code></li><li class="listitem" style="list-style-type: disc">Building the Web API access layer</li><li class="listitem" style="list-style-type: disc">Application State</li><li class="listitem" style="list-style-type: disc">Setting up the navigation service</li><li class="listitem" style="list-style-type: disc">Building the iOS navigation service</li><li class="listitem" style="list-style-type: disc">Building the Android navigation service</li><li class="listitem" style="list-style-type: disc">Building the iOS interface</li><li class="listitem" style="list-style-type: disc">Handling Hub proxy callbacks</li><li class="listitem" style="list-style-type: disc">Implementing the <code class="literal">LoginPresenter</code></li><li class="listitem" style="list-style-type: disc">Creating the connection between Presenter and View</li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">LoginActivity</code></li><li class="listitem" style="list-style-type: disc">Implementing the <code class="literal">ClientsListPresenter</code></li><li class="listitem" style="list-style-type: disc">Creating the <code class="literal">ClientListViewController</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">TaskCompletionSource</code> framework</li><li class="listitem" style="list-style-type: disc">Creating the <code class="literal">ClientsListActivity</code></li><li class="listitem" style="list-style-type: disc">Overriding the Activity <code class="literal">OnBackPressed()</code></li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">ListAdapter</code></li><li class="listitem" style="list-style-type: disc">Building the <code class="literal">ChatPresenter</code></li><li class="listitem" style="list-style-type: disc">Building the iOS <code class="literal">ChatView</code></li><li class="listitem" style="list-style-type: disc">Extending the <code class="literal">UIColor</code> framework</li><li class="listitem" style="list-style-type: disc">Android <code class="literal">TableLayouts</code></li><li class="listitem" style="list-style-type: disc">Building the Android <code class="literal">ChatActivity</code></li><li class="listitem" style="list-style-type: disc">Running the server and clients</li></ul></div><div class="section" title="The Model-View-Presenter (MVP) pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec77"/>The Model-View-Presenter (MVP) pattern</h1></div></div></div><p>In all our previous chapters we have focused our development patterns around the <span class="strong"><strong>Model-View-View-Model</strong></span> (<span class="strong"><strong>MVVM</strong></span>) approach. This time we are going to be setting up our project around the MVP design pattern. In MVP the presenter centralizes the user interface functionality between the model and the view, meaning all presentation logic is pushed to the presenter.</p><div class="mediaobject"><img src="graphics/B05293_06_01.jpg" alt="The Model-View-Presenter (MVP) pattern"/></div><div class="section" title="So why bother with this approach?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec37"/>So why bother with this approach?</h2></div></div></div><p>The advantage with this approach is we can apply unit testing to our presenters, meaning all UI logic is tested via the presenter. We also have the ability to keep our user interfaces in native, and share a great amount of the UI logic between the different platforms.</p></div></div></div>
<div class="section" title="Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Architecture</h1></div></div></div><p>When it comes to cross-platform applications, our goal is to share as much code as possible. We focus our attention on architecture, having a nice clean project structure that lends itself to a maximization of code sharing across platforms. So how do we solve this problem? Ask yourself:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What are the different layers?</li><li class="listitem" style="list-style-type: disc">How do we set up the folder structure?</li><li class="listitem" style="list-style-type: disc">What parts go in which projects?</li></ul></div><p>There are many different approaches to this problem; here are some of the most common architectural layers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data layer</strong></span>: This stores the database</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data access layer</strong></span>: This layer focuses on the objects and wrappers that apply operations on the data layer (Read, Write, Update)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Business layer (logic)</strong></span>: This layer focuses on the different domains (domain-driven design), separating the different areas of logic into objects that handle operations for each domain</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Service access layer</strong></span>: The area that focuses operations on the web API, how we handle JSON, and data sent and received between the API Controllers</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Application/platform layer</strong></span>: Code which is not shared, specific to the native platform</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Common layer</strong></span>: A shared project, code which is shared to all native projects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User interface layer</strong></span>: The layer which contains all the UI design (XAML sheets, UIViewControllers, AXML)</li></ul></div><div class="section" title="How do we determine which layers our project needs?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>How do we determine which layers our project needs?</h2></div></div></div><p>In this example it is quite simple; we don't have a database so we don't need the data layer or data access layer. Everything else we will require, so let's begin building our project from the ground up, starting with the lower layers first.</p><p>We are going to start building the project from the service access layer; it will include everything involved with SignalR, so our first step is to build the backend SignalR hub.</p></div></div>
<div class="section" title="SignalR"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec79"/>SignalR</h1></div></div></div><p>SignalR is a library that provides real-time web functionality to applications using WebSocket transport (if HTML 5 is supported; older transport methods will be used if it is not supported). It has the ability for a server to push data to its clients in real-time as it becomes available; this means we do not have to repeatedly ask the server for data (such as refreshing/recalling the Web API).</p><p>In order to set up SignalR, we must first set up a SignalR <span class="strong"><strong>Hub</strong></span> on the server side; our clients (mobile projects) will use access this <span class="strong"><strong>Hub</strong></span> by creating a <span class="strong"><strong>HubConnection </strong></span>and creating a <span class="strong"><strong>HubProxy</strong></span> from which the server and client can call functions on either side.</p><div class="mediaobject"><img src="graphics/B05293_06_02.jpg" alt="SignalR"/></div><p>Now let's get into development; we will have the same hardware set up as the last chapter. We will set up a locally hosted backend via Visual Studio and build our mobile projects via Xamarin Studio on MacOSX. Open up Visual Studio, create a <code class="literal">newASP.NET</code> web application, and call it <code class="literal">Chat</code>.</p><div class="mediaobject"><img src="graphics/B05293_06_03.jpg" alt="SignalR"/></div><p>Then we must select a template; select the <span class="strong"><strong>Empty</strong></span> template:</p><div class="mediaobject"><img src="graphics/B05293_06_04.jpg" alt="SignalR"/></div><p>Great! We now have our empty project, let's start by adding the NuGet package, <span class="strong"><strong>Microsoft.AspNet.SignalR</strong></span>.</p><div class="mediaobject"><img src="graphics/B05293_06_05.jpg" alt="SignalR"/></div><p>A readme file will appear with some basic directions on setting up the SignalR <span class="strong"><strong>Hub</strong></span>. We also want to add Web API 2.2 features for OWIN as we will be adding a small Web API to the project to handle login, register, and account functionality. Let's add in the following libraries:</p><div class="mediaobject"><img src="graphics/B05293_06_06.jpg" alt="SignalR"/></div><p>This will install Web API functionality so we can create API controllers and map routes through the <code class="literal">Startup</code> class. We then want to add the Web API 2.2 OWIN library to integrate the OWIN pipeline to our HTTP configuration:</p><div class="mediaobject"><img src="graphics/B05293_06_07.jpg" alt="SignalR"/></div><p>We also want to add the <code class="literal">OWIN.Security</code> libraries for handling account authorization using <span class="strong"><strong>Bearer tokens</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>Bearer tokens are used in HTTP request headers for authorizing access to OAuth 2.0 protected resources.</p></div></div><div class="mediaobject"><img src="graphics/B05293_06_08.jpg" alt="SignalR"/></div><p>Finally, we have to add another package called <code class="literal">Microsoft.AspNet.Identity.Framework</code>. This library will be used to handle storage of user accounts (usernames and passwords) using the <code class="literal">UserManager</code> framework.</p><div class="mediaobject"><img src="graphics/B05293_06_09.jpg" alt="SignalR"/></div><p>Now that we have all our packages added, let's start building the web application from the ground up.</p></div>
<div class="section" title="Starting with Open Web Interface for .NET (OWIN)"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Starting with Open Web Interface for .NET (OWIN)</h1></div></div></div><p><span class="strong"><strong>OWIN</strong></span> is a standard interface between .NET servers and web applications. It provides a middleware for decoupling a web server from a web application. The biggest advantage of OWIN is that we are able to host the web application anywhere, and keep the server and application completely separated.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>For more information on OWIN, the best place to start is with the Katana Project. Katana is a collection of projects that support OWIN with various Microsoft components.</p></div></div><p>So what does OWIN have to do with our project?</p><p>If you notice the code above we see all references to OWIN namespaces, and we register in the assembly the <code class="literal">OwinStartup</code> object to our <code class="literal">Startup</code> class. We must have at least one <code class="literal">Startup</code> class registered in the <code class="literal">OwinStartup</code> attribute. The <code class="literal">Startup</code> class has one function called <code class="literal">Configuration</code>. All <code class="literal">Startup</code> classes must include this function, and it must accept <code class="literal">IAppBuilder</code>. Additional services, such as <code class="literal">IHostingEnvironment</code> and <code class="literal">ILoggerFactory</code> may also be specified, in which case these services will be injected by the server if they are available. The <code class="literal">Configuration</code> specifies how the application will respond to individual HTTP requests. Finally, in our <code class="literal">Configuration</code> method, we will be calling the <code class="literal">MapSignalR</code> (an extension to the <code class="literal">IAppBuilder</code> object). This will define the route for clients to use to connect to your <span class="strong"><strong>Hub/s</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>The route is set to the app builder pipeline at the URL <code class="literal">/signalr</code> by default: we can also customize this URL if required.</p></div></div><p>Our next step is to bring in some security.</p><div class="section" title="Creating an authorization server using OWIN OAuth 2.0"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Creating an authorization server using OWIN OAuth 2.0</h2></div></div></div><p>The OAuth 2.0 framework enables a server to provide clients with limited access for HTTP services. Protected server resources can only be accessed via access tokens that expire after certain periods of time. Clients will shoot a HTTP request at a domain endpoint URL (normally <code class="literal">/token</code>), the server will send a response with token details (such as expiration, access token, time/date issued), and the access token will be used for a period of time with other HTTP request headers to authorize access to protected resources.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>Access tokens are strings denoting specified scope, lifetime, and other access attributes.</p></div></div><p>So where do we begin to set up server authorization?</p><p>Our first step is to build the logic behind granting clients access from username and password credentials.</p></div><div class="section" title="OAuthAuthorizationServerProvider"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>OAuthAuthorizationServerProvider</h2></div></div></div><p>An <code class="literal">OAuthAuthorizationServerProvider</code> determines how we validate user credentials using <code class="literal">OAuthGrantResourceOwnerCredentialsContext</code>. Its job is to simply handle the authentication of users. This item provides the context in which we handle resource grants.</p><p>Let's add a new folder called <code class="literal">Providers</code>, and add a new file in this folder called <code class="literal">AuthorizationServerProvider.cs</code>. Implement the following:</p><pre class="programlisting">public class AuthorizationServerProvider : OAuthAuthorizationServerProvider &#13;
    { &#13;
        public override async Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context) &#13;
        { &#13;
            context.Validated(); &#13;
        } &#13;
  &#13;
        public override async Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context) &#13;
        { &#13;
            context.OwinContext.Response.Headers.Add("Access-Control-Allow-Origin", new[] { "*" }); &#13;
            string userName = null; &#13;
  &#13;
            using (AuthenticationRepository authenticationRepository = new AuthenticationRepository()) &#13;
            { &#13;
                IdentityUser user = await authenticationRepository.FindUser(context.UserName, context.Password); &#13;
  &#13;
                if (user == null) &#13;
                { &#13;
                    context.SetError("invalid_grant", "Incorrect user name or password"); &#13;
                    return; &#13;
                } &#13;
  &#13;
                userName = user.UserName; &#13;
            } &#13;
  &#13;
            var identity = new ClaimsIdentity(context.Options.AuthenticationType); &#13;
            identity.AddClaim(new Claim("Role", "User")); &#13;
            identity.AddClaim(new Claim("UserName", userName)); &#13;
  &#13;
            context.Validated(identity); &#13;
        } &#13;
    }   &#13;
</pre><p>Our implementation of the <code class="literal">OAuthAuthorizationServerProvider</code> will override the <code class="literal">ValidateClientAuthentication</code> function, which simply returns whether the <code class="literal">usercontext</code> has been validated. We then override the <code class="literal">GrantResourceOwnerCredentials()</code> function, which is called when a request to the token endpoint (<code class="literal">/token</code>) arrives with a <code class="literal">grant_type</code> of <code class="literal">password</code> (this key is set in the request header along with the username and password). The function will simply initialize a new <code class="literal">AuthenticationRepository</code> to access the <code class="literal">UserManager</code> framework and check if the user exists; if it doesn't we return, and the context will still be invalid. If the user exists, we create a new <code class="literal">ClaimsIdentity</code> object with two claims, one for the <span class="emphasis"><em>role</em></span> and <span class="emphasis"><em>username</em></span> principles of there source owner (the user who sent the HTTP request). Finally, we then place the <code class="literal">ClaimsIdentity</code> object into the <code class="literal">context.Validated()</code> function in order to issue the access token. This <code class="literal">ClaimsIdentity</code> object is now the ticket that contains the claims about the resource owner (the user) associated with the access token.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note82"/>Note</h3><p>A <code class="literal">ClaimsIdentity</code> is an object that is a collection of <code class="literal">Claim</code> objects to represent an entity's identity. Each <code class="literal">Claim</code> object is simply a statement describing an identity's role, permission, or an other quality of an entity.</p></div></div></div><div class="section" title="Use OAuthBearerAuthentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Use OAuthBearerAuthentication</h2></div></div></div><p>Our next step is to add the logic behind handling bearer tokens (these are the access tokens granted by the authorization server provider). <code class="literal">UseOAuthBearerAuthentication</code> has the job of ensuring that only authenticated users can access your protected server resources (in our example the <code class="literal">ChatHub</code>). Add a new file called <code class="literal">OAuthBearerTokenAuthenticationProvider.cs</code> and implement the following:</p><pre class="programlisting">public class OAuthBearerTokenAuthenticationProvider : OAuthBearerAuthenticationProvider &#13;
    { &#13;
        public override Task RequestToken(OAuthRequestTokenContext context) &#13;
        { &#13;
            string cookieToken = null; &#13;
            string queryStringToken = null; &#13;
            string headerToken = null; &#13;
  &#13;
            try &#13;
            { &#13;
                cookieToken = context.OwinContext.Request.Cookies["BearerToken"]; &#13;
            } &#13;
            catch (NullReferenceException) &#13;
            { &#13;
                System.Diagnostics.Debug.WriteLine("The cookie does not contain the bearer token"); &#13;
            } &#13;
  &#13;
            try &#13;
            { &#13;
                queryStringToken = context.OwinContext.Request.Query["BearerToken"].ToString(); &#13;
            } &#13;
            catch (NullReferenceException) &#13;
            { &#13;
                System.Diagnostics.Debug.WriteLine("The query string does not contain the bearer token"); &#13;
            } &#13;
  &#13;
            try &#13;
            { &#13;
                headerToken = context.OwinContext.Request.Headers["BearerToken"]; &#13;
            } &#13;
            catch (NullReferenceException) &#13;
            { &#13;
                System.Diagnostics.Debug.WriteLine("The connection header does not contain the bearer token"); &#13;
            } &#13;
  &#13;
            if (!String.IsNullOrEmpty(cookieToken)) &#13;
                context.Token = cookieToken; &#13;
  &#13;
            else if (!String.IsNullOrEmpty(queryStringToken)) &#13;
                context.Token = queryStringToken; &#13;
  &#13;
            else if (!String.IsNullOrEmpty(headerToken)) &#13;
                context.Token = headerToken; &#13;
  &#13;
            return Task.FromResult&lt;object&gt;(null); &#13;
        } &#13;
    } &#13;
</pre><p>Let's look at this item more closely. We are overriding the <code class="literal">RequestToken()</code> function to access the <code class="literal">OAuthRequestTokenContext</code> from every HTTP request that hits the server. Inside the <code class="literal">OwinContext</code> object, we can access the HTTP request that just hit the server, check through the dictionary of headers for our <code class="literal">BearerToken</code>, and then extract this access token and assign it to the <code class="literal">OAuthRequestTokenContext.Token</code> property.</p></div></div>
<div class="section" title="Setting up the AuthenticationRepository"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Setting up the AuthenticationRepository</h1></div></div></div><p>Now we move on to the <code class="literal">AuthenticationRepository</code>. This is the object that will handle access and storage using the <code class="literal">UserManager</code> framework provided by the <code class="literal">Identity.EntityFramework</code> library. Add in a new folder called <code class="literal">Repositories</code>, then add a new file called <code class="literal">AuthenticationRepository.cs</code>, and implement the following:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note83"/>Note</h3><p>The <code class="literal">UserManager</code> class is a facade for providing identity management in any ASP.Net application</p></div></div><pre class="programlisting">public class AuthenticationRepository : IDisposable &#13;
    { &#13;
        private AuthenticationContext authenticationContext; &#13;
        private UserManager&lt;IdentityUser&gt; userManager; &#13;
  &#13;
        public AuthenticationRepository() &#13;
        { &#13;
            authenticationContext = new AuthenticationContext(); &#13;
            userManager = new UserManager&lt;IdentityUser&gt;(new UserStore&lt;IdentityUser&gt;(authenticationContext)); &#13;
        } &#13;
  &#13;
        public async Task&lt;IdentityResult&gt; RegisterUser(UserModel userModel) &#13;
        { &#13;
            IdentityUser newUser = new IdentityUser() &#13;
            { &#13;
                UserName = userModel.Username &#13;
            }; &#13;
  &#13;
            var foundUser = await userManager.FindByNameAsync(newUser.UserName); &#13;
            if (foundUser != null) &#13;
            { &#13;
                await userManager.RemovePasswordAsync(foundUser.Id); &#13;
                return await userManager.AddPasswordAsync(foundUser.Id, userModel.Password); &#13;
            } &#13;
            else &#13;
            { &#13;
                return await userManager.CreateAsync(newUser, userModel.Password); &#13;
            } &#13;
        } &#13;
  &#13;
        public async Task&lt;IdentityUser&gt; FindUser(string userName, string password) &#13;
        { &#13;
            return await userManager.FindAsync(userName, password); &#13;
        } &#13;
  &#13;
        public void Dispose() &#13;
        { &#13;
            authenticationContext.Dispose(); &#13;
            userManager.Dispose(); &#13;
        } &#13;
    } &#13;
</pre><p>Our main concern here involves two functions, one for registering users if they don't exist, and one for finding users. The authorization server provider uses <code class="literal">FindUser</code> to determine whether a user exists to confirm authentication.</p><p>We also need to add another file called <code class="literal">AuthenticationContext.cs</code> and implement the following:</p><pre class="programlisting">public class AuthenticationContext : IdentityDbContext&lt;IdentityUser&gt; &#13;
    { &#13;
        public AuthenticationContext() &#13;
            : base("AuthenticationContext") &#13;
        { &#13;
        } &#13;
    }  &#13;
</pre><p>This is a very simple class which inherits the <code class="literal">IdentityDBContext</code> of type <code class="literal">IdentityUser</code>. This object is the access layer for retrieving data objects (<code class="literal">IdentityUser </code>objects) via the <code class="literal">EntityFramework</code>. The following diagram shows the layers of logic between your ASP.Net application and <code class="literal">EntityFramework</code>:</p><div class="mediaobject"><img src="graphics/B05293_06_10.jpg" alt="Setting up the AuthenticationRepository"/></div><p>Fantastic! Hopefully those topic weren't too confusing. Now let's start building the Web API.</p><div class="section" title="Configuring the Web API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Configuring the Web API</h2></div></div></div><p>Our next step is to configure the Web API. Let's add in a new folder called <code class="literal">App_Start</code>. Inside this folder add a new file called <code class="literal">WebApiConfig.cs</code> and implement the following:,</p><pre class="programlisting">public static class WebApiConfig &#13;
    { &#13;
        public static void Register(HttpConfiguration config) &#13;
        { &#13;
            config.Routes.MapHttpRoute( &#13;
                name: "DefaultApi", &#13;
                routeTemplate: "api/{controller}/{action}/{id}", &#13;
                defaults: new { id = RouteParameter.Optional } &#13;
            ); &#13;
        } &#13;
    } &#13;
</pre><p>Look more closely at the <code class="literal">routeTemplate</code>; notice the <code class="literal">{action}</code> addition? This means we have to include the <code class="literal">ActionName</code> attribute with each function in our <code class="literal">AccountController</code>. The <code class="literal">ActionName</code> attribute represents the URL extension, for example:</p><pre class="programlisting">ActionName("Register") = http://{IP Address}:{Port}/Register &#13;
</pre><p>Now let's add another file called <code class="literal">Startup.cs</code> and implement the following:,</p><pre class="programlisting">public class Startup &#13;
    { &#13;
        public void Configuration(IAppBuilder app) &#13;
        {  &#13;
            HttpConfiguration config = new HttpConfiguration(); &#13;
            WebApiConfig.Register(config); &#13;
  &#13;
            app.UseWebApi(config); &#13;
        } &#13;
    } &#13;
</pre><p>Now let's move on to building the <code class="literal">AccountController</code> to handle incoming HTTP requests for user login and registration.</p></div><div class="section" title="Building the AccountController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Building the AccountController</h2></div></div></div><p>Now that we have configured the Web API, let's build the first API controller. Add in a new folder called <code class="literal">Models</code>. Inside this folder, add a new file called <code class="literal">UserModel.cs</code>, and implement the following:</p><pre class="programlisting">public class UserModel { &#13;
  &#13;
        [Required] &#13;
        public string Username { get; set; } &#13;
  &#13;
        [Required] &#13;
        public string Password { get; set; } &#13;
    } &#13;
</pre><p>The object will contain the username and password fields passed in through the HTTP request from the client. The <code class="literal">Register</code> attribute is used to make sure that this property is included with the HTTP request. We can then map this attribute to the API controller <code class="literal">ModelState.IsValid</code> check, so if any of the properties with this attribute are missing, the <code class="literal">IsValid</code> property will be <code class="literal">false</code>. Next, let's add in another folder called <code class="literal">Controllers</code>. Inside this folder add in a new file, <code class="literal">AccountController.cs</code>, and implement the following:</p><pre class="programlisting">public class AccountController : ApiController &#13;
    { &#13;
        private AuthenticationRepository authenticationRepository; &#13;
 &#13;
        public AccountController() &#13;
        { &#13;
            authenticationRepository = new AuthenticationRepository(); &#13;
        } &#13;
 &#13;
        [HttpPost] &#13;
        [AllowAnonymous] &#13;
        [ActionName("Register")] &#13;
        public async Task&lt;IHttpActionResult&gt; Register(UserModel userModel) &#13;
        { &#13;
            if (!ModelState.IsValid) &#13;
            { &#13;
                return BadRequest(ModelState); &#13;
            } &#13;
 &#13;
            var result = await authenticationRepository.RegisterUser(userModel); &#13;
            return Ok(); &#13;
        } &#13;
    } &#13;
</pre><p>Our first step is the <code class="literal">Register</code> function, which is responsible for storing a new user into the <code class="literal">UserManager</code> through the <code class="literal">AccountRepository</code>.</p><p>Notice the if statement on <code class="literal">ModalState.IsValid</code>?</p><p>If either the <code class="literal">Username</code> or <code class="literal">Password</code> properties are missing from the HTTP request, it will return <code class="literal">false</code>.</p><p>Let's now add the <code class="literal">Login</code> function:</p><pre class="programlisting">[HttpPost] &#13;
        [AllowAnonymous] &#13;
        [ActionName("Login")] &#13;
        public async Task&lt;bool&gt; Login(UserModel userModel) &#13;
        { &#13;
            if (!ModelState.IsValid) &#13;
            { &#13;
                return false; &#13;
            } &#13;
            var result = await &#13;
            authenticationRepository.FindUser(userModel.Username, &#13;
            userModel.Password); &#13;
            return (result != null); &#13;
        } &#13;
</pre><p>This is exactly the same as <code class="literal">Register</code> but we are using the <code class="literal">FindUser</code> function to check if the user exists in the <code class="literal">UserManager</code>. Finally, to avoid any memory leakage, we need to make sure that the <code class="literal">AuthenticationRepostiory</code> is disposed when the API controller is disposed. Let's override the <code class="literal">Dispose</code> function like this:</p><pre class="programlisting">         protected override void Dispose(bool disposing) &#13;
        { &#13;
            if (disposing) &#13;
                authenticationRepository.Dispose(); &#13;
 &#13;
            base.Dispose(disposing); &#13;
        } &#13;
</pre><p>Great! That's everything for the <code class="literal">AccountController</code>, now we must integrate the OAuth authentication and Web API together.</p></div><div class="section" title="Configuring OAuth Authentication with our Web API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Configuring OAuth Authentication with our Web API</h2></div></div></div><p>In order to integrate our OAuth module with the Web API we must add some extra configuration in <code class="literal">Startup.cs</code>. Add in a new function called <code class="literal">ConfigureOAuth</code> like this:</p><pre class="programlisting">public class Startup &#13;
    { &#13;
        ... &#13;
 &#13;
public void ConfigureOAuth(IAppBuilder app) &#13;
        { &#13;
            OAuthAuthorizationServerOptions OAuthServerOptions = new OAuthAuthorizationServerOptions() &#13;
            { &#13;
                AllowInsecureHttp = true, &#13;
                TokenEndpointPath = new PathString("/token"), &#13;
                AccessTokenExpireTimeSpan = TimeSpan.FromDays(1), &#13;
                Provider = new AuthorizationServerProvider() &#13;
            }; &#13;
  &#13;
            app.UseOAuthAuthorizationServer(OAuthServerOptions); &#13;
            app.UseOAuthBearerAuthentication(new OAuthBearerAuthenticationOptions() &#13;
            { &#13;
                Provider = new OAuthBearerTokenAuthenticationProvider() &#13;
            }); &#13;
  &#13;
        } &#13;
 &#13;
   ... &#13;
} &#13;
</pre><p>Looking more closely, we start with instantiating a new <code class="literal">OAuthAuthorizationServerOptions</code> object, we set the endpoint URL, expiration period for an access token, and the provider is set to our <code class="literal">AuthorizationServerProvider</code> class created in the preceding example. We then add this object into the <code class="literal">IAppBuilder</code> object using the function <code class="literal">UseOAuthAuthorizationServer</code>. Finally, we create a new <code class="literal">OAuthBearerAuthenticationOptions</code> object where the provider is set to our <code class="literal">OAuthBearerTokenAuthenticationProvider</code> object created in the preceding example.</p><p>That's all for now; we now have OAuth authentication integrated with our Web API. Now let's implement the final part of our server application.</p></div><div class="section" title="Building the SignalR Hub"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Building the SignalR Hub</h2></div></div></div><p>The <code class="literal">ChatHub</code> will be responsible for routing messages between clients using a <code class="literal">ConnectionId</code>. Let's add in a new file called <code class="literal">ChatHub</code> and start with overriding the <code class="literal">OnConnected</code> and <code class="literal">OnDisconnected</code> functions:</p><pre class="programlisting">[Authorize] &#13;
    public class ChatHub : Hub &#13;
    { &#13;
        public static readonly ConcurrentDictionary&lt;string, SigRUser&gt; Users &#13;
            = new ConcurrentDictionary&lt;string, SigRUser&gt;(StringComparer.InvariantCultureIgnoreCase); &#13;
  &#13;
         &#13;
  public override Task OnConnected() &#13;
        { &#13;
            var userName = (Context.User.Identity as ClaimsIdentity).Claims.FirstOrDefault(claim =&gt; claim.Type == "UserName").Value; &#13;
            string connectionId = Context.ConnectionId; &#13;
  &#13;
            var user = Users.GetOrAdd(userName, _ =&gt; new SigRUser &#13;
            { &#13;
                Name = userName, &#13;
                ConnectionIds = new HashSet&lt;string&gt;() &#13;
            }); &#13;
  &#13;
            lock (user.ConnectionIds) &#13;
            { &#13;
  &#13;
                user.ConnectionIds.Add(connectionId); &#13;
                NotifyOtherConnectedUsers(userName); &#13;
            } &#13;
  &#13;
            return base.OnConnected(); &#13;
        } &#13;
  &#13;
        public override Task OnDisconnected(bool stopCalled) &#13;
        { &#13;
            var userName = (Context.User.Identity as ClaimsIdentity).Claims.FirstOrDefault(claim =&gt; claim.Type == "UserName").Value; &#13;
            string connectionId = Context.ConnectionId; &#13;
  &#13;
            SigRUser user; &#13;
            Users.TryGetValue(userName, out user); &#13;
  &#13;
            if (user != null) &#13;
            { &#13;
                lock (user.ConnectionIds) &#13;
                { &#13;
                    SigRUser removedUser; &#13;
                    Users.TryRemove(userName, out removedUser); &#13;
  &#13;
                    NotifyOtherConnectedUsers(userName); &#13;
                } &#13;
            } &#13;
  &#13;
            return base.OnDisconnected(stopCalled); &#13;
        } &#13;
    } &#13;
</pre><p><code class="literal">HashSetUsers</code> is static because we are going to use this later on in our <code class="literal">AccountController</code>.</p><p>Notice the Authorize attribute?</p><p>This is how we created a protected server resource; only clients with granted access tokens can connect to the <code class="literal">ChatHub</code>.</p><p>Now let's turn our attention to the <code class="literal">OnConnected</code> function. When a client connects to the <code class="literal">ChatHub</code>, the username is retrieved from the <code class="literal">HubCallerContext</code> property, which is actually a <code class="literal">ClaimsIdentity</code> object. When we login through the <code class="literal">AccountController</code>, inside the <code class="literal">AuthorizationServerProvider</code>
<span class="strong"><strong> </strong></span>we store the identity object inside the context when the function <code class="literal">GrantResourceOwnerCredentials</code> is called. We also store a <code class="literal">Claim</code> object of type <code class="literal">username</code> inside the identity, which we can now retrieve from the user's identity in the <code class="literal">HubCallerContext</code>. This is how we integrate OAuth with SignalR.</p><p>Now that we have the username, we are going to try and retrieve a <code class="literal">SigRUser</code> object from the <code class="literal">ConcurrentDictionary</code>; if the username doesn't exist we create a new <code class="literal">SignRUser</code> and add it to the <code class="literal">HashSet</code>. We then lock the <code class="literal">ConnectionIdsConcurrentDictionary</code> making it thread safe as multiple threads (different user connections) can make changes on this property. Inside the lock statement we add the new <code class="literal">ConnectionId</code> and notify all other usernames connected to the <code class="literal">ChatHub</code> using the function <code class="literal">NotifyOtherConnectedUsers</code>. Let's now add this function to the <code class="literal">ChatHub</code>:</p><pre class="programlisting">public void NotifyOtherConnectedUsers(string userName) &#13;
        { &#13;
            var connectionIds = Users.Where(x =&gt; !x.Key.Contains(userName)) &#13;
            .SelectMany(x =&gt; x.Value.ConnectionIds) &#13;
            .Distinct(); &#13;
  &#13;
            foreach (var cid in connectionIds) &#13;
            { &#13;
                Clients.Client(cid).displayMessage("clients", JsonConvert.SerializeObject(Users.Select(x =&gt; x.Key))); &#13;
            } &#13;
        } &#13;
</pre><p>This function will call <code class="literal">displayMessage</code>, sending a serialized JSON object of the <code class="literal">ConcurrentDictionary Users</code> to all other connected clients (we will see why later).</p><p>Now let's turn our attention to the <code class="literal">OnDisconnected</code> function. This function will simply check there is a <code class="literal">SigRUser</code> with the username equal to the one retrieved from the <code class="literal">HubCallerContext</code> object. If this user exists, we try and remove it from the <code class="literal">ConcurrentDictionary</code> and call the <code class="literal">NotifyOtherConnectedUsers</code> again sending the updated dictionary of clients to the remaining connected clients.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip84"/>Tip</h3><p>We call this function every time a user connects or disconnects to the hub, so in our mobile application we can update a list of connected clients in real time without refreshing the page.</p></div></div><p>Now that we can handle an updated list of connected clients, our last step is to add the function which will send a message between two clients. The <code class="literal">Send</code> function will be called through the client's hub proxy with two parameters (message and username):</p><pre class="programlisting">public void Send(string message, string to) &#13;
        { &#13;
            SigRUser receiver; &#13;
  &#13;
            if (Users.TryGetValue(to, out receiver)) &#13;
            { &#13;
                var userName = (Context.User.Identity as ClaimsIdentity).Claims.FirstOrDefault(claim =&gt; claim.Type == "UserName").Value; &#13;
  &#13;
                SigRUser sender; &#13;
                Users.TryGetValue(userName, out sender); &#13;
 &#13;
  &#13;
                lock (receiver.ConnectionIds) &#13;
                { &#13;
                    foreach (var cid in receiver.ConnectionIds) &#13;
                    { &#13;
                        Clients.Client(cid).displayMessage("chat", message); &#13;
                    } &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>That's all for our backend. We have now created our first addition to the server's service access layer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip85"/>Tip</h3><p>The server service access layer will sit in a different service access layer to the mobile projects. With server and client code, each side of the system will have its own architecture and layers.</p></div></div><p>Now let's move onto the client side and start building our mobile applications.</p></div></div>
<div class="section" title="Setting up mobile projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Setting up mobile projects</h1></div></div></div><p>Now we move back to the mobile side; in our mobile projects we are going to be setting up SignalR clients on both Android and iOS natively. We will also be creating a presenter layer to share the UI logic between both native platforms. Open up Xamarin Studio and create a new shared project called <code class="literal">Chat.Common</code>; inside this project add two empty folders called <code class="literal">Model</code> and <code class="literal">Presenter</code>.</p><p>We then want to create a <span class="strong"><strong>single view iOS application</strong></span>, a <span class="strong"><strong>general Android application</strong></span> and a shared project called <code class="literal">Chat.ServiceAccess</code>. Our project structure will look like this:</p><div class="mediaobject"><img src="graphics/B05293_06_11.jpg" alt="Setting up mobile projects"/></div><div class="section" title="Creating the SignalRClient"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Creating the SignalRClient</h2></div></div></div><p>We are going to start implementing a new class called <code class="literal">SignalRClient</code>. This will sit in the service access layer, the shared project called <code class="literal">Chat.ServiceAccess</code>. Create a new file called <code class="literal">SignalRClient.cs</code>, and implement the following:</p><pre class="programlisting">public class SignalRClient&#13;
     {&#13;
         private readonly HubConnection _connection;&#13;
         private readonly IHubProxy _proxy;&#13;
         public event EventHandler&lt;Tuple&lt;string, string&gt;&gt; OnDataReceived;&#13;
         public SignalRClient()&#13;
         {&#13;
             _connection = new HubConnection("http://{IP Address}:{Port}/");&#13;
             _proxy = _connection.CreateHubProxy("ChatHub");&#13;
         }&#13;
 }  &#13;
</pre><p>Now let's look more closely. We have two <code class="literal">readonly</code> properties in which we only initialize once when the object is created, the hub connection which is set to the server URL, and the <code class="literal">HubProxy</code> which is created off the connection to the server.</p><p>Now let's add two functions for connecting and disconnecting to the <code class="literal">ChatHub</code>:</p><pre class="programlisting">public async Task&lt;bool&gt; Connect(string accessToken)&#13;
         {&#13;
             try&#13;
             {&#13;
                 _connection.Headers.Add("Authorization",&#13;
                 string.Format("Bearer {0}", accessToken));&#13;
                 await _connection.Start();&#13;
                 _proxy.On&lt;string, string&gt;("displayMessage", (id, data) =&gt;&#13;
                 {&#13;
                     if (OnDataReceived != null)&#13;
                     {&#13;
                         OnDataReceived(this, new Tuple&lt;string,&#13;
                         string&gt;(id, data));&#13;
                     }&#13;
                 });&#13;
                 return true;&#13;
             }&#13;
             catch (Exception e)&#13;
             {&#13;
                 Console.WriteLine(e);&#13;
             }&#13;
             return false;&#13;
         }&#13;
         public void Disconnect()&#13;
         {&#13;
             _connection.Stop();&#13;
             _connection.Dispose();&#13;
         }</pre><p>The <code class="literal">Connect</code> function requires an access token which we add to the <code class="literal">Headers</code> dictionary of the <code class="literal">HubConnection</code> object.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note86"/>Note</h3><p>The access token is used as a Bearer token to authorize access to the <code class="literal">ChatHub</code>.</p></div></div><p>The function <code class="literal">On</code> called from the proxy takes in two parameters, the name of the function on the server we are listening for, and the action that will be performed every time this function is called on the Hub's connected clients. In this example, our proxy will fire this action whenever two strings are received from the server. The first string is an ID for the data passed in the second string (this could be a JSON list of connected clients or it could be a simple chat message). This data will then be passed a <code class="literal">Tuple&lt;string, string&gt;</code> object to the <code class="literal">EventHandler</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note87"/>Note</h3><p>We can call <code class="literal">On</code> for multiple functions, and fire different actions for as many different functions being called on the <code class="literal">Hub</code>.</p></div></div><p>The <code class="literal">Disconnect</code> function simply closes the connection and disposes the <code class="literal">HubConnection</code> object. Finally, we add another function for invoking the <code class="literal">Send</code> function via the <code class="literal">ChatHub</code>
<span class="strong"><strong> </strong></span>object on the server:</p><pre class="programlisting">public async Task SendMessageToClient(string user, string message)&#13;
{&#13;
    await _proxy.Invoke("Send", new object[]&#13;
    {&#13;
        message,&#13;
        user&#13;
    });&#13;
}</pre><p>When we invoke server functions, we use an array of objects, in order to match the parameters required on the server function.</p><p>Since the <code class="literal">SignalRClient</code>
<span class="strong"><strong> </strong></span>will sit in a shared project, the same code will be used for each different platform, but the libraries referenced from the <code class="literal">using</code> statements will come from each platform project. Now let's have both the iOS and Android projects reference this shared project. We also want to add the <code class="literal">Microsoft.AspNet.SignalR.Client</code>
<span class="strong"><strong> </strong></span>NuGet package for all the platform projects (iOS and Android).</p><div class="mediaobject"><img src="graphics/B05293_06_12.jpg" alt="Creating the SignalRClient"/></div><p>If you are trying to add the NuGet package for SignalR version 2.2.0 with Xamarin.iOS 1.0, the package will fail to add. If so, visit the following link and add the correct <code class="literal">.dll</code> files from the <code class="literal">lib</code> folder to each platform project's references: <a class="ulink" href="https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr">https://components.xamarin.com/auth?redirect_to=%2fdownload%2fsignalr</a>.</p><div class="mediaobject"><img src="graphics/B05293_06_13.jpg" alt="Creating the SignalRClient"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip88"/>Tip</h3><p>To add the references correctly, right-click the folder <span class="strong"><strong>References</strong></span> for each project, click the <span class="strong"><strong>.Net assembly</strong></span> tab, and click the <span class="strong"><strong>B</strong></span><span class="strong"><strong>rowse</strong></span> button to add the <code class="literal">.dll</code> files (<code class="literal">Microsoft.AspNet.SignalR.Client</code>, <code class="literal">System.Net.Http.Extensions</code>, and <code class="literal">System.Net.Http.Primitives</code>).</p></div></div><p>For each platform project, we also need to add the <code class="literal">Json.Net</code> package from NuGet, then right-click on the <span class="strong"><strong>References</strong></span><span class="strong"><strong>, </strong></span>click the <span class="strong"><strong>All</strong></span> tab, and select <span class="strong"><strong>System.Net</strong></span> and <span class="strong"><strong>System.Net.Http</strong></span>.</p><div class="mediaobject"><img src="graphics/B05293_06_14.jpg" alt="Creating the SignalRClient"/></div><p>Now that we have <span class="strong"><strong>SignalR</strong></span> configured, let's move on to building the <code class="literal">WebApiAccess</code> layer.</p></div><div class="section" title="Building the WebApiAccess layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Building the WebApiAccess layer</h2></div></div></div><p>Our <code class="literal">WebApiAccess</code> object will be mapped to the <code class="literal">AccountController</code> on the server. Let's add in a new file called <code class="literal">WebApiAccess.cs</code>, and implement the <code class="literal">LoginAsync</code> function:</p><pre class="programlisting"> &#13;
public class WebApiAccess&#13;
     {&#13;
         private string _baseAddress = "http://{IP Address}:{Port}/";&#13;
         public async Task&lt;bool&gt; LoginAsync(string name, string password,&#13;
         CancellationToken? cancellationToken = null)&#13;
         {&#13;
             var httpMessage = new HttpRequestMessage(HttpMethod.Post,&#13;
             new Uri(_baseAddress + "api/Account/Login"))&#13;
             {&#13;
                 Content = new StringContent(string.Format&#13;
                 ("Username={0}&amp;Password={1}", name, password), Encoding.UTF8,&#13;
                  "application/x-www-form-urlencoded"),&#13;
             };&#13;
             var client = new HttpClient();&#13;
             var response = await client.SendAsync(httpMessage,&#13;
             cancellationToken ?? new CancellationToken(false));&#13;
             switch (response.StatusCode)&#13;
             {&#13;
                 case HttpStatusCode.NotFound:&#13;
                     throw new Exception(string.Empty);&#13;
             }&#13;
             var responseContent = await response.Content.ReadAsStringAsync();&#13;
             var loginSuccess = false;&#13;
             bool.TryParse(responseContent, out loginSuccess);&#13;
             return loginSuccess;&#13;
         }&#13;
     }  &#13;
</pre><p>The <code class="literal">_baseAddress</code> property will be the same as the <code class="literal">SignalRHubConnection</code> address; this is our server link. In our <code class="literal">LoginAsync</code> function, we start with creating a new <code class="literal">HttpRequestMessage</code> set as a <code class="literal">HttpMethod.Post</code>. We also set the content to a new <code class="literal">StringContent</code> object, which takes the username and password. This message is used in a new <code class="literal">HttpClient</code> to send to the server, and the response received is read as a string and parsed in to a new <code class="literal">bool</code> object to determine the success of the login.</p><p>Let's go ahead and implement the rest of the access layer:</p><pre class="programlisting">public async Task&lt;bool&gt; RegisterAsync(string name, string password, CancellationToken? cancellationToken = null)&#13;
         {&#13;
             var httpMessage = new HttpRequestMessage(HttpMethod.Post,&#13;
             new Uri(_baseAddress + "api/Account/Register"))&#13;
             {&#13;
                 Content = new StringContent(string.Format&#13;
                 ("Username={0}&amp;Password={1}", name, password), Encoding.UTF8,&#13;
                 "application/x-www-form-urlencoded"),&#13;
             };&#13;
             var client = new HttpClient();&#13;
             var response = await client.SendAsync(httpMessage,&#13;
             cancellationToken ?? new CancellationToken(false));&#13;
             return response.StatusCode == HttpStatusCode.OK;&#13;
         } &#13;
</pre><p>The <code class="literal">Register</code> function is very much the same, but we only check that the response status code is a <code class="literal">200(OK)</code> response; if so, then we have registered successfully.</p><pre class="programlisting">public async Task&lt;TokenContract&gt; GetTokenAsync(string name, string password, CancellationToken? cancellationToken = null)&#13;
         {&#13;
             var httpMessage = new HttpRequestMessage(HttpMethod.Post,&#13;
             new Uri(_baseAddress + "token"))&#13;
             {&#13;
                 Content = new StringContent(string.Format&#13;
                 ("Username={0}&amp;Password={1}&amp;grant_type=password", name,&#13;
                 password), Encoding.UTF8, "application/x-www-form-urlencoded"),&#13;
             };&#13;
             var client = new HttpClient();&#13;
             var response = await client.SendAsync(httpMessage,&#13;
             cancellationToken ?? new CancellationToken(false));&#13;
             switch (response.StatusCode)&#13;
             {&#13;
                 case HttpStatusCode.NotFound:&#13;
                     throw new Exception(string.Empty);&#13;
             }&#13;
             var tokenJson = await response.Content.ReadAsStringAsync();&#13;
             return JsonConvert.DeserializeObject&lt;TokenContract&gt;(tokenJson);&#13;
            }</pre><p>The <code class="literal">GetTokenAsync</code> function is responsible for retrieving the access token from the OAuth endpoint (<code class="literal">/token</code>). The JSON response will be of the type <code class="literal">TokenContract</code>; let's go ahead and add this object into the <code class="literal">Chat.ServiceAccess</code> project. Create a new folder called <code class="literal">Contracts</code> inside the <code class="literal">Web</code> folder, add in a new file called <code class="literal">TokenContract.cs</code>, and implement the following:</p><pre class="programlisting">public class TokenContract&#13;
     {&#13;
         [JsonProperty("access_token")]&#13;
         public string AccessToken { get; set; }&#13;
         [JsonProperty("token_type")]&#13;
         public string TokenType { get; set; }&#13;
         [JsonProperty("expires_in")]&#13;
         public int ExpiresIn { get; set; }&#13;
         [JsonProperty("userName")]&#13;
         public string Username { get; set; }&#13;
         [JsonProperty(".issued")]&#13;
         public string IssuedAt { get; set; }&#13;
         [JsonProperty(".expires")]&#13;
         public string ExpiresAt { get; set; }&#13;
     }  &#13;
</pre><p>Notice the <code class="literal">JsonProperty</code> attribute?</p><p>We can map properties from the JSON objects into other named variables for the class.</p><p>Now for the final Web API function, <code class="literal">GetAllConnectedUsersAsync</code>. This function will be called when a user logs in for the first time. We need to have both an API call and a real-time update with the <span class="strong"><strong>SignalRClient</strong></span> to keep track of the current connected clients because when a new user logs in, the server will call <code class="literal">displayMessage</code> on all other clients. Even if we were to call <code class="literal">displayMessage</code> on <code class="literal">Clients.All</code> (this is a reference to all the connected clients on any <span class="strong"><strong>SignalR Hub</strong></span>), the newly connected client won't appear in the Clients list as there is a minor delay with the connection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip89"/>Tip</h3><p>This minor delay is something we cannot control; only sometimes would the newly connected client receives the updated list through the <code class="literal">HubProxy</code> event. So, to make things more reliable, we add this update through the API access layer.</p></div></div><p>Let's add the final Web API function for <code class="literal">GetAllConnectedUsersAsync</code>. This function will deserialized an IEnumerable of strings which represents the list of connected clients from the <span class="strong"><strong>ChatHub</strong></span>:</p><pre class="programlisting">public async Task&lt;IEnumerable&lt;string&gt;&gt;&#13;
 GetAllConnectedUsersAsync(CancellationToken? cancellationToken = null)&#13;
         {&#13;
             var httpMessage = new HttpRequestMessage(HttpMethod.Get,&#13;
             new Uri(_baseAddress + "api/Account/GetAllConnectedUsers"));&#13;
             var client = new HttpClient();&#13;
             var response = await client.SendAsync(httpMessage,&#13;
             cancellationToken ?? new CancellationToken(false));&#13;
             switch (response.StatusCode)&#13;
             {&#13;
                 case HttpStatusCode.NotFound:&#13;
                     throw new Exception(string.Empty);&#13;
             }&#13;
             var responseContent = await response.Content.ReadAsStringAsync();&#13;
             return JsonConvert.DeserializeObject&lt;IEnumerable&lt;string&gt;&gt;&#13;
(responseContent);&#13;
         }  &#13;
</pre><p>Great! We now have our Web API access layer. Our next step is to start building the application state and navigation service required for each presenter.</p></div><div class="section" title="Application state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Application state</h2></div></div></div><p>In MVP, every presenter must include the current application state. When we cross between different screens, the persistent state of application data is kept alive throughout the entire life of the application (this includes search results, downloaded JSON objects, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip90"/>Tip</h3><p>In some most MVP applications, the application state will include a service for saving and loading this persistent data between different sessions.
For an extra learning activity, try implementing a new service called <code class="literal">IApplicationStateService</code>. This will be responsible for saving and loading the <code class="literal">ApplicationState</code> object locally to your device.</p></div></div><p>Excellent! Now let's add another file called <code class="literal">ApplicationState.cs</code>, and implement the following:</p><pre class="programlisting">public class ApplicationState&#13;
     {&#13;
         #region Public Properties&#13;
         public string AccessToken { get; set; }&#13;
         public string Username { get; set; }&#13;
         #endregion&#13;
     } &#13;
</pre><p>Nothing much to it, right?</p><p>We only ever want one instance of this object throughout the entire life of the application, so we will build upon the persistent data to be kept alive between each screen.</p></div></div>
<div class="section" title="Setting up the navigation service"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Setting up the navigation service</h1></div></div></div><p>Implementing a navigation service in MVP is very different from our <code class="literal">Xamarin.Forms</code> navigation service. Our navigation service will not be used in an IoC container this time; instead, we will be instantiating one of these objects at the start of our application in the <code class="literal">AppDelegate</code> and <code class="literal">MainActivity</code> classes. Since we are working in native, we will also be implementing a separate navigation service for each platform that will share the same interface.</p><p>Let's start with creating the shared interface. Add a new file to the <code class="literal">Chat.Common</code> folder <span class="strong"><strong>
<span class="strong"><strong>Presenter</strong></span>
</strong></span> | <span class="strong"><strong>Services</strong></span>, call it <code class="literal">INavigationService.cs</code>, and implement the following:</p><pre class="programlisting">public interface INavigationService { void PushPresenter(BasePresenter presenter); } &#13;
</pre><div class="section" title="Building the iOS navigation service"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Building the iOS navigation service</h2></div></div></div><p>Let's start with the iOS navigation service. Add in a new folder called <code class="literal">Services</code> to the <code class="literal">Chat.iOS</code> project, create a new file called <code class="literal">NavigationService.cs</code>, and implement the following:</p><pre class="programlisting">public class NavigationService : INavigationService&#13;
    {&#13;
         #region Private Properties&#13;
         private UINavigationController _navigationController;&#13;
         #endregion&#13;
         #region Constructors&#13;
         public NavigationService(UINavigationController navigationController)&#13;
         {&#13;
             _navigationController = navigationController;&#13;
         }&#13;
         #endregion&#13;
         #region INavigationService implementation&#13;
         public void PushPresenter(BasePresenter presenter)&#13;
         {&#13;
             if (presenter is LoginPresenter)&#13;
             {&#13;
                 var viewController = new LoginViewController&#13;
                 (presenter as LoginPresenter);&#13;
                 _navigationController.PushViewController(viewController, true);&#13;
             }&#13;
  &#13;
        }&#13;
   &#13;
        public void PopPresenter(bool animated)&#13;
         {&#13;
           _navigationController.PopViewController(animated);&#13;
         }&#13;
  &#13;
         #endregion&#13;
     }  &#13;
</pre><p>When we instantiate this object we always want to pass in the <code class="literal">UINavigationController</code> that is assigned to our <code class="literal">RootViewController</code> of the <code class="literal">UIWindow</code> object created in our <code class="literal">AppDelegate</code>. We also have to implement the <code class="literal">Push</code> function, which takes a <code class="literal">BasePresenter</code> object (any presenter), and we perform a type check to determine which presenter is being passed, and pushing the related <code class="literal">UIViewController</code>, onto the navigation stack. We must always pass the presenter to the new <code class="literal">UIViewController</code>, so we can register the new view to the current presenter.</p></div><div class="section" title="Building the Android navigation service"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Building the Android navigation service</h2></div></div></div><p>Before we move onto the Android navigation service, we have to add an extra class to hold persistent state on the current activity, current presenter, and current context. Add in a new file called <code class="literal">Application.cs</code> and implement the following:</p><pre class="programlisting">[Application]&#13;
     public class ChatApplication : Application&#13;
     {&#13;
         #region Public Properties&#13;
         public object Presenter&#13;
         {&#13;
             get;&#13;
             set;&#13;
         }&#13;
         public Activity CurrentActivity&#13;
         {&#13;
             get;&#13;
             set;&#13;
         }&#13;
         #endregion&#13;
         #region Constructors&#13;
         public ChatApplication()&#13;
             : base()&#13;
         {&#13;
         }&#13;
         public ChatApplication(IntPtr javaReference,&#13;
         JniHandleOwnership transfer)&#13;
             : base(javaReference, transfer)&#13;
         {&#13;
         }&#13;
         #endregion&#13;
         #region Public Methods&#13;
         public static ChatApplication GetApplication(Context context)&#13;
         {&#13;
             return (ChatApplication)context.ApplicationContext;&#13;
         }&#13;
         #endregion&#13;
     }  &#13;
</pre><p>This class will extend off the Android application, so when we reference the Android application class in other parts of our application, we have reference to the extra persistent objects.</p><p>Now let's implement the Android navigation service. Add in a new folder to the Android project called <code class="literal">Services</code>, add a new file called <code class="literal">NavigationService.cs</code>, and implement the following:</p><pre class="programlisting">public class NavigationService : INavigationService&#13;
     {&#13;
         private ChatApplication _application;&#13;
         public NavigationService(ChatApplication application)&#13;
         {&#13;
             _application = application;&#13;
         }&#13;
         public void PushPresenter(BasePresenter presenter)&#13;
         {&#13;
             var oldPresenter = _application.Presenter as BasePresenter;&#13;
             if (presenter != oldPresenter)&#13;
             {&#13;
                 _application.Presenter = presenter;&#13;
                 Intent intent = null;&#13;
                 if (presenter is LoginPresenter)&#13;
                 {&#13;
                     intent = new Intent(_application.CurrentActivity,&#13;
                     typeof(LoginActivity));&#13;
                 }&#13;
                 if (intent != null)&#13;
                 {&#13;
                     _application.CurrentActivity.StartActivity(intent);&#13;
                 }&#13;
             }&#13;
         }&#13;
         public void PopPresenter(bool animated)&#13;
         {&#13;
             _application.CurrentActivity.Finish();&#13;
         }  &#13;
    }  &#13;
</pre><p>In the constructor, we pass in the <code class="literal">Application</code>
<span class="strong"><strong> </strong></span>object and keep this stored as a private variable inside the navigation service. The <code class="literal">Push</code> function requires the <code class="literal">Application</code>
<span class="strong"><strong> </strong></span>everytime we push a new <code class="literal">Activity</code> onto the stack, because we require the current activity reference to start the new intent from the current activity held inside the <code class="literal">Application</code> object.</p><p>Now that we have our navigation service and application state, let's start building our user interface for iOS.</p></div><div class="section" title="Building the iOS interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Building the iOS interface</h2></div></div></div><p>Since we don't really know how the user interface is going to look for each screen, we can't define the logic in our presenters. So let's loosely talk about how the user interface is going to look.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip91"/>Tip</h3><p>We should normally have screen mock-ups at this point before we move to the UI layer of a project.</p></div></div><p>We have three screens in our application, one of which is going to be list which displays all the connected clients live on the <span class="strong"><strong>ChatHub</strong></span> on our server. A user will be able to select this user from the list; when a user selects another client from the list, this client should receive a message asking for permission to start a chat conversation. When a user accepts, this will move to another screen which will show a typical chat conversation, much the same as with any other SMS application (speech bubbles on either side). The following diagram is a quick mock-up of the three screens and workflow. All we see is the first screen showing a login screen, then another showing a list with the connected clients, and the last screen showing a conversation between two connected clients.</p><div class="mediaobject"><img src="graphics/B05293_06_15.jpg" alt="Building the iOS interface"/></div><p>Excellent! Now that we have an idea as to how our screens are going to look, let's talk about the logic behind the first screen that we can share. We have a screen with two entry boxes for a username and password. The screen will be able to perform logins and registrations on our Web API, so we will require a button for each. If we are successful with login, this will push the list page on to the navigation stack.</p><p>Let's consider a cross-platform approach; what can we share here?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Web API layer</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>EventHandlers</strong></span> to handle the click events for a login and register</li><li class="listitem" style="list-style-type: disc">Navigation service to handle push/pop onto our navigation stack</li></ul></div><p>We have a rough idea of the logic behind our first screen; let's build our first <span class="strong"><strong>Presenter</strong></span>. Create two new files called <code class="literal">BasePresenter.cs</code> and <code class="literal">IView.cs</code>. We will start with the <code class="literal">IView</code>
<span class="strong"><strong> </strong></span>class:</p><pre class="programlisting">public interface IView&#13;
  {&#13;
    void SetMessage(string message);&#13;
    bool IsInProgress&#13;
      {&#13;
         get;&#13;
         set;&#13;
      }&#13;
  } &#13;
</pre><p>We want all screens to have an <code class="literal">IsInProgress</code> variable, if any screen is loading or processing, we can display loading activity to the user. The <code class="literal">SetMessage</code> function is used to display any errors to the user through an alert dialog.</p><p>Now for the <code class="literal">BasePresenter</code>, this is an abstract class which will be used for all presenters. All presenters require the <code class="literal">ApplicationState</code>, <code class="literal">INavigationService</code>, and the <code class="literal">SignalRClient</code>. Throughout our entire application, each screen requires events from the <code class="literal">SignalRClient</code> to function, so we can bring it into the <code class="literal">BasePresenter</code> object. We have created two <code class="literal">EventHandlers</code>; these are fired based upon the data received via the <span class="strong"><strong>hub proxy</strong></span> on the <code class="literal">SignalRClient</code>. If we receive a list of <span class="strong"><strong>Clients</strong></span>, we will fire the <code class="literal">ConnectedClientsUpdated</code> event. If we receive a <code class="literal">string</code>, we will fire the <code class="literal">ChatReceived</code> event, so we can actually control all <code class="literal">SignalR</code> data via the <code class="literal">BasePresenter</code> class, and channel specific data types to specific events for our views to register. We also have the <code class="literal">WebApiAccess</code> object for accessing the Web API and a string for holding the access token when we login successfully:</p><pre class="programlisting">public abstract class BasePresenter&#13;
     {&#13;
         #region Private Properties&#13;
         private IDictionary&lt;string, Action&lt;string&gt;&gt; _signalREvents;&#13;
         #endregion&#13;
         #region Protected Properties&#13;
         protected INavigationService _navigationService;&#13;
         protected ApplicationState _state;&#13;
         protected SignalRClient _signalRClient;&#13;
         protected WebApiAccess _webApiAccess;&#13;
         protected string _accessToken;&#13;
         #endregion&#13;
 &#13;
         #region Events&#13;
         public event EventHandler&lt;ConnectedClientsUpdatedEventArgs&gt;&#13;
         ConnectedClientsUpdated;&#13;
         public event EventHandler&lt;ChatEventArgs&gt; ChatReceived;&#13;
         #endregion &#13;
 } &#13;
</pre></div></div>
<div class="section" title="Handling Hub proxy callbacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec84"/>Handling Hub proxy callbacks</h1></div></div></div><p>Let's turn our attention to the <code class="literal">SignalRClient</code>; we created an <code class="literal">EventHandler</code>, which fires every time data is received from the <span class="strong"><strong>Hub</strong></span>. The <code class="literal">BasePresenter</code> will be responsible for handling the data received from this <code class="literal">EventHandler</code>:</p><pre class="programlisting">         #region Constructors&#13;
         public BasePresenter()&#13;
         {&#13;
             _webApiAccess = new WebApiAccess();&#13;
             _signalREvents = new Dictionary&lt;string, Action&lt;string&gt;&gt;()&#13;
             {&#13;
                 {"clients", (data) =&gt;&#13;
                      {&#13;
                         var list = JsonConvert.DeserializeObject&lt;IEnumerable&lt;string&gt;&gt;(data);&#13;
                         if (ConnectedClientsUpdated != null)&#13;
                         {&#13;
                             ConnectedClientsUpdated(this, new ConnectedClientsUpdatedEventArgs(list.Select(x =&gt; new Client&#13;
                             {&#13;
                                 Username = x,&#13;
                             })));&#13;
                         }&#13;
                     }&#13;
                 },&#13;
                 {"chat", (data) =&gt;&#13;
                      {&#13;
                         if (ChatReceived != null)&#13;
                         {&#13;
                             ChatReceived(this, new ChatEventArgs(data));&#13;
                         }&#13;
                     }&#13;
                 },&#13;
             };&#13;
         }&#13;
         #endregion  &#13;
         #region Protected Methods&#13;
         protected void HandleSignalRDataReceived(object sender, Tuple&lt;string, string&gt; e)&#13;
         {&#13;
             _signalREvents[e.Item1](e.Item2);&#13;
         }&#13;
         #endregion</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip92"/>Tip</h3><p>The private dictionary <code class="literal">_signalREvents</code> is used instead of a switch statement.</p></div></div><p>With each <code class="literal">Tuple</code> received from the SignalRClient's <code class="literal">OnDataReceived</code> event, the first string will be the key matching the indexed <code class="literal">Action&lt;string&gt;</code> in the dictionary. The other string of the <code class="literal">Tuple</code> is the data string (either a serialized JSON of <code class="literal">HashSet&lt;string&gt;</code>, or a string which represents a chat message), which is passed as the input parameter for our <code class="literal">Action&lt;string&gt;</code>, then, out of this input parameter, we will create the correct arguments used for the specified event.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note93"/>Note</h3><p>We could take things a step further and abstract a <code class="literal">view</code> object into the <code class="literal">BasePresenter</code>, as every presenter requires a <code class="literal">view</code>, but because each view logic is independent, it is very hard to centralize this logic in one area. The need for this will come if multiple views have similar behaviors. Then we can look at abstracting these areas into the <code class="literal">BasePresenter</code>.</p></div></div><p>But wait! You may have noticed that we have two types of arguments being passed into each <code class="literal">EventHandler</code>. Add a new file to the <code class="literal">Events</code> folder in the <code class="literal">Chat.Common</code> project called <code class="literal">ConnectedClientsUpdatedEventArgs.cs</code>, and implement the following:</p><pre class="programlisting">public class ConnectedClientsUpdatedEventArgs : EventArgs&#13;
     {&#13;
         public IList&lt;Client&gt; ConnectedClients { private set; get;&#13;
     }&#13;
         public ConnectedClientsUpdatedEventArgs(IEnumerable&lt;Client&gt; connectedClients)&#13;
         {&#13;
             ConnectedClients = new List&lt;Client&gt;();&#13;
             foreach (var client in connectedClients)&#13;
             {&#13;
                 ConnectedClients.Add(client);&#13;
             }&#13;
         }&#13;
     } &#13;
</pre><p>We also need another file called <code class="literal">ChatEventArgs.cs</code>. Add this to the <code class="literal">Events</code> folder and implement the following:</p><pre class="programlisting">public class ChatEventArgs : EventArgs&#13;
     {&#13;
         public string Message { private set; get;&#13;
     }&#13;
         public ChatEventArgs(string message)&#13;
         {&#13;
             Message = message;&#13;
         }&#13;
     } &#13;
</pre><p>This object is the wrapper for every message received for a chat message. Now we have everything ready to implement our first presenter object.</p></div>
<div class="section" title="Implementing the LoginPresenter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec85"/>Implementing the LoginPresenter</h1></div></div></div><p>Create a new file called <code class="literal">LoginPresenter.cs</code>, add it to the <code class="literal">Presenter</code> folder in the <code class="literal">Chat.Common</code> project, and implement the following:</p><pre class="programlisting">public class LoginPresenter : BasePresenter&#13;
     {&#13;
         #region Private Properties&#13;
         private ILoginView _view;&#13;
         #endregion&#13;
         #region IClientsListView&#13;
         public interface ILoginView : IView&#13;
         {&#13;
             event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Login;&#13;
             event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Register;&#13;
         }&#13;
         #endregion&#13;
         #region Constructors&#13;
         public LoginPresenter(ApplicationState state, INavigationService navigationService)&#13;
         {&#13;
             _navigationService = navigationService;&#13;
             _state = state;&#13;
             _webApiAccess = new WebApiAccess();&#13;
         }&#13;
         #endregion&#13;
&#13;
&#13;
#region Public Methods&#13;
         public void SetView(ILoginView view)&#13;
         {&#13;
             _view = view;&#13;
             _view.Login -= HandleLogin;&#13;
             _view.Login += HandleLogin;&#13;
             _view.Register -= HandleRegister;&#13;
             _view.Register += HandleRegister;&#13;
         }&#13;
         #endregion&#13;
     }  </pre><p>Our <code class="literal">LoginPresenter</code> contains a new <code class="literal">ILoginView</code> interface with two new event handlers for the two buttons that will appear on the login screen. We also include a new <code class="literal">WebApiAccess</code> object as we will need to perform logins and registrations on the Web API. We also need another function called <code class="literal">SetView</code>, this will take the user interface object and register any <code class="literal">EventHandlers</code> specified by the <code class="literal">ILoginView</code> interface. Let's now add the function for handling logins:</p><pre class="programlisting">         #region Private Methods&#13;
         private async void HandleLogin(object sender, Tuple&lt;string, string&gt; user)&#13;
         {&#13;
             if (!_view.IsInProgress)&#13;
             {&#13;
                 _state.Username = user.Item1;&#13;
                 _view.IsInProgress = true;&#13;
                 if (user.Item2.Length &gt;= 6)&#13;
                 {&#13;
                     var loggedIn = await _webApiAccess.LoginAsync(user.Item1, user.Item2, CancellationToken.None);&#13;
                     if (loggedIn)&#13;
                     {&#13;
                         var tokenContract = await _webApiAccess.GetTokenAsync(user.Item1, user.Item2, CancellationToken.None);&#13;
                         if (!string.IsNullOrEmpty(tokenContract.AccessToken))&#13;
                         {&#13;
                             var presenter = new ClientsListPresenter(_state, _navigationService, tokenContract.AccessToken);&#13;
                             _navigationService.PushPresenter(presenter);&#13;
                         }&#13;
                         else&#13;
                         {&#13;
                             _view.SetErrorMessage("Failed to register user.");&#13;
                         }&#13;
                     }&#13;
                     else&#13;
                     {&#13;
                         _view.SetErrorMessage("Invalid username or password.");&#13;
                     }&#13;
                 }&#13;
                 else&#13;
                 {&#13;
                     _view.SetErrorMessage("Password must be at least 6 characters.");&#13;
                 }&#13;
                 _view.IsInProgress = false;&#13;
             }&#13;
         } &#13;
</pre><p>The <code class="literal">HandleLogin</code> function will check first if the screen is currently progressing from another login; we want to make sure that only one login or registration can occur at any one time. Firstly, we call the <code class="literal">LoginAsync</code> and check that the user exists in the <code class="literal">UserManager</code>, then we call the <code class="literal">GetTokenAsync</code> function to retrieve the access token which will be used in our <code class="literal">HubConnection</code>. If both are successful, we push on the <code class="literal">ClientsListViewController</code> using the <code class="literal">NavigationService</code>. If either fails, we use the <code class="literal">SetErrorMessage</code> function for displaying an error.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note94"/>Note</h3><p>We control the navigation stack by the presenter type passed into the <code class="literal">PushPresenter</code>/ <code class="literal">PopPresenter</code> functions.</p></div></div><p>Now let's add the function for handling registrations:</p><pre class="programlisting">private async void HandleRegister(object sender, Tuple&lt;string, string&gt; user)&#13;
         {&#13;
             // make sure only once can we be registering at any one time&#13;
             if (!_view.IsInProgress)&#13;
             {&#13;
                 _state.Username = user.Item1;&#13;
                 _view.IsInProgress = true;&#13;
                 if (user.Item2.Length &gt;= 6)&#13;
                 {&#13;
                     var registerSuccess = await _webApiAccess.RegisterAsync(user.Item1, user.Item2, CancellationToken.None);&#13;
                     if (registerSuccess)&#13;
                     {&#13;
                         _view.SetErrorMessage("User successfully registered.");&#13;
                     }&#13;
                 }&#13;
                 else&#13;
                 {&#13;
                     _view.SetErrorMessage("Password must be at least 6 characters.");&#13;
                 }&#13;
                 _view.IsInProgress = false;&#13;
             }&#13;
         }&#13;
         #endregion</pre><p>Very much the same as the <code class="literal">LoginAsync</code>, but we call the <code class="literal">RegisterAsync</code> and simply wait for the call to finish and check we have the HTTP status code of <code class="literal">200 (OK)</code>.</p></div>
<div class="section" title="Creating the connection between Presenter and View"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec86"/>Creating the connection between Presenter and View</h1></div></div></div><p>Now we move on to the user interface design and demonstrate how we set up the link between our presenters. Developing the user interface is no different to developing natively for iOS and Android; the only difference with MVP is that we initialize a view with its related presenter in the constructor.</p><p>Let's start by adding a new folder to the <code class="literal">Chat.iOS</code> project called <code class="literal">Views</code>, add in a new file called <code class="literal">LoginViewController.cs</code>, and implement the following:</p><pre class="programlisting">public class LoginViewController : UIViewController, LoginPresenter.ILoginView&#13;
     {&#13;
         #region Private Properties&#13;
         private bool _isInProgress = false;&#13;
         private LoginPresenter _presenter;&#13;
         private UITextField _loginTextField;&#13;
         private UITextField _passwordTextField;&#13;
         private UIActivityIndicatorView _activityIndicatorView;&#13;
         #endregion&#13;
         #region Constructors&#13;
         public LoginViewController(LoginPresenter presenter)&#13;
         {&#13;
             _presenter = presenter;&#13;
         }&#13;
         #endregion&#13;
    } &#13;
 &#13;
</pre><p>We start off simply with the private properties and the constructor, where we are passing a new <code class="literal">LoginPresenter</code> object that we create from the <code class="literal">AppDelegate</code> as the starting presenter. The two text fields are used for the username and password entries. We have these as a local variable as we will need to access one instance of each from multiple functions. We also have a <code class="literal">UIActivityIndicatorView</code> for displaying the progress when we login and register.</p><p>Let's go ahead and add the <code class="literal">ViewDidLoad</code> function. We will implement this in a few parts. First we are going to set the view of the presenter and initialize all the UI elements and add them into the <code class="literal">View</code>:</p><pre class="programlisting">#region Public Methods&#13;
         public override void ViewDidLoad()&#13;
         {&#13;
             base.ViewDidLoad();&#13;
             View.BackgroundColor = UIColor.White;&#13;
             _presenter.SetView(this);&#13;
             var width = View.Bounds.Width;&#13;
             var height = View.Bounds.Height;&#13;
             Title = "Welcome";&#13;
             var titleLabel = new UILabel()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Text = "Chat",&#13;
                 Font = UIFont.FromName("Helvetica-Bold", 22),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             _activityIndicatorView = new UIActivityIndicatorView()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Color = UIColor.Black&#13;
             };&#13;
             var descriptionLabel = new UILabel()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Text = "Enter your login name to join the chat room.",&#13;
                 Font = UIFont.FromName("Helvetica", 18),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             _loginTextField = new UITextField()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Placeholder = "Username",&#13;
                 Font = UIFont.FromName("Helvetica", 18),&#13;
                 BackgroundColor = UIColor.Clear.FromHex("#DFE4E6"),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             _passwordTextField = new UITextField()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Placeholder = "Password",&#13;
                 Font = UIFont.FromName("Helvetica", 18),&#13;
                 BackgroundColor = UIColor.Clear.FromHex("#DFE4E6"),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             var buttonView = new UIView()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false&#13;
             };&#13;
             var loginButton = new UIButton(UIButtonType.RoundedRect)&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false&#13;
             };&#13;
             loginButton.SetTitle("Login", UIControlState.Normal);&#13;
             loginButton.TouchUpInside += (sender, e) =&gt;&#13;
                  Login(this, new Tuple&lt;string, string&gt;(_loginTextField.Text, _passwordTextField.Text));&#13;
             var registerButton = new UIButton(UIButtonType.RoundedRect)&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false&#13;
             };&#13;
             registerButton.SetTitle("Register", UIControlState.Normal);&#13;
             registerButton.TouchUpInside += (sender, e) =&gt;&#13;
                 Register(this, new Tuple&lt;string, string&gt;(_loginTextField?.Text, _passwordTextField?.Text));&#13;
             Add(titleLabel);&#13;
             Add(descriptionLabel);&#13;
             Add(_activityIndicatorView);&#13;
             Add(_loginTextField);&#13;
             Add(_passwordTextField);&#13;
             Add(buttonView);&#13;
             buttonView.Add(loginButton);&#13;
             buttonView.Add(registerButton);&#13;
         }&#13;
         #endregion &#13;
</pre><p>This is a large block of code, but we are creating quite a few UI elements. All have the <code class="literal">TranslatesAutoresizingMaskIntoConstraints</code> set to <code class="literal">false</code> ready for <code class="literal">
<span class="strong"><strong>NSLayout</strong></span>
</code>. Have a look at how we integrate the <code class="literal">ILoginView</code> implementation with the Login and <code class="literal">RegisterEventHandlers</code> as they are wired to the <code class="literal">TouchUpInside</code> event of each button.</p><p>Now let's start building the <code class="literal">NSLayoutConstraints</code>. Add the following to the bottom of the <code class="literal">ViewDidLoad</code> function:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip95"/>Tip</h3><p>We are using the <code class="literal">DictionaryViews</code> object that we used in previous chapters. Create a new folder called <code class="literal">Extras</code> and add this object into the <code class="literal">Extras</code> folder.</p></div></div><pre class="programlisting">var views = new DictionaryViews()&#13;
             {&#13;
                 {"titleLabel", titleLabel},&#13;
                 {"descriptionLabel", descriptionLabel},&#13;
                 {"loginTextField", _loginTextField},&#13;
                 {"passwordTextField", _passwordTextField},&#13;
                 {"loginButton", loginButton},&#13;
                 {"registerButton", registerButton},&#13;
                 {"activityIndicatorView", _activityIndicatorView},&#13;
                 {"buttonView", buttonView}&#13;
             };&#13;
             buttonView.AddConstraints(&#13;
                 NSLayoutConstraint.FromVisualFormat("V:|-[registerButton]-|", NSLayoutFormatOptions.DirectionLeftToRight, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("V:|-[loginButton]-|", NSLayoutFormatOptions.DirectionLeftToRight, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-[registerButton]-30-[loginButton]-|", NSLayoutFormatOptions.DirectionLeftToRight, null, views))&#13;
                 .ToArray());&#13;
             View.AddConstraints(&#13;
                 NSLayoutConstraint.FromVisualFormat("V:|-100-[titleLabel(50)]-[descriptionLabel(30)]-10-[loginTextField(30)]-10-[passwordTextField(30)]-10-[buttonView]", NSLayoutFormatOptions.DirectionLeftToRight, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("V:|-100-[activityIndicatorView(50)]-[descriptionLabel(30)]-10-[loginTextField(30)]-10-[passwordTextField(30)]-10-[buttonView]", NSLayoutFormatOptions.DirectionLeftToRight, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[titleLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:[activityIndicatorView(30)]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[descriptionLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-30-[loginTextField]-30-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-30-[passwordTextField]-30-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(new[] { NSLayoutConstraint.Create(buttonView, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal, View, NSLayoutAttribute.CenterX, 1, 1)&#13;
 })&#13;
                 .ToArray());</pre><p>The constraints will position the <code class="literal">buttonView</code> to the center of the screen horizontally; each buttons inside will be positioned horizontally next to each other. The rest of the layout is very self-explanatory. We are simply stacking the remaining element vertically down the page. The <code class="literal">UIActivityIndicatorView</code> will be positioned to the top right of the screen next to the <code class="literal">TitleLabel</code>. The rest of the layout will make more sense when we try running the application.</p><p>Finally, we add the remaining interface implementations; we require both Login and <code class="literal">Register</code> for the <code class="literal">ILoginView</code> interface. We also require <code class="literal">IsInProgress</code>
<span class="strong"><strong> </strong></span>bool and the <code class="literal">SetErrorMessage</code> function; this will create a new <code class="literal">UIAlertView</code> showing the error message. We also override the get and set of <code class="literal">IsInProgress</code> to control the start and stop animation of the <code class="literal">UIActivityIndicatorView</code>:</p><pre class="programlisting">         #region ILoginView implementation&#13;
         public event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Login;&#13;
         public event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Register;&#13;
         #endregion&#13;
         #region IView implementation&#13;
 &#13;
         public void SetErrorMessage(string message)&#13;
         {&#13;
             var alert = new UIAlertView()&#13;
             {&#13;
                 Title = "Chat",&#13;
                 Message = message&#13;
             };&#13;
             alert.AddButton("OK");&#13;
             alert.Show();&#13;
         }&#13;
         public bool IsInProgress&#13;
          {&#13;
              get&#13;
             {&#13;
                 return _isInProgress;&#13;
             }&#13;
             set&#13;
             {&#13;
                 if (value == _isInProgress)&#13;
                 {&#13;
                     return;&#13;
                 }&#13;
                 // we control the activity view when we set 'IsInProgress'&#13;
                 if (value)&#13;
                 {&#13;
                     _activityIndicatorView.StartAnimating();&#13;
                 }&#13;
                 else&#13;
                 {&#13;
                     _activityIndicatorView.StopAnimating();&#13;
                 }&#13;
                 _isInProgress = value;&#13;
             }&#13;
         }&#13;
         #endregion &#13;
</pre><p>The link between our first view and presenter is not as clean as an MVVM <span class="strong"><strong>BindingContext</strong></span> with <code class="literal">Xamarin.Forms</code>, but the advantage is having no middle layer of rendering between the native user interface and the data to be displayed.</p></div>
<div class="section" title="Building the LoginActivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec87"/>Building the LoginActivity</h1></div></div></div><p>Let's move back into the <code class="literal">Chat.Droid</code> project; before we create our <code class="literal">Activity</code> we need to create the layout using a new XML sheet. Add a new file called <code class="literal">LoginView.xml</code> into the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>l<span class="strong"><strong>ayout</strong></span>
</strong></span> and implement the following:</p><pre class="programlisting"> &#13;
&lt;?xml version="1.0" encoding="utf-8"?&gt;&#13;
 &lt;LinearLayout &#13;
     android:id="@+id/tableLayout"&#13;
     android:layout_width="fill_parent"&#13;
     android:layout_height="fill_parent"&#13;
     android:orientation="vertical"&#13;
     android:gravity="center"&#13;
     android:background="#FFFFFF"&gt;&#13;
     &lt;TextView&#13;
         android:id="@+id/titleTextView"&#13;
         android:text="Chat"&#13;
         android:fontFamily="helvetica"&#13;
         android:textStyle="bold"&#13;
         android:textSize="22dp"&#13;
         android:textColor="#000000"&#13;
         android:paddingBottom="20dp"&#13;
         android:layout_width="wrap_content"&#13;
         android:layout_height="wrap_content" /&gt;&#13;
     &lt;TextView&#13;
         android:id="@+id/descriptionTextView"&#13;
         android:text="Enter your login name to join the chat room."&#13;
         android:fontFamily="helvetica"&#13;
         android:textColor="#000000"&#13;
         android:paddingBottom="20dp"&#13;
         android:layout_centerInParent="true"&#13;
         android:layout_width="wrap_content"&#13;
         android:layout_height="wrap_content" /&gt;&#13;
     &lt;EditText&#13;
         android:id="@+id/usernameField"&#13;
         android:textColor="#000000"&#13;
         android:layout_width="fill_parent"&#13;
         android:layout_height="50dp"&#13;
         android:paddingBottom="20dp"&#13;
         android:hint="Enter Username" /&gt;&#13;
     &lt;EditText&#13;
         android:id="@+id/passwordField"&#13;
         android:textColor="#000000"&#13;
         android:layout_width="fill_parent"&#13;
         android:layout_height="50dp"&#13;
         android:hint="Enter Password" /&gt;&#13;
     &lt;LinearLayout&#13;
         android:id="@+id/tableLayout"&#13;
         android:gravity="center"&#13;
         android:layout_width="fill_parent"&#13;
         android:layout_height="150dp"&#13;
         android:orientation="horizontal"&#13;
         android:background="#FFFFFF"&gt;&#13;
         &lt;Button&#13;
             android:id="@+id/registerButton"&#13;
             android:text="Register"&#13;
             android:textColor="#417BB5"&#13;
             android:background="@android:color/transparent"&#13;
             android:layout_height="50dp"&#13;
             android:layout_width="100dp" /&gt;&#13;
         &lt;Button&#13;
             android:id="@+id/loginButton"&#13;
             android:text="Login"&#13;
             android:textColor="#417BB5"&#13;
             android:background="@android:color/transparent"&#13;
             android:paddingLeft="20dp"&#13;
             android:layout_height="50dp"&#13;
             android:layout_width="100dp" /&gt;&#13;
     &lt;/LinearLayout&gt;&#13;
 &lt;/LinearLayout&gt; &#13;
</pre><p>The <code class="literal">XMLlayout</code> will stack the page vertically, with the two buttons placed side-by-side.</p><p>A quick way of checking your layouts in <code class="literal">Xamarin.Studio</code> is to click the <span class="strong"><strong>Designer</strong></span> window:</p><div class="mediaobject"><img src="graphics/B05293_06_16.jpg" alt="Building the LoginActivity"/></div><p>Now let's create a new folder called <code class="literal">Views</code>, add in a new file called <code class="literal">LoginActivity.cs</code>, and implement the first section:</p><pre class="programlisting"> &#13;
[Activity(MainLauncher = true, Label = "Chat", ScreenOrientation = ScreenOrientation.Portrait)]&#13;
     public class LoginActivity : Activity, LoginPresenter.ILoginView&#13;
     {&#13;
         #region Private Properties&#13;
         private bool _isInProgress = false;&#13;
         private bool _dialogShown = false;&#13;
         private LoginPresenter _presenter;&#13;
         private EditText _loginField;&#13;
         private EditText _passwordField;&#13;
         private ProgressDialog progressDialog;&#13;
         #endregion&#13;
         #region Protected Methods&#13;
         protected override void OnCreate(Bundle bundle)&#13;
         {&#13;
             base.OnCreate(bundle);&#13;
             SetContentView(Resource.Layout.LoginView);&#13;
             progressDialog = new ProgressDialog(this);&#13;
             progressDialog.SetMessage("Loading...");&#13;
             progressDialog.SetCancelable(false);&#13;
             _loginField = FindViewById&lt;EditText&gt;(Resource.Id.usernameField);&#13;
             _passwordField = FindViewById&lt;EditText&gt;(Resource.Id.passwordField);&#13;
             var registerButton = FindViewById&lt;Button&gt;(Resource.Id.registerButton);&#13;
             registerButton.Touch += (sender, e) =&gt;&#13;
                 Register(this, new Tuple&lt;string, string&gt;(_loginField.Text, _passwordField.Text));&#13;
             var loginButton = FindViewById&lt;Button&gt;(Resource.Id.loginButton);&#13;
             loginButton.Touch += (sender, e) =&gt;&#13;
                 Login(this, new Tuple&lt;string, string&gt;(_loginField.Text, _passwordField.Text));&#13;
             var app = ChatApplication.GetApplication(this);&#13;
             var state = new ApplicationState();&#13;
             _presenter = new LoginPresenter(state, new NavigationService(app));&#13;
             _presenter.SetView(this);&#13;
             app.CurrentActivity = this;&#13;
         }&#13;
     #endregion &#13;
</pre><p>Since we already have the UI logic in our presenter, building the interface for <code class="literal">LoginActivity</code> is much easier as the answers all lie in the presenter. This is the advantage of code-sharing using the MVP pattern.</p><p>In our <code class="literal">OnCreate()</code> function, we will start with setting the <code class="literal">ContentView</code> to the <code class="literal">XMLlayout</code> we created previously. We will then register the button <code class="literal">Touch</code> events to the <code class="literal">ILoginView</code>interface, very much like the iOS version with the <code class="literal">TouchUpInside</code> events. We then retrieve the application from the <code class="literal">GetApplication</code> function<span class="strong"><strong>.</strong></span> We also create an instance of the <code class="literal">ApplicationState</code>, and create a new <code class="literal">LoginPresenter</code>.</p><p>We must also add the requirements of the <code class="literal">ILoginView</code> and <code class="literal">IView</code> interfaces. The <code class="literal">SetErrorMessage</code> will use the <code class="literal">AlertDialog.Builder</code> framework to create the same popup as the iOS version. We only set one button for this dialog which will simply close the dialog when we press <span class="strong"><strong>
<span class="strong"><strong>OK</strong></span>:</strong></span>.</p><pre class="programlisting">         #region ILoginView implementation&#13;
         public event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Login;&#13;
         public event EventHandler&lt;Tuple&lt;string, string&gt;&gt; Register;&#13;
         #endregion&#13;
         #region IView implementation&#13;
         public void SetErrorMessage(string message)&#13;
         {&#13;
             if (!_dialogShown)&#13;
             {&#13;
                 _dialogShown = true;&#13;
                 AlertDialog.Builder builder = new AlertDialog.Builder(this);&#13;
                 builder&#13;
                     .SetTitle("Chat")&#13;
                     .SetMessage(message)&#13;
                     .SetNeutralButton("Ok", (sender, e) =&gt; { _dialogShown = false ;})&#13;
                     .Show();&#13;
             }&#13;
         }&#13;
         public bool IsInProgress&#13;
         {&#13;
             get&#13;
             {&#13;
                 return _isInProgress;&#13;
             }&#13;
             set&#13;
             {&#13;
                 if (value == _isInProgress)&#13;
                 {&#13;
                     return;&#13;
                 }&#13;
                 // we control the activity view when we set 'IsInProgress'&#13;
                 if (value)&#13;
                 {&#13;
                     progressDialog.Show();&#13;
                 }&#13;
                 else&#13;
                 {&#13;
                     progressDialog.Dismiss();&#13;
                 }&#13;
                 _isInProgress = value;&#13;
             }&#13;
         }&#13;
         #endregion&#13;
     } &#13;
</pre><p>See how the structure is the exact same as iOS?</p><p>We just have to match the UI elements for each platform independently. Our final part to the activity is the <code class="literal">OnResume</code> function. This function will reset the <code class="literal">CurrentActivity</code> in the <code class="literal">Application</code>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip96"/>Tip</h3><p>It is important that every time an activity is resumed we reset the <code class="literal">CurrentActivity</code>, otherwise the navigation service will not push/pop on the correct <code class="literal">Activity</code>.</p></div></div><pre class="programlisting">protected override void OnResume()&#13;
         {&#13;
             base.OnResume();&#13;
             var app = ChatApplication.GetApplication(this);&#13;
             app.CurrentActivity = this;&#13;
             if (_presenter != null)&#13;
             {&#13;
                 _presenter.SetView(this);&#13;
             }&#13;
         }&#13;
         #endregion</pre><p>Excellent! Now we have created the first screen, presenter, and linked it up with the navigation service. Let's hop back into the <code class="literal">Chat.iOS</code> project and build the next screen of our application.</p></div>
<div class="section" title="Implementing the ClientsListPresenter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec88"/>Implementing the ClientsListPresenter</h1></div></div></div><p>Create a new file called <code class="literal">ClientsListPresenter.cs</code>, add it to the <code class="literal">Presenter</code> folder in the <code class="literal">Chat.Common</code> project, and implement the following:</p><pre class="programlisting"> &#13;
public class ClientsListPresenter : BasePresenter&#13;
     {&#13;
         #region Private Properties&#13;
         private IClientsListView _view;&#13;
         #endregion&#13;
         #region IClientsListView&#13;
         public interface IClientsListView : IView&#13;
         {&#13;
             event EventHandler&lt;ClientSelectedEventArgs&gt; ClientSelected;&#13;
             void NotifyConnectedClientsUpdated(IEnumerable&lt;Client&gt; clients);&#13;
         }&#13;
         #endregion&#13;
         #region Constructors&#13;
         public ClientsListPresenter(ApplicationState state, INavigationService navigationService,&#13;
                                      string accessToken)&#13;
         {&#13;
             _navigationService = navigationService;&#13;
             _state = state;&#13;
             _state.AccessToken = accessToken;&#13;
             InitSignalR(accessToken).ConfigureAwait(false);&#13;
         }&#13;
         #endregion&#13;
  &#13;
 }  &#13;
</pre><p>We have declared a new <span class="strong"><strong>IClientsListView</strong></span> interface specific to the current <span class="strong"><strong>UIViewController</strong></span> (this must be done for every screen). It simply extends off the <span class="strong"><strong>IView</strong></span> interface, and we add an extra event handler for selected items in our <span class="strong"><strong>UITableView</strong></span>. We then have our constructor which we must pass in an <span class="strong"><strong>ApplicationState</strong></span>,<span class="strong"><strong>NavigationService,</strong></span> and an access token. We also initialize the <span class="strong"><strong>SignalRClient</strong></span>: the <code class="literal">ConfigureAwait</code> function is set to false because we don't want to wait for this task to finish.</p><p>We now need to add another function called <code class="literal">SetView</code>.This will take the action user interface object and register any <code class="literal">EventHandlers</code> specified by the <span class="strong"><strong>IClientsListView</strong></span> interface. We also make another call to the Web API to retrieve the current clients connected to the <span class="strong"><strong>ChatHub</strong></span>. We also specify that we don't want to wait on this task via the <code class="literal">ConfigureAwait</code>function.</p><p>In each <code class="literal">SetView</code> that will be responding to real-time data updates from the <span class="strong"><strong>SignalRClient</strong></span>, we have to reregister to the OnDataReceived<code class="literal">EventHandler</code> so the correct presenter function <code class="literal">HandleSignalRDataReceived</code> is called:</p><pre class="programlisting">#region Public Methods public void SetView(IClientsListView view)&#13;
         {&#13;
             _view = view;&#13;
             _signalRClient.OnDataReceived -= HandleSignalRDataReceived;&#13;
             _signalRClient.OnDataReceived += HandleSignalRDataReceived;&#13;
             _view.ClientSelected -= HandleClientSelected;&#13;
             _view.ClientSelected += HandleClientSelected;&#13;
             ConnectedClientsUpdated -= HandleConnectedClientsUpdated;&#13;
             ConnectedClientsUpdated += HandleConnectedClientsUpdated;&#13;
             GetAllConnectedClients().ConfigureAwait(false);&#13;
         }&#13;
  &#13;
 #endregion &#13;
 &#13;
</pre><p>A presenter can also have the opposite to the <code class="literal">SetView</code> function called <code class="literal">ReleaseView</code>. It will be responsible for disposing EventHandlers when screens disappear. This ensures we don't have events on any previous pages doing work when they are not visible. Add the following under the <code class="literal">SetView</code> function:</p><pre class="programlisting"> &#13;
public void ReleaseView()&#13;
         {&#13;
             _signalRClient.OnDataReceived -= HandleSignalRDataReceived;&#13;
         } &#13;
 &#13;
</pre><p>Now let's add the <code class="literal">Signout</code> function.This will be called when a user wants to disconnect from the <span class="strong"><strong>ChatHub</strong></span> (when the user leaves the <span class="strong"><strong>ClientsListViewController</strong></span>):</p><pre class="programlisting">public void Signout()&#13;
         {&#13;
             _signalRClient.Disconnect();&#13;
             _navigationService.PopPresenter(true);&#13;
         } &#13;
</pre><p>Let's add two more functions: <code class="literal">HandleClientSelected</code> will use the <span class="strong"><strong>INavigationService</strong></span> to push the next screen on to the stack, and the other function, <code class="literal">HandleConnectedClientsUpdated</code> will call the native implementation in the user interface object. We will also filter the list of clients using Linq to include all other clients but the current user:</p><pre class="programlisting">#region Private Methods&#13;
         private void HandleClientSelected(object sender, ClientSelectedEventArgs e)&#13;
         {&#13;
             var presenter = new ChatPresenter(_state, _navigationService, e.Client, _signalRClient);&#13;
             _navigationService.PushPresenter(presenter);&#13;
         }&#13;
         private void HandleConnectedClientsUpdated(object sender,&#13;
         ConnectedClientsUpdatedEventArgs e)&#13;
         {&#13;
             _view.NotifyConnectedClientsUpdated(e.ConnectedClients&#13;
                                                 .Where(x =&gt; !x.Username.ToLower()&#13;
                                                 .Contains(_state.Username.ToLower())));&#13;
         }&#13;
         #endregion &#13;
 &#13;
</pre><p>Since we know that we require a <span class="strong"><strong>UITableView </strong></span>on the <span class="strong"><strong>ClientsListView </strong></span>screen, we need to create a <span class="strong"><strong>TableSource </strong></span>object that will show all our clients that are connected to the <span class="strong"><strong>ChatHub</strong></span>. We also need a model object to hold the data to be displayed for each <span class="strong"><strong>Client</strong></span>.</p><p>Firstly, create a new folder in the <span class="strong"><strong>Chat.Common </strong></span>project called <span class="strong"><strong>Model</strong></span>, add in a new file called <code class="literal">Client.cs</code> and implement the following:</p><pre class="programlisting">public class Client { public string Username; }  &#13;
</pre><p>For each cell, we are only going to display one text label showing the username of the connected client. Now let's add in a new file called <code class="literal">ClientsTableSource.cs</code> and start with the following:</p><pre class="programlisting"> &#13;
public class ClientsTableSource : UITableViewSource  &#13;
{ &#13;
         #region Public Properties &#13;
 &#13;
         public event EventHandler&lt;Client&gt; ItemSelected; &#13;
 &#13;
         #endregion &#13;
 &#13;
         #region Private Properties &#13;
 &#13;
         private List&lt;Client&gt; _clients; &#13;
 &#13;
         string CellIdentifier = "ClientCell"; &#13;
 &#13;
         #endregion &#13;
 &#13;
         #region Constructors &#13;
 &#13;
         public ClientsTableSource () &#13;
         { &#13;
               _clients = new List&lt;Client&gt; (); &#13;
         } &#13;
 &#13;
         #endregion &#13;
} &#13;
 &#13;
</pre><p>We require a private <code class="literal">List</code> for holding the latest clients connected, we have our <code class="literal">CellIdentifier</code> label set as <code class="literal">ClientCell</code>, and we have an <code class="literal">EventHandler</code> for selected cell events that will occur from the <code class="literal">UITableView</code>.</p><p>Every time one of these events are fired from the <code class="literal">TableSource</code>, we will be firing the event handler in our <code class="literal">ClientsListPresenter </code>presenter. Now let's implement the rest of the overrides required by the <code class="literal">UITableViewSource</code>
<span class="strong"><strong> </strong></span>class:</p><pre class="programlisting">#region Methods&#13;
         public void UpdateClients(IEnumerable&lt;Client&gt; clients)&#13;
         {&#13;
             foreach (var client in clients)&#13;
             {&#13;
                 _clients.Add (client);&#13;
             }&#13;
         }&#13;
         public override nint NumberOfSections (UITableView tableView)&#13;
         {&#13;
             return 1;&#13;
         }&#13;
         public override nint RowsInSection (UITableView tableview, nint section)&#13;
         {&#13;
             return _clients.Count;&#13;
         }&#13;
         public override void RowSelected (UITableView tableView, NSIndexPath indexPath)&#13;
         {&#13;
             if (ItemSelected != null)&#13;
             {&#13;
                 ItemSelected (this, _clients[indexPath.Row]);&#13;
             }&#13;
             tableView.DeselectRow (indexPath, true);&#13;
         }&#13;
         public override nfloat GetHeightForRow (UITableView tableView, NSIndexPath indexPath)&#13;
         {&#13;
             return 80;&#13;
         }&#13;
         public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)&#13;
         {&#13;
             UITableViewCell cell = tableView.DequeueReusableCell(CellIdentifier);&#13;
             var client = _clients[indexPath.Row];&#13;
             if (cell == null)&#13;
             {&#13;
                  cell = new UITableViewCell(UITableViewCellStyle.Default, CellIdentifier);&#13;
              }&#13;
             cell.TextLabel.Text = client.Ip;&#13;
             return cell;&#13;
         }&#13;
 #endregion  &#13;
</pre><p>Our <code class="literal">GetCell</code> function will use the default <code class="literal">UITableViewCellStyle</code>, and the text will be set to the username of the <code class="literal">Client</code> object. Our <code class="literal">RowSelected</code> function will fire our custom <code class="literal">EventHandlerItemSelected</code>. We will register a delegate on this <code class="literal">EventHandler</code> for firing
our related presenter <code class="literal">Event</code>. Finally, our <code class="literal">UpdateClients</code> will be called whenever we receive a
proxy event when the client count changes.</p></div>
<div class="section" title="Creating ClientListViewController"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec89"/>Creating ClientListViewController</h1></div></div></div><p>Now we will move on to the user interface design and demonstrate how we set up the link between our presenters. Developing the user interface is no different to developing natively for iOS and Android; the only difference with MVP is that we initialize a view with its related presenter in the constructor.</p><p>Let's start by adding a new folder to the <code class="literal">Chat.iOS</code> project called <code class="literal">Views</code>, add in a new file called <code class="literal">ClientsListViewController.cs</code>, and implement the following:</p><pre class="programlisting">public class ClientsListViewController : UIViewController, ClientsListPresenter.IClientsListView&#13;
     {&#13;
         #region Private Properties&#13;
         private UITableView _tableView;&#13;
         private ClientsTableSource _source;&#13;
         private ClientsListPresenter _presenter;&#13;
         private UIActivityIndicatorView _activityIndicatorView;&#13;
         #endregion&#13;
         #region Constructors&#13;
         public ClientsListViewController(ClientsListPresenter presenter)&#13;
         {&#13;
             _presenter = presenter;&#13;
             _source = new ClientsTableSource();&#13;
             _source.ItemSelected += (sender, e) =&gt;&#13;
             {&#13;
                 if (ClientSelected != null)&#13;
                 {&#13;
                     ClientSelected(this, new ClientSelectedEventArgs(e));&#13;
                 }&#13;
             };&#13;
         }&#13;
         #endregion&#13;
  &#13;
   } &#13;
</pre><p>Notice how we pass the presenter in the constructor of the <code class="literal">UIViewController</code>?</p><p>We will be doing this with every view that is added to the navigation service.</p><p>Inside the constructor, we are also registering the <code class="literal">itemSelected</code> event to fire the interface event for our presenter. Let's add in the following:</p><pre class="programlisting"> &#13;
#region Public Methods&#13;
         public override void ViewDidLoad()&#13;
         {&#13;
             base.ViewDidLoad();&#13;
             // Perform any additional set up after loading the view, typically from a nib.&#13;
             UIBarButtonItem backButton = new UIBarButtonItem("&lt; Back", UIBarButtonItemStyle.Bordered, HandleSignout);&#13;
             NavigationItem.SetLeftBarButtonItem(backButton, false);&#13;
             View.BackgroundColor = UIColor.White;&#13;
             _presenter.SetView(this);&#13;
             var width = View.Bounds.Width;&#13;
             var height = View.Bounds.Height;&#13;
             Title = "Clients";&#13;
             var titleLabel = new UILabel()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Text = "Connected Clients",&#13;
                 Font = UIFont.FromName("Helvetica-Bold", 22),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             var descriptionLabel = new UILabel()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Text = "Select a client you would like to chat with",&#13;
                 Font = UIFont.FromName("Helvetica", 18),&#13;
                 TextAlignment = UITextAlignment.Center&#13;
             };&#13;
             _tableView = new UITableView(new CGRect(0, 0, width, height))&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false&#13;
             };&#13;
             _tableView.AutoresizingMask = UIViewAutoresizing.All;&#13;
             _tableView.Source = _source;&#13;
             Add(titleLabel);&#13;
             Add(descriptionLabel);&#13;
             Add(_tableView);&#13;
             var views = new DictionaryViews()&#13;
             {&#13;
                 {"titleLabel", titleLabel},&#13;
                 {"descriptionLabel", descriptionLabel},&#13;
                 {"tableView", _tableView},&#13;
             };&#13;
             View.AddConstraints(&#13;
                 NSLayoutConstraint.FromVisualFormat("V:|-100-[titleLabel(30)]-[descriptionLabel(30)]-[tableView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|[tableView]|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[titleLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[descriptionLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))                 .ToArray());&#13;
         }  &#13;
 &#13;
 &#13;
#endregion &#13;
</pre><p>In the <code class="literal">ViewDidLoad</code> function, we will always be calling the <code class="literal">SetView</code> on a presenter class, and passing the view itself to the presenter. We are also going to add another little trick on this screen to override the <code class="literal">navbar</code> back button. We must create a <code class="literal">UIBArButtonItem</code>, which will be set as the left button of the navigation bar. When we instantiate this item, the <code class="literal">HandleSignout</code> function will be called when this button is pressed. Let's add this to the <code class="literal">UIViewController</code>:</p><pre class="programlisting">public async void HandleSignout(object sender, EventArgs e)&#13;
         {&#13;
             bool accepted = await ShowAlert("Chat", "Would you like to signout?");&#13;
             if (accepted)&#13;
             {&#13;
                 _presenter.Signout();&#13;
             }&#13;
         }</pre><p>The function will show an alert and wait for a response to be provided by the user. In this case, it will be <code class="literal">"Yes"</code> or <code class="literal">"No"</code>. We are going to add another function <code class="literal">ShowAlert()</code>, which will use the <code class="literal">TaskCompletionSource</code> framework to allow us to await a response from a <code class="literal">UIAlertView</code>.</p></div>
<div class="section" title="The TaskCompletionSource framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec90"/>The TaskCompletionSource framework</h1></div></div></div><p>The <code class="literal">ShowAlert</code> function will instantiate a new instance of a <code class="literal">TaskCompletionSource</code> of type <code class="literal">bool</code>. We then invoke the action on the main thread using the <code class="literal">UIApplication.SharedApplication</code>, and then return the <code class="literal">Task</code> object of the <code class="literal">TaskCompletionSource</code>. This means we can wait for the task to be returned When we create the <code class="literal">UIAlertView</code>, we set the <code class="literal">Clicked</code> event of the dialog to call the <code class="literal">SetResult</code>function of the <code class="literal">TaskCompletionSource</code>, so the <code class="literal">Task</code> will not finish until this click event has occurred:</p><pre class="programlisting">         public Task&lt;bool&gt; ShowAlert(string title, string message)&#13;
         {&#13;
             var tcs = new TaskCompletionSource&lt;bool&gt;();&#13;
             UIApplication.SharedApplication.InvokeOnMainThread(new Action(() =&gt;&#13;
             {&#13;
                 UIAlertView alert = new UIAlertView(title, message, null, NSBundle.MainBundle.LocalizedString("Cancel", "Cancel"),&#13;
                                     NSBundle.MainBundle.LocalizedString("OK", "OK"));&#13;
                 alert.Clicked += (sender, buttonArgs) =&gt;&#13;
 tcs.SetResult(buttonArgs.ButtonIndex != alert.CancelButtonIndex);&#13;
                 alert.Show();&#13;
             }));&#13;
             return tcs.Task;&#13;
         }&#13;
</pre><p>Now that we have overriden the back button, when a user tries to click back on the clients list screen to return to the login, the <code class="literal">UIAlertView</code> will appear, asking if the user wants to signout (meaning the user will disconnect from the <code class="literal">ChatHub</code>). If the user presses <span class="strong"><strong>Yes</strong></span>, we will call the <code class="literal">Signout</code> function on the <code class="literal">ClientsListPresenter</code>.</p><p>Now let's get back to the <code class="literal">ViewDidLoad</code> function and add in the <code class="literal">NSLayoutConstraints</code> to build the screen:</p><pre class="programlisting">View.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-100-[titleLabel(30)]-[descriptionLabel(30)]-[tableView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|[tableView]|", NSLayoutFormatOptions.AlignAllTop, null, views)) &#13;
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[titleLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views)) &#13;
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-10-[descriptionLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .ToArray());  &#13;
 &#13;
</pre><p>We have all the elements stacked vertically, taking up the entire width of the screen with padding.</p><p>Finally, we also want to add the <code class="literal">ViewDidUnload</code> function, so we can remove the <code class="literal">OnDataReceived</code> event on the <code class="literal">SignalRClient</code>:</p><pre class="programlisting">public override void ViewDidUnload()&#13;
         {&#13;
             base.ViewDidUnload();&#13;
             _presenter.ReleaseView();&#13;
         } &#13;
</pre></div>
<div class="section" title="Creating the ClientsListActivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec91"/>Creating the ClientsListActivity</h1></div></div></div><p>Let's move back again to the <code class="literal">Chat.Droid</code> project. Create a new folder called <code class="literal">Views</code>, add in a new file called <code class="literal">ClientsListView.cs</code>, and implement the following:</p><pre class="programlisting">[Activity(Label = "Chat Room", Icon = "@drawable/icon", ScreenOrientation = ScreenOrientation.Portrait)]&#13;
     public class ClientsListActivity : ListActivity, ClientsListPresenter.IClientsListView&#13;
     {&#13;
         #region Private Properties&#13;
         private ClientsListPresenter _presenter;&#13;
         private ClientsListAdapter _adapter;&#13;
         private bool _dialogShown = false;&#13;
         #endregion&#13;
         #region Protected Methods&#13;
         protected override void OnCreate(Bundle bundle)&#13;
         {&#13;
             base.OnCreate(bundle);&#13;
             ListView.SetBackgroundColor(Color.White);&#13;
              var app = ChatApplication.GetApplication(this);&#13;
             app.CurrentActivity = this;&#13;
             _presenter = app.Presenter as ClientsListPresenter;&#13;
             _presenter.SetView(this);&#13;
             _adapter = new ClientsListAdapter(this);&#13;
             ListAdapter = _adapter;&#13;
         }&#13;
         protected override void OnResume()&#13;
         {&#13;
             base.OnResume();&#13;
             var app = ChatApplication.GetApplication(this);&#13;
             app.CurrentActivity = this;&#13;
             if (_presenter != null)&#13;
             {&#13;
                 _presenter.SetView(this);&#13;
             }&#13;
         }    &#13;
 &#13;
  #endregion&#13;
  }  &#13;
</pre><p>For the first section of the <code class="literal">ClientsListActivity</code>, let's look at the <code class="literal">OnCreate</code>override. We will start with the <code class="literal">ChatApplication</code> instance and set the current <code class="literal">Activity</code> to the <code class="literal">ClientsListView</code> activity. We then instantiate a new <code class="literal">ClientsListPresenter</code>, add in the state, and add a new <code class="literal">NavigationService</code>. We will also set the view object of the presenter to the <code class="literal">ClientsListView</code>. Finally, we simply instantiate a new <code class="literal">ClientsListAdapter</code> and set it to the <code class="literal">ListAdapter</code> of the <code class="literal">Activity</code>, as we are inheriting a <code class="literal">ListActivity</code>. We are going to have a different layout to iOS and only show the <code class="literal">ListView</code> on this screen so we can demonstrate the <code class="literal">ListActivity</code>; therefore, we don't need an <code class="literal">XMLsheet</code> for the layout of this <code class="literal">Activity</code>.</p><p>The <code class="literal">OnResume</code> function is the same as the <code class="literal">LoginActivity</code>; we have to maintain the current <code class="literal">Activity</code>shown to the user. We also want to override the <code class="literal">OnPause</code> function to call <code class="literal">ReleaseView</code> on the <code class="literal">ClientsListPresenter</code> so we remove the <code class="literal">EventHandler</code> on the <code class="literal">OnDataReceived</code> property of the <code class="literal">SignalRClient</code>. This ensures we don't call <code class="literal">HandleSignalRDataReceived</code> whilst the screen is not visible.</p><pre class="programlisting">protected override void OnPause()&#13;
         {&#13;
             base.OnPause();&#13;
             if (_presenter != null)&#13;
             {&#13;
                 _presenter.ReleaseView();&#13;
             }&#13;
         }  &#13;
</pre><p>Now let's add the <code class="literal">IClientsListView</code> and <code class="literal">IView</code> implementation.The <code class="literal">NotifyConnectedClientsUpdated</code> will call the <code class="literal">UpdateClients</code> function on the <code class="literal">ListAdapter</code>, and we must propogate the <code class="literal">NotifyDataSetChanged</code> on the main thread as we are making data changes to the <code class="literal">ListView</code>:</p><pre class="programlisting">#region IClientsListView implementation&#13;
         public event EventHandler&lt;ClientSelectedEventArgs&gt; ClientSelected;&#13;
         public void NotifyConnectedClientsUpdated(IEnumerable&lt;Client&gt; clients)&#13;
         {&#13;
             if (_adapter != null)&#13;
             {&#13;
                 _adapter.UpdateClients(clients);&#13;
                 // perform action on UI thread&#13;
                 Application.SynchronizationContext.Post(state =&gt;&#13;
                  {&#13;
                      _adapter.NotifyDataSetChanged();&#13;
                  }, null);&#13;
             }&#13;
         }&#13;
         #endregion&#13;
         #region IView implementation&#13;
         public void SetErrorMessage(string message)&#13;
         {&#13;
             if (!_dialogShown)&#13;
             {&#13;
                 _dialogShown = true;&#13;
                 AlertDialog.Builder builder = new AlertDialog.Builder(this);&#13;
                 builder&#13;
                     .SetTitle("Chat")&#13;
                     .SetMessage(message)&#13;
                     .SetNeutralButton("Ok", (sender, e) =&gt; { _dialogShown = false; })&#13;
                     .Show();&#13;
             }         }&#13;
         public bool IsInProgress { get; set;&#13;
 }&#13;
         #endregion</pre><p>The <code class="literal">SetErrorMessage()</code> will initiate a dialog similar to iOS, using the <code class="literal">AlertDialog.Builder</code> framework. In this case, we only need to set the original button since we only need one button on the dialog.</p></div>
<div class="section" title="Overriding the OnBackPressed activity"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec92"/>Overriding the OnBackPressed activity</h1></div></div></div><p>With our iOS implementation we integrated an override to the navigation back button, so when a user leaves the <code class="literal">ClientListViewController</code>, we ask the user if they would like to signout from the <code class="literal">ChatHub</code>. We are going to do the same here but on the Android platform. We will be building the alert from the <code class="literal">AlertDialog.Builder</code> framework:</p><pre class="programlisting">public override void OnBackPressed()&#13;
         {&#13;
             //Put up the Yes/No message box&#13;
             AlertDialog.Builder builder = new AlertDialog.Builder(this);&#13;
             builder&#13;
                 .SetTitle("Chat")&#13;
                 .SetMessage("Would you like to signout?")&#13;
                 .SetNegativeButton("No", (sender, e) =&gt; { })&#13;
                 .SetPositiveButton("Yes", (sender, e) =&gt;&#13;
                      {&#13;
                          _presenter.Signout();&#13;
                     })&#13;
                 .Show();&#13;
         }</pre><p>We start with instantiating a new builder object which must take the <code class="literal">Activity</code> context as the only parameter. We then set the title and message of the dialog, and two buttons for the <code class="literal">"Yes"</code> and <code class="literal">"No"</code> selections. Only when the user selects <code class="literal">"Yes"</code> does an action occur by calling the same <code class="literal">Signout</code> as with iOS.</p><p>Our last piece of this <code class="literal">Activity</code> is to override the <code class="literal">OnListItemClick</code>. When an item in the list is selected, we want to fire the <code class="literal">ClientSelected</code> event specified by the interface, so we can tie this event logic into the <code class="literal">ClientsListPresenter:</code></p><pre class="programlisting">         protected override void OnListItemClick(ListView l, Android.Views.View v, int position, long id)&#13;
         {&#13;
             var item = _adapter[position];&#13;
             if (ClientSelected != null)&#13;
             {&#13;
                 ClientSelected(this, new ClientSelectedEventArgs(item));&#13;
             }&#13;
         }&#13;
         #endregion  &#13;
</pre></div>
<div class="section" title="Building the ListAdapter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec93"/>Building the ListAdapter</h1></div></div></div><p>Before we build our <code class="literal">ListAdapter,</code> we need to create another AXML sheet for the <span class="strong"><strong>CustomCell</strong></span>, add another file to the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>layout</strong></span> folder called <code class="literal">CustomCell.xml</code>, and implement the following:</p><pre class="programlisting"> &#13;
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout &#13;
     android:orientation="horizontal"&#13;
     android:layout_width="match_parent"&#13;
     android:layout_height="match_parent"&#13;
     android:weightSum="4"&gt;&#13;
     &lt;TextView&#13;
         android:id="@+id/username"&#13;
         android:layout_width="wrap_content"&#13;
         android:layout_height="wrap_content"&#13;
         android:layout_weight="1" /&gt;&#13;
 &lt;/LinearLayout&gt; &#13;
</pre><p>This is another simple layout which has one <code class="literal">TextView</code> wrapped in a <code class="literal">LinearLayout</code>. The <code class="literal">TextView</code>
<span class="strong"><strong> </strong></span>will display the <code class="literal">ConnectionId</code> for each <code class="literal">Client</code>.</p><p>Now let's get back to the <code class="literal">ListAdapter</code>. Inside the <code class="literal">Views</code> folder, add another file called <code class="literal">ClientsListAdapter.cs</code> and implement the following:</p><pre class="programlisting">public class ClientsListAdapter : BaseAdapter&lt;Client&gt;&#13;
     {&#13;
         private List&lt;Client&gt; _clients;&#13;
         private Activity _context;&#13;
         public ClientsListAdapter(Activity context) : base()&#13;
         {&#13;
             _context = context;&#13;
             _clients = new List&lt;Client&gt;();&#13;
         } &#13;
    } &#13;
</pre><p>Firstly, we are just creating a new class which inherits the <code class="literal">BaseAdapter</code> class which is typecasted to the <code class="literal">Client</code> object. We also have a private <code class="literal">List</code> which is going to store the clients retrieved from the <code class="literal">SignalRClient</code>, and finally we have the current <span class="strong"><strong>Activity Context</strong></span>. Now let's add in the required override functions from the <code class="literal">BaseAdapter:</code></p><pre class="programlisting">public override Client this[int position]&#13;
         {&#13;
             get&#13;
             {&#13;
                 return _clients[position];&#13;
             }&#13;
         }&#13;
         public override Java.Lang.Object GetItem (int position)&#13;
         {&#13;
             return null;&#13;
         }&#13;
 &#13;
         public override long GetItemId(int position)&#13;
         {&#13;
             return position;&#13;
         }&#13;
         public override int Count&#13;
         {&#13;
             get&#13;
              {&#13;
                  return _clients.Count;&#13;
              }&#13;
          }&#13;
 &#13;
         public override View GetView(int position, View convertView, ViewGroup parent)&#13;
         {&#13;
             View view = convertView; // re-use an existing view, if one is available&#13;
             if (view == null)&#13;
             {&#13;
                  // otherwise create a new one&#13;
                 view = _context.LayoutInflater.Inflate(Resource.Layout.CustomCell, null);&#13;
             }&#13;
             // set labels&#13;
             var connectionIdTextView = view.FindViewById&lt;TextView&gt;&#13;
 (Resource.Id.username);&#13;
             connectionIdTextView.Text = _clients[position].Username;&#13;
             return view;&#13;
         }  &#13;
</pre><p>The first override is to implement an index reference to the <code class="literal">_clientslist</code>. All the override functions are the same as we implemented in <a class="link" href="ch01.html" title="Chapter 1.  Building a Gallery Application">Chapter 1</a>, <span class="emphasis"><em>Building a Gallery Application</em></span>. Let's turn our attention to the <code class="literal">GetView</code> function; we are simply creating a new <code class="literal">CustomCell</code> layout using the <code class="literal">LayoutInflater</code> framework (this will take any AXML file and create a new instance of the view).</p><p>Then, now that we have our new view, we will set the <code class="literal">Text</code> property of the <code class="literal">TextView</code>
<span class="strong"><strong> </strong></span>object in the <code class="literal">CustomCell</code> view to the <code class="literal">Username</code> in our <code class="literal">Client</code> object.</p><p>Finally, our last step is to add a another function called <code class="literal">UpdateClients</code> (as specified in our presenter). This will simply take a new <code class="literal">IEnumerable</code> of <span class="strong"><strong>Clients</strong></span>, and the <code class="literal">List</code> will be updated accordingly:</p><pre class="programlisting">public void UpdateClients(IEnumerable&lt;Client&gt; clients)&#13;
         {&#13;
             foreach (var client in clients)&#13;
             {&#13;
                 _clients.Add(client);&#13;
             }&#13;
         }  &#13;
</pre><p>With complete direction from the presenter class, look how fast we developed the android interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip97"/>Tip</h3><p>Before we can test the connection to the server <span class="strong"><strong>Hub</strong></span>, we have to make changes to the application.config and <code class="literal">http.sys</code> using <code class="literal">netsh</code> in the command prompt. Follow the section <span class="emphasis"><em>Hosting the Web API project locally</em></span> in <a class="link" href="ch05.html" title="Chapter 5. Building a Stocklist Application">Chapter 5</a>, <span class="emphasis"><em>Building a Stocklist Application</em></span>.</p></div></div><p>You can try testing the first page. Startup the server <span class="strong"><strong>Hub</strong></span> and watch the list update whenever we connect or disconnect a new client. A good test on this example is to use multiple running instances of the application on different devices.</p></div>
<div class="section" title="Building the ChatPresenter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec94"/>Building the ChatPresenter</h1></div></div></div><p>Now we move on to the next screen; this will be our chat window in which we will be passing messages between different clients connected to the server <span class="strong"><strong>Hub</strong></span>. Our first step is to build the <code class="literal">ChatPresenter</code>:</p><pre class="programlisting">public class ChatPresenter : BasePresenter&#13;
     {&#13;
         #region Private Properties&#13;
         private Client _client;&#13;
         private IChatView _view;&#13;
         #endregion&#13;
         #region IChatView&#13;
         public interface IChatView : IView&#13;
         {&#13;
             void NotifyChatMessageReceived(string message);&#13;
         }&#13;
         #endregion&#13;
     } &#13;
 &#13;
</pre><p>We are going to start by inheriting the <code class="literal">BasePresenter</code> class. It will include two <code class="literal">private</code> properties, one for the <code class="literal">Client</code> selected from the previous <code class="literal">ClientListView</code> screen and another for the <code class="literal">IChatView</code> interface. The <code class="literal">IChatView</code> interface inherits the <code class="literal">IView</code> interface and it will include one function for handling messages received from the receiving <code class="literal">Client</code>.</p><p>Let's implement the following:</p><pre class="programlisting">#region Constructors&#13;
         public ChatPresenter(ApplicationState state, INavigationService navigationService, Client client)&#13;
         {&#13;
             _navigationService = navigationService;&#13;
             _state = state;&#13;
             _client = client;&#13;
         }&#13;
         #endregion&#13;
         #region Public Methods&#13;
         public void SetView(IChatView view)&#13;
         {&#13;
             _view = view;&#13;
             ChatReceived -= HandleChatReceived;&#13;
             ChatReceived += HandleChatReceived;&#13;
         }&#13;
         public async Task SendChat(string message)&#13;
         {&#13;
             await _signalRClient.SendMessageToClient(_client.ConnectedId, message);&#13;
         }&#13;
 &#13;
         #endregion&#13;
         #region Private Methods&#13;
         private void HandleChatReceived(object sender, ChatEventArgs e)&#13;
         {&#13;
             _view.NotifyChatMessageReceived(e.Message);&#13;
         }&#13;
         #endregion &#13;
</pre><p>It is the same set up as the <code class="literal">ClientsListPresenter</code>; our <code class="literal">SetView</code> function will take the native view object and register the events. We also have another function, <code class="literal">SendChat</code> which will invoke the <code class="literal">SendChat</code> function on the <span class="strong"><strong>Hub</strong></span>. Don't forget the <code class="literal">ReleaseView</code> function; this will be exactly the same as the <code class="literal">ClientsListPresenter</code>:</p><pre class="programlisting">public void ReleaseView()&#13;
         {&#13;
             _signalRClient.OnDataReceived -= HandleSignalRDataReceived;&#13;
         } &#13;
</pre><p>Now that we have built all our presenter objects, we need to make a small update to the navigation service implementations to allow navigation for the other screens. Open the Android <code class="literal">NavigationService.cs</code>, and in the <code class="literal">PushPresenter</code> function update the <code class="literal">if</code> statement to the following:</p><pre class="programlisting">if (presenter is LoginPresenter)&#13;
                 {&#13;
                     intent = new Intent(_application.CurrentActivity, typeof(LoginActivity));&#13;
                 }&#13;
                 else if (presenter is ClientsListPresenter)&#13;
                 {&#13;
                     intent = new Intent(_application.CurrentActivity, typeof(ClientsListActivity));&#13;
                 }&#13;
                 else if (presenter is ChatPresenter)&#13;
                 {&#13;
                     intent = new Intent(_application.CurrentActivity, typeof(ChatActivity));&#13;
                 }  &#13;
</pre><p>For the iOS <code class="literal">NavigationService.cs</code>, update the if statement to the following:</p><pre class="programlisting">if (presenter is LoginPresenter)&#13;
             {&#13;
                 var viewController = new LoginViewController(presenter as LoginPresenter);&#13;
                 _navigationController.PushViewController(viewController, true);&#13;
             }&#13;
             else if (presenter is ClientsListPresenter)&#13;
             {&#13;
                 var viewController = new ClientsListViewController(presenter as ClientsListPresenter);&#13;
                 _navigationController.PushViewController(viewController, true);&#13;
             }&#13;
             else if (presenter is ChatPresenter)&#13;
             {&#13;
                 var viewController = new ChatViewController(presenter as ChatPresenter);&#13;
                 _navigationController.PushViewController(viewController, true);&#13;
             } &#13;
</pre></div>
<div class="section" title="Building the iOS ChatView"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec95"/>Building the iOS ChatView</h1></div></div></div><p>Add a new file called <code class="literal">ChatViewController</code> into the <code class="literal">Views</code> project of the <code class="literal">Chat.iOS</code> project and implement the following:</p><pre class="programlisting"> &#13;
public class ChatViewController : UIViewController, ChatPresenter.IChatView {&#13;
         #region Private Properties&#13;
         private ChatPresenter _presenter;&#13;
         private UITextField _chatField;&#13;
         private UIScrollView _scrollView;&#13;
         private int _currentTop = 20;&#13;
         private nfloat _width;&#13;
         #endregion&#13;
  &#13;
         #region Constructors&#13;
         public ChatViewController(ChatPresenter presenter)&#13;
         {&#13;
             _presenter = presenter;&#13;
         }&#13;
         #endregion&#13;
 &#13;
} &#13;
</pre><p>We have multiple <code class="literal">Private</code> properties, one for the presenter, a local <code class="literal">UITextField</code>. We need this UI object to be local, as we need to extract the <code class="literal">Text</code> value to send through the <code class="literal">SignalRClient</code>, and we also need the <code class="literal">UIScrollView</code> to be local so we can change the content size and add in <code class="literal">ChatView</code>
<span class="strong"><strong> </strong></span>objects. The integers are use to record the current top (y-axis + height) of the all chat messages which will display on the screen. Finally, the remaining <code class="literal">nfloat</code> is used for recording the height and width of the screen.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note98"/>Note</h3><p>We will see all these variables used further on through the class functions.</p></div></div><p>Let's now add the <code class="literal">ViewDidLoad</code> function to build the user interface:</p><pre class="programlisting">#region Public Methods&#13;
         public override void ViewDidLoad()&#13;
         {&#13;
             base.ViewDidLoad();&#13;
             Title = "Chat Room";&#13;
             _presenter.SetView(this);&#13;
             View.BackgroundColor = UIColor.White;&#13;
             _width = View.Bounds.Width;&#13;
             var _sendButton = new UIButton(UIButtonType.RoundedRect)&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false&#13;
             };&#13;
             _sendButton.SetTitle("Send", UIControlState.Normal);&#13;
             _sendButton.TouchUpInside += HandleSendButton;&#13;
             _chatField = new UITextField()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 BackgroundColor = UIColor.Clear.FromHex("#DFE4E6"),&#13;
                 Placeholder = "Enter message"&#13;
             };&#13;
             _scrollView = new UIScrollView()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
             };&#13;
             Add(_chatField);&#13;
             Add(_sendButton);&#13;
             Add(_scrollView);&#13;
             var views = new DictionaryViews()&#13;
             {&#13;
                 {"sendButton", _sendButton},&#13;
                 {"chatField", _chatField},&#13;
                 {"scrollView", _scrollView},&#13;
             };&#13;
             this.View.AddConstraints(&#13;
                 NSLayoutConstraint.FromVisualFormat("V:|-68-[chatField(60)]", NSLayoutFormatOptions.DirectionLeftToRight, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("V:|-62-[sendButton(60)]-20-[scrollView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-5-[chatField]-[sendButton(60)]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|[scrollView]|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .ToArray());&#13;
         }  &#13;
         #endregion  &#13;
</pre><p>The chat screen will contain a <code class="literal">UITextField</code>, a <code class="literal">UIButton</code>, and a <code class="literal">UIScrollView</code>. The button is for notifying the current <code class="literal">Text</code> value of the <code class="literal">UITextField</code> to be sent to the server <span class="strong"><strong>Hub</strong></span>, and our <code class="literal">UIScrollView</code> will contain all the messages published from each client.</p><p>We also want to add the <code class="literal">ViewDidUnload()</code> function, so we can remove the <code class="literal">OnDataReceived</code> event on the <code class="literal">SignalRClient</code>:</p><pre class="programlisting">public override void ViewDidUnload()&#13;
         {&#13;
             base.ViewDidUnload();&#13;
             _presenter.ReleaseView();&#13;
         } &#13;
</pre><p>Let's then add the <code class="literal">IView</code>
<span class="strong"><strong> </strong></span>implementation:</p><pre class="programlisting">#region IView implementation&#13;
         public void SetMessage(string message)&#13;
         {&#13;
             var alert = new UIAlertView()&#13;
             {&#13;
                 Title = "Chat",&#13;
                 Message = message&#13;
             };&#13;
             alert.AddButton("OK");&#13;
             alert.Show();&#13;
         }&#13;
         public bool IsInProgress { get; set; } #endregion  &#13;
</pre><p>The <code class="literal">IView</code>
<span class="strong"><strong> </strong></span>implementation is the same as with the <code class="literal">ClientsListViewController</code>.</p><p>Let's create a new file called <code class="literal">ChatBoxView.cs</code> and add it to the <code class="literal">Views</code> folder. We will create a new one of these for every chat message:</p><pre class="programlisting">public class ChatBoxView : UIView&#13;
     {&#13;
         private UILabel messageLabel;&#13;
         public ChatBoxView(string message)&#13;
         {&#13;
             Layer.CornerRadius = 10;&#13;
             messageLabel = new UILabel()&#13;
             {&#13;
                 TranslatesAutoresizingMaskIntoConstraints = false,&#13;
                 Text = message&#13;
             };&#13;
             Add(messageLabel);&#13;
             var views = new DictionaryViews()&#13;
             {&#13;
                 {"messageLabel", messageLabel},&#13;
             };&#13;
             AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|[messageLabel]|", NSLayoutFormatOptions.AlignAllTop, null, views)&#13;
                 .Concat(NSLayoutConstraint.FromVisualFormat("H:|-5-[messageLabel]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views))&#13;
                 .ToArray());&#13;
         }&#13;
     }  &#13;
</pre><p>This is a very simple object that contains one <code class="literal">UILabel</code> for the chat message. We also set the height and width of this label to the height and width of the <code class="literal">UIView</code> using <code class="literal">NSAutoLayout</code>. We also round the corners of the <code class="literal">Layer</code> to <code class="literal">5</code>.</p><p>If you have ever used the <span class="strong"><strong>SMS</strong></span> application on any iOS device, you will see we have two colors, distinguishing between you and the person you are talking to. We are going to do the same with our application but instead of using standard colors from the <code class="literal">UIColor</code> interface, we are going to use custom hex colors.</p></div>
<div class="section" title="Extending the UIColor framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec96"/>Extending the UIColor framework</h1></div></div></div><p>In this section we are going to apply a common technique for extending on standard iOS classes. In the <code class="literal">UIColor</code> class, there is no function for applying hex strings to determine a color, so let's add this on top. Create a new folder called <code class="literal">Extensions</code>, add in a new file called <code class="literal">UIColorExtensions.cs</code>, and implement the following:</p><pre class="programlisting">public static class UIColorExtensions&#13;
     {&#13;
         public static UIColor FromHex(this UIColor color, string hexValue, float alpha = 1.0f)&#13;
         {&#13;
             var colorString = hexValue.Replace("#", "");&#13;
             if (alpha &gt; 1.0f)&#13;
             {&#13;
                 alpha = 1.0f;&#13;
             }&#13;
             else if (alpha &lt; 0.0f)&#13;
             {&#13;
                 alpha = 0.0f;&#13;
             }&#13;
             float red, green, blue;&#13;
             switch (colorString.Length)&#13;
             {&#13;
                 case 3: // #RGB&#13;
                     {&#13;
                         red = Convert.ToInt32(string.Format("{0}{0}",&#13;
                         colorString.Substring(0, 1)), 16) / 255f;&#13;
                         green = Convert.ToInt32(string.Format("{0}{0}",&#13;
                         colorString.Substring(1, 1)), 16) / 255f;&#13;
                         blue = Convert.ToInt32(string.Format("{0}{0}",&#13;
                         colorString.Substring(2, 1)), 16) / 255f;&#13;
                         return UIColor.FromRGBA(red, green, blue, alpha);&#13;
                     }&#13;
                 case 6: // #RRGGBB&#13;
                     {&#13;
                         red = Convert.ToInt32(colorString.Substring(0, 2), 16) / 255f;&#13;
                         green = Convert.ToInt32(colorString.Substring(2, 2), 16) / 255f;&#13;
                         blue = Convert.ToInt32(colorString.Substring(4, 2), 16) / 255f;&#13;
                         return UIColor.FromRGBA(red, green, blue, alpha);&#13;
                     }&#13;
                 default:&#13;
                     throw new ArgumentOutOfRangeException(string.Format("Invalid color value {0} is invalid. It should be a hex value of the form #RBG, #RRGGBB", hexValue));&#13;
             }&#13;
         }&#13;
     }   &#13;
</pre><p>When we extend a class with extra functions, the first input parameter must always start with the <code class="literal">this</code> keyword; this represents the current object calling the function. The next two parameters are a string representing the hex value and an alpha percentage (between 0 and 1) for transparency.</p><p>Firstly, we remove the <code class="literal">#</code> character from the hex string. We then double-check if the alpha character is below 0, if so, set the alpha to 0, and vice versa with the alpha if it is greater than 1. Then our switch statement will select a case based on the hex string length (either an RGB or RRGGBB value). Then we simply extract the red, green, and blue string values and return a new <code class="literal">UIColor</code> from the red, green, and blue values.</p><p>Now we can apply a hex color string to the <code class="literal">UIColor</code> framework like this:</p><pre class="programlisting">UIColor.Clear.FromHex("#FFFFFF"); &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip99"/>Tip</h3><p>Since MonoTouch 5.4, we have to apply the <code class="literal">FromHex</code> extension to a <code class="literal">Color.Clear</code>. Previously we were able to use a parameterless constructor like this: <code class="literal">new UIColor().FromHex("FFFFFF")</code>.</p></div></div><p>Now that we have our <code class="literal">UIColor</code> additions, let's use these for our chatbox <code class="literal">BackgroundColor</code> property. We are going to add in a new function to the <code class="literal">ChatView</code>, which will create a new <code class="literal">ChatBox</code> and set the color according to whether it was sent or received. We will also do the same with the x-axis position and set the <code class="literal">ChatBox</code> to the left if sent and to the right if received:</p><pre class="programlisting">         public void CreateChatBox(bool received, string message)&#13;
         {&#13;
             _scrollView.ContentSize = new CGSize(_width, _currentTop);&#13;
             _scrollView.AddSubview(new ChatBoxView(message)&#13;
             {&#13;
                 Frame = new CGRect(received ? _width - 120 : 20, _currentTop, 100, 60),&#13;
                 BackgroundColor = UIColor.Clear.FromHex(received ? "#4CD964" : "#5AC8FA")&#13;
             });&#13;
             _currentTop += 80;&#13;
         } &#13;
</pre><p>We first update the <code class="literal">ContentSize</code> property of the <code class="literal">UIScrollView</code>; this represents the dimensions of the scroll area. The <code class="literal">currentTop</code> variable is used to record the last ChatBox's y-axis value so we know the height of the UIScrollView's content, and so we know the next y-axis position for the next <code class="literal">ChatBox</code>. Then we add the new <code class="literal">ChatBox</code> object, pass in the new message, and assign the message to the <code class="literal">Title</code> of the <code class="literal">UILabel</code>. We also use our new extension function to set the <code class="literal">BackgroundColor</code> property of the <code class="literal">ChatBox</code>.</p><p>Now, where do we call this function?</p><p>We have two areas, whenever the <code class="literal">Send</code> button is pressed, or when a message is received. Let's add the <code class="literal">TouchUpInside</code> callback on the <code class="literal">_sendButton</code>:</p><pre class="programlisting"> #region Private Properties private void HandleSendButton(object sender, EventArgs e)&#13;
         {&#13;
             _presenter.SendChat(_chatField.Text).ConfigureAwait(false);&#13;
             CreateChatBox(false, _chatField.Text);&#13;
         }&#13;
  #endregion  &#13;
</pre><p>The <code class="literal">HandleSendButton</code> will also call the presenter function, <code class="literal">SendChat</code>, and send the message to the server <span class="strong"><strong>Hub</strong></span>. We also need to add the <code class="literal">IChatView</code> implementation. The <code class="literal">NotifyChatMessageReceived</code> function will also use <code class="literal">CreateChatBox</code>, but this time we will set the <code class="literal">received</code>
<span class="strong"><strong> </strong></span>flag to <code class="literal">true</code>. This must also be invoked on the main thread as sometimes the event might fire this function on another thread:</p><pre class="programlisting">#region IChatView implementation&#13;
         public void NotifyChatMessageReceived(string message)&#13;
         {&#13;
             InvokeOnMainThread(() =&gt; CreateChatBox(true, message));&#13;
         }&#13;
         #endregion  &#13;
</pre><p>Fantastic!</p><p>Now that we have finished the iOS <code class="literal">ChatView</code>, try testing. Connect two iOS clients to the <span class="strong"><strong>Hub</strong></span>, select the other client from either client, try entering messages into the <code class="literal">UITextField</code>, press Send, and watch the magic happen.</p><p>That's enough of iOS development, let's move back over to Android and complete the <code class="literal">ChatView</code>.</p></div>
<div class="section" title="Android TableLayouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec97"/>Android TableLayouts</h1></div></div></div><p>Let's move back to the Android implementation. This part is easy, we have already mapped the UI logic to the <code class="literal">ChatPresenter</code> so let's get straight into building the interface. For our <code class="literal">ChatView.xml</code> file, we are going to introduce a <code class="literal">TableLayout</code>. TableLayouts are similar to <span class="strong"><strong>Grids</strong></span> in <code class="literal">Xamarin.Forms</code>; we simply split an area into rows and columns. We are able to set UI objects to specific rows and columns as well as span specific UI objects across multiple rows and columns.</p><p>Let's add a new file called <code class="literal">ChatView.xml</code> to the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>layout</strong></span> folder and implement the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;&#13;
 &lt;TableLayout &#13;
     android:id="@+id/tableLayout"&#13;
     android:layout_width="fill_parent"&#13;
     android:layout_height="fill_parent"&#13;
     android:background="#FFFFFF"&gt;&#13;
     &lt;TableRow&#13;
         android:id="@+id/tableRow1"&#13;
         android:layout_width="fill_parent"&#13;
         android:layout_height="100dp"&#13;
         android:padding="5dip"&gt;&#13;
         &lt;EditText&#13;
             android:id="@+id/chatField"&#13;
             android:hint="Enter message"&#13;
             android:textColor="#000000"&#13;
             android:layout_weight="2"&#13;
             android:layout_column="1" /&gt;&#13;
         &lt;Button&#13;
             android:id="@+id/sendButton"&#13;
             android:text="Send"&#13;
             android:textColor="#417BB5"&#13;
             android:background="@android:color/transparent"&#13;
             android:focusableInTouchMode="false"&#13;
             android:layout_weight="1"&#13;
             android:layout_column="3" /&gt;&#13;
     &lt;/TableRow&gt;&#13;
     &lt;TableRow&#13;
         android:id="@+id/tableRow2"&#13;
         android:layout_width="fill_parent"&#13;
         android:layout_weight="1"&#13;
         android:padding="5dip"&gt;&#13;
         &lt;ScrollView&#13;
             android:id="@+id/scrollView"&#13;
             android:layout_width="match_parent"&#13;
             android:layout_height="match_parent"&#13;
             android:fillViewport="true"&#13;
             android:layout_weight="2"&#13;
             android:layout_span="4"&gt;&#13;
             &lt;LinearLayout&#13;
                 android:id="@+id/scrollViewInnerLayout"&#13;
                 android:layout_width="match_parent"&#13;
                 android:layout_height="wrap_content"&#13;
                 android:orientation="vertical" /&gt;&#13;
         &lt;/ScrollView&gt;&#13;
     &lt;/TableRow&gt;&#13;
 &lt;/TableLayout&gt; &#13;
</pre><p>Each row is declared using the <code class="literal">&lt;TableRow&gt;</code> tag; our first row contains an <code class="literal">EditText</code> item for the messages, and a button to call the <code class="literal">SendChat</code>
<span class="strong"><strong> </strong></span>function on the <code class="literal">SignalRClient</code>.</p></div>
<div class="section" title="Building the Android ChatActivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec98"/>Building the Android ChatActivity</h1></div></div></div><p>Let's move back to the Android implementation. This part is easy, we have already mapped the UI logic to the <code class="literal">ChatPresenter</code>, so let's get straight into building the interface. Add a new file to the <code class="literal">Views</code> folder in the <code class="literal">Chat.Droid</code> project, call it <code class="literal">ChatActivity.cs</code>, and implement the first part:</p><pre class="programlisting">[Activity(Label = "Chat", ScreenOrientation = ScreenOrientation.Portrait)]&#13;
     public class ChatView : ListActivity, ChatPresenter.IChatView&#13;
     {&#13;
         #region Private Properties&#13;
         private ChatPresenter _presenter;&#13;
         private LinearLayout _scrollViewInnerLayout;&#13;
         private EditText _editText;&#13;
         private long _lastSendClick = 0;&#13;
         private int _width;&#13;
         private float _currentTop;&#13;
         private bool _dialogShown = false;  &#13;
       #endregion  &#13;
         #region Protected Methods&#13;
         protected override void OnCreate(Bundle bundle)&#13;
         {&#13;
             base.OnCreate(bundle);&#13;
             SetContentView(Resource.Layout.ChatView);&#13;
             var metrics = Resources.DisplayMetrics;&#13;
             _width = (int)(( metrics.WidthPixels) /&#13;
             Resources.DisplayMetrics.Density);&#13;
             _scrollViewInnerLayout = FindViewById&lt;LinearLayout&gt;&#13;
             (Resource.Id.scrollViewInnerLayout);&#13;
             _editText = FindViewById&lt;EditText&gt;(Resource.Id.chatField);&#13;
             var sendButton = FindViewById&lt;Button&gt;(Resource.Id.sendButton);&#13;
             sendButton.Touch += HandleSendButton;&#13;
             var app = ChatApplication.GetApplication(this);&#13;
             app.CurrentActivity = this;&#13;
             _presenter = app.Presenter as ChatPresenter;&#13;
             _presenter.SetView(this);&#13;
             app.CurrentActivity = this;&#13;
         }&#13;
         #endregion &#13;
 &#13;
    }  &#13;
</pre><p>In the <code class="literal">OnCreate</code> function, we are setting the content view to the <code class="literal">ChatView</code> layout. We then retrieve the width of the screen as we need to be able position the x-axis of the chat box to the left or right of the screen, based on whether it was sent/received. We then assign the SendButton's <code class="literal">Touch</code> event to call the <code class="literal">HandleSendButton</code> function. Finally, we retrieve the <code class="literal">ChatApplication</code> object and cast the presenter to a <code class="literal">ChatPresenter</code>, call the <code class="literal">SetView</code>  function, and pass the <code class="literal">ChatActivity</code>. Then we set the <code class="literal">CurrentActivity</code> of the <code class="literal">ChatApplication</code> object to the <code class="literal">ChatActivity</code>. Let's also add an override on the <code class="literal">OnPause</code> so we can call <code class="literal">ReleaseView</code> on the <code class="literal">ChatPresenter</code> to remove the <code class="literal">OnDataReceived</code> event from the <code class="literal">SignalRClient</code>. This is the equivalent to the <code class="literal">ViewDidUnload</code> override on a <code class="literal">UIViewController</code>:</p><pre class="programlisting">protected override void OnPause()&#13;
         {&#13;
             base.OnPause();&#13;
             if (_presenter != null)&#13;
             {&#13;
                 _presenter.ReleaseView();&#13;
             }&#13;
         } &#13;
</pre><p>Now we have to add the <code class="literal">IChatView</code> implementation; <code class="literal">CreateChatBox</code> must be propagated to the main thread as this event will sometimes call this function on a different thread:</p><pre class="programlisting">#region IChatView implementation&#13;
         public void NotifyChatMessageReceived(string message)&#13;
         {&#13;
             // perform action on UI thread&#13;
             Application.SynchronizationContext.Post(state =&gt;&#13;
             {&#13;
                 CreateChatBox(true, message);&#13;
             }, null);&#13;
         }&#13;
         #endregion &#13;
</pre><p>Now we have to add the <code class="literal">IView</code> implementation, which we can simply copy from the previous activity:</p><pre class="programlisting">#region IView implementation&#13;
         public void SetErrorMessage(string message)&#13;
         {&#13;
             if (!_dialogShown)&#13;
             {&#13;
                 _dialogShown = true;&#13;
                 AlertDialog.Builder builder = new AlertDialog.Builder(this);&#13;
                 builder&#13;
                     .SetTitle("Chat")&#13;
                     .SetMessage(message)&#13;
                     .SetNeutralButton("Ok", (sender, e) =&gt; { _dialogShown = false; })&#13;
                     .Show();&#13;
             }&#13;
         }&#13;
         public bool IsInProgress { get; set; }&#13;
         #endregion  &#13;
</pre><p>Before we add the remaining functions, we are going to add another layout for the <code class="literal">ChatBoxView</code> in Android. Add a new file called <code class="literal">ChatBoxView.xml</code>, add it to the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>layout</strong></span> folder, and implement the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;&#13;
 &lt;LinearLayout&#13;
 &#13;
     android:orientation="horizontal"&#13;
     android:layout_width="match_parent"&#13;
     android:layout_height="match_parent"&#13;
     android:weightSum="4"&gt;&#13;
     &lt;TextView&#13;
         android:id="@+id/messageTextView"&#13;
         android:layout_width="wrap_content"&#13;
         android:layout_height="wrap_content"&#13;
         android:layout_weight="1" /&gt;&#13;
 &lt;/LinearLayout&gt;  &#13;
</pre><p>This is a very simple view which contains a <code class="literal">LinearLayout</code> that contains one <code class="literal">TextView</code> to display the chat message.</p><p>Finally, we add the remaining <code class="literal">HandleSendButton</code> and <code class="literal">CreateChatBox</code> functions; they are the same functions as iOS, but use Android objects:</p><pre class="programlisting">#region Private Methods&#13;
         private void HandleSendButton(object sender, View.TouchEventArgs e)&#13;
         { &#13;
            // multiple-clicking prevention using a threshold of 1000 ms&#13;
             if (SystemClock.ElapsedRealtime() - _lastSendClick &lt; 1000)&#13;
             {&#13;
                 return;&#13;
             }&#13;
             _lastSendClick = SystemClock.ElapsedRealtime();&#13;
             _presenter.SendChat(_editText.Text).ConfigureAwait(false);&#13;
             CreateChatBox(false, _editText.Text);&#13;
         }&#13;
         #endregion&#13;
         #region Public Methods&#13;
         public void CreateChatBox(bool received, string message)&#13;
         {&#13;
             var view = LayoutInflater.Inflate(Resource.Layout.ChatBoxView, null);&#13;
             view.SetX(received ? _width : 0);&#13;
             view.SetY(_currentTop);&#13;
             var messageTextView = view.FindViewById&lt;TextView&gt;&#13;
             (Resource.Id.messageTextView);&#13;
             messageTextView.Text = message;&#13;
             var color = Color.ParseColor(received ? "#4CD964" : "#5AC8FA");&#13;
             messageTextView.SetBackgroundColor(color);&#13;
             _scrollViewInnerLayout.AddView(view);&#13;
             _currentTop += 60;&#13;
         }&#13;
         #endregion  &#13;
</pre><p>The <code class="literal">HandleSendButton</code> function will do the exact same: call the presenter function, <code class="literal">SendChat</code>, create a new chatbox, and add it to the <code class="literal">ScrollView</code>. The <code class="literal">CreateChatBox</code> function will use the context's <code class="literal">LayoutInflator</code> and create a new <code class="literal">ChatBoxView</code>. We will then set the x, y, width and height properties, retrieve the <code class="literal">TextView</code> property of the view, and set the <code class="literal">Text</code> property to the message. We then call <code class="literal">SetBackgroundColor</code> on the view and change the background color according to whether it has been sent or received. Finally, we add the new view to the <code class="literal">ScrollView</code> and record the current y-axis value.</p></div>
<div class="section" title="Running the server and clients"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec99"/>Running the server and clients</h1></div></div></div><p>Before we can test everything together, please revisit the section in <a class="link" href="ch05.html" title="Chapter 5. Building a Stocklist Application">Chapter 5</a>, <span class="emphasis"><em>Building a Stocklist Application</em></span>, called<span class="strong"><strong> Hosting a Web API project locally</strong></span>. This must be done before we can connect to the server side from our mobile clients. Once we have the server application running, build and run the mobile application from either platform and register a user first before we login. The <code class="literal">Register</code> button will place the new account in the <code class="literal">UserManager</code>, allowing us to perform a <span class="strong"><strong>Login</strong></span> with those account details as they now exist in the <code class="literal">UserManager</code>. Once we login, we can't do anymore unless we have another mobile client that can run the app and login. It is best to test this application with two mobile devices running the mobile application. Once both have logged in and the clients list screen has been loaded, each user will be connected to the user, and both users can now click on each other to navigate to the chat window and begin sending messages to each other.</p><p>To further understand everything going on, try adding debug breakpoints to server functions, and test these server functions by clicking between the different screens of the mobile application. This will give a better overview as to what is happening between server and client on each screen.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec100"/>Summary</h1></div></div></div><p>In this chapter, we created an application for iOS and Android using the native libraries. We integrated SignalR on the client and server side by building a hub and proxy connections via a client. In the next chapter, we will see how to store files locally with <code class="literal">Xamarin.Forms</code> using dependency services. You will learn about shared projects and their differences to PCL projects. We will also run through SQLite, setting it up with Android, iOS, and WinPhone and share the same code using different platform-specific libraries.</p></div></body></html>