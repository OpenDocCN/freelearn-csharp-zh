<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-151"><a id="_idTextAnchor166"/>4. Data Structures and LINQ</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will learn about the main collections and their primary usage in C#. You will then see how Language-Integrated Query (LINQ) can be used to query collections in memory using code that is efficient and succinct. By the end of this chapter, you will be well versed in using LINQ for operations such as sorting, filtering, and aggregating data.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor167"/>Introduction</h1>
<p>Throughout the previous chapters, you have used variables that refer to a single value, such as the <code>string</code> and <code>double</code> system types, system <code>class</code> instances, and your own class instances. .NET has a variety of data structures that can be used to store multiple values. These structures are generally referred to as collections. This chapter builds on this concept by introducing collection types from the <code>System.Collections.Generic</code> namespace.</p>
<p>You can create variables that can store multiple object references using collection types. Such collections include lists that resize to accommodate the number of elements and dictionaries that offer access to the elements using a unique key as an identifier. For example, you may need to store a list of international dialing codes using the codes as unique identifiers. In this case, you need to be certain that the same dialing code is not added to the collection twice.</p>
<p>These collections are instantiated like any other classes and are used extensively in most applications. Choosing the correct type of collection depends primarily on how you intend to add items and the way you would like to access such items once they are in a collection. The commonly used collection types include <code>List</code>, <code>Set</code>, and <code>HashSet</code>, which you will cover in detail shortly.</p>
<p>LINQ is a technology that offers an expressive and concise syntax for querying objects. Much of the complexities around filtering, sorting, and grouping objects can be removed using the SQL-like language, or if you prefer, a set of extension methods that can be chained together to produce collections that can be enumerated with ease.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor168"/>Data Structures</h1>
<p>.NET provides various types of in-built data structures, such as the <code>Array</code>, <code>List</code>, and <code>Dictionary</code> types. At the heart of all data structures are the <code>IEnumerable</code> and <code>ICollection</code> interfaces. Classes that implement these interfaces offer a way to enumerate through the individual elements and to manipulate their items. There is rarely a need to create your own classes that derive directly from these interfaces, as all the required functionality is covered by the built-in collection types, but it is worth knowing the key properties as they are heavily used throughout .NET.</p>
<p>The generic version of each collection type requires a single type parameter, which defines the type of elements that can be added to a collection, using the standard <code>&lt;T&gt;</code> syntax of the generic types.</p>
<p>The <code>IEnumerable</code> interface has a single property, that is, <code>IEnumerator&lt;T&gt; GetEnumerator()</code>. This property returns a type that provides methods that allow the caller to iterate through the elements in the collection. You do not need to call the <code>GetEnumerator()</code> method directly, as the compiler will call it whenever you use a <code>foreach</code> statement, such as <code>foreach(var book in books)</code>. You will learn more about using this in the upcoming sections.</p>
<p>The <code>ICollection</code> interface has the following properties:</p>
<ul>
<li><code>int Count { get; }</code>: Returns the number of items in the collection.</li>
<li><code>bool IsReadOnly { get; }</code>: Indicates if the collection is read-only. Certain collections can be marked as read-only to prevent callers from adding, deleting, or moving elements in the collection. C# will not prevent you from amending the properties of individual items in a read-only collection.</li>
<li><code>void Add(T item)</code>: Adds an item of type <code>&lt;T&gt;</code> to the collection.</li>
<li><code>void Clear()</code>: Removes all items from the collection.</li>
<li><code>bool Contains(T item)</code>: Returns <code>true</code> if the collection contains a certain value. Depending on the type of item in the collection, this can be value-equality, where an object is similarly based on its members, or reference-equality, where the object points to the same memory location.</li>
<li><code>void CopyTo(T[] array, int arrayIndex)</code>: Copies each element from the collection into the target array, starting with the first element at a specified index position. This can be useful if you need to skip a specific number of elements from the beginning of the collection.</li>
<li><code>bool Remove(T item)</code>: Removes the specified item from the collection. If there are multiple occurrences of the instance, then only the first instance is removed. This returns <code>true</code> if an item was successfully removed.</li>
</ul>
<p><code>IEnumerable</code> and <code>ICollection</code> are interfaces that all collections implement:</p>
<p> </p>
<div><div><img alt="Figure 4.1: ICollection and IEnumerable class diagram " height="802" src="img/B16835_04_01.jpg" width="750"/>
</div>
</div>
<p class="figure-caption">Figure 4.1: ICollection and IEnumerable class diagram</p>
<p>There are further interfaces that some collections implement, depending on how elements are accessed within a collection.</p>
<p>The <code>IList</code> interface is used for collections that can be accessed by index position, starting from zero. So, for a list that contains two items, <code>Red</code> and <code>Blue</code>, the element at index zero is <code>Red</code> and the element at index one is <code>Blue</code>.</p>
<div><div><img alt="Figure 4.2: IList class diagram " height="598" src="img/B16835_04_02.jpg" width="725"/>
</div>
</div>
<p class="figure-caption">Figure 4.2: IList class diagram</p>
<p>The <code>IList</code> interface has the following properties:</p>
<ul>
<li><code>T this[int index] { get; set; }</code>: Gets or sets the element at the specified index position.</li>
<li><code>int Add(T item)</code>: Adds the specified item and returns the index position of that item in the list.</li>
<li><code>void Clear()</code>: Removes all items from the list.</li>
<li><code>bool Contains(T item)</code>: Returns <code>true</code> if the list contains the specified item.</li>
<li><code>int IndexOf(T item)</code>: Returns the index position of the item, or <code>-1</code> if not found.</li>
<li><code>void Insert(int index, T item)</code>: Inserts the item at the index position specified.</li>
<li><code>void Remove(T item)</code>: Removes the item if it exists within the list.</li>
<li><code>void RemoveAt(int index)</code>: Removes the item at the specified index position.</li>
</ul>
<p>You have now seen the primary interfaces common to collections. So, now you will now take a look at the main collection types that are available and how they are used.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor169"/>Lists</h2>
<p>The <code>List&lt;T&gt;</code> type is one of the most extensively used collections in C#. It is used where you have a collection of items and want to control the order of items using their index position. It implements the <code>IList</code> interface, which allows items to be inserted, accessed, or removed using an index position:</p>
<div><div><img alt="Figure 4.3: List class diagram " height="761" src="img/B16835_04_03.jpg" width="806"/>
</div>
</div>
<p class="figure-caption">Figure 4.3: List class diagram</p>
<p>Lists have the following behavior:</p>
<ul>
<li>Items can be inserted at any position within the collection. Any trailing items will have their index position incremented.</li>
<li>Items can be removed, either by index or value. This will also cause trailing items to have their index position updated.</li>
<li>Items can be set using their index value.</li>
<li>Items can be added to the end of the collection.</li>
<li>Items can be duplicated within the collection.</li>
<li>The position of items can be sorted using the various <code>Sort</code> methods.</li>
</ul>
<p>One example of a list might be the tabs in a web browser application. Typically, a user may want to drag a browser tab amongst other tabs, open new tabs at the end, or close tabs anywhere in a list of tabs. The code to control these actions can be implemented using <code>List</code>.</p>
<p>Internally, <code>List</code> maintains an array to store its objects. This can be efficient when adding items to the end, but it may be inefficient when inserting items, particularly near the beginning of the list, as the index position of items will need to be recalculated.</p>
<p>The following example shows how the generic <code>List</code> class is used. The code uses the <code>List&lt;string&gt;</code> type parameter, which allows <code>string</code> types to be added to the list. Attempts to add any other type will result in a compiler error. This will show the various commonly used methods of the <code>List</code> class.</p>
<ol>
<li>Create a new folder called <code>Chapter04</code> in your source code folder.</li>
<li>Change to the <code>Chapter04</code> folder and create a new console app, called <code>Chapter04</code>, using the following .NET command:<pre>source\Chapter04&gt;dotnet new console -o Chapter04
The template "Console Application" was created successfully.</pre></li>
<li>Delete the <code>Class1.cs</code> file.</li>
<li>Add a new folder called <code>Examples</code>.</li>
<li>Add a new class file called <code>ListExamples.cs</code>.</li>
<li>Add the <code>System.Collections.Generic</code> namespace to access the <code>List&lt;T&gt;</code> class and declare a new variable called <code>colors</code>:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Examples
{
    class ListExamples
    {     
        public static void Main()
        {
            var colors = new List&lt;string&gt; {"red", "green"};
            colors.Add("orange");</pre></li>
</ol>
<p>The code declares the new <code>colors</code> variable, which can store multiple color names as <code>strings</code>. Here, the collection initialization syntax is used so that <code>red</code> and <code>green</code> are added as part of the initialization of the variable. The <code>Add</code> method is called, adding <code>orange</code> to the list.</p>
<ol>
<li value="7">Similarly, <code>AddRange</code> adds <code>yellow</code> and <code>pink</code> to the end of the list:<pre>            colors.AddRange(new [] {"yellow", "pink"});</pre></li>
<li>At this point, there are five colors in the list, with <code>red</code> at index position <code>0</code> and <code>green</code> at position <code>1</code>. You can verify this using the following code:<pre>            Console.WriteLine($"Colors has {colors.Count} items");
            Console.WriteLine($"Item at index 1 is {colors[1]}");</pre></li>
</ol>
<p>Running the code produces the following output:</p>
<pre>Colors has 5 items
Item at index 1 is green</pre>
<ol>
<li value="9">Using <code>Insert</code>, <code>blue</code> can be inserted at the beginning of the list, that is, at index <code>0</code>, as shown in the following code. Note that this moves <code>red</code> from index <code>0</code> to <code>1</code> and all other colors will have their index incremented by one:<pre>            Console.WriteLine("Inserting blue at 0");
            colors.Insert(0, "blue");
            Console.WriteLine($"Item at index 1 is now {colors[1]}");</pre></li>
</ol>
<p>You should see the following output on running this code:</p>
<pre>Inserting blue at 0
Item at index 1 is now red</pre>
<ol>
<li value="10">Using <code>foreach</code> you can iterate through the strings in the list, writing each string to the console, as follows:<pre>            Console.WriteLine("foreach");
            foreach (var color in colors)
                Console.Write($"{color}|");
            Console.WriteLine();</pre></li>
</ol>
<p>You should get the following output:</p>
<pre>foreach
blue|red|green|orange|yellow|pink|</pre>
<ol>
<li value="11">Now, add the following code to reverse the array. Here, each <code>color</code> string is converted into an array of <code>char</code> type using <code>ToCharArray</code>:<pre>            Console.WriteLine("ForEach Action:");
            colors.ForEach(color =&gt;
            {
                var characters = color.ToCharArray();
                Array.Reverse(characters);
                var reversed = new string(characters);
                Console.Write($"{reversed}|");
            });
            Console.WriteLine();</pre></li>
</ol>
<p>This does not affect any of the values in the <code>colors</code> List, as <code>characters</code> refers to a different object. Note that <code>foreach</code> iterates through each string, whereas <code>ForEach</code> defines an Action delegate to be invoked using each string (recall that in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, you saw how lambda statements can be used to create <code>Action</code> delegates).</p>
<ol>
<li value="12">Running the code leads to this output:<pre>ForEach Action:
eulb|der|neerg|egnaro|wolley|knip|</pre></li>
<li>In the next snippet, the <code>List</code> constructor accepts a source collection. This creates a new list containing a copy of the <code>colors</code> strings in this case, which is sorted using the default <code>Sort</code> implementation:<pre>            var backupColors = new List&lt;string&gt;(colors);
            backupColors.Sort();</pre></li>
</ol>
<p>The string type uses value-type semantics, which means that the <code>backupColors</code> list is populated with a <strong class="bold">copy</strong> of each source string value. Updating a string in one list will <strong class="bold">not</strong> affect the other list. Conversely, classes are defined as reference-types so passing a list of class instances to the constructor will still create a new list, with independent element indexes, but each element will point to the same shared reference in memory rather than an independent copy.</p>
<ol>
<li value="14">In the following snippet, prior to removing all colors (using <code>colors.Clear</code>), each value is written to the console (the list will be repopulated shortly):<pre>            Console.WriteLine("Foreach before clearing:");
            foreach (var color in colors)
                Console.Write($"{color}|");
            Console.WriteLine();
            colors.Clear();
            Console.WriteLine($"Colors has {colors.Count} items");</pre></li>
</ol>
<p>Running the code produces this output:</p>
<pre>Foreach before clearing:
blue|red|green|orange|yellow|pink|
Colors has 0 items</pre>
<ol>
<li value="15">Then, <code>AddRange</code> is used again, to add the full list of colors back to the <code>colors</code> list, using the sorted <code>backupColors</code> items as a source:<pre>            colors.AddRange(backupColors);
            Console.WriteLine("foreach after addrange (sorted items):");
            foreach (var color in colors)
                Console.Write($"{color}|");
            Console.WriteLine();</pre></li>
</ol>
<p>You should see the following output:</p>
<pre>foreach after addrange (sorted items):
blue|green|orange|pink|red|yellow|</pre>
<ol>
<li value="16">The <code>ConvertAll</code> method is passed a delegate that can be used to return a new list of any type:<pre>            var indexes = colors.ConvertAll(color =&gt;                      $"{color} is at index {colors.IndexOf(color)}");
            Console.WriteLine("ConvertAll:");
            Console.WriteLine(string.Join(Environment.NewLine, indexes));</pre></li>
</ol>
<p>Here, a new <code>List&lt;string&gt;</code> is returned with each item being formatted using its value and the item's index in the list. As expected, running the code produces this output:</p>
<pre>ConvertAll:
blue is at index 0
green is at index 1
orange is at index 2
pink is at index 3
red is at index 4
yellow is at index 5</pre>
<ol>
<li value="17">In the next snippet, two <code>Contains()</code> methods are used to show string value-equality in action:<pre>            Console.WriteLine($"Contains RED: {colors.Contains("RED")}");
            Console.WriteLine($"Contains red: {colors.Contains("red")}");</pre></li>
</ol>
<p>Note that the uppercase <code>RED</code> is <code>red</code> will be. Running the code produces this output:</p>
<pre>Contains RED: False
Contains red: True</pre>
<ol>
<li value="18">Now, add the following snippet: <pre>            var existsInk = colors.Exists(color =&gt; color.EndsWith("ink"));
            Console.WriteLine($"Exists *ink: {existsInk}");</pre></li>
</ol>
<p>Here, the <code>Exists</code> method is passed a Predicate delegate, which returns <code>True</code> or <code>False</code> if the test condition is met. Predicate is an inbuilt delegate, which returns a boolean value. In this case, <code>True</code> will be returned if any item exists where the string value ends with the letters <code>ink</code> (<code>pink</code>, for example).</p>
<p>You should see the following output:</p>
<pre>Exists *ink: True</pre>
<ol>
<li value="19">You know there is already a <code>red</code> color, but it will be interesting to see what happens if you insert <code>red</code> again, twice, at the very beginning of the list:<pre>            Console.WriteLine("Inserting reds");
            colors.InsertRange(0, new [] {"red", "red"});
            foreach (var color in colors)
                Console.Write($"{color}|");
            Console.WriteLine();</pre></li>
</ol>
<p>You will get the following output:</p>
<pre>Inserting reds
red|red|blue|green|orange|pink|red|yellow|</pre>
<p>This shows that it is possible to insert the same item more than once into a list.</p>
<ol>
<li value="20">The next snippet shows you how to use the <code>FindAll</code> method. <code>FindAll</code> is similar to the <code>Exists</code> method, in that it is passed a <code>Predicate</code> condition. All items that match that rule will be returned. Add the following code:<pre>            var allReds = colors.FindAll(color =&gt; color == "red");
            Console.WriteLine($"Found {allReds.Count} red");</pre></li>
</ol>
<p>You should get an output as follows. As expected, there are three <code>red</code> items returned:</p>
<pre>Found 3 red</pre>
<ol>
<li value="21">Finishing the example, the <code>Remove</code> method is used to remove the first <code>red</code> from the list. There are still two <code>FindLastIndex</code> to get the index of the last <code>red</code> item:<pre>            colors.Remove("red");
            var lastRedIndex = colors.FindLastIndex(color =&gt; color == "red");
            Console.WriteLine($"Last red found at index {lastRedIndex}");
            Console.ReadLine();
        }
    }
}</pre></li>
</ol>
<p>Running the code produces this output:</p>
<pre>Last red found at index 5</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/dLbK6">https://packt.link/dLbK6</a>.</p>
<p>With the knowledge of how the generic <code>List</code> class is used, it is time for you to work on an exercise.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor170"/>Exercise 4.01: Maintaining Order within a List</h2>
<p>At the beginning of the chapter, web browser tabs were described as an ideal example of lists. In this exercise, you will put this idea into action, and create a class that controls the navigation of the tabs within an app that mimics a web browser.</p>
<p>For this, you will create a <code>Tab</code> class and a <code>TabController</code> app that allows new tabs to be opened and existing tabs to be closed or moved. The following steps will help you complete this exercise:</p>
<ol>
<li value="1">In VSCode, select your <code>Chapter04</code> project.</li>
<li>Add a new folder called <code>Exercises</code>.</li>
<li>Inside the <code>Exercises</code> folder, add a folder called <code>Exercise01</code> and add a file called <code>Exercise01.cs</code>.</li>
<li>Open <code>Exercise01.cs</code> and define a <code>Tab</code> class with a string URL constructor parameter as follows:<pre>using System;
using System.Collections;
using System.Collections.Generic;
namespace Chapter04.Exercises.Exercise01
{
    public class Tab 
    {
        public Tab()
        {}
        public Tab(string url) =&gt; (Url) = (url);
        public string Url { get; set; }
        public override string ToString() =&gt; Url;
    }   </pre></li>
</ol>
<p>Here, the <code>ToString</code> method has been overridden to return the current URL to help when logging details to the console.</p>
<ol>
<li value="5">Create the <code>TabController</code> class as follows:<pre>    public class TabController : IEnumerable&lt;Tab&gt;
    {
        private readonly List&lt;Tab&gt; _tabs = new();</pre></li>
</ol>
<p>The <code>TabController</code> class contains a List of tabs. Notice how the class inherits from the <code>IEnumerable</code> interface. This interface is used so that the class provides a way to iterate through its items, using a <code>foreach</code> statement. You will provide methods to open, move, and close tabs, which will directly control the order of items in the <code>_tabs</code> list, in the next steps. Note that you could have exposed the <code>_tabs</code> list directly to callers, but it would be preferable to limit access to the tabs through your own methods. Hence, it is defined as a <code>readonly</code> list.</p>
<ol>
<li value="6">Next, define the <code>OpenNew</code> method, which adds a new tab to the end of the list:<pre>        public Tab OpenNew(string url)
        {
            var tab = new Tab(url);
            _tabs.Add(tab);
            Console.WriteLine($"OpenNew {tab}");
            return tab;
        }</pre></li>
<li>Define another method, <code>Close</code>, which removes the tab from the list if it exists. Add the following code for this:<pre>        public void Close(Tab tab)
        {
            if (_tabs.Remove(tab))
            {
                Console.WriteLine($"Removed {tab}");
            }
        }</pre></li>
<li>To move a tab to the start of the list, add the following code:<pre>        public void MoveToStart(Tab tab)
        {
            if (_tabs.Remove(tab))
            {
                _tabs.Insert(0, tab);
                Console.WriteLine($"Moved {tab} to start");
            }</pre></li>
</ol>
<p>Here, <code>MoveToStart</code> will try to remove the tab and then insert it at index <code>0</code>.</p>
<ol>
<li value="9">Similarly, add the following code to move a tab to the end:<pre>        public void MoveToEnd(Tab tab)
        {
            if (_tabs.Remove(tab))
            {
                _tabs.Add(tab);
                Console.WriteLine($"Moved {tab} to end. Index={_tabs.IndexOf(tab)}");
            }
        }</pre></li>
</ol>
<p>Here, calling <code>MoveToEnd</code> removes the tab first, and then adds it to the end, logging the new index position to the console.</p>
<p>Finally, the <code>IEnumerable</code> interface requires that you implement two methods, <code>IEnumerator&lt;Tab&gt; GetEnumerator()</code> and <code>IEnumerable.GetEnumerator()</code>. These allow the caller to iterate through a collection using either a generic of type <code>Tab</code> or using the second method to iterate via an object-based type. The second method is a throwback to earlier versions of C# but is needed for compatibility. </p>
<ol>
<li value="10">For the actual results for both methods, you can use the <code>GetEnumerator</code> method of the <code>_tab</code> list, as that contains the tabs in list form. Add the following code to do so:<pre>        public IEnumerator&lt;Tab&gt; GetEnumerator() =&gt; _tabs.GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() =&gt; _tabs.GetEnumerator();
    }</pre></li>
<li>You can now create a console app that tests the controller's behavior. Start by opening three new tabs and logging the tab details via <code>LogTabs</code> (this will be defined shortly):<pre>    static class Program
    {
        public static void Main()
        {
            var controller = new TabController();
            Console.WriteLine("Opening tabs...");
            var packt = controller.OpenNew("packtpub.com");
            var msoft = controller.OpenNew("microsoft.com");
            var amazon = controller.OpenNew("amazon.com");
            controller.LogTabs();</pre></li>
<li>Now, move <code>amazon</code> to the start and <code>packt</code> to the end, and log the tab details:<pre>            Console.WriteLine("Moving...");
            controller.MoveToStart(amazon);
            controller.MoveToEnd(packt);
            controller.LogTabs();</pre></li>
<li>Close the <code>msoft</code> tab and log details once more:<pre>            Console.WriteLine("Closing tab...");
            controller.Close(msoft);
            controller.LogTabs();
            Console.ReadLine();
        }</pre></li>
<li>Finally, add an extension method that helps log the URL of each tab in <code>TabController</code>. Define this as an extension method for <code>IEnumerable&lt;Tab&gt;</code>, rather than <code>TabController</code>, as you simply need an iterator to iterate through the tabs using a <code>foreach</code> loop. </li>
<li>Use <code>PadRight</code> to left-align each URL, as follows:<pre>        private static void LogTabs(this IEnumerable&lt;Tab&gt; tabs)
        {
            Console.Write("TABS: |");
            foreach(var tab in tabs)
                Console.Write($"{tab.Url.PadRight(15)}|");
            Console.WriteLine();
        }    
   } 
}</pre></li>
<li>Running the code produces the following output:<pre>Opening tabs...
OpenNew packtpub.com
OpenNew microsoft.com
OpenNew amazon.com
TABS: |packtpub.com   |microsoft.com  |amazon.com     |
Moving...
Moved amazon.com to start
Moved packtpub.com to end. Index=2
TABS: |amazon.com     |microsoft.com  |packtpub.com   |
Closing tab...
Removed microsoft.com
TABS: |amazon.com     |packtpub.com   |</pre><p class="callout-heading">Note</p><p class="callout">Sometimes Visual Studio might report a non-nullable property error the first time you execute the program. This is a helpful reminder that you are attempting to use a string value that may have a null value at runtime.</p></li>
</ol>
<p>The three tabs are opened. <code>amazon.com</code> and <code>packtpub.com</code> are then moved before <code>microsoft.com</code> is finally closed and removed from the tab list.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/iUcIs">https://packt.link/iUcIs</a>.</p>
<p>In this exercise, you have seen how lists can be used to store multiple items of the same type while maintaining the order of items. The next section covers the <code>Queue</code> and <code>Stack</code> classes, which allow items to be added and removed in a predefined sequence.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor171"/>Queues</h2>
<p>The Queue class provides a first-in, first-out mechanism. Items are added to the end of the queue using the <code>Enqueue</code> method and are removed from the front of the queue using the <code>Dequeue</code> method. Items in the queue cannot be accessed via an index element.</p>
<p>Queues are typically used when you need a workflow that ensures items are processed in the order in which they are added to the queue. A typical example might be a busy online ticketing system selling a limited number of concert tickets to customers. To ensure fairness, customers are added to a queuing system as soon as they log on. The system would then dequeue each customer and process each order, in full, either until all tickets have been sold or the customer queue is empty.</p>
<p>The following example creates a queue containing five <code>CustomerOrder</code> records. When it is time to process the orders, each order is dequeued using the <code>TryDequeue</code> method, which will return <code>true</code> until all orders have been processed. The customer orders are processed in the order that they were added. If the number of tickets requested is more than or equal to the tickets remaining, then the customer is shown a success message. An apology message is shown if the number of tickets remaining is less than the requested amount.</p>
<div><div><img alt="Figure 4.4: The Queue's Enqueue() and Dequeue() workflow " height="1051" src="img/B16835_04_04.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.4: The Queue's Enqueue() and Dequeue() workflow</p>
<p>Perform the following steps to complete this example:</p>
<ol>
<li value="1">In the <code>Examples</code> folder of your <code>Chapter04</code> source folder, add a new class called <code>QueueExamples.cs</code> and edit it as follows:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Examples
{
    class QueueExamples
    {      
        record CustomerOrder (string Name, int TicketsRequested)
        {}
        public static void Main()
        {
            var ticketsAvailable = 10;
            var customers = new Queue&lt;CustomerOrder&gt;();</pre></li>
<li>Add five orders to the queue using the <code>Enqueue</code> method as follows:<pre>            customers.Enqueue(new CustomerOrder("Dave", 2));
            customers.Enqueue(new CustomerOrder("Siva", 4));
            customers.Enqueue(new CustomerOrder("Julien", 3));
            customers.Enqueue(new CustomerOrder("Kane", 2));
            customers.Enqueue(new CustomerOrder("Ann", 1));</pre></li>
<li>Now, use a <code>while</code> loop that repeats until <code>TryDequeue</code> returns <code>false</code>, meaning all current orders have been processed:<pre>            // Start processing orders...
            while(customers.TryDequeue(out CustomerOrder nextOrder))
            {
                if (nextOrder.TicketsRequested &lt;= ticketsAvailable)
                {
                    ticketsAvailable -= nextOrder.TicketsRequested;   
                    Console.WriteLine($"Congratulations {nextOrder.Name}, you've purchased {nextOrder.TicketsRequested} ticket(s)");
                }
                else
                {
                    Console.WriteLine($"Sorry {nextOrder.Name}, cannot fulfil {nextOrder.TicketsRequested} ticket(s)");
                }
            }
            Console.WriteLine($"Finished. Available={ticketsAvailable}");
            Console.ReadLine();
        }
    }
}</pre></li>
<li>Running the example code produces the following output:<pre>Congratulations Dave, you've purchased 2 ticket(s)
Congratulations Siva, you've purchased 4 ticket(s)
Congratulations Julien, you've purchased 3 ticket(s)
Sorry Kane, cannot fulfil 2 ticket(s)
Congratulations Ann, you've purchased 1 ticket(s)
Finished. Available=0</pre><p class="callout-heading">Note</p><p class="callout">The first time you run this program, Visual Studio might show a non-nullable type error. This error is a reminder that you are using a variable that could be a null value.</p></li>
</ol>
<p>The output shows that <code>Dave</code> requested two tickets. As there are two or more tickets available, he was successful. Both <code>Siva</code> and <code>Julien</code> were also successful, but by the time <code>Kane</code> placed his order of two tickets, there was only one ticket available, so he was shown the apology message. Finally, <code>Ann</code> requested one ticket and was successful in her order.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/Zb524">https://packt.link/Zb524</a>.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor172"/>Stacks</h2>
<p>The <code>Stack</code> class provides the opposite mechanism to the <code>Queue</code> class; items are processed in last-in, first-out order. As with the <code>Queue</code> class, you cannot access elements via their index position. Items are added to the stack using the <code>Push</code> method and removed using the <code>Pop</code> method.</p>
<p>An application's <code>Undo</code> menu can be implemented using a stack. For example, in a word processor, as the user edits a document, an <code>Action</code> delegate is created, which can reverse the most recent change whenever the user presses <code>Ctrl</code> + <code>Z</code>. The most recent action is popped off the stack and the change is undone. This allows multiple steps to be undone.</p>
<div><div><img alt="Figure 4.5: The Stack's Push() and Pop() workflow " height="796" src="img/B16835_04_05.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.5: The Stack's Push() and Pop() workflow</p>
<p>The following example shows this in practice.</p>
<p>You will start by creating an <code>UndoStack</code> class that supports multiple undo operations. The caller decides what action should run each time the <code>Undo</code> request is called.</p>
<p>A typical undoable operation would be storing a copy of text prior to the user adding a word. Another undoable operation would be storing a copy of the current font prior to a new font being applied. You can start by adding the following code, where you are creating the <code>UndoStack</code> class and defining a <code>readonly Stack of Action</code> delegates, named <code>_undoStack</code>:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new class called <code>StackExamples.cs</code> and edit it as follows:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Examples
{
    class UndoStack
    {
        private readonly Stack&lt;Action&gt; _undoStack = new Stack&lt;Action&gt;();</pre></li>
<li>When the user has done something, the same action can be undone. So push an <code>Action</code> to the front of <code>_undoStack</code>:<pre>        public void Do(Action action)
        {
            _undoStack.Push(action);
        }</pre></li>
<li>The <code>Undo</code> method checks to see if there are any items to undo, then calls <code>Pop</code> to remove the most recent <code>Action</code> and invoke it, thus undoing the change that was just applied. The code for this can be added as follows:<pre>        public void Undo()
        {
            if (_undoStack.Count &gt; 0)
            {
                var undo = _undoStack.Pop();
                undo?.Invoke();
            }
        }
    }</pre></li>
<li>Now, you can create a <code>TextEditor</code> class that allows edits to be added to <code>UndoStack</code>. This constructor is passed <code>UndoStack</code> as there could be multiple editors that need to add various <code>Action</code> delegates to the stack:<pre>    class TextEditor
    {
        private readonly UndoStack _undoStack;
        public TextEditor(UndoStack undoStack)
        {
            _undoStack = undoStack;
        }
        public string Text {get; private set; }</pre></li>
<li>Next, add the <code>EditText</code> command, which takes a copy of the <code>previousText</code> value and creates an <code>Action</code> delegate that can revert the text to its previous value, if invoked:<pre>        public void EditText(string newText)
        {
            var previousText = Text;
            _undoStack.Do( () =&gt;
            {
                Text = previousText;
                Console.Write($"Undo:'{newText}'".PadRight(40));
                Console.WriteLine($"Text='{Text}'");
            });</pre></li>
<li>Now, the <code>newText</code> value should be appended to the <code>Text</code> property, using the <code>+=</code> operator. The details for this are logged to the console, using <code>PadRight</code> to improve the format:<pre>            Text += newText;
            Console.Write($"Edit:'{newText}'".PadRight(40));
            Console.WriteLine($"Text='{Text}'");
        }
    }</pre></li>
<li>Finally, it is time to create a console app that tests <code>TextEditor</code> and <code>UndoStack</code>. Four edits are initially made, followed by two <strong class="bold">undo operations</strong>, and finally two more text edits:<pre>    class StackExamples
    {
        
        public static void Main()
        {
            var undoStack = new UndoStack();
            var editor = new TextEditor(undoStack);
            editor.EditText("One day, ");
            editor.EditText("in a ");
            editor.EditText("city ");
            editor.EditText("near by ");
            undoStack.Undo(); // remove 'near by'
            undoStack.Undo(); // remove 'city'
            editor.EditText("land ");
            editor.EditText("far far away ");
            Console.ReadLine();
        }
    }    
}</pre></li>
<li>Running the console app produces the following output:<pre>Edit:'One day, '                        Text='One day, '
Edit:'in a '                            Text='One day, in a '
Edit:'city '                            Text='One day, in a city '
Edit:'near by '                         Text='One day, in a city near by '
Undo:'near by '                         Text='One day, in a city '
Undo:'city '                            Text='One day, in a '
Edit:'land '                            Text='One day, in a land '
Edit:'far far away '                    Text='One day, in a land far far away '</pre><p class="callout-heading">Note</p><p class="callout">Visual Studio may show non-nullable property error the first time the code is executed. This is because Visual Studio notices that the <code>Text</code> property can be a null value at runtime so offers a suggestion to improve the code.</p></li>
</ol>
<p>The left-hand output shows the text edits and undoes operations as they are applied and the resulting <code>Text</code> value on the right-hand side. The two <code>Undo</code> calls result in <code>near by</code> and <code>city</code> being removed from the <code>Text</code> value, before <code>land </code>and <code>far far away</code> are finally added to the <code>Text</code> value.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/tLVyf">https://packt.link/tLVyf</a>.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor173"/>HashSets</h2>
<p>The <code>HashSet</code> class provides mathematical set operations with collections of objects in an efficient and highly performant manner. <code>HashSet</code> does not allow duplicate elements and items are not stored in any particular order. Using the <code>HashSet</code> class is ideal for high-performance operations, such as needing to quickly find where two collections of objects overlap.</p>
<p>Typically, <code>HashSet</code> is used with the following operations:</p>
<ul>
<li><code>public void UnionWith(IEnumerable&lt;T&gt; other)</code>: Produ<a id="_idTextAnchor174"/>ces a set union. This modifies <code>HashSet</code> to include the items present in the current <code>HashSet</code> instance, the other collection, or both.</li>
<li><code>public void IntersectWith(IEnumerable&lt;T&gt; other)</code>: Produces a set intersect. This modifies <code>HashSet</code> to include items present in the current <code>HashSet</code> instance and the other collection.</li>
<li><code>public void ExceptWith(IEnumerable&lt;T&gt; other)</code>: Produces a set subtraction. This removes items from the <code>HashSet</code> that are present in the current <code>HashSet</code> instance and the other collection.</li>
</ul>
<p><code>HashSet</code> is useful when you need to include or exclude certain elements from <strong class="bold">collections</strong>. As an example, consider that an agent manages various celebrities and has been asked to find three sets of stars:</p>
<ul>
<li>Those that can act <strong class="bold">or</strong> sing.</li>
<li>Those that can act <strong class="bold">and</strong> sing.</li>
<li>Those that can act <strong class="bold">only</strong> (no singers allowed).</li>
</ul>
<p>In the following snippet, a list of actors' and singers' names is created:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new class called <code>HashSetExamples.cs</code> and edit it as follows:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Examples
{
    class HashSetExamples
    {
        public static void Main()
        {
            var actors = new List&lt;string&gt; {"Harrison Ford", "Will Smith", 
                                           "Sigourney Weaver"};
            var singers = new List&lt;string&gt; {"Will Smith", "Adele"};</pre></li>
<li>Now, create a new <code>HashSet</code> instance that initially contains singers only and then use <code>UnionWith</code> to modify the set to contain a distinct set of those that can act <strong class="bold">or</strong> sing:<pre>            var actingOrSinging = new HashSet&lt;string&gt;(singers);
            actingOrSinging.UnionWith(actors);
            Console.WriteLine($"Acting or Singing: {string.Join(", ", 
                              actingOrSinging)}");</pre></li>
<li>For those that can act <code>HashSet</code> instance of singers, and modify the <code>HashSet</code> instance using <code>IntersectWith</code> to contain a distinct list of those that are in both collections:<pre>            var actingAndSinging = new HashSet&lt;string&gt;(singers);
            actingAndSinging.IntersectWith(actors);
            Console.WriteLine($"Acting and Singing: {string.Join(", ", 
                              actingAndSinging)}");</pre></li>
<li>Finally, for those that can <code>ExceptWith</code> to remove those from the <code>HashSet</code> instance that can also sing:<pre>            var actingOnly = new HashSet&lt;string&gt;(actors);
            actingOnly.ExceptWith(singers);
            Console.WriteLine($"Acting Only: {string.Join(", ", actingOnly)}");
            Console.ReadLine();
        }
    }
}</pre></li>
<li>Running the console app produces the following output:<pre>Acting or Singing: Will Smith, Adele, Harrison Ford, Sigourney Weaver
Acting and Singing: Will Smith
Acting Only: Harrison Ford, Sigourney Weaver</pre></li>
</ol>
<p>From the output, you can see that out of the given list of actors and singers, only <code>Will Smith</code> can act and sing.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ZdNbS">https://packt.link/ZdNbS</a>.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor175"/>Dictionaries</h2>
<p>Another commonly used collection type is the generic <code>Dictionary&lt;TK, TV&gt;</code>. This allows multiple items to be added, but a unique <strong class="bold">key</strong> is needed to identify an item instance.</p>
<p>Dictionaries are commonly used to look up values using known keys. The key and value type parameters can be of any type. A value can exist in a <code>Dictionary</code> more than once, provided that its key is <strong class="bold">unique</strong>. Attempting to add a key that already exists will result in a runtime exception being thrown.</p>
<p>A common example of a <code>Dictionary</code> might be a registry of known countries that are keyed by their ISO country code. A customer service application may load customer details from a database and then use the ISO code to look up the customer's country from the country list, rather than having the extra overhead of creating a new country instance for each customer.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on standard ISO country codes at <a href="https://www.iso.org/iso-3166-country-codes.xhtml">https://www.iso.org/iso-3166-country-codes.xhtml</a>.</p>
<p>The main methods used in the <code>Dictionary</code> class are as follows:</p>
<ul>
<li><code>public TValue this[TKey key] {get; set;}</code>: Gets or sets a value associated with the key. An exception is thrown if the key does not exist.</li>
<li><code>Dictionary&lt;TKey, TValue&gt;.KeyCollection Keys { get; }</code>: Returns a <code>KeyCollection</code> dictionary instance that contains all keys.</li>
<li><code>Dictionary&lt;TKey, TValue&gt;.ValueCollection Values { get; }</code>: Returns a <code>ValueCollection</code> dictionary instance that contains all values.</li>
<li><code>public int Count { get; }</code>: Returns the number of elements in the <code>Dictionary</code>.</li>
<li><code>void Add(TKey key, TValue value)</code>: Adds the key and associated value. If the key already exists, an exception is thrown.</li>
<li><code>void Clear()</code>: Clears all keys and values from the <code>Dictionary</code>.</li>
<li><code>bool ContainsKey(TKey key)</code>: Returns <code>true</code> if the specified key exists.</li>
<li><code>bool ContainsValue(TValue value)</code>: Returns <code>true</code> if the specified value exists.</li>
<li><code>bool Remove(TKey key)</code>: Removes a value with the associated key.</li>
<li><code>bool TryAdd(TKey key, TValue value)</code>: Attempts to add the key and value. If the key already exists, an exception is "not" thrown. Returns <code>true</code> if the value was added.</li>
<li><code>bool TryGetValue(TKey key, out TValue value)</code>: Gets the value associated with the key, if it is available. Returns <code>true</code> if it was found.</li>
</ul>
<p>The following code shows how a <code>Dictionary</code> can be used to add and navigate <code>Country</code> records:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new class called <code>DictionaryExamples.cs</code>.</li>
<li>Start by defining a <code>Country</code> record, which is passed a <code>Name</code> parameter:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Examples
{
    public record Country(string Name)
    {}
    class DictionaryExamples
    {
        public static void Main()
        {</pre></li>
<li>Use the <code>Dictionary</code> initialization syntax to create a <code>Dictionary</code> with five countries, as follows:<pre>            var countries = new Dictionary&lt;string, Country&gt;
            {
                {"AFG", new Country("Afghanistan")},
                {"ALB", new Country("Albania")},
                {"DZA", new Country("Algeria")},
                {"ASM", new Country("American Samoa")},
                {"AND", new Country("Andorra")}
            };</pre></li>
<li>In the next code snippet, <code>Dictionary</code> implements the <code>IEnumerable</code> interface, which allows you to retrieve a key-value pair representing the key and value items in the <code>Dictionary</code>:<pre>            Console.WriteLine("Enumerate foreach KeyValuePair");
            foreach (var kvp in countries)
            {
                Console.WriteLine($"\t{kvp.Key} = {kvp.Value.Name}");
            }</pre></li>
<li>Running the example code produces the following output. By iterating through each item in <code>countries</code>, you can see the five country codes and their names:<pre>Enumerate foreach KeyValuePair
        AFG = Afghanistan
        ALB = Albania
        DZA = Algeria
        ASM = American Samoa
        AND = Andorra</pre></li>
<li>There is an entry with the <code>AFG</code> key, so using the <code>set indexer</code> passing in <code>AFG</code> as a key allows a new <code>Country</code> record to be set that replaces the previous item with the <code>AGF</code> key. You can add the following code for this:<pre>            Console.WriteLine("set indexor AFG to new value");
            countries["AFG"] = new Country("AFGHANISTAN");
            Console.WriteLine($"get indexor AFG: {countries["AFG"].Name}");</pre></li>
<li>When you run the code, adding a key for <code>AFG</code> allows you to get a value using that key:<pre>set indexor AFG to new value
get indexor AFG: AFGHANISTAN
ContainsKey AGO: False
ContainsKey and: False</pre></li>
<li>Key comparisons are case-sensitive with string keys, so <code>AGO</code> is present but <code>and</code> is not as the corresponding country (<code>Andorra</code>) is defined with the uppercase <code>AND</code> key. You can add the following code to check this:<pre>            Console.WriteLine($"ContainsKey {"AGO"}:                          {countries.ContainsKey("AGO")}");
            Console.WriteLine($"ContainsKey {"and"}:                          {countries.ContainsKey("and")}"); // Case sensitive</pre></li>
<li>Using <code>Add</code> to add a new entry will throw an exception if the key already exists. This can be seen by adding the following code:<pre>            var anguilla = new Country("Anguilla");
            Console.WriteLine($"Add {anguilla}...");
            countries.Add("AIA", anguilla);
            try
            {
                var anguillaCopy = new Country("Anguilla");
                Console.WriteLine($"Adding {anguillaCopy}...");
                countries.Add("AIA", anguillaCopy);
            }
            catch (Exception e)
            {
                Console.WriteLine($"Caught {e.Message}");
            }</pre></li>
<li>Conversely, <code>TryAdd</code> does <code>AIA</code> key, so using <code>TryAdd</code> simply returns a <code>false</code> value rather than throwing an exception:<pre>            var addedAIA = countries.TryAdd("AIA", new Country("Anguilla"));
            Console.WriteLine($"TryAdd AIA: {addedAIA}");</pre></li>
<li>As the following output shows, adding <code>Anguilla</code> once using the <code>AIA</code> key is valid but attempting to add it again using the <code>AIA</code> key results in an exception being caught:<pre>Add Country { Name = Anguilla }...
Adding Country { Name = Anguilla }...
Caught An item with the same key has already been added. Key: AIA
TryAdd AIA: False</pre></li>
<li><code>TryGetValue</code>, as the name suggests, allows you to try to get a value by key. You pass in a key that may be missing from the <code>Dictionary</code>. Requesting an object whose key is missing from the <code>Dictionary</code> will ensure that an exception is not thrown. This is useful if you are unsure whether a value has been added for the specified key:<pre>            var tryGet = countries.TryGetValue("ALB", out Country albania1);
            Console.WriteLine($"TryGetValue for ALB: {albania1}                              Result={tryGet}");
            countries.TryGetValue("alb", out Country albania2);
            Console.WriteLine($"TryGetValue for ALB: {albania2}");
        }
    }
}</pre></li>
<li>You should see the following output upon running this code:<pre>TryGetValue for ALB: Country { Name = Albania } Result=True
TryGetValue for ALB:</pre><p class="callout-heading">Note</p><p class="callout">Visual Studio might report the following warning: <code>Warning CS8600: Converting null literal or possible null value to non-nullable type</code>. This is a reminder from Visual Studio that a variable may have a null value at runtime.</p></li>
</ol>
<p>You have seen how the <code>Dictionary</code> class is used to ensure that only unique identities are associated with values. Even if you do not know which keys are in the <code>Dictionary</code> until runtime, you can use the <code>TryGetValue</code> and <code>TryAdd</code> methods to prevent runtime exceptions.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/vzHUb">https://packt.link/vzHUb</a>.</p>
<p>In this example, a string key was used for the <code>Dictionary</code>. However, any type can be used as a key. You will often find that an integer value is used as a key when source data is retrieved from relational databases, as integers can often be more efficient in memory than strings. Now it is time to use this feature through an exercise.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor176"/>Exercise 4.02: Using a Dictionary to Count the Words in a Sentence</h2>
<p>You have been asked to create a console app that asks the user to enter a sentence. The console should then split the input into individual words (using a space character as a word delimiter) and count the number of times that each word occurs. If possible, simple forms of punctuation should be removed from the output, and you are to ignore capitalized words so that, for example, <code>Apple</code> and <code>apple</code> both appear as a single word.</p>
<p>This is an ideal use of a <code>Dictionary</code>. The <code>Dictionary</code> will use a string as the key (a unique entry for each word) with an <code>int</code> value to count the words. You will use <code>string.Split()</code> to split a sentence into words, and <code>char.IsPunctuation</code> to remove any trailing punctuation marks. </p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In your <code>Chapter04\Exercises</code> folder, create a new folder called <code>Exercise02</code>.</li>
<li>Inside the <code>Exercise02</code> folder, add a new class called <code>Program.cs</code>.</li>
<li>Start by defining a new class called <code>WordCounter</code>. This can be marked as <code>static</code> so that it can be used without needing to create an instance:<pre>using System;
using System.Collections.Generic;
namespace Chapter04.Exercises.Exercise02
{
    static class WordCounter 
    {</pre></li>
<li>Define a <code>static</code> method called <code>Process</code>: <pre>        public static IEnumerable&lt;KeyValuePair&lt;string, int&gt;&gt; Process(            string phrase)
        {
            var wordCounts = new Dictionary&lt;string, int&gt;();</pre></li>
</ol>
<p>This is passed a phrase and returns <code>IEnumerable&lt;KeyValuePair&gt;</code>, which allows the caller to enumerate through a <code>Dictionary</code> of results. After this definition, the <code>Dictionary</code> of <code>wordCounts</code> is keyed using a <code>string</code> (each word found) and an <code>int</code> (the number of times that a word occurs).</p>
<ol>
<li value="5">You are to ignore the case of words with capital letters, so convert the string into its lowercase equivalent before using the <code>string.Split</code> method to split the phrase. </li>
<li>Then you can use the <code>RemoveEmptyEntries</code> option to remove any empty string values. Add the following code for this:<pre>             var words = phrase.ToLower().Split(' ',                        StringSplitOptions.RemoveEmptyEntries);</pre></li>
<li>Use a simple <code>foreach</code> loop to iterate through the individual words found in the phrase:<pre>            foreach(var word in words)
            {
                var key = word;
                if (char.IsPunctuation(key[key.Length-1]))
                {
                    key = key.Remove(key.Length-1);
                }</pre></li>
</ol>
<p>The <code>char.IsPunctuation</code> method is used to remove punctuation marks from the end of the word.</p>
<ol>
<li value="8">Use the <code>TryGetValue</code> method to check if there is a <code>Dictionary</code> entry with the current word. If so, update the <code>count</code> by one:<pre>                if (wordCounts.TryGetValue(key, out var count))
                {
                    wordCounts[key] = count + 1;
                }
                else
                {
                    wordCounts.Add(key, 1);
                }
            }</pre></li>
</ol>
<p>If the word does not exist, add a new word key with a starting value of <code>1</code>.</p>
<ol>
<li value="9">Once all the words in the phrase have been processed, return the <code>wordCounts Dictionary</code>:<pre>            return wordCounts;
        }
    }</pre></li>
<li>Now, write the console app that allows the user to enter a phrase:<pre>    class Program
    {
        public static void Main()
        {
            string input;
            do
            {
                Console.Write("Enter a phrase:");
                input = Console.ReadLine();</pre></li>
</ol>
<p>The <code>do</code> loop will end once the user enters an empty string; you will add the code for this in an upcoming step.</p>
<ol>
<li value="11">Call the <code>WordCounter.Process</code> method to return a key-value pair that can be enumerated through. </li>
<li>For each <code>key</code> and <code>value</code>, write the word and its count, padding each word to the right: <pre>                if (!string.IsNullOrEmpty(input))
                {
                    var countsByWord = WordCounter.Process(input);
                    var i = 0;
                    foreach (var (key, value) in countsByWord)
                    {
                        Console.Write($"{key.PadLeft(20)}={value}\t");
                        i++;
                        if (i % 3 == 0)
                        {
                            Console.WriteLine();
                        }
                    }
                    Console.WriteLine();</pre></li>
</ol>
<p>A new line is started after every third word (using <code>i % 3 = 0</code>) for improved output formatting.</p>
<ol>
<li value="13">Finish off the <code>do-while</code> loop:<pre>                    }
            } while (input != string.Empty);
        }
    }
}</pre></li>
<li>Running the console using the opening text from <em class="italic">The Gettysburg Address</em> of 1863 produces this output:<pre>Enter a phrase: Four score and seven years ago our fathers brought forth, upon this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived, and so dedicated, can long endure.
                four=1                 score=1                 and=3
               seven=1                 years=1                 ago=1
                 our=1               fathers=1             brought=1
               forth=1                  upon=1                this=1
           continent=1                     a=2                 new=1
              nation=3             conceived=2                  in=2
             liberty=1             dedicated=2                  to=1
                 the=1           proposition=1                that=2
                 all=1                   men=1                 are=2
             created=1                 equal=1                 now=1
                  we=1               engaged=1               great=1
               civil=1                   war=1             testing=1
             whether=1                    or=1                 any=1
                  so=2                   can=1                 long=1
              endure=1</pre><p class="callout-heading">Note</p><p class="callout">You can search online for The Gettysburg Address or visit <a href="https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm">https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm</a>.</p></li>
</ol>
<p>From the results, you can see that each word is displayed only once and that certain words, such as <code>and</code> and <code>that</code>, appear more than once in the speech. The words are listed in the order they appear in the text, but this is not always the case with the <code>Dictionary</code> class. It should be assumed that the order will <strong class="bold">not</strong> remain fixed this way; dictionaries' values should be accessed using a key.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Dnw4a">https://packt.link/Dnw4a</a>.</p>
<p>So far, you have learned about the main collections commonly used in .NET. It is now time to look at LINQ, which makes extensive use of collections based on the <code>IEnumerable</code> interface.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor177"/>LINQ</h1>
<p>LINQ (pronounced <strong class="bold">link</strong>) is short for Language Integrated Query. LINQ is a general-purpose language that can be used to query objects in memory by using a syntax that is similar to Structured Query Language (SQL), that is, it is used to query databases. It is an enhancement of the C# language that makes it easier to interact with objects in memory using SQL-like Query Expressions or Query Operators (implemented through a series of extension methods).</p>
<p>Microsoft's original idea for LINQ was to bridge the gap between .NET code and data sources, such as relational databases and XML, using LINQ providers. LINQ providers form a set of building blocks that can be used to query various sources of data, using a similar set of Query Operators, without the caller needing to know the intricacies of how each data source works. The following is a list of providers and how they are used:</p>
<ul>
<li>LINQ to Objects: Queries applied to objects in memory, such as those defined in a list.</li>
<li>LINQ to SQL: Queries applied to relational databases such as SQL Server, Sybase, or Oracle.</li>
<li>LINQ to XML: Queries applied to XML documents.</li>
</ul>
<p>This chapter will cover LINQ to Objects. This is, by far, the most common use of LINQ providers and offers a flexible way to query collections in memory. In fact, when talking about LINQ, most people refer to LINQ to Objects, mainly due to its ubiquitous use throughout C# applications.</p>
<p>At the heart of LINQ is the way that collections can be converted, filtered, and aggregated into new forms using a concise and easy-to-use syntax. LINQ can be used in two interchangeable styles:</p>
<ul>
<li>Query Operators</li>
<li>Query Expressions</li>
</ul>
<p>Each style offers a different syntax to achieve the same result, and which one you use often comes down to personal preference. Each style can be interwoven in code easily.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor178"/>Query Operators</h2>
<p>These are based on a series of core extension methods. The results from one method can be chained together into a programming style, which can often be easier to grasp than their expression-based counterparts.</p>
<p>The extension methods typically take an <code>IEnumerable&lt;T&gt;</code> or <code>IQueryable&lt;T&gt;</code> input source, such as a list, and allow a <code>Func&lt;T&gt;</code> predicate to be applied to that source. The source is generic-based, so Query Operators work with all types. It is just as easy to work with <code>List&lt;string&gt;</code> as it is with <code>List&lt;Customer&gt;</code>, for example.</p>
<p>In the following snippet, <code>.Where</code>, <code>.OrderBy</code>, and <code>.Select</code> are the extension methods being called:</p>
<pre>books.Where(book =&gt; book.Price &gt; 10)
     .OrderBy(book =&gt; book.Price)
     .Select(book =&gt; book.Name)</pre>
<p>Here, you are taking the results from a <code>.Where</code> extension method to find all books with a unit price greater than <code>10</code>, which is then sorted using the <code>.OrderBy</code> extension method. Finally, the name of each book is extracted using the <code>.Select</code> method. These methods could have been declared as single lines of code, but chaining in this way provides a more intuitive syntax. This will be covered in more detail in the upcoming sections.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor179"/>Query Expressions</h2>
<p>Query Expressions are an enhancement of the C# language and resemble SQL syntax. The C# compiler compiles Query Expressions into a sequence of Query Operator extension method calls. Note that not all Query Operators are available with an equivalent Query Expression implementation.</p>
<p>Query Expressions have the following rules:</p>
<ul>
<li>They start with a <code>from</code> clause.</li>
<li>They can contain at least one or more optional <code>where</code>, <code>orderby</code>, <code>join</code>, <code>let</code>, and additional <code>from</code> clauses.</li>
<li>They end with either a <code>select</code> or a <code>group</code> clause.</li>
</ul>
<p>The following snippet is functionally equivalent to the Query Operator style defined in the previous section:</p>
<pre>from book in books where book.Price &gt; 10 orderby book.Price select book.Name</pre>
<p>You will take a more in-depth look at both styles as you learn about the standard Query Operators shortly.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor180"/>Deferred Execution</h2>
<p>Whether you choose to use Query Operators, Query Expressions, or a mixture of the two, it is important to remember that for many operators, the query that you define is not executed when it is defined, but only when it is enumerated over. This means that it is not until a <code>foreach</code> statement or a <code>ToList</code>, <code>ToArray</code>, <code>ToDictionary</code>, <code>ToLookup</code>, or <code>ToHashSet</code> method is called that the actual query is executed.</p>
<p>This allows queries to be constructed elsewhere in code with additional criteria included, and then used or even reused with a different collection of data. Recall that in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Lambdas, and Events</em>, you saw similar behavior with delegates. Delegates are not executed where they are defined, but only when they are invoked.</p>
<p>In the following short Query Operator example, the output will be <code>abz</code> even though <code>z</code> is added <strong class="bold">after</strong> the query is defined but <strong class="bold">before</strong> it is enumerated through. This demonstrates that LINQ queries are evaluated on demand, rather than at the point where they are declared:</p>
<pre>var letters = new List&lt;string&gt; { "a", "b"}
var query = letters.Select(w =&gt; w.ToUpper());
letters.Add("z");
foreach(var l in query) 
  Console.Write(l);</pre>
<h2 id="_idParaDest-165"><a id="_idTextAnchor181"/>Standard Query Operators</h2>
<p>LINQ is driven by a core set of extension methods, referred to as standard Query Operators. These are grouped into operations based on their functionality. There are many standard Query Operators available, so for this introduction, you will explore all the main operators that you are likely to use regularly.</p>
<h3 id="_idParaDest-166"><a id="_idTextAnchor182"/>Projection Operations</h3>
<p>Projection operations allow you to convert an object into a new structure using only the properties that you need. You can create a new type, apply mathematical operations, or return the original object:</p>
<ul>
<li><code>Select</code>: Projects each item in the source into a new form.</li>
<li><code>SelectMany</code>: Projects all items in the source, flattens the result, and optionally projects them to a new form. There is no Query Expression equivalent for <code>SelectMany</code>.</li>
</ul>
<h3 id="_idParaDest-167"><a id="_idTextAnchor183"/>Select</h3>
<p>Consider the following snippet, which iterates through a <code>List&lt;string&gt;</code> containing the values <code>Mon</code>, <code>Tues</code>, and <code>Wednes</code>, outputting each with the word day appended.</p>
<p>In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqSelectExamples.cs</code> and edit it as follows:</p>
<pre>using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    class LinqSelectExamples
    {
        public static void Main()
        {
            var days = new List&lt;string&gt; { "Mon", "Tues", "Wednes" };
            var query1 = days.Select(d =&gt; d + "day");
            foreach(var day in query1)
                Console.WriteLine($"Query1: {day}");         </pre>
<p>Looking at the Query Operator syntax first, you can see that <code>query1</code> uses the <code>Select</code> extension method and defines a <code>Func&lt;T&gt;</code> like this: </p>
<pre><code>d =&gt; d + "day"</code></pre>
<p>When executed, the variable <code>d</code> is passed to the lambda statement, which appends the word <code>day</code> to each string in the <code>days</code> list: <code>"Mon"</code>, <code>"Tues"</code>, <code>"Wednes"</code>. This returns a new <code>IEnumerable&lt;string&gt;</code> instance, with the original values inside the source variable, <code>days</code>, remaining unchanged.</p>
<p>You can now enumerate through the new <code>IEnumerable</code> instance using <code>foreach</code>, as follows:</p>
<pre>            var query2 = days.Select((d, i) =&gt; $"{i} : {d}day");
            foreach (var day in query2)
                Console.WriteLine($"Query2: {day}");</pre>
<p>Note that the <code>Select</code> method has another overload that allows the index position in the source and value to be accessed, rather than just the value itself. Here, <code>d</code> (the string value) and <code>i</code> (its index) are passed, using the <code>( d , i ) =&gt;</code> syntax and joined into a new string. The output will be displayed as <code>0 : Monday</code>, <code>1 : Tuesday</code>, and so on.</p>
<h3 id="_idParaDest-168"><a id="_idTextAnchor184"/>Anonymous Types</h3>
<p>Before you continue looking at <code>Select</code> projections, it is worth noting that C# does not limit you to just creating new strings from existing strings. You can project into any type.</p>
<p>You can also create anonymous types, which are types created by the compiler from the properties that you name and specify. For example, consider the following example, which results in a new type being created that represents the results of the <code>Select</code> method:</p>
<pre>            var query3 = days.Select((d, i) =&gt; new
            {
                Index = i, 
                UpperCaseName = $"{d.ToUpper()}DAY"
            });
            foreach (var day in query3)
                Console.WriteLine($"Query3: Index={day.Index},                                             UpperCaseDay={day.UpperCaseName}");</pre>
<p>Here, <code>query3</code> results in a new type that has an Index and <code>UpperCaseName</code> property; the values are assigned using <code>Index = i</code> and <code>UpperCaseName = $"{d.ToUpper()}DAY"</code>.</p>
<p>These types are scoped to be available within your local method and can then be used in any local statements, such as in the previous <code>foreach</code> block. This saves you from having to create classes to temporarily store values from a <code>Select</code> method.</p>
<p>Running the code produces output in this format:</p>
<pre>Index=0, UpperCaseDay=MONDAY</pre>
<p>As an alternative, consider how the equivalent Query Expression looks. In the following example, you start with the from <code>day in days</code> expression. This assigns the name <code>day</code> to the string values in the <code>days</code> list. You then use <code>select</code> to project that to a new string, appending <code>"day"</code> to each.</p>
<p>This is functionally equivalent to the example in <code>query1</code>. The only difference is the code readability:</p>
<pre>            var query4 = from day in days
                         select day + "day";
            foreach (var day in query4)
                Console.WriteLine($"Query4: {day}");</pre>
<p>The following example snippet mixes a Query Operator and Query Expressions. The <code>select</code> Query Expression cannot be used to select a value and index, so the <code>Select</code> extension method is used to create an anonymous type with a <code>Name</code> and <code>Index</code> property:</p>
<pre>                       var query5 = from dayIndex in 
                         days.Select( (d, i) =&gt; new {Name = d, Index = i})
                         select dayIndex;
            foreach (var day in query5)
                Console.WriteLine($"Query5: Index={day.Index} : {day.Name}");
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the full example produces this output:</p>
<pre>Query1: Monday
Query1: Tuesday
Query1: Wednesday
Query2: 0 : Monday
Query2: 1 : Tuesday
Query2: 2 : Wednesday
Query3: Index=0, UpperCaseDay=MONDAY
Query3: Index=1, UpperCaseDay=TUESDAY
Query3: Index=2, UpperCaseDay=WEDNESDAY
Query4: Monday
Query4: Tuesday
Query4: Wednesday
Query5: Index=0 : Mon
Query5: Index=1 : Tues
Query5: Index=2 : Wednes</pre>
<p>Again, it largely comes down to personal choice as to which you prefer using. As queries become longer, one form may require less code than the other.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/wKye0">https://packt.link/wKye0</a>.</p>
<h3 id="_idParaDest-169"><a id="_idTextAnchor185"/>SelectMany</h3>
<p>You have seen how <code>Select</code> can be used to project values from each item in a source collection. In the case of a source that has enumerable properties, the <code>SelectMany</code> extension method can extract the multiple items into a single list, which can then be optionally projected into a new form.</p>
<p>The following example creates two <code>City</code> records, each with multiple <code>Station</code> names, and uses <code>SelectMany</code> to extract all stations from both cities:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqSelectManyExamples.cs</code> and edit it as follows:<pre>using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    record City (string Name, IEnumerable&lt;string&gt; Stations);
    class LinqSelectManyExamples
    {
        public static void Main()
        {
            var cities = new List&lt;City&gt;
            {
                new City("London", new[] {"Kings Cross KGX",                                           "Liverpool Street LVS",                                           "Euston EUS"}),
                new City("Birmingham", new[] {"New Street NST"})
            };
            Console.WriteLine("All Stations: ");
            <strong class="bold">foreach (var station in cities.SelectMany(city =&gt; city.Stations))</strong>
            {
                Console.WriteLine(station);
            }</pre></li>
</ol>
<p>The <code>Func</code> parameter, which is passed to <code>SelectMany</code>, requires you to specify an enumerable property, in this case, the <code>City</code> class's <code>Stations</code> property, which contains a list of string names (see the highlighted code).</p>
<p>Notice how a shortcut is used here, by directly integrating the query into a <code>foreach</code> statement. You are not altering or reusing the query variable, so there is no benefit in defining it separately, as done earlier.</p>
<p><code>SelectMany</code> extracts all the station names from all of the items in the <code>List&lt;City&gt;</code> variable. Starting with the <code>City</code> class at element <code>0</code>, which has the name <code>London</code>, it will extract the three station names <code>("Kings Cross KGX"</code>, <code>"Liverpool Street LVS"</code>, and <code>"Euston EUS"</code>). It will then move on to the second <code>City</code> element, named <code>Birmingham</code>, and extract the single station, named <code>"New Street NST"</code>.</p>
<ol>
<li value="2">Running the example produces the following output:<pre>All Stations:
Kings Cross KGX
Liverpool Street LVS
Euston EUS
New Street NST</pre></li>
<li>As an alternative, consider the following snippet. Here, you revert to using a query variable, <code>stations</code>, to make the code easier to follow:<pre>            Console.Write("All Station Codes: ");
            var stati<a id="_idTextAnchor186"/>ons = cities
                .Sele<a id="_idTextAnchor187"/>ctMany(city =&gt; city.Stations.Select(s =&gt; s[^3..]));
            foreach (var station in stations)
            {
                Console.Write($"{station} ");
            }
            Console.WriteLine();
            Console.ReadLine();
        }
    }
}</pre></li>
</ol>
<p>Rather than just returning each <code>Station</code> string, this example uses a nested <code>Select</code> method and a <code>Range</code> operator to extract the last three characters from the station name using <code>s[^3..]</code>, where <code>s</code> is a string for each station name and <code>^3</code> indicates that the <code>Range</code> operator should extract a string that starts at the last three characters in the string.</p>
<ol>
<li value="4">Running the example produces the following output:<pre>All Station Codes: KGX LVS EUS NST</pre></li>
</ol>
<p>You can see the last three characters of each station name are shown in the output.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/g8dXZ">https://packt.link/g8dXZ</a>.</p>
<p>In the next section you will read about the filtering operations that filter a result as per a condition.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor188"/>Filtering Operations</h2>
<p>Filtering operations allow you to filter a result to return only those items that match a condition. For example, consider the following snippet, which contains a list of orders:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqWhereExample.cs</code> and edit it as follows:<pre>LinqWhereExamples.cs
using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    record Order (string Product, int Quantity, double Price);
    class LinqWhereExamples
    {
        public static void Main()
        {
            var orders = new List&lt;Order&gt;
            {
                new Order("Pen", 2, 1.99),
                new Order("Pencil", 5, 1.50),
                new Order("Note Pad", 1, 2.99),</pre></li>
</ol>
<pre>You can find the complete code here: <a href="https://packt.link/ZJpb5">https://packt.link/ZJpb5</a>.</pre>
<p>Here, some order items are defined for various stationery products. Suppose you want to output all orders that have a quantity greater than five (this should output the <code>Ruler</code> and <code>USB Memory Stick</code> orders from the source). </p>
<ol>
<li value="2">For this, you can add the following code:<pre>            Console.WriteLine("Orders with quantity over 5:");
            foreach (var order in orders.Where(o =&gt; o.Quantity &gt; 5))
            {
                Console.WriteLine(order);
            }</pre></li>
<li>Now, suppose you extend the criteria to find all products where the product is <code>Pen</code> or <code>Pencil</code>. You can chain that result into a <code>Select</code> method, which will return each order's total value; remember that <code>Select</code> can return anything from a source, even a simple extra calculation like this:<pre>            Console.WriteLine("Pens or Pencils:");
            foreach (var orderValue in orders
                .Where(o =&gt; o.Product == "Pen"  || o.Product == "Pencil")
                .Select( o =&gt; o.Quantity * o.Price))
            {
                Console.WriteLine(orderValue);
            }</pre></li>
<li>Next, the Query Expression in the following snippet uses a <code>where</code> clause to find the orders with a price less than or equal to <code>3.99</code>. This projects them into an anonymous type that has <code>Name</code> and <code>Value</code> properties, which you enumerate through using a <code>foreach</code> statement:<pre>            var query = from order in orders
               where order.Price &lt;= 3.99
               select new {Name=order.Product, Value=order.Quantity*order.Price};
            Console.WriteLine("Cheapest Orders:");
            foreach(var order in query)
            {
                Console.WriteLine($"{order.Name}: {order.Value}");
            }
        }
    }
}</pre></li>
<li>Running the full example produces this result:<pre>Orders with quantity over 5:
Order { Product = Ruler, Quantity = 10, Price = 0.5 }
Order { Product = USB Memory Stick, Quantity = 6, Price = 20 }
Pens or Pencils:
3.98
7.5
Cheapest Orders:
Pen: 3.98
Pencil: 7.5
Note Pad: 2.99
Stapler: 3.99
Ruler: 5</pre></li>
</ol>
<p>Now you have seen Query Operators in action, it is worth returning to deferred execution to see how this affects a query that is enumerated multiple times over.</p>
<p>In this next example, you have a collection of journeys made by a vehicle, which are populated via a <code>TravelLog</code> record. The <code>TravelLog</code> class contains an <code>AverageSpeed</code> method that logs a console message each time it is executed, and, as the name suggests, returns the average speed of the vehicle during that journey:</p>
<ol>
<li value="1">In your Chapter04\Examples folder, add a new file called <code>LinqMultipleEnumerationExample.cs</code> and edit it as follows:<pre>using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    record TravelLog (string Name, int Distance, int Duration)
    {
        public double AverageSpeed()
        {
            Console.WriteLine($"AverageSpeed() called for '{Name}'");
            return Distance / Duration;
        }
    }
    class LinqMultipleEnumerationExample
    {</pre></li>
<li>Next, define the console app's <code>Main</code> method, which populates a <code>travelLogs</code> list with four <code>TravelLog</code> records. You will add the following code for this:<pre>        public static void Main()
        {
            var travelLogs = new List&lt;TravelLog&gt;
            {
                new TravelLog("London to Brighton", 50, 4),
                new TravelLog("Newcastle to London", 300, 24),
                new TravelLog("New York to Florida", 1146, 19),
                new TravelLog("Paris to Berlin", 546, 10)
            };</pre></li>
<li>You will now create a <code>fastestJourneys</code> query variable, which includes a <code>Where</code> clause. This <code>Where</code> clause will call each journey's <code>AverageSpeed</code> method when enumerated. </li>
<li>Then, using a <code>foreach</code> loop, you enumerate through the items in <code>fastestJourneys</code> and write the name and distance to the console (note that you do <code>AverageSpeed</code> method inside the <code>foreach</code> loop):<pre>            var fastestJourneys = travelLogs.Where(tl =&gt; tl.AverageSpeed() &gt; 50);
            Console.WriteLine("Fastest Distances:");
            foreach (var item in fastestJourneys)
            {
                Console.WriteLine($"{item.Name}: {item.Distance} miles<a id="_idTextAnchor189"/>");
            }
            Console.WriteLine();</pre></li>
<li>Running the code block will produce the following output, the <code>Name</code> and <code>Distance</code> for each journey:<pre>Fastest Distances:
AverageSpeed() called for 'London to Brighton'
AverageSpeed() called for 'Newcastle to London'
AverageSpeed() called for 'New York to Florida'
New York to Florida: 1146 miles
AverageSpeed() called for 'Paris to Berlin'
Paris to Berlin: 546 miles</pre></li>
<li>You can see that <code>AverageSpeed</code> was called <code>Where</code> condition. This is as expected so far, but now, you can reuse the same query to output the <code>Name</code> and, alternatively, the <code>Duration</code>:<pre>            Console.WriteLine("Fastest Duration:");
            foreach (var item in fastestJourneys)
            {
                Console.WriteLine($"{item.Name}: {item.Duration} hours");
            }
            Console.WriteLine();</pre></li>
<li>Running this block produces the same <code>AverageSpeed</code> method:<pre>Fastest Duration:
AverageSpeed() called for 'London to Brighton'
AverageSpeed() called for 'Newcastle to London'
AverageSpeed() called for 'New York to Florida'
New York to Florida: 19 hours
AverageSpeed() called for 'Paris to Berlin'
Paris to Berlin: 10 hours</pre></li>
</ol>
<p>This shows that whenever a query is enumerated, the full query is <code>AverageSpeed</code>, but what if a method needs to access a database to extract some data? That would result in multiple database calls and, possibly, a very slow application.</p>
<ol>
<li value="8">You can use methods such as <code>ToList</code>, <code>ToArray</code>, <code>ToDictionary</code>, <code>ToLookup</code>, or <code>ToHashSet</code> to ensure that a query that could be enumerated many times is <code>Where</code> clause but includes an extra <code>ToList</code> call to immediately execute the query and ensure it is not re-evaluated:<pre>            Console.WriteLine("Fastest Duration Multiple loops:");
            var fastestJourneysList = travelLogs
                  .Where(tl =&gt; tl.AverageSpeed() &gt; 50)
                  .ToList();
            for (var i = 0; i &lt; 2; i++)
            {
                Console.WriteLine($"Fastest Duration Multiple loop iteration {i+1}:");
                foreach (var item in fastestJourneysList)
                {
                    Console.WriteLine($"{item.Name}: {item.Distance} in {item.Duration} hours");
                }
            }
        }
    }
}</pre></li>
<li>Running the block produces the following output. Notice how <code>AverageSpeed</code> is called <code>Fastest Duration Multiple loop iteration</code> messages:<pre>Fastest Duration Multiple loops:
AverageSpeed() called for 'London to Brighton'
AverageSpeed() called for 'Newcastle to London'
AverageSpeed() called for 'New York to Florida'
AverageSpeed() called for 'Paris to Berlin'
Fastest Duration Multiple loop iteration 1:
New York to Florida: 1146 in 19 hours
Paris to Berlin: 546 in 10 hours
Fastest Duration Multiple loop iteration 2:
New York to Florida: 1146 in 19 hours
Paris to Berlin: 546 in 10 hours</pre></li>
</ol>
<p>Notice that from the collection of journeys made by a vehicle, the code returns the average speed of the vehicle during the journeys.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/CIZJE">https://packt.link/CIZJE</a>.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor190"/>Sorting Operations</h2>
<p>There are five operations to sort items in a source. Items are primarily sorted and that can be followed by an optional secondary sort, which sorts the items within their primary group. For example, you can use a primary sort to sort a list of people firstly by the <code>City</code> property and then use a secondary sort to further sort them by the <code>Surname</code> property:</p>
<ul>
<li><code>OrderBy</code>: Sorts values into ascending order.</li>
<li><code>OrderByDescending</code>: Sorts values into descending order.</li>
<li><code>ThenBy</code>: Sorts values that have been primarily sorted into a secondary ascending order.</li>
<li><code>ThenByDescending</code>: Sorts values that have been primarily sorted into a secondary descending order.</li>
<li><code>Reverse</code>: Simply returns a collection where the order of elements in the source is reversed. There is no expression equivalent.</li>
</ul>
<h3 id="_idParaDest-172"><a id="_idTextAnchor191"/>OrderBy and OrderByDescending</h3>
<p>In this example, you will use the <code>System.IO</code> namespace to query files in the host machine's <code>temp</code> folder, rather than creating small objects from lists.</p>
<p>The static <code>Directory</code> class offers methods that can query the filesystem. <code>FileInfo</code> retrieves details about a specific file, such as its size or creation date. The <code>Path.GetTempPath</code> method returns the system's <code>temp</code> folder. To illustrate the point, in the Windows operating system, this can typically be found at <code>C:\Users\username\AppData\Local\Temp</code>, where <code>username</code> is a specific Windows login name. This will be different for other users and other systems:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqOrderByExamples.cs</code> and edit it as follows:<pre>using System;
using System.IO;
using System.Linq;
namespace Chapter04.Examples
{
    class LinqOrderByExamples
    {
        public static void Main()
        {</pre></li>
<li>Use the <code>Directory.EnumerateFiles</code> method to find all filenames with the <code>.tmp</code> extension in the <code>temp</code> folder:<pre>            var fileInfos = Directory.EnumerateFiles(Path.GetTempPath(), "*.tmp")
                .Select(filename =&gt; new FileInfo(filename))
                .ToList();</pre></li>
</ol>
<p>Here, each filename is projected into a <code>FileInfo</code> instance and chained into a populated collection using <code>ToList</code>, which allows you to further query the resulting <code>fileInfos</code> details.</p>
<ol>
<li value="3">Next, the <code>OrderBy</code> method is used to sort the earliest files by comparing the <code>CreationTime</code> property of the file:<pre>            Console.WriteLine("Earliest Files");
            foreach (var fileInfo in fileInfos.OrderBy(fi =&gt; fi.CreationTime))
            {
                Console.WriteLine($"{fileInfo.CreationTime:dd MMM yy}: {fileInfo.Name}");
            }</pre></li>
<li>To find the largest files, re-query <code>fileInfos</code> and sort each file by its <code>Length</code> property using <code>OrderByDescending</code>:<pre>            Console.WriteLine("Largest Files");
            foreach (var fileInfo in fileInfos                                        .OrderByDescending(fi =&gt; fi.Length))
            {
                Console.WriteLine($"{fileInfo.Length:N0} bytes: \t{fileInfo.Name}");
            }</pre></li>
<li>Finally, use <code>where</code> and <code>orderby</code> descending expressions to find the largest files that are less than <code>1,000</code> bytes in length:<pre>            Console.WriteLine("Largest smaller files");
            foreach (var fileInfo in
                from fi in fileInfos
                where fi.Length &lt; 1000
                orderby fi.Length descending
                select fi)
            {
                Console.WriteLine($"{fileInfo.Length:N0} bytes: \t{fileInfo.Name}");
            }
            Console.ReadLine();
        }
    }
}</pre></li>
<li>Depending on the files in your <code>temp</code> folder, you should see an output like this:<pre>Earliest Files
05 Jan 21: wct63C3.tmp
05 Jan 21: wctD308.tmp
05 Jan 21: wctFE7.tmp
04 Feb 21: wctE092.tmp
Largest Files
38,997,896 bytes:       wctE092.tmp
4,824,572 bytes:        cb6dfb76-4dc9-494d-9683-ce31eab43612.tmp
4,014,036 bytes:        492f224c-c811-41d6-8c5d-371359d520db.tmp
Largest smaller files
726 bytes:      wct38BC.tmp
726 bytes:      wctE239.tmp
512 bytes:      ~DF8CE3ED20D298A9EC.TMP
416 bytes:      TFR14D8.tmp</pre></li>
</ol>
<p>With this example, you have queried files in the host machine's <code>temp</code> folder, rather than creating small objects from lists.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/mWeVC">https://packt.link/mWeVC</a>.</p>
<h3 id="_idParaDest-173"><a id="_idTextAnchor192"/>ThenBy and ThenByDescending</h3>
<p>The following example sorts popular quotes, based on the number of words found in each.</p>
<p>In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqThenByExamples.cs</code> and edit it as follows:</p>
<pre>using System;
using System.IO;
using System.Linq;
namespace Chapter04.Examples
{
    class LinqThenByExamples
    {
        public static void Main()
        {</pre>
<p>You start by declaring a string array of quotes as follows:</p>
<pre>            var quotes = new[]
            {
                "Love <a id="_idTextAnchor193"/>for all hatred for none",
                "Change the world by being yourself",
                "Every moment is a fresh beginning",
                "Never regret anything that made you smile",
                "Die with memories not dreams",
                "Aspire to inspire before we expire"
            };</pre>
<p>In the next snippet, each of these string quotes is projected into a new anonymous type based on the number of words in the quote (found using <code>String.Split()</code>). The items are first sorted in descending order to show those with the most words and then sorted in alphabetical order:</p>
<pre>            forea<a id="_idTextAnchor194"/>ch (var item in quotes
                .Select(q =&gt; new {Quote = q, Words = q.Split(" ").Length})
                .OrderByDescending(q =&gt; q.Words)
                .ThenBy(q =&gt; q.Quote))
            {
                Console.WriteLine($"{item.Words}: {item.Quote}");
            }
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the code lists the quotes in word count order as follows: </p>
<pre>7: Never regret anything that made you smile
6: Aspire to inspire before we expire
6: Change the world by being yourself
6: Every moment is a fresh beginning
6: Love for all hatred for none
5: Die with memories not dreams</pre>
<p>Note how the quotes with six words are shown alphabetically.</p>
<p>The following (highlighted code) is the equivalent Query Expression with <code>orderby quote.Words descending</code> followed by the <code>quote.Words</code> ascending clause:</p>
<pre><strong class="bold">var query = from quote in </strong>
<strong class="bold">            (quotes.Select(q =&gt; new {Quote = q, Words = q.Split(" ").Length}))</strong>
<strong class="bold">            orderby quote.Words descending, quote.Words ascending </strong>
<strong class="bold">            select quote;</strong>
foreach(var item in query)        
            {
                Console.WriteLine($"{item.Words}: {item.Quote}");
            }
            Console.ReadLine();
        }
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/YWJRz">https://packt.link/YWJRz</a>.</p>
<p>Now you have sorted popular quotes based on the number of words found in each. It is time to apply the skills learnt in the next exercise.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor195"/>Exercise 4.03: Filtering a List of Countries by Continent and Sorting by Area</h2>
<p>In the preceding examples, you have looked at code that can select, filter, and sort a collection source. You will now combine these into an exercise that filters a small list of countries for two continents (South America and Africa) and sorts the results by geographical size.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In your <code>Chapter04\Exercises</code> folder, create a new <code>Exercise03</code> folder.</li>
<li>Add a new class called <code>Program.cs</code> in the <code>Exercise03</code> folder.</li>
<li>Start by adding a <code>Country</code> record that will be passed the <code>Name</code> of a country, the <code>Continent</code> to which it belongs, and its <code>Area</code> in square miles:<pre>using System;
using System.Linq;
namespace Chapter04.Exercises.Exercise03
{
    class Program
    {
        record Country (string Name, string Continent, int Area);
        public static void Main()
        {</pre></li>
<li>Now create a small subset of country data defined in an array, as follows:<pre>            var countries = new[]
            {
                new Country("Seychelles", "Africa", 176),
                new Country("India", "Asia", 1_269_219),
                new Country("Brazil", "South America",3_287_956),
                new Country("Argentina", "South America", 1_073_500),
                new Country("Mexico", "South America",750_561),
                new Country("Peru", "South America",494_209),
                new Country("Algeria", "Africa", 919_595),
                new Country("Sudan", "Africa", 668_602)
            };</pre></li>
</ol>
<p>The array contains the name of a country, the continent it belongs to, and its geographical size in square miles.</p>
<ol>
<li value="5">Your search criteria must include <code>South America</code> or <code>Africa</code>. So define them in an array rather than hardcoding the <code>where</code> clause with two specific strings:<pre>            var requiredContinents = new[] {"South America", "Africa"};</pre></li>
</ol>
<p>This offers extra code flexibility should you need to alter it.</p>
<ol>
<li value="6">Build up a query by filtering and sorting by continent, sorting by area, and using the <code>.Select</code> extension method, which returns the <code>Index</code> and <code>item</code> value: <pre>            var filteredCountries = countries
                .Where(c =&gt; requiredContinents.Contains(c.Continent))
                .OrderBy(c =&gt; c.Continent)
                .ThenByDescending(c =&gt; c.Area)
                .Select( (cty, i) =&gt; new {Index = i, Country = cty});
                
            foreach(var item in filteredCountries)
                Console.WriteLine($"{item.Index+1}: {item.Country.Continent}, {item.Country.Name} = {item.Country.Area:N0} sq mi");
        }
    }
}</pre></li>
</ol>
<p>You finally project each into a new anonymous type to be written to the console. </p>
<ol>
<li value="7">Running the code block produces the following result:<pre>1: Africa, Algeria = 919,595 sq mi
2: Africa, Sudan = 668,602 sq mi
3: Africa, Seychelles = 176 sq mi
4: South America, Brazil = 3,287,956 sq mi
5: South America, Argentina = 1,073,500 sq mi
6: South America, Mexico = 750,561 sq mi
7: South America, Peru = 494,209 sq mi</pre></li>
</ol>
<p>Notice that <code>Algeria</code> has the largest area in <code>Africa</code>, and <code>Brazil</code> has the largest area in <code>South America</code> (based on this small subset of data). Notice how you add <code>1</code> to each <code>Index</code> for readability (since starting at zero is less user-friendly).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Djddw">https://packt.link/Djddw</a>.</p>
<p>You have seen how LINQ extension methods can be used to access items in a data source. Now, you will learn about partitioning data, which can be used to extract subsets of items.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor196"/>Partitioning Operations</h2>
<p>So far, you have looked at filtering the items in a data source that match a defined condition. Partitioning is used when you need to divide a data source into two distinct sections and return either of those two sections for subsequent processing.</p>
<p>For example, consider that you have a list of vehicles sorted by value and want to process the five least expensive vehicles using some method. If the list is sorted in ascending order, then you could partition the data using the <code>Take(5)</code> method (defined in the following paragraphs), which will extract the first five items and discard the remaining.</p>
<p>There are six partitioning operations that are used to split a source, with either of the two sections being returned. There are no partitioning Query Expressions:</p>
<ul>
<li><code>Skip</code>: Returns a collection that skips items up to a specified numeric position in the source sequence. Used when you need to skip the first N items in a source collection.</li>
<li><code>SkipLast</code>: Returns a collection that skips the last N items in the source sequence.</li>
<li><code>SkipWhile</code>: Returns a collection that skips items in the source sequence that match a specified condition.</li>
<li><code>Take</code>: Returns a collection that contains the first N items in the sequence.</li>
<li><code>TakeLast</code>: Returns a collection that contains the last N items in the sequence.</li>
<li><code>TakeWhile</code>: Returns a collection that contains only those items that match the condition specified.</li>
</ul>
<p>The following example demonstrates various <code>Skip</code> and <code>Take</code> operations on an unsorted list of exam grades. Here, you use <code>Skip(1)</code> to ignore the highest grade in a sorted list.</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqSkipTakeExamples.cs</code> and edit it as follows:<pre>using System;
using System.Linq;
namespace Chapter04.Examples
{
    class LinqSkipTakeExamples
    {
        public static void Main()
        {
            var grades = new[] {25, 95, 75, 40, 54, 9, 99};
            Console.Write("Skip: Highest Grades (skipping first):");
            foreach (var grade in grades
                .OrderByDescending(g =&gt; g)
                .Skip(1))
            {
                Console.Write($"{grade} ");
            }
            Console.WriteLine();</pre></li>
<li>Next, the relational <code>is</code> operator is used to exclude those less than <code>25</code> or greater than <code>75</code>:<pre>            Console.Write("SkipWhile@ Middle Grades (excluding 25 or 75):");
            foreach (var grade in grades
                .OrderByDescending(g =&gt; g)
                .SkipWhile(g =&gt; g is &lt;= 25 or &gt;=75))
            {
                Console.Write($"{grade} ");
            }
            Console.WriteLine();</pre></li>
<li>By using <code>SkipLast</code>, you can show the bottom half of the results. Add the code for this as follows:<pre>            Console.Write("SkipLast: Bottom Half Grades:");
            foreach (var grade in grades
                .OrderBy(g =&gt; g)
                .SkipLast(grades.Length / 2))
            {
                Console.Write($"{grade} ");
            }
            Console.WriteLine();</pre></li>
<li>Finally, <code>Take(2)</code> is used here to show the two highest grades:<pre>            Console.Write("Take: Two Highest Grades:");
            foreach (var grade in grades
                .OrderByDescending(g =&gt; g)
                .Take(2))
            {
                Console.Write($"{grade} ");
            }
        }
    }
}</pre></li>
<li>Running the example produces this output, which is as expected:<pre>Skip: Highest Grades (skipping first):95 75 54 40 25 9
SkipWhile Middle Grades (excluding 25 or 75):54 40 25 9
SkipLast: Bottom Half Grades:9 25 40 54
Take: Two Highest Grades:99 95</pre></li>
</ol>
<p>This example demonstrated the various <code>Skip</code> and <code>Take</code> operations on an unsorted list of exam grades.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/TsDFk">https://packt.link/TsDFk</a>.</p>
<h2 id="_idParaDest-176">Group<a id="_idTextAnchor197"/>ing Operations</h2>
<p><code>GroupBy</code> groups elements that share the same attribute. It is often used to group data or provide a count of items grouped by a common attribute. The result is an enumerable <code>IGrouping&lt;K, V&gt;</code> type collection, where <code>K</code> is the key type and <code>V</code> is the value type specified. <code>IGrouping</code> itself is enumerable as it contains all items that match the specified key.</p>
<p>For example, consider the next snippet, which groups a <code>List</code> of customer orders by name. In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqGroupByExamples.cs</code> and edit it as follows:</p>
<pre>LinqGroupByExamples.cs
using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    record CustomerOrder(string Name, string Product, int Quantity);
    class LinqGroupByExamples
    {
        public static void Main()
        {
            var orders = new List&lt;CustomerOrder&gt;
            {
                new CustomerOrder("Mr Green", "LED TV", 4),
                new CustomerOrder("Mr Smith", "iPhone", 2),
                new CustomerOrder("Mrs Jones", "Printer", 1),
You can find the complete code here: <a href="https://packt.link/GbwF2">https://packt.link/GbwF2</a>.</pre>
<p>In this example, you have a list of <code>CustomerOrder</code> objects and want to group them by the <code>Name</code> property. For this, the <code>GroupBy</code> method is passed a <code>Func</code> delegate, which selects the <code>Name</code> property from each <code>CustomerOrder</code> instance.</p>
<p>Each item in the <code>GroupBy</code> result contains a <code>Key</code> (in this case, the customer's <code>Name</code>). You can then sort the grouping item to show the <code>CustomerOrders</code> items sorted by <code>Quantity</code>, as follows:</p>
<pre>                foreach (var item in grouping.OrderByDescending(i =&gt; i.Quantity))
                {
                    Console.WriteLine($"\t{item.Product} * {item.Quantity}");
                }
            }
            Console.ReadLine();
        }
    }
}</pre>
<p>Running the code produces the following output:</p>
<pre>Customer Mr Green:
        LED TV * 4
        MP3 Player * 1
        Microwave Oven * 1
Customer Mr Smith:
        PC * 5
        iPhone * 2
        Printer * 2
Customer Mrs Jones:
        Printer * 1</pre>
<p>You can see the data is first grouped by customer <code>Name</code> and then ordered by order <code>Quantity</code> within each customer grouping. The equivalent Query Expression is written like this:</p>
<pre>            var query = from order in orders
                        group order by order.Name;
            foreach (var grouping in query)
            {
                Console.WriteLine($"Customer {grouping.Key}:");
                foreach (var item in from item in grouping 
                                     orderby item.Quantity descending 
                                     select item)
                {
                    Console.WriteLine($"\t{item.Product} * {item.Quantity}");
                }
            }</pre>
<p>You have now seen some of the commonly used LINQ operators. You will now bring them together in an exercise.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor198"/>Exercise 4.04: Finding the Most Commonly Used Words in a Book</h2>
<p>In <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, you used the <code>WebClient</code> class to download data from a website. In this exercise, you will use data downloaded from <em class="italic">Project Gutenberg</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Project Gutenberg is a library of 60,000 free eBooks. You can search online for Project Gutenberg or visit <a href="https://www.gutenberg.org/">https://www.gutenberg.org/</a>.</p>
<p>You will create a console app that allows the user to enter a URL. Then, you will download the book's text from the Project Gutenberg URL and use various LINQ statements to find the most frequent words in the book's text.</p>
<p>Additionally, you want to exclude some common stop-words; these are words such as <code>and</code>, <code>or</code>, and <code>the</code> that appear regularly in English, but add little to the meaning of a sentence. You will use the <code>Regex.Split</code> method to help split words more accurately than a simple space delimiter. Perform the following steps to do so:</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on Regex can be found at <a href="https://packt.link/v4hGN">https://packt.link/v4hGN</a>.</p>
<ol>
<li value="1">In your <code>Chapter04\Exercises</code> folder, create a new <code>Exercise04</code> folder.</li>
<li>Add a new class called <code>Program.cs</code> in the <code>Exercise04</code> folder.</li>
<li>First, define the <code>TextCounter</code> class. This will be passed the path to a file, which you will add shortly. This should contain common English stop-words:<pre>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
namespace Chapter04.Exercises.Exercise04
{
    class TextCounter
    {
        private readonly HashSet&lt;string&gt; _stopWords;
        public TextCounter(string stopWordPath)
        {
            Console.WriteLine($"Reading stop word file: {stopWordPath}");</pre></li>
<li>Using <code>File.ReadAllLines</code>, add each word into the <code>_stopWords</code> <code>HashSet</code>.<pre>          _stopWords = new HashSet&lt;string&gt;(File.ReadAllLines(stopWordPath));
        }</pre></li>
</ol>
<p>You have used a <code>HashSet</code>, as each stop-word is unique.</p>
<ol>
<li value="5">Next, the <code>Process</code> method is passed a string that contains the book's text and the maximum number of words to show. </li>
<li>Return the result as a <code>Tuple&lt;string, int&gt;</code> collection, which saves you from having to create a class or record to hold the results:<pre>        public IEnumerable&lt;Tuple&lt;string, int&gt;&gt; Process(string text,                                                        int maximumWords)
        {</pre></li>
<li>Now perform the query part. Use <code>Regex.Split</code> with the pattern <code>@"\s+"</code> to split all the words. </li>
</ol>
<p>In its simplest form, this pattern splits a string into a list of words, typically using a space or punctuation marks to identify word boundaries. For example, the string <code>Hello Goodbye</code> would be split into an array that contains two elements, <code>Hello</code> and <code>Goodbye</code>. The returned string items are filtered via <code>where</code> to ensure all stop-words are ignored using the <code>Contains</code> method. The words are then grouped by value, <code>GroupBy(t=&gt;t)</code>, projected to a <code>Tuple</code> using the word as a <code>Key</code>, and the number of times it occurs using <code>grp.Count</code>. </p>
<ol>
<li value="8">Finally, you sort by <code>Item2</code>, which for this <code>Tuple</code> is the word count, and then take only the required number of words:<pre>            var words = Regex.Split(text.ToLower(), @"\s+")
                .Where(t =&gt; !_stopWords.Contains(t))
                .GroupBy(t =&gt; t)
                .Select(grp =&gt; Tuple.Create(grp.Key, grp.Count()))
                .OrderByDescending(tup =&gt; tup.Item2) //int
                .Take(maximumWords);
            return words;
        }
    }</pre></li>
<li>Now start creating the main console app:<pre>    class Program
    {
        public static void Main()
        {</pre></li>
<li>Include a text file called <code>StopWords.txt</code> in the <code>Chapter04</code> source folder:<pre>            const string StopWordFile = "StopWords.txt";
            var counter = new TextCounter(StopWordFile);</pre><p class="callout-heading">Note</p><p class="callout">You can find <code>StopWords.txt</code> on GitHub at <a href="https://packt.link/Vi8JH">https://packt.link/Vi8JH</a>, or you can download any standard stop-word file, such as NLTK's <a href="https://packt.link/ZF1Tf">https://packt.link/ZF1Tf</a>. This file should be saved in the <code>Chapter04\Exercises</code> folder.</p></li>
<li>Once <code>TextCounter</code> has been created, prompt the user for a URL:<pre>            string address;
            do
            {
                //https://www.gutenberg.org/files/64333/64333-0.txt
                Console.Write("Enter a Gutenberg book URL: ");
                address = Console.ReadLine();
                if (string.IsNullOrEmpty(address)) 
                    continue;</pre></li>
<li>Enter a valid address and create a new <code>WebClient</code> instance and download the data file into a temporary file. </li>
<li>Perform extra processing to the text file before passing its contents to <code>TextCounter</code>:<pre>                using var client = new WebClient();
                var tempFile = Path.GetTempFileName();
                Console.WriteLine("Downloading...");
                client.DownloadFile(address, tempFile);</pre></li>
</ol>
<p>The Gutenberg text files contain extra details such as the author and title. These can be read by reading each line in the file. The actual text of the book doesn't begin until finding a line that starts <code>*** START OF THE PROJECT GUTENBERG EBOOK</code>, so you need to read each line looking for this start message too:</p>
<pre>                Console.WriteLine($"Processing file {tempFile}");
                const string StartIndicator = "*** START OF THE PROJECT GUTENBERG EBOOK";
                //Title: The Little Review, October 1914(Vol. 1, No. 7)
                //Author: Various
                var title = string.Empty;
                var author = string.Empty;</pre>
<ol>
<li value="14">Next, append each line read into a <code>StringBuilder</code> instance, which is efficient for such string operations:<pre>                var bookText = new StringBuilder();
                var isReadingBookText = false;
                var bookTextLineCount = 0;</pre></li>
<li>Now parse each line inside <code>tempFile</code>, looking for the <code>Author</code>, <code>Title</code>, or the <code>StartIndicator</code>:<pre>                foreach (var line in File.ReadAllLines(tempFile))
                {
                    if (line.StartsWith("Title"))
                    {
                        title = line;
                    }
                    else if (line.StartsWith("Author"))
                    {
                        author = line;
                    }
                    else if (line.StartsWith(StartIndicator))
                    {
                        isReadingBookText = true;
                    }
                    else if (isReadingBookText)
                    {
                        bookText.Append(line);
                        bookTextLineCount++;
                    }
                }</pre></li>
<li>If the book text is found, provide a summary of lines and characters read before calling the <code>counter.Process</code> method. Here, you want the top <code>50</code> words:<pre>                if (bookTextLineCount &gt; 0)
                {
                    Console.WriteLine($"Processing {bookTextLineCount:N0} lines ({bookText.Length:N0} characters)..");
                  var wordCounts = counter.Process(bookText.ToString(), 50);
                  Console.WriteLine(title);
                  Console.WriteLine(author);</pre></li>
<li>Once you have the results, use a <code>foreach</code> loop to output the word count details, adding a blank line to the output after every third word:<pre>                    var i = 0;
                    //deconstruction
                    foreach (var (word, count) in wordCounts)
                    {
                        Console.Write($"'{word}'={count}\t\t");
                        i++;
                        if (i % 3 == 0)
                        {
                            Console.WriteLine();
                        }
                    }
                    Console.WriteLine();
                }
                else
                {</pre></li>
<li>Running the console app, using <code>https://www.gutenberg.org/files/64333/64333-0.txt</code> as an example URL produces the following output:<pre>Reading stop word file: StopWords.txt
Enter a Gutenberg book URL: https://www.gutenberg.org/files/64333/64333-0.txt
Downloading...
Processing file C:\Temp\tmpB0A3.tmp
Processing 4,063 lines (201,216 characters)..
Title: The Little Review, October 1914 (Vol. 1, No. 7)
Author: Various
'one'=108               'new'=95                'project'=62
'man'=56                'little'=54             'life'=52
'would'=51              'work'=50               'book'=42
'must'=42               'people'=39             'great'=37
'love'=37               'like'=36               'gutenberg-tm'=36
'may'=35                'men'=35                'us'=32
'could'=30              'every'=30              'first'=29
'full'=29               'world'=28              'mr.'=28
'old'=27                'never'=26              'without'=26
'make'=26               'young'=24              'among'=24
'modern'=23             'good'=23               'it.'=23
'even'=22               'war'=22                'might'=22
'long'=22               'cannot'=22             '_the'=22
'many'=21               'works'=21              'electronic'=21
'always'=20             'way'=20                'thing'=20
'day'=20                'upon'=20               'art'=20
'terms'=20              'made'=19</pre><p class="callout-heading">Note</p><p class="callout">Visual Studio might show the following when the code is run for the first time: <code>warning SYSLIB0014: 'WebClient.WebClient()' is obsolete: 'WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.</code></p><p class="callout">This is a recommendation to use the newer <code>HttpClient</code> class instead of the <code>WebClient</code> class. Both are, however, functionally equivalent.</p></li>
</ol>
<p>The output shows a list of words found amongst the <code>4,063</code> lines of text downloaded. The counter shows that <code>one</code>, <code>new</code>, and <code>project</code> are the most popular words. Notice how <code>mr.</code>, <code>gutenberg-tm</code>, <code>it.</code>, and <code>_the</code> appear as words. This shows that the Regex expression used is not completely accurate when splitting words.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Q7Pf8">https://packt.link/Q7Pf8</a>.</p>
<p>An interesting enhancement to this exercise would be to sort the words by count, include a count of the stop words found, or find the average word length.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor199"/>Aggregation Operations</h2>
<p>Aggregation operations are used to compute a single value from a collection of values in a data source. An example could be the maximum, minimum, and average rainfall from data collected over a month:</p>
<ul>
<li><code>Average</code>: Calculates the average value in a collection.</li>
<li><code>Count</code>: Counts the items that match a predicate.</li>
<li><code>Max</code>: Calculates the maximum value.</li>
<li><code>Min</code>: Calculates the minimum value.</li>
<li><code>Sum</code>: Calculates the sum of values.</li>
</ul>
<p>The following example uses the <code>Process.GetProcess</code> method from the <code>System.Diagnostics</code> namespace to retrieve a list of processes currently running on the system:</p>
<p>In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqAggregationExamples.cs</code> and edit it as follows:</p>
<pre>using System;
using System.Diagnostics;
using System.Linq;
namespace Chapter04.Examples
{
    class LinqAggregationExamples
    {
        public static void Main()
        {</pre>
<p>First, <code>Process.GetProcesses().ToList()</code> is called to retrieve a list of the active processes running on the system:</p>
<pre>            var processes = Process.GetProcesses().ToList();</pre>
<p>Then, the <code>Count</code> extension method obtains a count of the items returned. Count has an additional overload, which accepts a <code>Func</code> delegate used to filter each of the items to be counted. The <code>Process</code> class has a <code>PrivateMemorySize64</code> property, which returns the number of bytes of memory the process is currently consuming, so you can use that to count the <code>1,000,000</code> bytes of memory:</p>
<pre>            var allProcesses = processes.Count;
            var smallProcesses = processes.Count(proc =&gt;                                        proc.PrivateMemorySize64 &lt; 1_000_000);</pre>
<p>Next, the <code>Average</code> extension method returns the overall average of a specific value for all items in the <code>processes</code> list. In this case, you use it to calculate the average memory consumption, using the <code>PrivateMemorySize64</code> property again:</p>
<pre>            var average = processes.Average(p =&gt; p.PrivateMemorySize64);</pre>
<p>The <code>PrivateMemorySize64</code> property is also used to calculate the maximum and minimum memory used for all processes, along with the total memory, as follows:</p>
<pre>            var max = processes.Max(p =&gt; p.PrivateMemorySize64);
            var min = processes.Min(p =&gt; p.PrivateMemorySize64);
            var sum = processes.Sum(p =&gt; p.PrivateMemorySize64);</pre>
<p>Once you have calculated the statistics, each value is written to the console:</p>
<pre>            Console.WriteLine("Process Memory Details");
            Console.WriteLine($"  All Count: {allProcesses}");
            Console.WriteLine($"Small Count: {smallProcesses}");
            Console.WriteLine($"    Average: {FormatBytes(average)}");
            Console.WriteLine($"    Maximum: {FormatBytes(max)}");
            Console.WriteLine($"    Minimum: {FormatBytes(min)}");
            Console.WriteLine($"      Total: {FormatBytes(sum)}");
        }</pre>
<p>In the preceding snippet, the <code>Count</code> method returns the number of all processes and, using the <code>Predicate</code> overload, you <code>Count</code> those where the memory is less than 1,000,000 bytes (by examining the <code>process.PrivateMemorySize64</code> property). You can also see that <code>Average</code>, <code>Max</code>, <code>Min</code>, and <code>Sum</code> are used to calculate statistics for process memory usage on the system.</p>
<p class="callout-heading">Note</p>
<p class="callout">The aggregate operators will throw <code>InvalidOperationException</code> with the error <code>Sequence contains no elements</code> if you attempt to calculate using a source collection that contains no elements. You should check the <code>Count</code> or <code>Any</code> methods prior to calling any aggregate operators.</p>
<p>Finally, <code>FormatBytes</code> formats the amounts of memory into their megabyte equivalents:</p>
<pre>        private static string FormatBytes(double bytes)
        {
            return $"{bytes / Math.Pow(1024, 2):N2} MB";
        }
    }
}</pre>
<p>Running the example produces results similar to this:</p>
<pre>Process Memory Details
  All Count: 305
Small Count: 5
    Average: 38.10 MB
    Maximum: 1,320.16 MB
    Minimum: 0.06 MB
      Total: 11,620.03 MB</pre>
<p>From the output you will observe how the program retrieves a list of processes currently running on the system.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/HI2eV">https://packt.link/HI2eV</a>.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor200"/>Quantifier Operations</h2>
<p>Quantifier operations return a <code>bool</code> that indicates whether <code>Predicate</code> condition. This is often used to verify any elements in a collection match some criteria, rather than relying on <code>Count</code>, which enumerates <strong class="bold">all</strong> items in the collection, even if you need just one result.</p>
<p>Quantifier operations are accessed using the following extension methods:</p>
<ul>
<li><code>All</code>: Returns <code>true</code> if <strong class="bold">all</strong> elements in the source sequence match a condition.</li>
<li><code>Any</code>: Returns <code>true</code> if <strong class="bold">any</strong> element in the source sequence matches a condition.</li>
<li><code>Contains</code>: Returns <code>true</code> if the source sequence contains the specified item.</li>
</ul>
<p>The following card-dealing example selects three cards at random and returns a summary of those selected. The summary uses the <code>All</code> and <code>Any</code> extension methods to determine whether any of the cards were clubs or red and whether all cards were diamonds or an even number:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqAllAnyExamples.cs</code>.</li>
<li>Start by declaring an <code>enum</code> that represents each of the four suits in a pack of playing cards and a <code>record</code> class that defines a playing card:<pre>using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    enum PlayingCardSuit
    {
        Hearts,
        Clubs,
        Spades,
        Diamonds
    }
    record PlayingCard (int Number, PlayingCardSuit Suit)
    {</pre></li>
<li>It is common practice to override the <code>ToString</code> method to provide a user-friendly way to describe an object's state at runtime. Here, the card's number and suit are returned as a string:<pre>        public override string ToString()
        {
            return $"{Number} of {Suit}";
        }
    }</pre></li>
<li>Now create a class to represent a deck of cards (for ease, only create cards numbered one to 10). The deck's constructor will populate the <code>_cards</code> collection with <code>10</code> cards for each of the suits:<pre>    class Deck
    {
        private readonly List&lt;PlayingCard&gt; _cards = new();
        private readonly Random _random = new();
        public Deck()
        {
            for (var i = 1; i &lt;= 10; i++)
            {
                _cards.Add(new PlayingCard(i, PlayingCardSuit.Hearts));
                _cards.Add(new PlayingCard(i, PlayingCardSuit.Clubs));
                _cards.Add(new PlayingCard(i, PlayingCardSuit.Spades));
                _cards.Add(new PlayingCard(i, PlayingCardSuit.Diamonds));
            }
        }</pre></li>
<li>Next, the <code>Draw</code> method randomly selects a card from the <code>_cards</code> List, which it removes before returning to the caller:<pre>        public PlayingCard Draw()
        {
            var index = _random.Next(_cards.Count);
            var drawnCard = _cards.ElementAt(index);
            _cards.Remove(drawnCard);
            return drawnCard;
        }
    }</pre></li>
<li>The console app selects three cards using the deck's <code>Draw</code> method. Add the code for this as follows:<pre>    class LinqAllAnyExamples
    {
        public static void Main()
        {
            var deck = new Deck();
            var hand = new List&lt;PlayingCard&gt;();
            
            for (var i = 0; i &lt; 3; i++)
            {
                hand.Add(deck.Draw());
            }</pre></li>
<li>To show a summary, use the <code>OrderByDescending</code> and <code>Select</code> operations to extract the user-friendly <code>ToString</code> description for each <code>PlayingCard</code>. This is then joined into a single delimited string as follows:<pre>            var summary = string.Join(" | ", 
                hand.OrderByDescending(c =&gt; c.Number)
                    .Select(c =&gt; c.ToString()));
            Console.WriteLine($"Hand: {summary}");</pre></li>
<li>Using <code>All</code> or <code>Any</code>, you can provide an overview of the cards and their score using the <code>Sum</code> of the card numbers. By using <code>Any</code>, you determine whether <code>PlayingCardSuit.Clubs</code>):<pre>            Console.WriteLine($"Any Clubs: {hand.Any(card =&gt; card.Suit == PlayingCardSuit.Clubs)}");</pre></li>
<li>Similarly, <code>Any</code> is used to see if <code>Hearts</code> or <code>Diamonds</code> suits, and therefore, are <code>Red</code>:<pre>            Console.WriteLine($"Any Red: {hand.Any(card =&gt; card.Suit == PlayingCardSuit.Hearts || card.Suit == PlayingCardSuit.Diamonds)}");</pre></li>
<li>In the next snippet, the <code>All</code> extension looks at every item in the collection and returns <code>true</code>, in this case, if <code>Diamonds</code>:<pre>            Console.WriteLine($"All Diamonds: {hand.All(card =&gt; card.Suit == PlayingCardSuit.Diamonds)}");</pre></li>
<li>All is used again to see if all card numbers can be divided by two without a remainder, that is, whether they are even:<pre>            Console.WriteLine($"All Even: {hand.All(card =&gt; card.Number % 2 == 0)}");</pre></li>
<li>Conclude by using the <code>Sum</code> aggregation method to calculate the value of the cards in the hand:<pre>            Console.WriteLine($"Score :{hand.Sum(card =&gt; card.Number)}");
        }
    }
}</pre></li>
<li>Running the console app produces output like this:<pre>Hand: 8 of Spades | 7 of Diamonds | 6 of Diamonds
Any Clubs: False
Any Red: True
All Diamonds: False
All Even: False
Score :21</pre></li>
</ol>
<p>The cards are randomly selected so you will have different hands each time you run the program. In this example, the score was <code>21</code>, which is often a winning hand in card games.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/xPuTc">https://packt.link/xPuTc</a>.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor201"/>Join Operations</h2>
<p>Join operations are used to join two sources based on the association of objects in one data source with those that share a common attribute in a second data source. If you are familiar with database design, this can be thought of as a primary and foreign key relationship between tables.</p>
<p>A common example of a join is one where you have a one-way relationship, such as <code>Orders</code>, which has a property of type <code>Products</code>, but the <code>Products</code> class does not have a collection property that represents a backward relationship to a collection of <code>Orders</code>. By using a <code>Join</code> operator, you can create a backward relationship to show <code>Orders</code> for <code>Products</code>.</p>
<p>The two join extension methods are the following:</p>
<ul>
<li><code>Join</code>: Joins two sequences using a key selector to extract pairs of values.</li>
<li><code>GroupJoin</code>: Joins two sequences using a key selector and groups the resulting items.</li>
</ul>
<p>The following example contains three <code>Manufacturer</code> records, each with a unique <code>ManufacturerId</code>. These numeric IDs are used to define various <code>Car</code> records, but to save memory, you will not have a direct memory reference from <code>Manufacturer</code> back to <code>Car</code>. You will use the <code>Join</code> method to create an association between the <code>Manufacturer</code> and <code>Car</code> instances:</p>
<ol>
<li value="1">In your <code>Chapter04\Examples</code> folder, add a new file called <code>LinqJoinExamples.cs</code>.</li>
<li>First, declare the <code>Manufacturer</code> and <code>Car</code> records as follows:<pre>using System;
using System.Collections.Generic;
using System.Linq;
namespace Chapter04.Examples
{
    record Manufacturer(int ManufacturerId, string Name);
    record Car (string Name, int ManufacturerId);</pre></li>
<li>Inside the <code>Main</code> entry point, create two lists, one for the manufacturers and the other to represent the <code>cars</code>:<pre>LinqJoinExamples.cs
    class LinqJoinExamples
    {
        public static void Main()
        {
            var manufacturers = new List&lt;Manufacturer&gt;
            {
                new(1, "Ford"),
                new(2, "BMW"),
                new(3, "VW")
            };
            var cars = new List&lt;Car&gt;
            {
                new("Focus", 1),
                new("Galaxy", 1),
                new("GT40", 1),</pre></li>
</ol>
<pre>You can find the complete code here: <a href="https://packt.link/Ue7Fj">https://packt.link/Ue7Fj</a>.</pre>
<ol>
<li value="4">At this point, there is no direct reference, but as you know, you can use <code>ManufacturerId</code> to link the two together using the <code>int</code> IDs. You can add the following code for this:<pre>            var joinedQuery = manufacturers.Join(
                cars,
                manufacturer =&gt; manufacturer.ManufacturerId,
                car =&gt; car.ManufacturerId,
                (manufacturer, car) =&gt; new                        {ManufacturerName = manufacturer.Name,                         CarName = car.Name});
            foreach (var item in joinedQuery)
            {
                Console.WriteLine($"{item}");
            }
        }
    }
}</pre></li>
</ol>
<p>In the preceding snippet, the <code>Join</code> operation has various parameters. You pass in the <code>cars</code> list and define which properties in the <code>manufacturer</code> and <code>car</code> classes should be used to create the join. In this case, <code>manufacturer.ManufacturerId = car.ManufacturerId</code> determines the correct join.</p>
<p>Finally, the <code>manufacturer</code> and <code>car</code> arguments return a new anonymous type that contains the <code>manufacturer.Name</code> and <code>car.Name</code> properties.</p>
<ol>
<li value="5">Running the console app produces the following output:<pre>{ ManufacturerName = Ford, CarName = Focus }
{ ManufacturerName = Ford, CarName = Galaxy }
{ ManufacturerName = Ford, CarName = GT40 }
{ ManufacturerName = BMW, CarName = 1 Series }
{ ManufacturerName = BMW, CarName = 2 Series }
{ ManufacturerName = VW, CarName = Golf }
{ ManufacturerName = VW, CarName = Polo }</pre></li>
</ol>
<p>As you can see, each of the <code>Car</code> and <code>Manufacturer</code> instances has been joined correctly using <code>ManufacturerId</code>.</p>
<ol>
<li value="6">The equivalent Query Expression would be as follows (note that in this case, it is a more concise format than the Query Operator syntax):<pre>var query = from manufacturer in manufacturers
            join car in cars
              on manufacturer.ManufacturerId equals car.ManufacturerId
              select new
              {
                ManufacturerName = manufacturer.Name, CarName = car.Name
              };
foreach (var item in query)
{
  Console.WriteLine($"{item}");
}</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this example at <a href="http://packt.link/Wh8jK">http://packt.link/Wh8jK</a>.</p></li>
</ol>
<p>Before you finish exploring LINQ, there is one more area related to LINQ Query Expressions—the <code>let</code> clause.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor202"/>Using a let Clause in Query Expressions</h2>
<p>In earlier Query Expressions, you are often required to repeat similar-looking code in various clauses. Using a <code>let</code> clause, you can introduce new variables inside an Expression Query and reuse the variable's value throughout the rest of the query. For example, consider the following query:</p>
<pre>var stations = new List&lt;string&gt;
{
    "Kings Cross KGX", 
    "Liverpool Street LVS", 
    "Euston EUS", 
    "New Street NST"
};
var query1 = from station in stations
             where station[^3..] == "LVS" || station[^3..] == "EUS" || 
                   station[0..^3].Trim().ToUpper().EndsWith("CROSS")
             select new { code= station[^3..],                           name= station[0..^3].Trim().ToUpper()};</pre>
<p>Here, you are searching for a station with the <code>LVS</code> or <code>EUS</code> code or a name ending in <code>CROSS</code>. To do this, you must extract the last three characters using a range, <code>station[^3..]</code>, but you have duplicated that in two <code>where</code> clauses and the final projection.</p>
<p>The station code and station names could both be converted into local variables using the <code>let</code> clause:</p>
<pre>var query2 = from station in stations
             let code = station[^3..]
             let name = station[0..^3].Trim().ToUpper()
             where code == "LVS" || code == "EUS" || 
                   name.EndsWith("CROSS") 
             select new {code, name};</pre>
<p>Here, you have defined <code>code</code> and <code>name</code> using a <code>let</code> clause and reused them throughout the query. This code looks much neater and is also easier to follow and maintain.</p>
<p>Running the code produces the following output:</p>
<pre>Station Codes: 
KGX : KINGS CROSS
LVS : LIVERPOOL STREET
EUS : EUSTON
Station Codes (2):
KGX : KINGS CROSS
LVS : LIVERPOOL STREET
EUS : EUSTON</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/b2KiG">https://packt.link/b2KiG</a>.</p>
<p>By now you have seen the main parts of LINQ. Now you will now bring these together into an activity that filters a set of flight records based on a user's criteria and provides various statistics on the subset of flights found.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor203"/>Activity 4.01: Treasury Flight Data Analysis</h2>
<p>You have been asked to create a console app that allows the user to download publicly available flight data files and apply statistical analysis to the files. This analysis should be used to calculate a count of the total records found, along with the average, minimum, and maximum fare paid within that subset.</p>
<p>The user should be able to enter a number of commands and each command should add a specific filter based on the flight's class, origin, or destination properties. Once the user has entered the required criteria, the <code>go</code> command must be entered, and the console should run a query and output the results.</p>
<p>The data file you will use for this activity contains details of flights made by the UK's HM Treasury department between January 1 to December 31, 2011 (there are 714 records.) You will need to use <code>WebClient.DownloadFile</code> to download the data from the following URL: <a href="https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv">https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv</a></p>
<p class="callout-heading">Note</p>
<p class="callout">The website might open differently for Internet Explorer or Google Chrome. This depends on how IE or Chrome are configured on your machine. Using <code>WebClient.DownloadFile</code>, you can download the data as suggested.</p>
<p>Ideally, the program should download data once and then reread it from the local filesystem each time it is started.</p>
<div><div><img alt="Figure 4.6: Preview of HM Treasury traffic data in Excel " height="874" src="img/B16835_04_06.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.6: Preview of HM Treasury traffic data in Excel</p>
<p>Once downloaded, the data should then be read into a suitable record structure before being added to a collection, which allows various queries to be applied. The output should show the following aggregate values for all rows that match the user's criteria:</p>
<ul>
<li>Record count</li>
<li>Average fare</li>
<li>Minimum fare</li>
<li>Maximum fare</li>
</ul>
<p>The user should be able to enter the following console commands:</p>
<ul>
<li><code>Class c</code>: Adds a class filter, where <code>c</code> is a flight class to search for, such as <code>economy</code> or <code>Business class</code>.</li>
<li><code>Origin o</code>: Adds an <code>origin</code> filter, where o is the flight origin, such as <code>dublin</code>, <code>london</code>, or <code>basel</code>.</li>
<li><code>Destination d</code>: Adds a destination filter, where <code>d</code> is the flight destination, such as <code>delhi</code>.</li>
<li><code>Clear</code>: Clears all filters.</li>
<li><code>go</code>: Applies the current filters.</li>
</ul>
<p>If a user enters multiple filters of the same type, then these should be treated as an <code>OR</code> filter.</p>
<p>An <code>enum</code> can be used to identify the filter criteria type entered, as shown in the following line of code:</p>
<pre>enum FilterCriteriaType {Class, Origin, Destination}</pre>
<p>Similarly, a record can be used to store each filter type and comparison operand, as follows:</p>
<pre>record FilterCriteria(FilterCriteriaType Filter, string Operand)</pre>
<p>Each filter specified should be added to a <code>List&lt;FilterCriteria&gt;</code> instance. For example, if the user enters two origin filters, one for <code>dublin</code> and another for <code>london</code>, then the list should contain two objects, each representing an origin type filter.</p>
<p>When the user enters the <code>go</code> command, a query should be built that performs the following steps:</p>
<ul>
<li>Extracts all <code>class</code> filter values into a list of strings (<code>List&lt;string&gt;</code>).</li>
<li>Extracts all <code>origin</code> filter values into <code>List&lt;string&gt;</code>.</li>
<li>Extracts all <code>destination</code> filter values into <code>List&lt;string&gt;</code>.</li>
<li>Uses a <code>where</code> extension method to filter the fight records for each criteria type specified using the <code>List&lt;string&gt;</code>. It contains a method to perform a case-insensitive search.</li>
</ul>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a new folder called <code>Activities</code> in the <code>Chapter04</code> folder.</li>
<li>Add a new folder called <code>Activity01</code> to that new folder.</li>
<li>Add a new class file called <code>Flight.cs</code>. This will be a <code>Record</code> class with fields that match those in the flight data. A <code>Record</code> class should be used as it offers a simple type purely to hold data rather than any form of behavior.</li>
<li>Add a new class file called <code>FlightLoader.cs</code>. This class will be used for downloading or importing data. <code>FlightLoader</code> should include a list of the field index positions within the data file, to be used when reading each line of data and splitting the contents into a string array, for example:<pre>public const int Agency = 0;
public const int PaidFare = 1; </pre></li>
<li>Now for the <code>FlightLoader</code> implementation, use a <code>static</code> class to define the index of known field positions in the data file. This will make it easier to handle any future changes in the layout of the data.</li>
<li>Next, a <code>Download</code> method should be passed a URL and destination file. Use <code>WebClient.DownloadFile</code> to download the data file and then defer to <code>Import</code> to process the downloaded file.</li>
<li>An <code>Import</code> method is to be added. This is passed the name of the local file to import (downloaded using the <code>Import</code> method) and will return a list of <code>Flight</code> records.</li>
<li>Add a class file called <code>FilterCriteria.cs</code>. This should contain a <code>FilterCriteriaType</code> <code>enum</code> definition. You will offer filters based on the flight's class, origin, and destination properties, so <code>FilterCriteriaType</code> should represent each of these.</li>
<li>Now, for the main filtering class, add a new class file called <code>FlightQuery.cs</code>. The constructor will be passed a <code>FlightLoader</code> instance. Within it, create a list named <code>_flights</code> to contain the data imported via <code>FlightLoader</code>. Create a <code>List&lt;FilterCriteria&gt;</code> instance named <code>_filters</code> that represent each of the criteria items that are added, each time the user specifies a new filter condition.</li>
<li>The <code>Import</code> and <code>Download</code> methods of <code>FlightLoader</code> should be called by the console at startup, allowing previously downloaded data to be processed, via the <code>_loader</code> instance.</li>
<li>Create a <code>Count</code> variable that returns the number of flight records that have been imported.</li>
<li>When the user specifies a filter to add, the console will call <code>AddFilter</code>, passing an <code>enum</code> to define the criteria type and the string value being filtered for.</li>
<li><code>RunQuery</code> is the main method that returns those flights that match the user's criteria. You need to use the built-in <code>StringComparer.InvariantCultureIgnoreCase</code> comparer to ensure string comparison ignores any case differences. You define a query variable that calls <code>Select</code> on the flights; at the moment, this would result in a filtered result set.</li>
<li>Each of the types of filter available is string-based, so you need to extract all the string items. If there are any items to filter, you add an extra <code>Where</code> call to the query for each type (<code>Class</code>, <code>Destination</code>, or <code>Origin</code>). Each <code>Where</code> clause uses a <code>Contains</code> predicate, which examines the associated property.</li>
<li>Next, add the two helper methods used by <code>RunQuery</code>. <code>GetFiltersByType</code> is passed each of the <code>FilterCriteriaType</code> enums that represent a known type of criteria type and finds any of these in the list of filters using the <code>.Where</code> method. For example, if the user added two <code>Destination</code> criteria such as India and Germany, this would result in the two strings <code>India</code> and <code>Germany</code> being returned.</li>
<li><code>FormatFilters</code> simply joins a list of <code>filterValues</code> strings into a user-friendly string with the word <code>OR</code> between each item, such as <code>London OR Dublin</code>.</li>
<li>Now create the main console app. Add a new class called <code>Program.cs</code>, which will allow the user to input requests and process their commands.</li>
<li>Hardcode the download URL and destination filename.</li>
<li>Create the main <code>FlightQuery</code> class, passing in a <code>FlightLoader</code> instance. If the app has been run before, you can <code>Import</code> the local flight data, or use <code>Download</code> if not.</li>
<li>Show a summary of the records imported and the available commands.</li>
<li>When the user enters a command, there might also be an argument, such as <code>destination united kingdom</code>, where <code>destination</code> is the command and <code>united kingdom</code> is the argument. To determine this, use the <code>IndexOf</code> method to find the location of the first space character in the input, if any.</li>
<li>For the <code>go</code> command, call <code>RunQuery</code> and use various aggregation operators on the results returned.</li>
<li>For the remaining commands, clear or add filters as requested. If the <code>Clear</code> command is specified, call the query's <code>ClearFilters</code> method, which will clear the list of criteria items.</li>
<li>If a <code>class</code> filter command is specified, call <code>AddFilter</code> specifying the <code>FilterCriteriaType.Class enum</code> and the string <code>Argument</code>.</li>
<li>The same pattern should be used for <code>Origin</code> and <code>Destination</code> commands. Call <code>AddFilter</code>, passing in the required <code>enum</code> value and the argument.</li>
</ol>
<p>The console output should be similar to the following, here listing the commands available to the user:</p>
<pre>Commands: go | clear | class value | origin value | destination value</pre>
<ol>
<li value="26">The user should be able to add two class filters, for <code>economy</code> or <code>Business Class</code> (all string comparisons should be case-insensitive), as shown in the following snippet:<pre>Enter a command:class economy
Added filter: Class=economy
Enter a command:class Business Class
Added filter: Class=business class</pre></li>
<li>Similarly, the user should be able to add an origin filter as follows (this example is for <code>london</code>):<pre>Enter a command:origin london
Added filter: Origin=london</pre></li>
<li>Adding the destination filter should look like this (this example is for <code>zurich</code>):<pre>Enter a command:destination zurich
Added filter: Destination=zurich</pre></li>
<li>Entering <code>go</code> should show a summary of all filters specified, followed by the results for flights that match the filters:<pre>Enter a command:go
Classes: economy OR business class
Destinations: zurich
Origins: london
Results: Count=16, Avg=266.92, Min=-74.71, Max=443.49</pre><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p></li>
</ol>
<h1 id="_idParaDest-183"><a id="_idTextAnchor204"/>Summary</h1>
<p>In this chapter, you saw how the <code>IEnumerable</code> and <code>ICollection</code> interfaces form the basis of .NET data structures, and how they can be used to store multiple items. You created different types of collections depending on how each collection is meant to be used. You learned that the <code>List</code> collection is most extensively used to store collections of items, particularly if the number of elements is not known at compile time. You saw that the <code>Stack</code> and <code>Queue</code> types allow the order of items to be handled in a controlled manner, and how the <code>HashSet</code> offers set-based processing, while the <code>Dictionary</code> stores unique values using a key identifier.</p>
<p>You then further explored data structures by using LINQ Query Expressions and Query Operators to apply queries to data, showing how queries can be altered at runtime depending on filtering requirements. You sorted and partitioned data and saw how similar operations can be achieved using both Query Operators and Query Expressions, each offering a preference and flexibility based on context.</p>
<p>In the next chapter, you will see how parallel and asynchronous code can be used to run complex or long-running operations together.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>