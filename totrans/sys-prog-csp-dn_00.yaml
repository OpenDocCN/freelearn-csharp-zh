- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: 'Most people think of **graphical user interface** (**GUI**) applications when
    they think of software. Software is the code that the user interacts with. But
    these days, that’s not true anymore. All modern applications, web servers, web
    applications, and mobile solutions mostly rely on hidden, unseen system software.
    This is the software that is built for other software. It is dormant until needed,
    then it does its job and goes back to sleep. These programs are the unsung heroes
    of our ecosystem, doing the work in the background. At the same time, GUI systems
    stand in the limelight. However, do not underestimate these hard-working systems:
    they must be extremely fast, reliable, and safe. Therefore, they are essential
    to good working systems and are hard to write. This book teaches you all you need
    to know to write these applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想到软件时，大多数人会想到**图形用户界面**（**GUI**）应用程序。软件是用户与之交互的代码。但如今，这已经不再是这样了。所有现代应用程序、网络服务器、网络应用和移动解决方案主要依赖于隐藏的、不可见的系统软件。这是为其他软件构建的软件。它在需要时才会活跃，完成工作后就会进入休眠状态。这些程序是我们生态系统的无名英雄，在后台默默工作。同时，GUI系统处于聚光灯下。然而，不要低估这些勤奋的系统：它们必须非常快速、可靠和安全。因此，它们对于良好的系统运行至关重要，而且编写起来也很困难。这本书教你所有你需要知道的内容来编写这些应用程序。
- en: Who this book is for
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书面向的对象
- en: People writing systems software are not junior developers. Ideally, you have
    a couple of years of experience developing software with C# and .NET. I will not
    explain what a variable is or how a while-loop differs from a for-loop. You know
    how to use NuGet. If I ask you to switch from Debug to Release mode in Visual
    Studio, you know what I am asking you to do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写系统软件的人不是初级开发者。理想情况下，你应有几年使用C#和.NET开发软件的经验。我不会解释变量是什么，或者while循环与for循环有何不同。你知道如何使用NuGet。如果我要求你在Visual
    Studio中将模式从Debug切换到Release，你知道我在要求你做什么。
- en: But I do not expect you to know what instructions a CPU uses. I will explain
    those when we reach that point in the book. So there is no need to be on that
    low level just yet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不期望你知道CPU使用哪些指令。当我们在书中达到那个点时，我会解释这些。所以现在没有必要深入到那个低层次。
- en: This book is for people who want to write system software. System software is
    software that is usually not visible to the regular user. However, it is essential
    to the good working of the complete software ecosystem running on your systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为那些想要编写系统软件的人准备的。系统软件通常是普通用户看不到的软件。然而，它对于运行在您系统上的完整软件生态系统的良好运行至关重要。
- en: 'This means that you must have a passion for programs that run fast and are
    stable. This also means that the software we write is not the easiest to maintain:
    readability often decreases as performance increases. This is not for the faint-hearted:
    writing this kind of software is hard-core development. But if you are curious
    about how your programs really work deep inside the heart of the machine, this
    is the book for you.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须对运行速度快且稳定的程序充满热情。这也意味着我们编写的软件不是最容易维护的：随着性能的提高，可读性往往会降低。这不是给胆小的人准备的：编写这类软件是硬核开发。但如果你对程序在机器内部深处是如何真正工作的感到好奇，这本书就是为你准备的。
- en: The lessons learned here can, of course, be applied to all sorts of projects.
    Performance and stability can benefit all programs. So, if you are ready to take
    your C# and .NET skills to the next level, follow along!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里学到的经验当然可以应用于各种项目。性能和稳定性可以惠及所有程序。所以，如果你准备好将你的C#和.NET技能提升到下一个层次，请继续阅读！
- en: What this book covers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书涵盖的内容
- en: '*Overview of Systems Programming* sets the stage and explains what systems
    programming is all about.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统编程概述*为背景设定，并解释了系统编程究竟是什么。'
- en: '[*Chapter 1*](B20924_02.xhtml#_idTextAnchor026), *The One with the Low-Level
    Secrets*, dives into the low-level APIs, the BCL and CLR, and how to use Win32
    APIs.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第1章*](B20924_02.xhtml#_idTextAnchor026)，*低级秘密那章*，深入探讨了低级API、BCL和CLR，以及如何使用Win32
    API。'
- en: '[*Chapter 2*](B20924_03.xhtml#_idTextAnchor042), *The One Where Speed Matters*,
    examines how to make your software perform as fast as possible.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第2章*](B20924_03.xhtml#_idTextAnchor042)，*速度至上那章*，探讨了如何使你的软件尽可能快地运行。'
- en: '[*Chapter 3*](B20924_04.xhtml#_idTextAnchor077), *The One with the Memory Games*,
    talks about memory handling, the garbage collector, and how to be as memory efficient
    as possible.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B20924_04.xhtml#_idTextAnchor077)，*记忆游戏那章*，讨论了内存处理、垃圾回收器以及如何尽可能提高内存效率。'
- en: '[*Chapter 4*](B20924_05.xhtml#_idTextAnchor087), *The One with the Thread Tangles*,
    looks at threads and asynchronous programming.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第4章*](B20924_05.xhtml#_idTextAnchor087)，*线程纠缠之处*，探讨了线程和异步编程。'
- en: '[*Chapter 5*](B20924_06.xhtml#_idTextAnchor111), *The One with the Filesystem
    Chronicles* , teaches input/output, file handling, encryption, and compression
    of files.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第5章*](B20924_06.xhtml#_idTextAnchor111)，*文件系统编年史之处*，教授输入/输出、文件处理、加密和文件压缩。'
- en: '[*Chapter 6*](B20924_07.xhtml#_idTextAnchor140), *The One Where Processes Whisper*,
    talks about how to make programs communicate on one machine or over a network.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第6章*](B20924_07.xhtml#_idTextAnchor140)，*进程低语之处*，讲述了如何在同一台机器或网络上使程序进行通信。'
- en: '[*Chapter 7*](B20924_08.xhtml#_idTextAnchor159), *The One with the Operating
    System Tango*, dives into the operating system’s services and how to use them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B20924_08.xhtml#_idTextAnchor159)，*操作系统探戈之处*，深入探讨了操作系统的服务和如何使用它们。'
- en: '[*Chapter 8*](B20924_09.xhtml#_idTextAnchor181), *The One with the Network
    Navigation*, discusses everything we need to know about networking in your application,
    both as a server and a client.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第8章*](B20924_09.xhtml#_idTextAnchor181)，*网络导航之处*，讨论了您在应用程序中需要了解的所有关于网络的知识，无论是作为服务器还是客户端。'
- en: '[*Chapter 9*](B20924_10.xhtml#_idTextAnchor208), *The One with the Hardware
    Handshakes*, deals with connecting to outside hardware and communicating with
    other devices.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B20924_10.xhtml#_idTextAnchor208)，*硬件握手之处*，处理连接外部硬件和与其他设备通信。'
- en: '[*Chapter 10*](B20924_11.xhtml#_idTextAnchor222), *The One with the Systems
    Check-Ups*, talks about logging and monitoring your software.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第10章*](B20924_11.xhtml#_idTextAnchor222)，*系统检查之处*，讨论了记录和监控您的软件。'
- en: '[*Chapter 11*](B20924_12.xhtml#_idTextAnchor237), *The One with the Debugging
    Dances*, is all about debugging your software.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第11章*](B20924_12.xhtml#_idTextAnchor237)，*调试舞蹈之处*，全部关于调试您的软件。'
- en: '[*Chapter 12*](B20924_13.xhtml#_idTextAnchor260), *The One with the Security
    Safeguards*, talks about the security of your software.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第12章*](B20924_13.xhtml#_idTextAnchor260)，*安全防护之处*，讨论了您软件的安全性。'
- en: '[*Chapter 13*](B20924_14.xhtml#_idTextAnchor283), *The One with the Deployment
    Dramas*, teaches you how to deploy your software to the production machines.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第13章*](B20924_14.xhtml#_idTextAnchor283)，*部署戏剧之处*，教您如何将软件部署到生产机器。'
- en: '[*Chapter 14*](B20924_15.xhtml#_idTextAnchor303), *The One with the Linux Leaps*,
    discusses the operating system that most of our software will run on: Linux.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第14章*](B20924_15.xhtml#_idTextAnchor303)，*Linux跳跃之处*，讨论了我们大部分软件将运行的操作系统：Linux。'
- en: To get the most out of this book
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了充分利用这本书
- en: I use Visual Studio 2022 as the main software development tool in this book.
    It is advisable for you to have a working knowledge of this, including creating
    console applications, class libraries, and worker services. You do not need to
    know what a Worker Service is as long as you can create a default one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中使用Visual Studio 2022作为主要的软件开发工具。建议您对此有实际了解，包括创建控制台应用程序、类库和工作者服务。只要您能创建一个默认的工作者服务，您就不需要了解工作者服务是什么。
- en: Each chapter might have software that you may want to try out. You’ll find the
    details explained in the *Technical requirements* section of the concerned chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章可能都有您可能想要尝试的软件。您将在相关章节的*技术要求*部分找到详细说明。
- en: '| **Software/hardware covered in** **the book** | **Operating** **system requirements**
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **本书涵盖的软件/硬件** | **操作系统要求** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Visual Studio | Windows 10 or 11 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio | Windows 10或11 |'
- en: '**If you are using the digital version of this book, we advise you to type
    the code yourself or access the code from the book’s GitHub repository (a link
    is available in the next section). Doing so will help you avoid any potential
    errors related to the copying and pasting** **of code.**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您使用的是这本书的数字版，我们建议您亲自输入代码或从书的GitHub仓库（下一节中有一个链接）获取代码。这样做将帮助您避免与代码复制和粘贴相关的任何潜在错误。**'
- en: Download the example code files
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载示例代码文件
- en: You can download the example code files for this book from GitHub at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET).
    If there’s an update to the code, it will be updated in the GitHub repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载这本书的示例代码文件：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET)。如果代码有更新，它将在GitHub仓库中更新。
- en: We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他来自我们丰富图书和视频目录的代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)找到。查看它们吧！
- en: Conventions used
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的约定
- en: There are a number of text conventions used throughout this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中使用了多种文本约定。
- en: '`Code in text`: Indicates code words in text, database table names, folder
    names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter
    handles. Here is an example: “ One of them is the `Share` option. We have set
    it to `FileShare.Delete` `"`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`文本中的代码`: 表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称。以下是一个示例：“其中一个选项是`Share`。我们将其设置为`FileShare.Delete`”。'
- en: 'A block of code is set as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置为以下格式：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any command-line input or output is written as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令行输入或输出都按照以下方式编写：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Bold**: Indicates a new term, an important word, or words that you see onscreen.
    For instance, words in menus or dialog boxes appear in **bold**. Here is an example:
    “**Compact object representations**: Sometimes, you can save some memory by smartly
    combining data into other data structures”.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗体**: 表示新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词以**粗体**显示。以下是一个示例：“**紧凑对象表示法**：有时，您可以通过将数据智能地组合到其他数据结构中来节省一些内存”。'
- en: Tips or important notes
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士或重要提示
- en: Appear like this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样。
- en: Get in touch
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系我们
- en: Feedback from our readers is always welcome.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终欢迎读者的反馈。
- en: '**General feedback**: If you have questions about any aspect of this book,
    email us at [customercare@packtpub.com](mailto:customercare@packtpub.com) and
    mention the book title in the subject of your message.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般反馈**: 如果您对这本书的任何方面有疑问，请通过电子邮件发送至[customercare@packtpub.com](mailto:customercare@packtpub.com)，并在邮件主题中提及书名。'
- en: '**Errata**: Although we have taken every care to ensure the accuracy of our
    content, mistakes do happen. If you have found a mistake in this book, we would
    be grateful if you would report this to us. Please visit [www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)
    and fill in the form.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误**: 尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们非常感谢您能向我们报告。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。'
- en: '**Piracy**: If you come across any illegal copies of our works in any form
    on the internet, we would be grateful if you would provide us with the location
    address or website name. Please contact us at [copyright@packt.com](mailto:copyright@packt.com)
    with a link to the material.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版**: 如果您在互联网上以任何形式发现我们作品的非法副本，我们非常感谢您能提供位置地址或网站名称。请通过[copyright@packt.com](mailto:copyright@packt.com)与我们联系，并提供材料的链接。'
- en: '**If you are interested in becoming an author**: If there is a topic that you
    have expertise in and you are interested in either writing or contributing to
    a book, please visit [authors.packtpub.com](http://authors.packtpub.com).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您有兴趣成为作者**：如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。'
- en: Share Your Thoughts
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享您的想法
- en: Once you’ve read *Systems Programming with C# and .NET*, we’d love to hear your
    thoughts! Please [click here to go straight to the Amazon review page](https://packt.link/r/1-835-08268-8)
    for this book and share your feedback.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您阅读了《使用C#和.NET进行系统编程》，我们非常乐意听到您的想法！请[点击此处直接转到该书的亚马逊评论页面](https://packt.link/r/1-835-08268-8)并分享您的反馈。
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。
- en: Download a free PDF copy of this book
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载这本书的免费PDF副本
- en: Thanks for purchasing this book!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买这本书！
- en: Do you like to read on the go but are unable to carry your print books everywhere?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢在路上阅读，但又无法携带你的印刷书籍到处走吗？
- en: Is your eBook purchase not compatible with the device of your choice?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电子书购买是否与您选择的设备不兼容？
- en: Don’t worry, now with every Packt book you get a DRM-free PDF version of that
    book at no cost.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，现在，随着每本Packt书籍，您都可以免费获得该书的DRM免费PDF版本。
- en: Read anywhere, any place, on any device. Search, copy, and paste code from your
    favorite technical books directly into your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方、任何设备上阅读。直接从您最喜欢的技术书籍中搜索、复制和粘贴代码到您的应用程序中。
- en: The perks don’t stop there, you can get exclusive access to discounts, newsletters,
    and great free content in your inbox daily
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 优惠不仅限于此，您还可以获得独家折扣、新闻通讯以及每天收件箱中的优质免费内容。
- en: 'Follow these simple steps to get the benefits:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤获取优惠：
- en: Scan the QR code or visit the link below
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描下面的二维码或访问以下链接
- en: '![Download a free PDF copy of this book'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![下载此书的免费PDF副本'
- en: '](img/B20924_QR_Free_PDF.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B20924_QR_Free_PDF.jpg)'
- en: '[https://packt.link/free-ebook/978-1-83508-268-3](https://packt.link/free-ebook/978-1-83508-268-3)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/free-ebook/978-1-83508-268-3](https://packt.link/free-ebook/978-1-83508-268-3)'
- en: Submit your proof of purchase
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的购买证明
- en: That’s it! We’ll send your free PDF and other benefits to your email directly
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就足够了！我们将直接将您的免费PDF和其他优惠发送到您的电子邮件
- en: Overview of Systems Programming
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统编程概述
- en: 'So, you want to learn about **systems programming** in .NET, using C#. At least,
    I assume you want to learn that; you probably read the title of this book and
    decided that this was a good match. Maybe you have dived into systems programming
    a bit and want to get better at it. Or, perhaps you haven’t touched that subject
    and want to start. Or, maybe you picked the wrong book. If the latter is the case,
    I hope you still have your receipt so you can return this book and get something
    else. For all others: welcome!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你想学习.NET中使用C#的**系统编程**。至少，我假设你想学习这个；你很可能读了这个书的标题，并决定这是一个好选择。也许你已经涉足系统编程，并想提高这方面的技能。或者，也许你还没有接触过这个主题，并想开始。或者，也许你选错了书。如果是后一种情况，我希望你还有收据，这样你可以退回这本书并得到其他东西。对于所有人：欢迎！
- en: Let’s define systems programming
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们定义一下系统编程
- en: Before we go into the nitty gritty details of systems programming, we need to
    set the stage. We need to have a common understanding of a couple of things. For
    instance, what does the term “systems programming” even mean? What is it for?
    Who is it for?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入系统编程的细节之前，我们需要做好铺垫。我们需要对一些事情有一个共同的理解。例如，“系统编程”这个术语到底是什么意思？它是用来做什么的？它是为谁准备的？
- en: Let me get started with a definition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从定义开始。
- en: '*Systems programming is the programming of systems*. That might technically
    be correct, but I don’t think it helps us move forward.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统编程是系统的编程。这在技术上可能是正确的，但我认为这并不能帮助我们前进。*'
- en: 'Let us break it down: what is a *system*?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：什么是**系统**？
- en: That one is easy. We have been building systems for ages, so we understand what
    we mean by a **system**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那个很简单。我们构建系统已经有很多年了，所以我们知道我们所说的**系统**是什么意思。
- en: 'Let me show you one definition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你展示一个定义：
- en: '*A system is a set or arrangement of things that are related or connected so
    as to form a unity or organic whole. It is a collection of components or parts
    that interact with each other to function. This term is used in various fields
    such as physics, biology, computer science, and business management, each with
    slightly* *different connotations.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统是一组或排列相关或连接的物品，以便形成一个统一体或有机整体。它是一组相互作用的组件或部分，以实现功能。这个术语在物理学、生物学、计算机科学和商业管理等各个领域都有使用，每个领域都有略微不同的含义。*'
- en: 'Great. But this definition is a bit broad. We might want to focus on computer
    science or software development. No problem; there are several definitions to
    choose from as well:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。但这个定义有点宽泛。我们可能想专注于计算机科学或软件开发。没问题；也有几个定义可以选择：
- en: '*A system is a collection of software components that interact to perform a
    specific function or set* *of functions*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统是一组相互交互以执行特定功能或一系列功能的软件组件。*'
- en: 'That is a lot better. If we dive into this a bit further, we can distinguish
    between different groups of systems:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更好了。如果我们进一步深入探讨，我们可以区分不同的系统组：
- en: '**Software systems**: This is an integrated set of software components that
    work together to carry out a specific function or set of functions. Those components
    can be a database server, micro-services, and a frontend. Those components form
    the complete system, such as a CRM system, source control repository system, and
    others like that.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件系统**：这是一个集成的软件组件集合，它们一起执行特定的功能或一系列功能。这些组件可以是数据库服务器、微服务和一个前端。这些组件构成了完整的系统，例如CRM系统、源代码控制系统和其他类似系统。'
- en: '**Operating systems (OSs)**: You probably know what an OS is. I think you have
    seen that term so often that there is a fair chance you didn’t even realize it
    is a system. But it most definitely is an OS that contains many parts and components,
    such as drivers, tools, helpers, and logs. Together, they deliver a system you
    as a user can use to run your software on, independently of the hardware.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统（OSs）**：你可能知道什么是操作系统。我认为你看到这个术语太多次了，以至于你甚至没有意识到它是一个系统。但确实是一个包含许多部分和组件的操作系统，如驱动程序、工具、辅助工具和日志。它们共同提供了一个系统，你可以作为用户使用它来运行你的软件，而不依赖于硬件。'
- en: '**Distributed systems**: We often refer to loosely connected components on
    a network as a distributed system. Each part is isolated from the others, but
    they must collaborate to achieve something worthwhile. For example, Azure DevOps
    runs on many different servers in the Azure cloud. All the components run potentially
    on different servers and machines, and these components can even be running in
    different parts of the world. However, they work together to form a complete solution
    for the end user.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式系统**：我们通常将网络上松散连接的组件称为分布式系统。每个部分都是相互隔离的，但它们必须协作以实现有价值的目标。例如，Azure DevOps在Azure云中的许多不同服务器上运行。所有组件可能运行在不同的服务器和机器上，这些组件甚至可能运行在世界上的不同部分。然而，它们共同工作，为最终用户提供一个完整的解决方案。'
- en: '**Embedded systems**: An embedded system is usually a combination of hardware
    and software. The components are tightly coupled with each other. Developers usually
    write the software to match specific specifications so it uses the hardware best.
    Think, for instance, about the systems in your car. If you have a reasonably recent
    car, you undoubtedly have an entertainment system on board. The word “system”
    in “entertainment system” is a bit of a giveaway: it consists of many distinct
    components. There is very likely a device that can collect electromagnetic waves
    from the air (we call that a radio). That device is connected to some software
    that interprets those waves and turns them into an electrical signal to feed the
    speakers. Next to that, a component shows you, as the user, what you are listening
    to. I am sure you can find a lot of other systems in your car and probably in
    your TV, your phone, or your refrigerator.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式系统**：嵌入式系统通常是由硬件和软件的组合。组件之间紧密耦合。开发者通常编写软件以匹配特定的规格，以便最好地使用硬件。例如，想想你车上的系统。如果你有一辆相当新的车，你无疑在车上有一个娱乐系统。在“娱乐系统”这个词中，“系统”这个词有点提示：它由许多不同的组件组成。很可能有一个设备可以从空气中收集电磁波（我们称之为收音机）。该设备连接到一些软件，这些软件解释这些波并将其转换为电信号以供扬声器使用。旁边，一个组件会向你，作为用户，显示你正在听的内容。我确信你可以在你的车上找到很多其他系统，也许在你的电视、手机或冰箱上也能找到。'
- en: There are many more examples, but I hope you see that a system always consists
    of individual components that are not useful on their own but, when combined,
    deliver a solution to a problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的例子，但我希望你能看到，一个系统总是由单独的组件组成，这些组件单独使用时没有用处，但结合在一起，可以解决一个问题。
- en: But hold on. We are not done yet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。我们还没有完成。
- en: Given these definitions and examples, you might think that the art of systems
    programming is just the programming of these systems, and you would not be wrong.
    But that is, in general, not what systems programming means. It most certainly
    is not what I mean by that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义和例子，你可能会认为系统编程的艺术就是这些系统的编程，你不会错。但通常情况下，系统编程并不是这个意思。我所说的系统编程绝对不是这个意思。
- en: 'Very, very roughly, we can divide software into two types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大概、非常粗略地来说，我们可以将软件分为两种类型：
- en: '**User-facing software**: This is software written to be used by people. It
    has a **user interface** (**UI**) with buttons, lists, labels, and more. People
    interact with the software by using various means of input modalities.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向用户的软件**：这是一种为人们编写的软件。它有一个用户界面（UI），包括按钮、列表、标签等。人们通过使用各种输入方式与软件进行交互。'
- en: '**Software-facing software**: This is software designed to be used by other
    software. There are no UIs since we have no users. We could say other components
    are the users, but when I say users, I mean people. Software-facing software interacts
    with other components through APIs, RPC (Remote Procedure Calls) calls, file transfer,
    and many other ways. No humans are involved in this.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向软件的软件**：这是一种为其他软件设计的软件。由于我们没有用户，所以没有用户界面（UI）。我们可以说是其他组件是用户，但当我提到用户时，我指的是人。面向软件的软件通过API、RPC（远程过程调用）调用、文件传输以及许多其他方式与其他组件交互。在这个过程中不涉及任何人类。'
- en: It is the second type we are most interested in here in this book – software
    meant to be used by other software.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我们最感兴趣的第二种类型——软件是为了被其他软件使用的。
- en: When is a system user-facing and when is it not?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统何时是面向用户的，何时不是？
- en: It is not always clear when people are the primary users of some code or when
    other processes are. We could be very rigorous and say that anything with a UI
    is user-oriented; anything else is systems-oriented. That will make life easier
    for us if we want a clear definition. However, in the real world, the boundaries
    tend to blur.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是清楚人们是某些代码的主要用户还是其他进程。我们可以非常严谨地说，任何带有UI的东西都是面向用户的；其他一切都是面向系统的。如果我们想要一个明确的定义，这将使生活更容易。然而，在现实世界中，边界往往变得模糊。
- en: 'Let me give you an example. Have a look at this Visual Studio Solution:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子。看看这个Visual Studio解决方案：
- en: "![Figure \uFEFF\uFEFF0.1: Solution Explorer with the Calculator project](img/B20924_01_01.jpg)"
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图0.1：带有计算器项目的解决方案资源管理器](img/B20924_01_01.jpg)'
- en: 'Figure 0.1: Solution Explorer with the Calculator project'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.1：带有计算器项目的解决方案资源管理器
- en: We have a very, very simple solution here. It has a main program called `MyAwesomeCalculator`
    that contains the main code. This is the entry point of our app, using the console
    as the UI. All logic is in the `MathFunctions` class library. This is where the
    magic happens.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有一个非常、非常简单的解决方案。它有一个名为`MyAwesomeCalculator`的主程序，其中包含主代码。这是我们的应用程序的入口点，使用控制台作为UI。所有逻辑都在`MathFunctions`类库中。这就是魔法发生的地方。
- en: If we go back to our definition of Systems programming, we could say that writing
    the `MathFunctions` class library is part of Systems programming. After all, no
    user will ever interact with the classes and interfaces in that library. It is
    the code in `MyAwesomeCalculator` that actually uses it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们对系统编程的定义，我们可以说编写`MathFunctions`类库是系统编程的一部分。毕竟，没有用户会与该库中的类和接口交互。真正使用它的代码是`MyAwesomeCalculator`中的代码。
- en: Great! This means writing the `MathFunctions` library is systems programming!
    Well, not so fast. We might come to another conclusion if we look at the sequence
    diagram that explains the flow. *Figure 0**.2* shows this sequence diagram.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这意味着编写`MathFunctions`库是系统编程！嗯，但别急。如果我们看看解释流程的序列图，我们可能会得出另一个结论。*图0.2*展示了这个序列图。
- en: "![Figure \uFEFF\uFEFF0.2: Sequence diagram for our calculations](img/B20924_01_02.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图0.2：我们的计算序列图](img/B20924_01_02.jpg)'
- en: 'Figure 0.2: Sequence diagram for our calculations'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.2：我们的计算序列图
- en: 'As you can see in *Figure 0**.2*, the user initiates an operation: they want
    to add up two numbers. They enter it in the UI of the `Main` class. The `Main`
    class then instantiates an instance of the `Adder` class. After that creation,
    the `Main` class calls the `AddUp(a,b)` method. The result is passed back to the
    `Main` class and shown to the user. After all this, we could discard the `Adder`
    instance.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图0.2*中看到的，用户启动了一个操作：他们想要将两个数字相加。他们在`Main`类的UI中输入它。然后`Main`类实例化`Adder`类的一个实例。在创建之后，`Main`类调用`AddUp(a,b)`方法。结果被传回`Main`类并展示给用户。在这之后，我们可以丢弃`Adder`实例。
- en: Great. Where are the boundaries? If we look at it this way, we could say that
    the code in `Adder` and, thus, in the `MathFunctions` library is immediately tied
    to user actions. So, it is user-facing code instead of systems-facing code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。边界在哪里？如果我们这样看，我们可以说`Adder`中的代码以及因此`MathFunctions`库中的代码与用户操作直接相关。所以，它是面向用户的代码，而不是面向系统的代码。
- en: I still like to use the question of who is using the code to determine what
    kind of software we are writing. But apparently, this is not enough. We need to
    go a bit deeper.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然喜欢用谁在使用代码的问题来确定我们正在编写什么类型的软件。但显然，这还不够。我们需要深入一点。
- en: The code in `MyAwesomeCalculator` and `MathFunctions` are in separate assemblies.
    The user interacts with one assembly; the other is accessed through code only.
    But they can still be seen as one. If we run the application, the runtime creates
    `AppDomain` for us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAwesomeCalculator`和`MathFunctions`中的代码在单独的组件中。用户与一个组件交互；另一个组件仅通过代码访问。但它们仍然可以被视为一个整体。如果我们运行应用程序，运行时将为我们创建`AppDomain`。'
- en: '`AppDomain` in .NET is different than `AppDomain` in .NET Framework. The latter
    had more ways to isolate code from each other. That was nice, but it was a typical
    Windows feature. That did not translate well to other platforms. So, to make .NET
    applications run on other platforms, they needed to redesign this. This results
    in `AppDomain` being less restrictive than it used to be. Still, `AppDomain` remains
    a logical boundary between different processes. Code runs in one app domain and
    cannot access other app domains directly.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的`AppDomain`与.NET Framework中的`AppDomain`不同。后者有更多方式将代码彼此隔离。这很好，但它是一个典型的Windows功能。这不太适合其他平台。因此，为了使.NET应用程序在其他平台上运行，它们需要重新设计这一点。这导致`AppDomain`比以前不那么限制性。尽管如此，`AppDomain`仍然是不同进程之间的逻辑边界。代码在一个应用程序域中运行，不能直接访问其他应用程序域。
- en: 'Here, we have another clue: our `MyAwesomeCalculator` app and the associated
    `MathFunctions` assembly all run in the same `AppDomain`. To the OS, they are
    one. Since we decided that actual people use the `Main` method, the same applies
    to all other pieces of code in that particular `AppDomain`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们又有另一个线索：我们的`MyAwesomeCalculator`应用程序和相关的`MathFunctions`程序集都在同一个`AppDomain`中运行。对于操作系统来说，它们是同一个。由于我们决定实际的人使用`Main`方法，所以这也适用于该特定`AppDomain`中的所有其他代码片段。
- en: Let’s rewrite our solution a bit. See the following screenshot.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微重写一下我们的解决方案。请看下面的截图。
- en: "![Figure \uFEFF\uFEFF0.3: Our solution with a worker process](img/B20924_01_03.jpg)"
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图0.3：带有工作进程的我们的解决方案](img/B20924_01_03.jpg)'
- en: 'Figure 0.3: Our solution with a worker process'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.3：带有工作进程的我们的解决方案
- en: We removed the class library with the code that did all the work. Instead, we
    created a new project. That project is a **worker process**. Technically, I should
    have kept that class library and referenced that, but I wanted to keep things
    simple.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了包含所有工作的代码的类库。相反，我们创建了一个新的项目。这个项目是一个**工作进程**。技术上，我应该保留那个类库并引用它，但我希望保持事情简单。
- en: A worker process is a background process that runs all the time (not technically
    true, but for now, this is true enough). It just sits there doing nothing. Then,
    suddenly, something of interest happens, and it comes to life, does its job, and
    goes to idle mode again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 工作进程是一个始终运行的后台进程（在技术上并不完全正确，但就现在而言，这已经足够了）。它只是坐在那里什么也不做。然后，突然，发生了有趣的事情，它活跃起来，完成工作，然后再次进入空闲模式。
- en: As shown in *Figure 0**.4*, the sequence diagram in this case is also slightly
    different.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图0**.4*所示，在这种情况下，序列图也有所不同。
- en: "![Figure \uFEFF\uFEFF0.4: Sequence diagram for the new revised architecture](img/B20924_01_04.jpg)"
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图0.4：新修订架构的序列图](img/B20924_01_04.jpg)'
- en: 'Figure 0.4: Sequence diagram for the new revised architecture'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.4：新修订架构的序列图
- en: '`MyAwesomeCalculator` and the `MathFunctionServices` worker are now independent
    of each other. They each run in their own `AppDomain`. When the user wants to
    perform the calculation, they enter this in the UI, which invokes the service.
    The `Worker` class picks up the command, creates an instance of the `Adder` class,
    calls the `AddUp` method, and then calls the `MyAwesomeCalculator` again with
    the results.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAwesomeCalculator`和`MathFunctionServices`工作进程现在是相互独立的。它们各自在自己的`AppDomain`中运行。当用户想要执行计算时，他们在UI中输入，这会调用服务。`Worker`类获取命令，创建`Adder`类的实例，调用`AddUp`方法，然后再次使用结果调用`MyAwesomeCalculator`。'
- en: As you can see, the calls between all classes are synchronous (designated by
    a line with a solid arrowhead) except for the call between `Main` and `Worker`.
    That is asynchronous (designated by a line and an open arrowhead).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有类之间的调用都是同步的（由实心箭头线表示），除了`Main`和`Worker`之间的调用。这是异步的（由线和开放箭头表示）。
- en: That makes sense; the calculator cannot know whether the command has arrived
    or the service is listening. It just does a fire-and-forget, crosses its digital
    fingers, and hopes for the best.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的；计算器无法知道命令是否到达或服务是否正在监听。它只是发射并忘记，交叉着数字手指，希望一切顺利。
- en: This is more like it. This is genuinely writing software used by other software
    (I am talking about `MathFunctionServices` here, not `MyAwesomeCalculator`).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这更接近了。这确实是编写供其他软件使用的软件（我在这里谈论的是`MathFunctionServices`，而不是`MyAwesomeCalculator`）。
- en: I have not shown you how the code in `Main` calls `Worker` and how the result
    flows back from `Worker` to `Main`. After all, they are in separate app domains.
    So, they cannot share memory, right? That is correct. I did not show you that.
    But do not worry. I have a couple of chapters dedicated to this.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有向你展示`Main`中的代码是如何调用`Worker`的，以及结果是如何从`Worker`流回`Main`的。毕竟，它们位于不同的应用程序域中。因此，它们不能共享内存，对吗？这是正确的。我没有向你展示这一点。但不要担心，我有一些章节专门讨论这个问题。
- en: It is important to realize that `MathFunctionServices` does not have a UI in
    the ordinary sense of the word. No user ever touches this code. It lies there,
    dormant, until its services are required. If we compare that to the first example,
    we see the differences. That first example had all code loaded on the user’s demand,
    and it somehow all responded to the users’ actions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到`MathFunctionServices`在通常意义上并没有用户界面。没有用户会触摸这段代码。它在那里，处于休眠状态，直到需要其服务。如果我们将其与第一个例子进行比较，我们会看到差异。第一个例子中，所有代码都是在用户需求下加载的，并且它们以某种方式对用户的操作做出响应。
- en: A better definition
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更好的定义
- en: So, if we combine all of this, we can determine that systems programming is
    the art of writing components that can perform a function or a set of functions
    but interact only with other components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们结合所有这些，我们可以确定系统编程是编写能够执行功能或一系列功能但仅与其他组件交互的组件的艺术。
- en: That is what this book is all about. We will learn how to write software that
    is to be consumed by other software. That is a whole other way of looking at software,
    requirements, design considerations, and more compared to software meant for humans.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是本书的主题。我们将学习如何编写将被其他软件消费的软件。与面向人类的软件相比，这是一种完全不同的看待软件、需求、设计考虑等方面的方式。
- en: 'Writing software for software means other ways of thinking about communications,
    performance, memory usage, security, and so on. All those topics are covered here
    in this book. Now, you might say: “But wait a minute. Software written for users
    should also keep performance in mind!” You are right, but software communicating
    with software has unique needs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为软件编写软件意味着以其他方式思考通信、性能、内存使用、安全性等问题。本书中涵盖了所有这些主题。现在，你可能会说：“等等，为用户编写的软件也应该考虑到性能！”你说得对，但与面向人类的软件相比，软件之间的通信有独特的需求。
- en: Later chapters show how you can achieve the desired performance and explain
    why this is important. Let us agree that a component, potentially called thousands
    of times per second, could use more thought about performance than a screen with
    a button that a user might click once an hour. I am exaggerating here, but I am
    sure you get the point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将展示如何实现期望的性能，并解释为什么这一点很重要。让我们达成共识：一个可能每秒被调用数千次的组件，在性能方面需要比一个用户可能每小时点击一次的按钮屏幕投入更多的思考。我在这里夸张了，但我相信你明白了这个观点。
- en: The same applies to memory consumption. I believe we should always write all
    software with memory consumption in mind. However, a component that gets used
    frequently by many other systems tends to be much more vulnerable to issues with
    memory than other software programs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于内存消耗。我相信我们始终应该考虑到内存消耗来编写所有软件。然而，一个被许多其他系统频繁使用的组件，往往比其他软件程序更容易受到内存问题的困扰。
- en: Performance and memory pressure are essential when we think about writing embedded
    systems. Embedded software usually runs on very limited hardware, so we have to
    try and take advantage of every trick in the book to get it running as fast as
    possible and using as little memory as possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考编写嵌入式系统时，性能和内存压力是至关重要的。嵌入式软件通常在非常有限的硬件上运行，因此我们必须尽力利用书中所有的技巧，使其尽可能快地运行，并尽可能少地使用内存。
- en: As promised, we will spend much time looking at ways to communicate with these
    types of software.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们将花大量时间研究与这类软件通信的方法。
- en: To me, Systems programming is the purest form of software development. It is
    all about algorithms, tweaks, and trying out every trick in the book to get the
    most out of it. systems programming is the major league of software development.
    When you have this covered, all other software you write will also benefit from
    your newfound knowledge. What you learn when writing systems software will become
    second nature, and you will improve your overall software writing skills. Does
    this sound exciting? Then, let’s get started!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，系统编程是软件开发最纯粹的形式。它全部关乎算法、微调，以及尝试书中所有的技巧来最大限度地利用它。系统编程是软件开发的大联盟。当你掌握了这些，你编写的所有其他软件也将从你新获得的知识中受益。你在编写系统软件时所学的知识将变得习以为常，并且你会提高你的整体软件开发技能。这听起来令人兴奋吗？那么，让我们开始吧！
- en: Using C# and .NET in systems programming
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在系统编程中使用 C# 和 .NET
- en: We already run into a problem. You most likely are a C# developer. Maybe you
    are a VB.Net developer. But no matter what language, you are a .NET developer.
    After all, that is what this book is about.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了一个问题。你很可能是 C# 开发者。也许你是 VB.Net 开发者。但无论什么语言，你都是 .NET 开发者。毕竟，这本书就是关于这个的。
- en: 'Traditionally, Systems programming is done in Assembly, C, and C++. Systems
    programming has always been the realm of hardcore developers who know the systems
    they are working on inside out. In the early 50s of the last century, people wrote
    systems software using switches. A switch in the up position meant a 1, and a
    switch in the down position meant a 0\. These early computers had 8, 16, or even
    more switches that pointed to the memory address to read or write. Then, 8 switches
    represented all the bits in a byte for that memory address. Above these switches,
    there were little lights (no, not LEDS: that invention happened later). Those
    little lights, if illuminated, meant a 1 in that byte (and a 0 if not illuminated).
    That way, you could read the contents of that memory address.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，系统编程是在汇编语言、C 和 C++ 中完成的。系统编程一直是那些对所从事的系统了如指掌的硬核开发者的领域。在上个世纪的五十年代初期，人们使用开关编写系统软件。开关处于向上位置表示
    1，而处于向下位置表示 0。这些早期的计算机有 8、16 或更多的开关，指向读取或写入的内存地址。然后，8 个开关代表该内存地址的字节中的所有位。在这些开关之上，有一些小灯（不，不是
    LED：那个发明发生得晚些）。这些小灯，如果点亮，表示该字节中的 1（如果没有点亮，则表示 0）。这样，你就可以读取该内存地址的内容。
- en: 'Do not worry; that kind of low-level programming is not the topic of this book.
    If you are interested, there are good remakes of the original Altair 8800 that
    started a company called Microsoft. You can program that computer in this way:
    use the switches and lights on the front panel to enter your software. That is
    how Bill Gates and Paul Allen wrote their first software. But we have other tools
    at our disposal.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心；这种低级编程不是这本书的主题。如果你感兴趣，有很好的 Altair 8800 复制品，它开启了一家名为微软的公司。你可以用这种方式编程这台计算机：使用前面板上的开关和灯来输入你的软件。这就是比尔·盖茨和保罗·艾伦编写他们第一份软件的方式。但我们有其他工具可以利用。
- en: Since systems software relies on efficient, fast, and memory-aware code, people
    often use programming languages close to the metal. That usually means using language
    such as machine code – such as the switches I mentioned earlier. Assembly language
    is another language used, especially in the seventies and eighties of the last
    century. C and later C++ are other examples of languages that can take advantage
    of the specifics of the hardware. Most parts of Windows, for instance, are written
    in C.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统软件依赖于高效、快速和内存感知的代码，人们通常使用接近硬件的编程语言。这通常意味着使用机器代码之类的语言——例如我之前提到的开关。汇编语言是另一种使用的语言，尤其是在上个世纪的七十年代和八十年代。C
    和后来的 C++ 是其他可以利用硬件特定功能的语言示例。例如，Windows 的大部分代码都是用 C 编写的。
- en: However, systems developers do not restrict themselves to low-level languages
    only. Let me give you an example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，系统开发者并不局限于低级语言。让我给你举一个例子。
- en: Higher-level languages for systems programming
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统编程的高级语言
- en: 'In 1965, IBM published a manual called *PL/I Language Specifications. C28-6571*.
    This relatively obscure title is a fascinating read: it outlines the specifications
    of the **PL/I programming language**. **PL/I**, a sort of abbreviation for **Programming
    Language One**, is a higher-level programming language. It contains block structures
    to allow for recursion, many different datatypes, exception handling, and many
    other features we take for granted today. It truly was a high-level language.
    However, they used it to write parts of the early OSs inside IBM. Remember, this
    was in the sixties when every microsecond counted. Machines were extremely slow
    compared to modern systems, so they had to utilize every trick in the book to
    make things work. Yet, a high-level language was considered appropriate. That
    means there is no reason not to use a high-level language today, especially considering
    memory profilers’ compiler techniques and advantages.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在1965年，IBM发布了一本名为《PL/I语言规范 C28-6571》的手册。这个相对冷门的书名读起来非常有趣：它概述了**PL/I编程语言**的规范。**PL/I**，即**Programming
    Language One**的缩写，是一种高级编程语言。它包含块结构以允许递归，许多不同的数据类型，异常处理，以及我们今天视为理所当然的许多其他特性。它确实是一种高级语言。然而，他们用它来编写IBM早期操作系统的部分。记住，这是六十年代，当时每毫秒都很宝贵。与现在的系统相比，机器运行得非常慢，所以他们不得不利用书中的每一个技巧来使事情工作。然而，高级语言被认为是合适的。这意味着今天没有理由不使用高级语言，尤其是考虑到内存分析器和编译器的技术优势。
- en: Kernel mode and user mode
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模式与用户模式
- en: OSs and drivers are usually not built using .NET. The reason for this is that
    drivers and most parts of the OS run in kernel mode.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（OSs）和驱动程序通常不是使用.NET构建的。原因是驱动程序和操作系统的绝大部分都在内核模式（kernel mode）下运行。
- en: 'The CPU in your computer can run in two modes: **kernel** or **system mode
    and user mode**. User mode is where most of the applications run. The CPU shields
    the applications from using other memory or process spaces. The CPU protects the
    applications by placing them in a sandbox. That is precisely what you would want:
    it would be very undesirable for a program to snoop around in another application’s
    memory. The processor handles this level of security.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你电脑中的CPU可以运行在两种模式下：**内核模式**或**系统模式**和**用户模式**。用户模式是大多数应用程序运行的地方。CPU通过将应用程序放置在沙盒中来保护应用程序，防止它们使用其他内存或进程空间。处理器通过这种方式处理这一级别的安全性。
- en: 'Kernel mode, however, does not have those limitations. Software running in
    kernel mode is less restricted, controlled, and trusted. That makes sense: parts
    of an OS should be able to run in all parts of the system, including in the space
    of other applications.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内核模式没有这些限制。在内核模式下运行的软件受到的限制较少，控制较少，且更受信任。这是有道理的：操作系统的某些部分应该能够在系统的所有部分运行，包括在其他应用程序的空间中。
- en: However, to run in kernel, the compiled code needs to have certain flags set,
    and the layout of the binaries should be very specific. That is the problem we
    face. Our C# code relies heavily on the .NET Runtime, and that runtime is not
    built to be used in Kernel mode. So, even if we could compile our code so that
    the OS would accept it, it still would not work due to the app not loading the
    runtime.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要在内核模式下运行，编译的代码需要设置某些标志，二进制文件的布局应该非常具体。这正是我们面临的问题。我们的C#代码严重依赖于.NET运行时，而这个运行时不是为在内核模式下使用而构建的。所以，即使我们能够编译我们的代码以便操作系统接受它，由于应用程序没有加载运行时，它仍然无法工作。
- en: There are ways around this. There are ways to pre-compile and include the runtime
    classes in your binary. Then, you can modify that binary to run in kernel mode.
    However, the results may vary, and the whole thing would be unreliable. Unreliable
    code is the exact opposite of what a device driver or OS part should be, so we
    will not get into this in this book. It’s a hack, not a standard way of working.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以绕过这个问题。有方法可以预编译并将运行时类包含到你的二进制文件中。然后，你可以修改这个二进制文件以在内核模式下运行。然而，结果可能会有所不同，整个过程将是不可靠的。不可靠的代码与设备驱动程序或操作系统部分应该具备的特性正好相反，所以我们不会在本书中涉及这一点。这是一个黑客行为，而不是一种标准的工作方式。
- en: Although this book does not deal with kernel-mode apps, I want to give you some
    insight. Especially since systems programming is usually programming “close to
    the metal,” so to speak, we are interacting with systems that are running in kernel
    mode.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书没有涉及内核模式应用程序，但我想要给你一些见解。特别是，因为系统编程通常可以称为“接近金属”的编程，也就是说，我们正在与在内核模式下运行的系统交互。
- en: 'Kernel mode is a mode in the CPU. A system can request the CPU to turn on kernel
    mode. If the code requesting it has the proper privileges, the CPU will do so,
    thus unlocking parts of the memory previously unavailable. The code does what
    it needs to do, and then the CPU returns to user mode. Since the code is still
    in memory doing all sorts of things, it is quite wrong to say an app is a kernel
    or user-mode app. Some apps can switch the CPU into that state, but the app is
    almost always running in mixed mode: most of the time, it is in user mode, sometimes
    kernel mode. Oh, and when I say CPU, I mean **logical CPU**. This toggling happens
    on that level, not on the chip itself (but it can also do that).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式是CPU的一种模式。系统可以请求CPU打开内核模式。如果请求它的代码具有适当的权限，CPU就会这样做，从而解锁之前不可用的内存部分。代码执行它需要执行的操作，然后CPU返回用户模式。由于代码仍然在内存中执行各种操作，所以说一个应用程序是内核或用户模式应用程序是非常错误的。一些应用程序可以将CPU切换到那种状态，但应用程序几乎总是以混合模式运行：大多数时间在用户模式，有时在内核模式。哦，当我提到CPU时，我指的是**逻辑CPU**。这种切换发生在那个层面，而不是在芯片本身（但它也可以做到）。
- en: I have Adobe Creative Cloud installed on my machine. We all know Photoshop,
    Illustrator, and Premiere, but these apps are meant to be accessed through the
    Creative Cloud app. This app monitors the system and launches any app you need
    when you need it. It also updates the background and keeps track of your fonts,
    files, colors, and other things like that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的机器上安装了Adobe Creative Cloud。我们都知道Photoshop、Illustrator和Premiere，但这些应用程序旨在通过Creative
    Cloud应用程序访问。此应用程序监控系统，并在需要时启动所需的任何应用程序。它还会更新背景，并跟踪您的字体、文件、颜色和其他类似事物。
- en: Whenever you read something like “runs in the background,” you might expect
    some systems programming going on, and indeed, there is.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您读到“在后台运行”这样的内容时，您可能会期望有一些系统编程在进行，确实如此。
- en: For example, I get this image if I start `% Privileged Time` and `% User Time`
    counters for the Adobe Desktop Service process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我启动Adobe桌面服务进程的`% Privileged Time`和`% User Time`计数器，我会得到这个图像。
- en: "![Figure \uFEFF\uFEFF0.5: Performance \uFEFFMonitor showing kernel and user\
    \ times](img/B20924_01_05.jpg)"
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图0.5：性能监视器显示内核和用户时间](img/B20924_01_05.jpg)'
- en: 'Figure 0.5: Performance Monitor showing kernel and user times'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.5：性能监视器显示内核和用户时间
- en: The red line in *Figure 0**.5* shows how much time the Adobe Desktop Service
    spends in user time. The green line, however, shows how long the service is running
    in privileged time, and privileged time is just a fancy term for kernel time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图0.5*中，红线显示了Adobe桌面服务在用户时间中花费的时间。然而，绿色线显示服务在特权时间中运行的时间，而特权时间只是内核时间的另一种说法。
- en: As you can see, this app is doing much work in the kernel time. Although I have
    to admit, I have no clue what it is doing there, but I am sure it is all for a
    good reason.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此应用程序在内核时间中做了大量工作。虽然我必须承认，我对它在那里做什么一无所知，但我确信它肯定有很好的理由。
- en: We will encounter kernel mode later in other chapters but we will not build
    apps that run in it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他章节中遇到内核模式，但我们将不会构建在其中运行的应用程序。
- en: Why use .NET?
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用.NET？
- en: 'So, we established that we cannot build an OS or a device driver in .NET. That
    might lead to the question: “Can we use .NET for systems programming?” The answer
    is a big yes. Otherwise, this would have been a very thin and short book.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们确定我们无法在.NET中构建操作系统或设备驱动程序。这可能会引发问题：“我们能否使用.NET进行系统编程？”答案是肯定的。否则，这将是一本非常薄且简短的书。
- en: Shall we have a look at our recently discovered definition of systems programming?
    “Writing software used by other software, as a part of a bigger system that works
    together to achieve a certain goal.” I have shortened the definition, but it is
    all about this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该看看我们最近发现的系统编程的定义？“编写用于其他软件的软件，作为更大系统的一部分，共同实现某个目标。”我简化了这个定义，但它就是这个意思。
- en: 'Looking at it this way, we can use .NET to write that software. Better yet:
    I bet .NET is one of the best choices to do so.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，我们可以使用.NET来编写这样的软件。更好的是：我敢打赌.NET是做这件事的最佳选择之一。
- en: .NET offers many advantages over plain C or even C++ (not the managed kind of
    C++, that is still .NET.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: .NET相对于纯C或甚至C++（不是托管类型的C++，那种仍然是.NET）提供了许多优势。
- en: Back in the day, when we used .NET-Framework-based applications, it would have
    been a bad idea to use that for systems programming. However, with the introduction
    of the latest versions of .NET, many disadvantages have been taken care of. With
    many disadvantages out of the way, .NET-based systems are a viable choice for
    these kinds of systems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我们使用基于 .NET Framework 的应用程序时，将其用于系统编程是个糟糕的主意。然而，随着最新版本的 .NET 的引入，许多缺点都得到了解决。随着许多缺点被消除，基于
    .NET 的系统成为这些类型系统的可行选择。
- en: C and C++ still are excellent languages for low-level systems code. However,
    C# and .NET Core have their advantages as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 仍然是底层系统代码的优秀语言。然而，C# 和 .NET Core 也有其优势。
- en: This table lays out the differences.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此表列出了差异。
- en: '| **Topic** | **C# and .****net core** | **C/C++** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **主题** | **C# 和 .NET Core** | **C/C++** |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Performance | .NET Core has improved performance compared to .NET Framework,
    but there may still be overhead due to its runtime. This won’t be an issue for
    most applications, but it could matter for highly performance-critical systems.
    | C/C++ provides direct control over hardware and, with careful optimization,
    can yield superior performance in performance-critical systems. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 与 .NET Framework 相比，.NET Core 的性能有所提高，但由于其运行时，可能仍然存在开销。这对大多数应用程序来说不会是问题，但对于高度性能关键的系统来说可能很重要。
    | C/C++ 提供了对硬件的直接控制，并且通过仔细优化，可以在性能关键系统中提供优越的性能。 |'
- en: '| Memory management | .NET Core still provides automatic garbage collection,
    reducing the chance of memory leaks, but it gives less control to the developer.
    This is more suitable for application-level programming. | C/C++ gives developers
    direct control over memory allocation and deallocation, making it more suitable
    for systems programming that requires fine-grained memory management. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 内存管理 | .NET Core 仍然提供自动垃圾回收，减少了内存泄漏的机会，但给予开发者的控制较少。这更适合应用级编程。 | C/C++ 允许开发者直接控制内存分配和释放，使其更适合需要精细内存管理的系统编程。
    |'
- en: '| System-level programming | Some system-level programming tasks may still
    be more difficult in .NET Core due to its higher-level abstractions and safety
    features. | C/C++ is often used for system-level programming because it allows
    for direct hardware access and low-level system calls, which are essential for
    kernel development, device drivers, and so on. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 系统级编程 | 由于其高级抽象和安全功能，某些系统级编程任务在 .NET Core 中可能仍然比较困难。 | C/C++ 通常用于系统级编程，因为它允许直接访问硬件和低级系统调用，这对于内核开发、设备驱动程序等至关重要。
    |'
- en: '| Portability | .NET Core applications can run on multiple platforms without
    recompilation, but you must install the .NET Runtime on the target machine. This
    is an improvement over .NET Framework. | C and C++ code can be compiled and run
    on virtually any system but often requires careful management of platform-specific
    differences. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 可移植性 | .NET Core 应用程序可以在多个平台上运行而无需重新编译，但必须在目标机器上安装 .NET 运行时。这比 .NET Framework
    有所改进。 | C 和 C++ 代码几乎可以在任何系统上编译和运行，但通常需要仔细管理平台特定的差异。 |'
- en: '| Runtime requirement | .NET Core applications still require the .NET Core
    Runtime to be installed on the target machine. This can limit its use on systems
    with limited resources. | C and C++ applications compile down to machine code
    and don’t require a separate runtime. This can be beneficial for system-level
    applications or when working with resource-constrained systems. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 运行时要求 | .NET Core 应用程序仍然需要在目标机器上安装 .NET Core 运行时。这可能会限制其在资源有限的系统上的使用。 | C
    和 C++ 应用程序编译成机器代码，不需要单独的运行时。这对于系统级应用程序或与资源受限系统一起工作时可能是有益的。 |'
- en: '| Direct control | C# and .NET Core still provide many abstractions that can
    increase productivity, but these abstractions can limit direct control over the
    system and how code runs. | C/C++ provides more direct control over the system,
    allowing for finely tuned optimizations and precise control over how your code
    runs. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 直接控制 | C# 和 .NET Core 仍然提供许多可以增加生产力的抽象，但这些抽象可能会限制对系统和代码运行方式的直接控制。 | C/C++
    提供了对系统的更多直接控制，允许进行精细调优的优化，并精确控制代码的运行方式。 |'
- en: '| Community and support | .NET Core and C# have a growing community and plenty
    of support resources, including for cross-platform development. | C/C++ has a
    large, established community, many open-source projects, and a vast amount of
    existing system-level code. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 社区和支持 | .NET Core和C#拥有不断增长的社区和丰富的支持资源，包括跨平台开发。 | C/C++拥有庞大且成熟的社区，许多开源项目以及大量的现有系统级代码。
    |'
- en: 'Table 0.1: Comparison of C# and C/C++'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表0.1：C#和C/C++的比较
- en: As you can see, both options have advantages and disadvantages. However, most
    of the disadvantages of .NET Core can be removed using clever tricks and smart
    programming. Those are the topics of the rest of this book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两种选择都有其优缺点。然而，大多数.NET Core的缺点可以通过巧妙的方法和智能编程来消除。这些就是本书剩余部分要讨论的主题。
- en: C# is a very mature and well-designed language. The capabilities far exceed
    what developers had when they used C to build, for example, the Unix OS.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种非常成熟且设计精良的语言。其功能远超开发者在使用C语言构建，例如Unix操作系统时所能拥有的。
- en: What is .NET anyway?
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么.NET究竟是什么呢？
- en: .NET Core is the next version of the over two decades old framework that was
    meant to help developers get their work done quickly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是旨在帮助开发者快速完成工作的二十多年老框架的下一个版本。
- en: 'It all started with .NET Framework 1 back in 2002\. Microsoft presented it
    as the end-all solution to many issues developers were facing. Fun fact: the project
    had the internal code name Project 42\. You get bonus points if you know why they
    chose that name.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于2002年的.NET Framework 1。微软将其作为解决开发者面临许多问题的终极解决方案。有趣的事实：该项目内部代号为Project
    42。如果你知道他们为什么选择这个名字，你会得到额外的分数。
- en: In the years following the introduction, we have seen many different functions
    of .NET Framework. Microsoft released the last version of .NET Framework on April
    18, 2019.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入后的几年里，我们看到了.NET Framework的许多不同功能。微软于2019年4月18日发布了.NET Framework的最后一个版本。
- en: Before that, Microsoft realized they needed to support other platforms as well.
    They wanted .NET to be available everywhere, including Linux, Macintosh, and most
    mobile devices. That meant they had to make fundamental changes to the runtime
    and the framework. Instead of having different runtime versions for each platform,
    they decided to have a unified version. That became .NET Core. Microsoft released
    this in June 2016.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，微软意识到他们需要支持其他平台。他们希望.NET能够在任何地方可用，包括Linux、Macintosh以及大多数移动设备。这意味着他们必须对运行时和框架进行根本性的改变。他们决定不再为每个平台提供不同的运行时版本，而是选择了一个统一的版本。这成为了.NET
    Core。微软于2016年6月发布了这个版本。
- en: .NET Standard was a set of specifications. The specifications told all developers
    which features of the runtime were available in which version of the runtime.
    Most developers did not understand the purpose of .NET Standard and assumed it
    was yet another version of the runtime. But once they got the idea behind this,
    it made a lot of sense. If you need a specific API, look it up in the documentation,
    see what version of .NET Standard it was supported, and then check whether your
    desired runtime supported that version of .NET Standard.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard是一套规范。这些规范告诉所有开发者运行时在哪个版本中提供了哪些功能。大多数开发者并不理解.NET Standard的目的，并假设它又是运行时的另一个版本。但一旦他们理解了其背后的理念，它就变得非常有意义。如果你需要一个特定的API，查阅文档，看看它支持哪个.NET
    Standard版本，然后检查你想要的运行时是否支持该版本的.NET Standard。
- en: 'An example might be helpful here. Let’s say you build an app that does some
    fancy drawing on the screen. You have worked with `System.Drawing.Bitmap` before,
    so you want to use that again. However, your new app should be running on .NET
    Core. Can you reuse your code? If you look up the documentation of the `System.Drawing.Bitmap`
    class, you see the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里举一个例子可能会有所帮助。假设你构建了一个在屏幕上执行一些复杂绘图的程序。你之前已经使用过`System.Drawing.Bitmap`，所以你希望再次使用它。然而，你的新应用程序应该在.NET
    Core上运行。你能重用你的代码吗？如果你查阅`System.Drawing.Bitmap`类的文档，你会看到以下内容：
- en: '| **Product** | **Versions** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **产品** | **版本** |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| .NET framework | 1.1, 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1,
    4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| .NET框架 | 1.1, 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7,
    4.7.1, 4.7.2, 4.8, 4.8.1 |'
- en: '| . NET platform extensions | 2.1, 2.2, 3.0, 3.1, 5, 6, 7, 8 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| .NET平台扩展 | 2.1, 2.2, 3.0, 3.1, 5, 6, 7, 8 |'
- en: '| Windows desktop | 3.0, 3.1, 5, 6, 7, 8 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Windows桌面 | 3.0, 3.1, 5, 6, 7, 8 |'
- en: 'Table 0.2: Support for System.Drawing.Bitmap'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表0.2：System.Drawing.Bitmap的支持情况
- en: Darn. This class is not part of .NET Standard. It is not available in all runtimes
    out there. You need to find another way to draw your images.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 真糟糕。这个类不是 .NET 标准的一部分。它不是所有运行时都有的。你需要找到另一种方式来绘制你的图像。
- en: 'Your app also communicates with the outside world. It uses the `HttpClient`
    class, found in the `System.Net.Http` namespace. Can you move that to other platforms?
    Again, we need to look up the documentation of that class. There, we see this
    table:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序也与外部世界进行通信。它使用 `HttpClient` 类，该类位于 `System.Net.Http` 命名空间中。你能将其移动到其他平台吗？再次，我们需要查找该类的文档。在那里，我们看到这个表格：
- en: '| **Product** | **Versions** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **产品** | **版本** |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| .NET | Core 1.0, core 1.1, core 2.0, core 2.1, core 2.2, core 3.0, core 3.1,
    5, 6, 7, 8 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| .NET | Core 1.0, core 1.1, core 2.0, core 2.1, core 2.2, core 3.0, core 3.1,
    5, 6, 7, 8 |'
- en: '| .NET framework | 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2,
    4.8, 4.8.1 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| .NET framework | 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2,
    4.8, 4.8.1 |'
- en: '| .NET standard | 1.1, 1.2, 1.3, 1.4, 1.6, 2.0, 2.1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| .NET standard | 1.1, 1.2, 1.3, 1.4, 1.6, 2.0, 2.1 |'
- en: '| Uwp | 10.0 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Uwp | 10.0 |'
- en: '| Xamarin.ios | 10.8 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.ios | 10.8 |'
- en: '| Xamarin.mac | 3.0 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.mac | 3.0 |'
- en: 'Table 0.3: Support for Sstem.Net.Http.HttpClient'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '表 0.3: 对 Sstem.Net.Http.HttpClient 的支持'
- en: Now, that is more like it. `HttpClient` is part of the .NET Standard specification,
    which means that all runtimes that support the mentioned versions of .NET Standard
    implement this class. You are good to go!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更像样子了。`HttpClient` 是 .NET 标准规范的一部分，这意味着所有支持提到的 .NET 标准版本的运行时都实现了这个类。你可以开始了！
- en: .NET, .NET Framework, .NET Standard – what is all this?
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET、.NET Framework、.NET 标准——这些都是什么？
- en: '*Table 0.3* shows .NET Framework, .NET Standard, and .NET but not .NET Core.
    We do see .NET, though. What is this all about?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 0.3* 显示了 .NET Framework、.NET 标准和 .NET，但没有 .NET Core。我们确实看到了 .NET。这究竟是怎么回事？'
- en: .NET Core was introduced to sit next to .NET Framework. Microsoft intended for
    .NET Framework to support Windows devices. However, as I explained, Microsoft
    later decided to support other devices, OSs, and other hardware architectures;
    hence the introduction of .NET Core. Then, they realized that this complicated
    things a lot. People lost track of what they could use and where they could use
    it. The solution to this was the introduction of the .NET Standard specifications,
    but that only worsened things – even the people who were not confused initially
    lost track of what was going on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 的引入是为了与 .NET Framework 并行。微软原本打算让 .NET Framework 支持Windows设备。然而，正如我解释的那样，微软后来决定支持其他设备、操作系统和其他硬件架构；因此引入了
    .NET Core。然后，他们意识到这使事情变得更加复杂。人们失去了对可以使用什么以及在哪里使用的跟踪。这个解决方案是引入 .NET 标准规范，但这使事情变得更糟——甚至那些最初没有困惑的人也失去了对正在发生什么的跟踪。
- en: The version numbering was an issue as well. We have .NET Framework version 4.8.1
    that matched .NET Standard 2.1\. .NET Core 3.1 also supported .NET Standard 2.1\.
    Many people had no idea what was happening. They could not understand why a .NET
    (Core) version of 3.0 was newer than .NET 4.5.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 版本编号也是一个问题。我们有与 .NET Standard 2.1 匹配的 .NET Framework 版本 4.8.1。.NET Core 3.1
    也支持 .NET Standard 2.1。许多人不知道发生了什么。他们无法理解为什么 .NET（Core）3.0 版本比 .NET 4.5 更新。
- en: 'Microsoft saw this problem as well. They also had internal issues: they had
    to backport a lot of the code in the libraries so it would be available everywhere.
    To eliminate this mess once and for all, they announced that .NET Framework 4.8
    would be the last version. .NET Core 3.1 would be the last version. From now on,
    it was all unified in something called .NET. Then, to prevent issues with the
    numbering, .NET started with the number 5.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 微软也看到了这个问题。他们也有内部问题：他们必须将库中的大量代码回溯，以便在所有地方都可以使用。为了彻底解决这个问题，他们宣布 .NET Framework
    4.8 将是最后一个版本。.NET Core 3.1 也将是最后一个版本。从现在开始，所有内容都统一在称为 .NET 的东西中。然后，为了防止编号问题，.NET
    从数字 5 开始。
- en: They also made it easier to track when new versions would come out. Every single
    year, there will be a new version of .NET. So far, the odd numbers are under **Long
    Term Support** (**LTS**); the even numbers are under Standard Term Support (**STS**).
    STS is 18 months, and LTS is 3 years.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还使跟踪新版本发布的时间变得更加容易。每年，都会有新的 .NET 版本。到目前为止，奇数版本处于**长期支持**（**LTS**）状态；偶数版本处于**标准期限支持**（**STS**）状态。STS
    为 18 个月，LTS 为 3 年。
- en: .NET 5 was an STS version, and since it was released in November 2020, the support
    ended in May 2022\. .NET 6 was an LTS version. Released in November 2021, support
    ends November 2024\. .NET 7 is again an STS, released in November 2022, with an
    end of life in May 2024.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5 是一个短期支持版本，自 2020 年 11 月发布以来，支持已于 2022 年 5 月结束。.NET 6 是一个长期支持版本。于 2021
    年 11 月发布，支持将于 2024 年 11 月结束。.NET 7 再次是一个短期支持版本，于 2022 年 11 月发布，生命周期结束于 2024 年
    5 月。
- en: By the time of writing this book, the preview versions of .NET 8 are out, and
    that will be an LTS version.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，.NET 8 的预览版已经发布，并且它将是一个长期支持版本。
- en: This is what I use in this book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我使用的就是这个版本。
- en: Now, the versioning is clear. The release cycle is understood. We can finally
    let that go. We can focus on building cool stuff instead of worrying about versions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，版本号是清晰的。发布周期是可理解的。我们终于可以放手了。我们可以专注于构建酷炫的东西，而不是担心版本。
- en: Programming languages – a choice to make
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言 – 一个需要做出的选择
- en: 'We are not done yet. We have figured out which version of the runtime we need.
    But the runtime is just that: a runtime. A set of libraries that we can use. Those
    libraries have a lot of tools and pre-built classes available, so we do not have
    to write that. That is awesome. However, we still have to write some code ourselves.
    We do that in a programming language, and then link to the libraries, compile
    the code, and have a binary we can deploy and run.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。我们已经确定了需要哪个版本的运行时。但是，运行时只是那样：一个运行时。一组我们可以使用的库。这些库提供了许多工具和预构建的类，因此我们不必自己编写这些。这真是太棒了。然而，我们仍然需要自己编写一些代码。我们用编程语言来做这件事，然后链接到库，编译代码，并拥有可以部署和运行的二进制文件。
- en: What language should we use?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用哪种语言？
- en: Microsoft offers us three choices. Others have made their own .NET-compatible
    languages, but we ignore them. These days, the main languages to write .NET code
    are C#, F#, and Visual Basic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为我们提供了三种选择。其他人已经创建了他们自己的与 .NET 兼容的语言，但我们忽略它们。如今，编写 .NET 代码的主要语言是 C#、F# 和 Visual
    Basic。
- en: F# is a language used for functional programming. This is a different approach
    to programming than most people are used to, but the financial domain and data-intensive
    systems use it a lot.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: F# 是一种用于函数式编程的语言。这是一种与大多数人习惯的编程方式不同的方法，但金融领域和数据密集型系统大量使用它。
- en: Visual Basic is an excellent language for people just getting started in development.
    Back in the nineties, at the end of the last century, it was one of the few options
    people had to build GUI systems rapidly. When .NET came along, Microsoft quickly
    ported Visual Basic to support this framework, so developers did not have as steep
    a learning curve. However, usage of Visual Basic is dwindling now that Microsoft
    stopped co-evolving it with C#.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic 是一种非常适合刚开始开发的人使用的语言。在上个世纪的九十年代，它是人们快速构建 GUI 系统的少数几种选择之一。当 .NET
    出现时，微软迅速将 Visual Basic 移植到支持这个框架，这样开发者就不需要那么陡峭的学习曲线。然而，随着微软停止与 C# 共同进化，Visual
    Basic 的使用正在减少。
- en: C# is the language we use in this book.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我们使用的是 C# 语言。
- en: Although not coupled with the available runtime, Microsoft seems to release
    a new version of the language around the same time they release a new version
    of .NET. Version 11 of the language came out in November 2022\. Version 12 of
    C# is now in preview when writing this book.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与可用的运行时不耦合，但微软似乎在发布新的 .NET 版本的同时发布新的语言版本。该语言的第 11 版于 2022 年 11 月发布。当撰写这本书时，C#
    的第 12 版现在处于预览阶段。
- en: Each new version of the language has improvements, but many are syntactic. That
    means that if you cannot use the latest language version, you can still use all
    the features in the runtime. They are officially decoupled. Sometimes, it is just
    a bit more typing work.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的新版本都有改进，但许多都是语法上的。这意味着如果你不能使用最新的语言版本，你仍然可以使用运行时中的所有功能。它们是官方解耦的。有时，这仅仅需要更多的打字工作。
- en: The .NET Runtime is an excellent foundation for building all sorts of systems.
    The ecosystem surrounding .NET is very extensive. Next, a huge group of people
    contributes to the framework daily. It is hard to think of a task that cannot
    be performed with .NET or one of the thousands of NuGet packages available.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时是构建各种系统的优秀基础。围绕 .NET 的生态系统非常广泛。接下来，一大群人每天都在为框架做出贡献。很难想象一个不能用 .NET 或可用的数千个
    NuGet 包完成的任务。
- en: Again, real Kernel mode systems, such as device drivers, are best built with
    non-managed languages. However, for all other purposes, .NET and C# are an excellent
    choice.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于真正的内核模式系统，例如设备驱动程序，最好使用非托管语言来构建。然而，对于所有其他用途，.NET 和 C# 是一个极好的选择。
- en: Now what?
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在又是什么呢？
- en: Congratulations! You have made the first steps towards becoming a systems programmer.
    You now know what systems programming is and how it differs from the usual day-to-day
    programming you might be used to doing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经迈出了成为系统程序员的第一个步骤。你现在知道什么是系统编程，以及它与你可能习惯的日常编程有何不同。
- en: You know about the background of programming and the challenges our predecessors
    faced, and you know why .NET is such an awesome tool to build systems software
    in.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解编程的背景以及我们的前辈所面临的挑战，你也知道为什么.NET是构建系统软件的如此出色的工具。
- en: We are ready to take the next step. We will dive into the nitty-gritty details.
    However, before we do that, we will need to talk about APIs and .NET Framework,
    its upsides, and its downsides. So, let’s go!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好迈出下一步。我们将深入探讨细节。然而，在我们这样做之前，我们需要讨论API和.NET框架，它的优点和缺点。那么，让我们开始吧！
- en: Setting up your development environment
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的开发环境
- en: I asked you to follow along. I requested that you open up your development environment
    and do what I do. However, to do that, you need to set up the right kind of development
    environment so that you can actually do what I do.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我要求你跟我一起做。我要求你打开你的开发环境并做我做的事情。然而，为了做到这一点，你需要设置正确类型的开发环境，这样你才能真正做到我做的事情。
- en: Let me help you with that.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来帮你。
- en: 'I use **Visual Studio 2022 Enterprise**. There is no particular reason I use
    the Enterprise version besides having that on my machine. There are two other
    versions: The Professional and the free Community edition. All three versions
    are fine for the things we want to do. However, the Enterprise edition does have
    some debugging tools we might need when discussing debugging. When that time comes,
    I will pinpoint the differences and show you other ways of achieving your goals.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用**Visual Studio 2022 Enterprise**。我使用企业版的原因没有特别之处，只是因为我机器上有这个版本。还有两个版本：专业版和免费的社区版。所有三个版本都适合我们想要做的事情。然而，企业版确实有一些我们在讨论调试时可能需要的调试工具。当那个时候到来时，我会指出差异，并展示其他实现目标的方法。
- en: Alternatives such as JetBrains Rider and Visual Studio Code also work, but you
    might have to do more work yourself when we go into performance tuning and debugging.
    Again, I will tell you about these when we get there.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他替代品，如JetBrains Rider和Visual Studio Code也适用，但当我们进入性能调整和调试时，你可能需要自己做更多的工作。再次提醒，当我到达那里时，我会告诉你这些信息。
- en: I have limited experience with Rider, so I cannot tell you precisely what you
    need to do, but I am sure that when you are an experienced developer, you can
    translate what I am showing you into the tools you know and love.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我对Rider的经验有限，所以不能确切地告诉你你需要做什么，但我确信当你成为一名经验丰富的开发者时，你可以将我展示的内容翻译成你熟悉和喜爱的工具。
- en: Use what you have and what you know. I am cool with that.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你所拥有的和所知道的一切。我对此很满意。
- en: If you decide to go with Visual Studio, which I highly recommend, you should
    use version 2022 instead of 2019\. The latest versions of .NET and C# offer a
    lot related to performance tuning and memory optimizations. Those versions are
    only available in the 2022 version of Visual Studio. So, make sure you have that
    one on your device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用我强烈推荐的Visual Studio，你应该使用2022版本而不是2019版本。.NET和C#的最新版本提供了许多与性能调整和内存优化相关的功能。这些版本仅在Visual
    Studio 2022版本中可用。所以，确保你的设备上有这个版本。
- en: 'Next to that, we will be doing a lot of console stuff. That means using PowerShell:
    gone are the days of using `cmd.exe`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将进行大量的控制台操作。这意味着使用PowerShell：使用`cmd.exe`的日子已经过去了。
- en: I highly recommend downloading Windows Terminal. With Terminal, you can have
    all sorts of consoles. We will use PowerShell most of the time, but when we talk
    about Linux, we will use the WSL feature to use our machines as Linux machines.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐下载Windows Terminal。有了终端，你可以拥有各种控制台。我们大部分时间会使用PowerShell，但当我们谈到Linux时，我们会使用WSL功能来将我们的机器作为Linux机器使用。
- en: 'Downloading and installing Terminal is a breeze: you can find it on the Microsoft
    Store.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装终端非常简单：你可以在Microsoft Store中找到它。
- en: Make sure to install Windows Subsystem for Linux as well. Instructions on how
    to do that are all over the internet; I will not repeat that here.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确保还安装了Windows Subsystem for Linux。有关如何操作的说明在网上到处都是；我不会在这里重复。
- en: 'Once you have installed all of your favorite tools, you can select any one
    of them in your Terminal. Mine looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了所有你喜欢的工具，你可以在你的终端中选择其中任何一个。我的看起来像这样：
- en: "![Figure \uFEFF\uFEFF0.6: Windows Terminal with different shells](img/B20924_01_06.jpg)"
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图0.6：带有不同shell的Windows终端](img/B20924_01_06.jpg)'
- en: 'Figure 0.6: Windows Terminal with different shells'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.6：不同壳的 Windows Terminal
- en: As you can see, I have **PowerShell**, **Command Prompt**, **Ubuntu**, **Azure
    Cloud Shell**, and some more installed. Selecting one of them is a matter of clicking.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已经安装了 **PowerShell**、**命令提示符**、**Ubuntu**、**Azure Cloud Shell** 以及一些其他的东西。选择其中之一只需点击一下。
- en: Switching between Linux and Windows has never been easier!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Windows 之间切换从未如此简单！
- en: Another tool we will be using later on is **WinDbg**. WinDbg is an extremely
    powerful external debugger. It can give you a lot of information about the processes
    you are interested in. It runs standalone, so you do not have to attach Visual
    Studio to the process. There are versions available for both X86 and ARM, so it
    is usable on many devices. You can find WinDbg on the Microsoft website at [https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/).
    Download and install that. WinDbg might become one of your latest best friends.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会使用的一个工具是 **WinDbg**。WinDbg 是一个功能极其强大的外部调试器。它可以提供大量关于你感兴趣进程的信息。它独立运行，因此你不需要将
    Visual Studio 附加到进程上。它有 X86 和 ARM 两种版本，因此可以在许多设备上使用。你可以在微软网站上找到 WinDbg，网址是 [https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)。下载并安装它。WinDbg
    可能会成为你最新的最佳拍档之一。
- en: Next, you might want to install **PerfView**. It is a free and open-source performance
    monitoring tool from Microsoft, specially built for analyzing performance on .NET
    applications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能想安装 **PerfView**。这是一个来自微软的免费开源性能监控工具，专门为分析 .NET 应用程序的性能而构建。
- en: 'You can find the source code at [https://github.com/Microsoft/perfview](https://github.com/Microsoft/perfview).
    You can download the sources and build the tool yourself or grab one of the pre-build
    versions. Those are also on that same site. I would suggest building yourself
    and looking through the source code: there are some terrific examples of how to
    build software like this. I do not intend to describe how the tool works internally,
    but I will use it when discussing performance.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/Microsoft/perfview](https://github.com/Microsoft/perfview)
    找到源代码。你可以下载源代码自行构建工具，或者获取预构建版本。这些版本也在同一个网站上。我建议你自己构建并查看源代码：这里有如何构建此类软件的一些极好的示例。我并不打算描述工具的内部工作原理，但我会讨论性能时使用它。
- en: Now, all you need is a cup of your favorite beverage, and we are good to go!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要一杯你最喜欢的饮料，我们就可以出发了！
