- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Popular Third-Party Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流行的第三方库
- en: This chapter is about some popular third-party libraries for .NET that enable
    you to perform actions that either are not possible with the core .NET libraries
    or are better than the built-in functionality. These actions include manipulating
    images with **ImageSharp**, logging with **Serilog**, mapping objects to other
    objects with **AutoMapper**, making unit test assertions with **FluentAssertions**,
    validating data with **FluentValidation**, and generating PDFs with **QuestPDF**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个流行的 .NET 第三方库，这些库允许你执行一些操作，这些操作要么无法使用核心 .NET 库完成，要么比内置功能更好。这些操作包括使用 **ImageSharp**
    处理图像、使用 **Serilog** 记录、使用 **AutoMapper** 将对象映射到其他对象、使用 **FluentAssertions** 进行单元测试断言、使用
    **FluentValidation** 验证数据以及使用 **QuestPDF** 生成 PDF。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Which third-party libraries are most popular?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些第三方库最受欢迎？
- en: Working with images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理图像
- en: Logging with Serilog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Serilog 记录
- en: Mapping between objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象之间的映射
- en: Making fluent assertions in unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中进行流畅断言
- en: Validating data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据
- en: Generating PDFs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 PDF
- en: Which third-party libraries are most popular?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪些第三方库最受欢迎？
- en: 'To help me decide which third-party libraries to include in this book, I researched
    which are downloaded most frequently at [https://www.nuget.org/stats/packages](https://www.nuget.org/stats/packages),
    and, as shown in *Table 6.1*, they are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我决定在本书中包含哪些第三方库，我研究了在 [https://www.nuget.org/stats/packages](https://www.nuget.org/stats/packages)
    上下载频率最高的库，如 *表 6.1* 所示，它们是：
- en: '| **Rank** | **Package** | **Downloads** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **排名** | **包** | **下载量** |'
- en: '| 1 | `newtonsoft.json` | 167,927,712 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `newtonsoft.json` | 167,927,712 |'
- en: '| 2 | `serilog` | 42,436,567 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `serilog` | 42,436,567 |'
- en: '| 3 | `awssdk.core` | 36,423,449 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `awssdk.core` | 36,423,449 |'
- en: '| 4 | `castle.core` | 28,383,411 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `castle.core` | 28,383,411 |'
- en: '| 5 | `newtonsoft.json.bson` | 26,547,661 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `newtonsoft.json.bson` | 26,547,661 |'
- en: '| 6 | `swashbuckle.aspnetcore.swagger` | 25,828,940 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `swashbuckle.aspnetcore.swagger` | 25,828,940 |'
- en: '| 7 | `swashbuckle.aspnetcore.swaggergen` | 25,823,941 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `swashbuckle.aspnetcore.swaggergen` | 25,823,941 |'
- en: '| 8 | `polly` | 22,487,368 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `polly` | 22,487,368 |'
- en: '| 9 | `automapper` | 21,679,921 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `automapper` | 21,679,921 |'
- en: '| 10 | `swashbuckle.aspnetcore.swaggerui` | 21,373,873 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `swashbuckle.aspnetcore.swaggerui` | 21,373,873 |'
- en: '| 12 | `moq` | 19,408,440 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `moq` | 19,408,440 |'
- en: '| 15 | `fluentvalidation` | 17,739,259 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 15 | `fluentvalidation` | 17,739,259 |'
- en: '| 16 | `humanizer.core` | 17,602,598 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 16 | `humanizer.core` | 17,602,598 |'
- en: '| 23 | `stackexchange.redis` | 15,771,377 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 23 | `stackexchange.redis` | 15,771,377 |'
- en: '| 36 | `fluentassertions` | 12,244,097 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 36 | `fluentassertions` | 12,244,097 |'
- en: '| 40 | `dapper` | 10,819,569 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 40 | `dapper` | 10,819,569 |'
- en: '| 52 | `rabbitmq.client` | 8,591,362 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 52 | `rabbitmq.client` | 8,591,362 |'
- en: '| 83 | `hangfire.core` | 5,479,381 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 83 | `hangfire.core` | 5,479,381 |'
- en: '| 94 | `nodatime` | 4,944,830 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 94 | `nodatime` | 4,944,830 |'
- en: 'Table 6.1: The most downloaded NuGet packages'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：最受欢迎的 NuGet 包
- en: What is covered in my books
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我书中涵盖的内容
- en: My book *C# 12 and .NET 8 – Modern Cross-Platform Development Fundamentals*
    introduces processing JSON using `newtonsoft.json` and documenting web services
    using `swashbuckle`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我的书《C# 12 和 .NET 8 – 现代跨平台开发基础》介绍了使用 `newtonsoft.json` 处理 JSON 以及使用 `swashbuckle`
    记录 Web 服务。
- en: For now, using Castle Core to generate dynamic proxies and typed dictionaries,
    or deploying to and integrating with **Amazon Web Services** (**AWS**), is out
    of scope for this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用 Castle Core 生成动态代理和类型化字典，或将应用程序部署到并与 **Amazon Web Services**（**AWS**）集成，超出了本书的范围。
- en: 'As well as raw download numbers, questions from readers and the usefulness
    of the library also contributed to my decision to include a library in this chapter,
    as summarized in the following list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始下载量外，读者的提问和库的有用性也影响了我将库包含在本章中的决定，如下列总结所示：
- en: 'Most popular library for manipulating images: **ImageSharp**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的图像处理库：**ImageSharp**
- en: 'Most popular library for manipulating text: **Humanizer**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的文本处理库：**Humanizer**
- en: 'Most popular library for logging: **Serilog**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的日志库：**Serilog**
- en: 'Most popular library for object mapping: **AutoMapper**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的对象映射库：**AutoMapper**
- en: 'Most popular library for unit test assertions: **FluentAssertions**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的单元测试断言库：**FluentAssertions**
- en: 'Most popular library for data validation: **FluentValidation**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的数据验证库：**FluentValidation**
- en: 'Open-source library for generating PDFs: **QuestPDF**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 PDF 的开源库：**QuestPDF**
- en: 'In *Chapter 7*, *Handling Dates, Times, and Internationalization*, I cover
    the most popular library for handling dates and times: **Noda Time**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，*处理日期、时间和国际化* 中，我介绍了处理日期和时间的最流行库：**Noda Time**。
- en: 'In *Chapter 9*, *Caching, Queuing, and Resilient Background Services*, I cover
    a few more popular libraries, as summarized in the following list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 章，*缓存、队列和弹性后台服务* 中，我介绍了一些更受欢迎的库，如下列列表中总结：
- en: 'Most popular library for resilience and transient fault handling: **Polly**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的弹性和短暂故障处理库：**Polly**
- en: 'Most popular library for scheduling jobs and implementing background services:
    **Hangfire**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的作业调度和实现后台服务的库：**Hangfire**
- en: 'Most popular library for distributed caching: **Redis**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的分布式缓存库：**Redis**
- en: 'Most popular library for queuing: **RabbitMQ**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的队列库：**RabbitMQ**
- en: Working with images
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像
- en: '**ImageSharp** is a third-party cross-platform 2D graphics library. When .NET
    Core 1.0 was in development, there was negative feedback from the community about
    the missing `System.Drawing` namespace for working with 2D images. The ImageSharp
    project was started to fill that gap for modern .NET applications.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**ImageSharp** 是一个第三方跨平台 2D 图形库。当 .NET Core 1.0 开发时，社区对缺少用于处理 2D 图像的 `System.Drawing`
    命名空间提出了负面反馈。ImageSharp 项目开始是为了填补现代 .NET 应用程序的这一空白。'
- en: In their official documentation for `System.Drawing`, Microsoft says, “The `System.Drawing`
    namespace is not recommended for new development due to not being supported within
    a Windows or ASP.NET service, and it is not cross-platform. ImageSharp and SkiaSharp
    are recommended as alternatives.”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Microsoft 的 `System.Drawing` 的官方文档中，微软表示，“`System.Drawing` 命名空间不建议用于新开发，因为它不支持在
    Windows 或 ASP.NET 服务中，并且它不是跨平台的。ImageSharp 和 SkiaSharp 被推荐作为替代方案。”
- en: 'Six Labors released ImageSharp 3.0 in March 2023\. It now requires .NET 6 or
    later and major future versions will target LTS releases of .NET, like .NET 8\.
    You can read the announcement at the following link: [https://sixlabors.com/posts/announcing-imagesharp-300/](https://sixlabors.com/posts/announcing-imagesharp-300/).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 六个劳动在 2023 年 3 月发布了 ImageSharp 3.0。现在它需要 .NET 6 或更高版本，未来的主要版本将针对 .NET 的 LTS
    版本，如 .NET 8。您可以在以下链接中阅读公告：[https://sixlabors.com/posts/announcing-imagesharp-300/](https://sixlabors.com/posts/announcing-imagesharp-300/)。
- en: Generating grayscale thumbnails
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成灰度缩略图
- en: 'Let’s see what can be achieved with ImageSharp:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 ImageSharp 能实现什么：
- en: 'Use your preferred code editor to create a console app project, as defined
    in the following list:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个控制台应用程序项目，如下列列表中定义：
- en: 'Project template: **Console App** / `console`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Solution file and folder: `Chapter06`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `WorkingWithImages`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithImages`
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除'
- en: '**Enable native AOT publish**: Cleared'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT 发布**：已清除'
- en: 'In the `WorkingWithImages` project, create an `images` folder and download
    the nine images from the following link to it: [https://github.com/markjprice/apps-services-net8/tree/master/images/Categories](https://github.com/markjprice/apps-services-net8/tree/master/images/Categories).'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithImages` 项目中，创建一个 `images` 文件夹，并从以下链接下载九张图片到该文件夹：[https://github.com/markjprice/apps-services-net8/tree/master/images/Categories](https://github.com/markjprice/apps-services-net8/tree/master/images/Categories)。
- en: 'If you are using Visual Studio 2022, then the `images` folder and its files
    must be copied to the `WorkingWithImages\bin\Debug\net8` folder where the compiled
    console app will run. We can configure Visual Studio to do this for us, as shown
    in the following steps:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio 2022，那么 `images` 文件夹及其文件必须复制到 `WorkingWithImages\bin\Debug\net8`
    文件夹，编译的控制台应用程序将在该文件夹中运行。我们可以配置 Visual Studio 为我们完成此操作，如下所示的操作步骤：
- en: In **Solution Explorer**, select all nine images.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，选择所有九张图片。
- en: In **Properties**, set **Copy to Output Directory** to **Copy always**, as shown
    in *Figure 6.1*:![A picture containing text, screenshot, software, computer icon  Description
    automatically generated](img/B19587_06_01.png)
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 中，将 **复制到输出目录** 设置为 **始终复制**，如图 6.1 所示：![包含文本、截图、软件、计算机图标  自动生成的描述](img/B19587_06_01.png)
- en: 'Figure 6.1: Setting images to always copy to the output directory'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.1：设置图像始终复制到输出目录
- en: 'Open the project file and note the `<ItemGroup>` entries that will copy the
    nine images to the correct folder, as partially shown in the following markup:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目文件，注意 `<ItemGroup>` 条目，它们将复制九张图片到正确的文件夹，如下所示的部分标记：
- en: '[PRE0]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `WorkingWithImages` project, treat warnings as errors, globally and
    statically import the `System.Console` class, and add a package reference for
    `SixLabors.ImageSharp`, as shown highlighted in the following markup:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithImages` 项目中，将警告视为错误，全局和静态导入 `System.Console` 类，并为 `SixLabors.ImageSharp`
    添加包引用，如下面的标记所示：
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To save space, in other steps like this in this chapter, I will not show the
    markup to treat warnings as errors or to globally and statically import the `System.Console`
    class. I will only show the `ItemGroup` and `PackageReference` for task-specific
    libraries.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了节省空间，在本章的其他类似步骤中，我将不会显示将警告视为错误或全局和静态导入 `System.Console` 类的标记。我将只显示针对特定任务的库的
    `ItemGroup` 和 `PackageReference`。
- en: Build the `WorkingWithImages` project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建名为 `WorkingWithImages` 的项目。
- en: If you are using Visual Studio 2022, then in **Solution Explorer**, toggle **Show
    All Files**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio 2022，那么在**解决方案资源管理器**中，切换**显示所有文件**。
- en: 'In the `obj\Debug\net8.0` folder, open `WorkingWithImages.GlobalUsings.g.cs`,
    and note that referencing the `SixLabors.ImageSharp` package adds three global
    namespace imports alongside the usual ones added by the .NET SDK, as shown in
    the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `obj\Debug\net8.0` 文件夹中，打开 `WorkingWithImages.GlobalUsings.g.cs`，并注意引用 `SixLabors.ImageSharp`
    包会在 .NET SDK 添加的常规命名空间导入旁边添加三个全局命名空间导入，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you reference older versions of `SixLabors.ImageSharp` like 2.0.0, then it
    does not do this so you must manually import those three namespaces in each code
    file. This feature is one reason why version 3.0 and later have a minimum requirement
    of .NET 6.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你引用了 `SixLabors.ImageSharp` 的旧版本，如 2.0.0，那么它不会这样做，因此你必须在每个代码文件中手动导入这三个命名空间。这是为什么
    3.0 及以后的版本对 .NET 6 有最低要求的一个原因。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    convert all the files in the `images` folder into grayscale thumbnails at one-tenth
    size, as shown in the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加语句将 `images` 文件夹中的所有文件转换为十分之一大小的灰度缩略图，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the console app and note the images should be converted into grayscale
    thumbnails, as shown in the following partial output:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意图像应该被转换为灰度缩略图，如下面的部分输出所示：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the filesystem, open the appropriate `images` folder and note the much-smaller-in-bytes
    grayscale thumbnails, as shown in *Figure 6.2*:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统中，打开适当的 `images` 文件夹，并注意比之前小得多的字节灰度缩略图，如图 *6.2* 所示：
- en: '![](img/B19587_06_02.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_06_02.png)'
- en: 'Figure 6.2: Images after processing'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：处理后的图像
- en: ImageSharp packages for drawing and the web
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于绘制和网络的 ImageSharp 包
- en: 'ImageSharp also has NuGet packages for programmatically drawing images and
    working with images on the web, as shown in the following list:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ImageSharp 还提供了用于程序化绘制图像和在网络中处理图像的 NuGet 包，如下面的列表所示：
- en: '`SixLabors.ImageSharp.Drawing`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SixLabors.ImageSharp.Drawing`'
- en: '`SixLabors.ImageSharp.Web`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SixLabors.ImageSharp.Web`'
- en: '**More Information**: Learn more details at the following link: [https://docs.sixlabors.com/](https://docs.sixlabors.com/).'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：了解更多详情，请访问以下链接：[https://docs.sixlabors.com/](https://docs.sixlabors.com/)。'
- en: Working with text and numbers using Humanizer
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Humanizer 处理文本和数字
- en: Humanizer manipulates text in `string` values, names of `enum` values, dates,
    times, numbers, and quantities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Humanizer 在 `string` 值、`enum` 值的名称、日期、时间、数字和数量中操作文本。
- en: Working with text
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理文本
- en: 'The built-in `string` type has methods to manipulate text like `Substring`
    and `Trim`. But there are plenty of other common manipulations that we might want
    to perform on text. For example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `string` 类型有 `Substring` 和 `Trim` 等方法来操作文本。但还有许多其他常见的文本操作，我们可能想要执行。例如：
- en: You might have an ugly string generated by some code and you want to make it
    look friendlier to display to a user. This is common with `enum` types that cannot
    use spaces in multi-word values.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能有一些代码生成的丑陋字符串，你希望使其看起来更友好，以便向用户显示。这在多词值不能使用空格的 `enum` 类型中很常见。
- en: You might build a web content management system, and when a user enters an article
    title, you need to convert what they enter into a format suitable for a URL path.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能正在构建一个内容管理系统，当用户输入文章标题时，你需要将他们输入的内容转换为适合 URL 路径的格式。
- en: You might have a long `string` value that needs to be truncated to show in the
    limited space of a mobile user interface.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能有一个需要截断以在移动用户界面有限空间中显示的长 `string` 值。
- en: Humanizer case transformations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Humanizer 的案例转换
- en: Complex transformations can be performed in sequence by passing multiple Humanizer
    transformations to the `Transform` method. Transforms implement the `IStringTransformer`
    or `ICulturedStringTransformer` interfaces so you can implement your own custom
    transforms.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将多个 Humanizer 转换传递给 `Transform` 方法来按顺序执行复杂转换。转换实现 `IStringTransformer` 或
    `ICulturedStringTransformer` 接口，因此您可以实现自己的自定义转换。
- en: 'The built-in transforms are all casing transformations, and they are listed
    in *Table 6.2* along with convenient alternative methods that extend the `string`
    type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的转换都是大小写转换，它们列在 *表 6.2* 中，以及扩展 `string` 类型的便捷替代方法：
- en: '| **Transform** | **Description** | **Example** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **Transform** | **描述** | **示例** |'
- en: '| `To.LowerCase` | Transforms all characters in the `string` to lowercase.
    | the cat sat on the mat |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `To.LowerCase` | 将 `string` 中的所有字符转换为小写。 | the cat sat on the mat |'
- en: '| `To.UpperCase` | Transforms all characters in the `string` to uppercase.
    | THE CAT SAT ON THE MAT |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `To.UpperCase` | 将 `string` 中的所有字符转换为大写。 | THE CAT SAT ON THE MAT |'
- en: '| `To.TitleCase` | Transforms the first character of each word in the `string`
    to uppercase. | The Cat Sat on the Mat |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `To.TitleCase` | 将 `string` 中每个单词的第一个字符转换为大写。 | The Cat Sat on the Mat |'
- en: '| `To.SentenceCase` | Transforms the first character in the `string` to uppercase.
    It ignores periods (full stops) so it does not recognize sentences! | The cat
    sat on the mat |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `To.SentenceCase` | 将 `string` 中的第一个字符转换为大写。它忽略句点（句号），因此不识别句子！ | The cat
    sat on the mat |'
- en: 'Table 6.2: Humanizer casing transforms'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：Humanizer 大小写转换
- en: '**Good Practice**: It is important to consider the casing of the original text.
    If it is already uppercase, the title and sentence casing options will *not* convert
    to lowercase! You might need to transform to lowercase first, then transform to
    title or sentence case.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：考虑原始文本的大小写非常重要。如果它已经是大写，标题和句子大小写选项将 *不会* 转换为小写！您可能需要先转换为小写，然后再转换为标题或句子大小写。'
- en: 'As well as calling the `Transform` method with a transform object like `To.TitleCase`,
    there are convenience methods for manipulating the case of text, as shown in *Table
    6.3*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `To.TitleCase` 这样的转换对象调用 `Transform` 方法外，还有便捷的方法来操作文本的大小写，如 *表 6.3* 所示：
- en: '| **String extension method** | **Description** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **字符串扩展方法** | **描述** |'
- en: '| `Titleize` | Equivalent to transforming with `To.TitleCase` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Titleize` | 等同于使用 `To.TitleCase` 进行转换 |'
- en: '| `Pascalize` | Converts strings to upper camel case, also removing underscores
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Pascalize` | 将字符串转换为 upper camel case，同时删除下划线 |'
- en: '| `Camelize` | Same as `Pascalize` except that the first character is lowercase
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Camelize` | 与 `Pascalize` 相同，除了第一个字符是小写 |'
- en: 'Table 6.3: Humanizer text extension methods'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3：Humanizer 文本扩展方法
- en: Humanizer spacing conversions
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Humanizer 空格转换
- en: 'There are convenient methods for manipulating the spacing of text, by adding
    underscores and dashes, as shown in *Table 6.4*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有便捷的方法来操作文本的空格，通过添加下划线和破折号，如 *表 6.4* 所示：
- en: '| **String extension method** | **Description** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **字符串扩展方法** | **描述** |'
- en: '| `Underscore` | Separates the input words with an underscore |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Underscore` | 使用下划线分隔输入单词 |'
- en: '| `Dasherize`, `Hyphenate` | Replaces underscores with dashes (hyphens) in
    the string |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Dasherize`、`Hyphenate` | 在字符串中将下划线替换为破折号（连字符） |'
- en: '| `Kebaberize` | Separates the input words with dashes (hyphens) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Kebaberize` | 使用破折号（连字符）分隔输入单词 |'
- en: 'Table 6.4: Humanizer spacing conversion methods'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4：Humanizer 空格转换方法
- en: Humanizer’s Singularize and Pluralize methods
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Humanizer 的单复数转换方法
- en: 'Humanizer has two extension methods for the `string` class that automate converting
    between the singular and plural versions of a word, as shown in *Table 6.5*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Humanizer 为 `string` 类提供了两个扩展方法，用于自动在单词的单数和复数版本之间转换，如 *表 6.5* 所示：
- en: '| **String extension method** | **Description** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **字符串扩展方法** | **描述** |'
- en: '| `Singularize` | If the `string` contains a plural word, it is converted to
    the singular equivalent. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Singularize` | 如果 `string` 包含复数词，则将其转换为单数等价词。 |'
- en: '| `Pluralize` | If the `string` contains a singular word, it is converted to
    the plural equivalent. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Pluralize` | 如果 `string` 包含单数词，则将其转换为复数等价词。 |'
- en: 'Table 6.5: Humanizer’s Singularize and Pluralize methods'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5：Humanizer 的单复数转换方法
- en: These methods are used by Microsoft Entity Framework Core to singularize and
    pluralize the names of entity classes and their members.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被 Microsoft Entity Framework Core 用于将实体类及其成员的名称单复数化。
- en: Exploring text manipulations with a console app
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控制台应用程序探索文本操作
- en: 'Let’s explore some examples of text manipulation using Humanizer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些使用Humanizer进行文本操作示例：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HumanizingData` to the `Chapter06` solution. In Visual Studio 2022, set
    the startup project to the current selection.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器向`Chapter06`解决方案中添加一个名为`HumanizingData`的新**Console App** / `console`项目。在Visual
    Studio 2022中，将启动项目设置为当前选择。
- en: 'In the `HumanizingData` project, treat warnings as errors, globally and statically
    import the `System.Console` class, and add a package reference for `Humanizer`,
    as shown in the following markup:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HumanizingData`项目中，将警告视为错误，全局和静态导入`System.Console`类，并为`Humanizer`添加包引用，如下所示标记：
- en: '[PRE5]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are referencing a `Humanizer` package that includes all languages. If you
    only need the English language, then you can reference `Humanizer.Core` instead.
    If you also need a subset of languages, reference specific language packages using
    the pattern `Humanizer.Core.<lang>`, for example, `Humanizer.Core.fr` for French.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在引用一个包含所有语言的`Humanizer`包。如果你只需要英语，那么你可以引用`Humanizer.Core`。如果你还需要语言子集，请使用模式`Humanizer.Core.<lang>`引用特定的语言包，例如，`Humanizer.Core.fr`用于法语。
- en: Build the `HumanizingData` project to restore packages.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`HumanizingData`以恢复包。
- en: Add a new class file to the project named `Program.Functions.cs`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为`Program.Functions.cs`的新类文件。
- en: 'In `Program.Functions.cs`, add statements to import the namespace for working
    with globalization, and to define a method to configure the console to enable
    easy switching of the current culture and enable the use of special characters,
    as shown in the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，添加导入用于全球化操作的命名空间的语句，并定义一个方法来配置控制台以启用当前文化的轻松切换并启用特殊字符的使用，如下所示代码：
- en: '[PRE6]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Program.cs`, delete the existing statements, and then call the `ConfigureConsole`
    method, as shown in the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后调用`ConfigureConsole`方法，如下所示代码：
- en: '[PRE7]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `Program.Functions.cs`, add a statement to import the namespace for working
    with extension methods provided by Humanizer, as shown in the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，添加导入用于处理Humanizer提供的扩展方法的命名空间的语句，如下所示代码：
- en: '[PRE8]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `Program.Functions.cs`, add statements to define a method to output an original
    `string` and then the results of transforming it using the built-in casing transforms,
    as shown in the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，添加定义一个方法来输出原始的`string`，然后是使用内置的大小写转换转换的结果，如下所示代码：
- en: '[PRE9]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `Program.cs`, call the `OutputCasings` method with three different `string`
    values, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，使用三个不同的`string`值调用`OutputCasings`方法，如下所示代码：
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE11]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `Program.Functions.cs`, add statements to define a method that outputs an
    ugly `string` value using various Humanizer extension methods, as shown in the
    following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，添加定义一个方法，该方法使用各种Humanizer扩展方法输出一个丑陋的`string`值，如下所示代码：
- en: '[PRE12]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `Program.cs`, comment out the previous method calls and then add a statement
    to call the new method, as shown highlighted in the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的调用方法，然后添加调用新方法的语句，如下所示高亮显示的代码：
- en: '[PRE13]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE14]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add a new class file to the project named `WondersOfTheAncientWorld.cs`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为`WondersOfTheAncientWorld.cs`的新类文件。
- en: 'Modify the `WondersOfTheAncientWorld.cs` file, as shown in the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WondersOfTheAncientWorld.cs`文件，如下所示代码：
- en: '[PRE15]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `Program.Functions.cs`, import the namespace for using the `enum` that we
    just defined, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，导入用于使用我们刚刚定义的`enum`的命名空间，如下所示代码：
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `Program.Functions.cs`, define a method to create the `WondersOfTheWorld`
    variable and output its name using various Humanizer extension methods, as shown
    in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，定义一个方法来创建`WondersOfTheWorld`变量并使用各种Humanizer扩展方法输出其名称，如下所示代码：
- en: '[PRE17]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `Program.cs`, comment out the previous method call, and then add a call
    to `OutputEnumNames`, as shown highlighted in the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的调用方法，然后添加对`OutputEnumNames`的调用，如下所示高亮显示的代码：
- en: '[PRE18]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the `Truncate` method uses the single-character `…` (ellipsis) by default.
    If you ask to truncate to a length of 8, it can return the first seven characters
    followed by the ellipsis character. You can specify a different character using
    an overload of the `Truncate` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Truncate`方法默认使用单字符`…`（省略号）。如果你要求截断到8个字符的长度，它可以返回前七个字符后跟省略号字符。你可以使用`Truncate`方法的重载指定不同的字符。
- en: Working with numbers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数字
- en: 'Now let’s see how Humanizer can help us with numbers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Humanizer如何帮助我们处理数字：
- en: 'In `Program.Functions.cs`, define a method to create some numbers and then
    output them using various Humanizer extension methods, as shown in the following
    code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，定义一个方法以创建一些数字，然后使用各种Humanizer扩展方法输出它们，如下所示代码：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `Program.cs`, comment out the previous method call and add a call to `NumberFormatting`,
    as shown highlighted in the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用并添加对`NumberFormatting`的调用，如下所示高亮显示的代码：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Humanizer’s default vocabulary is quite decent, but it does not correctly pluralize
    attorney general (the plural is *attorneys general*) or biceps (the singular is
    *biceps* and the plural is *bicepses*).
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Humanizer的默认词汇表相当不错，但它并没有正确地将“总检察长”（复数形式为*attorneys general*）或“二头肌”（单数为*biceps*，复数为*bicepses*）进行复数化。
- en: 'In `Program.Functions.cs`, import the namespace for working with Humanizer
    vocabularies, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，导入用于处理Humanizer词汇的命名空间，如下所示代码：
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Program.Functions.cs`, at the top of the `NumberFormatting` method, add
    statements to register two irregular words, as shown in the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，在`NumberFormatting`方法的顶部添加语句以注册两个不规则单词，如下所示代码：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the code, view the result, and note that the two irregular words now output
    correctly.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意现在两个不规则单词的输出是正确的。
- en: Working with dates and times
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: 'Now let’s see how Humanizer can help us with dates and times:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Humanizer如何帮助我们处理日期和时间：
- en: 'In `Program.Functions.cs`, define a method to get the current date and time
    and some number of days, and then output them using various Humanizer extension
    methods, as shown in the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Functions.cs`中，定义一个方法以获取当前日期和时间以及一些天数，然后使用各种Humanizer扩展方法输出它们，如下所示代码：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `Program.cs`, comment out the previous method call and add a call to `DateTimeFormatting`,
    as shown highlighted in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用并添加对`DateTimeFormatting`的调用，如下所示高亮显示的代码：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `Program.cs`, specify the French language and region when configuring the
    console, as shown highlighted in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，配置控制台时指定法语语言和区域，如下所示高亮显示的代码：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the code, view the result, and note that the text is localized to French.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意文本已本地化为法语。
- en: Logging with Serilog
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Serilog进行日志记录
- en: Although .NET includes logging frameworks, third-party logging providers give
    more power and flexibility by using **structured event data**. Serilog is the
    most popular.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET包括日志记录框架，但第三方日志提供程序通过使用**结构化事件数据**提供了更多的功能和灵活性。Serilog是最受欢迎的。
- en: Structured event data
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化事件数据
- en: Most systems write plain text messages to their logs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统将纯文本消息写入其日志。
- en: Serilog can be told to write serialized structured data to the log. The `@`
    symbol prefixing a parameter tells Serilog to serialize the object passed in,
    instead of just the result of calling the `ToString` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog可以指示将序列化的结构化数据写入日志。在参数前加上`@`符号会告诉Serilog序列化传入的对象，而不是仅调用`ToString`方法的结果。
- en: Later, that complex object can be queried for improved search and sort capabilities
    in the logs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，那个复杂对象可以在日志中进行查询，以提供改进的搜索和排序功能。
- en: 'For example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can learn more about how Serilog handles structured data at the following
    link: [https://github.com/serilog/serilog/wiki/Structured-Data](https://github.com/serilog/serilog/wiki/Structured-Data).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于Serilog如何处理结构化数据的信息：[https://github.com/serilog/serilog/wiki/Structured-Data](https://github.com/serilog/serilog/wiki/Structured-Data)。
- en: Serilog sinks
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serilog接收器
- en: All logging systems need to record the log entries somewhere. That could be
    to the console output, a file, or a more complex data store like a relational
    database or cloud data store. Serilog calls these **sinks**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日志系统都需要将日志条目记录到某个地方。这可能是在控制台输出、文件或更复杂的数据存储，如关系数据库或云数据存储。Serilog 将这些称为 **sinks**。
- en: 'Serilog has hundreds of official and third-party sink packages for all the
    possible places you might want to record your logs. To use them, just include
    the appropriate package. The most popular are shown in the following list:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog 为您可能想要记录日志的所有可能位置提供了数百个官方和第三方 sink 包。要使用它们，只需包含适当的包。以下是最受欢迎的列表：
- en: '`serilog.sinks.file`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.file`'
- en: '`serilog.sinks.console`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.console`'
- en: '`serilog.sinks.periodicbatching`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.periodicbatching`'
- en: '`serilog.sinks.debug`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.debug`'
- en: '`serilog.sinks.rollingfile` (deprecated; use `serilog.sinks.file` instead)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.rollingfile`（已弃用；请使用 `serilog.sinks.file` 代替）'
- en: '`serilog.sinks.applicationinsights`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.applicationinsights`'
- en: '`serilog.sinks.mssqlserver`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serilog.sinks.mssqlserver`'
- en: 'There are more than 470 packages currently listed on Microsoft’s public NuGet
    feed: [https://www.nuget.org/packages?q=serilog.sinks](https://www.nuget.org/packages?q=serilog.sinks).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在微软的公共 NuGet 资源库中列出了 470 多个包：[https://www.nuget.org/packages?q=serilog.sinks](https://www.nuget.org/packages?q=serilog.sinks)。
- en: Logging to the console and a rolling file with Serilog
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Serilog 将日志记录到控制台和滚动文件
- en: 'Let’s start:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Serilogging` to a `Chapter06` solution.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，向 `Chapter06` 解决方案中添加一个名为 `Serilogging` 的新 **Console App** / `console`
    项目。
- en: 'In the `Serilogging` project, treat warnings as errors, globally and statically
    import the `System.Console` class, and add a package reference for `Serilog`,
    including sinks for `console` and `file` (which also supports rolling files),
    as shown in the following markup:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Serilogging` 项目中，将警告视为错误，全局和静态导入 `System.Console` 类，并为 `Serilog` 添加包引用，包括
    `console` 和 `file`（也支持滚动文件）的存储，如下面的标记所示：
- en: '[PRE30]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Build the `Serilogging` project.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `Serilogging`。
- en: In the `Serilogging` project, add a new folder named `Models`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Serilogging` 项目中，添加一个名为 `Models` 的新文件夹。
- en: 'In the `Serilogging` project, in the `Models` folder, add a new class file
    named `ProductPageView.cs`, and modify its contents, as shown in the following
    code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Serilogging` 项目中，在 `Models` 文件夹中，添加一个名为 `ProductPageView.cs` 的新类文件，并修改其内容，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `Program.cs`, delete the existing statements and then import some namespaces
    for working with Serilog, as shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后导入一些用于处理 Serilog 的命名空间，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `Program.cs`, create a logger configuration that will write to the console
    as well as configure a rolling interval that means a new file is created each
    day, and write various levels of log entries, as shown in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，创建一个将日志写入控制台并配置滚动间隔的日志配置器，这意味着每天创建一个新文件，并写入各种级别的日志条目，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the console app and note the messages, as shown in the following output:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意消息，如下面的输出所示：
- en: '[PRE34]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open the `logYYYYMMDD.txt` file, where `YYYY` is the year, `MM` is the month,
    and `DD` is the day, and note it contains the same messages:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `logYYYYMMDD.txt` 文件，其中 `YYYY` 是年份，`MM` 是月份，`DD` 是日期，并注意它包含相同的消息：
- en: For Visual Studio 2022, the log file will be written to the `Serilogging\bin\Debug\net8.0`
    folder.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Visual Studio 2022，日志文件将被写入到 `Serilogging\bin\Debug\net8.0` 文件夹。
- en: For Visual Studio Code and `dotnet run`, the log file will be written to the
    `Serilogging` folder.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Visual Studio Code 和 `dotnet run`，日志文件将被写入到 `Serilogging` 文件夹。
- en: '**More Information**: Learn more details at the following link: [https://serilog.net/](https://serilog.net/).'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：在以下链接中了解更多详情：[https://serilog.net/](https://serilog.net/)。'
- en: '**Good Practice**: Disable logging when it is not needed. Logging can get costly
    fast. For example, one organization was spending $10,000 per month on cloud resources,
    much more than predicted, and they didn’t know why. It turned out they were logging
    every SQL statement executed in production. By “flipping a switch” to stop that
    logging they saved $8,500 per month! You can read Milan Jovanović’s story at the
    following link: [https://www.linkedin.com/posts/milan-jovanovic_i-helped-a-team-save-100k-in-azure-cloud-activity-7109887614664474625-YDiU/](https://www.linkedin.com/posts/milan-jovanovic_i-helped-a-team-save-100k-in-azure-cloud-activity-7109887614664474625-YDiU/).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在不必要时禁用日志记录。日志记录可能会迅速变得昂贵。例如，一个组织每月在云资源上花费10,000美元，远超过预期，而且他们不知道原因。结果发现，他们在生产中记录了每个执行的SQL语句。通过“切换”停止该日志记录，他们每月节省了8,500美元！您可以在以下链接中阅读Milan
    Jovanović的故事：[https://www.linkedin.com/posts/milan-jovanovic_i-helped-a-team-save-100k-in-azure-cloud-activity-7109887614664474625-YDiU/](https://www.linkedin.com/posts/milan-jovanovic_i-helped-a-team-save-100k-in-azure-cloud-activity-7109887614664474625-YDiU/).'
- en: Mapping between objects
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象之间的映射
- en: One of the most boring parts of being a programmer is mapping between objects.
    It is common to need to integrate systems or components that have conceptually
    similar objects but with different structures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员最无聊的部分之一就是对象之间的映射。通常需要集成具有概念上相似对象但结构不同的系统或组件。
- en: Models for data are different for different parts of an application. Models
    that represent data in storage are often called **entity models**. Models that
    represent data that must be passed between layers are often called **data transfer
    objects** (**DTOs**). Models that represent only the data that must be presented
    to a user are often called **view models**. All these models are likely to have
    commonalities but different structures.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的不同部分可能有不同的数据模型。表示存储中数据的模型通常被称为**实体模型**。表示必须在层之间传递的数据的模型通常称为**数据传输对象**（**DTOs**）。仅表示必须向用户展示的数据的模型通常称为**视图模型**。所有这些模型都可能具有共性但结构不同。
- en: '**AutoMapper** is a popular package for mapping objects because it has conventions
    that make the work as easy as possible. For example, if you have a source member
    called `CompanyName`, it will be mapped to a destination member with the name
    `CompanyName`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**AutoMapper**是一个流行的映射对象包，因为它具有使工作尽可能简单的约定。例如，如果您有一个名为`CompanyName`的源成员，它将被映射到具有相同名称`CompanyName`的目标成员。'
- en: 'AutoMapper’s creator, Jimmy Bogard, has written an article about its design
    philosophy that is worth reading, available at the following link: [https://jimmybogard.com/automappers-design-philosophy/](https://jimmybogard.com/automappers-design-philosophy/).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper的创造者Jimmy Bogard写了一篇关于其设计哲学的文章，值得一读，可在以下链接中找到：[https://jimmybogard.com/automappers-design-philosophy/](https://jimmybogard.com/automappers-design-philosophy/).
- en: 'Let’s see an example of AutoMapper in action. You will create four projects:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看AutoMapper的实际应用示例。您将创建四个项目：
- en: A class library for the entity and view models.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体和视图模型的类库。
- en: A class library to create mapper configurations for reuse in unit tests and
    actual projects.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类库，用于创建可在单元测试和实际项目中重用的映射配置。
- en: A unit test project to test the mappings.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元测试项目来测试映射。
- en: A console app to perform a live mapping.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于执行实时映射的控制台应用程序。
- en: We will construct an example object model that represents an e-commerce website
    customer and their shopping cart with a couple of items, and then map it to a
    summary view model to present to the user.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个示例对象模型，它代表一个电子商务网站客户及其包含几个项目的购物车，然后将其映射到摘要视图模型以向用户展示。
- en: Defining models for an AutoMapper configuration
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义AutoMapper配置的模型
- en: To test the mapping, we will define some `record` types. As a reminder, a `record`
    (or `record class`) is a reference type that has value-based equality. A `class`
    is a reference type that has memory address-based equality (except for `string`,
    which overrides this behavior).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试映射，我们将定义一些`record`类型。作为提醒，`record`（或`record class`）是一个基于值相等性的引用类型。`class`是一个基于内存地址相等性的引用类型（除了`string`，它覆盖了这种行为）。
- en: 'It is good practice to always validate your configuration for mappings before
    using them, so we will start by defining some models and a mapping between them,
    and then create a unit test for the mappings:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前始终验证映射配置是一个好习惯，因此我们将首先定义一些模型和它们之间的映射，然后为映射创建一个单元测试：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `MappingObjects.Models` to the `Chapter06` solution.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将名为`MappingObjects.Models`的新**类库**/ `classlib`项目添加到`Chapter06`解决方案中。
- en: In the `MappingObjects.Models` project, delete the file named `Class1.cs`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Models`项目中，删除名为`Class1.cs`的文件。
- en: 'In the `MappingObjects.Models` project, add a new class file named `Customer.cs`
    and modify its contents to define an immutable record type named `Customer` by
    using constructor syntax, as shown in the following code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Models`项目中，添加一个名为`Customer.cs`的新类文件，并修改其内容以使用构造函数语法定义一个不可变的记录类型`Customer`，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `MappingObjects.Models` project, add a new class file named `LineItem.cs`
    and modify its contents, as shown in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Models`项目中，添加一个名为`LineItem.cs`的新类文件，并修改其内容，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `MappingObjects.Models` project, add a new class file named `Cart.cs`
    and modify its contents, as shown in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Models`项目中，添加一个名为`Cart.cs`的新类文件，并修改其内容，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `MappingObjects.Models` project, add a new class file named `Summary.cs`
    in the `Northwind.ViewModels` namespace (not `Northwind.EntityModels`), delete
    any existing statements, and then define a record type that can have its properties
    set *after* instantiating with a default parameterless constructor, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Models`项目中，在`Northwind.ViewModels`命名空间（不是`Northwind.EntityModels`）中添加一个名为`Summary.cs`的新类文件，删除任何现有语句，然后定义一个记录类型，该类型可以使用默认的无参数构造函数实例化，并在之后设置其属性，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For the entity models, we used `record class` types defined using the constructor
    syntax to make them immutable. But an instance of `Summary` will need to be created
    using a default parameterless constructor and then its members set by AutoMapper.
    Therefore, it must be a `record class` with public properties that can be set
    during initialization but not after that. To do this, we use the `init` keyword.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实体模型，我们使用了使用构造函数语法定义的`record class`类型来使它们不可变。但`Summary`的一个实例需要使用默认的无参数构造函数创建，然后通过
    AutoMapper 设置其成员。因此，它必须是一个`record class`，具有可以在初始化时设置但在之后不能设置的公共属性。为此，我们使用`init`关键字。
- en: Defining mappers for an AutoMapper configuration
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 AutoMapper 配置的映射器
- en: 'Now we can define the mappings between models:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义模型之间的映射：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `MappingObjects.Mappers` to the `Chapter06` solution.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将名为`MappingObjects.Mappers`的新**类库**/ `classlib`项目添加到`Chapter06`解决方案中。
- en: 'In the `MappingObjects.Mappers` project, treat warnings as errors, add a reference
    to the latest `AutoMapper` package, and add a reference to the `Models` project,
    as shown in the following markup:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Mappers`项目中，将警告视为错误，添加对最新`AutoMapper`包的引用，并添加对`Models`项目的引用，如下面的标记所示：
- en: '[PRE39]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Build the `MappingObjects.Mappers` project to restore packages and compile referenced
    projects.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`MappingObjects.Mappers`项目以恢复包并编译引用的项目。
- en: In the `MappingObjects.Mappers` project, delete the file named `Class1.cs`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Mappers`项目中，删除名为`Class1.cs`的文件。
- en: 'In the `MappingObjects.Mappers` project, add a new class file named `CartToSummaryMapper.cs`
    and modify its contents to create a mapper configuration that maps the `FullName`
    of the `Summary` to a combination of the `FirstName` and `LastName` from `Customer`,
    as shown in the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Mappers`项目中，添加一个名为`CartToSummaryMapper.cs`的新类文件，并修改其内容以创建一个映射配置，将`Summary`的`FullName`映射到`Customer`的`FirstName`和`LastName`的组合，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Performing tests for an AutoMapper configuration
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 AutoMapper 配置进行测试
- en: 'Now we can define unit tests for the mapper:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为映射器定义单元测试：
- en: Use your preferred code editor to add a new **xUnit Test Project** / `xunit`
    named `MappingObjects.Tests` to the `Chapter06` solution.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将名为`MappingObjects.Tests`的新**xUnit 测试项目**/ `xunit`添加到`Chapter06`解决方案中。
- en: 'In the `MappingObjects.Tests` project file, add a package reference to `AutoMapper`,
    as shown highlighted in the following markup:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Tests`项目文件中，添加对`AutoMapper`的包引用，如下面的标记所示：
- en: '[PRE41]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `MappingObjects.Tests` project file, add project references to `MappingObjects.Models`
    and `MappingObjects.Mappers`, as shown in the following markup:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Tests`项目文件中，添加对`MappingObjects.Models`和`MappingObjects.Mappers`的项目引用，如下面的标记所示：
- en: '[PRE42]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Build the `MappingObjects.Tests` project to restore packages and build referenced
    projects.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建MappingObjects.Tests项目以恢复包并构建引用的项目。
- en: In the `MappingObjects.Tests` project, rename `UnitTest1.cs` to `TestAutoMapperConfig.cs`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Tests`项目中，将`UnitTest1.cs`重命名为`TestAutoMapperConfig.cs`。
- en: 'Modify the contents of `TestAutoMapperConfig.cs` to get the mapper and then
    assert that the mapping is complete, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TestAutoMapperConfig.cs`的内容以获取映射器，然后断言映射已完成，如下所示代码：
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the test:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试：
- en: In Visual Studio 2022, navigate to **Test** | **Run All Tests**.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，导航到**测试** | **运行所有测试**。
- en: In Visual Studio Code, in **Terminal**, enter `dotnet test`.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code的**终端**中，输入`dotnet test`。
- en: 'Note the test fails because the `Total` member of the `Summary` view model
    is unmapped, as shown in *Figure 6.3*:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意测试失败是因为`Summary`视图模型的`Total`成员未映射，如图6.3所示：
- en: '![](img/B19587_06_03.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_06_03.png)'
- en: 'Figure 6.3: The test fails because the Total member is unmapped'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：测试失败是因为Total成员未映射
- en: 'In the `MappingObjects.Mappers` project, in the mapper configuration, after
    the mapping for the `FullName` member, add a mapping for the `Total` member, as
    shown highlighted in the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Mappers`项目中，在映射配置中，在`FullName`成员的映射之后，添加对`Total`成员的映射，如下所示代码中突出显示：
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the test and note that, this time, it passes.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意，这次它通过了。
- en: Performing live mappings between models
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模型之间执行实时映射
- en: 'Now that we have validated the configuration of our mapping, we can use it
    in a live console app:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了映射配置，我们可以在实时控制台应用程序中使用它：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `MappingObjects.Console` to the `Chapter06` solution.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将一个新的**控制台应用程序**/ `console`项目命名为`MappingObjects.Console`并添加到`Chapter06`解决方案中。
- en: 'In the `MappingObjects.Console` project, treat warnings as errors, globally
    and statically import the `System.Console` class, add a project reference for
    the two class libraries, and add a package reference for `AutoMapper`, as shown
    in the following markup:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MappingObjects.Console`项目中，将警告视为错误，全局和静态导入`System.Console`类，为两个类库添加项目引用，并为`AutoMapper`添加包引用，如下所示标记：
- en: '[PRE45]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Build the `MappingObjects.Console` project.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`MappingObjects.Console`。
- en: 'In `Program.cs`, delete the existing statements, add some statements to construct
    an example object model that represents a customer and their shopping cart with
    a couple of items, and then map it to a summary view model to present to the user,
    as shown in the following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，添加一些语句来构建一个表示客户及其购物车中几个项目的示例对象模型，并将其映射到摘要视图模型以向用户展示，如下所示代码：
- en: '[PRE46]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the console app and note the successful result, as shown in the following
    code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意成功的结果，如下所示代码：
- en: '[PRE47]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Optionally, write a unit test to perform a similar check as the preceding code
    to assert that the `Summary` has the correct full name and total.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，编写一个单元测试以执行与前面代码类似的检查，断言`Summary`具有正确的全名和总计。
- en: '**Good Practice**: There is a debate about when AutoMapper should be used that
    you can read about in an article (which has more links at the bottom) at the following
    link: [https://www.anthonysteele.co.uk/AgainstAutoMapper.html](https://www.anthonysteele.co.uk/AgainstAutoMapper.html).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：关于何时使用AutoMapper的讨论，您可以在以下链接的文章中阅读（文章底部有更多链接）：[https://www.anthonysteele.co.uk/AgainstAutoMapper.html](https://www.anthonysteele.co.uk/AgainstAutoMapper.html)。'
- en: '**More Information**: Learn more details at the following link: [https://automapper.org/](https://automapper.org/).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：了解更多详情，请访问以下链接：[https://automapper.org/](https://automapper.org/)。'
- en: Making fluent assertions in unit testing
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中进行流畅的断言
- en: '**FluentAssertions** are a set of extension methods that make writing and reading
    the code in unit tests and the error messages of failing tests more similar to
    a natural human language like English.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**FluentAssertions**是一组扩展方法，可以使在单元测试中编写和阅读代码以及失败的测试的错误消息更接近自然语言，如英语。'
- en: It works with most unit testing frameworks, including xUnit. When you add a
    package reference for a test framework, FluentAssertions will automatically find
    the package and use it for throwing exceptions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它与大多数单元测试框架兼容，包括xUnit。当你为测试框架添加包引用时，FluentAssertions会自动找到该包并将其用于抛出异常。
- en: After importing the `FluentAssertions` namespace, call the `Should()` extension
    method on a variable and then one of the hundreds of other extension methods to
    make assertions in a human-readable way. You can chain multiple assertions using
    the `And()` extension method or have separate statements, each calling `Should()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 `FluentAssertions` 命名空间后，对一个变量调用 `Should()` 扩展方法，然后调用数百种其他扩展方法之一以以人类可读的方式做出断言。您可以使用
    `And()` 扩展方法链式调用多个断言，或者有单独的语句，每个语句都调用 `Should()`。
- en: Making assertions about strings
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对字符串做出断言
- en: 'Let’s start by making assertions about a single `string` value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对单个 `string` 值做出断言开始：
- en: Use your preferred code editor to add a new **xUnit Test Project** / `xunit`
    named `FluentTests` to a `Chapter06` solution.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将一个新的 **xUnit 测试项目** / `xunit` 命名为 `FluentTests` 添加到 `Chapter06`
    解决方案中。
- en: 'In the `FluentTests` project, add a package reference to `FluentAssertions`,
    as highlighted in the following markup:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentTests` 项目中，添加对 `FluentAssertions` 的包引用，如下所示：
- en: '[PRE48]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`FluentAssertions` `7.0` should be available by the time this book is published.
    You can check at the following link: [https://www.nuget.org/packages/FluentAssertions/](https://www.nuget.org/packages/FluentAssertions/).'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FluentAssertions` `7.0` 应在本书出版时可用。您可以在以下链接中检查：[https://www.nuget.org/packages/FluentAssertions/](https://www.nuget.org/packages/FluentAssertions/)。'
- en: Build the `FluentTests` project.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `FluentTests`。
- en: Rename `UnitTest1.cs` to `FluentExamples.cs`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UnitTest1.cs` 重命名为 `FluentExamples.cs`。
- en: 'In `FluentExamples.cs`, import the namespace to make the `FluentAssertions`
    extension methods available and write a test method for a `string` value, as shown
    in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentExamples.cs` 中，导入命名空间以使 `FluentAssertions` 扩展方法可用，并编写一个针对 `string`
    值的测试方法，如下所示：
- en: '[PRE49]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the test:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试：
- en: In Visual Studio 2022, navigate to **Test** | **Run All Tests**.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中，导航到 **测试** | **运行所有测试**。
- en: In Visual Studio Code, in **Terminal**, enter `dotnet test`.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，在 **终端** 中输入 `dotnet test`。
- en: Note the test passes.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意测试通过。
- en: In the `TestString` method, for the `city` variable, delete the last `n` in
    `London`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TestString` 方法中，对于 `city` 变量，删除 `London` 中的最后一个 `n`。
- en: 'Run the test and note it fails, as shown in the following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意它失败，如下所示输出：
- en: '[PRE50]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Add the `n` back in `London`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `London` 中重新添加 `n`。
- en: Run the test again to confirm the fix.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试以确认修复。
- en: Making assertions about collections and arrays
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对集合和数组做出断言
- en: 'Now let’s continue by making assertions about collections and arrays:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续对集合和数组做出断言：
- en: 'In `FluentExamples.cs`, add a test method to explore collection assertions,
    as shown in the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentExamples.cs` 中，添加一个测试方法来探索集合断言，如下所示代码：
- en: '[PRE51]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the tests and note the collections test fails, as shown in the following
    output:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意集合测试失败，如下所示输出：
- en: '[PRE52]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Change `Charlie` to `Charly`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Charlie` 改为 `Charly`。
- en: Run the tests and note they succeed.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意它们成功。
- en: Making assertions about dates and times
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对日期和时间做出断言
- en: 'Let’s start by making assertions about date and time values:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对日期和时间值做出断言开始：
- en: 'In `FluentExamples.cs`, import the namespace for adding more extension methods
    for named months and other useful date/time-related functionality, as shown in
    the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentExamples.cs` 中，导入命名空间以添加更多针对命名月份和其他有用的日期/时间相关功能的扩展方法，如下所示：
- en: '[PRE53]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a test method to explore date/time assertions, as shown in the following
    code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试方法来探索日期/时间断言，如下所示：
- en: '[PRE54]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the tests and note the date/time test fails, as shown in the following
    output:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意日期/时间测试失败，如下所示输出：
- en: '[PRE55]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the `due` variable, change the hour from `11` to `13`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `due` 变量，将小时从 `11` 改为 `13`。
- en: Run the tests and note that the date/time test succeeds.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并注意日期/时间测试成功。
- en: '**More Information**: You can learn more details about FluentAssertions at
    the following link: [https://fluentassertions.com/](https://fluentassertions.com/).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于 FluentAssertions 的详细信息：[https://fluentassertions.com/](https://fluentassertions.com/)。'
- en: Validating data
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证数据
- en: '**FluentValidation** allows you to define strongly typed validation rules in
    a human-readable way.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**FluentValidation** 允许您以人类可读的方式定义强类型验证规则。'
- en: You create a validator for a type by inheriting from `AbstractValidator<T>`,
    where `T` is the type that you want to validate. In the constructor, you call
    the `RuleFor` method to define one or more rules. If a rule should run only in
    specified scenarios, then you call the `When` method.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过从 `AbstractValidator<T>` 继承来为类型创建验证器，其中 `T` 是您想要验证的类型。在构造函数中，您调用 `RuleFor`
    方法来定义一个或多个规则。如果规则应在指定的场景中运行，则调用 `When` 方法。
- en: Understanding the built-in validators
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内置验证器
- en: 'FluentValidation ships with lots of useful built-in validator extension methods
    for defining rules, as shown in the following partial list, some of which you
    will explore in the coding task in this section:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: FluentValidation 随带了许多有用的内置验证器扩展方法，用于定义规则，如下面的部分列表所示，其中一些您将在本节的编码任务中探索：
- en: '`Null`, `NotNull`, `Empty`, `NotEmpty`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Null`, `NotNull`, `Empty`, `NotEmpty`'
- en: '`Equal`, `NotEqual`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Equal`, `NotEqual`'
- en: '`Length`, `MaxLength`, `MinLength`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Length`, `MaxLength`, `MinLength`'
- en: '`LessThan`, `LessThanOrEqualTo`, `GreaterThan`, `GreaterThanOrEqualTo`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LessThan`, `LessThanOrEqualTo`, `GreaterThan`, `GreaterThanOrEqualTo`'
- en: '`InclusiveBetween`, `ExclusiveBetween`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InclusiveBetween`, `ExclusiveBetween`'
- en: '`ScalePrecision`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScalePrecision`'
- en: '`Must` (aka predicate)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Must`（即谓词）'
- en: '`Matches` (aka regular expression), `EmailAddress`, `CreditCard`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Matches`（即正则表达式），`EmailAddress`, `CreditCard`'
- en: '`IsInEnum`, `IsEnumName`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsInEnum`, `IsEnumName`'
- en: Performing custom validation
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行自定义验证
- en: The easiest way to create custom rules is to use `Predicate` to write a custom
    validation function. You can also call the `Custom` method to get maximum control.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义规则的最简单方法是使用 `Predicate` 编写自定义验证函数。您还可以调用 `Custom` 方法以获得最大控制。
- en: Customizing validation messages
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义验证消息
- en: 'There are a few extension methods that are used to customize the validation
    messages’ output when data fails to pass the rules:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些扩展方法用于在数据未通过规则时自定义验证消息的输出：
- en: '`WithName`: Change the name used for a property in the message.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithName`: 更改消息中使用的属性名称。'
- en: '`WithSeverity`: Change the default severity from `Error` to `Warning` or some
    other level.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithSeverity`: 将默认严重性从 `Error` 更改为 `Warning` 或其他级别。'
- en: '`WithErrorCode`: Assign an error code that can be output in the message.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithErrorCode`: 分配一个错误代码，可以在消息中输出。'
- en: '`WithState`: Add some state that can be used in the message.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithState`: 添加一些可以在消息中使用的状态。'
- en: '`WithMessage`: Customize the format of the default message.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithMessage`: 自定义默认消息的格式。'
- en: Defining a model and validator
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型和验证器
- en: 'Let’s see an example of FluentValidation in action. You will create three projects:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 FluentValidation 的实际应用示例。您将创建三个项目：
- en: A class library for a model to validate that represents an order made by a customer.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于验证代表客户下单的模型的类库。
- en: A class library for the validator for the model.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于验证模型的验证器类库。
- en: A console app to perform a live validation.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于执行实时验证的控制台应用程序。
- en: 'Let’s start:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `FluentValidation.Models` to the `Chapter06` solution.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，将一个名为 `FluentValidation.Models` 的新 **类库**/ `classlib` 项目添加到 `Chapter06`
    解决方案中。
- en: In the `FluentValidation.Models` project, delete the file named `Class1.cs`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentValidation.Models` 项目中，删除名为 `Class1.cs` 的文件。
- en: 'In the `FluentValidation.Models` project, add a new class file named `CustomerLevel.cs`
    and modify its contents to define an `enum` with three customer levels, `Bronze`,
    `Silver`, and `Gold`, as shown in the following code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentValidation.Models` 项目中，添加一个名为 `CustomerLevel.cs` 的新类文件，并修改其内容以定义一个包含三个客户级别
    `Bronze`、`Silver` 和 `Gold` 的 `enum`，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `FluentValidation.Models` project, add a new class file named `Order.cs`
    and modify its contents, as shown in the following code:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentValidation.Models` 项目中，添加一个名为 `Order.cs` 的新类文件，并修改其内容，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `FluentValidation.Validators` to the `Chapter06` solution.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器，将一个名为 `FluentValidation.Validators` 的新 **类库**/ `classlib` 项目添加到
    `Chapter06` 解决方案中。
- en: 'In the `FluentValidation.Validators` project, add a project reference to the
    `Models` project and a package reference to the `FluentValidation` package, as
    shown in the following markup:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentValidation.Validators` 项目中，将 `Models` 项目添加为项目引用，并将 `FluentValidation`
    包添加为包引用，如下面的标记所示：
- en: '[PRE58]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Build the `FluentValidation.Validators` project.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建的 `FluentValidation.Validators` 项目。
- en: In the `FluentValidation.Validators` project, delete the file named `Class1.cs`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FluentValidation.Validators` 项目中，删除名为 `Class1.cs` 的文件。
- en: 'In the `FluentValidation.Validators` project, add a new class file named `OrderValidator.cs`
    and modify its contents, as shown in the following code:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FluentValidation.Validators`项目中，添加一个名为`OrderValidator.cs`的新类文件，并修改其内容，如下所示：
- en: '[PRE59]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Testing the validator
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试验证器
- en: 'Now we are ready to create a console app to test the validator on the model:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建一个控制台应用程序来测试模型上的验证器：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `FluentValidation.Console` to a `Chapter06` solution.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，向`Chapter06`解决方案中添加一个名为`FluentValidation.Console`的新**控制台应用程序**/`console`项目。
- en: 'In the `FluentValidation.Console` project, treat warnings as errors, globally
    and statically import the `System.Console` class, and add project references for
    `FluentValidation.Validators` and `FluentValidation.Models`, as shown in the following
    markup:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FluentValidation.Console`项目中，将警告视为错误，全局和静态导入`System.Console`类，并为`FluentValidation.Validators`和`FluentValidation.Models`添加项目引用，如下所示：
- en: '[PRE60]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Build the `FluentValidation.Console` project to build referenced projects.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`FluentValidation.Console`以构建引用的项目。
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    create an order and validate it, as shown in the following code:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中删除现有语句，然后添加创建订单并验证的语句，如下所示：
- en: '[PRE61]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the console app and note the failed rules, as shown in the following output:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意以下输出中显示的失败规则：
- en: '[PRE62]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Comment out the two statements that set the culture to see the output in your
    local language and region. For example, if you are in France (`fr-FR`), it would
    look like the following:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释设置文化的两个语句，以查看您本地语言和区域的输出。例如，如果您在法国（`fr-FR`），它将如下所示：
- en: '[PRE63]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Set some property values for the order, as shown highlighted in the following
    code:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置订单的一些属性值，如下所示（高亮显示的代码）：
- en: '[PRE64]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Set the current culture to US English to make sure you see the same output as
    in this book. You can experiment with your own culture later.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前文化设置为美国英语，以确保您看到的输出与本书中的输出相同。您可以在以后尝试自己的文化设置。
- en: 'Run the console app and note the failed rules, as shown in the following output:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意以下输出中显示的失败规则：
- en: '[PRE65]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Modify some property values for the order, as shown highlighted in the following
    code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改订单的一些属性值，如下所示（高亮显示的代码）：
- en: '[PRE66]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the console app and note the order is now valid, as shown in the following
    output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意订单现在有效，如下所示：
- en: '[PRE67]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Validating data with ASP.NET Core
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core验证数据
- en: For automatic data validation with ASP.NET Core, FluentValidation supports .NET
    Core 3.1 and later.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用ASP.NET Core进行自动数据验证，FluentValidation支持.NET Core 3.1及更高版本。
- en: '**More Information**: Learn more details at the following link: [https://cecilphillip.com/fluent-validation-rules-with-asp-net-core/](https://cecilphillip.com/fluent-validation-rules-with-asp-net-core/).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：在以下链接中了解更多详细信息：[https://cecilphillip.com/fluent-validation-rules-with-asp-net-core/](https://cecilphillip.com/fluent-validation-rules-with-asp-net-core/)。'
- en: Generating PDFs
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成PDF文件
- en: One of the most common questions I get when teaching C# and .NET is, “What open-source
    library is available to generate PDF files?”
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在教授C#和.NET时，我经常被问到的一个最常见问题是：“有什么开源库可以用来生成PDF文件？”
- en: There are many licensed libraries for generating PDF files, but over the years,
    it has been difficult to find cross-platform open-source ones.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 生成PDF文件的授权库有很多，但多年来，找到跨平台的开源库一直很困难。
- en: QuestPDF says, “*If you are consuming the QuestPDF library as a Direct Package
    Dependency for usage in a Closed Source software in the capacity of a for-profit
    company/individual with more than 1M USD annual gross revenue, you must purchase
    the QuestPDF Professional or Enterprise License, depending on the number of software
    developers. Please refer to the QuestPDF License and Pricing webpage for more
    details. (*[https://www.questpdf.com/pricing.html](https://www.questpdf.com/pricing.html)*)*”
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: QuestPDF表示：“*如果您作为年收入超过100万美元的营利性公司/个人，以直接包依赖项的方式使用QuestPDF库在闭源软件中，您必须根据软件开发人员的数量购买QuestPDF专业版或企业版许可证。请参阅QuestPDF许可和定价网页以获取更多详细信息。（[https://www.questpdf.com/pricing.html](https://www.questpdf.com/pricing.html)）*”
- en: The older 2022.12.X release will always be available under the MIT license,
    free for commercial usage. If you want to support library development, please
    consider purchasing the Professional License for version 2023.1.X or later.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的2022.12.X版本将始终在MIT许可下可用，免费用于商业用途。如果您想支持库开发，请考虑购买2023.1.X或更高版本的Professional许可证。
- en: Using QuestPDF on Apple silicon Macs
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Apple硅Mac上使用QuestPDF
- en: QuestPDF uses SkiaSharp, which has implementations for Windows, Mac, and Linux
    operating systems. The console app that you create in this section to generate
    PDFs is therefore cross-platform. But on an Apple silicon Mac, like my Mac mini
    M1, I had to install the x64 version of .NET SDK and start the project using `dotnet
    new -a x64`. This tells the .NET SDK to use the x64 architecture, otherwise the
    SkiaSharp libraries give an error because they have not yet been built to target
    ARM64.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: QuestPDF 使用 SkiaSharp，它为 Windows、Mac 和 Linux 操作系统提供了实现。因此，您在本节中创建的用于生成 PDF 的控制台应用程序是跨平台的。但在苹果硅
    Mac（如我的 Mac mini M1）上，我必须安装 x64 版本的 .NET SDK，并使用 `dotnet new -a x64` 启动项目。这告诉
    .NET SDK 使用 x64 架构，否则 SkiaSharp 库会报错，因为它们尚未构建以针对 ARM64。
- en: Creating class libraries to generate PDF documents
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于生成 PDF 文档的类库
- en: 'Let’s see an example of QuestPDF in action. You will create three projects:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 QuestPDF 的一个实际例子。您将创建三个项目：
- en: A class library for a model that represents a catalog of product categories
    with names and images.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示具有名称和图像的产品类别目录的模型的类库。
- en: A class library for the document template.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于文档模板的类库。
- en: A console app to perform a live generation of a PDF file.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于执行实时生成 PDF 文件的控制台应用程序。
- en: 'Let’s start:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `GeneratingPdf.Models` to the `Chapter06` solution.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将一个名为 `GeneratingPdf.Models` 的新 **类库** / `classlib` 项目添加到 `Chapter06`
    解决方案中。
- en: In the `GeneratingPdf.Models` project, delete the file named `Class1.cs`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Models` 项目中，删除名为 `Class1.cs` 的文件。
- en: 'In the `GeneratingPdf.Models` project, add a new class file named `Category.cs`
    and modify its contents to define a class with two properties for the name and
    identifier of a category, as shown in the following code:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Models` 项目中，添加一个名为 `Category.cs` 的新类文件，并修改其内容以定义一个包含类别名称和标识符的两个属性的类，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Later, you will create an `images` folder with filenames that use the pattern
    `categoryN.jpeg`, where `N` is a number from 1 to 8 that matches the `CategoryId`
    values.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，您将创建一个 `images` 文件夹，其文件名使用 `categoryN.jpeg` 的模式，其中 `N` 是从 1 到 8 的数字，与 `CategoryId`
    值匹配。
- en: 'In the `GeneratingPdf.Models` project, add a new class file named `Catalog.cs`
    and modify its contents to define a class with a property to store the eight categories,
    as shown in the following code:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Models` 项目中，添加一个名为 `Catalog.cs` 的新类文件，并修改其内容以定义一个包含存储八个类别的属性的类，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Use your preferred code editor to add a new **Class Library** / `classlib` project
    named `GeneratingPdf.Document` to the `Chapter06` solution.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将一个名为 `GeneratingPdf.Document` 的新 **类库** / `classlib` 项目添加到 `Chapter06`
    解决方案中。
- en: 'In the `GeneratingPdf.Document` project, add a package reference for `QuestPDF`
    and a project reference for the `Models` class library, as shown in the following
    markup:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Document` 项目中，添加对 `QuestPDF` 的包引用和对 `Models` 类库的项目引用，如下面的标记所示：
- en: '[PRE70]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Build the `GeneratingPdf.Document` project.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `GeneratingPdf.Document` 项目。
- en: In the `GeneratingPdf.Document` project, delete the file named `Class1.cs`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Document` 项目中，删除名为 `Class1.cs` 的文件。
- en: In the `GeneratingPdf.Document` project, add a new class file named `CatalogDocument.cs`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Document` 项目中，添加一个名为 `CatalogDocument.cs` 的新类文件。
- en: 'In `CatalogDocument.cs`, define a class that implements the `IDocument` interface
    to define a template with a header and a footer, and then output the eight categories,
    including name and image, as shown in the following code:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CatalogDocument.cs` 中，定义一个实现 `IDocument` 接口的类，以定义一个包含页眉和页脚的模板，然后输出八个类别，包括名称和图像，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Creating a console app to generate PDF documents
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于生成 PDF 文档的控制台应用程序
- en: 'Now we can create a console app project that will use the class libraries to
    generate a PDF document:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个控制台应用程序项目，它将使用类库生成 PDF 文档：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `GeneratingPdf.Console` to a `Chapter06` solution.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，将一个名为 `GeneratingPdf.Console` 的新 **控制台应用程序** / `console` 项目添加到 `Chapter06`
    解决方案中。
- en: 'In the `GeneratingPdf.Console` project, create an `images` folder and download
    the eight category images 1 to 8 from the following link to it: [https://github.com/markjprice/apps-services-net8/tree/master/images/Categories](https://github.com/markjprice/apps-services-net8/tree/master/images/Categories).'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Console` 项目中，创建一个 `images` 文件夹，并从以下链接下载 1 到 8 的八个类别图像到该文件夹：[https://github.com/markjprice/apps-services-net8/tree/master/images/Categories](https://github.com/markjprice/apps-services-net8/tree/master/images/Categories)。
- en: 'If you are using Visual Studio 2022 or JetBrains Rider, then the `images` folder
    and its files must be copied to the `GeneratingPdf.Console\bin\Debug\net8` folder:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio 2022 或 JetBrains Rider，那么 `images` 文件夹及其文件必须复制到 `GeneratingPdf.Console\bin\Debug\net8`
    文件夹：
- en: In **Solution Explorer**, select all the images.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，选择所有图像。
- en: In **Properties**, set **Copy To Output Directory** to **Copy Always**.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 中，将 **复制到输出目录** 设置为 **始终复制**。
- en: 'Open the project file and note the `<ItemGroup>` entries that will copy the
    eight images to the correct folder, as partially shown in the following markup:'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目文件，注意将八张图片复制到正确文件夹的 `<ItemGroup>` 条目，如下所示的部分标记：
- en: '[PRE72]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the `GeneratingPdf.Console` project, treat warnings as errors, globally
    and statically import the `System.Console` class, and add a project reference
    for the `Document` template class library, as shown in the following markup:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeneratingPdf.Console` 项目中，将警告视为错误，全局和静态导入 `System.Console` 类，并为 `Document`
    模板类库添加项目引用，如下所示的部分标记：
- en: '[PRE73]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Build the `GeneratingPdf.Console` project.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `GeneratingPdf.Console` 项目。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    create a catalog model, pass it to a catalog document, generate a PDF file, and
    then attempt to open the file using the appropriate operating system command,
    as shown in the following code:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加语句来创建目录模型，将其传递给目录文档，生成 PDF 文件，然后尝试使用适当的操作系统命令打开文件，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `Process` class and its `Start` method should also be able to start processes
    on Mac and Linux, but getting the paths right can be tricky, so I’ve left that
    as an optional exercise for the reader. You can learn more about the `Process`
    class and its `Start` method at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start).'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Process` 类及其 `Start` 方法也应该能够在 Mac 和 Linux 上启动进程，但正确获取路径可能很棘手，所以我将其留作读者的可选练习。你可以在以下链接中了解更多关于
    `Process` 类及其 `Start` 方法的知识：[https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start).'
- en: 'Run the console app and note the PDF file generated, as shown in *Figure 6.4*:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意生成的 PDF 文件，如图 *6.4* 所示：
- en: '![](img/B19587_06_04.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_06_04.png)'
- en: 'Figure 6.4: A PDF file generated from C# code'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：从 C# 代码生成的 PDF 文件
- en: '**More Information**: Learn more details at the following link: [https://www.questpdf.com/](https://www.questpdf.com/).'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**: 在以下链接中了解更多详情：[https://www.questpdf.com/](https://www.questpdf.com/).'
- en: Practicing and exploring
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and doing deeper research into the topics in this chapter.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习，并对本章中的主题进行深入研究来测试你的知识和理解。
- en: Exercise 6.1 – Test your knowledge
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.1 – 测试你的知识
- en: 'Use the web to answer the following questions:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络回答以下问题：
- en: What is the most downloaded third-party `NuGet` package of all time?
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有时间中最受欢迎的第三方 `NuGet` 包是什么？
- en: What method do you call on the `ImageSharp Image` class to make a change like
    resizing the image or replacing colors with grayscale?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在 `ImageSharp Image` 类上调用哪个方法来执行像调整大小或用灰度替换颜色这样的更改？
- en: What is a key benefit of using `Serilog` for logging?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Serilog` 进行日志记录的主要好处是什么？
- en: What is a Serilog sink?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Serilog 沉淀器是什么？
- en: Should you always use a package like `AutoMapper` to map between objects?
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该始终使用像 `AutoMapper` 这样的包来在对象之间进行映射？
- en: Which `FluentAssertions` method should you call to start a fluent assertion
    on a value?
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该调用哪个 `FluentAssertions` 方法来开始对值进行流畅断言？
- en: Which `FluentAssertions` method should you call to assert that all items in
    a sequence conform to a condition, like a `string` item must have less than six
    characters?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该调用哪个 `FluentAssertions` 方法来断言序列中的所有项目都符合某个条件，例如一个 `string` 项目必须少于六个字符？
- en: Which `FluentValidation` class should you inherit from to define a custom validator?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该从哪个 `FluentValidation` 类继承来定义自定义验证器？
- en: With `FluentValidation`, how can you set a rule to only apply in certain conditions?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `FluentValidation`，你如何设置仅在特定条件下应用的规则？
- en: With `QuestPDF`, which interface must you implement to define a document for
    a PDF and what methods of that interface must you implement?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `QuestPDF`，你必须实现哪个接口来定义 PDF 文档，以及该接口必须实现哪些方法？
- en: Exercise 6.2 – Explore topics
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.2 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一页上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-6---implementing-popular-third-party-libraries](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-6---implementing-popular-third-party-libraries)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-6---implementing-popular-third-party-libraries](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-6---implementing-popular-third-party-libraries)'
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you explored some third-party libraries that are popular with
    .NET developers to perform functions, including:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探索了一些受.NET开发者欢迎的第三方库，用于执行以下功能：
- en: Manipulating images using a Microsoft-recommended third-party library named
    ImageSharp.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微软推荐的第三方库ImageSharp来操作图像。
- en: Making text, numbers, dates, and times friendlier with Humanizer.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Humanizer使文本、数字、日期和时间更友好。
- en: Logging structured data with Serilog.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Serilog记录结构化数据。
- en: Mapping between objects, for example, entity models to view models.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象之间的映射，例如，实体模型到视图模型。
- en: Making fluent assertions in unit testing.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中进行流畅的断言。
- en: Validating data in a local culture language-readable way.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以本地文化语言可读的方式验证数据。
- en: Generating a PDF file.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成PDF文件。
- en: In the next chapter, we will learn how to handle internationalization with dates
    and times and localization, including a new type in .NET 8 for making it easier
    to unit test components with a dependency on the current time.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何处理日期和时间的国际化以及本地化，包括.NET 8中的一个新类型，它使得对依赖于当前时间的组件进行单元测试更容易。
- en: Learn more on Discord
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
- en: '![](img/QR_Code3048220001028652625.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code3048220001028652625.png)'
