<html><head></head><body>
		<div><h1 id="_idParaDest-162"><em class="italic"><a id="_idTextAnchor162"/>Chapter 10</em>: Designing and Implementing Microsoft DevOps Solutions</h1>
			<p>In the previous chapter, we learned about the key characteristics of modern web solutions. We also explored the project structure of the three main frontend frameworks and provided a quick comparison. We then learned the three hosting options in Azure and how to choose the best hosting approach for our solution.</p>
			<p>In this chapter, we will learn how to effectively plan and manage <strong class="bold">DevOps</strong> processes while building Microsoft solutions. Azure DevOps offers a set of modern tools that allow us to plan smarter and develop a product faster. It also provides solid collaboration between the team members to deliver better quality products.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring agile planning with <strong class="bold">Azure Boards</strong></li>
				<li>Learning about source control</li>
				<li>Understanding Git repositories, along with branching and pull requests</li>
				<li>Getting to know <strong class="bold">Azure Artifacts</strong></li>
				<li>Understanding the logic behind the CI/CD practices</li>
			</ul>
			<p>By the end of this chapter, we will have learned how to make use of DevOps to build, test, and deploy our applications using modern software development practices. Moreover, we will know about Work Items, and we will have learned about <strong class="bold">Git</strong> and its main capabilities. We will have also explored how to manage packages using Azure Artifacts, and also understood the <strong class="bold">continuous integration</strong>/<strong class="bold">continuous development</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) practices.</p>
			<p>Now, let's take a look at the key characteristics of modern web solutions.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor163"/>Exploring Agile planning with Azure Boards</h1>
			<p>Azure <a id="_idIndexMarker678"/>Boards is a service provided by <strong class="bold">Microsoft</strong> as <a id="_idIndexMarker679"/>part of the Azure DevOps service. It provides a set of features and capabilities for managing the entire life cycle of the software project. It includes tools for managing <strong class="bold">Work Items</strong>, <strong class="bold">Sprints</strong>, and <strong class="bold">Backlogs</strong>. Moreover, it provides end-to-end predefined and customizable dashboards, allowing us to dig deeper into the big picture of the project's activities, alongside essential <strong class="bold">KPIs</strong> and metrics, to understand how the project is progressing.</p>
			<p>Let's start by exploring the core features of Azure Boards.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor164"/>Introducing Work Items</h2>
			<p><strong class="bold">Work Items</strong> are the<a id="_idIndexMarker680"/> core components in <a id="_idIndexMarker681"/>Azure DevOps and can help our Agile team manage their daily work, organize Sprints, and prioritize tasks in Backlogs. A Work Item can be a general task, an issue, or a requirement. The following screenshot shows the landing page of <strong class="bold">Work Items</strong>:</p>
			<div><div><img src="img/Figure_10.01_B17366.jpg" alt="Figure 10.1: Work Items landing page"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Work Items landing page</p>
			<p>The preceding screenshot represents the home page of all <strong class="bold">Work Items</strong>, where we can filter items based on specific criteria. We can also assign items, add new items, and manage existing ones. This page provides every person that's working on the project with a complete view of the progress, along with the status of each item and who is doing what. We can filter to see tasks that were planned to be delivered in the next <strong class="bold">Sprints</strong>.</p>
			<p>We can also specify the dependencies between the items to break large tasks down into smaller, more manageable items, as well as create queries and save them for later use. A query is a filtered view of all the <strong class="bold">Work Items</strong>. For example, we can create a query to display the active tasks, or a query to display tasks that have been assigned to a particular team member.</p>
			<p>It is easy to <a id="_idIndexMarker682"/>create a new Work Item. As shown<a id="_idIndexMarker683"/> in the following screenshot, we just need to click on <strong class="bold">New Work Item</strong> and then choose the type; that is, <strong class="bold">Epic</strong>, <strong class="bold">Issue</strong>, or <strong class="bold">Task</strong>:</p>
			<div><div><img src="img/Figure_10.02_B17366.jpg" alt="Figure 10.2: Action menu for creating a new Work Item"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Action menu for creating a new Work Item</p>
			<p>In the action menu, we can see three main types of Work Items:</p>
			<ul>
				<li><strong class="bold">Epic</strong>: This represents a large item that's required for the product to function. It can be broken down into smaller user stories. A user story is a specific Work Item within <strong class="bold">Epic</strong>. For example, let's assume we have received a request to implement a login mechanism for an e-commerce website. In this case, the Epic represents this request. The user stories here could be <strong class="bold">Login with Email</strong>, <strong class="bold">Login with Google</strong>, <strong class="bold">Login with Facebook</strong>, and <strong class="bold">Forgot password</strong>.</li>
				<li><strong class="bold">Feature</strong>: This represents the bulk of the functionality that fulfils users' needs. A <strong class="bold">Feature</strong> is a collection of user stories that delivers business value and the context of the software product.</li>
				<li><code>role-feature-benefit</code> template: as a (<em class="italic">user role</em>), I want (<em class="italic">an action/or goal</em>) so that (<em class="italic">a benefit/or reason</em>); for example: as a (<em class="italic">customer</em>), I want (<em class="italic">a shopping cart functionality</em>) so that (<em class="italic">I can buy items and pay online</em>).</li>
				<li><strong class="bold">Issue</strong>: This represents bugs, code defects, and software issues that we may capture while developing the product.</li>
				<li><strong class="bold">Task</strong>: This <a id="_idIndexMarker684"/>represents a Work Item<a id="_idIndexMarker685"/> that has been planned as part of building the product. This can be either a result of an issue or requirements, including requirement analysis, development, or testing.</li>
			</ul>
			<p>The following screenshot shows the details page of a sample Work Item:</p>
			<div><div><img src="img/Figure_10.03_B17366.jpg" alt="Figure 10.3: A bug item details page"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3: A bug item details page</p>
			<p>On the details page, we can see that every Work Item has a title with a unique ID, status, and iteration, along with the steps to reproduce if it is a defect, or an item description if it is a requirement.</p>
			<p>We can also see the comments that are attached to the Work Item. These represent the discussion happening between the team members about this Work Item. We can follow a Work Item to<a id="_idIndexMarker686"/> receive notifications <a id="_idIndexMarker687"/>whenever there is an update. We can also assign it to a team member, as well as link it to another Work Item by, for example, linking an issue to a task or Epic.</p>
			<p>In the next section, we will learn how to use Work Items to report and organize work.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor165"/>Exploring Boards, Backlogs, and Sprints</h2>
			<p>In the<a id="_idIndexMarker688"/> previous<a id="_idIndexMarker689"/> section, we<a id="_idIndexMarker690"/> learned<a id="_idIndexMarker691"/> about<a id="_idIndexMarker692"/> Work<a id="_idIndexMarker693"/> Items, so let's learn how to use them in Boards, Backlogs, and Sprints to organize and track team deliverables.</p>
			<p>The following screenshot shows a sample board that was associated with a project upon its creation:</p>
			<div><div><img src="img/Figure_10.04_B17366.jpg" alt="Figure 10.4: Sample Kanban Board"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4: Sample Kanban Board</p>
			<p>Every time we create a new project, there is a preconfigured <strong class="bold">Kanban Board</strong> that is created and linked to the project so that we can visualize the progress of work items. This board is fully customizable. We can drag and drop items from one category to another to reflect the current situation of the project. We can also organize tasks by status, ownership, Sprints, or any other criteria.</p>
			<p><strong class="bold">Backlogs</strong> help us keep things organized according to priorities. As shown in the following<a id="_idIndexMarker694"/> screenshot, Backlogs <a id="_idIndexMarker695"/>provide<a id="_idIndexMarker696"/> a <a id="_idIndexMarker697"/>flat view of <a id="_idIndexMarker698"/>the <a id="_idIndexMarker699"/>Work Items, while Boards display them as cards:</p>
			<div><div><img src="img/Figure_10.05_B17366.jpg" alt="Figure 10.5: Backlogs list view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5: Backlogs list view</p>
			<p>The product backlog should reflect the plan and roadmap of what we plan to deliver in the upcoming Sprints.</p>
			<p>Finally, <strong class="bold">Sprints</strong> are the heartbeat of DevOps as they represent the iterations of an Agile project. A Sprint has its own <strong class="bold">Capacity</strong> planning and <strong class="bold">Taskboard</strong>. It should be short in terms of duration, typically between 1 to 4 weeks; during this period, there must be a set of Work Items that should be accomplished by the team. The following screenshot shows a sample <strong class="bold">Sprint</strong> view:</p>
			<div><div><img src="img/Figure_10.06_B17366.jpg" alt="Figure 10.6: Sprint view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6: Sprint view</p>
			<p>In the <a id="_idIndexMarker700"/>preceding <a id="_idIndexMarker701"/>screenshot, we<a id="_idIndexMarker702"/> can<a id="_idIndexMarker703"/> see how<a id="_idIndexMarker704"/> the<a id="_idIndexMarker705"/> tasks are organized in the <strong class="bold">Taskboard</strong> area to reflect the plan of a <strong class="bold">Sprint</strong>. We can drag and drop items between the different categories, and we can check the overall progress of the team in this <strong class="bold">Sprint</strong>.</p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">The Microsoft documentation for learning about and understanding everything related to Azure Boards can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/boards/?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/boards/?view=azure-devops</a>.</p>
			<p>In this section, we learned how to define the project roadmap and plan Work Items. This helps our team break down complex solutions into manageable workloads by using a robust platform from Azure DevOps. In the next section, we will learn about source control in Azure DevOps.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor166"/>Getting started with source control</h1>
			<p><strong class="bold">Source control</strong> (also<a id="_idIndexMarker706"/> known as <strong class="bold">version control</strong>) is an essential <a id="_idIndexMarker707"/>part of DevOps. It is a collaboration platform that can be used by the development team to track and manage changes in the source code. It provides a historical version of each source code file in the project. It also helps resolve conflicts when merging changes from multiple developers. <strong class="bold">Azure Repos</strong> is a set of version control tools that we can use to manage our code.</p>
			<p>Here is a list of source control benefits:</p>
			<ul>
				<li>Ability to create multiple workflows for development, production, and testing.</li>
				<li>There is a lot of collaboration that must be done by the development team to deliver the product, especially at the source code level, to maintain a common repository when multiple developers are working on the same project.</li>
				<li>Source control supports us tracking and managing all the changes that have been made to the code by multiple team members. This is very important, especially when we need to resolve conflicts when multiple developers try to modify the same file.</li>
				<li>Maintains a history of changes by allowing us to retrieve the complete history of every file in the repository.</li>
				<li>Ability to label the source code to keep track of the product version, especially when we have multiple releases. We can also create branches to manage the development activities between the production and development environments.</li>
			</ul>
			<p>Azure Repos provides two types of version control:</p>
			<ul>
				<li><strong class="bold">Team Foundation Version Control</strong> (<strong class="bold">TFVC</strong>): The code history is centralized on the <a id="_idIndexMarker708"/>server and team members need to be connected to check in.</li>
				<li><strong class="bold">Git</strong>: The code history is distributed on each team member's machine, where they can commit <a id="_idIndexMarker709"/>changes locally.</li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor167"/>Scaling Git for enterprise DevOps</h1>
			<p>Git is one of<a id="_idIndexMarker710"/> the most essential version control systems that is<a id="_idIndexMarker711"/> adopted by development teams and companies. Git is a distributed version control system, which means the local copy of the source code that's stored on each machine represents a complete version control repository.</p>
			<p>In this section, we will learn more about Git and how to structure repositories, manage branches, and collaborate with pull requests.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>Structuring Git repos</h2>
			<p>There <a id="_idIndexMarker712"/>are two <a id="_idIndexMarker713"/>types of repositories that we can use with Git:</p>
			<ul>
				<li><strong class="bold">Mono-repo</strong>: More<a id="_idIndexMarker714"/> than <a id="_idIndexMarker715"/>one project is stored in a single repository</li>
				<li><strong class="bold">Multi-repo</strong>: Each<a id="_idIndexMarker716"/> project <a id="_idIndexMarker717"/>has its own repository</li>
			</ul>
			<p>Mono versus multi; <em class="italic">what's the right approach?</em> There is no direct answer that would recommend a particular approach. The strategy that we choose to use in order to structure our repositories is totally based on our way of managing projects; both types have their advantages and disadvantages. However, it is good to mention that <strong class="bold">Facebook</strong> and <strong class="bold">Google</strong> use mono-repos to manage their projects. Here are some key points to help you decide which strategy to follow:</p>
			<ul>
				<li>Mono-repo facilitates managing dependencies that may be complex if we use multi-repo.</li>
				<li>With mono-repo, we may face some performance drawbacks in the case of a large code base. This is not a problem in multi-repo.</li>
				<li>It's noticeable that enforcing common practices and standards is easier in mono-repo than in multi-repo.</li>
				<li>Multi-repo allows us to work efficiently by enabling each microservice team to work <a id="_idIndexMarker718"/>independently to finish their work faster. This allows us to grant developers access to the repositories they need to access.</li>
			</ul>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>Branching strategy with Git</h2>
			<p>Git branches <a id="_idIndexMarker719"/>are effective references to a snapshot of the code changes. A branch provides a way to isolate changes related to a new feature or a hotfix from the main branch of the code. Code changes that are committed to one branch don't affect the other branches automatically, unless we merge changes. </p>
			<p>It is essential to adopt a branching strategy and make it simple by following these three concepts:</p>
			<ul>
				<li>Create a new branch for every feature or set of features of a particular release. This is also applicable in the case of releasing hotfixes after fixing defects.</li>
				<li>Merge sub-branches into the main branch by using pull requests. Never merge code into the main branch unless the code had been tested properly, and also ensure that the affected functionalities are working well and certified.</li>
				<li>Keep the main branch up to date and never modify code directly inside it.</li>
			</ul>
			<p>The following diagram shows how all the sub-branches merge their updates into the main branch:</p>
			<div><div><img src="img/Figure_10.07_B17366.jpg" alt="Figure 10.7: Merging sub-branches into the main branch"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7: Merging sub-branches into the main branch</p>
			<p>There are many<a id="_idIndexMarker720"/> branching strategies that you can implement. The most important part is to separate the development activities from the production code by <a id="_idIndexMarker721"/>creating two separate branches. One of the strategies that we can follow is the <strong class="bold">trunk-based branching</strong> strategy, as shown in the following diagram: </p>
			<div><div><img src="img/Figure_10.08_B17366.jpg" alt="Figure 10.8: Trunk-based branching strategy"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8: Trunk-based branching strategy</p>
			<p>In the preceding diagram, we can see the two main branches: development (<strong class="bold">Dev</strong>) and production (<strong class="bold">Main</strong>). The concept here is that we never write code directly into the <strong class="bold">Main</strong> branch. Instead, we need to create a branch for hotfixes; at the same time, the hotfixes should be merged with <strong class="bold">Dev</strong> after proper testing.</p>
			<p>As for the <strong class="bold">Release</strong> branch, it is usually created from the development branch. After development and proper testing, it is merged with both the production and development branches. This way, we make sure that the <strong class="bold">Main</strong> branch contains the production version of the code, while the <strong class="bold">Dev</strong> branch contains the development branches.</p>
			<p>Git branches are inexpensive to create and maintain. Therefore, as shown in the preceding diagram, we created a separate branch. Even small fixes and changes should have their own<a id="_idIndexMarker722"/> feature branches, which should simplify reviewing the history of the changes. When creating a new branch, it is important to provide descriptive information about the branch and link it to a Work Item.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor170"/>Collaborating with pull requests in Azure repos</h2>
			<p><strong class="bold">Pull requests</strong> are <a id="_idIndexMarker723"/>robust mechanisms<a id="_idIndexMarker724"/> for notifying the team leader or the code reviewer that the development of a new feature or a bug fix has been completed, and that the code must be reviewed before it's merged into the main branch. Avoid merging code to the main branch without a pull request, which enforces a code review process. This is essential for improving the code's quality.</p>
			<p>It is noticeable that if the feedback that was received after the review process is good and up to standards, it may improve the code's quality. Therefore, it is recommended that you provide high-quality feedback. Here are some key suggestions for successful pull requests:</p>
			<ul>
				<li>Having the right people to review the pull request and provide feedback is a key factor for better reviews.</li>
				<li>It is recommended to have two reviewers as an optimal number for the review process.</li>
				<li>Giving actionable and constructive feedback is very essential.</li>
				<li>It is important to reply to comments promptly to accelerate the pull request process, especially if you have a large number of requests in the queue.</li>
				<li>Providing enough details in the branch description helps the reviewer understand the purpose of the changes.</li>
				<li>It is recommended to combine the code review sessions, if you have them in place, with the pull request process to avoid duplicating the effort.</li>
			</ul>
			<p>In this section, we learned about the structuring options that we can use in Git repositories and how to choose between them. We also explored some recommendations<a id="_idIndexMarker725"/> for a better branching <a id="_idIndexMarker726"/>strategy and discussed the benefits of the pull request process. We then highlighted some key factors for improving this process. In the next section, we are going to learn how to set a good dependency management strategy.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Managing packages with Azure Artifacts</h1>
			<p><strong class="bold">Azure Artifacts</strong> is <a id="_idIndexMarker727"/>an extension in Azure DevOps that provides a set of capabilities to create and manage packages with <strong class="bold">NuGet</strong>, <strong class="bold">npm</strong>, and <strong class="bold">Maven</strong>. This can help us manage the dependencies in our code base and <a id="_idIndexMarker728"/>group<a id="_idIndexMarker729"/> them<a id="_idIndexMarker730"/> into feeds. Each feed that's created in Azure Artifacts has its own URL that we can consume from <strong class="bold">Visual Studio</strong> to install the packages into our solution; the development team can also use the same feed URL to publish private packages.</p>
			<p>Azure Artifacts is free as long as the size of the packages and artifacts is less than <strong class="bold">2 GB</strong>. Everything above 2 GB will be billed according to the subscription plan. The following page on Azure Artifacts can be found in the left-hand side menu, next to the arrow depicted in the following screenshot:</p>
			<div><div><img src="img/Figure_10.09_B17366.jpg" alt="Figure 10.9: Packages feed within Azure Artifacts"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9: Packages feed within Azure Artifacts</p>
			<p>In the preceding<a id="_idIndexMarker731"/> screenshot, we have a feed called <strong class="bold">CMSArtifacts</strong>. In this feed, we can see a group of packages that were added to this container. The purpose here is to organize the public and private packages that we are using in our solutions into a feed that can be consumed by the development team.</p>
			<p>With Azure Artifacts, we can create views of the feed. For instance, we can create a view for the packages that are used in the development environment and another view for the production version of the product.</p>
			<p>The following screenshot shows three different views of the same feed; that is, <strong class="bold">Local</strong>, <strong class="bold">Prerelease</strong>, and <strong class="bold">Release</strong>. Each view holds a particular version of the packages, and it is being used for a particular work environment:</p>
			<div><div><img src="img/Figure_10.10_B17366.jpg" alt="Figure 10.10: Feed views"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10: Feed views</p>
			<p>As we can see, there are three views in the preceding screenshot. These views were created alongside the feed. We can still add new views or modify an existing one.</p>
			<p><strong class="bold">Upstream source</strong>, as shown in the preceding screenshot, allows us to group the packages that we create along with the packages that we consume from the remote feeds in one place. The following screenshot shows the interface we can use to create an upstream. Notice<a id="_idIndexMarker732"/> that we can specify the type of <strong class="bold">View</strong> that we want to use for the upstream:</p>
			<div><div><img src="img/Figure_10.11_B17366.jpg" alt="Figure 10.11: Adding an upstream source with a specific view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11: Adding an upstream source with a specific view</p>
			<p>Each upstream source is linked to one view, and that's how we can make use of the views in Visual Studio through upstream sources.</p>
			<p>In this section, we introduced Azure Artifacts, which supports the multiple feeds approach. We can make use of it to organize and group the packages that we are consuming in our projects. For more technical information on how to create and manage Azure Artifacts, please refer to the Microsoft documentation: <a href="https://docs.microsoft.com/en-us/azure/devops/artifacts/overview?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/artifacts/overview?view=azure-devops</a>.</p>
			<p>In the next section, we will explore continuous integration with <strong class="bold">Azure Pipelines</strong>.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor172"/>Exploring CI/CD with Azure pipelines</h1>
			<p><strong class="bold">Continuous integration</strong>, <strong class="bold">continuous delivery</strong>, and <strong class="bold">continuous deployment</strong> (or <strong class="bold">CI</strong>/<strong class="bold">CD</strong>) are <a id="_idIndexMarker733"/>the<a id="_idIndexMarker734"/> main pillars of building, testing, and deploying robust applications using modern software development techniques in DevOps. These practices allow us to release new features and fixes quickly through automated processes. Let's get to know each of these practices.</p>
			<p><strong class="bold">Continuous integration</strong> (<strong class="bold">CI</strong>) is the <a id="_idIndexMarker735"/>nucleus practice in DevOps. It allows us to frequently integrate all source code modifications coming from multiple developers into the main repository. It is an automated process that can be configured in Azure DevOps. When this capability is enabled, every time a developer commits their code, the CI will be verified by starting an automated build process to verify that the project contains no build errors. After that, an automated testing process is triggered to confirm that the newly committed code is stable. This approach is very helpful for identifying errors quickly and easily.</p>
			<p><strong class="bold">Continuous delivery</strong> is a<a id="_idIndexMarker736"/> practice that automates the delivery step that comes after the building and testing phase. Whenever we have a successful build and tests, an automated process is triggered to deploy the artifacts to the desired environment. This can be staging or production. Note that in this practice, shipping the code from staging to production is completed through manual intervention.</p>
			<p><strong class="bold">Continuous deployment</strong> has<a id="_idIndexMarker737"/> a lot in common with continuous delivery. The main difference is that this practice automates the entire life cycle of the release process, and the artifacts are automatically deployed to production.</p>
			<p>The following diagram shows the steps of each practice:</p>
			<div><div><img src="img/Figure_10.12_B17366.jpg" alt="Figure 10.12: CI/CD steps"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12: CI/CD steps</p>
			<p>In the preceding diagram, neither the <strong class="bold">Continuous Delivery</strong> nor <strong class="bold">Continuous Deployment</strong> processes can start unless the <strong class="bold">Continuous Integration</strong> process is completed. The steps between <strong class="bold">Continuous Delivery</strong> and <strong class="bold">Continuous Deployment</strong> are almost the same; however, in <strong class="bold">Continuous Delivery</strong>, the deployment to production is done through a manual job, while in <strong class="bold">Continuous Deployment</strong>, it is an automatic process.</p>
			<p>To implement<a id="_idIndexMarker738"/> a<a id="_idIndexMarker739"/> build strategy, we need to make use of the pipelines in Azure DevOps. A pipeline is an automated service that's used to verify a build and make it ready for deployment. The usage of the pipeline will reduce the manual work needed from the developer to merge the code, build it, and test the changes, along with the affected features. It is important to mention that the pipelines are used in continuous delivery and continuous deployment to automate their steps.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor173"/>Summary</h1>
			<p>In this chapter, we explored the fundamental procedures of Agile planning in Azure DevOps. We also learned about Azure Boards, along with related components, such as Work Items, Backlogs, and Sprints. Then, we discussed source control and explained the difference between TFVC and Git.</p>
			<p>After that, we explored Git and how it can version source code, before learning about branching and pull requests. Later, we learned about the packages that are available in Azure Artifacts, along with CI/CD, which help automate the steps related to building, testing, and deploying our code.</p>
			<p>Now that you have finished reading this book, your mind is probably filled with a lot of different ideas since you've dived deep into the everyday aspects of solution architecture. I suggest that you start by measuring where you are on your journey toward becoming an effective solution architecture. A good solution architect helps build high-quality products that fit the existing environment, along with the clients' requirements. To achieve this, a solution architect must learn about each part of the business model and how these parts work together.</p>
			<p>We covered many topics in this book. However, it is a good practice that we develop a learning mindset by frequently researching and getting to know new techniques and patterns in solution architectures, and also focus on the cloud services offered by Azure for building modern solutions. At the same time, it is essential to always improve our soft skills, especially if we want to become effective leaders. I hope that you have enjoyed reading this book as much as I enjoyed writing it and sharing my thoughts and experiences. I wish you every success in all your .NET projects!</p>
		</div>
	</body></html>