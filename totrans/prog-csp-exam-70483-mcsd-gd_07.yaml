- en: Implementing Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling helps developers structure their programs in a way that helps
    them handle both expected and unexpected scenarios. Often, application logic may
    throw some form of unhandled exception, for example, a code block trying to write
    to a file on a system that ends up with a file with a use exception. Such scenarios
    can be handled if proper exception handling is in place.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling uses the `try`, `catch`, and `finally` keywords to allow
    us to write code that may not succeed and can be handled when required, as well
    as to help us clean up resources once the `try` block has been executed. These
    exceptions can be thrown by CLR, .NET Framework, or by external libraries that
    are used in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will try to understand how we can use, create, and throw
    exceptions by looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and handling exceptions in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler-generated exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to structure an application program
    and handle all sorts of exceptions that may be thrown from your application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or newer. However, any new C# features from C# 7.0 and
    above require that you have Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of the aforementioned products, you can
    download the community version of Visual studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The same code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and handling exceptions in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are types that are derived from the `System.Exception` class. We
    use the `try` block around statements that may throw an exception. When an exception
    occurs, control jumps to the `catch` statement, where CLR collects all the required
    stack trace information before terminating the program and displaying a message
    to the user. If exception handling is not done, the program just terminates with
    an error. While handling exceptions, it is important to understand that if we
    cannot handle an exception, we should not catch it. This ensures that the application
    will be in a known state. When you define a `catch` block, you define an exception
    variable that can be used to obtain more information, such as the origin of the
    exception, which line in the code threw this exception, the type of exception,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A programmer can create and throw exceptions from the application logic using
    the throw keyword. Each `try` block may or may not define the `finally` block,
    which will be executed whether an exception is thrown or not. This block helps
    us release resources that have been used in the code block. Alternatively, if
    you want a piece of code to execute in all scenarios, it can be placed in the
    `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will look at how we can use exceptions, the syntax
    of the `try`-`catch`-`finally` block, using the `finally` block, when we can dispose
    of unused objects, different types of system exceptions, and creating our own
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, errors in C# programs are propagated at runtime
    using exceptions. When application code encounters an error, it throws an exception,
    which is then caught by another block of code that collects all the information
    about the exception and pushes it to the calling method, where the `catch` block
    was provided. A dialog box will be displayed by the system if you're using a generic
    exception handler for any uncaught exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are trying to parse an empty string into an `int`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the runtime throws a format exception with a message stating
    Input string was not in a correct format. As this exception wasn''t caught, we
    can see the generic handler displaying this error message in a dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba893895-c52d-4363-91ad-b06cd309b8ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the exception''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `catch` block defines an exception variable that gives us more information
    about the exception that is being thrown. The `exception` class defines multiple
    properties, all of which hold the following extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Data` | Gets custom-defined details about the exception in a key/value pair
    collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `HelpLink` | Gets or sets a help link related to an exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `HResult` | Gets or sets `HRESULT`, a number value that is associated with
    the exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `InnerException` | Gets the instance of the exception that triggered the
    exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `Message` | Gets detailed information from the exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `Source` | Gets or sets the application/instance name or the object/variable
    that caused the error. |'
  prefs: []
  type: TYPE_TB
- en: '| `StackTrace` | Gets a call stack in a string format. |'
  prefs: []
  type: TYPE_TB
- en: '| `TargetSite` | Gets the method that triggered the exception. |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we will try to handle the format exception and see what each property
    will provide us with. In the following example, we have a `try` block where the
    string is being parsed into an integer and a `catch` block that is being used
    to catch the format exception. In the `catch` block, we are displaying all the
    properties of the exception that we''ve caught:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are trying to parse a string into an integer variable. However, this is
    not allowed, and so the system throws an exception. When we catch the exception,
    we are displaying each property of the exception to observe what it stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa6c6e08-4d29-47cc-8eb8-eea6dc13b351.png)'
  prefs: []
  type: TYPE_IMG
- en: Each exception is inherited from the `System.Exception` base case, which defines
    the type of exception and details all the properties that provide more information
    about the exception. When you need to throw an exception, you need to create an
    instance of the exception class, set all or some of these properties, and throw
    them using the `throw` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have more than one `catch` block for a `try` block. During execution,
    when an exception is thrown, a specific `catch` statement that handles the exception
    executes first and any other generic `catch` statements are ignored. Therefore,
    it is important to organize your `catch` blocks by placing them in order, that
    is, from the most specific to the least specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program executes, although there are multiple `catch` blocks present,
    the system identifies an appropriate `catch` block and consumes the exception.
    Due to this, you will see a `Format Exception caught` message in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `finally` block is checked before invoking a `catch` block. When using
    resources in a `try`-`catch` block, there is a chance that these resources will
    move to an ambiguous state and aren''t collected until the framework''s garbage
    collector is invoked. Such resources can be cleaned up by the programmer via the
    use of `finally` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `finally` block was executed, but not before an exception
    was raised and caught using the respective `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although we had three different `catch` blocks, the format exception was executed
    and the `finally` block was executed after.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers partition application logic that may throw exceptions into a `try`
    block, followed by a `catch` block to handle these exceptions. An optional `finally`
    block, if present, is executed, regardless of whether an exception is thrown by
    a `try` block. You cannot just have a `try` blockâ€”it has to be accompanied by
    either a `catch` block or a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at different code blocks in order to understand
    the usage of the `try`-`catch` statement, the `try`-`finally` statement, and the
    `try`-`catch`-`finally` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a `try`-`catch` statement without a `finally` block like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The system also allows you to use a `try` block with a `finally` blockâ€”there''s
    no need for the `catch` exception. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, there''s the `try`-`catch`-`finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A compile-time error is thrown if the runtime identifies incorrect syntax in
    a `try` block; for example, a `try` block without a `catch` or `finally` block
    during the compilation of the code. When you don''t provide a `catch` or `finally`
    block, the compiler puts a red mark next to the closing bracket of `try` and an
    error is thrown, as shown in the error list window in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bedb9a2-e322-45ac-aa37-b0072f16f25a.png)'
  prefs: []
  type: TYPE_IMG
- en: Exception filters are a type of exception that's used to catch in a `catch`
    block. `System.Exception` is the base class for any exception type class. As this
    is the base class, it can hold any exception in the code. We use this when we
    have code that handles every exception or when we are throwing an exception while
    calling `method()`.
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed that a `try` block can have multiple `catch` blocks
    with different exception filters. When the runtime evaluates the `catch` block,
    it takes a top-to-bottom approach and executes the most specific `catch` block
    that suits the exception that's been caught. If the `exception` filter in the
    `catch` block matches the exception that's been thrown or matches the base class
    of the exception that's been thrown, it's executed. As an exam tip, always remember
    to place the most specific `catch` statements on top and place the generic ones
    at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of exception handling helps you write proper code
    that handles every possible scenario and executes it without unexpected behavior
    occurring. For example, let's say your program is trying to open and write into
    a file and you receive an exception such as `File not found` or `File-in-Use`.
    Exception handling allows us to handle these scenarios. In the first case, the
    prompt asks the user to provide a correct filename, while in the second case,
    the prompt checks whether it is OK to create a new file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a `for` loop is throwing an index is out of range
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code handles it and displays a message on the screen before throwing it
    so that the invoking method can handle it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3af8902a-b937-4084-8b0f-7993dbf386a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, our main program doesn''t handle the exception system. Instead, it
    uses the default and displays a dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/691694c8-8895-4d6f-b177-50a9b4f6b3ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `finally` block releases any variables or objects that were created in
    the `try` block. This block executes last and always runs if present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a file object in a `try` block and tried
    to write some bytes to it. When the runtime completes the execution of the `try`
    block, it executes a `finally` block and releases the `file` object that was created
    in the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler-generated exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over a few runtime-generated exceptions that .NET Framework supports.
    The framework uses these exceptions on valid statements that are being executed.
    Then, based on their type, an exception from the following table is thrown. For
    example, if the compiler tries to execute a division operation and if the denominator
    is zero, `DividebyZeroException` is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Exception** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ArithmeticException` | An exception that''s triggered while performing arithmetic
    operations can be caught. |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayTypeMismatchException` | When the value and type of the array don''t
    match, this exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `DivideByZeroException` | When an attempt to divide an integer value by zero
    is made, this exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexOutOfRangeException` | When an array is accessed with an index outside
    of its boundaries, this exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `InvalidCastException` | Converting a base type into an interface or derived
    type will cause this exception at runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| `NullReferenceException` | When you try to access an object that is `null`,
    this exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `OutOfMemoryException` | When the available memory for CLR is utilized, the
    new operator throws such exceptions. |'
  prefs: []
  type: TYPE_TB
- en: '| `OverflowException` | While performing a division operation, for example,
    if the output is long and you try to push it to `int`, this exception is thrown.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `StackOverflowException` | Recursive calls usually cause such exceptions
    and indicate a very deep or infinite recursion. |'
  prefs: []
  type: TYPE_TB
- en: '| `TypeInitializationException` | If you try to instantiate an abstract class,
    for example, this exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: Now that we've looked at compiler-generated exceptions, let's take a look at
    custom exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All exceptions are derived from the `System.Exception` class in .NET Framework.
    So, in a scenario where these predefined exceptions don't suit our requirements,
    the framework allows us to create our own exceptions by deriving our exception
    class from the `Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a custom exception and inheriting
    from the `Exception` class. We can use different constructors for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you create your own exception class, derive from the `System.Exception`
    class, and implement the base class, you get four constructors; implementing the
    three mentioned is the best practice. In the first instance, the base class message
    property is initialized by default and a message is displayed. However, in the
    second and third scenarios, the method that's throwing this custom exception needs
    to pass these values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can use the exception class in a program,
    how we can create custom exceptions to meet our requirements, and different types
    of exceptions. We also learned about industry standards regarding how to plan
    and implement exceptions in an application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand types and how to create and consume
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# supports `try` blocks without`catch` and `finally` blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`catch` blocks need to be used in a most-generic-to-least-generic pattern.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If present, a `finally` block always executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**False**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**False**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**True**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While implementing exception handling in your application code, it is important
    to understand industry standards. Please take a look at the following link to
    understand these best practices: [https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions).'
  prefs: []
  type: TYPE_NORMAL
