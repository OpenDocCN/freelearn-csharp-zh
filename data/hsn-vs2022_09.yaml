- en: 'Chapter 7: Coding Efficiently with AI and Code Views'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使用AI和代码视图高效编码
- en: Artificial intelligence is a vast and interesting field that allows us to improve
    our lifestyle in one way or another. We see, hear, and use it every day, and if
    you don't believe it, ask yourself how many times you use the Google search engine
    throughout the day. Other places where you can find it are in photo-editing programs,
    where it is possible to remove, for example, the background of an image in an
    almost perfect way. Social networks are another perfect example of the use of
    artificial intelligence, as they are constantly processing the best recommendations
    for you to stay on them as long as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能是一个庞大且有趣的领域，它以某种方式改善了我们的生活方式。我们每天都在看到、听到并使用它，如果你不相信，问问自己你一天中使用了多少次 Google
    搜索引擎。你还可以在照片编辑程序中找到它，例如，几乎完美地移除图像的背景。社交网络是人工智能应用的另一个完美例子，因为它们不断为你提供最佳推荐，让你尽可能长时间地留在上面。
- en: Fortunately, artificial intelligence has even reached new software development
    tools, through predictive code integration, which allows us to choose the pieces
    of code we need at the right time. In Visual Studio, we have a powerful feature
    called **Visual Studio IntelliCode** that does this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，人工智能甚至已经扩展到了新的软件开发工具，通过预测代码集成，它允许我们在正确的时间选择所需的代码片段。在 Visual Studio 中，我们有一个名为
    **Visual Studio IntelliCode** 的强大功能，可以做到这一点。
- en: Similarly, we have different visual tools and windows that can help us find
    relationships in our code and navigate through them efficiently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还有不同的视觉工具和窗口，可以帮助我们找到代码中的关系并高效地导航。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding CodeLens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CodeLens
- en: Working with code views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码视图
- en: Using Visual Studio IntelliCode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio IntelliCode
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To use IntelliCode, Visual Studio 2022 with the web development workload must
    be installed. Because this chapter focuses more on showing auto-completion and
    class display features, no changes have been made to the code repositories. You
    can use the repository hosted at the following URL: [https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 IntelliCode，必须安装带有 Web 开发工作负载的 Visual Studio 2022。因为本章更侧重于展示自动完成和类显示功能，所以代码仓库没有进行任何更改。您可以使用以下
    URL 中的仓库：[https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07)。
- en: Also, to be able to perform the procedure of the *Code maps* section, it is
    required to use the Enterprise version of Visual Studio.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要执行*代码地图*部分中的程序，需要使用 Visual Studio 的企业版。
- en: 'Likewise, the **Code Map** and **Live Dependency Validation** tools must be
    installed by the Visual Studio Installer, selecting them as shown in *Figure 7.1*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**代码地图**和**实时依赖验证**工具必须通过 Visual Studio 安装程序安装，选择方式如*图7.1*所示：
- en: '![Figure 7.1 – Installation of the Code Map and Live Dependency Validation
    features'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 安装代码地图和实时依赖验证功能'
- en: '](img/Figure_7.1_B17873.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.1_B17873.jpg)'
- en: Figure 7.1 – Installation of the Code Map and Live Dependency Validation features
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 安装代码地图和实时依赖验证功能
- en: Now that we know the technical requirements, let's learn how to work with them
    to get the most out of Visual Studio.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了技术要求，让我们学习如何使用它们，以充分利用 Visual Studio。
- en: Understanding CodeLens
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CodeLens
- en: CodeLens is a powerful set of tools that is useful for finding references in
    code, relationships between your different components, seeing the history of changes
    in the code, linked bugs, code reviews, unit tests, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CodeLens 是一套强大的工具，用于在代码中查找引用、查看不同组件之间的关系、查看代码变更历史、关联的缺陷、代码审查、单元测试等。
- en: In this section, we will analyze the most important tools of this feature. Let's
    start by seeing how we can find references in our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析此功能最重要的工具。让我们先看看我们如何在我们的代码中找到引用。
- en: Finding references in code
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中查找引用
- en: 'CodeLens is presented in our code files from the first time we use Visual Studio.
    We can check this by going to any class, method, or property and verifying that
    a sentence appears, indicating the number of references in the project about it.
    In *Figure 7.2*, we can see that we have opened the `WeatherForecastController.cs`
    file, which shows us that three references have been found for the `WeatherForecastController`
    class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CodeLens从我们第一次使用Visual Studio时就在我们的代码文件中呈现。我们可以通过访问任何类、方法或属性并验证是否出现一个句子来检查这一点，该句子指示项目中关于它的引用数量。在图7.2中，我们可以看到我们打开了`WeatherForecastController.cs`文件，这显示我们找到了关于`WeatherForecastController`类的三个引用：
- en: '![Figure 7.2 – References for the WeatherForecastController class'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – WeatherForecastController类的引用'
- en: '](img/Figure_7.02_B17873.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17873.jpg)'
- en: Figure 7.2 – References for the WeatherForecastController class
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – WeatherForecastController类的引用
- en: 'This means that the `WeatherForecastController` class is being used in three
    places in our project. If we proceed by clicking on the legend titled `WeatherForecastController`
    class – specifically in the **14** and **16** lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`WeatherForecastController`类在我们的项目中使用了三个地方。如果我们通过点击标题为`WeatherForecastController`类的图例
    – 特别是第**14**行和**16**行：
- en: '![Figure 7.3 – The location in the code of the references in the WeatherForecastController
    class'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – WeatherForecastController类中引用的代码位置'
- en: '](img/Figure_7.03_B17873.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B17873.jpg)'
- en: Figure 7.3 – The location in the code of the references in the WeatherForecastController
    class
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – WeatherForecastController类中引用的代码位置
- en: 'Not only that, but we can also position over on any of the lines found, which
    will show us a section of the four closest lines of code surrounding the reference.
    This way, we can get a better idea of the purpose of using it, as shown in *Figure
    7.4*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，我们还可以定位到任何找到的行上，这将显示围绕引用的四个最近代码行的部分。这样，我们可以更好地了解使用它的目的，如图7.4所示：
- en: '![Figure 7.4 – A preview of a found code reference'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 找到的代码引用的预览'
- en: '](img/Figure_7.4_B17873.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B17873.jpg)'
- en: Figure 7.4 – A preview of a found code reference
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 找到的代码引用的预览
- en: This is quite useful if we are in a new project and need to quickly know what
    certain parts of the code do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是在一个新项目中，需要快速了解代码的某些部分的功能，这非常有用。
- en: Now, let's see a utility belonging to CodeLens that will allow you to see relationships
    between code visually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看CodeLens的一个实用工具，它将允许你以可视化的方式看到代码之间的关系。
- en: Important Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Sometimes, even if the number of references equals zero, there may be references
    to other GUI files, such as `.xaml` and `.aspx` files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使引用的数量为零，也可能有对其他GUI文件的引用，例如`.xaml`和`.aspx`文件。
- en: Code maps
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码图
- en: Code maps are a way to visualize relationships in code in a fast and efficient
    way. This tool allows the creation, as its name indicates, of visual maps from
    the code. With this tool, we will be able to see the structure of the entities,
    their different properties, and relationships, which lets us know how much impact
    a change we make can have.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码图是一种快速高效地可视化代码中关系的方法。这个工具允许创建，正如其名称所示，从代码中生成的可视化地图。使用这个工具，我们将能够看到实体的结构、它们的不同属性和关系，这让我们知道我们做出的更改可能产生多大的影响。
- en: 'There are several ways to create code maps. The first one is by selecting the
    option `.dgml` extension, in which we will be instructed to drag files from the
    solution explorer, class view, or object browser, as shown in *Figure 7.5*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代码图有几种方法。第一种是通过选择`.dgml`扩展名，我们将被指示从解决方案资源管理器、类视图或对象浏览器中拖动文件，如图7.5所示：
- en: '![Figure 7.5 – The empty code map file'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 空的代码图文件'
- en: '](img/Figure_7.05_B17873.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B17873.jpg)'
- en: Figure 7.5 – The empty code map file
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 空的代码图文件
- en: 'Let''s do a test – click on the `SPAProject.Controllers` namespace. This will
    show you the `WeatherForecastController` class, as shown in *Figure 7.6*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个测试 – 点击`SPAProject.Controllers`命名空间。这将显示`WeatherForecastController`类，如图7.6所示：
- en: '![Figure 7.6 – A visualization of the WeatherForecastController class, about
    to be dragged into the code map file](img/Figure_7.06_B17873.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 将要拖入代码图文件的WeatherForecastController类的可视化](img/Figure_7.06_B17873.jpg)'
- en: Figure 7.6 – A visualization of the WeatherForecastController class, about to
    be dragged into the code map file
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 将要拖入代码图文件的WeatherForecastController类的可视化
- en: 'Next, drag the `WeatherForecastController` class into the code map file. This
    will automatically generate a graph where we can see the dragged `class`, `namespace`
    that contains it, and finally, `.dll` in which it is hosted, as shown in *Figure
    7.7*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`WeatherForecastController`类拖动到代码映射文件中。这将自动生成一个图表，我们可以看到拖动的`class`、包含它的`namespace`，以及它所在的`.dll`文件，如图*图7.7*所示：
- en: '![Figure 7.7 – The WeatherForecastController class in the code map'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.7 – 代码映射中的WeatherForecastController类'
- en: '](img/Figure_7.07_B17873.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.07_B17873.jpg](img/Figure_7.07_B17873.jpg)'
- en: Figure 7.7 – The WeatherForecastController class in the code map
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.7 – 代码映射中的WeatherForecastController类
- en: 'Additionally, if we expand the `WeatherForecastController` class in the diagram,
    we will see the members that are part of the class, such as its attributes and
    behavior, as well as the relationships that can be found as part of the same class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们展开图中的`WeatherForecastController`类，我们将看到类中包含的成员，例如其属性和行为，以及作为同一类一部分可以找到的关系：
- en: '![Figure 7.8 – The relationships found through the code map'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.8 – 通过代码映射找到的关系'
- en: '](img/Figure_7.08_B17873.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.08_B17873.jpg](img/Figure_7.08_B17873.jpg)'
- en: Figure 7.8 – The relationships found through the code map
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.8 – 通过代码映射找到的关系
- en: In *Figure 7.8*, we can see in action a code map of the `WeatherForecastController`
    class with all its members expanded. This shows us quickly how the fields, properties,
    and methods are related.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.8*中，我们可以看到`WeatherForecastController`类的代码映射，其中所有成员都已展开。这迅速展示了字段、属性和方法之间的关系。
- en: 'Another way to create a map code from the source code is to go to the file
    where the member we are interested in is located, such as the `WeatherForecast.cs`
    file. Once we have opened the file, we can position the cursor on a class, method,
    property, or field and right-click, which will show us the **Code Map** | **Show
    on Code Map** option, as shown in *Figure 7.9*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码创建代码映射的另一种方法是转到我们感兴趣的成员所在的文件，例如`WeatherForecast.cs`文件。一旦我们打开了文件，我们可以将光标定位在类、方法、属性或字段上，然后右键单击，这将显示**代码映射**
    | **在代码映射上显示**选项，如图*图7.9*所示：
- en: '![Figure 7.9 – The option to add a class to a code map from the context menu
    of a class'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.9 – 从类的上下文菜单中将类添加到代码映射的选项'
- en: '](img/Figure_7.09_B17873.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.09_B17873.jpg](img/Figure_7.09_B17873.jpg)'
- en: Figure 7.9 – The option to add a class to a code map from the context menu of
    a class
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.9 – 从类的上下文菜单中将类添加到代码映射的选项
- en: This option will create a new `.dgml` file or, if you have already created one,
    as in our case, add the reference with its respective relations in the previously
    opened file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将创建一个新的`.dgml`文件，或者如果您已经创建了一个，就像我们的情况一样，在之前打开的文件中添加带有其相应关系的引用。
- en: Important Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to center the code map diagram, at any time you can click on any
    empty area of the diagram to center it. Likewise, if you double-click on any of
    the entities or members of the diagram, the corresponding code will open to view
    it next to the diagram.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将代码映射图居中，您可以在任何时候点击图表的任何空白区域来居中它。同样，如果您双击图表中的任何实体或成员，相应的代码将打开以在图表旁边查看。
- en: 'As a result of adding the new class to the diagram, we can see that the `WeatherForecast`
    class is being used in the `Get` method of the `WeatherForecastController` class,
    as shown in *Figure 7.10*. This way, we have discovered this relationship very
    easily:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向图中添加了新的类，我们可以看到`WeatherForecast`类正在`WeatherForecastController`类的`Get`方法中使用，如图*图7.10*所示。这样，我们很容易就发现了这种关系：
- en: '![Figure 7.10 – The relationships between classes by code map'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.10 – 通过代码映射显示的类之间的关系'
- en: '](img/Figure_7.10_B17873.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.10_B17873.jpg](img/Figure_7.10_B17873.jpg)'
- en: Figure 7.10 – The relationships between classes by code map
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.10 – 通过代码映射显示的类之间的关系
- en: Important Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The arrows indicating relationships between entities in the code map diagram
    appear and disappear as entities are selected, allowing more space and understanding
    of the diagram. I encourage you to select each of the elements in the diagram
    so that you can see the complete relationship.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码映射图中的箭头指示实体之间的关系，随着实体的选择而出现和消失，这为图表提供了更多空间和理解。我鼓励您选择图表中的每个元素，以便您可以看到完整的关系。
- en: 'Finally, if we want to be able to see the relationships in our solution without
    having to add entity by entity, from the **Architecture** menu, we can select
    the **Generate Code Map for Solution** option, as we can see in *Figure 7.11*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想能够在不逐个添加实体的前提下看到我们的解决方案中的关系，从**架构**菜单中，我们可以选择**为解决方案生成代码映射**选项，如图*图7.11*所示：
- en: '![Figure 7.11 – The option in the menu to generate a code map at a solution
    level'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.11 – 在解决方案级别生成代码图的菜单选项'
- en: '](img/Figure_7.11_B17873.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.11_B17873.jpg]'
- en: Figure 7.11 – The option in the menu to generate a code map at a solution level
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 在解决方案级别生成代码图的菜单选项
- en: This will start the process of generating the respective code map for the entire
    solution. Depending on the number of references in your code, the process may
    take more or less time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动生成整个解决方案相应代码图的进程。根据您代码中的引用数量，这个过程可能需要更多或更少的时间。
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although code maps can only be created in Visual Studio Enterprise Edition,
    it is possible to view them from any version of Visual Studio, including the Community
    version, but it is not possible to edit them from any version except the Enterprise
    Edition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码图只能在Visual Studio Enterprise Edition中创建，但您可以从任何版本的Visual Studio中查看它们，包括社区版，但除了企业版之外，您无法从任何版本编辑它们。
- en: Now that we have seen how CodeLens can help us understand our code better and
    faster, let's look at the windows available in Visual Studio, which will allow
    us to work with our code easily.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到CodeLens如何帮助我们更好地、更快地理解代码，让我们看看Visual Studio中可用的窗口，它们将使我们能够轻松地处理代码。
- en: Working with code views
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码视图
- en: In addition to CodeLens, there are several windows that can help us to examine
    the classes of a project and its members in a quicker way. In this section, you
    are going to learn about them and how they can help you in breaking down code
    of a project in Visual Studio.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CodeLens之外，还有几个窗口可以帮助我们更快地检查项目及其成员的类。在本节中，您将了解它们以及它们如何帮助您在Visual Studio中分解项目的代码。
- en: Class view
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类视图
- en: The class view is a window that allows you to see the elements of a Visual Studio
    project, such as namespaces, types, interfaces, enumerations, and classes, allowing
    you to access each of these elements quickly. Perhaps if you have worked with
    small projects in Visual Studio, you might not see it as being of much use. But
    if, like me, you work with solutions that can have up to 20 projects or more,
    then it is an excellent option to examine code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类视图是一个窗口，允许您查看Visual Studio项目的元素，如命名空间、类型、接口、枚举和类，使您能够快速访问这些元素中的每一个。也许如果您在Visual
    Studio中处理过小型项目，您可能不会认为它很有用。但像我一样，如果您处理的是可以包含多达20个或更多项目的解决方案，那么它是一个检查代码的绝佳选项。
- en: 'To access this window, you must select the **View** | **Class View** option
    from the menu, which will display the **Class View** window, showing all the elements
    of the solution that is currently open, as shown in *Figure 7.12*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此窗口，您必须从菜单中选择**视图** | **类视图**选项，这将显示**类视图**窗口，显示当前打开的解决方案的所有元素，如图*7.12*所示：
- en: '![Figure 7.12 – The Class View window with a loaded project'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.12 – 加载项目的类视图窗口'
- en: '](img/Figure_7.12_B17873.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.12_B17873.jpg]'
- en: Figure 7.12 – The Class View window with a loaded project
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 加载项目的类视图窗口
- en: 'As you can see, we can get a very quick idea of the structure of our project
    by seeing at a glance the namespaces into which the project has been divided.
    If we expand the nodes of each of the namespaces, we can also see the different
    classes that are part of these namespaces, as shown in *Figure 7.13*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过一眼查看项目被划分到的命名空间，我们可以迅速了解我们项目的结构。如果我们展开每个命名空间下的节点，我们还可以看到这些命名空间中包含的不同类，如图*7.13*所示：
- en: '![Figure 7.13 – The Class View window displaying the members of the WeatherForecastController
    class'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.13 – 显示WeatherForecastController类成员的类视图窗口'
- en: '](img/Figure_7.13_B17873.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.13_B17873.jpg]'
- en: Figure 7.13 – The Class View window displaying the members of the WeatherForecastController
    class
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 显示WeatherForecastController类成员的类视图窗口
- en: In addition, if we select any element of our project, such as a class, we will
    be able to see the properties and methods that compose it in the lower part of
    the window (as shown in *Figure 7.13*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们选择项目中的任何元素，例如一个类，我们将在窗口的下半部分看到组成它的属性和方法（如图*7.13*所示）。
- en: Another great advantage of this window is that you don't even have to recompile
    the project to see the changes, as they will be made automatically and instantly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口的另一个巨大优势是，您甚至不需要重新编译项目来查看更改，因为它们将自动且即时地完成。
- en: At the top of the window in *Figure 7.13*, we can also see a series of buttons
    that we can use to create new folders, navigate between the selected elements,
    configure the display options, and possibly add a class to a code map file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.13 的窗口顶部，我们还可以看到一系列按钮，我们可以使用这些按钮来创建新文件夹，在选定的元素之间导航，配置显示选项，并可能将一个类添加到代码映射文件中。
- en: It is certainly an excellent window to navigate between the classes of our project,
    but what if we want to navigate between classes that are not part of our project?
    In this case, the object browser can help us, which we will examine next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个在项目类之间导航的极好窗口，但如果我们想导航到不属于我们项目的类呢？在这种情况下，对象浏览器可以帮助我们，我们将在下一部分进行探讨。
- en: The object browser
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象浏览器
- en: The object browser is a very useful window that has been present since the beginning
    of Visual Studio. This window contains information about all the assemblies that
    are used in your project and allows you to examine them in depth. To access this
    window, we can do it from the **View** | **Object Browser** menu.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对象浏览器是一个自 Visual Studio 之初就存在的非常有用的窗口。此窗口包含有关项目中使用的所有程序集的信息，并允许您深入了解它们。要访问此窗口，我们可以从
    **视图** | **对象浏览器** 菜单中进行操作。
- en: 'Once we select the **Object Browser** option, it will open and load the assemblies
    that are used as part of our solution. We can see that the list of assemblies
    is quite long, and this is because we can examine assemblies that are part of
    the framework we are using and also the assemblies that we have created ourselves,
    as shown in *Figure 7.14*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择 **对象浏览器** 选项，它将打开并加载作为我们解决方案一部分使用的程序集。我们可以看到程序集列表相当长，这是因为我们可以检查我们使用的框架中的程序集以及我们自己创建的程序集，如图
    7.14 所示：
- en: '![Figure 7.14 – The Object Browser window'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – 对象浏览器窗口'
- en: '](img/Figure_7.14_B17873.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B17873.jpg)'
- en: Figure 7.14 – The Object Browser window
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 对象浏览器窗口
- en: 'As shown in *Figure 7.15*, at the top there is a filter, which we can deploy
    to choose which framework or set of libraries we want to examine:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 7.15 所示，在顶部有一个过滤器，我们可以展开以选择我们想要检查的框架或库集：
- en: '![Figure 7.15 – Displaying the object browser options to navigate between the
    different classes'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – 显示对象浏览器选项以在各个类之间导航'
- en: '](img/Figure_7.15_B17873.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B17873.jpg)'
- en: Figure 7.15 – Displaying the object browser options to navigate between the
    different classes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 显示对象浏览器选项以在各个类之间导航
- en: This list (in the preceding screenshot) will vary, according to the workloads
    picked in the Visual Studio installation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表（在先前的屏幕截图中）将根据在 Visual Studio 安装中选择的负载而变化。
- en: 'You will also have a powerful search engine available, in which you can enter
    a search term, and it will return all possible matches, including any type of
    data that has been found, as shown in *Figure 7.16*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将拥有一个强大的搜索引擎可供使用，您可以在其中输入搜索词，它将返回所有可能的匹配项，包括找到的任何类型的数据，如图 7.16 所示：
- en: '![Figure 7.16 – Performing a search in the object browser'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 – 在对象浏览器中执行搜索'
- en: '](img/Figure_7.16_B17873.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B17873.jpg)'
- en: Figure 7.16 – Performing a search in the object browser
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 在对象浏览器中执行搜索
- en: 'Finally, if you select any item from the list, you will see a second list on
    the right panel, as shown in *Figure 7.17*, which will contain all the members
    of the selected type, such as their methods, properties, structures, enumerations,
    among other available types, and at the bottom, a description of the selected
    member:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您从列表中选择任何项，您将在右侧面板中看到一个第二列表，如图 7.17 所示，它将包含所选类型的所有成员，例如它们的方法、属性、结构、枚举以及其他可用的类型，底部是所选成员的描述：
- en: '![Figure 7.17 – Showing the members of a class in the object browser'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.17 – 在对象浏览器中显示类的成员'
- en: '](img/Figure_7.17_B17873.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B17873.jpg)'
- en: Figure 7.17 – Showing the members of a class in the object browser
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 在对象浏览器中显示类的成员
- en: As you can see, this window is quite helpful, not only to see members of your
    own project but also of the whole framework in general.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此窗口非常有用，不仅可以看到您自己的项目成员，还可以查看整个框架的成员。
- en: Now, let's look at a new feature called IntelliCode, which will allow us to
    write code more efficiently.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个名为 IntelliCode 的新功能，它将使我们能够更高效地编写代码。
- en: Using Visual IntelliCode
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual IntelliCode
- en: IntelliCode is the tool integrated into Visual Studio 2022, which allows you
    to write code faster, thanks to artificial intelligence. It is a tool that has
    been trained with thousands of popular open source projects hosted on GitHub,
    and although it was already beginning to show a little of its potential in Visual
    Studio 2019, it is in this version where all the features have been implemented.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode是集成到Visual Studio 2022中的工具，它通过人工智能使您能够更快地编写代码。这是一个经过训练的工具，使用了GitHub上托管的上千个流行开源项目，尽管它已经在Visual
    Studio 2019中开始展示其潜力的一小部分，但所有功能都是在这一版本中实现的。
- en: 'IntelliCode can suggest patterns and styles while you write code, giving you
    accurate suggestions according to the context in which you find yourself, so you
    can complete lines of code. IntelliCode is also able to show you the methods and
    properties you are most likely to use and supports completion in multiple programming
    languages, such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写代码时，IntelliCode可以建议模式和样式，根据您所处的上下文提供准确的建议，因此您可以完成代码行。IntelliCode还能够显示您最可能使用的函数和属性，并支持多种编程语言的完成，如下所示：
- en: C#
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: C++
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: XAML
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML
- en: JavaScript
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: TypeScript
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript
- en: Visual Basic
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic
- en: Let's examine how this amazing tool works in the following subsections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下小节中检查这个神奇工具是如何工作的。
- en: Whole line completions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整行完成
- en: 'IntelliCode can be extremely useful in helping you complete entire lines of
    code. Best of all, code predictions are displayed according to different entries
    in your code, such as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode在帮助您完成整行代码方面可以非常有用。最好的是，代码预测将根据您的代码中的不同条目显示，如下所示：
- en: Variable names
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名称
- en: Function names
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称
- en: IntelliSense options used
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的IntelliSense选项
- en: Libraries used in the project
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目中使用的库
- en: 'There are two ways to receive entire line completion hints in Visual Studio
    2022:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，有两种方法可以接收整行完成提示：
- en: 'The first one is given automatically while you are writing code. In *Figure
    7.18*, we can see this in action, as we start writing a new property in the `WeatherForecast.cs`
    file of type `string`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是在您编写代码时自动提供的。在*图7.18*中，我们可以看到这一功能是如何工作的，因为我们开始在一个名为`WeatherForecast.cs`的文件中编写一个新的`string`类型的属性：
- en: '![Figure 7.18 – IntelliCode suggesting a full line completion'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.18 – IntelliCode suggesting a full line completion'
- en: '](img/Figure_7.18_B17873.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.18_B17873.jpg)'
- en: Figure 7.18 – IntelliCode suggesting a full line completion
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – IntelliCode suggesting a full line completion
- en: According to everything learned by the IntelliCode model, it suggests a new
    property called `Description`, which we can accept by pressing the *tab* key or
    reject by continuing to write code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IntelliCode模型学习到的所有内容，它建议一个新的属性名为`Description`，我们可以通过按*tab*键来接受它，或者通过继续编写代码来拒绝它。
- en: 'The second method of line completion through the use of IntelliCode is by selecting
    an item from the IntelliSense suggestion list. For example, if we create a constructor
    for the `WeatherForecast` class and type the letter `S`, a list of IntelliSense
    suggestions will appear. We can scroll through each of them, and in most cases,
    IntelliCode will show us auto-completion suggestions, as shown in *Figure 7.19*:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过IntelliCode使用第二种整行完成的方法是通过从IntelliSense建议列表中选择一个项目。例如，如果我们为`WeatherForecast`类创建一个构造函数并输入字母`S`，将出现一个IntelliSense建议列表。我们可以浏览每一个，在大多数情况下，IntelliCode将显示自动完成建议，如图*图7.19*所示：
- en: '![Figure 7.19 – IntelliCode recommending the completion of an IntelliSense
    element'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.19 – IntelliCode recommending the completion of an IntelliSense
    element'
- en: '](img/Figure_7.19_B17873.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B17873.jpg)'
- en: Figure 7.19 – IntelliCode recommending the completion of an IntelliSense element
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – IntelliCode推荐完成IntelliSense元素
- en: We can accept the line by pressing the *tab* key twice or continue writing code
    to ignore the suggestion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过按*tab*键两次来接受这一行，或者继续编写代码以忽略建议。
- en: Now that we have seen the two methods of full line completion, let's see how
    IntelliCode can help us write code based on its suggestions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两种整行完成的方法，让我们看看IntelliCode是如何根据其建议帮助我们编写代码的。
- en: IntelliCode suggestions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliCode建议
- en: IntelliCode suggestions are an assisted way to carry out similar code edits
    in our projects. Basically, IntelliCode keeps track of code we are writing, and
    if it detects code repetition that could be applied to our code, it will let us
    know through suggestions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode建议是一种辅助方式，在我们的项目中执行类似的代码编辑。基本上，IntelliCode会跟踪我们正在编写的代码，如果它检测到可以应用于我们代码的代码重复，它将通过建议让我们知道。
- en: A surprising thing about IntelliCode is that it is based on the semantic structure
    of code, so it can also help us to detect changes that we might have missed, such
    as changes in formulas.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode令人惊讶的一点是，它基于代码的语义结构，因此它还可以帮助我们检测我们可能错过的变化，例如公式的变化。
- en: 'For example, suppose we have some methods that allow us to calculate some static
    values, such as the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一些方法可以让我们计算一些静态值，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We see that the calculation follows the same structure, and the only thing
    that changes is the value of the `minValue` variable, so we decide to create a
    new method called `Calculate`, which will perform the same operation by receiving
    a parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到计算遵循相同的结构，唯一改变的是`minValue`变量的值，因此我们决定创建一个新的方法，名为`Calculate`，它将通过接收一个参数来执行相同的操作：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Subsequently, we decided to replace code of the `Calculate1` method to invoke
    the newly created `Calculate` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们决定将`Calculate1`方法的代码替换为调用新创建的`Calculate`方法：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we go to the `Calculate2` method and start typing the name of the `Calculate`
    method, an IntelliCode hint will appear, as shown in *Figure 7.20*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入`Calculate2`方法并开始输入`Calculate`方法的名称，IntelliCode提示将会出现，如图*图7.20*所示：
- en: '![Figure 7.20 – IntelliCode suggesting an implementation of the code repetition'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20 – IntelliCode建议代码重复的实现'
- en: '](img/Figure_7.20_B17873.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.20_B17873.jpg)'
- en: Figure 7.20 – IntelliCode suggesting an implementation of the code repetition
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 – IntelliCode建议代码重复的实现
- en: The suggestion made by IntelliCode tells us that we can apply the same invocation
    to the new method, which we can apply by pressing the *tab* key, or we can ignore
    the suggestion and continue writing code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode提出的建议告诉我们，我们可以将相同的调用应用于新方法，我们可以通过按*tab*键来实现，或者我们可以忽略建议并继续编写代码。
- en: Important Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is very important to note that IntelliCode suggestions are only available
    during the development session. This means that if you restart Visual Studio,
    the previous hints will not appear again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，IntelliCode建议仅在开发会话期间可用。这意味着如果你重新启动Visual Studio，之前的提示将不会再次出现。
- en: As we saw, IntelliCode provides a way to write code much faster through suggestions,
    which can save you several minutes a day.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，IntelliCode通过建议提供了一种更快地编写代码的方法，这可以每天为你节省几分钟。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Visual Studio contains a set of tools and windows that can help us a lot while
    we are developing our projects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio包含一系列工具和窗口，在开发项目时可以为我们提供很大帮助。
- en: We have seen how CodeLens can help us find references and relationships, both
    through code and visually. Likewise, we have studied the different code windows
    that help to examine class members in projects. Finally, we have seen how IntelliCode
    is a new addition to the IDE, which through artificial intelligence helps us to
    write code quickly through various suggestions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到CodeLens如何帮助我们通过代码和视觉方式找到引用和关系。同样，我们已经研究了不同的代码窗口，这些窗口有助于检查项目中的类成员。最后，我们已经看到IntelliCode是IDE的一个新功能，它通过人工智能帮助我们通过各种建议快速编写代码。
- en: In [*Chapter 8*](B17873_08_ePub.xhtml#_idTextAnchor100), *Web Tools and Hot
    Reload*, we will see several tools focused on web development for the development
    of web applications, and a new functionality included in Visual Studio 2022 that
    helps us to reload a web project after making a change.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17873_08_ePub.xhtml#_idTextAnchor100)，“Web工具和热重载”中，我们将看到几个专注于Web开发的工具，以及Visual
    Studio 2022中包含的新功能，该功能可以帮助我们在更改后重新加载Web项目。
