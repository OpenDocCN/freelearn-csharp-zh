- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convention over Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our programs need to be configured. Some of these configurations are things
    such as connection strings to a database or a URL for a REST API we are calling.
    These might change depending on the different environments our code is running
    in (e.g. development, testing, or production). On top of this, we often have to
    configure our code to be able to run as we expect. The type of configuration we
    do is often dictated by some third-party library or framework we’re using. In
    growing solutions, this type of configuration tends to also grow, and since configuration
    is often done at a specific point during the startup of the program, it’s not
    uncommon to end up with large files acting as dumping grounds for this type of
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into how we can leverage the power of the metadata
    we already have in running code to make code automatically configure itself and
    become more consistent as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control and its role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic ServiceCollection registrations by convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By end the of the chapter, you will have an idea of what conventions can do
    for you and how they can make you more productive and also allow you to create
    more consistent code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10))
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: You will need Docker Desktop installed ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)),
    Postman ([https://www.postman.com](https://www.postman.com)), and a MongoDB editor
    such as Compass ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass)).
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control and its role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software needs structure really fast when growing beyond one page of source
    code. Typically, you’d group things logically in types that have a specific purpose
    in your system. With your software being broken up for better maintainability,
    the different parts are then often dependent on each other to be able to perform
    the overall tasks you need it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Building a module for registering users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s build a simple system that handles a user sign-up feature exposed as
    a REST API. Start by creating a folder called **Chapter10**. Change into this
    folder in your command line and create a new web-based project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of information you’d want to capture involves both personal information
    and also the user’s credentials that we want to have as part of the body of our
    API. Add a file called **RegisterUser.cs** and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The **RegisterUser** type takes all the different properties you want to capture
    for the user for the API. This is not what you want to store directly in a database.
    When you store this, you want to store this as two separate things – the user
    credentials and the user details. Create a file called **User.cs** and add the
    following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **User** type only captures the actual user name and the password and has
    a unique identifier for the user. Then add a file called **UserDetails** and add
    the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**UserDetails** holds the rest of the information we will be getting from the
    **RegisterUser** type.'
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need is an API controller to take this and store the information
    in the database. We will be using MongoDB as a backing store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be relying on a third-party library to access MongoDB. Add the package
    to the project by running the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called **UsersController** and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up in its constructor the database and gets the two different
    collections in which we will be storing the user information coming in. The register
    API method then takes **RegisterUser** and splits it up into the two respective
    types and inserts them into each of their MongoDB collections.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In a real system, you would obviously encrypt the password with a strong (preferably
    one-way) encryption strategy and not just store the password as clear text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your **Program.cs** file and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run the solution so far, you need to start the MongoDB server. You
    do this by using Docker. In your terminal, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should start MongoDB as a background daemon and expose port **27017**
    so that you can connect to it. You should see something similar to the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is the unique identifier of the running Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the code you’ve created so far from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the code thus far, you now have an API that has a route of **/api/users/register**
    that accepts an HTTP POST.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your API by using Postman with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **POST**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the URL for the API – **http://localhost:5000/api/user/register**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Body** tab, select **Raw** as the input and then **JSON** as the type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The port of the URL has to match the port in the output where it says **Now
    listening on:** **http://localhost:{your port}**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Testing the API using Postman
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve clicked **Send**, you should get **200 OK** at the bottom. Then
    you can open the MongoDB editor – for instance, Compass, as suggested in the pre-requisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new connection to the MongoDB server and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the connection string is pointing to your MongoDB server. By default,
    it should say **mongodb://localhost:27017**, which matches the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Connect** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19418_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Creating a new connection
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, you should see the database **TheSystem** on the left-hand side
    and, within it, the collections. Clicking the **user** collection or **user-details**,
    you should see the data you registered on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Registered data
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine, and the code certainly does its job as expected. But the code
    could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of challenges with this type of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the controller is taking on the responsibility for the infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, it also takes on the responsibility for the actual domain logic and
    knowing exactly how to store things in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API surface should instead just rely on other subsystems to do their specific
    job and then delegate to them rather and then become a composition.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we could go and isolate the user credential registration and the
    user details registration into two different services that we could use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s pull it apart a little bit and start putting in some structure. Create
    a file called **UsersService.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is doing exactly the same as it did in **UsersController** for registering
    the user, just that it is now formalized as a service. Let’s do the same for the
    user details. Create a file called **UserDetailsService.cs** and make it look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with **UsersService**, the code does exactly the same as the original code
    in **UsersController**, only now separated out and focused.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great step. Now the infrastructure details of the database are hidden
    from the outside world and anyone wanting to register a user only has to focus
    on the information needed to do so and not how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is for you to change **UsersController** to leverage the new services.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go and change the controller to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of the **UsersService** class in the constructor
    and uses the **Register** method directly in the **Register** API method.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the sample at this point and perform the **HTTP POST** again, you
    will get the exact same result.
  prefs: []
  type: TYPE_NORMAL
- en: '**UsersService** and **UserDetailsService** are now dependencies that **UsersController**
    have and it creates those dependencies as instances itself. There are a couple
    of downsides to this. The dependencies are basically now following the life cycle
    of the controller. Since controllers are created once per web request, it means
    **UsersService** and **UserDetailsService** will be created every time as well.
    This could be a performance issue, and is not really a problem the controller
    should be worried about. Its main job is just to provide an API surface for registering
    users.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very hard to be able to write tests for **UsersController**, as the
    dependencies are now hard-wired and it brings in all the infrastructure with it
    and then makes it much harder to test the logic of **UsersController** in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: This is where dependency inversion comes in, by reversing the relationship and
    saying that the system, in our case **UsersController**, is not responsible for
    creating the instance itself, but rather has it as an argument to the constructor,
    and letting whoever is instantiating the controller be responsible for providing
    the dependencies **UsersController** has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change **UsersController** to take the dependency on the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code now takes **UsersService** and **UserDetailsService** as arguments
    and uses those directly instead of creating an instance of them itself.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the benefit of the dependencies being very clear to the outside
    world. The life cycle of **UsersService** can then be managed outside of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the controller is taking the concrete instances, it is still
    tied to the infrastructure. This can be improved upon to decouple the infrastructure
    and make it more testable.
  prefs: []
  type: TYPE_NORMAL
- en: Contract oriented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve further on this, we could also extract the content of **UsersService**
    and **UserDetailsService** into interfaces and use those instead. The benefits
    of that are that you would decouple from the concrete implementation and its infrastructure
    needs and add flexibility in your code by allowing different implementations and,
    depending on the configuration or the system being in a specific state, switch
    out which implementation of the interface to use.
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit of extracting into an interface is that you make it easier
    to write tests that focus purely on the unit being tested and only the interaction
    with its dependencies, without having to bring in the entire infrastructure to
    write the automated test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called **IUsersService.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code holds the **Register** method with the same signature as in the original
    **UsersService** class. Then the implementation of **UsersService** only changes
    by adding the **IUsersService** inheritance. Open the **UsersService** file and
    make it implement the **IUsersService** interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For **UserDetailsService**, we want to do the same. Add a file called **IUserDetailsService.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code holds the **Register** method with the same signature as in the original
    **UserDetailsService** class. Then the implementation of **UserDetailsService**
    only changes by adding the **IUserDetailsService** inheritance. Open the **UserDetailsService**
    file and make it implement the **IUserDetailsService** interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With these two changes, we can now change how we express the dependencies.
    In **UsersController**, you then change from using **UsersService** to **IUsersService**
    and **UserDetailsService** to **IUserDetailsService**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code now takes the two **IUsersService** and **IUserDetailsService** dependencies
    using their interfaces and the rest of the code remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve discussed dependencies and the benefits of the **dependency inversion
    principle**. Still, we need to be able to provide these dependencies. And it is
    very impractical if we have to manually provide these all around our system and
    maintain life cycles of them in different ways. It could lead to a very messy,
    unmaintainable code base and could also lead to unknown side effects.
  prefs: []
  type: TYPE_NORMAL
- en: What you really want is something that manages this for you. This is what is
    known as an **inversion of control container** (**IoC container**). Its job is
    to hold information about all your services, which implementation is used for
    what interface, and also the life cycle of these. The IoC container is a centralized
    piece that you configure at the beginning of your application and after its configuration
    is done, you can ask it to provide instances of anything that is registered with
    it. It’s very useful for registering any kind of dependencies, not just the ones
    where it is an interface to an implementation. You can register concrete types,
    delegate types, or pretty much anything.
  prefs: []
  type: TYPE_NORMAL
- en: The IoC container works recursively and will deal with dependencies of dependencies
    and resolve everything correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, the concept of an IoC container is already set up out of the
    box and is really easy to use with what is known as **ServiceCollection**, where
    you can set up all the service registrations.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic ServiceCollection registrations by convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve now left the code in a non-functional state. This is because the built-in
    IoC container does not know how to resolve the **IUsersService** dependency and
    **IUserDetailsService**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to explicitly tell ASP.NET which implementation it should use. Open
    your **Program.cs** file and put in the binding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a registration in the ASP.NET Core **ServiceCollection** for **IUsersService**
    to be resolved to **UsersService**, and it also explicitly says that it should
    add it as a **singleton**. This means that there will only be one instance of
    this service within the process.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a working program again, the only difference now is that
    the ASP.NET IoC container is resolving the instance for you, and it will be the
    same instance for every request.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Singletons can be dangerous. If the type being a singleton has a dependency
    on something that shouldn’t be a singleton but should in fact be new on every
    request, the type being singleton will be a blocker for that. Use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: The code thus far is very contained and simple. In real systems, you tend to
    want to be even clearer about responsibilities by dividing up the code into more
    focused units.
  prefs: []
  type: TYPE_NORMAL
- en: Further refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Too much responsibility lies on **UsersService** right now. The database part
    is not something it should own. Knowing how to create a database connection is
    something that should be extracted so that you do that in one place. Be conscious
    of the responsibilities of each unit in your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a unit representing the database. Start by creating an interface
    by adding a file called **IDatabase.cs** to the project, and make it look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The interface gives us access to getting MongoDB collections for types specified
    using generics.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: By creating an abstraction for the database, one could argue we could have gone
    further and created something that represented the database operations you typically
    do adhering to what is known as the repository pattern. If you did that, you would
    quickly find that you would not be able to work with the underlying database and
    its capabilities. Also, for the context of this book, we’ll keep it at this level.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **IDatabase** interface in place, you now need an implementation of
    it. Create a file called **Database.cs** and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code contains most of the database access you had in **UsersService** but
    adds a dimension of mapping types to collection names.
  prefs: []
  type: TYPE_NORMAL
- en: As a little bit of a sidetrack, but still on the theme of convention over configuration,
    let’s improve the **Database** class a little bit. At the top of the class, there
    is the map of **Type** to the collection name. This is something that would grow
    over time. If you look at the **User** type, it gets mapped to **Users** – a convention
    that I prefer, having the collection names as plural, indicating there is more
    than one user.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of convention over configuration was coined by David Heinemeier
    Hansson to describe the philosophy of the Ruby on Rails web framework. You can
    read more about it here: [https://rubyonrails.org/doctrine#convention-over-configuration](https://rubyonrails.org/doctrine#convention-over-configuration).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something that can be automated and would truly be convention over
    configuration. Let’s pull in a third-party library that deals with pluralization
    for us. Go to your terminal and run the following in the **Chapter10** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The **Humanizer** library knows how to pluralize English words by default, but
    it has support for other languages as well. I recommend reading more about it
    over on GitHub ([https://github.com/Humanizr/Humanizer](https://github.com/Humanizr/Humanizer)).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the package installed, you can improve and simplify your **Database**
    code. Change the **Database** class to be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty much the same, except you now don’t have **Dictionary** with
    the mapping between **Type** and collection names. Also, for the **GetCollection()**
    method, you no longer need to do a lookup but instead, just use the type name
    and use the **.Pluralize()** extension method on it. With this, you’re leveraging
    the type metadata to your advantage in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: With this fix, you’ve basically made your code future-proof and will not have
    to perform open-heart surgery on the code to add support for a new collection.
    It’s a predictable convention.
  prefs: []
  type: TYPE_NORMAL
- en: Since you now have encapsulated the infrastructure part of the system into the
    **Database** class, you can now start fixing **UserService** and **UserDetailsService**
    to leverage this centerpiece.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by changing **UsersService** to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code now completely gets rid of the management of the database connection
    and how to get a collection, and also not even the name of the collection, instead
    pulling in **IDatabase** as a dependency and letting the implementation of that
    interface take the full responsibility of the infrastructure. This is now just
    by convention, and you can trust that it will be a predictable collection name
    for the type you give it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to do the same to **UserDetailsService**. Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As with **UsersService**, the code change is pretty much the same, bringing
    in the **IDatabase** infrastructure dependency and letting **UserDetailsService**
    focus on its primary job of registering user details.
  prefs: []
  type: TYPE_NORMAL
- en: The activity of refactoring the code has led to a more decoupled system and
    a more maintainable system, where each component is laser-focused on doing one
    thing, a single responsibility. It now needs to be brought together.
  prefs: []
  type: TYPE_NORMAL
- en: Composing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the system broken up into focused components, we have to bring it together.
    Since the IoC container does not know how to resolve **IDatabase**, we need to
    add that binding. Change your **Program.cs** to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code adds the **.AddSingleton<IDatabase, Database>()** call to register
    the binding between **IDatabase** and **Database** and also say we only need it
    to be a singleton. You should, at this point, have a working system again. Running
    this and performing the API call using Postman should give you the same result
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: However, already there is a bit of a code smell here. The fact that we have
    to go and manually add a registration to the IoC container for everything we add
    is again open-heart surgery we have to perform every time we create something.
    With just a couple of components, this not only becomes tedious but quickly also
    makes **Program.cs** a dumping ground for this type of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there is a pattern we can turn into a convention. All the implementations
    have an interface representation that is named the same as the implementation,
    only prefixed with a capital *I*. This is a very common convention. We can make
    the code more future-proof by discovering the connections between the interfaces
    and implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we can discover the relationship between implementations and interfaces,
    we wouldn’t know how to know which life cycle they should be. To do this, we shift
    the responsibility of knowing the life cycle onto the implementation. We do this
    by introducing metadata in the form of attributes. The default behavior should
    be that every binding we do is **transient**, meaning that we get a new instance
    every time we ask the IoC container. Then all we need is attributes for overriding
    that behavior. For this sample, we’ll keep it to only one life cycle: singleton.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **SingletonAttribute.cs** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code represents an attribute that is for classes and lets you look for during
    discovery and decide whether or not it is a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take advantage of the **Fundamentals** project in the GitHub repository
    mentioned in the pre-requisites. You should add a project reference to it for
    this chapter by doing the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The path to the project might be different on your computer, depending on where
    you have the **Fundamentals** project from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: What you now want to do is create an extension method for **IServiceCollection**
    that you’ve been calling to register bindings with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a file called **ServiceCollectionExtensions.cs** and make it
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code just sets up a new extension method called **AddBindingsByConvention()**
    that also takes the **ITypes** system from **Fundamentals** and returns **services**
    given to it to be able to chain calls when using the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go and add the following to the top of the **AddBindingsConvention()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code uses **ITypes** to get all the discovered types in the system. For
    every type, it looks at whether the type implements any interfaces. If it does
    implement an interface, it will see whether any of the interfaces match the convention.
    The convention is that the interface type and the implementation type have to
    be in the same namespace and that the interface type has to match the name of
    the implementation, only prefixed with a capital *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this will be a collection of types that matches the convention.
    Next, you’ll need to add code that registers the bindings. Add the following code
    after the previous code you added in the **AddBindingsByConvention()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The code loops through all the types that adhere to the convention and gets
    the actual interface and then binds it either as a singleton or transient based
    on whether or not the implementation has **SingletonAttribute** or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go and make all the services singleton using the attribute. Open the
    **Database.cs** file and add **SingletonAttribute** in front of the type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for **UserDetailsService**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And then do the same for **UsersService**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All you now need to do is change the program startup. Open **Program.cs** and
    change it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code changes from all the explicit bindings of the different services to
    now leverage the **Types** class from **Fundamentals**, binding it as a singleton,
    and then adding all the bindings discovered by convention.
  prefs: []
  type: TYPE_NORMAL
- en: Running your application should still give you the same behavior and it should
    work in the exact same way. The only difference is that everything is now by convention,
    and you can just add things without having to configure anything.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve tasted a little bit of how powerful conventions can
    be for concrete everyday C# coding, touching on how to improve the experience
    working with the IoC container in ASP.NET Core by optimizing a common scenario
    of registering services by their interface. We’ve also looked at how designing
    by contract helps you create a system that is more flexible and much easier to
    test.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of *convention over configuration* is probably the thing that has
    impacted me personally the most in my career. It makes your code more consistent
    and if you fail to be consistent, it doesn’t work, which is a good thing because
    then you will have to fix your code to be more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Having to not configure everything and just be able to add code is a true productivity
    boost, and anyone working on the project will thank you for it. However, you need
    to be clear with all team members about what the conventions are, otherwise, they
    will not thank you at all. There is nothing worse than having your code work or
    not work seemingly arbitrarily. Document it and be clear about how things work.
  prefs: []
  type: TYPE_NORMAL
- en: Also worth mentioning is that conventions are not for all projects and are not
    necessarily for all teams. For conventions to make sense, the team needs to accept
    that way of working. If the team prefers reading code and seeing everything explicitly
    set up, then conventions will only cause confusion. If the project is a very small
    one, it might not be worth the cognitive overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up in the next chapter, we’ll get more into the open/closed principle,
    something we’ve touched on in this chapter, and see how it can benefit your code
    base.
  prefs: []
  type: TYPE_NORMAL
