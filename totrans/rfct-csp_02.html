<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor026"/>2</h1>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Introduction to Refactoring</h1>
<p>The best way to learn refactoring is to look at an example. In this chapter, we’ll explore a sample refactoring scenario using C# and Visual Studio and see firsthand how refactoring can transform the maintainability of code without altering its functionality.</p>
<p>In this chapter, we’re going to cover the following main areas:</p>
<ul>
<li>Refactoring a baggage price calculator</li>
<li>Refactoring in other editors</li>
</ul>
<p>Along the way, we’ll cover refactorings around introducing locals, constants, and parameters, extracting methods, and removing unreachable/unused code, as well as touching upon the importance of testing in any refactoring endeavor.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
<p>If you want to follow along with this chapter, you can clone this book’s code from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a>.</p>
<p>The starting code for this chapter can be found in the <code>Chapter02/Ch2BeginningCode</code> folder after cloning the repository.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Refactoring a baggage price calculator</h1>
<p>We’ll start by<a id="_idIndexMarker030"/> examining a baggage price calculator used by the staff of Cloudy Skies Airline during baggage checks to determine the amount an individual customer must pay.</p>
<p>The rules for baggage pricing are as follows:</p>
<ul>
<li>All carry-on baggage costs $30 per bag</li>
<li>The first checked bag a passenger checks costs $40</li>
<li>Each subsequent checked bag costs $50</li>
<li>If the travel occurs during the holidays, a 10% surcharge is applied</li>
</ul>
<p>This code lives in a C# <code>BaggageCalculator</code> class that we’ll review in a few blocks of code, starting with the class definition, field, and full property:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">BaggageCalculator.cs:</p>
<pre class="source-code">
public class BaggageCalculator {
  private decimal holidayFeePercent = 0.1M;
  public decimal HolidayFeePercent {
    get { return holidayFeePercent; }
    set { holidayFeePercent = value; }
  }</pre>
<p>This is a simple class with an older style of property definition setting <code>holidayFeePercent</code> to a <code>decimal</code> value (identified by the <code>M</code> suffix) of <code>0.1</code> or 10%.</p>
<p>The class also <a id="_idIndexMarker031"/>has a <code>CalculatePrice</code> method that returns a <code>decimal</code> value indicating the total cost of baggage fees:</p>
<pre class="source-code">
  public decimal CalculatePrice(int bags,
    int carryOn, int passengers, DateTime travelTime) {
    decimal total = 0;
    if (carryOn &gt; 0) {
      Console.WriteLine($"Carry-on: {carryOn * 30M}");
      total += carryOn * 30M;
    }
    if (bags &gt; 0) {
      if (bags &lt;= passengers) {
        Console.WriteLine($"Checked: {bags * 40M}");
        total += bags * 40M;
      } else {
        decimal checkedFee = (passengers * 40M) +
          ((bags - passengers) * 50M);
        Console.WriteLine($"Checked: {checkedFee}");
        total += checkedFee;
      }
    }
    if (travelTime.Month &gt;= 11 || travelTime.Month &lt;= 2) {
      Console.WriteLine("Holiday Fee: " +
        (total * HolidayFeePercent));
      total += total * HolidayFeePercent;
    }
    return total;
  }</pre>
<p>That logic has some<a id="_idIndexMarker032"/> complexity to it, but it matches up with the business rules described earlier.</p>
<p>Finally, the class ends with a <code>CalculatePriceFlat</code> method that was introduced in an earlier version of the application and is no longer used (which we’ll discuss later):</p>
<pre class="source-code">
  private decimal CalculatePriceFlat(int numBags) {
    decimal total = 0;
    return 100M;
    return numBags * 50M;
  }
}</pre>
<p>While this code isn’t the worst in the world by any stretch, this is a class that is slowly growing in complexity and becoming harder to understand and maintain as new rules are added to the application.</p>
<p>Fortunately, this class is supported by a series of passing unit tests and is generally agreed to calculate the correct amount by all users.</p>
<p>Over the course of the chapter, we’ll apply a series of targeted refactorings to improve this code to <a id="_idIndexMarker033"/>prevent it from being an issue in the future.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Converting properties to auto properties</h2>
<p>The class <a id="_idIndexMarker034"/>starts with the declaration of the <code>HolidayFeePercent</code> property as shown here:</p>
<pre class="source-code">
private decimal holidayFeePercent = 0.1M;
public decimal HolidayFeePercent {
  get { return holidayFeePercent; }
  set { holidayFeePercent = value; }
}</pre>
<p>This code is fine and has no issues whatsoever. However, C# is a language that continues to evolve and developers generally prefer to write and maintain fewer lines of code when given the choice.</p>
<p>Because of this, Microsoft gave us the ability to write <em class="italic">automatically implemented properties</em> (commonly<a id="_idIndexMarker035"/> called <strong class="bold">auto properties</strong>) that automatically generate their own field with a getter and setter when the code is compiled.</p>
<p>While we could delete the property and its field and redeclare it, there’s a possibility that we could make a spelling or capitalization mistake when doing so. Instead, let’s take a look at how Visual Studio can do this for us automatically.</p>
<p>In Visual Studio, if you move your typing cursor onto a property name, either by using the arrow keys or by clicking on the name of the property, you’ll see a light bulb appear in the margin as shown in <em class="italic">Figure 2</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 2.1 – The light bulb Quick Actions icon" src="img/B21324_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The light bulb Quick Actions icon</p>
<p>If you click on this light bulb (or press <em class="italic">Ctrl</em> + <em class="italic">.</em> by default), the <strong class="bold">Quick Actions</strong> menu will appear and list several refactorings.</p>
<p>The refactoring choices are context-sensitive, so only those that Visual Studio believes are relevant to the code you have currently selected will appear.</p>
<p>In this case, the first option, <strong class="bold">Use auto property</strong>, is the refactoring action we want. See <em class="italic">Figure 2</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 2.2 – Previewing the Use auto property refactoring" src="img/B21324_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Previewing the Use auto property refactoring</p>
<p>When this option<a id="_idIndexMarker036"/> is selected, the pane on the right will display a preview of the change this will make to your code. Here it lists the lines it will remove in red and the line it adds in green.</p>
<p>Clicking <strong class="bold">Use auto property</strong> or pressing <em class="italic">Enter</em> on the keyboard will accept the suggestion and replace your code with the auto property version:</p>
<pre class="source-code">
public decimal HolidayFeePercent { <strong class="bold">get; set;</strong> } = 0.1M;</pre>
<p>Admittedly this is a simple refactoring, but there are a couple of things I want to stress about the refactoring process:</p>
<ul>
<li>Visual Studio took care of making the change and did so in an automated way that was free of potential typos or other mistakes a human might make.</li>
<li>If you didn’t know that you could move a full property to an auto property, this <strong class="bold">Quick Action</strong> helped you discover that. These <strong class="bold">Quick Actions</strong> can actually <em class="italic">teach</em> you a lot about the C# programming language as it continues to evolve and change every year.</li>
</ul>
<p>With the <a id="_idIndexMarker037"/>mechanics of refactoring in Visual Studio out of the way, let’s explore some additional refactorings.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Introducing locals</h2>
<p>One of the <a id="_idIndexMarker038"/>problems the <code>CalculatePrice</code> method has is that <a id="_idIndexMarker039"/>there are a few expressions, such as <code>carryOn * 30M</code> and <code>bags * 40M</code>, that appear multiple times throughout the method.</p>
<p>These are small issues but can lead to maintainability problems. If the nature of the expressions changed, we would need to modify multiple places within our code.</p>
<p>In general, one of the reasons you may want to refactor code is if you find yourself modifying multiple places to make a single change on a regular basis. For example, if the pricing structure changed we should modify multiple lines of code to support the new pricing model. Each one of those lines we should modify is a place we might fail to make a change. Missing changes like this typically introduce bugs.</p>
<p>Even if we didn’t miss any code that needed to be modified, most developers would prefer to have to make a change in one place instead of multiple.</p>
<p>The <strong class="bold">Introduce local</strong> refactoring can help with this by introducing a local variable containing the result of the expression.</p>
<p>To use this refactoring, select the expression that is repeated as shown in <em class="italic">Figure 2</em><em class="italic">.3</em>, noting that Visual Studio helpfully highlights any places it is repeated:</p>
<div><div><img alt="Figure 2.3 – Selecting a repeated expression in Visual Studio" src="img/B21324_02_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Selecting a repeated expression in Visual Studio</p>
<p>Next, use the <strong class="bold">Quick Action</strong> button by pressing <em class="italic">Ctrl</em> + <em class="italic">.</em> or clicking on the screwdriver icon.</p>
<p class="callout-heading">A note on the Quick Actions icon</p>
<p class="callout">The <strong class="bold">Quick Action</strong> button<a id="_idIndexMarker040"/> sometimes appears as a light bulb and sometimes appears as a screwdriver, depending on your code analysis rules and the exact issues a line is facing. They are effectively the same option, but the light bulb tells you a suggested refactoring is present while a screwdriver indicates a less critical refactoring option to consider.</p>
<p>Once the context menu is open, expand the right arrow next to <strong class="bold">Introduce local</strong> by using the <a id="_idIndexMarker041"/>arrow keys to navigate the menu. This will let you view more <a id="_idIndexMarker042"/>detailed options.</p>
<div><div><img alt="Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring" src="img/B21324_02_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Drilling into the specialized forms of the Introduce local refactoring</p>
<p>Here it gives you the ability to introduce a local variable just for the expression you selected or to do so <strong class="bold">for all occurrences</strong> of this expression. I generally recommend using the <strong class="bold">for all occurrences</strong><em class="italic"> </em>option, but it will depend on the context of what you’re trying to improve.</p>
<p>Once you select the <strong class="bold">Introduce local</strong> option, Visual Studio will prompt you for a name for your variable (see <em class="italic">Figure 2</em><em class="italic">.5</em>):</p>
<div><div><img alt="Figure 2.5 – Naming your new local variable" src="img/B21324_02_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Naming your new local variable</p>
<p>Type in the name you would like and then press <em class="italic">Enter</em> to make the box disappear.</p>
<p>In my case, I called the variable <code>fee</code> and it replaced it in both lines as shown here:</p>
<pre class="source-code">
if (carryOn &gt; 0) {
  decimal <strong class="bold">fee</strong> = carryOn * 30M;
  Console.WriteLine($"Carry-on: {<strong class="bold">fee</strong>}");
  total += <strong class="bold">fee</strong>;
}</pre>
<p>While this is certainly cleaner for the carry-on baggage fee logic, there’s still a <code>bags * 40M</code> expression repeated in the checked baggage logic and a <code>total * HolidayFeePercent</code> expression that is also repeated.</p>
<p>You can use the <strong class="bold">Introduce local</strong> refactoring to make complex lines more understandable by pulling some logic out of dense lines into their own smaller lines.</p>
<p>Applying<a id="_idIndexMarker043"/> the <strong class="bold">Introduce local</strong> refactoring throughout this method<a id="_idIndexMarker044"/> results in a longer method, but one that’s easier to understand:</p>
<pre class="source-code">
public decimal CalculatePrice(int bags,
  int carryOn, int passengers, DateTime travelTime) {
  decimal total = 0;
  if (carryOn &gt; 0) {
    decimal fee = carryOn * 30M;
    Console.WriteLine($"Carry-on: {fee}");
    total += fee;
  }
  if (bags &gt; 0) {
    if (bags &lt;= passengers) {
      <strong class="bold">decimal firstBagFee = bags * 40M;</strong>
      Console.WriteLine($"Checked: {<strong class="bold">firstBagFee</strong>}");
      total += <strong class="bold">firstBagFee</strong>;
    } else {
      <strong class="bold">decimal firstBagFee = passengers * 40M;</strong>
      <strong class="bold">decimal extraBagFee = (bags - passengers) * 50M;</strong>
      decimal checkedFee = <strong class="bold">firstBagFee + extraBagFee</strong>;
      Console.WriteLine($"Checked: {checkedFee}");
      total += checkedFee;
    }
  }
  if (travelTime.Month &gt;= 11 || travelTime.Month &lt;= 2) {
    <strong class="bold">decimal holidayFee = total * HolidayFeePercent;</strong>
    Console.WriteLine("Holiday Fee: " + <strong class="bold">holidayFee</strong>);
    total += <strong class="bold">holidayFee</strong>;
  }
  return total;
}</pre>
<p>As a programming instructor, I saw many students under the mistaken assumption that the shortest way to implement something was always the best.</p>
<p>Instead, the best code tends to be the code that’s easier to maintain over time, less likely to break, and easier to think about as you go about development tasks.</p>
<p>Less code is <a id="_idIndexMarker045"/>often easier to think about, but when code gets too <a id="_idIndexMarker046"/>concise or too complex it can be hard to maintain. Find a happy medium between brevity and readability, keeping in mind that many times, programmers skim code looking for a specific section.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Introducing constants</h2>
<p>The <code>const</code> value that will never change during the program’s runtime.</p>
<p>However, <strong class="bold">Introduce constant</strong> is often used for a different purpose than <strong class="bold">Introduce local</strong>. While <strong class="bold">Introduce local</strong> tends to be used to reduce repetition or simplify complex lines of <a id="_idIndexMarker049"/>code, <strong class="bold">Introduce constant</strong> is often <a id="_idIndexMarker050"/>used to eliminate <strong class="bold">magic numbers</strong> or <strong class="bold">magic strings</strong> from code.</p>
<p>In programming, a magic number is a number that exists in your code without any explanation of what that number means or why it is there. This is bad because the person maintaining your code later doesn’t understand why that number was chosen.</p>
<p>The <code>CalculatePrice</code> method has three magic numbers: <code>30M</code>, <code>40M</code>, and <code>50M</code>, representing the various baggage fee amounts.</p>
<p>Introducing a constant for these is the same as introducing a local. Just highlight the number and open <a id="_idIndexMarker051"/>the <strong class="bold">Quick Actions</strong> menu, then <a id="_idIndexMarker052"/>select <strong class="bold">Introduce constant</strong> and then <strong class="bold">Introduce constant for all occurrences</strong> in the sub-menu as shown here:</p>
<div><div><img alt="Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal literal" src="img/B21324_02_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Introducing a constant for all occurrences of the 40M decimal literal</p>
<p>Doing this to the various magic numbers in our application and choosing appropriate names results in the following new constants at the top of the class:</p>
<pre class="source-code">
private const decimal CarryOnFee = 30M;
private const decimal FirstBagFee = 40M;
private const decimal ExtraBagFee = 50M;</pre>
<p>Introducing these constants has the added benefit of putting our price rules in a centralized place, making them more discoverable by new developers joining the team.</p>
<p>This also makes our code a lot easier to read:</p>
<pre class="source-code">
if (carryOn &gt; 0) {
    decimal fee = carryOn * <strong class="bold">CarryOnFee</strong>;
    Console.WriteLine($"Carry-on: {fee}");
    total += fee;
}</pre>
<p>Programmers spend disproportionally more time <em class="italic">reading</em> code rather than <em class="italic">writing</em> code. Optimizing<a id="_idIndexMarker053"/> your code for maintainability is a<a id="_idIndexMarker054"/> key habit that will help your application resist technical debt as time goes by.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Introducing parameters</h2>
<p>One refactoring <a id="_idIndexMarker055"/>technique I wish I saw more people <a id="_idIndexMarker056"/>use is the <strong class="bold">Introduce </strong><strong class="bold">parameter</strong> refactoring.</p>
<p>This refactoring takes an expression or variable in a method and removes it from the method entirely, instead adding its value as a new parameter to the method.</p>
<p>For example, right now the <code>CalculatePrice</code> method has logic inside of it for determining which travel dates should be considered for holiday travel:</p>
<pre class="source-code">
if (<strong class="bold">travelTime.Month &gt;= 11 || travelTime.Month &lt;= 2</strong>) {
  decimal holidayFee = total * HolidayFeePercent;
  Console.WriteLine("Holiday Fee: " + holidayFee);
  total += holidayFee;
}</pre>
<p>This is logic that could become more complex as more holidays are added and holidays from different countries are considered. As the code is written now, the additional complexity would need to go into this <code>if</code> statement.</p>
<p>Instead, introducing a parameter for <code>isHoliday</code> gives the callers of this method the responsibility of telling whether the method is holiday travel or not. This ultimately allows us to leave this method to focus on pricing the customer’s baggage and to be aware of holidays but it is not responsible for determining what is and what isn’t a holiday.</p>
<p>Introducing a parameter can be done by selecting the variable or expression you wish to move to a parameter and then triggering the <strong class="bold">Quick </strong><strong class="bold">Actions</strong> menu:</p>
<div><div><img alt="Figure 2.7 – Introducing a parameter using the Quick Actions menu" src="img/B21324_02_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Introducing a parameter using the Quick Actions menu</p>
<p>There are multiple options to choose from when introducing a parameter. Choosing <strong class="bold">and update call sites directly</strong> is usually a good option – provided you review the code it generates.</p>
<p>Once we introduce <a id="_idIndexMarker057"/>the parameter and name it appropriately, the <a id="_idIndexMarker058"/>holiday fee logic becomes much easier to read:</p>
<pre class="source-code">
if (<strong class="bold">isHoliday</strong>) {
  decimal holidayFee = total * HolidayFeePercent;
  Console.WriteLine("Holiday Fee: " + holidayFee);
  total += holidayFee;
}</pre>
<p>Introducing a parameter also changed the method signature line to add a Boolean <code>isHoliday</code> parameter:</p>
<pre class="source-code">
public decimal CalculatePrice(int bags, int carryOn,
  int passengers, DateTime travelTime, <strong class="bold">bool isHoliday</strong>) {</pre>
<p>As a result of this refactoring, any code that called the <code>CalculatePrice</code> method now calculates and passes a value for <code>isHoliday</code> to the method.</p>
<p>I find that <strong class="bold">Introduce parameter</strong> is particularly helpful for letting a method focus on just a few key pieces of logic.</p>
<p>It can also be very helpful in places where you have very similar methods of doing similar things but only differing by a few key details. It can sometimes be possible to merge many different methods into a single method that takes in a few details as parameters.</p>
<p>For example, the following code might perform logging for different actions:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Fee.cs</p>
<pre class="source-code">
public void ChargeCarryOnBaggageFee(decimal fee) {
    Console.WriteLine($"<strong class="bold">Carry-on Fee</strong>: {fee}");
    Total += fee;
}
public void ChargeCheckedBaggageFee(decimal fee) {
    Console.WriteLine($"<strong class="bold">Checked Fee</strong>: {fee}");
    Total += fee;
}</pre>
<p>These two methods<a id="_idIndexMarker059"/> both take in a numeric fee and <a id="_idIndexMarker060"/>write the charge name and charged fee to the console. In fact, the only way they differ is the charge name.</p>
<p>This code could be consolidated into a single method by introducing a parameter:</p>
<pre class="source-code">
public void ChargeFee(decimal fee, <strong class="bold">string chargeName</strong>) {
    Console.WriteLine($"{<strong class="bold">chargeName</strong>}: {fee}");
    Total += fee;
}</pre>
<p>Never underestimate the value of making a method more generalized by having outside code provide additional details.</p>
<p>With the charge logic largely improved, let’s move on to the final method in the code that has several<a id="_idIndexMarker061"/> warnings associated with it.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Removing unreachable and unused code</h2>
<p>If you<a id="_idIndexMarker062"/> opened the beginning code from<a id="_idIndexMarker063"/> this chapter in Visual Studio, you would likely notice that <code>CalculatePriceFlat</code> and a few variables inside it appear in gray with a number of wavy underscore suggestions as shown in <em class="italic">Figure 2</em><em class="italic">.8</em>.</p>
<div><div><img alt="Figure 2.8 – The CalculatePriceFlat method with gray text for many lines of code" src="img/B21324_02_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The CalculatePriceFlat method with gray text for many lines of code</p>
<p>Visual Studio can sometimes detect when variables, parameters, and even methods are not being used. If it does so, Visual Studio usually renders these identifiers in more muted tones and often includes suggestions to investigate or remove these items.</p>
<p>In this case, nothing is ever calling the <code>CalculatePriceFlat</code> method, and nothing is referencing the <code>numBags</code> parameter. The <code>total</code> variable is declared and given a value but is never read from after that, and the final <code>return</code> line is unreachable given the return line above it.</p>
<p>Each one of these issues can be addressed with a <em class="italic">remove unused member</em>, <em class="italic">remove unused variable</em>, or <em class="italic">remove unreachable </em><em class="italic">code</em> refactoring.</p>
<p>All these refactorings do what you’d expect: they remove the offending code.</p>
<p>Since nothing is calling the method at all, the entire method can be removed.</p>
<h3>Removing unused parameters</h3>
<p>There’s another <a id="_idIndexMarker064"/>piece of code from earlier that can be removed as well: the <code>CalculatePrice</code> method has a <code>travelTime</code> parameter that is no longer being used after we introduced the <code>isHoliday</code> parameter.</p>
<p>There is no <em class="italic">remove unused parameter</em> in Visual Studio at the time of writing, but you can remove it safely using some of the method-level refactorings we’ll discuss in the next chapter.</p>
<p>To perform this refactoring, select the <code>travelTime</code> parameter and then select <strong class="bold">Change signature...</strong> as shown here:</p>
<div><div><img alt="Figure 2.9 – Changing the signature of a method" src="img/B21324_02_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Changing the signature of a method</p>
<p>Clicking <strong class="bold">Change signature…</strong> will show the <strong class="bold">Change </strong><strong class="bold">Signature</strong> dialog.</p>
<p>Select the <code>travelTime</code> parameter <a id="_idIndexMarker065"/>and click <strong class="bold">Remove</strong>. The parameter will appear crossed out in the dialog:</p>
<div><div><img alt="Figure 2.10 – The Change Signature dialog with travelTime removed" src="img/B21324_02_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – The Change Signature dialog with travelTime removed</p>
<p>Click <strong class="bold">OK</strong> and the dialog will close and the parameter will be removed.</p>
<p>Any code that was referencing your method will also have their signatures updated to not pass anything for the <code>travelTime</code> parameter.</p>
<h3>Avoiding pitfalls when removing code</h3>
<p>One cautionary <a id="_idIndexMarker066"/>note on removing code: be particularly careful about removing <code>public</code> members from code. Sometimes Visual Studio is not aware of all the places using code. This is particularly true for serialization/deserialization logic, properties that exist for data binding, and members that are accessed using reflection.</p>
<p>Additionally, if your code is being deployed<a id="_idIndexMarker067"/> as a <strong class="bold">NuGet package</strong> or otherwise being shared in other projects, it is possible that code outside of your solution may depend on a method or parameter, and your change could cause their code to no longer compile.</p>
<p class="callout-heading">Reminder on testing</p>
<p class="callout">It is <em class="italic">your</em> responsibility to test any refactorings you make and ensure they do not bring about unintended changes in program behavior.</p>
<p>That may sound scary, but don’t let these edge cases stop you from removing dead code.</p>
<p>I’ve known a number of developers hesitant to remove code in case they need it later. Instead, these developers will either keep the code there untouched or comment the entire block of code out.</p>
<p>The problem with commenting out dead code is that it increases the amount of distracting and unhelpful comments in a file. This reduces the amount of importance developers place on the comments that are present and also increases the amount of scrolling the developers must do.</p>
<p>Delete dead code. Your code should be in source control anyway, so if you really need to find the code later, you can look at the history to recover it – assuming, of course, you checked the code into source control to begin with.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Extracting methods</h2>
<p>Our code is now<a id="_idIndexMarker068"/> looking fairly clean, but <a id="_idIndexMarker069"/>the <code>CalculatePrice</code> method has a lot of logic in it for the checked baggage price calculation.</p>
<p>This logic is complex enough for us to extract a method just for this logic and call that method from our existing code.</p>
<p>To do this, select the lines of code that represent the method you want to extract. Be mindful of the various <code>{}</code> instances that you select, as your selection must make sense as a related block of code to Visual Studio. See the following screenshot.</p>
<div><div><img alt="Figure 2.11 – Extracting a method from a block of code" src="img/B21324_02_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Extracting a method from a block of code</p>
<p>Once your block of <a id="_idIndexMarker070"/>code is selected, open the <strong class="bold">Quick Actions</strong> menu, choose <strong class="bold">Extract Method</strong>, and then name the method in the prompt before pressing <em class="italic">Enter</em> to confirm your name.</p>
<div><div><img alt="Figure 2.12 – Naming the extracted method" src="img/B21324_02_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Naming the extracted method</p>
<p>This will result in a new method being added to your code:</p>
<pre class="source-code">
private static decimal ApplyCheckedBagFee(int bags,
  int passengers, decimal total) {
  if (bags &lt;= passengers) {
    decimal firstBagFee = bags * FirstBagFee;
    Console.WriteLine($"Checked: {firstBagFee}");
    total += firstBagFee;
  } else {
    decimal firstBagFee = passengers * FirstBagFee;
    decimal extraBagFee = (bags - passengers)* ExtraBagFee;
    decimal checkedFee = firstBagFee + extraBagFee;
    Console.WriteLine($"Checked: {checkedFee}");
    total += checkedFee;
  }
  return total;
}</pre>
<p>Note that Visual Studio will make the method <code>private</code> by default and will mark the method as <code>static</code> if it does not access instance members on the class.</p>
<p>I generally prefer <code>private</code> methods, but your preferences on <code>static</code> may vary depending on what<a id="_idIndexMarker071"/> method you’re working with and<a id="_idIndexMarker072"/> whether it makes sense for the method to ultimately be <code>static</code>.</p>
<p>The extract method refactoring also removes the code from the original method and replaces it with a call to the new method:</p>
<pre class="source-code">
public decimal CalculatePrice(int bags, int carryOn,
  int passengers, DateTime travelTime, bool isHoliday) {
  decimal total = 0;
  if (carryOn &gt; 0) {
    decimal fee = carryOn * CarryOnFee;
    Console.WriteLine($"Carry-on: {fee}");
    total += fee;
  }
  if (bags &gt; 0) {
    total = <strong class="bold">ApplyCheckedBagFee(bags, passengers, total)</strong>;
  }
  if (isHoliday) {
    decimal holidayFee = total * HolidayFeePercent;
    Console.WriteLine("Holiday Fee: " + holidayFee);
    total += holidayFee;
  }
  return total;
}</pre>
<p>This results in a much more concise and readable <strong class="bold">CalculatePrice method</strong> and makes it easier to think about everything the method is doing. This reduced complexity greatly improves the long-term<a id="_idIndexMarker073"/> quality of the method by helping<a id="_idIndexMarker074"/> developers fully understand the method and avoids costly mistakes that can occur when maintaining complex blocks of code.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Refactoring manually</h2>
<p>Up until this<a id="_idIndexMarker075"/> point, we’ve performed a number of refactoring operations supported by Visual Studio. These have been fairly safe given the quality of the tools we’ve used, but there are some things the built-in tools just won’t do.</p>
<p>Visual Studio is powerful, but it can’t think about code like a human can (despite the exciting new AI features we’ll talk about in <a href="B21324_11.xhtml#_idTextAnchor236"><em class="italic">Chapter 11</em></a>, <em class="italic">AI-Assisted Refactoring with GitHub </em><em class="italic">Copilot Chat</em>).</p>
<p>Sometimes there will be opportunities to improve the code that no built-in refactoring can perform for you. At those points, you’ll have to make the changes manually.</p>
<p>The <code>ApplyCheckedBagFee</code> method we extracted earlier is a good method, but a few things could be improved.</p>
<p>First, the method takes in a total, increases it by a fee, and then returns that new total. It’d be easier for others to understand the method if the method returned the fee instead of the adjusted total.</p>
<p>Secondly, the method is performing the same <code>Console.WriteLine</code> operation twice. Additionally, all other <code>WriteLine</code> statements in the class are in the <code>CalculatePrice</code> method, making the user interface slightly hard to fully trace.</p>
<p>Let’s modify the method so that it returns only the fee, doesn’t require the <code>total</code> parameter, and <a id="_idIndexMarker076"/>doesn’t log anything:</p>
<pre class="source-code">
private static decimal ApplyCheckedBagFee(int bags,
  int passengers) {
  if (bags &lt;= passengers) {
    decimal firstBagFee = bags * FirstBagFee;
    <strong class="bold">return firstBagFee;</strong>
  } else {
    decimal firstBagFee = passengers * FirstBagFee;
    decimal extraBagFee = (bags-passengers) * ExtraBagFee;
    decimal checkedFee = firstBagFee + extraBagFee;
    <strong class="bold">return checkedFee;</strong>
  }
}</pre>
<p>Next, we’ll need to update the code that calls this method:</p>
<pre class="source-code">
if (bags &gt; 0) {
  <strong class="bold">decimal bagFee = ApplyCheckedBagFee(bags, passengers);</strong>
  Console.WriteLine($"Checked: {<strong class="bold">bagFee</strong>}");
  total += <strong class="bold">bagFee</strong>;
}</pre>
<p>Note that the result is stored in a <code>bagFee</code> variable, <code>total</code> is no longer passed to <code>ApplyCheckedBagFee</code>, and <code>Console.WriteLine</code> now appears here in this method.</p>
<p>Additionally, the <code>ApplyCheckedBagFee</code> name might not apply anymore since the method no longer actually applies the fee, but rather calculates it. In this case, applying the <em class="italic">rename method</em> refactoring <a id="_idIndexMarker077"/>would help the final code have a more appropriate name.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Testing refactored code</h2>
<p>As I mentioned<a id="_idIndexMarker078"/> earlier, it is <em class="italic">your responsibility</em> to<a id="_idIndexMarker079"/> ensure that your refactoring efforts have not altered how the system fundamentally behaves.</p>
<p>In our case, this means that <code>BaggageCalculator</code> should still calculate the same prices it did before for any valid set of inputs.</p>
<p>One of the many tools we have at our disposal for determining whether code still meets our needs is<a id="_idIndexMarker080"/> running <strong class="bold">unit tests</strong>.</p>
<p>We’ll talk more about unit tests in <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>, <em class="italic">Unit Testing</em>, but for now, know that unit tests are code that verifies that other code is working as expected.</p>
<p><code>BaggageCalculator</code> has five tests that can be run by clicking on the <strong class="bold">Test</strong> menu and then choosing <strong class="bold">Run </strong><strong class="bold">All Tests</strong>.</p>
<p>The <strong class="bold">Test Explorer</strong> window should show all tests as passing with green check marks:</p>
<div><div><img alt="Figure 2.13 – Five passing tests in Test Explorer" src="img/B21324_02_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Five passing tests in Test Explorer</p>
<p>If a test is now failing and didn’t fail before, this is a good thing, since it means the test found an issue you caused in the code’s behavior. Investigate the failing test and then resolve the issue before continuing.</p>
<p>We’ll explore testing in much more detail in <em class="italic">Part 2</em> of this book, but as it stands, it appears that our refactorings have been successful.</p>
<p class="callout-heading">Final code</p>
<p class="callout">The final refactored code from this chapter is available in the <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> repository, inside the <code>Chapter02/Ch2FinalCode</code> folder.</p>
<p>The code we produced in this chapter is simple, readable, and maintainable. Certainly, there are things that <a id="_idIndexMarker081"/>could still be improved, but the code is less likely to cause issues as it grows in complexity in the future.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Refactoring in other editors</h1>
<p>Before we end<a id="_idIndexMarker082"/> the chapter, let’s talk about refactoring in editors other than Visual Studio.</p>
<p>This book primarily focuses on refactoring in Visual Studio because that’s the current primary development environment for .NET developers. However, there are a few other editors and extensions that are frequently used for .NET development and offer refactoring support:</p>
<ul>
<li><strong class="bold">Visual </strong><strong class="bold">Studio Code</strong></li>
<li><strong class="bold">JetBrains Rider</strong></li>
<li><strong class="bold">JetBrains ReSharper</strong> (Visual Studio Extension)</li>
</ul>
<p>These tools will not be featured in examples throughout the remainder of the book since Visual Studio is the primary editing experience. However, most of what I’ll show you in the remainder of the book is also possible using these tools.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Refactoring in Visual Studio Code with the C# Dev Kit</h2>
<p><strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) is <a id="_idIndexMarker083"/>rapidly<a id="_idIndexMarker084"/> becoming a highly capable editing environment for .NET projects with its C# extension.</p>
<p>Where VS Code really comes into its own is with the newer <strong class="bold">C# Dev Kit</strong>, which gives an editing experience almost identical to Visual Studio, including the solution explorer. The C# Dev Kit integrates with the other C# extensions to provide code suggestions and refactoring <strong class="bold">Quick Actions</strong> with the same style of light bulb icons you see in Visual Studio.</p>
<div><div><img alt="Figure 2.14 – Refactoring with the C# Dev Kit in VS Code" src="img/B21324_02_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Refactoring with the C# Dev Kit in VS Code</p>
<p>VS Code won’t give you the full set of refactoring options Visual Studio currently does, but it is cross-platform and will work on Mac and Linux.</p>
<p class="callout-heading">Licensing note</p>
<p class="callout">VS Code is free, but the C# Dev Kit extension requires a paid Visual Studio license key.</p>
<p>I expect we’ll see VS Code featured much more prominently in .NET development with the improvements from the C# Dev Kit and VS Code’s cross-platform capabilities, along with its ability to<a id="_idIndexMarker085"/> run <a id="_idIndexMarker086"/>in-browser to some <a id="_idIndexMarker087"/>extent through <strong class="bold">GitHub Codespaces</strong>.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Refactoring in JetBrains Rider</h2>
<p>JetBrains Rider is a<a id="_idIndexMarker088"/> separate editor developed on the same set of editing software used by the <a id="_idIndexMarker089"/>popular <strong class="bold">IntelliJ</strong> Java editor.</p>
<p>Rider works with most .NET projects and has a fantastic set of refactoring capabilities built in. These capabilities will often be similar to those mentioned in this book, but the exact naming and user experience will be slightly different.</p>
<div><div><img alt="Figure 2.15 – Refactoring in JetBrains Rider" src="img/B21324_02_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Refactoring in JetBrains Rider</p>
<p>Like VS Code, one major advantage Rider has over Visual Studio is that it is fully cross-platform and can run on macOS or Linux.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Refactoring in Visual Studio with ReSharper</h2>
<p>If you love <a id="_idIndexMarker090"/>working with Visual Studio but want the <a id="_idIndexMarker091"/>same rich set of refactorings that Rider offers, JetBrains also offers a Visual Studio extension called <strong class="bold">ReSharper</strong>.</p>
<p>ReSharper replaces many Visual Studio features with enhanced versions, including Visual Studio’s code analysis and refactoring tools.</p>
<div><div><img alt="Figure 2.16 – Refactoring with ReSharper in Visual Studio" src="img/B21324_02_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Refactoring with ReSharper in Visual Studio</p>
<p>Nowadays, Visual Studio tends to have most of the refactoring capabilities ReSharper and Rider offer, but<a id="_idIndexMarker092"/> the capabilities of ReSharper and Rider <a id="_idIndexMarker093"/>can sometimes be a bit more advanced.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Summary</h1>
<p>Throughout this chapter, we explored refactoring by taking a class with a bit of complexity and applied targeted refactorings to make it easier to read, maintain, and expand.</p>
<p>We went from a modestly complex class to a relatively simple one by following a set of repeatable actions that transformed the code from one form to another without changing its overall behavior or result.</p>
<p>Although Visual Studio supports very capable refactoring tools, it is up to you as an experienced developer to know when you might want to apply each individual refactoring, based on the current level of complexity of your code and the code smells you’re observing.</p>
<p>Over the next three chapters, we’ll explore the built-in refactorings in more depth by exploring refactorings related to methods, classes, and individual lines of code.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Questions</h1>
<ol>
<li>What are some ways of triggering Quick Actions for a block of code?</li>
<li>Does Visual Studio ever indicate that refactorings are possible or recommended?</li>
<li>How can you know what a Quick Action will do before performing it?</li>
<li>Are Visual Studio Quick Actions the only way to refactor code?</li>
</ol>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Further reading</h1>
<p>You can find more information about refactoring in Visual Studio and other environments at these URLs:</p>
<ul>
<li><em class="italic">Quick Actions </em><em class="italic">Overview</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions ">https://learn.microsoft.com/en-us/visualstudio/ide/quick-actions</a></li>
<li><em class="italic">JetBrains Rider vs Visual Studio (with and without </em><em class="italic">ReSharper)</em>: <a href="https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/">https://www.jetbrains.com/rider/compare/rider-vs-visual-studio/</a></li>
<li><em class="italic">Announcing C# Dev Kit for Visual Studio </em><em class="italic">Code</em>: <a href="https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/">https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/</a></li>
</ul>
</div>
</body></html>