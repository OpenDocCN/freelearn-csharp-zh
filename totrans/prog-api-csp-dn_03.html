<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-38">
    <a id="_idTextAnchor038">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor039">
    </a>
    
     Implementing with REST
    
   </h1>
   <p>
    
     In the previous chapter, we created a simple database and object (
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     ) to interact with.
    
    
     In this chapter, we’ll look
    
    <a id="_idIndexMarker034">
    </a>
    
     at the
    
    <strong class="bold">
     
      Representation State Transfer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      REST
     
    </strong>
    
     ) protocol and how it is used in APIs.
    
    
     REST is the most popular protocol for
    
    
     
      creating APIs.
     
    
   </p>
   <p>
    
     We will see how REST contributes to creating a client/server architecture, and with it, desirable separation of concerns.
    
    
     We will cover the following topics in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Understanding what
     
     
      
       REST is
      
     
    </li>
    <li>
     
      Looking at standard
     
     
      
       web protocols
      
     
    </li>
    <li>
     
      The first implementation of a
     
     
      
       REST API
      
     
    </li>
    <li>
     
      What
     
     <strong class="bold">
      
       Data Transfer Objects
      
     </strong>
     
      (
     
     <strong class="bold">
      
       DTOs
      
     </strong>
     
      ) are and how to
     
     
      
       use them
      
     
    </li>
    <li>
     
      Using Postman as
     
     
      
       our frontend
      
     
    </li>
   </ul>
   <p>
    
     By the time you finish this chapter, you will understand the fundamentals of creating
    
    
     
      simple APIs.
     
    
   </p>
   <h1 id="_idParaDest-40">
    <a id="_idTextAnchor040">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, you will need
    
    <strong class="bold">
     
      Visual Studio
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      AutoMapper
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Dapper
     
    </strong>
    
     .
    
    
     Please see
    
    <a href="B21998_01.xhtml#_idTextAnchor013">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Getting Started
     
    </em>
    
     , for how to obtain these.
    
    
     The code files for this chapter can be found in the GitHub repository
    
    
     
      here:
     
    
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03">
     
      
       https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03
      
     
    </a>
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor041">
    </a>
    
     REST
    
   </h1>
   <p>
    
     One of
    
    <a id="_idIndexMarker035">
    </a>
    
     the key concepts in REST is the separation of concerns.
    
    
     This idea will be familiar to you as a C# programmer.
    
    
     Here, we are separating the concerns of the server and
    
    
     
      the client.
     
    
   </p>
   <p>
    
     The API can only respond to calls from the client, and cannot generate calls of its own.
    
    
     Note that within the logic of the API implementation, it is possible to call other APIs, but not back to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     The server is in no way dependent on the design or implementation of
    
    
     
      the client.
     
    
   </p>
   <h2 id="_idParaDest-42">
    <a id="_idTextAnchor042">
    </a>
    
     Client/server
    
   </h2>
   <p>
    
     The key to a
    
    <a id="_idIndexMarker036">
    </a>
    
     REST application is that the API can be called by any type of client: web application, phone application, and so on.
    
    
     Further, the client can be located anywhere and there are no constraints on the architecture of
    
    
     
      the client.
     
    
   </p>
   <p>
    
     The same is true for the backend, behind the API.
    
    
     Typically, this will be a database, but it can be any type of data storage: relational, object, in memory, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     One way to accomplish this, is to use the standard web protocols such as
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     , and so forth.
    
    
     This approach is essential to REST.
    
    
     In fact, for many people this is the virtual definition
    
    
     
      of REST.
     
    
   </p>
   <h1 id="_idParaDest-43">
    <a id="_idTextAnchor043">
    </a>
    
     Using web protocols
    
   </h1>
   <p>
    
     In REST, we
    
    <a id="_idIndexMarker037">
    </a>
    
     use the same verbs as we do in HTTP:
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     .
    
    
     In addition, the API returns standard web values to the client, for example,
    
    <strong class="source-inline">
     
      404 (not found)
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      200 (success)
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      201 (created)
     
    </strong>
    
     , and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     Each
    
    <a id="_idIndexMarker038">
    </a>
    
     request from the client to the API will consist of an HTTP header, body, and meta-data.
    
    
     The client expresses which API is wanted by calling a URL, and passes needed data (e.g., the
    
    <strong class="source-inline">
     
      id value for the requested entity
     
    </strong>
    
     either in the URL or, if passing too much data for a URL, in the body of the request.
    
    
     For example, here is a POST to add a car to the backend database.
    
    
     Don’t worry about the syntax for now; rather, take a look at the URL and the body of the request in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.1 – Sending data for insertion" src="img/B21988_03_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1 – Sending data for insertion
    
   </p>
   <p>
    
     At the
    
    <a id="_idIndexMarker039">
    </a>
    
     top of the figure, we see the URL (https://localhost:7025/Car).
    
    
     This is the “address” of the API.
    
    
     Notice that the last part of the URL is
    
    <em class="italic">
     
      Car
     
    </em>
    
     .
    
    
     This is the name of
    
    
     
      the controller.
     
    
   </p>
   <p>
    
     Below the URL is
    
    <a id="_idIndexMarker040">
    </a>
    
     a menu allowing you to see the parameters being sent, the Authorization any headers that go along as meta-data (see
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     ), the body that we see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     , any scripts to run before sending the request, tests to ensure we are getting back the right data (see
    
    <a href="B21998_08.xhtml#_idTextAnchor105">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Advanced Topics
     
    </em>
    
     ), and any settings we need for
    
    
     
      the request.
     
    
   </p>
   <p>
    
     The numbered lines 1-12 in the preceding figure are the body of this request.
    
    
     We are inserting a car into the database and so all the data for the insertion is here in JSON format.
    
    
     Notice that there is no ID; that will be assigned on
    
    
     
      the backend.
     
    
   </p>
   <div><div><img alt="Figure 3.2 – Headers" src="img/B21988_03_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.2 – Headers
    
   </p>
   <p>
    
     These
    
    <a id="_idIndexMarker041">
    </a>
    
     headers
    
    <a id="_idIndexMarker042">
    </a>
    
     provide vital information to the server.
    
    
     They must be sent for each interaction because REST is
    
    
     
      inherently stateless.
     
    
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor044">
    </a>
    
     Statelessness and caching
    
   </h2>
   <p>
    
     REST APIs are
    
    <a id="_idIndexMarker043">
    </a>
    
     stateless, so you must treat each call to the API as independent from all
    
    
     
      other calls.
     
    
   </p>
   <p>
    
     Note that if you need state and you are on Azure, you’ll want a durable function, which is covered in
    
    <a href="B21998_07.xhtml#_idTextAnchor094">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Azure
     
    </em>
    
     <em class="italic">
      
       Durable Functions
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     While you
    
    <a id="_idIndexMarker044">
    </a>
    
     cannot maintain state between calls, the server can cache data for faster retrieval.
    
    
     This can significantly improve performance There are a number of platforms that can support REST APIs; the one we will focus on for this book, and the platform of choice for .NET, is
    
    
     
      ASP.NET Core.
     
    
   </p>
   <p>
    
     An alternative to REST is GraphQL.
    
    
     There are two problems this designed to solve: overfetching and underfetching.
    
    
     The user wants to send a single API call to the server.
    
    
     In order to do this, they must designate what data is needed.
    
    
     If a Car entity is requested, it may be that they don’t care at all about some of the features of the car but they get the entire car as part of the API.
    
    
     This is called overfetching.
    
    
     On the other hand, if they designate an API that
    
    <a id="_idIndexMarker045">
    </a>
    
     only gets the type of car, this may be under fetching (they have to make a second
    
    <a id="_idIndexMarker046">
    </a>
    
     call for the rest of what they need).
    
    
     GraphQL is designed to solve this problem, allowing the client to specify exactly which properties
    
    
     
      are requested.
     
    
   </p>
   <p>
    
     That said, the downside of GraphQL is that each API query must be hand-crafted to designate what
    
    
     
      is wanted.
     
    
   </p>
   <p>
    
     Because of this, and other technical constraints, not the least of which is inertia, REST is by far the most popular way to write APIs and we will not cover GraphQL in
    
    
     
      this book.
     
    
   </p>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor045">
    </a>
    
     Implementing REST in ASP.NET Core
    
   </h1>
   <p>
    
     An API created
    
    <a id="_idIndexMarker047">
    </a>
    
     in ASP.NET Core will typically have three
    
    
     
      major components:
     
    
   </p>
   <ul>
    <li>
     
      
       Controllers
      
     
    </li>
    <li>
     
      
       Services
      
     
    </li>
    <li>
     
      
       Repositories
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     There is an alternative to controller-based APIs known as Minimal APIs.
    
    
     We discuss this in brief towards the end of this chapter (refer to the
    
    <em class="italic">
     
      Minimal APIs
     
    </em>
    
     box).
    
    
     We do not cover Minimal APIs for the rest of the book as they have too
    
    
     
      many limitations.
     
    
   </p>
   <p>
    
     When you
    
    <a id="_idIndexMarker048">
    </a>
    
     invoke an API with a URL, that address is resolved to a controller.
    
    
     For example, using the URL we saw earlier, if you call https://localhost:7025/Car, you will invoke the
    
    <strong class="source-inline">
     
      CarController
     
    </strong>
    
     at that address.
    
    
     Note that ASP.NET uses “convention over configuration,” by which we mean that
    
    <em class="italic">
     
      by convention
     
    </em>
    
     , the part of the word Controller is left off the address but is implied.
    
    
     So in this case,
    
    <strong class="source-inline">
     
      CarController
     
    </strong>
    
     , the address just uses
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     (leaving
    
    
     
      off Controller).
     
    
   </p>
   <p>
    
     The job of the controller is to ensure that the user has been authenticated (it’s really them) and authorized (they have permission to take whatever action is invoked).
    
    
     The controller then assembles any needed data and passes it along to the Service.
    
    
     Typically, but not necessarily, this will be called
    
    <strong class="source-inline">
     
      CarService
     
    </strong>
    
     and will sit in a folder with
    
    
     
      other services.
     
    
   </p>
   <p>
    
     The job of the Service is to handle any business logic and prepare the data to go into the database.
    
    
     It then passes the data to
    
    
     
      the repository.
     
    
   </p>
   <p>
    
     Similar to the Service, the repository would typically be called
    
    <strong class="source-inline">
     
      CarRepository
     
    </strong>
    
     and would be located in a folder along with other repositories.
    
    
     The job of the repository is to interact with the
    
    <a id="_idIndexMarker049">
    </a>
    
     underlying data storage (for example,
    
    
     
      a database).
     
    
   </p>
   <p>
    
     Often, you will want to separate the properties of the database from the properties of an object to be sent through the API.
    
    
     For that, we
    
    
     
      use DTOs.
     
    
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor046">
    </a>
    
     DTOs
    
   </h2>
   <p>
    
     It is
    
    <a id="_idIndexMarker050">
    </a>
    
     common to use DTOs to separate the representation of the structure of the database from a
    
    <a id="_idIndexMarker051">
    </a>
    
     supporting
    
    <strong class="bold">
     
      Plain Old C#
     
    </strong>
    
     <strong class="bold">
      
       Object
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       POCO
      
     </strong>
    
    
     
      )
     
    
   </p>
   <p>
    
     Let’s take an example from a relational database.
    
    
     Each row may have twelve columns but for a specific API request, only seven are needed.
    
    
     The DTO will be a class with seven properties, and we’ll use a tool (
    
    <strong class="source-inline">
     
      AutoMapper
     
    </strong>
    
     ) to map the values in the seven columns to the
    
    
     
      seven properties.
     
    
   </p>
   <h3>
    
     Installing AutoMapper
    
   </h3>
   <p>
    
     The easiest
    
    <a id="_idIndexMarker052">
    </a>
    
     way to install
    
    <strong class="source-inline">
     
      AutoMapper
     
    </strong>
    
     is to
    
    <a id="_idIndexMarker053">
    </a>
    
     download the NuGet packages, as shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.3 – Installing AutoMapper" src="img/B21988_03_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.3 – Installing AutoMapper
    
   </p>
   <p>
    
     There
    
    <a id="_idIndexMarker054">
    </a>
    
     is a bit of configuration
    
    <a id="_idIndexMarker055">
    </a>
    
     for
    
    <strong class="source-inline">
     
      AutoMapper
     
    </strong>
    
     , but it is only done once.
    
    
     In
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , add
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddAutoMapper(typeof(Program));</pre>
   <p>
    
     The next step is to create the DTO
    
    
     
      class itself.
     
    
   </p>
   <h3>
    
     Creating the DTO class
    
   </h3>
   <p>
    
     The POCO classes
    
    <a id="_idIndexMarker056">
    </a>
    
     we’ve created directly track the columns in the database, as described earlier.
    
    
     The DTO class tracks some or all of these columns
    
    
     
      as properties:
     
    
   </p>
   <pre class="source-code">
namespace Cars.Data.DTOs
{
    public class CarDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Mpg { get; set; }
        public string Cylinders { get; set; }
        public string Displacement { get; set; }
        public string Horsepower { get; set; }
        public string Weight { get; set; }
        public string Acceleration { get; set; }
        public string ModelYear { get; set; }
        public string Origin { get; set; }
    }
}</pre>
   <p>
    
     Once your
    
    <a id="_idIndexMarker057">
    </a>
    
     DTO is in place, you need a way to map the properties in the DTO to the properties in the database (POCO) class.
    
    
     We can do that in
    
    
     
      a profile.
     
    
   </p>
   <h3>
    
     Setting up the profile
    
   </h3>
   <p>
    
     While
    
    <a id="_idIndexMarker058">
    </a>
    
     we are here, let’s set up the profile file for the
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     entity.
    
    
     The
    
    <strong class="source-inline">
     
      AutoMapper
     
    </strong>
    
     tool (no pun intended) provides a base class,
    
    <strong class="source-inline">
     
      Profile
     
    </strong>
    
     , that we will
    
    
     
      derive from.
     
    
   </p>
   <p>
    
     Create a file called
    
    <strong class="source-inline">
     
      CarProfile.cs
     
    </strong>
    
     and put this code
    
    
     
      in it:
     
    
   </p>
   <pre class="source-code">
Public class CarProfile : Profile
{
   Public CarProfile()
   {
      CreateMap&lt;CarDto, Car&gt;()
        .ForMember(car =&gt; car.id, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
        Id))
        .ForMember(car =&gt; car.name, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
        Name))
        .ForMember(car =&gt; car.mpg, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
        Mpg))
        .ForMember(car =&gt; car.cylinders, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Cylinders))
        .ForMember(car =&gt; car.displacement, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Displacement))
        .ForMember(car =&gt; car.horsepower, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Horsepower))
        .ForMember(car =&gt; car.weight, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Weight))
        .ForMember(car =&gt; car.acceleration, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Acceleration))
        .ForMember(car =&gt; car.model_year, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.ModelYear))
        .ForMember(car =&gt; car.origin, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Origin))
        .ReverseMap();</pre>
   <p>
    
     Notice that for
    
    <a id="_idIndexMarker059">
    </a>
    
     every member that we want to share between the DTO and the POCO class, there is an entry.
    
    
     At the bottom is
    
    <strong class="source-inline">
     
      ReverseMap
     
    </strong>
    
     , which, as you may have guessed, reverses the mapping (for example, it causes the map to go from
    
    <strong class="bold">
     
      DTO &gt; Car
     
    </strong>
    
     to
    
    <strong class="bold">
     
      Car &gt;
     
    </strong>
    
     <strong class="bold">
      
       DTO
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     We have taken care of the DTO; now we need to connect our POCO to the database.
    
    
     We’ll do that
    
    
     
      with Dapper.
     
    
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor047">
    </a>
    
     Dapper
    
   </h2>
   <p>
    
     As noted
    
    <a id="_idIndexMarker060">
    </a>
    
     earlier, we will use Dapper as our
    
    <strong class="bold">
     
      Object Relational Model
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ORM
     
    </strong>
    
     ).
    
    
     This will greatly simplify our interaction between the repository and the database.
    
    
     Dapper has its own syntax but it is very (very) close to SQL and the points of departure will
    
    
     
      be obvious.
     
    
   </p>
   <p class="callout-heading">
    
     Installing Dapper
    
   </p>
   <p class="callout">
    
     To install and
    
    <a id="_idIndexMarker061">
    </a>
    
     use Dapper, please see their very straightforward and comprehensive instructions
    
    
     
      at
     
    
    <a href="https://www.learndapper.com/">
     
      
       https://www.learndapper.com/
      
     
    </a>
   </p>
   <p>
    
     Here, for
    
    <a id="_idIndexMarker062">
    </a>
    
     example, is the Dapper code to get a car
    
    
     
      by ID:
     
    
   </p>
   <pre class="source-code">
Public async Task&lt;Car?&gt; GetCarById(int carId)
{
var sql =
    $@"SELECT *
       FROM
            Cars C
       WHERE
            C.id = @{nameof(carId)}
            AND C.is_deleted = 0";
var param = new
{
    carId
};
var car = await QueryFirstOrDefaultAsync&lt;Car&gt;(sql, param);
return car;
}</pre>
   <p>
    
     We can create
    
    <a id="_idIndexMarker063">
    </a>
    
     more complex statements with
    
    
     
      conditional logic.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Dapper uses C# rather than SQL syntax except for the query itself.
    
    
     This makes interacting with the database much easier for
    
    
     
      C# programmers.
     
    
   </p>
   <p>
    
     That is really all you need to know to get started creating your API.
    
    
     Let’s try inserting a car into the database using
    
    
     
      the API.
     
    
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor048">
    </a>
    
     Examining the SQL
    
   </h2>
   <p>
    
     The
    
    <a id="_idIndexMarker064">
    </a>
    
     SQL (pronounced See-Quill) in the above example can almost be read as an English sentence.
    
    
     First, we use the keyword SELECT to indicate that we want to pick out and return a subset of the data in
    
    
     
      the Database.
     
    
   </p>
   <p>
    
     Next comes the asterisk (
    
    <strong class="source-inline">
     
      *
     
    </strong>
    
     ) which indicates that we want all the columns.
    
    
     The alternative is to list the columns
    
    
     
      we want.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      From Cars C
     
    </strong>
    
     indicates that we want the data to come from the
    
    <strong class="source-inline">
     
      Cars
     
    </strong>
    
     table, and that we will be using the alias
    
    <strong class="source-inline">
     
      C
     
    </strong>
    
     to refer to
    
    
     
      that table.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Where
     
    </strong>
    
     statement constrains the search to the criteria that follows it, in this case where the id of the car (using the alias C) matches the id we’re looking for.
    
    
     We then tack on “
    
    <strong class="source-inline">
     
      where is_deleted = 0
     
    </strong>
    
     ” indicating that we only want entries that are not marked
    
    
     
      as deleted.
     
    
   </p>
   <p>
    
     Here is where Dapper comes in.
    
    
     We set up an array of parameters,
    
    
     
      and then
     
    
   </p>
   <p>
    
     call:
    
    
     <strong class="source-inline">
      
       QueryFirstOrDefaultAsync&lt;Car&gt;(sql, param);
      
     </strong>
    
   </p>
   <p>
    
     This invokes the
    
    <strong class="source-inline">
     
      QueryFirstOrDefault
     
    </strong>
    
     method in dapper.
    
    
     We pass in the type of object we are looking for (Car) and then two parameters.
    
    
     For our purposes, the first will always be SQL, and the second will always be the name of the collection we created
    
    
     
      above (param).
     
    
   </p>
   <p>
    
     We assign the result (in this case one car) to a variable, and return
    
    
     
      that value.
     
    
   </p>
   <p>
    
     Please note that the constructor for this class will have interfaces passed in through Dependency Injection, and those parameters will be assigned to member variables (for example, _
    
    <strong class="source-inline">
     
      carService
     
    </strong>
    
     ).
    
    
     If you are not familiar with Dependency Injection, please refer to the code in
    
    
     
      the repository.
     
    
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor049">
    </a>
    
     Putting it all together (inserting a car)
    
   </h1>
   <p>
    
     Let’s put this
    
    <a id="_idIndexMarker065">
    </a>
    
     together using controller, service, and repository to insert a car with Dapper
    
    
     
      and AutoMapper:
     
    
   </p>
   <pre class="source-code">
//Controller
[HttpPost]
 public async Task&lt;ActionResult&lt;Car&gt;&gt; Insert([FromBody] CarDto 
 carAsDto)
 {
     try
     {
         if (carAsDto == null)
         {
             return BadRequest("No car was provided");
         }
         var carToInsert = _mapper.Map&lt;Car&gt;(carAsDto);
         var insertedCar = await _carService.Insert(carToInsert);
         var insertedCarDto = _mapper.Map&lt;CarDto&gt;(insertedCar);
         var location = $"https://localhost:5001/car/{insertedCarDto.
         Id}";
         return Created(location, insertedCarDto);
     }
     catch (Exception e)
     {
         return StatusCode(StatusCodes.Status500InternalServerError);
     }
 }</pre>
   <p>
    
     Notice that
    
    <a id="_idIndexMarker066">
    </a>
    
     we’ve transformed the DTO to a database object (
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     ), which we then pass to
    
    
     
      the service:
     
    
   </p>
   <pre class="source-code">
 // car service
  public async Task&lt;Car&gt; Insert(Car)
 {
     var newId = await _carRepository.UpsertAsync(car);
     if (newId &gt; 0)
     {
         car.id = newId;
     }
     else
     {
         throw new Exception("Failed to insert car");
     }
     return car;
 }</pre>
   <p>
    
     We are now ready to pass this car to the repository for storage in
    
    
     
      our database:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;int&gt; UpsertAsync(Car car)
 {
     using var db = databaseConnectionFactory.GetConnection();
     var sql = @"
     DECLARE @InsertedRows AS TABLE (Id int);
     MERGE INTO Car AS target
     USING (SELECT @Id AS Id, @Name AS Name, @MPG as MPG, @
     Cylinders as Cylinders, @Displacement as Displacement, @
     Horsepower as Horsepower, @Weight as Weight, @Acceleration as 
     Acceleration, @Model_Year AS Model_Year, @Origin AS origin, @
     Is_Deleted AS Is_Deleted ) AS source
     ON target.Id = source.Id
     WHEN MATCHED THEN
         UPDATE SET
             Name = source.Name,
             MPG = source.MPG,
             Cylinders = source.Cylinders,
             Displacement = source.Displacement,
             Horsepower = source.Horsepower,
             Weight = source.Weight,
             Acceleration = source.Acceleration,
             Model_Year = source.Model_Year,
             Origin = source.Origin,
             Is_Deleted = source.Is_Deleted
     WHEN NOT MATCHED THEN
         INSERT (Name, Mpg, Cylinders, Displacement, Horsepower, 
         Weight, Acceleration, Model_Year, Origin, Is_deleted)
         VALUES (source.Name, source.MPG, source.Cylinders, source.
         Displacement, source.Horsepower, source.Weight, source.
         Acceleration, source.Model_Year, source.Origin, source.Is_
         Deleted)
         OUTPUT inserted.Id INTO @InsertedRows
     ;
     SELECT Id FROM @InsertedRows;
 ";
     var newId = await db.QuerySingleOrDefaultAsync&lt;int&gt;(sql, car);
     return newId == 0 ? car.id : newId;
 }</pre>
   <p>
    
     If we get a
    
    <a id="_idIndexMarker067">
    </a>
    
     valid new car, we pass back the
    
    <strong class="source-inline">
     
      newId value
     
    </strong>
    
     , which we check for in the service.
    
    
     However, that is a lot of data we are passing to the API.
    
    
     We’ll look at solving that problem in the
    
    
     
      next section.
     
    
   </p>
   <p>
    
     A note on dependency injection: as you know, we pass in interfaces to our methods so that we can support dependency injection.
    
    
     This is set up in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , and the injection itself
    
    
     
      is automatic.
     
    
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor050">
    </a>
    
     Creating the body in Postman
    
   </h2>
   <p>
    
     As you can see, the
    
    <a id="_idIndexMarker068">
    </a>
    
     data that we want to pass into the API will be too much for the query string, and so we will pass it into the body.
    
    
     We can signal this in the definition of the API by writing
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;ActionResult&lt;Car&gt;&gt; Insert([<strong class="bold">FromBody</strong>] CarDto carAsDto)</pre>
   <p>
    
     Every API call will have zero or more
    
    <strong class="source-inline">
     
      FromQuery
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      FromUrl
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      FromBody
     
    </strong>
    
     attributes.
    
    
     In this case, we
    
    <a id="_idIndexMarker069">
    </a>
    
     are just using
    
    <strong class="source-inline">
     
      FromBody
     
    </strong>
    
     .
    
    
     Our call through Postman is seen in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .4
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.4 – Inserting a car" src="img/B21988_03_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.4 – Inserting a car
    
   </p>
   <p>
    
     Here, we are inserting all the properties of the car (except the ID value) as seen in the top window.
    
    
     To do
    
    <a id="_idIndexMarker070">
    </a>
    
     this, we would adjust the SQL statement to take all the properties.
    
    
     Notice that the API returns the properties of the inserted car, including its
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     (bottom window).
    
    
     The return code will be
    
    
     <strong class="source-inline">
      
       201
      
     </strong>
    
    
     
      (created).
     
    
   </p>
   <p>
    
     Since we are looking for the data in the body of the request, the URL is just the address of
    
    
     
      the controller.
     
    
   </p>
   <p>
    
     We have inserted a single car, but I have pre-seeded the database with many more.
    
    
     Let’s use the API to
    
    
     
      see them.
     
    
   </p>
   <h2 id="_idParaDest-51">
    <a id="_idTextAnchor051">
    </a>
    
     Get all
    
   </h2>
   <p>
    
     To get a list of all the cars in the database, we begin in
    
    
     
      the controller:
     
    
   </p>
   <p>
    
     Warning: the following example shows calling the repository directly for illustration purposes.
    
    
     Shortly afterwards we will discuss the correct way to
    
    
     
      do this.
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;Car&gt;&gt; GetAll(bool returnDeletedRecords = false)
{
    return await _carRepository.GetAll(returnDeletedRecords);
}</pre>
   <p>
    
     Here, we call the repository directly.
    
    
     This is an alternative to calling the service, and is generally a bad practice, but I wanted to show how it is done.
    
    
     Notice that we include a Boolean parameter as to whether to return the deleted records
    
    
     
      as well.
     
    
   </p>
   <p>
    
     Normally, we would use a
    
    <strong class="source-inline">
     
      Service
     
    </strong>
    
     class for separation of concerns.
    
    
     The service class would contain the program logic and would sit between the controller and
    
    
     
      the repository.
     
    
   </p>
   <p>
    
     In the repository, we build our
    
    <strong class="source-inline">
     
      SqlBuilder
     
    </strong>
    
     (as we saw earlier in the section on
    
    <em class="italic">
     
      Dapper
     
    </em>
    
     ) and obtain
    
    
     
      the records:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;IEnumerable&lt;Car&gt;&gt; GetAll(bool returnDeletedRecords = false)
{
    var builder = new SqlBuilder();
    var sqlTemplate = builder.AddTemplate("SELECT * FROM car " + 
    "/**where**/ ");
    if (!returnDeletedRecords)
    {
        builder.Where("is_deleted=0");
    }
    using var db = databaseConnectionFactory.GetConnection();
    return await db.QueryAsync&lt;Car&gt;(sqlTemplate.RawSql,sqlTemplate.
    Parameters)
}</pre>
   <p>
    
     Let’s take that one line at a time.
    
    
     The first line indicates that we will return a list of
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     objects and the decision as to whether or not to return deleted records defaults
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       false
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We next create a
    
    <strong class="source-inline">
     
      SqlBuilder
     
    </strong>
    
     object and then set the
    
    <strong class="source-inline">
     
      SqlTemplate
     
    </strong>
    
     object to select everything from
    
    
     
      the car.
     
    
   </p>
   <p>
    
     Notice the
    
    <strong class="source-inline">
     
      /**where**/
     
    </strong>
    
     statement.
    
    
     This is a Dapper convention indicating that a
    
    <strong class="source-inline">
     
      where
     
    </strong>
    
     clause may be
    
    
     
      placed here.
     
    
   </p>
   <p>
    
     We will now check to see whether the deleted records are to be included, and if not, we add a where clause using the builder we created on the
    
    
     
      first line.
     
    
   </p>
   <p>
    
     We are ready to get the Database from the factory we created and then query the database, passing in the
    
    <strong class="source-inline">
     
      RawSql
     
    </strong>
    
     code created for use in the
    
    <strong class="source-inline">
     
      SqlTemplate object
     
    </strong>
    
     and the parameters.
    
    
     In this case, there are
    
    
     
      no parameters.
     
    
   </p>
   <p>
    
     What we get back is an array of
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     objects, which we return to the
    
    
     
      calling method.
     
    
   </p>
   <p>
    
     To test this, we set Postman to
    
    <strong class="source-inline">
     
      Get
     
    </strong>
    
     and the URL to https://localhost:7025/Car.
    
    
     Since no ID is provided, our code will get them all, as shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .5
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.5 – Getting all the cars in the database" src="img/B21988_03_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.5 – Getting all the cars in the database
    
   </p>
   <p>
    
     Having inserted records, we may want to change one or another.
    
    
     To do that, we’ll want to use the
    
    
     <strong class="source-inline">
      
       Put
      
     </strong>
    
    
     
      verb.
     
    
   </p>
   <h2 id="_idParaDest-52">
    <a id="_idTextAnchor052">
    </a>
    
     Update
    
   </h2>
   <p>
    
     Updating
    
    <a id="_idIndexMarker071">
    </a>
    
     uses the HTTP
    
    <strong class="source-inline">
     
      Put
     
    </strong>
    
     verb.
    
    
     Let’s trace through how it
    
    
     
      is done.
     
    
   </p>
   <p>
    
     We return to the controller and add an
    
    <strong class="source-inline">
     
      HttpPut
     
    </strong>
    
     attribute.
    
    
     We then indicate that the contents will be in the body of the request (rather than the query) as we saw in
    
    
     
      the insert:
     
    
   </p>
   <pre class="source-code">
[HttpPut]
public async Task&lt;IActionResult&gt; Put([FromBody] Car car)</pre>
   <p>
    
     Since we can’t be certain that the record we want to update is still in the database, we put the call in a try block, and if we get an exception, we call
    
    <strong class="source-inline">
     
      BadRequest
     
    </strong>
    
     .
    
    
     Interestingly, if we succeed, we call
    
    <strong class="source-inline">
     
      NoContent
     
    </strong>
    
     as we are not adding anything to
    
    
     
      the database:
     
    
   </p>
   <pre class="source-code">
[HttpPut]
public async Task&lt;IActionResult&gt; Put([FromBody] Car car)
{
    try
    {
        await _carService.Update(car);
    }
    catch (Exception e)
    {
        return BadRequest(e);
    }
    return NoContent();
}</pre>
   <p>
    
     As shown, from here we call the
    
    <strong class="source-inline">
     
      carService
     
    </strong>
    
     ’s
    
    <strong class="source-inline">
     
      Update
     
    </strong>
    
     method, passing in the car we want to update.
    
    
     Note that some programmers use
    
    <strong class="source-inline">
     
      OK
     
    </strong>
    
     rather
    
    
     
      than
     
    
    
     <strong class="source-inline">
      
       NoContent
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In the service, we’ll
    
    <a id="_idIndexMarker072">
    </a>
    
     make sure we got a valid car
    
    <strong class="source-inline">
     
      id value
     
    </strong>
    
     and then call
    
    <strong class="source-inline">
     
      UpsertAsync
     
    </strong>
    
     , passing in the car.
    
    
     If we get back any
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     value except the original, we throw an exception; otherwise, we return the
    
    
     <strong class="source-inline">
      
       Car
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;Car&gt; Update(Car car)
{
    if (car.id == 0)
    {
        throw new Exception("Id must be set");
    }
    var oldId = car.id;
    var newId = await _carRepository.UpsertAsync(car);
    if (newId != oldId)
    {
        throw new Exception("Failed to update car");
    }
    return car;
}</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      Upsert
     
    </strong>
    
     method, we check to see whether this is a new car (insert) or
    
    
     
      an update:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;int&gt; UpsertAsync(Car car)
{
    using var db = databaseConnectionFactory.GetConnection();
    var sql = @"
    DECLARE @InsertedRows AS TABLE (Id int);
    MERGE INTO Car AS target
    USING (SELECT @Id AS Id, @Name AS Name, @MPG as MPG, @Cylinders as 
    Cylinders, @Displacement as Displacement, @Horsepower as 
    Horsepower, @Weight as Weight, @Acceleration as Acceleration, @
    Model_Year AS Model_Year, @Origin AS origin, @Is_Deleted AS Is_
    Deleted ) AS source
    ON target.Id = source.Id
    WHEN MATCHED THEN
        UPDATE SET
            Name = source.Name,
            MPG = source.MPG,
            Cylinders = source.Cylinders,
            Displacement = source.Displacement,
            Horsepower = source.Horsepower,
            Weight = source.Weight,
            Acceleration = source.Acceleration,
            Model_Year = source.Model_Year,
            Origin = source.Origin,
            Is_Deleted = source.Is_Deleted
    WHEN NOT MATCHED THEN
        INSERT (Name, Mpg, Cylinders, Displacement, Horsepower,
        Weight, Acceleration, Model_Year, Origin, Is_deleted)
        VALUES (source.Name, source.MPG, source.Cylinders, source.
        Displacement, source.Horsepower, source.Weight, source.
        Acceleration,source.Model_Year, source.Origin, source.Is_
        Deleted)
        OUTPUT inserted.Id INTO @InsertedRows
    ;
    SELECT Id FROM @InsertedRows;
";
    var newId = await db.QuerySingleOrDefaultAsync&lt;int&gt;(sql, car);
    return newId == 0 ? car.id : newId;
}</pre>
   <p>
    
     Notice, in the final
    
    <a id="_idIndexMarker073">
    </a>
    
     two lines, that we obtain the
    
    <strong class="source-inline">
     
      newId
     
    </strong>
    
     value from the query and if it is
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , we return the original car ID.
    
    
     Otherwise, we return the
    
    <strong class="source-inline">
     
      newid
     
    </strong>
    
     value from the car
    
    
     
      we inserted.
     
    
   </p>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor053">
    </a>
    
     Soft delete
    
   </h2>
   <p>
    
     For the
    
    <a id="_idIndexMarker074">
    </a>
    
     sake of completeness, let’s take a quick look at soft delete.
    
    
     You’ll remember that when the user asks to delete a record, rather than actually removing it from the database, we mark it as deleted (in the
    
    <strong class="source-inline">
     
      is_deleted
     
    </strong>
    
     column) so that we can obtain those records
    
    
     
      as needed.
     
    
   </p>
   <p>
    
     We start back in
    
    
     
      the controller:
     
    
   </p>
   <pre class="source-code">
[HttpDelete("{id}")]
public async Task&lt;IActionResult&gt; Delete(int id)
{
    try
    {
        await _carService.Delete(id);
    }
    catch (Exception e)
    {
        return BadRequest(e);
    }
    return NoContent();
}</pre>
   <p>
    <strong class="source-inline">
     
      Delete
     
    </strong>
    
     takes the
    
    <a id="_idIndexMarker075">
    </a>
    
     ID of the car to mark as deleted and then calls the service.
    
    
     All the service does is make sure that the ID is valid and then call the repository to do the
    
    
     
      actual deletion:
     
    
   </p>
   <pre class="source-code">
public async Task Delete(int id)
{
    var car = await _carRepository.Get(id);
    if (car == null)
    {
        throw new Exception("Car not found");
    }
    await _carRepository.DeleteAsync(id);
    return;
}</pre>
   <p>
    
     The code in the repo is dead simple.
    
    
     It gets the connection to the database and creates the query to set
    
    <strong class="source-inline">
     
      is_deleted
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     .
    
    
     It then
    
    <a id="_idIndexMarker076">
    </a>
    
     executes
    
    
     
      that query:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;int&gt; DeleteAsync(int id)
{
    using var db = databaseConnectionFactory.GetConnection();
    var query = "UPDATE car SET Is_Deleted = 1 WHERE Id = @Id";
    return await db.ExecuteAsync(query, new { Id = id });
}</pre>
   <p>
    
     At this point, you have a complete API for
    
    <strong class="bold">
     
      Create, Read, Update, Delete
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       CRUD
      
     </strong>
    
    
     
      ) operations.
     
    
   </p>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor054">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, you were introduced to using Dapper and AutoMapper, the latter for DTO objects.
    
    
     You also dove into the workings of the CRUD operations, using the typical three classes: controller, service,
    
    
     
      and repository.
     
    
   </p>
   <p>
    
     You saw that for simple operations, you can bypass the Service, but this is considered
    
    
     
      bad practice.
     
    
   </p>
   <p>
    
     In an enterprise application, you will want to use DTOs to separate the layout of the database from the layout of the object being passed around.
    
    
     As we delve into the realm of enhancing API usability and understanding, the next chapter will highlight the significance of documenting your project
    
    
     
      with Swagger.
     
    
   </p>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor055">
    </a>
    
     You try it
    
   </h1>
   <p>
    
     Create a simple database to track your music collection.
    
    
     Put this in a database and use Dapper and AutoMapper to implement the four CRUD operations.
    
    
     For this exercise, create DTOs that provide only a subset of the columns in
    
    
     
      the database.
     
    
   </p>
   <p class="callout-heading">
    
     Minimal APIs
    
   </p>
   <p class="callout">
    
     Minimal APIs offer an alternative way to create APIs without using Controllers.
    
    
     While they still allow for the injection of required services, they are primarily intended for smaller endpoints with
    
    
     
      minimal dependencies.
     
    
   </p>
   <p class="callout">
    
     In contrast, Controllers come with a larger hierarchy of endpoint components to consider.
    
    
     This includes features such as versioning, controller naming, and manual route attributes, which can introduce extra boilerplate that may not always be necessary.
    
    
     Minimal APIs simplify this process by allowing you to declare and handle requests in a
    
    
     
      single expression.
     
    
   </p>
   <p class="callout">
    
     To illustrate, let’s reimplement the call to get all cars.
    
    
     Start with the code from
    
    <a href="B21998_03.xhtml#_idTextAnchor038">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , then use the app variable to add calls to
    
    <strong class="source-inline">
     
      MapGet
     
    </strong>
    
     .
    
    
     The route will be
    
    <strong class="source-inline">
     
      /car-minimal
     
    </strong>
    
     , and the handler can remain the same as the
    
    <strong class="source-inline">
     
      GetAll
     
    </strong>
    
     method: a call to
    
    <strong class="source-inline">
     
      ICarRepository.GetAll
     
    </strong>
    
     .
    
    
     But how will we access the service interface without a constructor?
    
    
     Minimal APIs solve this by using parameter injection.
    
    
     Simply pass
    
    <strong class="source-inline">
     
      ICarRepository carRepository
     
    </strong>
    
     as an argument to the delegate for
    
    <strong class="source-inline">
     
      MapGet
     
    </strong>
    
     parameter, and use it to call the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       GetAll
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p class="callout">
    
     Many different types can be injected into the handlers for Minimal APIs.
    
    
     Model-bound types are differentiated by applying attributes to individual parameters.
    
    
     Commonly used ones include
    
    <strong class="source-inline">
     
      [FromRoute]
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      [FromBody]
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      [FromServices]
     
    </strong>
    
     .
    
    
     Additional special types include
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      HttpResponse
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      IFormFile
     
    </strong>
    
     , and a
    
    <strong class="source-inline">
     
      Stream
     
    </strong>
    
     of the request body.
    
    
     The full list is available in the official
    
    
     
      Microsoft documentation.
     
    
   </p>
  </div>
 </body></html>