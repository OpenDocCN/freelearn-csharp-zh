<html><head></head><body>
        

                            
                    <h1 class="header-title">Spatial Partition</h1>
                
            
            
                
<p>In this chapter, we are going to review the Spatial Partition pattern; the concept of spatial partitioning is prevalent in computer graphics and is used for organizing the objects in a virtual space in an optimal way. This approach is also valid for the management of GameObjects placed inside of a Unity scene. By implementing the core principles of the Spatial Partition pattern, we can divide a large environment that's filled to the brim with two-dimensional or three-dimensional objects, and still be able to maintain a degree of consistent performance. As you will see in this chapter, this pattern is one of the core ingredients that make the production of large AAA open-world games possible.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the basic principles behind the Spatial Partition pattern</li>
<li>We will implement a mini game in which a predator hunts prey in a scene</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter is hands-on, and you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>LINQ</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before moving forward.</p>
<p>LINQ is a very powerful query language that's somewhat similar to SQL; it can be a time saver when you want to simply iterate through a data structure.</p>
<div><p>The code files from this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2FAyWCf">http://bit.ly/2FAyWCf</a></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Spatial Partition pattern</h1>
                
            
            
                
<p>Game programmers are often faced with the problem of finding a way to quickly locate the specific entities in a scene that are closest to a reference point, for example, the player character. In Unity, there are many approaches to solving this problem, such as the following:</p>
<ul>
<li>Implement a ray casting system that will scan the area around the player character and report the locations of specific entities.</li>
<li>Use Unity's API features, such as the <kbd>GameObject.Find()</kbd> function, to locate specific entities in the scene, and then compare their coordinates to those of the player character.</li>
</ul>
<p>The first option is valid, but if we have a complex three-dimensional environment, it might be difficult to locate all of the entities that we are looking for, because they might be behind other objects and cannot be intersected by the ray. The second option might not be ideal performance-wise, because we will need to iterate through a list that includes every entity in the scene until we find every instance of a specific type.</p>
<p>We can resolve this type of technical challenge by using the Spatial Partition pattern; it was designed for this purpose. One thing that we need to address first is the name of this pattern. The term <strong>Spatial Partition</strong> can be misleading: we are not organizing or modifying the virtual space that we are partitioning. We are doing the opposite; we are removing space from the equation.</p>
<p>We achieve this by putting three-dimensional objects that are in a scene into a flat data structure that efficiently represents, in the memory, the distance between those objects in relation to each other without having to do calculations on the exact coordinates. This approach permits us to do fast and straightforward calculations to find the entities that are the closest to or farthest from a reference point.</p>
<p class="mce-root"/>
<p>In other words, we are sub-dividing a virtual space into a structure that's easier to analyze. An example of a universal structure that's easy to represent in memory (and that is often used to divide space into individual containers) is a fixed grid. In the following diagram, you can see a visual representation of this concept. The grid contains squares, which we will call <strong>cells</strong>. Those cells include <strong>units</strong>. Those units can be anythingâ€”a specific type of enemy character or hidden loot boxes spread out across a vast map:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/159db14d-2aec-488b-8a74-63cad602f3eb.png"/></p>
<p>Now, let's imagine that this grid is superimposed on the enormous open-world map of an RPG video game. Each cell (square) represents a virtual 2x2 km area. We know that our player character has spawned in a specific cell (square) on the map, but we want to offer him the option to quickly travel to an area that's filled with level-2 monsters that he can fight. By using a Spatial Partition, we can easily calculate for the nearest entities of a specific type in the memory without having to scan the entire three-dimensional environment.</p>
<p>The results of the calculations can suggest to us a nearby cell (square) that contains the largest grouping of enemies of level 2. With this information, we can move our player character into a random position inside of the suggested cell (square), so that he can loot the area. As you will see in the next sections, Spatial Partitioning simplifies the process of managing entities that reside in complex two-dimensional and three-dimensional spaces.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p class="mce-root">The drawbacks of this pattern are quite limited (and are non-existent in most cases) because it's so easy to use.</p>
<p class="mce-root">The benefits are as follows:</p>
<ul>
<li class="mce-root"><strong>Reusable</strong>: We can use the Spatial Partition pattern to optimize the way that we manage anything that's formed of entities spread out in two-dimensional or three-dimensional space (for example, user interfaces).</li>
<li class="mce-root"><strong>Simplification</strong>: A Spatial Partition makes it easier to implement code that calculates spatial relationships between objects. It's very beneficial for those that are not good with math.</li>
</ul>
<p>The drawbacks are as follows:</p>
<ul>
<li><strong>Not very dynamic</strong>: Spatial Partitioning can lose all of its optimization benefits if you are trying to manage entities that are continually moving in space over an extended area. So, if you have a scene that's full of objects bouncing around at full speed, you will need to continuously update the data structure that contains the collection of entities and their grid positions. In that case, this process can be resource-intensive and not worth the effort.</li>
</ul>
<p>The most important skill that a game programmer should acquire is mathematics. Being knowledgeable about design patterns is necessary to get into the industry, but it's not as important as a deep understanding of advanced mathematics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p class="mce-root">Imagine that we need to quickly prototype a straightforward mini game that simulates a non-player predator character hunting for prey on a map. The process of spawning the entities (prey and predator) in the environment is not complicated; actually, it is quite simple. However, how are we going to know if our predator is close to potential prey and move him toward it?</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Consider the following possible solutions:</p>
<ul>
<li class="mce-root">We could query every object in the scene and compare their coordinates with those of the predator.</li>
<li class="mce-root">We could implement a ray cast system that scans every object in the proximity of the predator, in order to spot potential prey.</li>
</ul>
<p class="mce-root">These solutions could potentially work, but they could be burdensome to implement in a short time. However, with the Spatial Partition pattern, we can avoid this lengthy process by making sure that all the entities in our scene get contained in a data structure that organizes the prey and predator by their relative positions. As you will see in our code example, writing this implementation is quite fast and useful, especially when you are in a rush and want to sketch out some basic AI navigation behaviors in code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>The following code example might look very rudimentary, but it can easily be expanded to implement more complex use cases. In a way, it's a foundation that we will be able to build on:</p>
<ol>
<li>Let's start by implementing the core element of our pattern, the <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using System.Linq;<br/>using UnityEngine;<br/><br/>public class Grid: MonoBehaviour<br/>{<br/>    private int m_SquareSize;<br/>    private int m_NumberOfSquares;<br/><br/>    public Grid(int squareSize, int numberOfSquares)<br/>    {<br/>        // The size can represent anything (meters, km)<br/>        m_SquareSize = squareSize;<br/><br/>        // Squares permits to subdivide the grid granulary<br/>        m_NumberOfSquares = numberOfSquares;<br/>    }<br/><br/>    public void AddToRandomnPosition(IUnit unit)<br/>    {<br/>        unit.AddToGrid(UnityEngine.Random.Range(0, m_NumberOfSquares));<br/>    }<br/><br/>    public int FindClosest(IUnit referenceUnit, IUnit[] list)<br/>    {<br/>        if (list != null)<br/>        {<br/>            // Using LINQ queries<br/>            var points = list.Select(a =&gt; a.GetGridPosition()).ToList();<br/>            var nearest = points.OrderBy(x =&gt; Math.Abs(x - referenceUnit.GetGridPosition())).First();<br/>            return nearest;<br/>        }<br/>        else<br/>        {<br/>            throw new ArgumentException("Parameters cannot be null", "list");<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The first thing that you should take note of is the <kbd>AddToRandomnPosition()</kbd> function, in which we are adding units to squares in the grid with a <kbd>Random.Range()</kbd> call. We are doing this for two reasons. We want to test our <kbd>Grid</kbd> implementation quickly, so we are simulating having the entities spread out in an environment at random positions. We also want to showcase how we canÂ use Spatial Partitioning in combination with a spawn system to manage the spawning of entities within a specific optimized grid space. In other words, we can partition the virtual space of our scene in the memory, even before initializing the things that will inhabit it.</p>
<p style="padding-left: 60px">Another function to analyze isÂ <kbd>FindClosest()</kbd>; note that we are using two LINQ queries. The first query extracts a list of grid positions from a list of units. With the second one, we are querying this list to find the nearest cell in relation to a reference unit. For those that have never worked with LINQ, it's a built-in C# query language that permits finding and extracting elements in a collection with a single line of code. It's an excellent tool to use when you need to prototype and quickly write implementations that use data structures and collections.<br/></p>
<ol start="2">
<li>Now, we need a way for our units to register themselves into a specific cell of the <kbd>Grid</kbd>. Let's start by implementing an interface to manage our unit types:</li>
</ol>
<pre style="padding-left: 60px">public interface IUnit<br/>{<br/>    // The Unit can add itself to the grid<br/>    void AddToGrid(int cell);<br/><br/>    // The Unit can return is current grid position<br/>    int GetGridPosition();<br/>}</pre>
<p style="padding-left: 60px">It's quite a straightforward interface; the <kbd>GetGridPosition()</kbd> function returns the grid position of a <kbd>Unit</kbd>. A question that might arise is, why are we not implementing a function that will return the actual location of a <kbd>Unit</kbd> in the scene? It's because, in Unity, if a GameObject has a <kbd>Transform</kbd> component attached to it, we can directly ask this component to return its position inside of aÂ three-dimensional scene. In other words, we are using Unity's API to do the heavy lifting for us.</p>
<ol start="3">
<li>We are going to implement two types of units for our code example; let's start with the <kbd>Prey</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Prey : MonoBehaviour, IUnit<br/>{<br/>    private int m_Square;<br/><br/>    public void AddToGrid(int square)<br/>    {<br/>        m_Square = square;<br/>    }<br/><br/>    public int GetGridPosition()<br/>    {<br/>        return m_Square;<br/>    }<br/>}</pre>
<ol start="4">
<li>Â Next up is our <kbd>Predator</kbd>Â class; he hunts our <kbd>Prey</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Predator : MonoBehaviour, IUnit<br/>{<br/>    private int m_Square;<br/><br/>    public void AddToGrid(int square)<br/>    {<br/>        m_Square = square;<br/>    }<br/><br/>    public int GetGridPosition()<br/>    {<br/>        return m_Square;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">We can see that both our <kbd>Predator</kbd> and <kbd>Prey</kbd> have two primary responsibilities, linking their positions into a specific cell of the grid and returning that cell number if requested.</p>
<ol start="5">
<li>Finally, our <kbd>Client</kbd> class, which we are using to spawn <kbd>Prey</kbd> on the <kbd>Grid</kbd> and unleash the <kbd>Predator</kbd> upon them, is as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.SpatialPartition<br/>{<br/>    public class Client : MonoBehaviour<br/>    {<br/>        private Grid m_Grid;<br/>        private IUnit[] m_Preys;<br/><br/>        void Start()<br/>        {<br/>            m_Grid = new Grid(4, 16);<br/>            Debug.Log("Grid generated");<br/>        }<br/><br/>        void Update()<br/>        {<br/>            if (Input.GetKeyDown(KeyCode.P))<br/>            {<br/>                IUnit prey;<br/>                int numberOfPrey = 5;<br/>                m_Preys = new IUnit[numberOfPrey];<br/><br/>                for (int i = 0; i &lt; numberOfPrey; i++)<br/>                {<br/>                    prey = new Prey();<br/>                    m_Grid.AddToRandomnPosition(prey);<br/>                    m_Preys[i] = prey;<br/><br/>                    Debug.Log("A prey was spawned @ square: " + m_Preys[i].GetGridPosition());<br/>                }<br/>            }<br/><br/>            if (Input.GetKeyDown(KeyCode.H))<br/>            {<br/>                IUnit predator;<br/>                predator = new Predator();<br/>                m_Grid.AddToRandomnPosition(predator);<br/>                Debug.Log("A predator was spawned @ square: " + predator.GetGridPosition());<br/><br/>                int closest = m_Grid.FindClosest(predator, m_Preys);<br/>                Debug.Log("The closest prey is @ square: " + closest);<br/>            }<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            GUI.color = Color.black;<br/>            GUI.Label(new Rect(10, 10, 500, 20), "Press P to spawn prey on the grid.");<br/>            GUI.Label(new Rect(10, 30, 500, 20), "Press H to hunt some prey.");<br/>            GUI.Label(new Rect(10, 50, 500, 20), "Open Debug Console to view the output.");<br/>        }<br/>    }<br/>}</pre>
<p>That's it; note that we never had to deal with the actual three-dimensional coordinates of objects to find their relative positions. We are avoiding a lot of unnecessary calculations by dividing the space into a grid and containing the objects within it. We are reducing the complexity by compartmentalizing it.</p>
<p>Of course, in our code example, we went with the easy route and avoided calculating the relative positions of our <kbd>Units</kbd> before adding them to a specific square in the <kbd>Grid</kbd>, but this can easily be added if need be. The most important takeaway is that we should always avoid doing complex calculations on the entities in a three-dimensional space if we can merely partition and manage them inside of a data structure that we can easily search and manipulate.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we took a simple approach to learning a pattern that offers a solution to a very complex problem, which is how to organize the objects in a space optimally. We now have a tool that we can use to build open-world games and a quick solution for prototyping a game in which grids are a central component (for example, a puzzle game).</p>
<p>In the final chapter of this book, we are going to review a subject that's the complete opposite of what we just explored: anti-patterns, the antithesis of design patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Practice</h1>
                
            
            
                
<p>In our code example, we implemented a straightforward use case of the Spatial Partition pattern. However, we limited ourselves to two-dimensional space; as a practical exercise, I would recommend expanding upon this basic example and organizing objects in a three-dimensionalÂ space. As inspiration, I would recommend observing the design of a Rubik's Cube. Note that it's composed of a collection of mini cubes; each can be considered a cell in a group.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Mathematics for 3D Game Programming and Computer Graphics</em><strong>Â </strong>by Eric Lengyel:Â <a href="https://www.mathfor3dgameprogramming.com/">https://www.mathfor3dgameprogramming.com</a><a href="https://www.mathfor3dgameprogramming.com/"/><a href="https://www.mathfor3dgameprogramming.com/"/></li>
</ul>


            

            
        
    </body></html>