<html><head></head><body>
<div><h1 class="chapterNumber">14</h1>
<h1 class="chapterTitle" id="_idParaDest-285">Implementing Microservices with .NET</h1>
<p class="normal">In <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, you learned the theory and basic concepts of microservices. In this chapter, you will learn how to put into practice those general concepts and tools to implement microservices in .NET. This way, you will have a practical understanding of how high-level architectural decisions translate into concrete .NET code.</p>
<p class="normal">The focus of this chapter is on worker microservices; that is, microservices that are not part of the public interface of your application. Other kinds of microservices will be focused on in other chapters. Worker microservices process jobs that are not connected to a specific user. They somehow prepare the data that will be used by frontend microservices to satisfy all user requests. They are the assembly line of each application, so their design priorities are efficiency in both communication and local processing, together with protocols that ensure data coherence and fault tolerance. </p>
<p class="normal">You will learn how to implement a frontend service in <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>, after having learned about techniques for implementing a presentation layer in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>. Other techniques for implementing presentation layers are described in<em class="italic"> Chapter 19, Client Frameworks: Blazor</em>, while techniques for implementing public APIs will be discussed in <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>.</p>
<p class="normal">This chapter explains the structure of a .NET microservice and discusses the options for exchanging messages and serializing .NET data structures. In particular, we will put into practice a lot of concepts analyzed in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, such as the concept of Generic Host, the techniques for ensuring reliable communication (exponential retry, etc.), forward communication, and idempotency of messages.</p>
<p class="normal">More specifically, in this chapter, you will learn about the following subjects:</p>
<ul>
<li class="bulletList">Communication and data serialization</li>
<li class="bulletList">Implementing worker microservices with ASP.NET Core</li>
<li class="bulletList">Implementing microservices with .NET worker services and message brokers</li>
</ul>
<p class="normal">Each point will be discussed in depth, and the reader can find further practical details in the section <em class="italic">A worker microservice with ASP</em> <em class="italic">.NET core </em>of <em class="italic">Chapter 21, Case Study</em>, which describes in detail three complete implementations of worker microservices.</p>
<p class="normal">The first section of the chapter discusses the main coordination and queuing problems that arise in microservices communication and how to solve them with either message brokers or custom permanent queues. These topics are fundamental in the design of efficient and fault-tolerant communication, which, in turn, are essential requirements for ensuring coherent behavior and low response times of the overall application.</p>
<p class="normal">The remaining sections include examples of how to implement the same microservice with two different techniques. The techniques in the second section are based on the ASP.NET Core implementation of gRPC and an SQL Server-based permanent queue. It is worth pointing out that this technique requires HTTP/2. The example in the third section shows how to use message brokers and two serialization techniques. </p>
<p class="normal">Message brokers are fundamental for three main reasons: </p>
<ul>
<li class="bulletList">They take care of most of the communication overhead.</li>
<li class="bulletList">They support the publisher/subscriber pattern, which promotes the independence of communicating microservices.</li>
<li class="bulletList">All main cloud providers offer message broker services. The <a id="_idIndexMarker976"/>example uses <strong class="keyWord">RabbitMQ</strong>, but RabbitMQ can be <a id="_idIndexMarker977"/>replaced by <strong class="keyWord">Azure Service Bus</strong>,<strong class="keyWord"> </strong>the message broker offered by Azure. The chapter also explains the pros and cons of different serialization techniques.</li>
</ul>
<h1 class="heading-1" id="_idParaDest-286">Technical requirements</h1>
<p class="normal">This chapter requires the free Visual Studio 2022 Community edition or better with all database tools installed. The code for this chapter is available at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>. </p>
<p class="normal">Experimenting with message brokers also requires the installation of the RabbitMQ message broker (version 3.9 or higher), which in turn requires the previous installation of a 64-bit version of Erlang. An adequate Erlang version for RabbitMQ 3.9 can be downloaded from <a href="https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe">https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe</a>. The RabbitMQ Windows installer can be downloaded from <a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe</a>. We recommend you launch both installations from an administrative account.</p>
<p class="normal">Three complete examples of worker microservices are in the <em class="italic">A worker microservice with ASP.NET core</em> and <em class="italic">A worker microservice based on RabbitMQ</em> sections of <em class="italic">Chapter 21, Case Study</em>. Each of them exemplifies a technique described in this chapter and shows an alternative way of collecting travel statistics in the case study application.</p>
<h1 class="heading-1" id="_idParaDest-287">Communication and data serialization</h1>
<p class="normal">As explained in the <em class="italic">Microservice design principles</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, requests to a microservices-based application can’t cause long chains of recursive microservices calls. </p>
<p class="normal">In fact, each call adds both a <a id="_idIndexMarker978"/>wait time and a communication time to the actual processing time, thus leading to unacceptable levels of overall response time, as shown in the following figure.</p>
<figure class="mediaobject"><img alt="Shape, circle  Description automatically generated" src="img/B19820_14_01.png"/></figure>
<p class="packt_figref">Figure 14.1: Tree of blocking RPC calls</p>
<p class="normal">Messages <strong class="keyWord">1-6</strong> are triggered by a request to the <strong class="keyWord">A</strong> microservice and are sent in sequence, so their processing times sum up to the response time. Moreover, once sent, message <strong class="keyWord">1</strong> from microservice <strong class="keyWord">A</strong> remains blocked until it receives the last message (<strong class="keyWord">6</strong>); that is, it remains blocked for the whole lifetime of the overall recursive communication process.</p>
<p class="normal">Microservice <strong class="keyWord">B</strong> remains<a id="_idIndexMarker979"/> blocked twice, waiting for an answer to a request it issued. The first time is during the <strong class="keyWord">2-3</strong> communication and then the second is during the <strong class="keyWord">4-5</strong> communication. To sum<a id="_idIndexMarker980"/> up, <strong class="keyWord">Remote Procedure Calls</strong> (<strong class="keyWord">RPCs</strong>) involve high response times and a waste of microservices computation time.</p>
<p class="normal">That’s why microservices avoid blocking recursive RPCs and prefer a data-driven approach that starts from the leaves of the procedure calls tree. Put simply, tree nodes, instead of waiting for requests from their parent nodes, send pre-processed data to all their possible callers each time their private data changes, as shown in the following figure.</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_14_02.png"/></figure>
<p class="packt_figref">Figure 14.2: Data-driven asynchronous communication</p>
<p class="normal">Both communications labeled <strong class="keyWord">1</strong> are triggered when the data of the <strong class="keyWord">C</strong>/<strong class="keyWord">D</strong> microservices changes, and they may occur in parallel. Moreover, once a communication is sent, each microservice can return to its job without waiting for a response. Finally, when a request arrives at microservice <strong class="keyWord">A</strong>, <strong class="keyWord">A</strong> already has all the data it needs to build the response with no need to interact with other microservices.</p>
<p class="normal">In general, microservices <a id="_idIndexMarker981"/>based on the data-driven approach pre-process data and send it to whichever other service might be interested. This way, each microservice already contains pre-computed data it can use to respond immediately to user requests with no need for further request-specific communications.</p>
<p class="normal">More specifically, as new data becomes available, each microservice does its job and then sends the results to all interested microservices with asynchronous communications; that is, a microservice doesn’t wait for any acknowledgment from its recipients. Asynchronous communication is a must since each communication act usually triggers other communication acts recursively for the recipient, so we can’t block the whole tree of microservices until the final acknowledgment arrives from all the tree leaves, as in the case of RPC.</p>
<p class="normal">However, while being the only acceptable option for high-traffic microservices, the data-driven approach is more difficult to implement. In particular, the absence of acknowledgments creates complex coordination problems that increase the application development and testing time. We will discuss how to face coordination problems later on in the chapter.</p>
<p class="normal">Here it is just worth stating the following rule of thumb.</p>
<div><p class="normal">Use the data-driven approach for all high-traffic worker microservices, but for services with shorter request-response cycles and experiencing low to moderate amounts of requests, use utilizing RPC (Remote Procedure Call).</p>
</div>
<p class="normal">Therefore, actual applications mix efficient short-path RPC calls with the data-driven approach.</p>
<p class="normal">Another point that is worth mentioning is communication security. When security is needed, and communication relies on an underlying TCP/IP connection, we can simply use TLS/SSL (the same protocol used by HTTPS connections). However, in this case, since we are speaking of communications among servers, so there is no actual client, it is common that both communicating microservices authenticate each other with private key certificates, and then agree on a cryptographic protocol and key to secure their TLS/SS communication. .NET furnishes all tools for negotiating a TLS/SSL connection based on reciprocal authentication based on servers.</p>
<div><p class="normal">However, when all microservices are part of the same private network, it is common to secure just the communication in/out of this private network and not secure all the intranet communications, both to simplify the design of the overall communication strategy and to save the performance cost of encryption.</p>
</div>
<p class="normal">Another<a id="_idIndexMarker982"/> typical optimization of inter-application communications is the usage of binary serialization, which produces shorter messages and requires less bandwidth and less processing time. In fact, for instance, representing an integer within an object with a binary serialization costs about 4 bytes, that is, basically the same number of bytes needed to store it in the computer memory (there is a small overhead, for protocol-handling metadata), while representing the same integer as a text requires a byte for each digit, plus the bytes needed for the field name.</p>
<p class="normal">Binary serialization is discussed in detail in the next subsection. Then, also, RPC- and data-driven asynchronous communication will be analyzed in dedicated subsections.</p>
<h2 class="heading-2" id="_idParaDest-288">Efficient and flexible binary serialization</h2>
<p class="normal">Serialization<a id="_idIndexMarker983"/> is the process of transforming data in a way that they can be sent on a communication channel, or stored <a id="_idIndexMarker984"/>in a file. Therefore, the way data are serialized has a strong impact on the quantity of data that will be sent.</p>
<p class="normal">The .NET echo system contains several fast, platform-specific binary serializers, which are able to produce compact, short messages with very low computational costs. In the <em class="italic">Implementing microservices with .NET worker services and message brokers</em> section, we will test one of the fastest, the <em class="italic">Binaron</em> package.</p>
<p class="normal">Unfortunately, efficient binary serializers suffer from a couple of well-known problems:</p>
<ul>
<li class="bulletList">Since the most performant binary serializers are tied to a specific platform, they are not interoperable. Thus, for instance, the Java binary format is not compatible with the .NET binary format. This constraint creates problems when your application microservices are heterogeneous and use different technologies.</li>
<li class="bulletList">If one uses the same platform-specific, in-memory binary format, adding/removing properties to/from an object breaks compatibility. Thus, a microservice that uses an old version of a class is not able to de-serialize data created with a newer version of the same class. This constraint creates dependencies between the microservices’ CI/CD cycles because when a microservice changes to meet new requirements, it causes recursive changes in all other microservices that communicate with it.</li>
</ul>
<p class="normal">In <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>, we will see that the JSON format was widely<a id="_idIndexMarker985"/> adopted because it avoids these two problems since it is not tied to any <a id="_idIndexMarker986"/>specific language/runtime, and added properties can simply be ignored, while removed properties are handled by assigning default values.</p>
<p class="normal">The <strong class="keyWord">ProtoBuf</strong> binary format <a id="_idIndexMarker987"/>was conceived to ensure the same JSON serialization/deserialization advantages for binary formats.</p>
<p class="normal">ProtoBuf achieves interoperability by defining abstract elementary types and their binary representations. Then, each framework takes care of converting its native types to/from them. Elementary types are combined into complex structures called <strong class="keyWord">messages</strong>, which represent classes.</p>
<p class="normal">Compatibility between different versions of the same message is ensured by assigning a unique integer number to each property. This way, when a message is de-serialized into an object, just the integers that mark the property of the given message version are searched in the serialized data and de-serialized. When a property number is not found in the serialized data, the default value is taken for the associate property. This way, ProtoBuf messages have the same serialization/deserialization advantages as JSON objects. In a few words compatibility among different versions is ensured if the developer doesn’t change the number associated with each property. The developer can also remove properties, but without assigning their numbers to new properties, because these numbers have the purpose of naming (with very short names) all fields. The receiver uses these integer names to restore the messages.</p>
<p class="normal">There are also other serialization proposals similar to ProtoBuf. Some of them also ensure better performance, but at the moment, ProtoBuf, which was created by Google, is the de facto standard for interoperable binary communication.</p>
<p class="normal">ProtoBuf messages are defined in <code class="inlineCode">.proto</code> files and are then compiled into code in the target language by language-specific tools. The section that follows describes the ProtoBuf data description language.</p>
<h2 class="heading-2" id="_idParaDest-289">The ProtoBuf language</h2>
<p class="normal">Each <code class="inlineCode">.proto</code> file starts with a declaration of the version of ProtoBuf. At the moment, the highest available<a id="_idIndexMarker988"/> version is <code class="inlineCode">proto3</code>:</p>
<pre class="programlisting code"><code class="hljs-code">syntax = "proto3";
</code></pre>
<p class="normal">Since .NET SDK will <a id="_idIndexMarker989"/>generate classes out of ProtoBuf definitions, then, if the target language is .NET, you can specify the namespace where you generate all the .NET classes corresponding to the ProtoBuf types defined in the file:</p>
<pre class="programlisting code"><code class="hljs-code">option csharp_namespace = "FakeSource";
</code></pre>
<p class="normal">Then, you can import definitions contained in other <code class="inlineCode">.proto</code> files, with one or more <code class="inlineCode">import</code> declarations:</p>
<pre class="programlisting code"><code class="hljs-code">import "google/protobuf/timestamp.proto";
</code></pre>
<p class="normal">The above definition imports the definition of the <code class="inlineCode">TimeStamp</code> type, which encodes both the <code class="inlineCode">DateTime</code> and <code class="inlineCode">DateTimeOffset</code> .NET types. <code class="inlineCode">TimeStamp</code> is not a ProtoBuf simple type but is defined in a standard ProtoBuf types library.</p>
<p class="normal">Finally, we can scope all message definitions to a <code class="inlineCode">package</code> to avoid name collisions. ProtoBuf packages have the same role as a .NET namespace but are not automatically converted into .NET namespaces during .NET code generation, since .NET namespaces are specified with the <code class="inlineCode">option C#</code> declaration:</p>
<pre class="programlisting code"><code class="hljs-code">package purchase;
</code></pre>
<p class="normal">Each <code class="inlineCode">.proto</code> file can contain several message definitions. Here is an example message:</p>
<pre class="programlisting code"><code class="hljs-code">message PurchaseMessage {
  string id = 1;
  google.protobuf.Timestamp time = 2;
  string location = 3;
  int32 cost =4;
  google.protobuf.Timestamp purchaseTime = 5;
}
</code></pre>
<p class="normal">Each property is specified by the property type followed by the property name, and then by the unique integer associated with that property. Property names must be in camel case, but they are converted to Pascal case during .NET code generation.</p>
<p class="normal">If a new <a id="_idIndexMarker990"/>version of <code class="inlineCode">PurchaseMessage</code> is created, compatibility with the past version can be maintained by not reusing the integers assigned to the properties of the old version, and by removing just unused properties, as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">message PurchaseMessage {
  string id = 1;
  int32 cost =4;
  google.protobuf.Timestamp purchaseTime = 5;
  Reseller reseller = 7;
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker991"/>new version of <code class="inlineCode">PurchaseMessage</code> doesn’t contain properties <code class="inlineCode">2</code> and <code class="inlineCode">3</code>, but it contains the new <code class="inlineCode">reseller</code> property, marked with the new <code class="inlineCode">7</code> integer. The <code class="inlineCode">Reseller</code> type is defined by another message that can be contained either in the same <code class="inlineCode">.proto</code> file or an imported file.</p>
<p class="normal">Clearly, compatibility is maintained just with clients that don’t use the removed properties, while clients directly affected by the changes must be updated.</p>
<p class="normal">Collections are represented by prefixing the name of the collection element type with the <code class="inlineCode">repeated</code> keyword:</p>
<pre class="programlisting code"><code class="hljs-code">message PurchaseMessage {
  ...
  repeated Product products = 3;
  ...
}
</code></pre>
<p class="normal">Repeated data are translated into the <code class="inlineCode">Google.Protobuf.Collections.RepeatedField&lt;T&gt;</code> .NET type, which implements <code class="inlineCode">IList&lt;T&gt;</code>.</p>
<p class="normal">Dictionaries are represented with the <code class="inlineCode">map&lt;T1, T2&gt;</code> type:</p>
<pre class="programlisting code"><code class="hljs-code">message PurchaseMessage {
  ...
  map&lt;string, int&gt; attributes = 3;
  ...
}
</code></pre>
<p class="normal">Messages can<a id="_idIndexMarker992"/> be nested in other messages, in which case they generate classes defined in other .NET classes during code generation:</p>
<pre class="programlisting code"><code class="hljs-code">message PurchaseMessage {
  message Product {
    int32 id = 1;
    string name = 2;
    uint32 cost = 3;
    uint32 quantity = 4;
  }
  ...
  repeated Product products = 3;
  ...
}
</code></pre>
<p class="normal">We can<a id="_idIndexMarker993"/> also define <code class="inlineCode">enum</code> types that translate directly to .NET <code class="inlineCode">enum</code> types:</p>
<pre class="programlisting code"><code class="hljs-code">enum ColorType {
    RED = 0;
    GREEN = 1;
    ...
  }
</code></pre>
<p class="normal">It is also possible to define messages with conditional content. This is useful for sending either a response or error information:</p>
<pre class="programlisting code"><code class="hljs-code">message Payload {
    ...
}
message Error {
    ...
}
message ResponseMessage {
  one of result {
    Error error = 1;
    Person payload = 2;
  }
}
</code></pre>
<p class="normal">Once a microservice receives a .NET object of the <code class="inlineCode">ResponseMessage</code> type, it can process it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">ResponseMessage  response = ...;
switch (response.ResultCase)
{
    case ResponseMessage.ResultOneofCase.Payload:
        HandlePayload(response. Payload);
        break;
    case ResponseMessage.ResultOneofCase.Error:
        HandleError(response.Error);
        break;
    default:
        throw new ArgumentException();
}
</code></pre>
<p class="normal">The<a id="_idIndexMarker994"/> table below summarizes <a id="_idIndexMarker995"/>all the ProtoBuf simple types and their equivalent .NET types:</p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">.NET types</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Protobuf types</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">double</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">double</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">float</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">float</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">string</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">string</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bool</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bool</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ByteString</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bytes</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int32, sint32, sfixed32</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uint</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uint32, fixed32</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int64, sint64, sfixed64</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ulong</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uint64, fixed64</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 14.1: Mapping Protobuf Simple Types to .NET Equivalents</p>
<p class="normal">The <code class="inlineCode">ByteString</code> .NET type is defined in the <code class="inlineCode">Google.Protobuf</code> namespace contained in the <code class="inlineCode">Google.Protobuf</code> NuGet package. It can be converted to <code class="inlineCode">byte[]</code> with its <code class="inlineCode">.ToByteArray()</code> method. A <code class="inlineCode">byte[]</code> object can be converted into a <code class="inlineCode">ByteString</code> with the <code class="inlineCode">ByteString.CopyFrom(byte[] data)</code> static method.</p>
<p class="normal"><code class="inlineCode">int32</code>, <code class="inlineCode">sint32</code>, and <code class="inlineCode">sfixed32</code> encode .NET <code class="inlineCode">int</code>. Now, <code class="inlineCode">sint32</code> is convenient when the integer is more<a id="_idIndexMarker996"/> likely to be negative, while the <code class="inlineCode">sfixed32</code> type is convenient when the integer is likely to contain more than 28 bits. Similar considerations apply to <code class="inlineCode">uint32</code> and <code class="inlineCode">fixed32</code>.</p>
<p class="normal">The same criteria apply to 64-bit integers, but in this case, the threshold for the convenience of <code class="inlineCode">sfixed64</code> and <code class="inlineCode">fixed64</code> is 56 bits.</p>
<p class="normal">ProtoBuf <a id="_idIndexMarker997"/>simple types are not nullable. This means that they can’t have a null value, and if no value is assigned to them, they take a default value. The default value of a <code class="inlineCode">string</code> is an empty <code class="inlineCode">string</code>, while the default value of a <code class="inlineCode">ByteString</code> is an empty <code class="inlineCode">ByteString</code>.</p>
<p class="normal">If you need nullable types, you must include a predefined <code class="inlineCode">.proto</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">import "google/protobuf/wrappers.proto"
</code></pre>
<p class="normal">Here is a table that details the correspondence between .NET nullable simple types and ProtoBuf nullable wrappers:</p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">.NET types</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">ProtoBuf types</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">double?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.DoubleValue</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">float?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.FloatValue</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">string?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.StringValue</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bool?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.BoolValue</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ByteString?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.BytesValue</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">int?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.Int32Value</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">uint?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.UInt32Value</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">long?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.Int64Value</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ulong?</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">google.protobuf.UInt64Value</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 14.2</p>
<p class="normal"><code class="inlineCode">DateTime</code>, <code class="inlineCode">DateTimeOffset</code>, and <code class="inlineCode">TimeSpan</code> have no direct equivalent in ProtoBuf, but the <code class="inlineCode">Google.Protobuf.WellKnownTypes</code> namespace contained in the <code class="inlineCode">Google.Protobuf</code> NuGet package contains the <code class="inlineCode">Timestamp</code> type, which maps from/to <code class="inlineCode">DateTime</code> and <code class="inlineCode">DateTimeOffset</code>, and the <code class="inlineCode">Duration</code> type, which maps from/to <code class="inlineCode">TimeSpan</code>. The mapping is completely <a id="_idIndexMarker998"/>analogous to that of <code class="inlineCode">ByteString</code>. Thus, for instance, a <code class="inlineCode">Duration</code> is obtained from a <code class="inlineCode">TimeSpan</code> with the <code class="inlineCode">Duration.FromTimeSpan</code> static method, while a <code class="inlineCode">Duration</code> is transformed into a <code class="inlineCode">TimeSpan</code> by calling its <code class="inlineCode">.ToTimeSpan</code> instance method.</p>
<p class="normal">The <a id="_idIndexMarker999"/>usage of <code class="inlineCode">Duration</code> and <code class="inlineCode">Timestamp</code> in <code class="inlineCode">.proto</code> files is shown in the following:</p>
<pre class="programlisting code"><code class="hljs-code">syntax = "proto3"
import "google/protobuf/duration.proto"; 
import "google/protobuf/timestamp.proto";
message PurchaseMessage {
  string id = 1;
  google.protobuf.Timestamp time = 2;
  string location = 3;
  int32 cost =4;
  google.protobuf.Timestamp purchaseTime = 5;
  google.protobuf.Duration travelDuration = 6;
}
</code></pre>
<p class="normal">Please notice that usage needs the import of predefined <code class="inlineCode">.proto</code> files.</p>
<p class="normal">At the moment, there is no equivalent to the .NET <code class="inlineCode">decimal</code> type, but it will probably be introduced in the next version. However, you can encode decimals with two integers, one for the integer part and the other for the decimal part, with a message like the one in the following:</p>
<pre class="programlisting code"><code class="hljs-code">message ProtoDecimal {
// Whole units part of the decimal
    int64 units = 1;
    // Nano units of the decimal (10^-9)
// Must be same sign as units
    sfixed32 nanos = 2;
}
</code></pre>
<p class="normal">We can add implicit conversion to the .NET <code class="inlineCode">decimal</code>, with a partial class that combines with another <a id="_idIndexMarker1000"/>partial class, which is automatically generated from the <code class="inlineCode">.proto</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">public partial class DecimalValue
{
    private const decimal nanoFactor = 1000000000m;
   
    public static implicit operator decimal(ProtoDecimal pDecimal)
    {
        return pDecimal.Units + pDecimal.Nanos / nanoFactor;
    }
    public static implicit operator ProtoDecimal (decimal value)
    {
        return new ProtoDecimal
          {
             Units = decimal.ToInt32(value),
             Nanos= decimal.ToInt32((value - Units) * nanoFactor),
          };
    }
}
</code></pre>
<p class="normal">We have <a id="_idIndexMarker1001"/>described almost completely the ProtoBuf data description language. The only missing subject is the representation of variable/unknown types, which are rarely used. However, the <em class="italic">Further reading</em> section contains a link to the official documentation. The next section explains how to serialize and de-serialize messages.</p>
<h2 class="heading-2" id="_idParaDest-290">ProtoBuf serialization</h2>
<p class="normal">An <a id="_idIndexMarker1002"/>object tree can be<a id="_idIndexMarker1003"/> serialized as shown in the following:</p>
<pre class="programlisting code"><code class="hljs-code">using Google.Protobuf;
...
PurchaseMessage purchase = ....
byte[]? body = null;
using (var stream = new MemoryStream())
{
    purchase.WriteTo(stream);
    stream.Flush();
    body = stream.ToArray();
}
</code></pre>
<p class="normal">The <code class="inlineCode">WriteTo</code> method<a id="_idIndexMarker1004"/> needs a stream so create an in-memory stream. After, we create a byte array from the stream with <code class="inlineCode">ToArray</code>, which ensures that the stream buffer is actually written into the stream before attempting the extraction of the byte array:</p>
<pre class="programlisting code"><code class="hljs-code">Byte[] body = ...
PurchaseMessage? message = null;
using (var stream = new MemoryStream(body))
{
    message = PurchaseMessage.Parser.ParseFrom(stream);
}
</code></pre>
<p class="normal">Here, since <code class="inlineCode">ParseFrom</code> also needs a stream, we generate a stream from the message bytes.</p>
<p class="normal">The next subsection<a id="_idIndexMarker1005"/> describes the usage of RPC in microservices.</p>
<h2 class="heading-2" id="_idParaDest-291">Efficient and flexible RPC</h2>
<p class="normal">The RPC approach <a id="_idIndexMarker1006"/>can be adopted in <a id="_idIndexMarker1007"/>some application microservices with good results if the following conditions are met:</p>
<ul>
<li class="bulletList">The chain of recursive calls is very short, usually just one call without recursive calls.</li>
<li class="bulletList">Low communication latency and high channel bandwidth. This condition is met by intranet communications that take place on high-speed Ethernet within the same data center.</li>
<li class="bulletList">Data is serialized quickly and in a very size-efficient format. This condition is met by any efficient binary serializer.</li>
</ul>
<p class="normal">Long chains of recursive calls are avoided whenever RPC is used just to queue a request and to receive confirmation that the request has been correctly queued, without waiting for any processing result. In this case, RPC is used to simulate an asynchronous communication with reception confirmation. If this is the case, all of these conditions are easily met whenever all communicating microservices are part of the same <strong class="keyWord">local area network</strong> (<strong class="keyWord">LAN</strong>) where all computers are connected with high-speed physical connections.</p>
<p class="normal">On the contrary, when <a id="_idIndexMarker1008"/>the communicating microservices are geographically distributed and are part of a WAN instead of a LAN, waiting for confirmation of the reception of an RPC message might be unacceptable for high-traffic microservices. In this case, it is better to rely on message brokers that support completely asynchronous communications.</p>
<p class="normal">The <a id="_idIndexMarker1009"/>gRPC protocol brings all the advantages of ProtoBuf to RPC since, by default, it is based on ProtoBuf. gRPC/ProtoBuf is a binary protocol that works over an HTTP/2 connection. It is worth pointing out that gRPC can’t work with HTTP versions less than 2. In the remainder of the chapter, we will always assume that gRPC uses ProtoBuf.</p>
<p class="normal">gRPC uses <code class="inlineCode">.proto</code> files, but <a id="_idIndexMarker1010"/>together with data, gRPC <code class="inlineCode">.proto</code> files also define services with their RPC methods. Here is a service definition:</p>
<pre class="programlisting code"><code class="hljs-code">service Counter {
  // Accepts a counting request
rpc Count (CountingRequest) returns (CountingReply);
 //Get current count for a given time slot
rpc GetCount (TimeSlotRequest) returns (TimeSlotDataReply);
}
</code></pre>
<p class="normal">Each service is introduced by the <code class="inlineCode">service</code> keyword, while each method is introduced by the <code class="inlineCode">rpc</code> keyword. Each service specifies an input message and an output message. If either of these two messages is empty, we can use the predefined <code class="inlineCode">google.protobuf.Empty</code> message, as shown in the following:</p>
<pre class="programlisting code"><code class="hljs-code">...
import "google/protobuf/empty.proto";
...
service Counter {
  ...
  rpc AllSlots(google.protobuf.Empty) return (AllDataReply);
}
</code></pre>
<p class="normal"><code class="inlineCode">.proto</code> files can be used to generate both server code and client code. In client code, each service is translated into a proxy class with the same methods declared in the service. Each of the proxy methods automatically invokes the remote service method and returns its result.</p>
<p class="normal">The server code, instead, translates each service into an abstract class, whose virtual methods correspond to methods declared in the service. The developer is responsible for inheriting from this abstract class and providing implementations for all service methods.</p>
<p class="normal">Below is an example of how to inherit from a similar class:</p>
<pre class="programlisting code"><code class="hljs-code">public class CounterService: Counter.CounterBase
{
    ...
    public override async  Task&lt;CountingReply&gt; Count(
          CountingRequest request, ServerCallContext context)
    {
        CountingReply reply =...
          return reply;
    }
}
</code></pre>
<p class="normal">Each method<a id="_idIndexMarker1011"/> receives both the input message and a context object. Since gRPC services use ASP.NET Core infrastructure, the context object furnishes access to the request <code class="inlineCode">HttpContext</code> through <code class="inlineCode">context.GetHttpContext()</code>.</p>
<p class="normal">An ASP.NET Core application is enabled to gRPC with <code class="inlineCode">builder.Services.AddGrpc()</code> and by declaring each service with something like <code class="inlineCode">app.MapGrpcService&lt;CounterService&gt;();</code>.</p>
<p class="normal">More <a id="_idIndexMarker1012"/>details on both gRPC servers and clients will be given while discussing the example in the <em class="italic">A worker microservice with ASP.NET core</em> section of <em class="italic">Chapter 21, Case Study</em>.</p>
<p class="normal">Services can receive as input and return continuous streams of data, where a long-term connection between the client and server is established. However, the usage of streams in microservices is not common since microservices are ephemeral processes that are frequently shut down and moved from one processing node to another by orchestrators, so long-term connections are not easy to maintain.</p>
<p class="normal">Here is a service that accepts and returns a stream:</p>
<pre class="programlisting code"><code class="hljs-code">service StreamExample {
  rpc Echo (stream MyMessage) returns (stream MyMessage);
}
</code></pre>
<p class="normal">Each input stream is passed as an argument to the .NET implementation of the method. If the method returns<a id="_idIndexMarker1013"/> a stream, the .NET implementation of the method must return a <code class="inlineCode">Task</code>, and also the output stream is passed as an argument to the method:</p>
<pre class="programlisting code"><code class="hljs-code">public override async Task Echo(
     IAsyncStreamReader&lt;MyMessage&gt; requestStream
      IServerStreamWriter&lt;MyMessage&gt; responseStream,
      ServerCallContext context){
     ...
          While(...)
          {
             bool inputFinished =  !await requestStream.MoveNext();
             var current = requestStream.Current;
             ...
             await responseStream.WriteAsync(result);
          }
}
</code></pre>
<p class="normal">On the <a id="_idIndexMarker1014"/>client side, both input and output streams are available in the <code class="inlineCode">call</code> object that is returned when the proxy method is called without awaiting it, as shown in the following:</p>
<pre class="programlisting code"><code class="hljs-code">var call = client.Echo();
...
await call.RequestStream.WriteAsync(...);
...
bool inputFinished =  ! await call.ResponseStream.MoveNext();
var current = call.ResponseS.Current;
...
call.RequestStream.CompleteAsync();
</code></pre>
<p class="normal">The <code class="inlineCode">CompleteAsync()</code> method closes the request stream, declaring that the input is finished.</p>
<p class="normal">More practical details on the client usage are given in the example in the <em class="italic">A worker microservice with ASP.NET core</em> section of <em class="italic">Chapter 21, Case Study</em>, while the <em class="italic">Further reading</em> section contains a link to the .NET gRPC official documentation.</p>
<p class="normal">The next subsection describes how to implement data-driven asynchronous communication.</p>
<h2 class="heading-2" id="_idParaDest-292">Reliable data-driven asynchronous communication</h2>
<p class="normal">Non-blocking <a id="_idIndexMarker1015"/>communication must necessarily rely on non-volatile queues to decouple the sender thread from the receiving thread. Decoupling can be achieved with just one queue on each communication path, but sometimes additional queues improve <a id="_idIndexMarker1016"/>performance and increase CPU usage. Queues, can be placed in three places: within the microservice that sends the message, within the microservice that receives the message, or outside both microservices using dedicated services known as message brokers. by using dedicated queuing services <a id="_idIndexMarker1017"/>called <strong class="keyWord">message brokers</strong>.</p>
<p class="normal"><strong class="keyWord">Azure Service Bus</strong>, which<a id="_idIndexMarker1018"/> we described in the <em class="italic">.NET communication facilities</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, is a message broker that, like most message brokers, offers queuing services and publisher/subscriber communication. In this chapter, we will also describe <strong class="keyWord">RabbitMQ</strong>, which <a id="_idIndexMarker1019"/>offers queuing services and publisher/subscriber communication that is broadly similar to <strong class="keyWord">Azure Service Bus</strong> <strong class="keyWord">topics</strong>. Since it is easier to debug code that uses a local instance of RabbitMQ, often it is convenient to use RabbitMQ during development and then move to Azure Service Bus.</p>
<p class="normal">Queues <a id="_idIndexMarker1020"/>decouple the sender and receiver but do not ensure that messages are not lost. In the <em class="italic">Resilient task execution</em> section of <em class="italic">Chapter 11,</em> we have already discussed strategies for achieving reliable communication. Here we give more practical details for preventing message losses with confirmations and timeouts:</p>
<ul>
<li class="bulletList">Queues must be stored on permanent storage; otherwise, their content can be lost if the processes controlling them either crash or are shut down.</li>
<li class="bulletList">If a confirmation that the message was successfully inserted in the queue doesn’t arrive within a timeout time, the source assumes that the message was lost and retries the operation.</li>
<li class="bulletList">When a message is extracted from a queue, it remains blocked and inaccessible to other consumers. If a confirmation that the message has been successfully processed arrives within a timeout time, the message is removed from the queue; otherwise, it is unblocked and becomes available again to other consumers.</li>
</ul>
<p class="normal">All confirmations <a id="_idIndexMarker1021"/>can be handled asynchronously with the exception of the insertion in the first queue of a communication path. In fact, if the sending code doesn’t remain blocked waiting for the confirmation but moves to further processing and the message is lost, there is no way to resend the message, since the message cannot be taken from any other queue.</p>
<p class="normal">For this reason, sometimes microservices that use a message broker also have an internal queue. More specifically, the main microservice thread produces all messages and stores them in a local queue that can be implemented with a database table. Another thread takes care of extracting messages from this queue and sending them to the message broker. </p>
<p class="normal">Messages that are removed from the local queue are blocked and removed only when an asynchronous confirmation arrives from the message broker. This technique is used in the example of <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>. The main advantage of the local queue is that confirmation from a local queue usually arrives faster because there is less concurrency with other threads/processes (don’t forget that each microservice should have a private database/permanent storage), so the blocking time is more acceptable.</p>
<p class="normal">Using a <a id="_idIndexMarker1022"/>queue inside each receiver is a viable alternative to message brokers. The main advantage of private queues is that the process that handles the queue is not shared among several microservices, so all queue operations are faster. In particular, the confirmation of each insertion is immediate, so the sender can use a blocking RPC call to send the message. However, this simple solution has the following disadvantages:</p>
<ul>
<li class="bulletList">There is no way to implement the publisher/subscriber pattern.</li>
<li class="bulletList">Just one microservice instance can extract messages from the queue. Therefore, microservices can’t be scaled horizontally. Limited vertical scaling can be achieved by increasing the number of processor cores and by processing queue messages with parallel threads.</li>
</ul>
<p class="normal">A similar approach can be efficiently implemented with gRPC and ASP.NET Core as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The sender sends the message to a gRPC method.</li>
<li class="numberedList">The gRPC method just enqueues the message and immediately returns a confirmation to the sender.</li>
<li class="numberedList">An ASP.NET Core hosted process takes care of extracting the messages from the queue and passing them to several parallel threads.</li>
<li class="numberedList">When a message is passed to a thread, it remains blocked and inaccessible. It is removed only after the thread confirms that the message has been successfully processed. If, instead, a thread reports a failure, the corresponding message is unblocked so it can be passed to another thread.</li>
</ol>
<p class="normal">ASP.NET Core threads<a id="_idIndexMarker1023"/> take care of the necessary input parallelism. Some horizontal parallelism can be achieved by using load balancers and several web servers. However, in this case, either all the web servers use the same database, thus increasing the concurrency on the queue, or we use several sharded databases.</p>
<p class="normal">This approach is described in more detail in the example in the <em class="italic">Implementing worker microservices with ASP.NET core </em>section. As we will see, it is simple to implement and ensures good response time, but due to its limited scalability, it is adequate just for small or medium-sized applications with low to medium traffic.</p>
<p class="normal">If, for <a id="_idIndexMarker1024"/>some reason, either an insertion in a queue or the processing of a message extracted by a queue requires more time than the timeout time, the operation is repeated so that the same message is processed twice. Therefore, messages must be idempotent, meaning processing them once or several times must have the same effect. Record updates and deletions are intrinsically idempotent since repeating an update or a deletion several times doesn’t change the result, but record additions are not.</p>
<p class="normal">Idempotency can always be forced by assigning a unique identifier to messages and then storing the identifiers of the already processed messages. This way, each incoming message can be discarded when its identifier is found among the identifiers of the already processed messages. We will use this technique in all examples in this chapter.</p>
<p class="normal">Queues, confirmations, and message resends ensure that requests to a single microservice are safely processed, but how can we handle requests that involve several cooperating microservices? We will discover that in the next subsection. There, we will explain how distributed microservices can coordinate and reach agreements to yield coherent behavior with only the help of asynchronous communication.</p>
<h2 class="heading-2" id="_idParaDest-293">Distributed transactions</h2>
<p class="normal">Everyone knows<a id="_idIndexMarker1025"/> what a database transaction is: several records are modified one after the other, but if a single action fails, all previous modifications are also undone before aborting the transaction. That is, either all operations succeed or they fail simultaneously.</p>
<p class="normal">A distributed transaction<a id="_idIndexMarker1026"/> does the same job, but in this case, the records are not part of a single database but are distributed among the databases associated with several cooperating microservices.</p>
<p class="normal">The reliable data-driven communication techniques described so far are the building blocks for solving more complex cooperation problems.</p>
<p class="normal">Let’s suppose that a user operation triggers processing and storage in several related microservices. The user operation can be considered successfully completed only if all involved processing/storage operations succeed.</p>
<p class="normal">Moreover, if a single processing/storage operation also fails for some fundamental reason, retrying the failed operation doesn’t help. Think, for instance, of a purchase that fails because the user has not got enough funds to complete the payment: the only way out is to undo all the operations that have already been performed.</p>
<p class="normal">In general, similar situations must be handled in a transactional way; either all operations are performed, or no operation is performed. Transactions that span several microservices are known as <strong class="keyWord">distributed transactions</strong>. In theory, <strong class="keyWord">distributed transactions</strong> can be handled with the following two-stage protocol:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the first stage, all operations are executed, each one in the scope of a local transaction (for instance, within the scope of each microservice database transaction). The success or failure of each operation is then returned to a transaction coordinator.</li>
<li class="numberedList">In the second stage, the transaction coordinator informs all microservices of the success or failure of the overall operation. In the case of failure, all local transactions are rolled back; otherwise, they are committed.</li>
</ol>
<p class="normal">When<a id="_idIndexMarker1027"/> using asynchronous messages, confirmations may arrive after quite a large amount of time and may interleave with other transactions performed on the same resources. Therefore, having all local resources blocked by a local transaction during a possibly time-consuming distributed transaction is not acceptable.</p>
<p class="normal">For this reason, microservices transactions use the <strong class="keyWord">saga</strong> pattern: all local operations are performed without opening a local transaction, and in the case of failure, they are compensated by other operations that undo the initial operations.</p>
<p class="normal">Undoing a <a id="_idIndexMarker1028"/>database insertion is quite easy since it is enough to remove the added item, but undoing modifications and deletes is quite difficult and requires the storage of additional information. The general solution to this problem is storing records that represent all database changes in a table. These records can be used to compute a compensation operation or to restore the previous database state starting from a reference database state. We already discussed this storage technique, which <a id="_idIndexMarker1029"/>is called <strong class="keyWord">event sourcing</strong>, in the <em class="italic">Event sourcing</em> section of <em class="italic">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>. Just to recap, and in a few words, each database stores not only the actual state but also the history of all changes up to a certain previous time.</p>
<p class="normal">When a saga transaction is undone, if other saga transactions depend on the undone changes, we must also undo them. For instance, suppose that an accepted purchase order depends on the funds uploaded by a user on an e-commerce platform. Then, if the funds upload transaction is undone, the purchase must also be undone.</p>
<p class="normal">In order to <a id="_idIndexMarker1030"/>avoid similar chain reactions when a<a id="_idIndexMarker1031"/> saga transaction is undone, often new transactions are accepted only if they depend on changes that took place before a certain safety interval. Thus, for instance, uploaded funds are made available only after, say, 5-10 minutes, because it is very unlikely that a transaction will be undone after more than 5-10 minutes.</p>
<p class="normal">Saga transactions may use two fundamental techniques:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Orchestration</strong>: When <a id="_idIndexMarker1032"/>the transaction starts, an orchestrator component is created that takes care of sending the necessary messages to all involved microservices and receiving their success/failure messages. This technique is easy to implement but creates dependencies between the software lifetimes of the involved microservices since the orchestrator must depend on the details of all microservices involved in the saga. Moreover, this technique may have poor performance since the orchestrator becomes a bottleneck.</li>
<li class="bulletList"><strong class="keyWord">Choreography</strong>: There<a id="_idIndexMarker1033"/> is no centralized control of the transaction but each microservice is invoked by a different sending microservice and forwards the success/failure messages it receives to other communication neighbors. Choreography overcomes the disadvantages<a id="_idIndexMarker1034"/> of orchestration but it is more difficult to implement and test.</li>
</ul>
<p class="normal">The following table <a id="_idIndexMarker1035"/>summarizes the pros and cons of the two techniques.</p>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Code maintainability</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Difficulties in designing and debugging</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Choreography</strong></p>
</td>
<td class="table-cell">
<p class="normal">Good</p>
</td>
<td class="table-cell">
<p class="normal">Quite high</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Orchestration</strong></p>
</td>
<td class="table-cell">
<p class="normal">Low</p>
</td>
<td class="table-cell">
<p class="normal">No particular difficulty</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 14.3: Pros and cons of choreography and orchestration</p>
<h1 class="heading-1" id="_idParaDest-294">Implementing worker microservices with ASP.NET Core</h1>
<p class="normal">In order to<a id="_idIndexMarker1036"/> avoid blocking the caller’s synchronous request for too much time, an ASP.NET Core-based solution<a id="_idIndexMarker1037"/> requires the implementation of an internal queue where it can store all received messages. This way, when a message is received, it is immediately enqueued without processing it, so that a “received” response can be immediately returned.</p>
<p class="normal">Therefore, the application level needs a repository interface that handles the queue. Here is a possible definition of this interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IMessageQueue
{
    public Task&lt;IList&lt;QueueItem&gt;&gt; Top(int n);
    public Task Dequeue(IEnumerable&lt;QueueItem&gt; items);
    public Task Enqueue(QueueItem item);
}
</code></pre>
<p class="normal">Where:</p>
<ul>
<li class="bulletList"><code class="inlineCode">QueueItem</code> is a class that contains all request information</li>
<li class="bulletList"><code class="inlineCode">Enqueue</code> adds a new message to the queue</li>
<li class="bulletList"><code class="inlineCode">Top</code> returns the first <code class="inlineCode">n</code> queue items without removing them from the queue</li>
<li class="bulletList"><code class="inlineCode">Dequeue</code> removes the first <code class="inlineCode">n</code> messages from the queue</li>
</ul>
<p class="normal">The actual implementation of the preceding interface can be based on a database table, or any other storage media.</p>
<p class="normal">The <a id="_idIndexMarker1038"/>application level can be <a id="_idIndexMarker1039"/>implemented with an ASP.NET Core gRPC project that organizes all the gRPC stuff for you:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_14_03.png"/></figure>
<p class="packt_figref">Figure 14.3: Creating a gRPC Server project</p>
<p class="normal">The actual request processing is performed by a worker-hosted service that runs in parallel with the ASP.NET Core pipeline. It is implemented with the hosted services we discussed in the <em class="italic">Using generic hosts</em> section of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>. It is worth recalling that hosted services are implementations of the <code class="inlineCode">IHostedService</code> interface defined in the dependency injection engine as follows:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddHostedService&lt;MyHostedService&gt;();
</code></pre>
<p class="normal">Being defined in the dependency injection engine, they are automatically injected services in their constructors. Hosted services are used to execute parallel threads that run independently of the remainder of the application. Usually, they are not defined by directly implementing the <code class="inlineCode">IHostedService</code> interface, but by inheriting from the abstract <code class="inlineCode">BackgroundService</code> class and overriding its <code class="inlineCode">Task ExecuteAsync(CancellationToken token)</code> abstract method.</p>
<p class="normal">The <code class="inlineCode">ExecuteAsync</code> method usually contains an endless loop that exits only when the application is shut down. This endless loop defines the behavior of a worker-hosted service that repeats a certain task. In our case, the task to repeat is the continuous extraction and processing of <code class="inlineCode">N</code> items from the queue.</p>
<p class="normal">Here is a possible implementation of our hosted service:</p>
<pre class="programlisting code"><code class="hljs-code">public class ProcessPurchases : BackgroundService
{
    IServiceProvider services;
    public ProcessPurchases(IServiceProvider services)
    {
        this.services = services;
    }
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        bool queueEmpty = false;
        while (!stoppingToken.IsCancellationRequested)
        {
           while (!queueEmpty &amp;&amp; !stoppingToken.IsCancellationRequested)
           {
             ...
           }
            await Task.Delay(100, stoppingToken);
            queueEmpty = false;
        }
    }
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker1040"/>class constructor is not injected with the specific services it needs but instead has the <code class="inlineCode">IServiceProvider</code> that can be <a id="_idIndexMarker1041"/>used to get any service defined in the dependency injection engine. The reason for this choice is that it will launch several threads (one for each of the <code class="inlineCode">N</code> messages extracted from the queue), and, in general, different threads can’t share the same service instance.</p>
<p class="normal">The problem is caused by services with a session scope. Usually, these services are not designed to be thread-safe since the single session-scoped instance used throughout a whole ASP.NET Core request is never shared among parallel threads. However, we are not going to use our services from within the usual ASP.NET Core pipeline but from within parallel threads launched by our hosted service. Therefore, we need a different session scope for each parallel thread. </p>
<p class="normal">Thus, the right way to process is to use <code class="inlineCode">IServiceProvider</code> to create each necessary scope and then use each scope to get a different instance for each parallel thread.</p>
<p class="normal">The inner <code class="inlineCode">while</code> loop runs until the queue is empty, then the worker thread sleeps for 100 milliseconds and then tries the inner loop again to see if in the meantime some new message reached the queue.</p>
<p class="normal">When the application is shut down, the <code class="inlineCode">stoppingToken</code> <code class="inlineCode">CancellationToken</code> is signaled and both loops exit, so that the whole <code class="inlineCode">ExecuteAsync</code> method exits and the worker thread dies.</p>
<p class="normal">Here is<a id="_idIndexMarker1042"/> the content of the <a id="_idIndexMarker1043"/>inner loop:</p>
<pre class="programlisting code"><code class="hljs-code">using (var scope = services.CreateScope())
{
    IMessageQueue queue = scope.ServiceProvider.GetRequiredService&lt;IMessageQueue&gt;();
                   
    var toProcess = await queue.Top(10);
    if (toProcess.Count &gt; 0)
    {
        Task&lt;QueueItem?&gt;[] tasks = new Task&lt;QueueItem?&gt;[toProcess.Count];
        for (int i = 0; i &lt; tasks.Length; i++)
        {
            tasks[i] = toExecute();
        }
        await Task.WhenAll(tasks);
        await queue.Dequeue(tasks.Select(m =&gt; m.Result)
           .Where(m =&gt; m != null).OfType&lt;QueueItem&gt;());
    }
    else queueEmpty = true;
}
</code></pre>
<p class="normal">A session scope surrounds the whole code since we need a unique instance of <code class="inlineCode">IMessageQueue</code> to manipulate the queue.</p>
<p class="normal">The code tries to extract <code class="inlineCode">N</code> messages from the queue. If no message is found, <code class="inlineCode">queueEmpty</code> is set to <code class="inlineCode">true</code>, so that the inner loop exits; otherwise, a <code class="inlineCode">for</code> loop creates a separate task for each extracted request and inserts it in the <code class="inlineCode">tasks</code> array.</p>
<p class="normal">Then, <code class="inlineCode">Task.WhenAll</code> awaits all tasks. Finally, <code class="inlineCode">queue.Dequeue</code> removes from the queue all not-null requests returned from the tasks. Since a not-null request is returned only in the case of successful processing, <code class="inlineCode">queue.Dequeue</code> removes just the successfully processed requests.</p>
<p class="normal">The <code class="inlineCode">toExecute</code> method performs the actual request processing that depends on the specific application.</p>
<p class="normal">A complete example containing all details and a step-by-step guide to its practical implementation is described in the<em class="italic"> A worker microservice with ASP.NET Core</em> section of <em class="italic">Chapter 21, Case Study</em>. The complete source code of the example is contained in the folder<a id="_idIndexMarker1044"/> associated with this chapter<a id="_idIndexMarker1045"/> in the book’s GitHub repository.</p>
<p class="normal">The next section shows you how to modify the code of this example to use queued communication based on the <strong class="keyWord">RabbitMQ</strong> message broker.</p>
<h1 class="heading-1" id="_idParaDest-295">Implementing microservices with .NET worker services and message brokers</h1>
<p class="normal">This <a id="_idIndexMarker1046"/>section explains the modifications needed to use a message broker instead of gRPC communication with an internal queue. This kind of solution is usually more difficult to test and design but allows for better horizontal scaling.</p>
<p class="normal">The message broker used in the code<a id="_idIndexMarker1047"/> is <strong class="keyWord">RabbitMQ</strong>. However, we could also replace it <a id="_idIndexMarker1048"/>with <strong class="keyWord">Azure Service Bus </strong>using the code available in the GitHub repository associated with the book. The next subsection explains how to install RabbitMQ on your development machine. We used RabbitMQ to give the reader the opportunity to install and study it, since Azure Service Bus needs less configuration and is immediately ready to use. In an actual production system, one might choose RabbitMQ, just so you are not tied to a specific cloud provider, because while Azure Service Bus is available just on Azure, RabbitMQ can be installed in any cloud or on-premises environment.</p>
<h2 class="heading-2" id="_idParaDest-296">Installing RabbitMQ</h2>
<p class="normal">Before<a id="_idIndexMarker1049"/> installing <strong class="keyWord">RabbitMQ,</strong> you need to install <strong class="keyWord">Erlang</strong> from the link given in the <em class="italic">Technical requirements</em> section. Just download and execute the installer from an administrative account. After that, you can download and install RabbitMQ from the link in the <em class="italic">Technical requirements</em> section.</p>
<p class="normal">If installation is successful, you should find a service called <strong class="keyWord">RabbitMQ</strong> among your machine’s Windows services. If either you don’t find it or it is not running, restart your computer.</p>
<p class="normal">Administrative commands can be issued to RabbitMQ from the command prompt, which you can find in the <strong class="keyWord">RabbitMQ Server</strong> Windows menu folder.</p>
<p class="normal">You can also enable a web-based administrative UI. Let’s open the RabbitMQ command prompt and issue the following command:</p>
<pre class="programlisting con"><code class="hljs-con">rabbitmq-plugins enable rabbitmq_management
</code></pre>
<p class="normal">Then, go to <code class="inlineCode">http://localhost:15672</code>. You will be prompted for a username and password. Initially, they are both set to <strong class="keyWord">guest</strong>. From there, you may inspect all active connections <a id="_idIndexMarker1050"/>and channels and all communication queues that have been created. The queues page contains all queues that have been defined. By clicking on each of them, you move to a queue-specific page where you can inspect the queue content and perform various operations on the specific queue.</p>
<p class="normal">The next subsection contains a short survey of RabbitMQ features.</p>
<h2 class="heading-2" id="_idParaDest-297">RabbitMQ basics</h2>
<p class="normal">Natively, RabbitMQ <a id="_idIndexMarker1051"/>supports the AMQP asynchronous message protocol, which is one of the most used asynchronous protocols, the other being MQTT, which has a specific syntax for the publisher/subscriber pattern. </p>
<p class="normal">Support for MQTT can be added with a plugin, but RabbitMQ has facilities for implementing easily a publisher/subscriber pattern on top of AMQP. Moreover, RabbitMQ offers several tools to support scalability, disaster recovery, and redundancy, so it fulfills all requirements to be a first-class actor in cloud and microservices environments. More specifically, it supports data replication like most SQL and NoSQL databases and also supports cooperation among several servers based on sophisticated and flexible techniques. For lack of space, in this section, we will describe just RabbitMQ’s basic operations, but the reader can find more details in the tutorials and <a id="_idIndexMarker1052"/>documentation of RabbitMQ’s official website: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>.</p>
<p class="normal">RabbitMQ messages must be prepared in binary format since RabbitMQ messages must be just an array of bytes. Therefore, we need to serialize .NET objects with a binary formatter before sending them. In the example in this section, we will test both the ProtoBuf serializer and a fast .NET-specific serializer called <em class="italic">Binaron</em>. It might also be possible to use a JSON serializer to ensure better compatibility if there are compatibility issues among microservices implemented with different frameworks by different teams, and/or if there are legacy microservices. It is worth recalling that JSON is usually more compatible but less efficient, while binary formats are less compatible. ProtoBuf tries to solve the binary compatibility issue by defining a universal binary language, but it is not an official standard but a de facto standard.</p>
<p class="normal">Messages <a id="_idIndexMarker1053"/>are not sent directly to queues, but to other entities called <strong class="keyWord">exchanges</strong> that <a id="_idIndexMarker1054"/>route them to queues. Exchanges are AMQP-specific concepts, and are RabbitMQ’s way of configuring complex communication protocols like the publisher/subscriber protocol.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_14_04.png"/></figure>
<p class="packt_figref">Figure 14.4: RabbitMQ exchanges</p>
<p class="normal">To adequately define the exchange routing strategy, we can implement several patterns. More specifically:</p>
<ul>
<li class="bulletList">When we use a default exchange, the message is sent to a single queue and we can implement asynchronous direct calls.</li>
<li class="bulletList">When we use a <code class="inlineCode">fanout</code> exchange, the exchange will send the message to all queues that subscribe to that exchange. This way, we can implement the publisher/subscriber pattern. </li>
<li class="bulletList">There is also a <code class="inlineCode">topic</code> exchange that enhances the publisher/subscriber pattern by enabling the matching of several events with wildcard chars. However, it is not usually needed in microservices for enterprise applications.</li>
</ul>
<p class="normal">Our examples <a id="_idIndexMarker1055"/>will describe just direct calls, but the <em class="italic">Further reading</em> section contains a link to RabbitMQ tutorials that show examples of publisher/subscriber implementations.</p>
<p class="normal">The next section explains how to modify the code in the previous section to use RabbitMQ-based direct communication.</p>
<h2 class="heading-2" id="_idParaDest-298">Replacing internal queues with RabbitMQ</h2>
<p class="normal">As<a id="_idIndexMarker1056"/> previously discussed, in high-traffic WAN networks also receiving a synchronous received-message acknowledgment has an unacceptable performance impact, so no RPC protocol can be used. Moreover, often microservices use the publisher/subscriber pattern to achieve the best decoupling. In these cases, using a message broker is a MUST. Finally, having all queues handled by a unique scalable broker enables the independent and easy scaling of the communication resources. This capability is fundamental for optimizing the performance of applications made of hundreds or thousands of microservices.</p>
<p class="normal">Summing up, there are cases where message brokers are a MUST or are at least the best choice. Therefore, in this section, we will show how to use them by transforming the previous project so that it uses RabbitMQ instead of gRPC and internal queues.</p>
<p class="normal">Unluckily this transformation requires a complete restructuration of the microservice project. We can save business and data layers but we need to move from an ASP.NET Core project to a different project template called <strong class="screenText">Worker Service</strong>.</p>
<p class="normal">Therefore, let’s replace the ASP.NET Core project with a <strong class="screenText">Worker Service</strong> project:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_14_05.png"/></figure>
<p class="packt_figref">Figure 14.5: Setup Process for a gRPC Server Project in ASP.NET Core</p>
<p class="normal">We don’t need the gRPC services anymore, but we need ProtoBuf because RabbitMQ works with binary messages.</p>
<p class="normal">The <a id="_idIndexMarker1057"/>Worker Service project automatically scaffolds a hosted service (hosted services were discussed in detail in the <em class="italic">Using generic hosts</em> section of <em class="italic">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</em>). However, the <code class="inlineCode">ExecuteAsync</code> method of this hosted service must be a little bit different:</p>
<pre class="programlisting code"><code class="hljs-code">protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        try
        {
            var factory = new ConnectionFactory() { HostName = "localhost" };
            using (var connection = factory.CreateConnection())
            using (var channel = connection.CreateModel())
            {
                channel.QueueDeclare(queue: "purchase_queue",
                                     durable: true,
                                     exclusive: false,
                                     autoDelete: false,
                                     arguments: null);
                channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global:                                false);
                var consumer = new EventingBasicConsumer(channel);
                consumer.Received += async (sender, ea) =&gt;
                {
                    // Message received even handler
                    ...
                };
                channel.BasicConsume(queue: "purchase_queue",
                            autoAck: false,
                            consumer: consumer);
                 await Task.Delay(1000, stoppingToken);
            }
         }
        catch { }
    }
}
</code></pre>
<p class="normal">Inside the <a id="_idIndexMarker1058"/>main loop, if an exception is thrown, it is intercepted by the empty <code class="inlineCode">catch</code>. Since the two <code class="inlineCode">using</code> statements are left, both the connection and channel are disposed of. Therefore, after the exception, a new loop is executed that creates a new fresh connection and a new channel.</p>
<p class="normal">Intercepting exceptions is fundamental for several reasons:</p>
<ul>
<li class="bulletList">First of all, it avoids the microservice crash.</li>
<li class="bulletList">It enables a complete reset of all client objects involved in the communication with the RabbitMQ server that might be damaged by the error.</li>
<li class="bulletList">It allows an error logging that, in the actual production environment, is the basic monitoring tool. For simplicity, error logging is not shown in the code snippets.</li>
</ul>
<p class="normal">In the <code class="inlineCode">using</code> statement body, we ensure that our queue exists, and then set <code class="inlineCode">prefetch</code> to <code class="inlineCode">1</code>.</p>
<div><p class="normal">Ensuring queues exist and creating them if they don’t exist is better than relying on a single microservice for creating them since this approach avoids introducing complex dependencies and maintenance challenges related to the sequence in which microservices will run.</p>
</div>
<p class="normal">Setting <code class="inlineCode">prefetch</code> to <code class="inlineCode">1</code> causes each server to extract just one message at a time, which ensures a fair distribution of the load among all servers. However, setting <code class="inlineCode">prefetch</code> to <code class="inlineCode">1</code> might not be convenient when each server runs several equal parallel threads to process the incoming messages since it sacrifices thread usage optimization in favor of fair distribution of messages among servers. As a consequence, threads that could successfully process further messages (after the first) might remain idle, thus possibly wasting processor cores available on each server machine.</p>
<p class="normal">Then, we define a <code class="inlineCode">message received</code> event handler. <code class="inlineCode">BasicConsume</code> starts the actual message reception. With <code class="inlineCode">autoAck</code> set to <code class="inlineCode">false</code>, when a message is read from the queue, it is not removed but just blocked, so it is not available to other servers that read from the same queue. The message is actually removed when a confirmation that it has been successfully processed is sent to RabbitMQ. We can also send a failure confirmation, in which case the message is unblocked and becomes available for processing again.</p>
<p class="normal">If no confirmation is received, the message remains blocked till the connection and channel are disposed of.</p>
<p class="normal">Since <code class="inlineCode">BasicConsume</code> is non-blocking, the <code class="inlineCode">Task.Delay</code> after it blocks until the cancellation token is signaled. In any case, after 1 second <code class="inlineCode">Task.Delay</code> unblocks and both the connection and the channel are replaced with fresh ones. This prevents non-confirmed messages from remaining blocked forever.</p>
<p class="normal">Making <a id="_idIndexMarker1059"/>instructions like <code class="inlineCode">BasicConsume</code> non-blocking prevents a thread from wasting processor cores by remaining blocked while waiting for an event. Instead, the thread is put in sleeping mode by instructions like <code class="inlineCode">Task.Delay</code>, thus freeing up all its resources and its assigned processor core, which, this way, can be assigned to another parallel thread that was waiting for a free core for its execution.</p>
<p class="normal">Let’s move on to the code inside the “message received” event. This is the place where the actual message processing takes place.</p>
<p class="normal">As a first step, the code verifies if the application is being shut down, in which case it disposes of the channel and connection and returns without performing any further operations:</p>
<pre class="programlisting code"><code class="hljs-code">if (stoppingToken.IsCancellationRequested)
{
    channel.Close();
    connection.Close();
    return;
}
</code></pre>
<p class="normal">Then, a session scope is created to access all session-scoped dependency injection services:</p>
<pre class="programlisting code"><code class="hljs-code">using (var scope = services.CreateScope())
{
  try
  {
  // actual application dependent message processing
  ...
  }
  catch {
    ((EventingBasicConsumer)sender).Model.BasicNack(ea.DeliveryTag, false, true);
  }
}
</code></pre>
<p class="normal">In the case <a id="_idIndexMarker1060"/>that an exception is thrown during the message processing, a <code class="inlineCode">Nack</code> message is sent to RabbitMQ to inform it that the message processing failed. <code class="inlineCode">ea.DeliveryTag</code> is a tag that uniquely identifies the message. The second argument set to <code class="inlineCode">false</code> informs RabbitMQ that the <code class="inlineCode">Nack</code> is just for the message identified by <code class="inlineCode">ea.DeliveryTag</code> that doesn’t also involve all other messages waiting for confirmation from this server. Finally, the last argument set to <code class="inlineCode">true</code> asks RabbitMQ to requeue the message whose processing failed.</p>
<p class="normal">Inside the <code class="inlineCode">try</code> block, there is the actual message processing. Its first step is the message deserialization:</p>
<pre class="programlisting code"><code class="hljs-code">var body = ea.Body.ToArray();
MyMessageClass? message = null;
using (var stream = new MemoryStream(body))
{
    message = PurchaseMessage.Parser.ParseFrom(stream);
}
</code></pre>
<p class="normal">After that, there is the actual application-dependent message processing. If this processing fails, we must send a <code class="inlineCode">Nack</code>; otherwise, we must send an <code class="inlineCode">Ack</code>:</p>
<pre class="programlisting code"><code class="hljs-code">if(success)
    ((EventingBasicConsumer)sender).Model
        .BasicAck(ea.DeliveryTag, false);
else
    ((EventingBasicConsumer)sender).Model
        .BasicNack(ea.DeliveryTag, false, true);
</code></pre>
<p class="normal">The full code of a complete example is in the <code class="inlineCode">GrpcMicroServiceRabbitProto</code> subfolder of the <code class="inlineCode">ch15</code> folder in the GitHub repository of this book. A detailed description of this example is in the <em class="italic">A worker microservice based on RabbitMQ</em> section of <em class="italic">Chapter 21</em>, <em class="italic">Case Study</em>.</p>
<p class="normal">The next chapter describes service-oriented architecture and how to implement it with ASP.NET Core.</p>
<h1 class="heading-1" id="_idParaDest-299">Summary</h1>
<p class="normal">In this chapter, we analyzed various options for efficient internal microservices communication. We explained the importance of a binary serialization that is interoperable and that ensures compatibility with previous message versions, and we described ProtoBuf in detail.</p>
<p class="normal">We analyzed the limits of RPC communication and why data-driven communication must be preferred. Then, we focused on how to achieve reliable asynchronous communication and efficient distributed transactions.</p>
<p class="normal">After having described the conceptual problems and techniques of reliable asynchronous communication, we looked at two architectures. The first one was based on gRPC, ASP.NET Core, and internal queues, and the second one was based on message brokers like RabbitMQ and .NET worker services.</p>
<p class="normal">The chapter explained, using practical examples, how to implement all the communication protocols that have been discussed and the architectural options for implementing worker microservices that are available in .NET.</p>
<h1 class="heading-1" id="_idParaDest-300">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Why are queues so important in microservices communication?</li>
<li class="numberedList">How do we recall another <code class="inlineCode">.proto</code> file?</li>
<li class="numberedList">How can we represent a <code class="inlineCode">TimeSpan</code> in the ProtoBuf language?</li>
<li class="numberedList">What are the advantages of ProtoBuf and gRPC over other binary options?</li>
<li class="numberedList">What are the advantages of using message brokers instead of internal queues?</li>
<li class="numberedList">Why is it acceptable to use a blocking gRPC call to enqueue a message in a recipient queue?</li>
<li class="numberedList">How do we enable <code class="inlineCode">.proto</code> file code generation in a .NET project file?</li>
<li class="numberedList">How do I send a message on a RabbitMQ channel with the official .NET client?</li>
<li class="numberedList">How do you ensure that a message sent on a RabbitMQ channel is safely saved on disk using the official .NET client?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-301">Further reading</h1>
<ul>
<li class="bulletList">The official .NET documentation on ProtoBuf can be found here: <a href="https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0">https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0</a>.</li>
<li class="bulletList">The .NET documentation on gRPC is here: <a href="https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0">https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0</a>.</li>
<li class="bulletList">The official Google documentation on the whole ProtoBuf language is here: <a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a>.</li>
<li class="bulletList">Complete tutorials on RabbitMQ can be found here: <a href="https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html">https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html</a>.</li>
<li class="bulletList">The complete documentation for RabbitMQ is here: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>.</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>