- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Security Considerations for CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI应用程序的安全考虑因素
- en: Security is one of the most critical concerns in any application development
    project. It’s interesting to see that, in many projects, development teams tend
    to think that because they implemented measures to prevent their application’s
    code from being subject to SQL injection, XSS attacks, or similar, their application
    is secure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是任何应用程序开发项目中最重要的关注点之一。有趣的是，在许多项目中，开发团队往往认为，由于他们实施了防止应用程序代码受到SQL注入、XSS攻击或类似攻击的措施，他们的应用程序就是安全的。
- en: However, it is important to keep in mind that security takes different forms
    and spans different areas, which means that it does not only concern the security
    of the application’s code or its usage but also extends to the security of the
    whole development lifecycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，安全性具有不同的形式，覆盖不同的领域，这意味着它不仅关乎应用程序代码的安全性或其使用，还扩展到整个开发生命周期的安全性。
- en: 'In this chapter, we will discuss these different areas and how they are related
    to securing CLI applications, and we will cover the key areas that you need to
    consider in order to enhance the security of your CLI application and the security
    of your development lifecycle. More specifically, we will do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些不同领域以及它们如何与确保CLI应用程序的安全性相关，并涵盖您需要考虑的关键领域，以增强您的CLI应用程序和开发生命周期的安全性。更具体地说，我们将做以下几件事：
- en: Discuss the different areas in which security should be considered
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论应该考虑安全性的不同领域
- en: Learn how to assess the security posture of a CLI application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何评估CLI应用程序的安全状况
- en: Learn how to implement authentication in order to secure access to user data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现身份验证以确保用户数据的访问安全
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的GitHub仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13)
- en: Security areas
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性领域
- en: As mentioned earlier, security is not only limited to the application’s code,
    nor can it only be achieved by implementing authentication, although these areas
    are very important.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，安全性不仅限于应用程序代码，也不能仅通过实现身份验证来实现，尽管这些领域非常重要。
- en: Let’s first start by highlighting the key areas involved in securing an application
    throughout its lifecycle. It is important for me to make this point (or reminder)
    here as I still meet with customers who introduce security too late in the lifecycle
    of an application (typically after the application has been developed and released
    to production), expecting security professionals to do miracles and secure the
    application with minimal or no modification to the application, which is, obviously,
    unrealistic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先强调一下在整个生命周期中确保应用程序安全性的关键领域。我必须在这里强调（或提醒）这一点，因为我仍然遇到一些客户，他们在应用程序的生命周期中引入安全性太晚（通常是在应用程序开发并发布到生产之后），期望安全专家能够创造奇迹，以最小的或没有修改应用程序的方式确保应用程序的安全，这显然是不现实的。
- en: 'Always keep in mind that security should span the entire lifecycle of the application.
    In concrete terms, security should be a concern from the early stages of designing
    the application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要牢记，安全性应该贯穿应用程序的整个生命周期。具体来说，安全性应该从设计应用程序的早期阶段就成为一个关注点：
- en: '**In the design phase**: It is important to define security requirements and
    objectives and to conduct threat modeling using methodologies such as STRIDE to
    identify potential security risks so we can incorporate the appropriate security
    controls into the initial design. STRIDE helps categorize threats into six groups:
    Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, and
    Elevation of privilege. After identifying threats, we can use the DREAD model
    to quantitatively assess and prioritize them based on their Damage potential,
    Reproducibility, Exploitability, Affected users, and Discoverability. During this
    phase, we should also consider privacy and data protection measures, such as encryption,
    authentication, and authorization.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在设计阶段**：定义安全需求和目标，并使用STRIDE等方法进行威胁建模，以识别潜在的安全风险，以便我们可以将适当的安全控制措施纳入初始设计，这是非常重要的。STRIDE帮助将威胁分类为六个组：欺骗、篡改、否认、信息泄露、拒绝服务和权限提升。在识别威胁后，我们可以使用DREAD模型根据其损害潜力、可重复性、可利用性、受影响用户和可发现性进行定量评估和优先排序。在此阶段，我们还应考虑隐私和数据保护措施，如加密、身份验证和授权。'
- en: '**In the architecture phase**: We are not only talking about the software architecture
    here but also about the infrastructure and networking architecture. Of course,
    we need to design a secure architecture that includes defense-in-depth strategies
    and integrates security mechanisms such as authentication and authorization. But
    we also need to plan for secure communication channels and data storage, using
    techniques such as encryption at rest and in transit along with network segmentation
    to ensure only appropriate routes of communication, through the appropriate network
    addresses, ports, and domains, and using appropriate protocols are allowed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在架构阶段**：我们在这里讨论的不仅仅是软件架构，还包括基础设施和网络架构。当然，我们需要设计一个包含深度防御策略并集成安全机制（如身份验证和授权）的安全架构。但我们还需要计划安全的通信通道和数据存储，使用诸如静态和传输中的加密以及网络分段等技术，以确保只有适当的通信路径、通过适当的网络地址、端口和域名，并使用适当的协议被允许。'
- en: '**In the development phase**: It is important to apply secure coding practices
    by relying on coding standards, such as implementing input validation and sanitization,
    and to ensure that our application is not vulnerable to common OWASP Top 10 security
    risks. It is equally important to ensure that secure coding practices are applied
    during code reviews. But this is not enough! You should use secure libraries and
    frameworks. In other words, ensure that your frameworks and libraries are still
    supported and receive security updates. Since we are using .NET 8 here, we know
    that it is still supported (and will receive security updates) until November
    10, 2026 (I’m writing this in November 2024). As a framework or a library becomes
    unsupported, it is important to plan to migrate to a newer version (not necessarily
    the latest, by the way 😉).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在开发阶段**：通过依赖编码标准，如实现输入验证和清理，并确保我们的应用程序不受常见的OWASP Top 10安全风险的影响，应用安全编码实践非常重要。同样重要的是，在代码审查期间也要应用安全编码实践。但这还不够！您应该使用安全的库和框架。换句话说，确保您的框架和库仍然受到支持并接收安全更新。由于我们在这里使用.NET
    8，我们知道它仍然受到支持（并且将接收安全更新）直到2026年11月10日（我在2024年11月写下这些）。随着框架或库变得不再受支持，重要的是要计划迁移到较新版本（顺便说一下，不一定是最新的版本
    😉）。'
- en: Suppose our application communicates with external dependencies, such as web
    services. In that case, we have to ensure that these communications happen in
    a secure manner (by leveraging authentication and authorization) and using the
    appropriate protocols (such as HTTPS).
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们的应用程序与外部依赖项进行通信，例如Web服务。在这种情况下，我们必须确保这些通信以安全的方式进行（通过利用身份验证和授权）并使用适当的协议（例如HTTPS）。
- en: '**In the infrastructure configuration phase**: All efforts to enhance the application’s
    security could be in vain if the infrastructure on which it is running is unsecured.
    In the case of CLI applications, which run on the user’s computer, this responsibility
    is delegated to them or their organization’s IT department, which usually controls
    employees’ workstations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在基础设施配置阶段**：如果应用程序运行的基础设施不安全，那么所有提高应用程序安全性的努力都可能徒劳。在CLI应用程序的情况下，这些应用程序在用户的计算机上运行，责任通常委托给用户或其组织的IT部门，该部门通常控制员工的工作站。'
- en: '**In the testing phase**: Security-specific testing, including penetration
    testing and vulnerability assessments, should be performed during the testing
    phase to ensure user data cannot leak, user accounts cannot be compromised, and
    the application cannot be diverted from its intended usage toward malicious activities.
    Performing security testing allows us to validate that security requirements are
    met. Mature DevSecOps teams perform such testing on a regular basis. However,
    security tests should at least be performed before releasing an application to
    production.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在测试阶段**：在测试阶段应进行特定于安全的测试，包括渗透测试和漏洞评估，以确保用户数据不会泄露，用户账户不会被破坏，并且应用程序不会被用于恶意活动。执行安全测试可以让我们验证是否满足安全要求。成熟的安全开发运营（DevSecOps）团队会定期进行此类测试。然而，安全测试至少应在将应用程序发布到生产之前进行。'
- en: '**In the deployment phase**: Every DevSecOps engineer knows that your CI/CD
    pipelines can be a security threat if not properly secured. Secrets (such as passwords,
    API keys, service connections, connection strings, and so on) should be kept…
    well, secret. Every CI/CD tool has its own secret management mechanism, which
    usually takes the form of a key vault, but we can also rely on external tools
    that are designed for such purposes, such as Azure Key Vault or HashiCorp Vault.
    Access to these secrets is usually restricted using roles and permissions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在部署阶段**：每个 DevSecOps 工程师都知道，如果你的 CI/CD 管道没有得到适当的安全保护，它可能成为安全威胁。秘密（如密码、API
    密钥、服务连接、连接字符串等）应该保密。每个 CI/CD 工具都有自己的秘密管理机制，这通常以密钥库的形式出现，但我们也可以依赖为这些目的设计的工具，如 Azure
    Key Vault 或 HashiCorp Vault。对这些秘密的访问通常通过角色和权限进行限制。'
- en: '**While the application is being used**: It is a common mistake for immature
    teams and organizations to believe that once the application has been released
    to production, the job of security is done. Wrong! This is where it all starts.
    You may argue that we put a lot of effort into securing the application before
    releasing it to our users, and you would be right. However, by releasing our application
    into the wild, it will experience a wide range of usage patterns and user environments,
    way beyond what we could have expected, thought of, and planned for. We will hence
    have to monitor for security incidents and anomalies, by implementing logging
    and auditing mechanisms and by regularly updating and patching the application
    and its dependencies.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在应用程序使用期间**：对于不成熟的小组和组织来说，认为一旦应用程序发布到生产环境，安全工作就完成了，这是一个常见的错误。错误！这正是一切开始的地方。你可能认为我们在发布给用户之前投入了大量精力来确保应用程序的安全性，你是对的。然而，通过将我们的应用程序发布到野外，它将经历各种使用模式和用户环境，远远超出我们所能预期的、考虑的和计划的。因此，我们必须通过实施日志记录和审计机制，并定期更新和修补应用程序及其依赖项，来监控安全事件和异常。'
- en: '`Destructure.ByMaskingProperties` method and pass a list of properties to be
    ignored when logging.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destructure.ByMaskingProperties` 方法用于在记录日志时忽略一系列属性。'
- en: '**As new versions or bug fixes are released**: Either when introducing new
    functionalities or fixing bugs, it is important to conduct a security impact analysis
    for the introduced changes. This can be done by performing regression testing
    to ensure existing security controls are still met and no vulnerability has been
    introduced.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随着新版本或错误修复的发布**：无论是引入新功能还是修复错误，对引入的更改进行安全影响分析都是非常重要的。这可以通过执行回归测试来完成，以确保现有的安全控制仍然满足要求，并且没有引入任何漏洞。'
- en: Fortunately, there is a variety of tools to help at every stage. If your team
    or organization has adopted a DevSecOps culture, you will already be aware of
    many of these tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有各种各样的工具可以帮助我们完成每个阶段。如果你的团队或组织已经采用了 DevSecOps 文化，你将已经了解其中许多工具。
- en: DevSecOps being way beyond the scope of this book, we will not be discussing
    the broad spectrum of tools you may use at every step. However, I do want to cover
    tools that will help us assess and enhance the security posture of a CLI application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DevSecOps 超出了本书的范围，我们不会讨论你可能在每一步使用的工具的广泛范围。然而，我想介绍一些可以帮助我们评估和增强 CLI 应用程序安全状态的工具。
- en: Assessing the security posture of a CLI application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估 CLI 应用程序的安全状态
- en: 'There are multiple tools that help assess the security posture of an application
    (including a CLI application). Among the most widely used ones, we find the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种工具可以帮助评估应用程序的安全状态（包括 CLI 应用程序）。在广泛使用的工具中，我们发现以下工具：
- en: '`.csproj` files to detect vulnerabilities in third-party libraries.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.csproj` 文件来检测第三方库中的漏洞。
- en: '**Snyk**: This popular tool offers vulnerability reporting and scanning for
    .NET projects. It can be integrated into local development environments as well
    as into CI/CD pipelines for continuous monitoring.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Snyk**：这个流行的工具为 .NET 项目提供漏洞报告和扫描。它可以集成到本地开发环境中，也可以集成到 CI/CD 管道中进行持续监控。'
- en: '**Mend Bolt**: Previously known as **WhiteSource Bolt**, this security scanning
    tool integrates with **Azure DevOps** or **GitHub** pipelines, scanning .NET projects
    for open source vulnerabilities and generating detailed reports.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mend Bolt**：之前被称为 **WhiteSource Bolt**，这是一款安全扫描工具，可以与 **Azure DevOps** 或
    **GitHub** 管道集成，扫描 .NET 项目中的开源漏洞并生成详细报告。'
- en: '**OWASP Dependency-Check**: This tool is effective for scanning third-party
    libraries and dependencies, which is crucial for .NET applications that often
    rely on external packages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OWASP Dependency-Check**：这个工具对于扫描第三方库和依赖项非常有效，这对于经常依赖外部包的 .NET 应用程序至关重要。'
- en: '**GitHub Advanced Security**: This tool integrates security features directly
    into GitHub or Azure DevOps workflows, performs code scanning (it uses static
    analysis to detect potential security vulnerabilities and coding errors) and secret
    scanning (it recognizes patterns for passwords, API keys, and other secrets and
    detects whether they are stored in clear text in the repository), and performs
    dependency reviews and highlights vulnerable ones.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub Advanced Security**：这个工具将安全功能直接集成到 GitHub 或 Azure DevOps 工作流程中，执行代码扫描（它使用静态分析来检测潜在的安全漏洞和编码错误）和秘密扫描（它识别密码、API
    密钥和其他秘密的模式，并检测它们是否以明文形式存储在存储库中），并执行依赖项审查并突出显示易受攻击的项。'
- en: These tools have in common that they inform us about the vulnerable library,
    and give us detailed information about the vulnerability itself and the recommended
    fix for it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的共同点是它们会告诉我们易受攻击的库，并为我们提供关于漏洞本身及其推荐修复的详细信息。
- en: These tools are either free (such as Mend Bolt and OWASP Dependency-Check) or
    offer a free plan but with limited functionality (such as SonarQube, Snyk, and
    GitHub Advanced Security).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具要么是免费的（例如 Mend Bolt 和 OWASP Dependency-Check），要么提供免费计划但功能有限（例如 SonarQube、Snyk
    和 GitHub Advanced Security）。
- en: They also vary in the level of complexity and effort required to set up and
    configure them. Hence, you will find SonarQube to be the most complex to set up,
    Snyk to be moderately easy to set up, and Mend Bolt, OWASP Dependency-Checker,
    and GitHub Advanced Security to be the easiest ones to set up.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在设置和配置的复杂性和所需努力方面也有所不同。因此，你会发现 SonarQube 设置最复杂，Snyk 设置中等容易，而 Mend Bolt、OWASP
    Dependency-Checker 和 GitHub Advanced Security 则是最容易设置的。
- en: I would recommend Mend Bolt as a good starting point since it comes as an Azure
    DevOps or GitHub free extension that can be obtained from their respective marketplaces.
    For these reasons, these tools are usually intended for organizations or larger
    teams.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议从 Mend Bolt 开始，因为它作为 Azure DevOps 或 GitHub 的免费扩展提供，可以从它们各自的市场中获得。因此，这些工具通常是为组织或大型团队设计的。
- en: However, the good news is that .NET already provides us with an out-of-the-box
    tool to serve this very purpose of assessing and enhancing the security posture
    of our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好消息是 .NET 已经为我们提供了一个现成的工具来评估和增强我们应用程序的安全状态。
- en: This tool, commonly known as dotnet-audit, focuses on detecting vulnerabilities
    in .NET project dependencies (namely, `NuGet` packages) by relying on the `GitHub
    Advisory Database`. For .NET-only projects, such as **Bookmarkr**, this tool is
    the perfect starting point!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具通常被称为 dotnet-audit，它通过依赖 `GitHub Advisory Database` 来检测 .NET 项目依赖项（特别是 `NuGet`
    包）中的漏洞。对于仅使用 .NET 的项目，例如 **Bookmarkr**，这个工具是完美的起点！
- en: 'To execute this tool, we simply need to type the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此工具，我们只需输入以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The results will be shown in the terminal window, and will look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在终端窗口中显示，看起来像这样：
- en: '![Figure 13.1 – Listing vulnerable packages](img/B22400_13_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 列出易受攻击的包](img/B22400_13_01.jpg)'
- en: Figure 13.1 – Listing vulnerable packages
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 列出易受攻击的包
- en: As you may have noticed in this figure, the command has not been executed on
    Bookmarkr’s code but rather for another application. As it turns out, we are glad
    that no vulnerability has been detected for Bookmarkr (yeah!), but this might
    change over time as vulnerabilities in referenced libraries are detected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此图中可能已经注意到的，该命令并未在Bookmarkr的代码上执行，而是针对另一个应用程序。结果证明，我们对没有在Bookmarkr中检测到漏洞感到高兴（是的！），但随着时间的推移，随着引用库中漏洞的发现，这可能会发生变化。
- en: '![Figure 13.2 – No vulnerable packages for Bookmarkr](img/B22400_13_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – Bookmarkr没有易受攻击的包](img/B22400_13_02.jpg)'
- en: Figure 13.2 – No vulnerable packages for Bookmarkr
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Bookmarkr没有易受攻击的包
- en: Keep in mind that this command may ask you to run `dotnet restore` before you
    can execute it. This is especially true if this is the first time you have cloned
    the Git repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此命令可能要求您在执行之前运行`dotnet restore`。如果这是您第一次克隆Git仓库，这尤其正确。
- en: There is another command that does not directly scan for vulnerabilities, but
    which I recommend. This command lists outdated packages. While these packages
    might not have known vulnerabilities, being outdated means that they will no longer
    receive security updates. My recommendation is that you consider upgrading these
    packages to newer supported versions (once again, not necessarily the latest version
    if this introduces breaking changes).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个命令不会直接扫描漏洞，但我推荐使用。此命令列出过时的包。虽然这些包可能没有已知的漏洞，但过时意味着它们将不再接收安全更新。我的建议是您考虑将这些包升级到较新的受支持版本（再次强调，如果这引入了破坏性更改，则不一定是最新版本）。
- en: 'To run this command, simply type the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此命令，只需键入以下内容：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the result of executing this command, although no vulnerability
    has been detected in Bookmarkr’s dependencies, some of them are outdated:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从执行此命令的结果中可以看到，尽管在Bookmarkr的依赖项中没有检测到漏洞，但其中一些已经过时：
- en: '![Figure 13.3 – Listing outdated packages](img/B22400_13_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 列出过时的包](img/B22400_13_03.jpg)'
- en: Figure 13.3 – Listing outdated packages
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 列出过时的包
- en: The appropriate way to upgrade these packages is to create a new branch, update
    the packages, test the application (both using manual and automated testing, as
    described in [*Chapter 10*](B22400_10.xhtml#_idTextAnchor155)) to ensure that
    the application still works as expected and that we did not introduce regressions,
    and finally, issue a pull request to merge the modifications into the `main` branch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 升级这些包的适当方式是创建一个新的分支，更新包，测试应用程序（如[*第10章*](B22400_10.xhtml#_idTextAnchor155)中所述，使用手动和自动测试），以确保应用程序仍然按预期工作，并且我们没有引入回归，最后，提交一个拉取请求以将修改合并到`main`分支。
- en: We now have the necessary knowledge and tools to assess, and ultimately enhance,
    the security posture of our CLI application. Let’s focus our attention on securing
    communication between our CLI application and the external services it interacts
    with, to protect against unauthorized access and ensure proper user management.
    This can be achieved through authentication.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有必要的知识和工具来评估，并最终增强我们CLI应用程序的安全态势。让我们将注意力集中在保护我们的CLI应用程序与外部服务之间的通信上，以防止未经授权的访问并确保适当的管理用户。这可以通过身份验证来实现。
- en: Securing remote communications using authentication
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用身份验证来保护远程通信
- en: In [*Chapter 9*](B22400_09.xhtml#_idTextAnchor136), we introduced the `sync`
    command, which allows Bookmarkr to back up local bookmarks to a remote location
    and retrieve them when needed. When doing so, the command also synchronizes local
    and remote bookmarks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B22400_09.xhtml#_idTextAnchor136)中，我们介绍了`sync`命令，它允许Bookmarkr将本地书签备份到远程位置，并在需要时检索它们。在执行此操作时，该命令还会同步本地和远程书签。
- en: Until now, the communication between the local CLI application and the remote
    external service has happened in an insecure manner. This means that anyone who
    invokes the `sync` command may retrieve your personal bookmarks, which you clearly
    don’t want, do you?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本地CLI应用程序与远程外部服务之间的通信一直是以不安全的方式进行。这意味着任何调用`sync`命令的人都可以检索您的个人书签，这显然不是您想要的，对吧？
- en: To address this issue, we need to implement authentication.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要实现身份验证。
- en: Why is authentication important?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么身份验证很重要？
- en: You may be wondering why authentication should be required in the context of
    CLI applications. After all, a CLI application runs on the user’s computer, which
    already requires that user to authenticate to their session.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在CLI应用程序的上下文中需要认证。毕竟，CLI应用程序是在用户的计算机上运行的，这已经要求用户认证到他们的会话。
- en: In the context of CLI applications, authentication is usually required when
    communicating with external services (i.e., sending data to and retrieving data
    from these services). This ensures that users have access to their data at the
    remote location by proving who they are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI应用程序的上下文中，认证通常在与外部服务通信时（即向这些服务发送数据并从这些服务检索数据）是必需的。这确保了用户通过证明自己的身份，可以访问远程位置的数据。
- en: How to perform authentication
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行认证
- en: Authentication can be achieved in many ways. One of the most common ones is
    for the external service provider to provide you with a **Personal Access Token**
    (**PAT**). You can usually get or generate such tokens by visiting the service
    provider’s website and logging in to your account. From there, on your account’s
    settings page, you should be able to get that token or to generate a new one.
    Such tokens are usually valid for a given period of time and expire after that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 认证可以通过许多方式实现。最常见的一种是外部服务提供商为你提供一个**个人访问令牌**（**PAT**）。通常，你可以通过访问服务提供商的网站并登录到你的账户来获取或生成这样的令牌。从那里，在你的账户设置页面，你应该能够获取该令牌或生成一个新的令牌。这样的令牌通常在给定的时间内有效，并在之后过期。
- en: 'Once you have this token, you can pass it as a parameter to a command that
    performs the call to the external service. An example of this would be the `sync`
    command, which could be invoked as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个令牌，你就可以将其作为参数传递给执行对外部服务调用的命令。一个例子就是`sync`命令，它可以按照以下方式调用：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `YOUR_PAT` is most commonly a GUID value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`YOUR_PAT`最常见的是一个GUID值。
- en: This call would then authenticate the user using the received PAT value before
    performing the sync operation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将使用接收到的PAT值对用户进行认证，然后再执行同步操作。
- en: As you may have noticed, this approach could quickly become tedious as it is
    not easy to remember the value of a PAT. For this reason, CLI applications usually
    store such values either in a local configuration file, in an environment variable,
    or in the operating system’s key vault. This allows the user to invoke the command
    without always having to pass the PAT as a parameter. The command will be smart
    enough to look for it in the local configuration file or in the environment variable
    and use it if it is present. If it is not present, the command should display
    an error message asking the user to provide it. If the PAT is invalid or expired,
    the command should also be able to inform the user about that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，这种方法可能会很快变得繁琐，因为记住PAT的值并不容易。因此，CLI应用程序通常会将这样的值存储在本地配置文件中、环境变量中，或者操作系统的密钥库中。这使用户可以在不总是需要传递PAT作为参数的情况下调用命令。命令将足够智能，能够在本地配置文件或环境变量中查找它，并在存在时使用它。如果不存在，命令应显示错误消息，提示用户提供它。如果PAT无效或已过期，命令还应能够通知用户这一点。
- en: 'This is the approach adopted by GitHub – for example: you create a PAT within
    your GitHub account, which you can use to authenticate and access GitHub resources
    from external services or applications. In our use case, the external service
    is the one that provides and manages the tokens, whereas the CLI application is
    only responsible for sending these tokens to the external service.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GitHub采用的方法——例如：你可以在GitHub账户内创建一个个人访问令牌（PAT），然后你可以使用它来从外部服务或应用程序中认证和访问GitHub资源。在我们的用例中，外部服务是提供和管理令牌的那个，而CLI应用程序只负责将这些令牌发送到外部服务。
- en: Another commonly used approach is to authenticate the user against an `auth`).
    Invoking this command usually triggers the default web browser and redirects the
    user to the application provider’s login page. After successful authentication,
    the IdP provides access and an ID token that the CLI can use for subsequent requests
    to the external service. These tokens are, as for the PAT, usually included in
    the HTTP headers when performing the requests to the external service. This approach
    leverages the `OAuth 2.0` and the `OpenID` `Connect` protocols.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用的方法是使用 `auth` 对用户进行身份验证。调用此命令通常会触发默认网络浏览器并将用户重定向到应用程序提供者的登录页面。身份验证成功后，身份提供者提供访问权限和一个
    ID 令牌，CLI 可以使用该令牌进行后续对外部服务的请求。这些令牌，就像 PAT 一样，通常在对外部服务进行请求时包含在 HTTP 头部中。这种方法利用了
    `OAuth 2.0` 和 `OpenID Connect` 协议。
- en: In the remainder of this chapter, we will explore how to implement authentication
    for Bookmarkr to secure communications with the **BookmarkrSyncr** external service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将探讨如何为 Bookmarkr 实现身份验证以保护与 **BookmarkrSyncr** 外部服务的通信。
- en: Implementing authentication
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现身份验证
- en: Here, we will leverage the PAT approach as it is more convenient and can work
    even in environments where no web browser can be launched, such as CI/CD pipelines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将利用 PAT 方法，因为它更方便，甚至可以在无法启动网络浏览器的环境中工作，例如 CI/CD 管道。
- en: 'To illustrate how this could be achieved, we will need to implement functionalities
    at two levels:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何实现这一点，我们需要在两个级别上实现功能：
- en: '**BookmarkrSyncr**: The external service will receive the PAT, validate it,
    and authenticate the user if it is valid'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BookmarkrSyncr**：外部服务将接收 PAT，验证它，如果有效则对用户进行身份验证'
- en: '**Bookmarkr**: The responsibility of the CLI application is to pass the token
    to the external service and act according to the response it gets from the sent
    request'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bookmarkr**：CLI 应用程序的责任是将令牌传递给外部服务并根据发送的请求的响应采取行动'
- en: Let’s start by adding the required functionality into BookmarkrSyncr.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将所需功能添加到 BookmarkrSyncr 开始。
- en: Authenticating external services using a PAT
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PAT 验证外部服务
- en: 'To make things simple, we will assume that BookmarkrSyncr (the code for which
    can be found in the `AppendixB` folder) holds two PAT tokens: a valid one and
    an expired one. All other values that the user passes will be considered invalid
    and will be rejected for this reason.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们假设 BookmarkrSyncr（其代码可在 `AppendixB` 文件夹中找到）持有两个 PAT 令牌：一个有效的和一个已过期的。用户传递的所有其他值都将被视为无效，并将因此被拒绝。
- en: The token validation service will also be a very basic one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌验证服务也将是一个非常基础的。
- en: 'While most of the code remains as it was, we had to make the following changes
    to the parameters we pass to the `MapPost` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分代码保持不变，但我们不得不对传递给 `MapPost` 方法的参数进行以下更改：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s explain these changes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释这些更改：
- en: We indicate that the value of the PAT token comes from an HTTP header named
    `X-PAT` and that this value will be stored in the input parameter named `pat`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指出 PAT 令牌的值来自名为 `X-PAT` 的 HTTP 头部，并且该值将存储在名为 `pat` 的输入参数中。
- en: We pass a parameter of type `ITokenValidator`, which is a service we have created
    to retrieve and validate PAT tokens.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们传递一个类型为 `ITokenValidator` 的参数，这是一个我们创建的服务，用于检索和验证 PAT 令牌。
- en: We pass the current HTTP context that we will need to set HTTP headers for the
    HTTP response, especially to notify the client that the received PAT token is
    either invalid or expired. We use a different response header to ensure that the
    client knows exactly why the request was unauthorized, as this is good programming
    practice.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们传递当前的 HTTP 上下文，我们将需要为 HTTP 响应设置 HTTP 头部，特别是通知客户端收到的 PAT 令牌是无效或已过期的。我们使用不同的响应头部以确保客户端确切地知道请求为何未经授权，因为这是一种良好的编程实践。
- en: 'We then invoke methods of the `TokenValidator` service to check whether the
    PAT token is invalid or expired, and if so, we set the appropriate HTTP header
    in the response object. The code looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `TokenValidator` 服务的相关方法来检查 PAT 令牌是否无效或已过期，如果是这样，我们在响应对象中设置适当的 HTTP
    头部。代码如下：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how we set the HTTP header. We use the indexer syntax. This will set
    the header. If the header already exists, it will replace the existing value with
    the new one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何设置 HTTP 头部的。我们使用索引器语法。这将设置头部。如果头部已经存在，它将用新值替换现有值。
- en: 'The last thing we need to do is to register the `TokenValidator` service. This
    can be done for any service, using this widely known syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是注册 `TokenValidator` 服务。这可以通过使用这个广为人知的语法为任何服务完成：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `TokenValidator` service is very basic and its code looks as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`TokenValidator` 服务非常基础，其代码如下所示：'
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only thing worth mentioning here is that we are simulating a token store
    (in the class’s constructor). In a real-world scenario, we would have a persistent
    token store (such as a database). But for the purposes of this demonstration,
    storing these PAT tokens in memory makes the code easier to understand. I also
    want you to notice that, for the purpose of the demonstration, we have two tokens:
    one is a valid token, and the other represents an expired token. Any other value
    will be considered invalid since it cannot be found in the token store (which
    is realistic, by the way 😉). The client (the CLI application) will hence behave
    differently depending on the validity of the token.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这里模拟了一个令牌存储（在类的构造函数中）。在现实世界的场景中，我们会有一个持久的令牌存储（例如数据库）。但为了演示的目的，将这些
    PAT 令牌存储在内存中使得代码更容易理解。我还想让你注意到，为了演示的目的，我们有两个令牌：一个是有效的令牌，另一个代表已过期的令牌。任何其他值都将被视为无效，因为它无法在令牌存储中找到（顺便说一句，这是现实的）。因此，客户端（CLI
    应用程序）将根据令牌的有效性表现出不同的行为。
- en: Excellent! Now that we have our external service ready, it’s time to update
    the client so that it can pass the PAT.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经准备好了外部服务，是时候更新客户端，使其能够传递 PAT。
- en: Passing the PAT from the CLI application to the external service
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 PAT 从 CLI 应用程序传递到外部服务
- en: For this to happen, we will need to modify the code of both the `sync` command
    and the service agent.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要修改 `sync` 命令和服务代理的代码。
- en: 'More specifically, we will need to do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们需要做以下事情：
- en: Add a `--pat` parameter to the `sync` command.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sync` 命令中添加一个 `--pat` 参数。
- en: Modify the request that the HTTP client makes to the external service so that
    it sends the PAT token.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 HTTP 客户端对外部服务发出的请求，以便发送 PAT 令牌。
- en: Modify the code to store the PAT token in an environment variable and retrieve
    it from there if the `--pat` parameter is not specified when invoking the `sync`
    command.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码以将 PAT 令牌存储在环境变量中，并在调用 `sync` 命令时未指定 `--pat` 参数时从那里检索它。
- en: Let’s start with the first step.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。
- en: 'Let’s go to the `SyncCommand.cs` file and, in the `Options` region, let’s add
    an `Option` for the PAT as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `SyncCommand.cs` 文件，在 `Options` 区域中，让我们添加一个用于 PAT 的 `Option`，如下所示：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `Option` is optional, as we mentioned earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这个 `Option` 是可选的。
- en: 'Next, we need to make the command use this `Option`. For that matter, we need
    to add this instruction to the class’s constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要让命令使用这个 `Option`。为此，我们需要将此指令添加到类的构造函数中：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s modify the command’s handler method so that the HTTP client can
    send the PAT to the BookmarkrSyncr service. For that matter, we need to modify
    the handler method’s signature to pass the PAT as a parameter, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改命令的处理方法，以便 HTTP 客户端可以向 BookmarkrSyncr 服务发送 PAT。为此，我们需要修改处理方法签名，将 PAT
    作为参数传递，如下所示：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Back to the class’s constructor again, we need to modify the call to the `SetHandler`
    method to pass the PAT Option as a parameter. The modified method call looks like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到类的构造函数，我们需要修改对 `SetHandler` 方法的调用，以便传递 PAT Option 作为参数。修改后的方法调用如下所示：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to pass this token to the service agent. For that matter, we
    first need to modify the call to the service agent in the handler method, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此令牌传递给服务代理。为此，我们首先需要修改处理方法中对服务代理的调用，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, we need to update the code of the `BookmarkrSyncrServiceAgent` class to
    ensure the presence of the token before calling the external service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新 `BookmarkrSyncrServiceAgent` 类的代码，以确保在调用外部服务之前令牌的存在。
- en: 'The first thing we need to do is, obviously, pass the PAT value as a parameter
    to its `Sync` method, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是，显然地，将 PAT 值作为参数传递给其 `Sync` 方法，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, the first thing the method should do is to ensure the presence
    of the PAT (i.e., ensure that we are not sending a null or an empty value to the
    external service). We do this by adding the following code at the beginning of
    the method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，方法应该做的第一件事是确保 PAT 的存在（即确保我们没有向外部服务发送空或空值）。我们通过在方法开头添加以下代码来实现这一点：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A few things to note here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意以下几点：
- en: We do not validate the token, nor do we check whether it is expired. This is
    the role of the BookmarkrSyncr external service.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们既不验证令牌，也不检查它是否已过期。这是 BookmarkrSyncr 外部服务的角色。
- en: The environment variable that is used to hold the PAT token is named `BOOKMARKR_PAT`.
    This name ensures that this variable does not conflict with any other variable
    set on the user’s computer.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 PAT 令牌的环境变量名为 `BOOKMARKR_PAT`。这个名字确保这个变量不会与用户计算机上设置的任何其他变量冲突。
- en: We have created a custom exception class, `PatNotFoundException`, to inform
    the client in case the PAT token has not been found.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义异常类 `PatNotFoundException`，以便在找不到 PAT 令牌时通知客户端。
- en: 'Now, since the PAT token is retrieved, we need to send it to the external service.
    We hence need to modify the HTTP client to pass the token in the HTTP headers
    of the request, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于已经检索到 PAT 令牌，我们需要将其发送到外部服务。因此，我们需要修改 HTTP 客户端，以便在请求的 HTTP 标头中传递令牌，如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the request to the external service is successful, we know that the PAT
    token is valid. We will then save it to the environment variable if it is not
    already present there. The updated code is therefore as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对外部服务的请求成功，我们知道 PAT 令牌是有效的。如果它尚未存在于那里，我们将将其保存到环境变量中。因此，更新的代码如下：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, if the PAT token is invalid or expired, we need to inform the client
    so that the proper error message is displayed to the user. We therefore need to
    modify the code block that handles the `Unauthorized` status code, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 PAT 令牌无效或已过期，我们需要通知客户端，以便向用户显示适当的错误消息。因此，我们需要修改处理 `Unauthorized` 状态码的代码块，如下所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is straightforward and easy to understand. One thing worth mentioning
    though is that here, again, we created custom exception classes, namely `PatInvalidException`
    and `PatExpiredException`, to clearly express the intent of an error when raising
    them. These exception classes can be found in the `Exceptions.cs` file located
    in the `BookmarkrSyncrServiceAgent` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单易懂。不过，值得一提的是，我们在这里又创建了自定义异常类，即 `PatInvalidException` 和 `PatExpiredException`，以便在抛出它们时清楚地表达错误意图。这些异常类可以在
    `BookmarkrSyncrServiceAgent` 文件夹中的 `Exceptions.cs` 文件中找到。
- en: 'The last step is to go back to the `SyncCommand` class, handle the responses
    from the service agent, and display the appropriate error messages to the user.
    For that matter, we need to modify the code of the `OnSyncCommand` handler method
    to catch the custom exceptions described previoulsy. The `catch` blocks are as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是回到 `SyncCommand` 类，处理服务代理的响应，并向用户显示适当的错误消息。为此，我们需要修改 `OnSyncCommand` 处理方法中的代码，以捕获之前描述的自定义异常。`catch`
    块如下：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And that’s it – we have completed all the required code modifications for Bookmarkr
    to ensure secure communication with the external service, BookmarkrSyncr, by using
    a PAT (it was about time, right? 😉).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样 – 我们已经完成了 Bookmarkr 为确保通过 PAT（it was about time, right? 😉）与外部服务 BookmarkrSyncr
    安全通信所需的所有代码修改。
- en: Let’s see if this works!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这行不行！
- en: 'The first test is to invoke the `sync` command without passing a PAT token.
    Knowing that it will not be found in the `BOOKMARKR_PAT` environment variable,
    the following error is expected:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试是不传递 PAT 令牌调用 `sync` 命令。鉴于它不会在 `BOOKMARKR_PAT` 环境变量中找到，我们预期会看到以下错误：
- en: '![Figure 13.4 – The PAT token was not found](img/B22400_13_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 未找到 PAT 令牌](img/B22400_13_04.jpg)'
- en: Figure 13.4 – The PAT token was not found
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 未找到 PAT 令牌
- en: 'The second test is to invoke the `sync` command with an invalid PAT token.
    Here too, an error message is expected:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试是使用无效的 PAT 令牌调用 `sync` 命令。这里也预期会看到一个错误消息：
- en: '![Figure 13.5 – The PAT token is invalid](img/B22400_13_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – PAT 令牌无效](img/B22400_13_05.jpg)'
- en: Figure 13.5 – The PAT token is invalid
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – PAT 令牌无效
- en: 'The next test is to invoke the `sync` command with an expired PAT token. Here
    too, an error message is expected:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是使用过期的 PAT 令牌调用 `sync` 命令。这里也预期会看到一个错误消息：
- en: '![Figure 13.6 – The PAT token is expired](img/B22400_13_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – PAT 令牌已过期](img/B22400_13_06.jpg)'
- en: Figure 13.6 – The PAT token is expired
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – PAT 令牌已过期
- en: 'The final test is to invoke the `sync` command with a valid PAT token. We can
    see that the bookmarks have been synchronized and that the PAT token has been
    saved to the `BOOKMARKR_PAT` environment variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试是使用有效的 PAT 令牌调用 `sync` 命令。我们可以看到书签已经同步，并且 PAT 令牌已保存到 `BOOKMARKR_PAT` 环境变量中：
- en: '![Figure 13.7 – The PAT token is valid](img/B22400_13_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – PAT 令牌有效](img/B22400_13_07.jpg)'
- en: Figure 13.7 – The PAT token is valid
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – PAT 令牌有效
- en: Wonderful! We now know all we need to know to assess and enhance the security
    of our CLI applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经知道所有需要了解的知识和技能来评估和增强我们的 CLI 应用程序的安全性。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various forms security can take, and we learned
    that it is not limited to the security of the application’s code but rather covers
    a broad spectrum of areas that span its entire lifecycle. We learned what tools
    and techniques we can use to assess and enhance the security posture of our CLI
    application. We also learned how to secure access to user data, especially when
    dealing with external services, by implementing authentication and authorization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了安全可以采取的各种形式，并了解到它不仅限于应用程序代码的安全性，而是涵盖了整个生命周期中的广泛领域。我们学习了我们可以使用哪些工具和技术来评估和增强我们的
    CLI 应用程序的安全状况。我们还学习了如何通过实现身份验证和授权来保护用户数据的访问，尤其是在处理外部服务时。
- en: Congratulations! You have now all the necessary knowledge and skills to build,
    secure, test, package, and release your very own CLI applications to the world.
    Look at you – what a milestone you have achieved. Take a moment to be proud of
    yourself and to celebrate!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在拥有了构建、安全、测试、打包和发布您自己的 CLI 应用程序到世界上的所有必要知识和技能。看看你——你取得了多么大的成就。花点时间为自己感到自豪，并庆祝一下！
- en: My journey with you, throughout the pages of this book, is almost over. But
    before you turn the last page and gently close the cover of this book, there is
    one last thing I wanted to share with you, one final chapter whose purpose is
    to provide you with additional learning material to help you continue your journey
    as well as pointing you to some useful tools and libraries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的每一页上，与您的旅程一起，我的旅程几乎结束了。但在您翻到最后一页并轻轻合上这本书的封面之前，我还有最后一件事想与您分享，那就是一个最后的章节，其目的是为您提供额外的学习材料，帮助您继续您的旅程，并指向一些有用的工具和库。
- en: Your turn!
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提供的代码进行实践是学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是挑战自己完成任务。因此，我挑战您通过添加以下功能来改进 Bookmarkr 应用程序。
- en: 'Task #1 – Update dependency versions'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 更新依赖项版本'
- en: We have seen how to list outdated packages that have reached their end of support
    and talked about the importance of updating these. However, I haven’t updated
    these.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何列出已达到其支持结束的过时包，并讨论了更新这些包的重要性。然而，我还没有更新这些。
- en: Your task is to clone the code into your GitHub or Azure DevOps account and
    to update it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是将代码克隆到您的 GitHub 或 Azure DevOps 账户中，并更新它。
- en: Once the dependencies have been updated, you will need to validate that the
    behavior of the application was not impacted, in other words, you need to ensure
    that the application still behaves as expected. This can be done by running the
    tests you developed earlier.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦依赖项已更新，您需要验证应用程序的行为是否受到影响，换句话说，您需要确保应用程序仍然按预期运行。这可以通过运行您之前开发的测试来完成。
- en: 'Task #2 – Use Mend Bolt to scan the code for vulnerabilities'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 使用 Mend Bolt 扫描代码中的漏洞'
- en: Your task is to clone the code into your GitHub or Azure DevOps account, enable
    Mend Bolt, and run a security scan. If any vulnerability is to be found, fix it!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是将代码克隆到您的 GitHub 或 Azure DevOps 账户中，启用 Mend Bolt，并运行安全扫描。如果发现任何漏洞，请修复它！
- en: 'Task #3 – Allow BookmarkrSyncr to manage multiple users'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #3 – 允许 BookmarkrSyncr 管理多个用户'
- en: Although we updated BookmarkrSyncr to receive and validate a PAT, it does not
    use this token to retrieve and update the appropriate user’s data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们更新了 BookmarkrSyncr 以接收和验证 PAT，但它并没有使用此令牌来检索和更新适当用户的数据。
- en: You are tasked to update the code to make this happen. The easiest way to achieve
    this is to have a separate JSON file for every user whose name matches the value
    of the PAT. Hence, the bookmarks for every user can be stored and retrieved from
    there.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是更新代码以实现这一点。最简单的方法是为每个与 PAT 值匹配名称的用户创建一个单独的 JSON 文件。因此，每个用户的书签都可以存储和检索于此。
