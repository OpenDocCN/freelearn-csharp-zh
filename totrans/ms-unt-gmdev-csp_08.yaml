- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Optimized User Interfaces with C# for Unity Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074), where we will learn
    how to optimize **user interfaces** (**UIs**) for our Unity games using the versatile
    capabilities of C#. This chapter equips you with practical skills to enhance the
    performance of your UI and ensure a smooth user experience. The first skill focuses
    on utilizing C# for efficient UI optimization, maximizing the performance of your
    UI elements. Following this, we delve into strategies for creating an optimized
    UI system in C#, providing insights into structuring and managing views effectively.
    Throughout this chapter, the presented system acts as a flexible framework, allowing
    you to customize and optimize UI elements based on your game’s unique requirements.
    Let’s dive into the world of optimized UIs, leveraging the power of C# to refine
    the performance and functionality of your Unity game interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing UI design in gaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices and optimizing techniques for UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI system using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing UI design in gaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the exciting world of making games, the UI is like the link between the
    player and the cool virtual world made by game creators. UI design isn’t just
    about making things look good; it’s super important in shaping how players experience
    the game. This section talks about why UI design is a big deal in games and how
    it really affects how much players get into the game and how much they like it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **first impression**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of the UI as the first hello between the game and the player. A well-made
    UI grabs attention, sets the vibe, and makes the game look and feel unique. Whether
    you’re on the main menu or playing the game, every part adds up to the first feeling
    you get when you start playing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Enhancing** **player immersion:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a game should feel like you’re right there in the action. A well-thought-out
    UI blends smoothly with the game, so you stay focused on playing without getting
    distracted. Whether it’s cool movements, matching themes, or easy controls, the
    UI becomes a big part of the game’s story.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Guiding** **user interaction:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI is like a helpful guide showing players what to do in the game. From
    health bars to markers for quests, each thing gives important information without
    confusing players. Making the UI clear and simple is super important so that players
    can think about their moves and the tricky parts of the game, not figuring out
    the buttons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Impact on** **player engagement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UI that’s easy to understand and looks good really keeps players interested.
    If moving around menus is smooth and the game responds well, players want to spend
    more time playing. On the flip side, a badly made UI can make players frustrated,
    not want to play, and ruin the fun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adapting to** **diverse platforms:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we play games on all kinds of devices now, the UI has to work well on
    everything. It’s like speaking different languages for each device, making sure
    the game feels right no matter whether you’re using a computer, console, or phone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Making the UI in games is like finding the right mix of making things look good
    and work well. It’s about picking colors and fonts, how things are spaced out,
    and also making sure everything runs smoothly. Using C# in Unity lets game makers
    use these cool design ideas and make interfaces that not only look awesome but
    also do their job well.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we’ll check out the basic ideas behind UI design
    and see how C# can help make really great UIs that make playing games even more
    awesome.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to best practices and optimization techniques for UIs, we’ll explore
    strategies to enhance UI performance and responsiveness next.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and optimization techniques for UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to talk about some optimization techniques for
    UIs along with some best practices to have a better performance. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up Canvases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue**: *Modifying a single element on the UI Canvas triggers a complete
    Canvas refresh,* *impacting performance.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity UI relies on the Canvas as its fundamental component. It creates meshes
    representing UI elements, refreshes these meshes when there are changes, and sends
    draw calls to the GPU for actual UI display.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh generation is resource-intensive, requiring UI Elements to be grouped into
    batches for efficiency in draw calls. Due to the cost of batch regeneration, it’s
    essential to minimize unnecessary refreshes. The challenge arises when even a
    single element changes on a Canvas, prompting a full Canvas re-evaluation to determine
    the optimal way to redraw its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Many users construct their entire game’s UI on a single Canvas with numerous
    elements. Altering just one element can lead to a significant CPU spike, consuming
    multiple milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Divide your Canvases.'
  prefs: []
  type: TYPE_NORMAL
- en: Each Canvas functions as an independent entity, segregating its elements from
    those on other Canvases. Leverage the Unity GUI’s support for multiple Canvases
    by segmenting your Canvases, addressing the batching challenges within Unity UI.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Canvases offer another solution, enabling the creation of complex hierarchical
    UIs without the need to consider the spatial arrangement of elements across Canvases.
    Child Canvases additionally insulate content from both their parent and sibling
    Canvases. They maintain individual geometry and conduct independent batching.
    An effective strategy for segmentation is based on the refresh frequency of elements.
    Place static UI Elements on a distinct Canvas, reserving smaller sub-Canvases
    for dynamic elements that update simultaneously. Additionally, ensure uniformity
    in Z values, materials, and textures for all UI Elements on each Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, let me illustrate with an example. We’ll set up a Canvas for the
    overall scene and, within this main canvas, each panel will function as an individual
    Canvas. This means that when we make updates, such as to the HUD canvas during
    gameplay, we won’t be affecting the **Pause** panel or any other panels. It’s
    crucial to ensure that every panel or view has its dedicated canvas component,
    preventing performance issues when updates are applied.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the division of the gameplay scene canvases into
    smaller sub-canvases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – GamePlayCanvas hierarchy](img/B22017_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – GamePlayCanvas hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the **GamePlayCanvas** which contains all canvases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – GamePlayCanvas GameObject](img/B22017_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – GamePlayCanvas GameObject
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the **PauseCanvas** which is a child of **GamePlayCanvas**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – PauseCanvas GameObject](img/B22017_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – PauseCanvas GameObject
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding too many Graphic Raycasters and turning off Raycast Target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue #1**: *Not using Graphic* *Raycaster well*'
  prefs: []
  type: TYPE_NORMAL
- en: The **Graphic Raycaster** helps with turning your clicks or taps on the screen
    into things the game understands. It’s like a translator between your actions
    and the game’s UI, figuring out what you’re touching and sending that information
    to the right parts of the game. You need this thing on every screen that needs
    your touch, even on smaller screens inside the big one. But it goes through all
    the places you touch on the screen and checks whether they’re inside a UI’s area,
    which can be a bit much.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it’s called a Graphic Raycaster, it doesn’t exactly cast rays. By
    default, it only cares about UI graphics. It looks at all the UI parts that want
    to know when you touch them and checks whether the spot where you touch matches
    up with the UI parts that are set up to respond.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that not all UI parts want to be bothered when you touch them.
  prefs: []
  type: TYPE_NORMAL
- en: '`Image` component – we only turn it off for images that you can’t interact
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – RayCast Target variable](img/B22017_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – RayCast Target variable
  prefs: []
  type: TYPE_NORMAL
- en: '**Issue #2**: *Sometimes the Graphic Raycaster does more than just* *translate
    touches.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you set **Render Mode** on your Canvas to **Worldspace Camera** or **Screen
    Space Camera**, a blocking mask can be added. This mask determines whether the
    Raycaster will cast rays using 2D or 3D physics, determining whether any physics
    object obstructs the user’s ability to interact with the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Casting rays via 2D or 3D physics can be resource-intensive,
    so use this feature judiciously. To minimize the number of Graphic Raycasters,
    exclude them from non-interactive UI Canvases since, in such cases, there is no
    need to check for interaction events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the **Graphic** **Raycaster** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Graphic Raycaster component](img/B22017_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Graphic Raycaster component
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently managing UI object pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue**: *Inefficient practices in UI* *object pooling*'
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, individuals engage in pooling UI objects by first changing their
    parent and then disabling them, resulting in unnecessary complications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Optimize for deactivating the object first before reassigning
    its parent within the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: This strategy ensures that the original hierarchy is dirtied only once. Once
    the object is reparented, there’s no need for an additional round of hierarchy
    changes, and the new hierarchy remains unaffected. When extracting an object from
    the pool, follow the sequence of reparenting it first, updating your data, and
    then activating it to maintain efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding a Canvas the right way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue**: *Uncertain about efficiently hiding* *a Canvas*'
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you want to keep UI Elements and Canvases out of sight.
    But how can you achieve this in an effective manner?
  prefs: []
  type: TYPE_NORMAL
- en: '`Canvas` component itself.'
  prefs: []
  type: TYPE_NORMAL
- en: By disabling the `Canvas` component, you stop the generation of draw calls to
    the GPU, rendering the Canvas invisible. Importantly, the Canvas retains its vertex
    buffer, preserving all meshes and vertices. Consequently, re-enabling it doesn’t
    trigger a rebuild; it simply resumes drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, deactivating the `Canvas` component avoids initiating the resource-intensive
    `OnDisable`/`OnEnable` callbacks within the Canvas hierarchy. Just exercise caution
    when disabling child components that execute computationally demanding per-frame
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient implementation of animations for UI Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue**: *Implementing animators on* *the UI*'
  prefs: []
  type: TYPE_NORMAL
- en: When animators are applied to the UI, they consistently affect UI Elements in
    every frame, even when the animation value remains constant.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Employ code for UI animation.'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict the use of animators to dynamic UI Elements that undergo constant changes.
    For elements that infrequently change or experience temporary alterations triggered
    by events, opt for coding your animations or utilizing a tweening system, a system
    you can make through code or you can use third-party assets for that. Various
    effective solutions for this purpose can be found on the Unity Asset Store. For
    our game, we will use the free `DoTween` package for this.
  prefs: []
  type: TYPE_NORMAL
- en: Effective handling of fullscreen UIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Issue**: *Performance issues with* *fullscreen UIs*'
  prefs: []
  type: TYPE_NORMAL
- en: When a pause or start screen occupies the entire display, the remaining elements
    of the game continue rendering in the background, potentially leading to performance
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Hide everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: If you present a screen that overlays the entire scene, deactivate the camera
    responsible for rendering the 3D scene. Likewise, disable Canvas elements positioned
    beneath the top Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Contemplate reducing `Application.targetFrameRate` when engaging a fullscreen
    UI, as there is no necessity for updates at a **60** **fps** rate.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood the best practices and optimization techniques for
    the UI, let’s move on to the next section where we will explore some architectural
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing architecture patterns (MVC and MVVM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of game development, organizing and managing the UI is crucial
    for creating engaging and efficient experiences. Two widely used architectural
    patterns – namely, **Model-View-Controller** (**MVC**) and **Model-View-ViewModel**
    (**MVVM**) – provide frameworks for structuring UI elements in a way that enhances
    clarity and maintainability. MVC separates the application into three interconnected
    components — the **model** for data and logic, the **view** for the user interface,
    and the **controller** for managing user input. On the other hand, MVVM introduces
    **ViewModel** as a mediator between the model and the view, simplifying presentation
    logic and data binding, which is the automatic synchronization of data between
    the UI and the underlying data model in software applications. In this section,
    we will explore the practical application of these patterns in Unity game development,
    offering insights and guidance to help you make informed decisions about structuring
    your game’s UI.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MVC – a teamwork of three roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following figure, you can see the arrangement of the MVC pattern and
    how its components interact.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – MVC structure](img/B22017_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – MVC structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand a little bit more about the MVC structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the data and business logic of the application'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: Often implemented as **ScriptableObject** or regular
    C# class instances'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Manages data, enforces business rules, and communicates changes to
    the view'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the UI elements, responsible for displaying data to the
    user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: Comprises Unity UI components, such as **Canvas**,
    **Text**, **Image**, and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Renders the data from the model and handles user input interactions,
    forwarding them to the controller'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Acts as an intermediary between the model and the view, handling
    user input and updating the model and view accordingly'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: A **MonoBehaviour** script attached to Unity UI elements
    or game objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Listens for user input, updates the model, and instructs the view to
    reflect changes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction flow**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User input*: Captured by the controller'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Model update*: The controller updates the model based on user input'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*View update*: The view receives notifications from the model and updates the
    UI accordingly'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros** **in Unity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simplicity*: Well suited for smaller projects and straightforward UI structures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity compatibility*: Aligns seamlessly with Unity’s built-in UI system'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons** **in Unity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Potential complexity*: May lead to increased complexity as the project grows'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data binding challenges*: Achieving efficient data binding might require additional
    effort'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to understanding the next architectural pattern, MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MVVM – a mix of views and models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the arrangement of the MVVM pattern and
    how its components interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – MVVM structure](img/B22017_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – MVVM structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand a little bit more about the MVVM structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the data and business logic, similar to MVC'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: **ScriptableObject** or regular C# class instances,
    much like in MVC'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Manages data, enforces business rules, and communicates changes to
    the view'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Represents the UI, responsible for displaying data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: Unity UI components, same as in MVC'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Renders the data from the model and handles user input interactions,
    forwarding them to the controller'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essence*: Acts as an intermediary between the model and the view, exposing
    properties and commands'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity implementation*: A **MonoBehaviour** script that facilitates data binding'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Role*: Simplifies data binding by exposing data and logic for the view to
    bind to directly'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction flow**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User input*: Captured by the view or directly by the ViewModel'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Model update*: The ViewModel updates the model based on user input'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*View update*: When data changes occur in the model, they automatically update
    the view through data binding'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros** **in Unity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enhanced data binding*: Streamlines the process of updating the UI in response
    to changes in the underlying data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testability*: ViewModel components can be tested independently, fostering
    maintainability'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons** **in Unity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning curve*: May pose a learning curve for developers unfamiliar with
    the pattern'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overhead of abstraction*: Introducing an additional layer with the ViewModel
    might be considered over-engineering for smaller projects'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand what MVC and MVVM are, let’s explore how to decide between
    them for our project based on certain factors.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right path for Unity UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points explain why we would choose MVC in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-established compatibility**: Unity’s built-in UI system aligns naturally
    with the principles of MVC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity for smaller projects**: For smaller projects or when simplicity
    is crucial, MVC can be a pragmatic choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following points explain why we would choose MVVM in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data-driven complexity**: MVVM shines in scenarios demanding efficient data
    binding and complex UI structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling for larger projects**: MVVM facilitates scalability and maintainability,
    making it a robust choice for larger endeavors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following points will help you select your approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consider project size**: MVC’s simplicity may be advantageous for smaller
    projects, while MVVM’s enhanced data binding and testability are beneficial for
    larger endeavors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluate data binding needs**: If efficient data binding is crucial, MVVM
    might be the preferred choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The journey through Unity UI development is a dynamic exploration, guided by
    the architectural choices of MVC and MVVM. While MVC offers simplicity and familiarity,
    MVVM introduces a layer of abstraction, elevating data binding and testability.
    As you navigate the Unity UI architecture, consider the specific needs of your
    project, the complexity of your UI, and the familiarity of your development team.
    Whether adhering to the clarity of MVC or embracing the sophistication of MVVM,
    the path you choose defines not only the structure of your UI but also the foundation
    of an immersive player experience. For our game, we will go with the MVC structure.
  prefs: []
  type: TYPE_NORMAL
- en: Practical suggestions for enhancing your UI development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some tips that can be beneficial for you while working on UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create Prefabs for the most frequently used elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this, consider using the title text as an example and attaching components
    to it. This makes it easier to implement changes later, as any modifications will
    impact all the elements in the game. Additionally, you can create images and any
    other UI elements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use Sprite Atlases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sprite Atlas is a feature in Unity that allows you to pack multiple Sprite
    textures into a single texture asset. This is particularly useful for optimizing
    and improving the performance of your game, as it reduces the number of draw calls
    by combining multiple Sprites into one texture.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some key points about Sprite Atlas in Unity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Draw call optimization**: By using Sprite Atlases, Unity can efficiently
    render multiple Sprites with a single draw call, which can significantly improve
    performance, especially on mobile devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping textures**: Sprite Atlases enable you to group multiple Sprites
    or textures together, making it easier to manage and organize your game assets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture packing**: Unity’s Sprite Atlas system performs automatic texture
    packing, arranging individual Sprites within the Atlas to minimize wasted space
    and optimize texture usage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mipmapping**: Sprite Atlases support mipmapping, which helps improve the
    rendering quality of textures when they are viewed from a distance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atlas variants**: Unity allows you to create different variants of Sprite
    Atlases for different platforms or screen resolutions, ensuring optimal performance
    across various devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with Unity Editor**: You can create and manage Sprite Atlases
    directly within the Unity Editor, making it convenient for game developers to
    visualize and adjust their assets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Design alignment using a transparent image overlay:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When provided with a designer’s view sample, you can overlay an image representing
    the final result with slight transparency. This allows you to align and organize
    the view according to the design.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the UI Extensions package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Discover the UI Extensions package, a valuable toolkit that significantly amplifies
    the capabilities of Unity’s native UI system. Here’s an overview of its key features:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensive controls**: With over 70 additional UI controls, it offers advanced
    text fields (auto-complete, password masking, multi-line), sliders, progress bars,
    checkboxes, toggles, color pickers, dropdowns, list views, tree views, grids,
    tooltips, modal windows, context menus, toolbars, docking panels, and more.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization flexibility**: Enjoy extensive customization options for existing
    UI elements, including the addition of shadows, outlines, and other visual effects,
    animation of properties (position, color, size), and the creation of custom layouts
    and interactions.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility functions**: Benefit from various helpful utility functions for easy
    alignment and positioning of elements. Moreover, discover a shortcut for anchoring
    elements to corners, particularly useful for managing multiple resolutions, especially
    in mobile games.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This package provides a robust set of tools and features, making UI development
    in Unity more flexible and efficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we understand practical tips and architectural pattern (MVC and MVVM)
    structures, let’s dive into creating a UI system using C# to efficiently handle
    UI behavior in our Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI system using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a C# system for handling UI behavior, leveraging
    optimization tips and the MVC structure to achieve our objectives. This involves
    creating a `UIManager` class to oversee views, a `BaseView` class containing core
    view logic, and a practical example demonstrating the implementation of the UI
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The UIManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To kick off this system, we’ll establish a base class called `UIManager`. This
    class will handle the invocation of `show` and `hide` functions for views and
    will act as a container for all the views. For each scene, we’ll create a child
    of `UIManager`, responsible for controlling the views within that specific scene.
    This scene-specific manager will hold all the views, providing us with better
    control over them. This setup allows us to hide all views, ensuring that only
    one view is active at a time, which is advantageous for performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block provides a sample of the `UIManager` base class, which
    includes generic functions for showing and hiding views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we employed generic functions to handle the showing
    and hiding of views based on their type directly, avoiding the use of strings
    for improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by registering the view and adding it to the dictionary, enabling us
    to hide or show it throughout the gameplay session. Additionally, we have functions
    to retrieve the view when needed, allowing access or performing specific actions
    on that view.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing UIManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To utilize this class, we can create child classes for each scene and either
    attach this component to a GameObject or simply place it on the main canvas of
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'As evident in the upcoming code block, we have `HUDManager`, which inherits
    from `UIManager`. We will attach it to the main canvas of the gameplay scene to
    manage and control all views associated with this scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, you’ll notice the `HUDManager` component connected
    to the main canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The HUDManager component](img/B22017_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The HUDManager component
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can proceed to the other key component of the UI system, which is the
    `BaseView` class.
  prefs: []
  type: TYPE_NORMAL
- en: The BaseView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the UI system, we require a foundational class for all views, encompassing
    core functions that define the view’s behavior, actions, or logic during `hide`
    and `show` operations. While the UI manager is responsible for invoking these
    functions, the underlying logic resides in the base class. We predominantly utilize
    `hide` and `show` canvas processes for efficiency, and for animations during these
    operations, we leverage the `DoTween` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, you’ll find the `BaseView` class along with its
    core functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseView` class serves as a foundational element within our UI system,
    facilitating essential functionalities crucial for managing views in Unity projects.
    At its core, this class offers methods to both show and hide views seamlessly.
    Moreover, it seamlessly integrates with `tween` components, enabling the application
    of animations during view transitions. Beyond its fundamental functions, the `BaseView`
    class provides a suite of auxiliary methods, offering invaluable support for implementing
    the intricate logic of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the functionality of the `BaseView` class, let’s proceed
    to grasp the functionality of the `UITween` component, which is utilized for animating
    the views.
  prefs: []
  type: TYPE_NORMAL
- en: The UITween component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UITween` component serves as a wrapper that I’ve created for utilizing
    `DoTween`, simplifying the process of adding and removing animations in the Inspector
    for showing or hiding views.
  prefs: []
  type: TYPE_NORMAL
- en: You can locate all of these classes and additional resources in the GitHub repository,
    the link to which is mentioned in the Technical requirements section.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, you’ll observe the `UITween` component. This serves
    as a sample class, and we can adjust it to suit our game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The UITween component](img/B22017_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The UITween component
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing BaseView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To utilize the `BaseView` class, all you need to do is create a child class
    for each view in the game, enabling the use of core functions. Afterward, you
    can incorporate specific logic for each view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, you’ll see an example of the `BaseView` class
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `TopBar` class, functioning as a view class, will be responsible for displaying
    elements such as the player’s currency in the game. Simply attach the `TopBar`
    class to a `TopBar` Canvas GameObject in your game scene, and you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you’ll observe the `TopBarView` component attached
    to its canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The TopBarView component](img/B22017_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The TopBarView component
  prefs: []
  type: TYPE_NORMAL
- en: This system serves as an abstract framework for the UI system, providing a foundation
    that can be customized or extended with additional logic as needed for the game.
    Feel free to tailor and expand upon this structure according to the specific requirements
    of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take an example to see how MVVM would be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing the MVVM structure in Unity involves separating the logic and data
    management from the UI elements. Let’s look at an example implementation of MVVM
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, `PlayerData` represents the data structure, such
    as player level and score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, `PlayerViewModel` acts as an intermediary between
    the model and the view. It holds the logic for data manipulation and exposes properties
    that the view can bind to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, `PlayerView` represents the UI elements and is
    responsible for displaying data from `ViewModel`. It subscribes to `ViewModel`
    events and updates UI elements based on changes in `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This structure allows for a clear separation of concerns, with `ViewModel` handling
    the logic and data manipulation while the view focuses solely on UI representation.
    Data binding ensures that changes in `ViewModel` automatically reflect in the
    view, promoting a more organized and maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to improve our game interfaces using C#. We
    started by getting better at making the parts of the UI work faster. Then, we
    figured out ways to organize and control the different views in our game. The
    skills you picked up here gave you the tools to make your UI look good and run
    smoothly based on what your game needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), we’ll dive
    into handling game data using C#. We’ll learn how to organize and save game information
    in Unity. These skills will help us manage game progress, save and load game states,
    and create features that use stored data. As you continue on this coding adventure,
    you’ll discover new ways to handle game data effectively with C#. Get ready for
    more coding challenges in the upcoming chapter. Happy coding!
  prefs: []
  type: TYPE_NORMAL
