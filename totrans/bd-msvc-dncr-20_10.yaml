- en: Creating a Complete Microservice Solution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建完整的微服务解决方案
- en: 'On our journey down the lane of understanding microservices and their evolution,
    we continued through various phases. We explored what led to the advent of microservices
    and the various advantages of utilizing them. We also discussed various integration
    techniques and testing strategies. Let''s recap all that we have talked about
    thus far:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解微服务和它们演变的旅程中，我们经历了各种阶段。我们探讨了导致微服务出现的原因以及利用它们的各种优势。我们还讨论了各种集成技术和测试策略。让我们回顾一下到目前为止我们所讨论的内容：
- en: Testing microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试微服务
- en: Security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Monitoring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Scaling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展性
- en: Reactive microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式微服务
- en: Architectures before microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之前的架构
- en: Microservices were never designed from the ground up to be in the present form.
    Instead, there has been a gradual transition from other forms of prevalent architecture
    styles to microservices. Prior to microservices, we had the monolithic architecture
    and service-oriented architecture that reigned over the world of enterprise development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务并非从一开始就被设计成现在的形式。相反，它们是从其他流行的架构风格逐渐过渡到微服务的。在微服务之前，我们有单体架构和统治企业开发世界的面向服务的架构。
- en: Let's delve into these two before doing a quick recap of microservices and their
    various attributes and advantages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速回顾微服务和它们的各种属性和优势之前，让我们深入探讨这两者。
- en: The monolithic architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: 'The monolithic architecture has been around for quite some time and it results
    in self-contained software with a single .NET assembly. It consists of the following
    components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构已经存在很长时间了，它导致了具有单个.NET组件的自包含软件。它包括以下组件：
- en: User interface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: Business logic
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: Database access
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问
- en: 'The cost paid for being self-contained was that all the components were interconnected
    and interdependent. A minor change in any module had the capability to impact
    the entire piece of software. With all the components so tightly coupled in this
    manner, it made testing the entire application necessary. Also, another repercussion
    of being so tightly coupled was that the entire application had to be deployed
    once again. Let''s sum up all the challenges we faced as a result of adopting
    this style of architecture:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现自包含而付出的代价是所有组件都是相互关联和相互依赖的。任何模块的微小变化都有可能影响整个软件。由于所有组件以这种方式紧密耦合，因此测试整个应用程序是必要的。此外，由于如此紧密耦合，整个应用程序必须重新部署。让我们总结一下由于采用这种架构风格而面临的全部挑战：
- en: Large interdependent code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量相互依赖的代码
- en: Code complexity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性
- en: Scalability
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: System deployment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统部署
- en: Adoption of a new technology
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新技术的采用
- en: Challenges in standardizing the .NET stack
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化.NET堆栈的挑战
- en: Technology adoption is not easy when it comes to monolithic. It poses certain
    challenges. Security, response time, throughput rate, and technology adoption
    are some of them. It is not that this style of architecture does not fight back
    with solutions. The challenge is that in monolithic, code reusability is really
    low or absent, which makes technology adoption difficult.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到单体架构时，技术的采用并不容易。它带来了一定的挑战。安全性、响应时间、吞吐率和技术的采用就是其中的一些。并不是这种架构风格没有反击的解决方案。挑战在于，在单体架构中，代码的可重用性真的很低或者不存在，这使得技术的采用变得困难。
- en: Scaling
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展性
- en: 'We also discussed how scaling is a viable option but with diminishing returns
    and increasing expenses. Both vertical and horizontal scaling have their own pros
    and cons. Vertical scaling is seemingly easier to begin with: investing in IT
    infrastructures, such as RAM upgrades and disk drives. However, the return plateaus
    out very quickly. The disadvantage of the downtime required for vertical scaling
    doesn''t exist in horizontal scaling. However, beyond a point, the cost of horizontal
    returns becomes too high.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了扩展性是一个可行的选择，但回报递减且成本增加。垂直扩展和水平扩展都有各自的优缺点。垂直扩展似乎更容易开始：投资于IT基础设施，如内存升级和磁盘驱动器。然而，回报很快就会达到顶峰。垂直扩展所需的停机时间的不利因素在水平扩展中不存在。然而，超过某个点，水平扩展的成本变得过高。
- en: Service-oriented architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: Another widely used architecture in the industry was a **service-oriented architecture**
    (**SOA**). This architecture was a move away from the monolithic architecture
    and was involved in resolving some of its challenges, mentioned in the preceding
    section. To begin with, it was based on a collection of services. Providing a
    service was the core concept of SOA.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中广泛使用的另一种架构是面向服务的架构（**SOA**）。这种架构是从单体架构的转变，并涉及解决前述部分中提到的一些挑战。首先，它基于服务集合。提供服务是SOA的核心概念。
- en: A service is a piece of code, program, or software that provides some functionality
    to other system components. This piece of code was able to interact directly with
    the database or indirectly through other services. It was self-contained to the
    extent that it allowed services to be consumed easily by both desktop and mobile
    applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一段代码、程序或软件，它为其他系统组件提供某些功能。这段代码能够直接与数据库交互，或者通过其他服务间接交互。它在一定程度上是自包含的，使得服务可以轻松被桌面和移动应用程序消费。
- en: 'Some of the definite advantages that SOA provided over monolithic were:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SOA相对于单体架构提供的某些明确优势包括：
- en: Reusable
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Stateless
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Scalable
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Contract-based
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于合同
- en: Ability to upgrade
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级能力
- en: Microservice-styled architecture
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务风格架构
- en: 'Apart from some of the definite advantages of SOA, microservices provide certain
    additional differentiating factors that make them a clear winner. At the core,
    microservices were defined to be completely independent of other services in the
    system and run in their process. The attribute of being independent required a
    certain discipline and strategy in the application design. Some of the benefits they
    provide are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SOA的一些明确优势外，微服务还提供了一些额外的差异化因素，使它们成为明显的赢家。在核心上，微服务被定义为完全独立于系统中的其他服务，并在它们自己的进程中运行。独立的属性要求在应用程序设计中有一定的纪律和策略。它们提供的一些好处包括：
- en: 'Clear code boundaries: This resulted in easier code changes. Its independent
    modules provided an isolated functionality that led to a change in one microservice
    having little impact on others.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的代码边界：这导致了代码更改更加容易。其独立的模块提供了隔离的功能，导致一个微服务的更改对其他微服务的影响很小。
- en: 'Easy deployment: It is possible to deploy one microservice at a time if required.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于部署：如果需要，可以一次部署一个微服务。
- en: 'Technology adaptation: The preceding attributes led to  this much sought-after
    benefit. This allows us to adopt different technologies in different modules.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术适应性：上述属性导致了这一备受追求的益处。这使得我们能够在不同的模块中采用不同的技术。
- en: 'Affordable scalability: This allows us to scale only chosen components/modules
    instead of the whole application.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经济可扩展性：这允许我们仅扩展选定的组件/模块，而不是整个应用程序。
- en: 'Distributed system: This is implicit, but a word of caution is necessary here.
    Make sure that your asynchronous calls are used well and the synchronous ones
    don''t block the whole flow of information. Use data partitioning well. We will
    come to this a little later, so don''t worry for now.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统：这是隐含的，但在这里需要提醒一句。确保你的异步调用得到良好使用，而同步调用不会阻塞整个信息流。合理使用数据分区。我们稍后会提到这一点，所以现在不用担心。
- en: 'Quick market response: In a competitive world, this is a definite advantage
    as users tend to lose interest quickly if you are slow to respond to new feature
    requests or to adopt a new technology within your system.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速市场响应：在竞争激烈的世界中，这是一个明显的优势，因为用户如果对新功能请求或系统内采用新技术反应迟缓，往往会迅速失去兴趣。
- en: Messaging in microservices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的消息传递
- en: 'This is another important area that needs its share of discussion. There are
    primarily two main types of messaging utilized in microservices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要讨论的另一个重要领域。在微服务中主要使用两种主要类型的消息传递：
- en: Synchronous
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: Asynchronous
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步
- en: Monolith transitioning
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体过渡
- en: 'As part of our exercise, we decided to transition our existing monolithic application
    FlixOne to a microservice-styled architecture. We saw how to identify decomposition
    candidates within a monolith, based on the following parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们练习的一部分，我们决定将现有的单体应用程序FlixOne过渡到微服务风格的架构。我们看到了如何根据以下参数在单体中识别分解候选者：
- en: Code complexity
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性
- en: Technology adoption
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术采用
- en: Resource requirement
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源需求
- en: Human dependency
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人力资源依赖
- en: There are definite advantages it provides in regard to cost, security, and scalability,
    apart from technology independence. This also aligns the application more with
    the business goals.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术独立性之外，它还提供了在成本、安全和可扩展性方面的明确优势，这也使应用程序更符合业务目标。
- en: The entire process of transitioning requires you to identify seams that act
    like boundaries of your microservices along which you can start the separation.
    You have to be careful about picking up seams on the right parameters. We have
    talked about how module interdependency, team structure, database, and technology
    are a few probable candidates. Special care is required to handle master data.
    It is more a choice of whether you want to handle master data through a separate
    service or through configurations. You will be the best judge for your scenario.
    The fundamental requirement of a microservice having its own database is that
    it removes many of the existing foreign key relationships. This would bring forth
    the need to pick your transaction-handling strategy intelligently to preserve
    data integrity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 转变整个过程的步骤需要你识别出像微服务边界一样的缝隙，沿着这些缝隙你可以开始分离。你必须小心选择正确的参数来挑选缝隙。我们已经讨论了模块依赖性、团队结构、数据库和技术是一些可能的候选者。处理主数据需要特别注意。这更多的是一个选择，即你想要通过独立的服务还是通过配置来处理主数据。你将是判断你场景的最佳裁判。微服务拥有自己的数据库的基本要求是它消除了许多现有的外键关系。这将带来选择你的事务处理策略的智能需求，以保持数据完整性。
- en: Integration techniques
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成技术
- en: We have already explored synchronous and asynchronous ways of communication
    between microservices and discussed the collaboration style of the services. Those
    styles were request/response and event-based. Though request/response seems to
    be synchronous in nature, the truth is that it is the implementation that decides
    the outcome of the style of integration. Event-based style, on the other hand,
    is purely asynchronous.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了微服务之间的同步和异步通信方式，并讨论了服务的协作风格。这些风格包括请求/响应和基于事件的。尽管请求/响应在本质上看起来是同步的，但事实是，实现方式决定了集成风格的最终结果。另一方面，基于事件的风格则是完全异步的。
- en: When dealing with a large number of microservices, it is important that we utilize
    an integration pattern in order to facilitate complex interaction among microservices.
    We explored the API Gateway along with an event-driven pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量微服务时，我们利用集成模式来促进微服务之间复杂交互是很重要的。我们探讨了API网关以及事件驱动模式。
- en: 'API Gateway provides you with a plethora of services, some of which are as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: API网关为你提供了一系列服务，以下是一些：
- en: Routing an API call
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由API调用
- en: Verifying API keys, JWT tokens, and certificates
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证API密钥、JWT令牌和证书
- en: Enforcing usage quotas and rate limits
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制使用配额和速率限制
- en: Transforming APIs on the fly without code modifications
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不修改代码的情况下动态转换API
- en: Setting up caching backend responses
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置缓存后端响应
- en: Logging call metadata for analytic purposes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析目的记录调用元数据
- en: The event-driven pattern works by some services publishing their events and
    some subscribing to those available events. The subscribing services simply react
    independently of the event-publishing services, based on the event and its metadata.
    The publisher is unaware of the business logic that the subscribers would be executing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动模式通过一些服务发布它们的事件，而另一些服务则订阅这些可用的事件来实现。订阅服务简单地根据事件及其元数据独立于事件发布服务做出反应。发布者不知道订阅者将执行的业务逻辑。
- en: Deployment
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: Monolithic deployments for enterprise applications can be challenging for more
    than one reason. Having a central database, which is difficult to break down,
    only increases the overall challenge along with time to market.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业应用来说，单体部署可能由于多个原因而具有挑战性。拥有一个难以分解的中心数据库，不仅增加了整体挑战，还增加了上市时间。
- en: For microservices, the scenario is very different. The benefits don't just come
    by virtue of the architecture being microservices. Instead, it is the planning
    from the initial stages itself. You can't expect an enterprise-scale microservice to
    be managed without **continuous delivery** (**CD**) and **continuous integration**
    (**CI**). So strong is the requirement for CI and CD right from the early stages
    that without it the production stage may never see the light of day.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务来说，情况非常不同。好处并不仅仅来自于架构是微服务的事实。相反，它是从最初阶段就开始的计划。你不能期望一个企业规模的微服务在没有**持续交付**（**CD**）和**持续集成**（**CI**）的情况下得到管理。CI和CD的需求如此之强，以至于没有它们，生产阶段可能永远看不到光明。
- en: 'Tools such as CFEngine, Chef, Puppet, Ansible, and PowerShell DSC help you
    represent an infrastructure with code and let you easily make different environments
    exactly the same. Azure could be an ally here: the rapid and repeated provisioning
    required could easily be met.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CFEngine、Chef、Puppet、Ansible和PowerShell DSC等工具可以帮助你用代码表示基础设施，并让你轻松地使不同的环境完全相同。Azure在这里可以成为盟友：快速和重复的配置需求可以轻松满足。
- en: Isolation requirements could be met with containers far more effectively than
    their closest rival, virtual machines. We have already explored Docker as one
    of the popular candidates for containerization and have seen how to deploy it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其最接近的竞争对手虚拟机相比，容器可以更有效地满足隔离需求。我们已经探讨了Docker作为容器化的热门候选之一，并看到了如何部署它。
- en: Testing microservices
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试微服务
- en: We all know the importance of unit tests and why every developer should be writing
    them. Unit tests are a good means to verify the smallest functionality that contributes
    toward building larger systems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道单元测试的重要性以及为什么每个开发者都应该编写它们。单元测试是验证对构建更大系统有贡献的最小功能的好方法。
- en: However, testing microservices is not a routine affair like testing a monolith,
    since one microservice might interact with a number of other microservices. In
    that case, should we utilize the calls to the actual microservices to ensure that
    the complete workflow is working fine? The answer is no, as this would make developing
    a microservice dependent on another piece. If we do this, then the whole purpose
    of having a microservice-based architecture is lost. In order to get around this,
    we will use the mock-and-stub approach. This approach not only makes the testing
    independent of other microservices but also makes testing with databases much
    easier since, we can mock database interactions as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试微服务并不像测试单体那样是常规事务，因为一个微服务可能会与多个其他微服务交互。在这种情况下，我们应该利用对实际微服务的调用来确保整个工作流程运行良好吗？答案是否定的，因为这会使微服务的开发依赖于另一个部分。如果我们这样做，那么拥有基于微服务的架构的全部目的就丧失了。为了解决这个问题，我们将使用模拟和存根方法。这种方法不仅使测试独立于其他微服务，而且使测试数据库变得更加容易，因为我们还可以模拟数据库交互。
- en: Testing a small isolated functionality with a unit test or testing a component
    by mocking the response from an external microservice has its scope and it works
    well within that scope. However, if you are already asking yourself the question
    about testing the larger context, then you are not alone. Integration testing
    and contract testing are the next steps in testing microservices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试测试一个小型的隔离功能或通过模拟外部微服务的响应来测试一个组件，都有其适用范围，并且在该范围内工作良好。然而，如果你已经在思考如何测试更大的上下文，那么你并不孤单。集成测试和合约测试是测试微服务的下一步。
- en: In integration testing, we're concerned about external microservices and communicate
    with them as part of the process. For this purpose, we mock external services.
    We take this further with contract testing, where we test each and every service
    call independently and then verify the response. An important concept worth spending
    time on is consumer-driven contracts. Refer to Chapter 4, *Testing Strategies*,
    to study this in detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，我们关注外部微服务，并在测试过程中与之通信。为此，我们模拟外部服务。在合约测试中，我们更进一步，独立测试每一个服务调用，然后验证响应。一个值得花时间研究的重要概念是消费者驱动的合约。请参考第4章，*测试策略*，以详细了解这一内容。
- en: Security
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: The traditional approach of having a single point of authentication and authorization
    worked well in the monolithic architecture. However, in the case of microservices,
    you would need to do this for each and every service. This would pose a challenge
    of not only implementing it but keeping it synchronized as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，拥有单一认证和授权点的传统方法运作得很好。然而，在微服务的情况下，你需要为每个服务都这样做。这不仅会带来实施上的挑战，还会带来保持同步的挑战。
- en: The OAuth 2.0 authorization framework and the OpenID Connect 1.0 specifications
    combined together can solve the problem for us. OAuth 2.0 describes all the roles
    involved in the authorization process that meets our needs pretty well. We just
    have to make sure that the right grant type is picked up; otherwise, the security
    will be compromised. OpenID Connect authentication is built on top of the OAuth
    2.0 protocol.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权框架和OpenID Connect 1.0规范结合在一起可以解决我们的问题。OAuth 2.0详细描述了授权过程中涉及的所有角色，很好地满足了我们的需求。我们只需确保选择了正确的授权类型；否则，安全将受到威胁。OpenID
    Connect身份验证建立在OAuth 2.0协议之上。
- en: '**Azure Active Directory** (**Azure AD**) is one of the providers of OAuth
    2.0 and OpenID Connect specifications. It is understood here that Azure AD scales
    very well with applications and integrates well with any organizational Windows
    Server Active Directory.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Active Directory**（**Azure AD**）是OAuth 2.0和OpenID Connect规范的提供者之一。在这里理解到，Azure
    AD与应用程序的扩展性非常好，并且与任何组织的Windows Server Active Directory很好地集成。'
- en: As we have already discussed containers, it is important and interesting to
    understand that containers are very close to the host operating system's kernel.
    Securing them is another aspect that can't be overrated. Docker was the tool we
    considered, and it provides the necessary security by means of the least privilege
    principle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已讨论的容器，了解容器非常接近宿主操作系统的内核是很重要且有趣的。确保它们的安全是另一个不容忽视的方面。我们考虑的工具是Docker，它通过最小权限原则提供了必要的安全保障。
- en: Monitoring
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: The monolithic world has a few advantages of its own. Monitoring and logging
    is one of those areas where things are easier compared to microservices. The sheer
    number of microservices across which an enterprise system might be spread can
    be mind-boggling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单体世界有其自身的优势。监控和日志记录是那些与微服务相比更容易处理的领域之一。企业系统可能分布的微服务数量可能令人难以置信。
- en: As discussed in Chapter 1, *An Introduction to Microservices*, in the *Prerequisites
    for a microservice architecture* section, an organization should be prepared for
    the profound change. The monitoring framework was one of the key requirements
    for this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章中“微服务架构的先决条件”部分所讨论的，*《微服务简介》*，组织应该为这种深刻的变化做好准备。监控框架是这一需求的关键之一。
- en: 'Unlike a monolithic architecture, monitoring is very much required from the
    very beginning in a microservice-based architecture. There is a wide range of
    reasons why monitoring can be categorized:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体架构不同，在基于微服务的架构中，监控从一开始就非常必要。监控可以归类的理由有很多：
- en: 'Health: We need to preemptively know when a service failure is imminent. Key
    parameters, such as CPU and memory utilization, along with other metadata, could
    be a precursor to either the impending failure or just a flaw in the service that
    needs to be fixed. Just imagine an insurance company''s rate engine getting overloaded
    and going out of service or even performing slowly when a few hundred field executives
    try to share the cost with potential clients. Nobody likes to wait these days.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康性：我们需要预先知道何时服务故障即将发生。关键参数，如CPU和内存利用率，以及其他元数据，可能是即将发生的故障的先兆，或者是需要修复的服务中的缺陷。想象一下，当几百名现场执行董事试图与潜在客户分享成本时，保险公司的费率引擎过载并停止服务，或者运行缓慢。如今没有人喜欢等待。
- en: 'Availability: There might be a situation when the service may not perform extensive
    calculations, but the bare availability of the service itself might be crucial
    to the entire system. In such a scenario, I remember relying upon pings to listeners
    that would wait for a few minutes before shooting out emails to the system administrators.
    It worked for monoliths with one or two services to be monitored. However, with
    microservices, much more metadata comes into the picture.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：可能存在一种情况，服务可能不需要进行广泛的计算，但服务本身的可用性对整个系统可能至关重要。在这种情况下，我记得依赖于向等待几分钟的监听器发送ping，然后向系统管理员发送电子邮件。这对于只有一到两个服务需要监控的单一服务系统是有效的。然而，在微服务中，涉及更多的元数据。
- en: 'Performance: For platforms receiving high footfall, such as banking and e-commerce,
    availability alone does not deliver the service required. Considering the number
    of people converging at their platforms in very short spans, ranging from a few
    minutes to even tens of seconds, performance is not a luxury anymore. You need
    to know how the system is responding by means of data, such as concurrent users
    being served, and compare that with the health parameters in the background. This
    might provide an e-commerce platform with the ability to decide whether upgrades
    are required before the upcoming holiday season. For more sales, you need to serve
    a higher number of people.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：对于像银行和电子商务这样的高流量平台，仅仅保证可用性并不能提供所需的服务。考虑到在非常短的时间内（从几分钟到甚至几十秒）汇聚到平台的人数，性能不再是奢侈品。你需要通过数据来了解系统的响应情况，例如正在服务的并发用户数，并将其与后台的健康参数进行比较。这可能使电子商务平台能够在即将到来的假日季节之前决定是否需要升级。为了获得更多销售，你需要服务更多的人。
- en: 'Security: In any system, you can plan resilience only up to a specific level.
    No matter how well designed a system is, there will be thresholds beyond which
    the system will falter, which can result in a domino effect. However, having a
    thoughtfully designed security system in place could easily avert DoS and SQL
    Injection attacks. This would really matter from system-to-system when dealing
    with microservices. So think ahead and think carefully when setting up trust levels
    between your microservices. The default strategy that I have seen people utilizing
    is securing the endpoints with microservices. However, covering this aspect increases
    your system''s security and is worth spending some time on.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：在任何系统中，你只能计划到一定程度的弹性。无论系统设计得多好，总会有系统无法承受的阈值，这可能导致连锁反应。然而，拥有一个精心设计的网络安全系统可以轻松避免拒绝服务（DoS）和SQL注入攻击。当处理微服务时，这一点在系统之间非常重要。因此，在设置微服务之间的信任级别时，要提前思考和仔细考虑。我看到的默认策略是使用微服务来保护端点。然而，覆盖这一方面可以提高系统的安全性，值得花些时间。
- en: 'Auditing: Healthcare, financing, and banking are a few of the domains that
    have the strictest compliance standards concerning associated services. And it
    is pretty much the same the world over. Depending upon the kind of compliance
    you are dealing with, you might have a requirement to keep the data for a specific
    period of time as a record, keep the data in a specific format to be shared with
    regulatory authorities, or even sync with systems provided by the authority. Taxation
    systems could be another example here. With a distributed architecture, you don''t
    want to risk losing the data recordset related to even a single transaction since
    that would amount to a compliance failure.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计：医疗保健、金融和银行是几个对相关服务有最严格合规标准的领域。而且，这在全世界都是一样的。根据你处理的合规类型，你可能需要保留数据一段时间作为记录，以特定格式保留数据以与监管机构共享，甚至与当局提供的系统同步。税收系统也可能是另一个例子。在分布式架构中，你不希望因为丢失与单个交易相关的数据记录集而面临合规失败的风险。
- en: 'Troubleshooting system failures: This, I bet, will be a favorite for a long
    time to come of anybody who is getting started with microservices. I remember
    the initial days when I used to try troubleshooting a scenario involving two Windows
    services. I never thought of recommending a similar design again. But the times
    have changed and so has the technology.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除系统故障：我相信，对于刚开始接触微服务的人来说，这将是长期以来的一个热门话题。我记得最初我尝试排除涉及两个Windows服务的场景。我从未想过再次推荐类似的设计。但时代已经改变，技术也是如此。
- en: When providing a service to other clients, monitoring becomes all the more important.
    In today's competitive world, an SLA would be part of any deal and has a cost
    associated with it, in the event of both success and failure. Ever wondered how
    easily we assumed that the Microsoft Azure SLA would stand true come what may?
    I have grown so used to it that the queries from clients worried about cloud resource
    availability are answered with a flat reply of 99.9 per cent uptime without even
    the blink of an eye.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当向其他客户提供服务时，监控变得更加重要。在当今竞争激烈的世界里，SLA将是任何交易的一部分，并且与其相关联的成本，无论是成功还是失败。你是否曾经想过，我们是如何轻易地假设微软Azure的SLA无论如何都会成立的？我已经习惯了它，以至于当客户担心云资源可用性时，我甚至没有眨一下眼，就给出了99.9%正常运行时间的直接回复。
- en: So unless you can be confident of agreeing an SLA with your clients when providing
    a service, they can't count on it to promise the same SLA going forward. As a
    matter of fact, no SLA might mean that your services are probably not stable enough
    to provide one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以除非你能够自信地与客户达成服务级别的协议（SLA），否则他们不能指望你承诺未来提供相同的SLA。事实上，没有SLA可能意味着你的服务可能不够稳定，无法提供SLA。
- en: Monitoring challenges
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控挑战
- en: There could be multiple key points that need to be addressed before you have
    a successful monitoring system in place. These need to be identified and assigned
    a solution. Some of the key points are discussed next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功建立监控系统之前，可能需要解决多个关键点。这些需要被识别并分配解决方案。以下是一些关键点的讨论。
- en: Scale
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模
- en: If you have a successfully running system with a few dozen microservices orchestrating
    successful transactions in perfect harmony, then you have won the first battle.
    Congratulations! However, you must plug in the necessary monitoring part if you
    haven't done so already. Ideally, this should be part of step one itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经拥有一个运行良好的系统，其中几十个微服务成功协调完美和谐的交易，那么你已经赢得了第一场战斗。恭喜！然而，如果你还没有这样做，你必须接入必要的监控部分。理想情况下，这应该是第一步本身的一部分。
- en: Component lifespan
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: With the use of virtual machines and containers, we need to figure out what
    part is worth monitoring. Some of these components might be already nonexistent
    by the time you look at the data generated by monitoring them. So it becomes extremely
    important that you choose the information to be monitored wisely.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟机和容器时，我们需要弄清楚哪些部分值得监控。在你查看监控产生的数据时，其中一些组件可能已经不存在了。因此，明智地选择要监控的信息变得极其重要。
- en: Information visualization
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息可视化
- en: There are tools available, such as AppDynamics and New Relic, that would allow
    you to visualize the data for maybe up to 100 microservices. However, in real-world
    applications, this is just a fraction of the number. There has to be clarity about
    the purpose of this information and a well-designed visualization around it. This
    is one area where we can opt for reverse design. First, think about the report/visualization
    you want and then see what how it is to be monitored.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具，如AppDynamics和New Relic，可以让你可视化多达100个微服务的数据。然而，在实际应用中，这仅仅是数量的一小部分。必须明确这些信息的目的，并围绕它设计良好的可视化。这是我们可以选择逆向设计的一个领域。首先，考虑你想要的报告/可视化，然后看看它是如何被监控的。
- en: Monitoring strategies
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控策略
- en: 'To begin with monitoring, you could think of different commonly implemented
    strategies as a solution to your problem. Some of the commonly implemented strategies
    are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在开始监控时，你可以将不同的常用策略视为解决你问题的方案。一些常用的策略包括：
- en: Application/system monitoring
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序/系统监控
- en: Real-user monitoring
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实用户监控
- en: Semantic monitoring and synthetic transactions
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义监控和合成事务
- en: Profiling
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Endpoint monitoring
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点监控
- en: Just bear in mind that each one of these strategies is focused on solving a
    specific purpose. While one could be helpful in analyzing transaction propagation,
    the other could be suitable for testing purposes. So it is important for you to
    pick a combination of these when designing the whole system, since just using
    a single strategy won't meet the needs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，这些策略中的每一个都是针对特定目的的。虽然其中一个可能在分析事务传播时有所帮助，但另一个可能适合测试目的。因此，在设计整个系统时，选择这些策略的组合非常重要，因为仅仅使用单一策略无法满足需求。
- en: Scalability
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: We have discussed in detail the scale-cube model of scalability and have found
    what scaling at each axis means. Note that *x *axis scaling is achieved through
    the use of load balancers between multiple instances and the users of the microservices.
    We also saw how *z *axis scaling based on the transaction origination suffered
    from some drawbacks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了可扩展性的立方模型，并发现了每个轴向上扩展的含义。请注意，*x* 轴扩展是通过在多个实例之间使用负载均衡器以及微服务的用户来实现的。我们还看到了基于事务起源的
    *z* 轴扩展存在一些缺点。
- en: 'Broadly, scaling in the microservice world can be categorized into two separate
    heads:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，扩展可以大致分为两个不同的方面：
- en: Infrastructure
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施
- en: Service design
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务设计
- en: Infrastructure scaling
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施扩展
- en: Virtual machines are an indispensable component of the microservice world. The
    features available as part of the Microsoft Azure platform enable you to perform
    this seemingly complex task without breaking a sweat.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是微服务世界不可或缺的组成部分。作为微软Azure平台的一部分，可用的功能使您能够轻松地完成这项看似复杂的任务。
- en: Through the scale set feature, which is integrated with Azure autoscale, we
    can easily manage a set of identical virtual machines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与Azure自动扩展集成的扩展集功能，我们可以轻松地管理一组相同的虚拟机。
- en: Autoscaling lets you define thresholds for various supported parameters, such
    as CPU usage. Once the threshold is breached, the scale set kicks in, based on
    whether the parameters scale in or scale out.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展允许您为各种支持的参数定义阈值，例如CPU使用率。一旦阈值被突破，根据参数是扩展内还是扩展外，扩展集将启动。
- en: This means that if the scale set predicts that it needs to add more virtual
    machines to cater for the increased load, it will continue to do so until the
    thresholds are back to normal. Similarly, if the demand for a resource being governed
    falls, it will decide to remove the virtual machine from the scale set. To me,
    this sounds like peace for the networking team. The options around auto-scaling
    can be explored further, as it is capable of taking care of complex scaling requirements,
    running into hundreds of virtual machines while scaling in or scaling out.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果扩展集预测需要添加更多虚拟机来应对增加的负载，它将继续这样做，直到阈值恢复正常。同样，如果受管理的资源需求下降，它将决定从扩展集中移除虚拟机。对我来说，这听起来像是网络团队的和平。可以进一步探索自动扩展的选项，因为它能够处理复杂的扩展需求，在扩展内或扩展外时运行数百个虚拟机。
- en: Service design
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务设计
- en: In our microservices, we have already achieved the isolation of data for each
    microservice. However, the model for reading and writing the database is still
    the same. With the underlying relational databases enforcing the ACID model, this
    can be a costly affair. Or we can say that this approach can be slightly modified
    to implement the database read/write operation in a different way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务中，我们已经实现了每个微服务的数据隔离。然而，读取和写入数据库的模型仍然是相同的。由于底层的关系数据库强制执行ACID模型，这可能会是一笔昂贵的交易。或者说，我们可以稍微修改这种方法，以不同的方式实现数据库的读写操作。
- en: We can employ the common query responsibility segregation, also referred to
    as CQRS, to make effective design changes in our microservices. Once the model-level
    separation is done, we will be free to optimize the read and write data models
    using a different strategy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常见的查询责任分离，也称为CQRS，在我们的微服务中进行有效的设计变更。一旦完成模型级别的分离，我们将能够自由地使用不同的策略来优化读取和写入数据模型。
- en: Reactive microservices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: 'We have progressed well while transitioning our monolithic application to the
    microservice-styled architecture. We have also briefly touched upon the possibility
    of introducing reactive traits to our services. We now know what the key attributes
    of reactive microservices are:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的单体应用程序过渡到微服务风格的架构过程中，我们已经取得了良好的进展。我们还简要地提到了向我们的服务引入响应式特性的可能性。我们现在知道响应式微服务的关键属性是什么：
- en: Responsiveness
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应性
- en: Resilience
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Autonomous
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主
- en: Being message-driven
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以消息驱动
- en: We also saw the benefits of reactive microservices amounting to less work on
    our part when it comes to managing communication across/between the microservices.
    This benefit translates not just into reduced work but the capability to focus
    on the core job of executing the business logic instead of trying to grapple with
    the complexities of inter-service communication.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了响应式微服务的益处，在管理微服务之间的通信时，我们所需的工作量减少。这种益处不仅体现在工作量减少，还在于能够专注于执行业务逻辑的核心工作，而不是试图处理服务间通信的复杂性。
- en: Greenfield application
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绿色田野应用
- en: Now let's go ahead and create the FlixOne bookstore from scratch. First, we
    will scope out our microservices and their functionalities and identify inter-service
    interactions as well.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从头开始创建FlixOne书店。首先，我们将确定我们的微服务和它们的职能，并识别服务间的交互。
- en: 'Our FlixOne bookstore will have the following set of functionalities available:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的FlixOne书店将提供以下一系列功能：
- en: Searching through the available books
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索可用的书籍
- en: Filtering books on the basis of categories
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据类别过滤书籍
- en: Adding books to the shopping cart
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将书籍添加到购物车
- en: Making changes to the shopping cart
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改购物车
- en: Placing an order from the shopping cart
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从购物车下订单
- en: User authentication
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: Scoping our services
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务范围
- en: In order to understand how these functionalities will map out as different microservices,
    we need to first understand, what it would take to support it, and what can be
    clubbed together as a microservice. We will see how the data store would start
    to look out of the window of microservices themselves.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些功能如何映射为不同的微服务，我们首先需要了解支持它们需要什么，什么可以组合成一个微服务。我们将看到数据存储是如何从微服务的视角开始的。
- en: The book-listing microservice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍列表微服务
- en: Let's try to break down the first functionality of searching through books.
    In order to let our users browse through the store for books, we need to maintain
    a list of books on offer. Here we have our first candidate being carved out as
    a microservice. The book-catalog service would be responsible for not just searching
    through the available books, but also maintaining the data store that would house
    all the information pertaining to books. The microservice should be able to handle
    various updates required for the available books in the system. We will call it
    the book-catalog microservice. And, it will have its own book data store.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试分解通过书籍搜索的第一个功能。为了使用户能够浏览书店中的书籍，我们需要维护一个提供的书籍列表。在这里，我们的第一个候选者被划为一个微服务。书籍目录服务不仅负责搜索可用的书籍，还要维护一个数据存储，该存储将包含所有与书籍相关的信息。该微服务应该能够处理系统中可用的书籍所需的各项更新。我们将称之为书籍目录微服务，并且它将拥有自己的书籍数据存储。
- en: The book-searching microservice
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍搜索微服务
- en: 'Examining the next functionality of filtering books seems to be coming under
    the purview of the book-catalog microservice itself. However, having said that,
    let''s confirm it by questioning our own understanding of the business domain
    here. The question that comes to my mind is related to the impact of all the searches
    that our users would perform bringing down the service. So should the book-search
    functionality be a different service? Here the answer lies in the fact that the
    microservice should have its own data store. Having the book catalog and the book-catalog
    search function as different services would require us to maintain a list of books
    in two different locations with additional challenges, such as having to sync
    them. The solution is simple: have a single microservice, and if required, scale
    up and load balance the book-catalog microservice.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 检查过滤书籍的下一个功能似乎属于书籍目录微服务本身的范畴。然而，话虽如此，让我们通过质疑我们对业务领域的理解来确认这一点。我心中浮现的问题是关于用户执行的所有搜索对服务的影响。因此，书籍搜索功能应该是一个不同的服务吗？在这里，答案在于微服务应该有自己的数据存储。如果将书籍目录和书籍目录搜索功能作为不同的服务，将需要我们在两个不同的位置维护书籍列表，并面临额外的挑战，例如需要同步它们。解决方案很简单：拥有一个单一的微服务，如果需要，可以扩展并负载均衡书籍目录微服务。
- en: The shopping-cart microservice
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务
- en: 'The next candidate is the one made famous by the online shopping revolution
    brought around by the likes of Amazon and further fuelled by smartphones: the
    shopping-cart microservice. It should let us add or remove books to our cart before
    we finally decide to check out and pay for them. There is no doubt about whether
    this should be a separate microservice or not. However, this brings forth an interesting
    question of whether it deals with the product''s data store or not; it would need
    to do this in order to receive some fundamental details, such as availability
    in stock. Accessing the data store across the service is out of the question as
    that is one of the most fundamental prerequisites for microservices. The answer
    to our question is inter-service communication. It is OK for a microservice to
    use the service provided by another microservice. We will call this our shopping-cart
    microservice.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个候选者是因亚马逊等在线购物革命而闻名，并由智能手机进一步推动的购物车微服务。它应该允许我们在最终决定结账并支付之前添加或删除书籍。毫无疑问，这应该是一个独立的微服务。然而，这引发了一个有趣的问题，即它是否处理产品的数据存储；为了获取一些基本细节，例如库存可用性，它必须这样做。跨服务访问数据存储是不可能的，因为这是最基本的前提之一。我们问题的答案是服务间通信。一个微服务使用另一个微服务提供的服务是可以接受的。我们将称之为我们的购物车微服务。
- en: The order microservice
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单微服务
- en: The business functionality of placing an order is next in line. When a user
    decides that their shopping cart has just the right books, they decide to place
    an order. At that moment, some information related to the order has to be confirmed/conveyed
    to various other microservices. For example, before the order is confirmed, we
    need to confirm from the book catalog that there is enough quantity available
    in stock to fulfill the order. After this confirmation, the right number of items
    is supposed to be reduced from the book catalog. The shopping cart would also
    have to be emptied after the successful confirmation of the order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要考虑的业务功能是下单。当用户认为他们的购物车中正好有足够的书籍时，他们决定下单。在那个时刻，一些与订单相关的信息必须被确认/传达给其他微服务。例如，在确认订单之前，我们需要从图书目录中确认是否有足够的库存来满足订单。确认之后，应该从图书目录中减少相应数量的项目。在订单成功确认后，购物车也应该被清空。
- en: Although our order microservice sounds more pervasive and in contradiction to
    the rules of non-sharing of data across microservices, it is not the case, as
    we will see shortly. All the operations will be completed while maintaining clear
    boundaries, with each microservice managing its own data store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的订单微服务听起来更具有普遍性，并且与微服务之间数据不共享的规则相矛盾，但事实并非如此，正如我们很快就会看到的。所有操作都将保持清晰的边界，每个微服务管理自己的数据存储。
- en: User-authentication
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: Our last candidate is the user-authentication microservice that would validate
    the user credentials of customers who log in to our bookstore. The sole purpose
    of this microservice is to confirm whether or not the provided credentials are
    correct in order to restrict unauthorized access. This seems pretty simple for a
    microservice; however, we have to remember the fact that making this functionality
    a part of any other microservice would impact more than one business functionality
    if you decide to change your authentication mechanism. The change may come in
    the form of using JWT tokens being generated and validated based on the OAuth
    2.0 authorization framework and OpenID Connect 1.0 authentication.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的候选者是用户身份验证微服务，它将验证登录到我们的书店的客户提供的用户凭据。这个微服务的唯一目的是确认提供的凭据是否正确，以限制未经授权的访问。对于一个微服务来说，这似乎很简单；然而，我们必须记住这样一个事实，如果决定更改身份验证机制，将这个功能作为任何其他微服务的一部分将对多个业务功能产生影响。这种变化可能以使用基于OAuth
    2.0授权框架和OpenID Connect 1.0身份验证生成的JWT令牌并进行验证的形式出现。
- en: 'The following is the final list of candidates for microservices:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为微服务准备的最终候选列表：
- en: The book-catalog microservice
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图书目录微服务
- en: The shopping-cart microservice
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务
- en: The order microservice
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单微服务
- en: The user-authentication microservice
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证微服务
- en: 'In the following image we can visualize four services that are catalog, shopping
    cart, order, and authentication:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以可视化四个服务：目录、购物车、订单和身份验证：
- en: '![](img/f9ac8893-2bd9-446a-9cd9-d3a4530dcaea.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9ac8893-2bd9-446a-9cd9-d3a4530dcaea.png)'
- en: Synchronous versus asynchronous
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步与异步
- en: Before we get started with a brief introduction of the microservices, there
    is an important point to consider here. Our microservices will be communicating
    with each other, and there is a possibility that they will rely on a response
    to move further. This poses a dilemma for us, having gone through all the pain
    of unlearning the beloved monolithic and then getting into the same situation
    where a point of failure can be a cascading collapse of the system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始简要介绍微服务之前，这里有一个重要的观点需要考虑。我们的微服务将相互通信，并且它们可能会依赖于响应来进一步操作。这给我们带来了困境，因为我们经历了从心爱的单体架构中解脱出来并陷入同样可能因故障点而引发系统级联崩溃的境地。
- en: The book-catalog microservice
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍目录微服务
- en: This microservice has six main functions exposed through an HTTP API component.
    It is the responsibility of this HTTP API component to handle all the HTTP requests
    for these functions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务通过HTTP API组件公开了六个主要功能。处理这些功能的所有HTTP请求是此HTTP API组件的责任。
- en: 'These functions are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能包括：
- en: '| **API resource description** | **API resource description** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **API资源描述** | **API资源描述** |'
- en: '| `GET` /`api`/`book` | Gets a list of the available books |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`book` | 获取可用书籍列表 |'
- en: '| `GET` /`api`/`book{category}` | Gets a list of the books for a category |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`book{category}` | 获取特定类别的书籍列表 |'
- en: '| `GET` /`api`/`book{name}` | Gets a list of the books by name |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`book{name}` | 根据名称获取书籍列表 |'
- en: '| `GET` /`api`/`book{isbn}` | Gets a book as per the ISBN number |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`book{isbn}` | 根据ISBN号获取书籍 |'
- en: '| `GET` /`api`/`bookquantity{id}` | Gets the available stock for the intended
    book |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`bookquantity{id}` | 获取目标书籍的可用库存 |'
- en: '| `PUT` /`api`/`bookquantity{id, changecount}` | Increase or decrease the available
    stock quantity for a book |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` /`api`/`bookquantity{id, changecount}` | 增加或减少特定书籍的可用库存数量 |'
- en: 'The following image is visualizing tables of the catalog services:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像可视化了目录服务的表：
- en: '![](img/dd32657b-5aa1-4ca3-a92c-6ba3e0c8a338.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd32657b-5aa1-4ca3-a92c-6ba3e0c8a338.png)'
- en: The shopping-cart microservice
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务将以下功能作为HTTP端点公开供消费：
- en: '| **API resource description** | **API resource description** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **API资源描述** | **API资源描述** |'
- en: '| `POST` /`api`/`book {customerid }` | Adds the specific book to the shopping
    cart of the customer |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `POST` /`api`/`book {customerid }` | 将特定书籍添加到客户的购物车中 |'
- en: '| `DELETE` /`api`/`book {customerid }` | Removes the book from the shopping
    cart of the customer |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` /`api`/`book {customerid }` | 从客户的购物车中删除书籍 |'
- en: '| `GET` /`api`/`book{customerid}` | Gets the list of books in the shopping
    cart of the customer |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`book{customerid}` | 获取客户购物车中的书籍列表 |'
- en: '| `PUT` /`api`/`empty` | Removes all the books currently contained in the shopping
    cart. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` /`api`/`empty` | 删除购物车中当前包含的所有书籍。 |'
- en: 'The following image is visualizing all supporting tables for the shopping-cart
    service:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像可视化了购物车服务的所有支持表：
- en: '![](img/e99e8356-0ac3-45c3-8aff-442655e8f63d.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e99e8356-0ac3-45c3-8aff-442655e8f63d.png)'
- en: The order microservice
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单微服务
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务将以下功能作为HTTP端点公开供消费：
- en: '| **API resource description** | **API resource description** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **API资源描述** | **API资源描述** |'
- en: '| `POST` /`api`/`order {customerid }` | Gets all the books in the shopping
    cart of the customer and creates an order for the same |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `POST` /`api`/`order {customerid }` | 获取客户购物车中的所有书籍并为同一订单创建订单 |'
- en: '| `DELETE` /`api`/`order {customerid }` | Removes the book from the shopping
    cart of the customer |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` /`api`/`order {customerid }` | 从客户的购物车中删除书籍 |'
- en: '| `GET` /`api`/`order{orderid}` | Gets all the books as part of the specific
    order |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`order{orderid}` | 获取特定订单中的所有书籍 |'
- en: 'The following image depicts all tables of the order service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了订单服务的所有表：
- en: '![](img/598e49f5-aca5-46e7-86fe-02c2b447c065.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/598e49f5-aca5-46e7-86fe-02c2b447c065.png)'
- en: The user-authentication microservice
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户身份验证微服务
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务将以下功能作为HTTP端点公开供消费：
- en: '| **API resource description** | **API resource description** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **API资源描述** | **API资源描述** |'
- en: '| `GET` /`api`/`verifyuser{customerid, password}` | Verifies the user |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`verifyuser{customerid, password}` | 验证用户 |'
- en: 'The following screenshot shows the user table of the authentication service:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了认证服务的用户表：
- en: '![](img/36041ba3-4ca1-4b99-b021-aec19d71dab0.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36041ba3-4ca1-4b99-b021-aec19d71dab0.png)'
- en: You can look at the application source code and analyze it as required.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看应用程序源代码并根据需要进行分析。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We hope that this book was able to introduce you to the fundamental concepts
    of the microservice-styled architecture and also helped you to dive deeply into
    the fine aspects of microservices with clear examples of the concepts. The final
    application is available for you to take a closer look and analyze what you have
    learned so far at your own pace. We wish you luck in utilizing the skills learned
    in this book and applying them to your real-world challenges.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这本书能够向您介绍微服务风格架构的基本概念，并帮助您通过清晰的概念示例深入理解微服务的细微之处。最终的应用程序可供您仔细查看，并根据自己的节奏分析到目前为止所学到的内容。我们祝愿您在使用本书中学到的技能并将其应用于现实世界挑战时一切顺利。
