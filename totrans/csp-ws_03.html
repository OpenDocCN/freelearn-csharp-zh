<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer109">
</div>
</div>
<div class="Content" id="_idContainer110">
<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>3. Delegates, Events, and Lambdas</h1>
</div>
<div class="Content" id="_idContainer111">
<p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will learn how delegates are defined and invoked, and you will explore their wide usage across the .NET ecosystem. With this knowledge, you will move on to the inbuilt <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates to discover how their usage reduces unnecessary boilerplate code. You will then see how multicast delegates can be harnessed to send messages to multiple parties, and how events can be incorporated into event-driven code. Along the way, you will discover some common pitfalls to avoid and best practices to follow that prevent a great application from turning into an unreliable one.</p>
<p class="callout">This chapter will demystify the lambda syntax style and show how it can be used effectively. By the end of the chapter, you will be able to use the lambda syntax comfortably to create code that is succinct, as well as easy to grasp and maintain.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Introduction</h1>
<p>In the previous chapter, you learned some of the key aspects of Object Oriented Programming (OOP). In this chapter, you will build on this by looking at the common patterns used specifically in C# that enable classes to interact.</p>
<p>Have you found yourself working with a code that has to listen to certain signals and act on them, but you cannot be sure until runtime what those actions should be? Maybe you have a block of code that you need to reuse or pass to other methods for them to call when they are ready. Or, you may want to filter a list of objects, but need to base how you would do that on a combination of user preferences. Much of this can be achieved using interfaces, but it is often more efficient to create chunks of code that you can then pass to other classes in a type-safe way. Such blocks are referred to as delegates and form the backbone of many .NET libraries, allowing methods or pieces of code to be passed as parameters.</p>
<p>The natural extension to a delegate is the event, which makes it possible to offer a form of optional behavior in software. For example, you may have a component that broadcasts live news and stock prices, but unless you provide a way to opt into these services, you may limit the usability of such a component.</p>
<p>User Interface (UI) apps often provide notifications of various user actions, for example, keypresses, swiping a screen, or clicking a mouse button; such notifications follow a standard pattern in C#, which will be discussed fully in this chapter. In such scenarios, the UI element detecting such actions is referred to as a publisher, whereas the code that acts upon those messages is called a subscriber. When brought together, they form an event-driven design referred to as the publisher-subscriber, or pub-sub, pattern. You will see how this can be used in all types of C#. Remember that its usage is not just the exclusive domain of UI applications.</p>
<p>Finally, you will learn about lambda statements and lambda expressions, collectively known as lambdas. These have an unusual syntax, which can initially take a while to become comfortable with. Rather than having lots of methods and functions scattered within a class, lambdas allow for smaller blocks of code that are often self-contained and located within close proximity to where they are used in the code, thereby offering an easier way to follow and maintain code. You will learn about lambdas in detail in the latter half of this chapter. First, you will learn about delegates.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Delegates</h1>
<p>The .NET delegate is similar to function pointers found in other languages, such as C++; in other words, it is like a pointer to a method to be invoked at runtime. In essence, it is a placeholder for a block of code, which can be something as simple as a single statement or a full-blown multiline code block, complete with complex branches of execution, that you ask other code to execute at some point in time. The term delegate hints at some form of <strong class="bold">representative</strong>, which is precisely what this placeholder concept relates to.</p>
<p>Delegates allow for minimum coupling between objects, and much less code. There is no need to create classes that are derived from specific classes or interfaces. By using a delegate, you are defining what a compatible method should look like, whether it is in a class or struct, static, or instance-based. The arguments and return type define this calling compatibility.</p>
<p>Furthermore, delegates can be used in a callback fashion, which allows multiple methods to be wired up to a single publication source. They often require much less code and provide more features than found using an interface-based design.</p>
<p>The following example shows how effective delegates can be. Suppose you have a class that searches for users by surname. It would probably look like this:</p>
<p class="source-code"><a id="_idTextAnchor132"/>public User FindBySurname(string name)</p>
<p class="source-code">{</p>
<p class="source-code">    foreach(var user in _users)</p>
<p class="source-code">       if (user.Surname == name)</p>
<p class="source-code">          return user;</p>
<p class="source-code">    return null;</p>
<p class="source-code">}</p>
<p>You then need to extend this to include a search of the user's login name:</p>
<p class="source-code"><a id="_idTextAnchor133"/>public User FindByLoginName(string name)</p>
<p class="source-code">{</p>
<p class="source-code">    foreach(var user in _users)</p>
<p class="source-code">       if (user.LoginName == name)</p>
<p class="source-code">          return user;</p>
<p class="source-code">    return null;</p>
<p class="source-code">}</p>
<p>Once again, you decide to add yet another search, this time by location:</p>
<p class="source-code"><a id="_idTextAnchor134"/>public User FindByLocation(string name)</p>
<p class="source-code">{</p>
<p class="source-code">    foreach(var user in _users)</p>
<p class="source-code">       if (user.Location == name)</p>
<p class="source-code">          return user;</p>
<p class="source-code">    return null;</p>
<p class="source-code">}</p>
<p>You start the searches with code like this:</p>
<p class="source-code"><a id="_idTextAnchor135"/>public void DoSearch()</p>
<p class="source-code">{</p>
<p class="source-code">  var user1 = FindBySurname("Wright");</p>
<p class="source-code">  var user2 = FindByLoginName("JamesR");</p>
<p class="source-code">  var user3 = FindByLocation("Scotland"); </p>
<p class="source-code">}</p>
<p>Can you see the pattern that is occurring every time? You are repeating the same code that iterates through the list of users, applying a Boolean condition (also known as a predicate) to find the first matching user.</p>
<p>The only thing that is different is that the predicate decides whether a match has been found. This is one of the common cases where delegates are used at a basic level. The <strong class="source-inline">predicate</strong> can be replaced with a delegate, acting as a placeholder, which is evaluated when required.</p>
<p>Converting this code to a delegate style, you define a delegate named <strong class="source-inline">FindUser</strong> (this step can be skipped as .NET contains a delegate definition that you can reuse; you will come to this later).</p>
<p>All you need is a single helper method, <strong class="source-inline">Find</strong>, which is passed a <strong class="source-inline">FindUser</strong> delegate instance. Find knows how to loop through the users, invoking the delegate passing in the user, which returns true or false for a match:</p>
<p class="source-code">private delegate bool FindUser(User user);</p>
<p class="source-code">private User Find(FindUser predicate)</p>
<p class="source-code">{</p>
<p class="source-code">  foreach (var user in _users)</p>
<p class="source-code">    if (predicate(user))</p>
<p class="source-code">      return user;</p>
<p class="source-code">  return null;</p>
<p class="source-code">}</p>
<p class="source-code">public void DoSearch()</p>
<p class="source-code">{</p>
<p class="source-code">  var user4 = Find(user =&gt; user.Surname == "Wright");</p>
<p class="source-code">  var user5 = Find(user =&gt; user.LoginName == "JamesR");</p>
<p class="source-code">  var user6 = Find(user =&gt; user.Location == "Scotland");</p>
<p class="source-code">}</p>
<p>As you can see, the code is kept together and is much more concise now. There is no need to cut and paste code that loops through the users, as that is all done in one place. For each type of search, you simply define a delegate once and pass it to <strong class="source-inline">Find</strong>. To add a new type of search, all you need to do is define it in a single statement line, rather than copying at least eight lines of code that repeat the looping function.</p>
<p>The lambda syntax is a fundamental style used to define method bodies, but its strange syntax can prove to be an obstacle at first. At first glance, lambda expressions can look odd with their <strong class="source-inline">=&gt;</strong> style, but they do offer a cleaner way to specify a target method. The act of defining a lambda is similar to defining a method; you essentially omit the method name and use <strong class="source-inline">=&gt;</strong> to prefix a block of code.</p>
<p>You will now look at another example, using interfaces this time. Consider that you are working on a graphics engine and need to calculate the position of an image onscreen each time the user rotates or zooms in. Note that this example skips any complex math calculations.</p>
<p>Consider that you need to transform a <strong class="source-inline">Point</strong> class using the <strong class="source-inline">ITransform</strong> interface with a single method named <strong class="source-inline">Move</strong>, as shown in the following code snippet:</p>
<p class="source-code">public class Point</p>
<p class="source-code">{</p>
<p class="source-code">  public double X { get; set; } </p>
<p class="source-code">  public double Y { get; set; }</p>
<p class="source-code">}</p>
<p class="source-code">public interface ITransform</p>
<p class="source-code">{</p>
<p class="source-code">  Point Move(double height, double width);</p>
<p class="source-code">}</p>
<p>When the user rotates an object, you need to use <strong class="source-inline">RotateTransform</strong>, and for a zoom operation, you will use <strong class="source-inline">ZoomTransform</strong>, as follows. Both are based on the <strong class="source-inline">ITransform</strong> interface:</p>
<p class="source-code">public class RotateTransform : ITransform</p>
<p class="source-code">{</p>
<p class="source-code">    public Point Move(double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        // do stuff</p>
<p class="source-code">        return new Point();</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p class="source-code">public class ZoomTransform : ITransform</p>
<p class="source-code">{</p>
<p class="source-code">    public Point Move(double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        // do stuff</p>
<p class="source-code">        return new Point();</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>So, given these two classes, a point can be transformed by creating a new <strong class="source-inline">Transform</strong> instance, which is passed to a method named <strong class="source-inline">Calculate</strong>, as shown in the following code. <strong class="source-inline">Calculate</strong> calls the corresponding <strong class="source-inline">Move</strong> method, and does some extra unspecified work on point, before returning point to the caller:</p>
<p class="source-code">public class Transformer</p>
<p class="source-code">{</p>
<p class="source-code">    public void Transform()</p>
<p class="source-code">    {</p>
<p class="source-code">        var rotatePoint = Calculate(new RotateTransform(), 100, 20);</p>
<p class="source-code">        var zoomPoint = Calculate(new ZoomTransform(), 5, 5);</p>
<p class="source-code">    }</p>
<p class="source-code">    private Point Calculate(ITransform transformer, double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        var point = transformer.Move(height, width);</p>
<p class="source-code">        //do stuff to point</p>
<p class="source-code">        return point;</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>This is a standard class and interface-based design, but you can see that you have made a lot of effort to create new classes with just a single numeric value from a <strong class="source-inline">Move</strong> method. It is a worthwhile idea to have the calculations broken down into an easy-to-follow implementation. After all, it could have led to a future maintenance problem if implemented in a single method with multiple if-then branches.</p>
<p>By re-implementing a delegate-based design, you still have maintainable code, but much less of it to look after. You can have a <strong class="source-inline">TransformPoint</strong> delegate and a new <strong class="source-inline">Calculate</strong> function that can be passed a <strong class="source-inline">TransformPoint</strong> delegate.</p>
<p>You can invoke a delegate by appending brackets around its name and passing in any arguments. This is similar to how you would call a standard class-level function or method. You will cover this invocation in more detail later; for now, consider the following snippet:</p>
<p class="source-code">    private delegate Point TransformPoint(double height, double width);</p>
<p class="source-code">    private Point Calculate(TransformPoint transformer, double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        var point = transformer(height, width);</p>
<p class="source-code">        //do stuff to point</p>
<p class="source-code">        return point;</p>
<p class="source-code">    }</p>
<p>You still need the actual target <strong class="source-inline">Rotate</strong> and <strong class="source-inline">Zoom</strong> methods, but you do not have the overhead of creating unnecessary classes to do this. You can add the following code:</p>
<p class="source-code">    private Point Rotate(double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        return new Point();</p>
<p class="source-code">    }</p>
<p class="source-code">    private Point Zoom(double height, double width)</p>
<p class="source-code">    {</p>
<p class="source-code">        return new Point();</p>
<p class="source-code">    }</p>
<p>Now, calling the method delegates is as simple as the following:</p>
<p class="source-code">    public void Transform()</p>
<p class="source-code">    {</p>
<p class="source-code">         var rotatePoint1 = Calculate(Rotate, 100, 20);</p>
<p class="source-code">         var zoomPoint1 = Calculate(Zoom, 5, 5);</p>
<p class="source-code">    }</p>
<p>Notice how using delegates in this way helps eliminate a lot of unnecessary code.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/AcwZA">https://packt.link/AcwZA</a>.</p>
<p>In addition to invoking a single placeholder method, a delegate also contains extra plumbing that allows it to be used in a <strong class="bold">multicast</strong> manner, that is, a way to chain multiple target methods together, each being invoked one after the other. This is often referred to as an invocation list or delegate chain and is initiated by code that acts as a publication source.</p>
<p>A simple example of how this multicast concept applies can be seen in UIs. Imagine you have an application that shows the map of a country. As the user moves their mouse over the map, you may want to perform various actions, such as the following:</p>
<ul>
<li>Changing the mouse pointer to a different shape while over a building.</li>
<li>Showing a tooltip that calculates the real-world longitude and latitude coordinates.</li>
<li>Showing a message in a status bar that calculates the population of the area where the mouse is hovering.</li>
</ul>
<p>To achieve this, you would need some way to detect when the user moves the mouse over the screen. This is often referred to as the publisher. In this example, its sole purpose is to detect mouse movements and publish them to anyone who is listening.</p>
<p>To perform the three required UI actions, you would create a class that has a list of objects to notify when the mouse position changes, allowing each object to perform whatever activity it needs, in isolation from the others. Each of these objects is referred to as a subscriber.</p>
<p>When your publisher detects that the mouse has moved, you follow this pseudo code:</p>
<p class="source-code">MouseEventArgs args = new MouseEventArgs(100,200)</p>
<p class="source-code">foreach(subscription in subscriptionList)</p>
<p class="source-code">{</p>
<p class="source-code">   subscription.OnMouseMoved(args)</p>
<p class="source-code">} </p>
<p>This assumes that <strong class="source-inline">subscriptionList</strong> is a list of objects, perhaps based on an interface with the <strong class="source-inline">OnMouseMoved</strong> method. It is up to you to add code that enables interested parties to subscribe to and unsubscribe from the <strong class="source-inline">OnMouseMoved</strong> notifications. It would be an unfortunate design if code that has previously subscribed has no way to unsubscribe and gets called repeatedly when there is no longer any need for it to be called.</p>
<p>In the preceding code, there is a fair amount of coupling between the publisher and subscribers, and you are back to using interfaces for a type-safe implementation. What if you then needed to listen for keypresses, both key down and key up? It would soon get quite frustrating having to repeatedly copy such similar code.</p>
<p>Fortunately, the delegate type contains all this as inbuilt behavior. You can use single or multiple target methods interchangeably; all you need to do is invoke a delegate and the delegate will handle the rest for you.</p>
<p>You will take an in-depth look at multicast delegates shortly, but first, you will explore the single-target method scenario.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor136"/>Defining a Custom Delegate</h2>
<p>Delegates are defined in a way that is similar to that of a standard method. The compiler does not care about the code in the body of a target method, only that it can be invoked safely at some point in time.</p>
<p>The <strong class="source-inline">delegate</strong> keyword is used to define a delegate, using the following format:</p>
<p class="source-code">public delegate void MessageReceivedHandler(string message, int size);</p>
<p>The following list describes each component of this syntax:</p>
<ul>
<li>Scope: An access modifier, such as <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, or <strong class="source-inline">protected</strong>, to define the scope of the delegate. If you do not include a modifier, the compiler will default to marking it as private, but it is always better to be explicit in showing the intent of your code.</li>
<li>The <strong class="source-inline">delegate</strong> keyword.</li>
<li>Return type: If there is no return type, <strong class="source-inline">void</strong> is used.</li>
<li>Delegate name: This can be anything that you like, but the name must be unique within the namespace. Many naming conventions (including Microsoft's) suggest adding <strong class="source-inline">Handler</strong> or <strong class="source-inline">EventHandler</strong> to your delegate's name.</li>
<li>Arguments, if required.<p class="callout-heading">Note</p><p class="callout">Delegates can be nested within a class or namespace; they can also be defined within the global namespace, although this practice is discouraged. When defining classes in C#, it is common practice to define them within a parent namespace, typically based on a hierarchical convention that starts with the company name, followed by the product name, and finally the feature. This helps to provide a more unique identity to a type.</p><p class="callout">By defining a delegate without a namespace, there is a high chance that it will clash with another delegate with the same name if it is also defined in a library without the protection of a namespace. This can cause the compiler to become confused as to which delegate you are referring to.</p></li>
</ul>
<p>In earlier versions of .NET, it was common practice to define custom delegates. Such code has since been replaced with various inbuilt .NET delegates, which you will look at shortly. For now, you will briefly cover the basics of defining a custom delegate. It is worthwhile know about this if you maintain any legacy C# code.</p>
<p>In the next exercise, you will create a custom delegate, one that is passed a <strong class="source-inline">DateTime</strong> parameter and returns a Boolean to indicate validity.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>Exercise 3.01: Defining and Invoking Custom Delegates</h2>
<p>Say you have an application that allows users to order products. While filling in the order details, the customer can specify an order date and a delivery date, both of which must be validated before accepting the order. You need a flexible way to validate these dates. For some customers, you may allow weekend delivery dates, while for others, it must be at least seven days away. You may also allow an order to be back-dated for certain customers.</p>
<p>You know that delegates offer a way to vary an implementation at runtime, so that is the best way to proceed. You do not want multiple interfaces, or worse, a complex jumble of <strong class="source-inline">if-then</strong> statements, to achieve this.</p>
<p>Depending on the customer's profile, you can create a class named <strong class="source-inline">Order</strong>, which can be passed different date validation rules. These rules can be validated by a <strong class="source-inline">Validate</strong> method:</p>
<p>Perform the following steps to do so:</p>
<ol>
<li>Create a new folder called <strong class="source-inline">Chapter03</strong>.</li>
<li>Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise01</strong>, using the CLI <strong class="source-inline">dotnet</strong> command, as follows:<p class="source-code">source\Chapter03&gt;dotnet new console -o Exercise01</p></li>
</ol>
<p>You will see the following output:</p>
<p class="source-code">The template "Console Application" was created successfully.</p>
<p class="source-code">Processing post-creation actions...</p>
<p class="source-code">Running 'dotnet restore' on Exercise01\Exercise01.csproj...</p>
<p class="source-code">  Determining projects to restore...</p>
<p class="source-code">  Restored source\Chapter03\Exercise01\Exercise01.csproj (in 191 ms).</p>
<p class="source-code">Restore succeeded.</p>
<ol>
<li value="3">Open <strong class="source-inline">Chapter03\Exercise01.csproj</strong> and replace the contents with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise01\Program.cs</strong> and clear the contents.</li>
<li>The preference for using namespaces to prevent a clash with objects from other libraries was mentioned earlier, so to keep things isolated, use <strong class="source-inline">Chapter03.Exercise01</strong> as the namespace.</li>
</ol>
<p>To implement your date validation rules, you will define a delegate that takes a single <strong class="source-inline">DateTime</strong> argument and returns a Boolean value. You will name it <strong class="source-inline">DateValidationHandler</strong>:</p>
<p class="source-code">using System;</p>
<p class="source-code">namespace Chapter03.Exercise01 </p>
<p class="source-code">{</p>
<p class="source-code">    public delegate bool DateValidationHandler(DateTime dateTime);</p>
<p class="source-code">}</p>
<ol>
<li value="6">Next, you will create a class named <strong class="source-inline">Order</strong>, which contains details of the order and can be passed to two date validation delegates:<p class="source-code">   public class Order</p><p class="source-code">    {</p><p class="source-code">        private readonly DateValidationHandler _orderDateValidator;</p><p class="source-code">        private readonly DateValidationHandler _deliveryDateValidator;</p></li>
</ol>
<p>Notice how you have declared two read-only, class-level instances of <strong class="source-inline">DateValidationHandler</strong>, one to validate the order date and a second to validate the delivery date. This design assumes that the date validation rules are not going to be altered for this <strong class="source-inline">Order</strong> instance.</p>
<ol>
<li value="7">Now for the constructor, you pass the two delegates:<p class="source-code">       public Order(DateValidationHandler orderDateValidator,</p><p class="source-code">            DateValidationHandler deliveryDateValidator)</p><p class="source-code">        {</p><p class="source-code">            _orderDateValidator = orderDateValidator;</p><p class="source-code">            _deliveryDateValidator = deliveryDateValidator;</p><p class="source-code">        }  </p></li>
</ol>
<p>In this design, a different class is typically responsible for deciding which delegates to use, based on the selected customer's profile.</p>
<ol>
<li value="8">You need to add the two date properties that are to be validated. These dates may be set using a UI that listens to keypresses and applies user edits directly to this class:<p class="source-code">        public DateTime OrderDate { get; set; }</p><p class="source-code">        public DateTime DeliveryDate { get; set; }</p></li>
<li>Now add an <strong class="source-inline">IsValid</strong> method that passes <strong class="source-inline">OrderDate</strong> to the <strong class="source-inline">orderDateValidator</strong> delegate and <strong class="source-inline">DeliveryDate</strong> to the <strong class="source-inline">deliveryDateValidator</strong> delegate:<p class="source-code">        public bool IsValid() =&gt; </p><p class="source-code">            _orderDateValidator(OrderDate) &amp;&amp;</p><p class="source-code">            _deliveryDateValidator(DeliveryDate);</p><p class="source-code">    }</p></li>
</ol>
<p>If both are valid, then this call will return <strong class="source-inline">true</strong>. The key here is that <strong class="source-inline">Order</strong> doesn't need to know about the precise implementation of an individual customer's date validation rules, so you can easily reuse <strong class="source-inline">Order</strong> elsewhere in a program. To invoke a delegate, you simply wrap any arguments in brackets, in this case passing the correct date property to each delegate instance:</p>
<ol>
<li value="10">To create a console app to test this, add a <strong class="source-inline">static</strong> class called <strong class="source-inline">Program</strong>:<p class="source-code">    public static class Program</p><p class="source-code">    {</p></li>
<li>You want to create two functions that validate whether the date passed to them is valid. These functions will form the basis of your delegate target methods:<p class="source-code">        private static bool IsWeekendDate(DateTime date)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("Called IsWeekendDate");</p><p class="source-code">            return date.DayOfWeek == DayOfWeek.Saturday ||</p><p class="source-code">                   date.DayOfWeek == DayOfWeek.Sunday;</p><p class="source-code">        }</p><p class="source-code">        private static bool IsPastDate(DateTime date)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("Called IsPastDate");</p><p class="source-code">            return date &lt; DateTime.Today;</p><p class="source-code">        }</p></li>
</ol>
<p>Notice how both have the exact signature that the <strong class="source-inline">DateValidationHandler</strong> delegate is expecting. Neither is aware of the nature of the date that they are validating, as that is not their concern. They are both marked <strong class="source-inline">static</strong> as they do not interact with any variables or properties anywhere in this class.</p>
<ol>
<li value="12">Now for the <strong class="source-inline">Main</strong> entry point. Here, you create two <strong class="source-inline">DateValidationHandler</strong> delegate instances, passing <strong class="source-inline">IsPastDate</strong> to one and <strong class="source-inline">IsWeekendDate</strong> to the second. These are the target methods that will get called when each of the delegates is invoked:<p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">           var orderValidator = new DateValidationHandler(IsPastDate);</p><p class="source-code">           var deliverValidator = new DateValidationHandler(IsWeekendDate);</p></li>
<li>Now you can create an <strong class="source-inline">Order</strong> instance, passing in the delegates and setting the order and delivery dates:<p class="source-code">          var order = new Order(orderValidator, deliverValidator)</p><p class="source-code">            {</p><p class="source-code">                OrderDate = DateTime.Today.AddDays(-10), </p><p class="source-code">                DeliveryDate = new DateTime(2020, 12, 31)</p><p class="source-code">            };</p></li>
</ol>
<p>There are various ways to create delegates. Here, you have assigned them to variables first to make the code clearer (you will cover different styles later).</p>
<ol>
<li value="14">Now it's just a case of displaying the dates in the console and calling <strong class="source-inline">IsValid</strong>, which, in turn, will invoke each of your delegate methods once. Notice that a custom date format is used to make the dates more readable:<p class="source-code">          Console.WriteLine($"Ordered: {order.OrderDate:dd-MMM-yy}");</p><p class="source-code">          Console.WriteLine($"Delivered: {order.DeliveryDate:dd-MMM-yy }");</p><p class="source-code">          Console.WriteLine($"IsValid: {order.IsValid()}");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the console app produces output like this: <p class="source-code">Ordered: 07-May-22</p><p class="source-code">Delivered: 31-Dec-20</p><p class="source-code">Called IsPastDate</p><p class="source-code">Called IsWeekendDate</p><p class="source-code">IsValid: False</p></li>
</ol>
<p>This order is <strong class="bold">not</strong> valid as the delivery date is a Thursday, not a weekend as you require:</p>
<p>You have learned how to define a custom delegate and have created two instances that make use of small helper functions to validate dates. This gives you an idea of how flexible delegates can be.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cmL0s">https://packt.link/cmL0s</a>.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/>The Inbuilt Action and Func Delegates</h2>
<p>When you define a delegate, you are describing its signature, that is, the return type and a list of input parameters. With that said, consider these two delegates:</p>
<p class="source-code">public delegate string DoStuff(string name, int age);</p>
<p class="source-code">public delegate string DoMoreStuff(string name, int age);</p>
<p>They both have the same signature but vary by name alone, which is why you can declare an instance of each and have them <strong class="bold">both</strong> point at the <strong class="bold">same</strong> target method when invoked:</p>
<p class="source-code">public static void Main()</p>
<p class="source-code">{</p>
<p class="source-code">    DoStuff stuff = new DoStuff(MyMethod);</p>
<p class="source-code">    DoMoreStuff moreStuff = new DoMoreStuff(MyMethod);</p>
<p class="source-code">    Console.WriteLine($"Stuff: {stuff("Louis", 2)}");</p>
<p class="source-code">    Console.WriteLine($"MoreStuff: {moreStuff("Louis", 2)}");</p>
<p class="source-code">}</p>
<p class="source-code">private static string MyMethod(string name, int age)</p>
<p class="source-code">{</p>
<p class="source-code">    return $"{name}@{age}";</p>
<p class="source-code">}</p>
<p>Running the console app produces the same results in both calls:</p>
<p class="source-code">Stuff: Louis@2</p>
<p class="source-code">MoreStuff: Louis@2</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/r6B8n">https://packt.link/r6B8n</a>.</p>
<p>It would be great if you could dispense with defining both <strong class="source-inline">DoStuff</strong> and <strong class="source-inline">DoMoreStuff</strong> delegates and use a more generalized delegate with precisely the same signature. After all, it does not matter in the preceding snippet if you create a <strong class="source-inline">DoStuff</strong> or <strong class="source-inline">DoMoreStuff</strong> delegate, since both make a call to the same target method.</p>
<p>.NET does, in fact, provide various inbuilt delegates that you can make use of directly, saving you the effort of defining such delegates yourself. These are the <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates.</p>
<p>There are many possible combinations of <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates, each allowing an increasing number of parameters. You can specify anywhere from zero to 16 different parameter types. With so many combinations available, it is extremely unlikely that you will ever need to define your own delegate type.</p>
<p>It is worth noting that <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates were added in a later version of .NET and, as such, the use of custom delegates tends to be found in older legacy code. There is no need to create new delegates yourself.</p>
<p>In the following snippet, <strong class="source-inline">MyMethod</strong> is invoked using the three-argument <strong class="source-inline">Func</strong> variation; you will cover the odd-looking <strong class="source-inline">&lt;string, int, string&gt;</strong> syntax shortly:</p>
<p class="source-code">Func&lt;string, int, string&gt; funcStuff = MyMethod;</p>
<p class="source-code">Console.WriteLine($"FuncStuff: {funcStuff("Louis", 2)}");</p>
<p>This produces the same return value as the two earlier invocations:</p>
<p class="source-code">FuncStuff: Louis@2</p>
<p>Before you continue exploring <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates, it is useful to explore the <strong class="source-inline">Action&lt;string, int, string&gt;</strong> syntax a bit further. This syntax allows type parameters to be used to define classes and methods. These are known as generics and act as placeholders for a particular type. In <em class="italic">Chapter 4</em>, <em class="italic">Data Structures and LINQ</em>, you will cover generics in much greater detail, but it is worth summarizing their usage here with the <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates.</p>
<p>The non-generic version of the <strong class="source-inline">Action</strong> delegate is predefined in .NET as follows:</p>
<p class="source-code">public delegate void Action()</p>
<p>As you know from your earlier look at delegates, this is a delegate that does not take any arguments and does not have a return type; it is the simplest type of delegate available.</p>
<p>Contrast that with one of the generic <strong class="source-inline">Action</strong> delegates predefined in .NET:</p>
<p class="source-code">public delegate void Action&lt;T&gt;(T obj)</p>
<p>You can see this includes a <strong class="source-inline">&lt;T&gt;</strong> and <strong class="source-inline">T</strong> parameter section, which means it accepts a <strong class="bold">single-type</strong> argument. Using this, you can declare an <strong class="source-inline">Action</strong> that is constrained to a string, which takes a single string argument and returns no value, as follows:</p>
<p class="source-code">Action&lt;string&gt; actionA;</p>
<p>How about an <strong class="source-inline">int</strong> constrained version? This also has no return type and takes a single <strong class="source-inline">int</strong> argument:</p>
<p class="source-code">Action&lt;int&gt; actionB;</p>
<p>Can you see the pattern here? In essence, the type that you specify can be used to declare a type at compile time. What if you wanted two arguments, or three, or four…or 16? Simple. There are <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> generic types that can take up to <strong class="bold">16</strong> different argument types. You are very unlikely to be writing code that needs more than 16 parameters.</p>
<p>This two-argument <strong class="source-inline">Action</strong> takes <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong> as parameters:</p>
<p class="source-code">Action&lt;int, string&gt; actionC;</p>
<p>You can spin that around. Here is another two-argument <strong class="source-inline">Action</strong>, but this takes a <strong class="source-inline">string</strong> parameter and then an <strong class="source-inline">int</strong> parameter:</p>
<p class="source-code">Action&lt;string, int&gt; actionD;</p>
<p>These cover most argument combinations, so you can see that it is very rare to create your own delegate types.</p>
<p>The same rules apply to delegates that return a value; this is where the <strong class="source-inline">Func</strong> types are used. The generic <strong class="source-inline">Func</strong> type starts with a single value type parameter:</p>
<p class="source-code">public delegate T Func&lt;T&gt;()</p>
<p>In the following example, <strong class="source-inline">funcE</strong> is a delegate that returns a Boolean value and takes no arguments:</p>
<p class="source-code">Func&lt;bool&gt; funcE;</p>
<p>Can you guess which is the return type from this rather long <strong class="source-inline">Func</strong> declaration?</p>
<p class="source-code">Func&lt;bool, int, int, DateTime, string&gt; funcF;</p>
<p>This gives a delegate that returns a <strong class="source-inline">string</strong> . In other words, the last argument type in a <strong class="source-inline">Func</strong> defines the return type. Notice that <strong class="source-inline">funcF</strong> takes four arguments: <strong class="source-inline">bool</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">DateTime</strong>.</p>
<p>In summary, generics are a great way to define types. They save a lot of duplicate code by allowing type parameters to act as placeholders.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>Assigning Delegates</h2>
<p>You covered creating custom delegates and briefly how to assign and invoke a delegate in <em class="italic">Exercise 3.01</em>. You then looked at using the preferred <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> equivalents, but what other options do you have for assigning the method (or methods) that form a delegate? Are there other ways to invoke a delegate?</p>
<p>Delegates can be assigned to a variable in much the same way that you might assign a class instance. You can also pass new instances or static instances around without having to use variables to do so. Once assigned, you can invoke the delegate or pass the reference to other classes so they can invoke it, and this is often done within the Framework API.</p>
<p>You will now look at a <strong class="source-inline">Func</strong> delegate, which takes a single <strong class="source-inline">DateTime</strong> argument and returns a <strong class="source-inline">bool</strong> value to indicate validity. You will use a <strong class="source-inline">static</strong> class containing two helper methods, which form the actual target:</p>
<p class="source-code">public static class DateValidators</p>
<p class="source-code">{</p>
<p class="source-code">    public static bool IsWeekend(DateTime dateTime)</p>
<p class="source-code">        =&gt; dateTime.DayOfWeek == DayOfWeek.Saturday ||</p>
<p class="source-code">           dateTime.DayOfWeek == DayOfWeek.Sunday;</p>
<p class="source-code">    public static bool IsFuture(DateTime dateTime) </p>
<p class="source-code">      =&gt; dateTime.Date &gt; DateTime.Today;</p>
<p class="source-code">}</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/mwmxh">https://packt.link/mwmxh</a>.</p>
<p>Note that the <strong class="source-inline">DateValidators</strong> class is marked as <strong class="source-inline">static</strong>. You may have heard the phrase <strong class="bold">statics are inefficient</strong>. In other words, creating an application with many static classes is a weak practice. Static classes are instantiated the first time they are accessed by running code and remain in memory until the application is closed. This makes it difficult to control their lifetime. Defining small utility classes as static is less of an issue, provided they do indeed remain stateless. Stateless means they do not set any local variables. Static classes that set local states are very difficult to unit test; you can never be sure that the variable set is from one test or another test.</p>
<p>In the preceding snippet, <strong class="source-inline">IsFuture</strong> returns <strong class="source-inline">true</strong> if the <strong class="source-inline">Date</strong> property of the <strong class="source-inline">DateTime</strong> argument is later than the current date. You are using the static <strong class="source-inline">DateTime.Today</strong> property to retrieve the current system date. <strong class="source-inline">IsWeekend</strong> is defined using an expression-bodied syntax and will return <strong class="source-inline">true</strong> if the <strong class="source-inline">DateTime</strong> argument's day of the week falls on a Saturday or Sunday.</p>
<p>You can assign delegates the same way that you would assign regular variables (remember you do <strong class="bold">not</strong> have to assign a variable to pass to other classes). You will now create two validator variables, <strong class="source-inline">futureValidator</strong> and <strong class="source-inline">weekendValidator</strong>. Each constructor is passed the actual target method, the <strong class="source-inline">IsFuture</strong> or <strong class="source-inline">IsWeekend</strong> instance, respectively:</p>
<p class="source-code"><a id="_idTextAnchor140"/>var <a id="_idTextAnchor141"/>futureValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsFuture);</p>
<p class="source-code">var weekendValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsWeekend);</p>
<p>Note that it is not valid to use the <strong class="source-inline">var</strong> keyword to assign a delegate without wrapping in the <strong class="source-inline">Func</strong> prefix:</p>
<p class="source-code">var futureValidator = DateValidation.IsFuture;</p>
<p>This results in the following compiler error:</p>
<p class="source-code">Cannot assign method group to an implicitly - typed variable</p>
<p>Taking this knowledge of delegates, proceed to how you can invoke a delegate.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor142"/>Invoking a Delegate</h2>
<p>There are several ways to invoke a delegate. For example, consider the following definition:</p>
<p class="source-code">var futureValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsFuture);</p>
<p>To invoke <strong class="source-inline">futureValidator</strong>, you must pass in a <strong class="source-inline">DateTime</strong> value, and it will return a <strong class="source-inline">bool</strong> value using any of these styles:</p>
<ul>
<li>Invoke with the null-coalescing operator:<p class="source-code">var isFuture1 = futureValidator?.Invoke(new DateTime(2000, 12, 31));</p></li>
</ul>
<p>This is the preferred and safest approach; you should always check for a null before calling <strong class="source-inline">Invoke</strong>. If there is a chance that a delegate does not point to an object in memory, then you must perform a null reference check before accessing methods and properties. A failure to do so will result in <strong class="source-inline">NullReferenceException</strong> being thrown. This is the runtime's way of warning you that the object is not pointing at anything.</p>
<p>By using the null-coalescing operator, the compiler will add the null check for you. In the code, you explicitly declared <strong class="source-inline">futureValidator</strong>, so here it cannot be null. But what if you had been passed <strong class="source-inline">futureValidator</strong> from another method? How can you be sure that the caller had correctly assigned a reference?</p>
<p>Delegates have additional rules that make it possible for them to throw <strong class="source-inline">NullReferenceException</strong> when invoked. In the preceding example, <strong class="source-inline">futureValidator</strong> has a single target, but as you will see later, the <strong class="bold">multicast</strong> feature of delegates allows multiple methods to be added and removed from a list of target methods. If all target methods are removed (which can happen), the runtime will throw a <strong class="source-inline">NullReferenceException</strong>.</p>
<ul>
<li>Direct Invoke</li>
</ul>
<p>This is the same as the previous method, but without the safety of the null check. This is not recommended for the same reason; that is, the delegate can throw a <strong class="source-inline">NullReferenceException</strong>:</p>
<p class="source-code">var isFuture1 = futureValidator.Invoke(new DateTime(2000, 12, 31));</p>
<ul>
<li>Without the <strong class="source-inline">Invoke</strong> prefix</li>
</ul>
<p>This looks more succinct as you simply call the delegate without the <strong class="source-inline">Invoke</strong> prefix. Again, this is not recommended due to a possible null reference:</p>
<p class="source-code">var isFuture2 = futureValidator(new DateTime(2050, 1, 20));</p>
<p>Try assigning and safely invoking a delegate through an exercise by bringing them together.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor143"/>Exercise 3.02: Assigning and Invoking Delegates</h2>
<p>In this exercise, you are going to write a console app showing how a <strong class="source-inline">Func</strong> delegate can be used to extract numeric values. You will create a <strong class="source-inline">Car</strong> class that has <strong class="source-inline">Distance</strong> and <strong class="source-inline">JourneyTime</strong> properties. You will prompt the user to enter the distance traveled yesterday and today, passing this information to a <strong class="source-inline">Comparison</strong> class that is told how to extract values and calculate their differences.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise02</strong>, using the CLI <strong class="source-inline">dotnet</strong> command:<p class="source-code">source\Chapter03&gt;dotnet new console -o Exercise02</p></li>
<li>Open <strong class="source-inline">Chapter03\Exercise02.csproj</strong> and replace the entire file with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise02\Program.cs</strong> and clear the contents.</li>
<li>Start by adding a record called <strong class="source-inline">Car</strong>. Include the <strong class="source-inline">System.Globalization</strong> namespace for string parsing. Use the <strong class="source-inline">Chapter03.Exercise02</strong> namespace to keep code separate from the other exercises.</li>
<li>Add two properties, <strong class="source-inline">Distance</strong> and <strong class="source-inline">JourneyTime</strong>. They will have <strong class="source-inline">init</strong>-only properties, so you will use the <strong class="source-inline">init</strong> keyword:<p class="source-code">using System;</p><p class="source-code">using System.Globalization;</p><p class="source-code">namespace Chapter03.Exercise02</p><p class="source-code">{</p><p class="source-code">    public record Car</p><p class="source-code">    {</p><p class="source-code">        public double Distance { get; init; }</p><p class="source-code">        public double JourneyTime { get; init; }</p><p class="source-code">    }</p></li>
<li>Next, create a class named <strong class="source-inline">Comparison</strong> that is passed a <strong class="source-inline">Func</strong> delegate to work with. The <strong class="source-inline">Comparison</strong> class will use the delegate to extract either the <strong class="source-inline">Distance</strong> or <strong class="source-inline">JourneyTime</strong> properties and calculate the difference for two <strong class="source-inline">Car</strong> instances. By using the flexibility of delegates, <strong class="source-inline">Comparison</strong> will not know whether it is extracting <strong class="source-inline">Distance</strong> or <strong class="source-inline">JourneyTime</strong>, just that it is using a double to calculate the differences. This shows that you can reuse this class should you need to calculate other <strong class="source-inline">Car</strong> properties in the future:<p class="source-code">    public class Comparison</p><p class="source-code">    {</p><p class="source-code">        private readonly Func&lt;Car, double&gt; _valueSelector;</p><p class="source-code">        public Comparison(Func&lt;Car, double&gt; valueSelector)</p><p class="source-code">        {</p><p class="source-code">            _valueSelector = valueSelector;</p><p class="source-code">        } </p></li>
<li>Add three properties that form the results of the calculation, as follows:<p class="source-code">        public double Yesterday { get; private set; }</p><p class="source-code">        public double Today { get; private set; }</p><p class="source-code">        public double Difference { get; private set; }</p></li>
<li>Now for the calculation, pass two <strong class="source-inline">Car</strong> instances, one for the car journey yesterday, <strong class="source-inline">yesterdayCar</strong>, and one for today, <strong class="source-inline">todayCar</strong>:<p class="source-code">        public void Compare(Car yesterdayCar, Car todayCar)</p><p class="source-code">        {</p></li>
<li>To calculate a value for <strong class="source-inline">Yesterday</strong>, invoke the <strong class="source-inline">valueSelector</strong> <strong class="source-inline">Func</strong> delegate, passing in the <strong class="source-inline">yesterdayCar</strong> instance. Again, remember that the <strong class="source-inline">Comparison</strong> class is unaware whether it is extracting <strong class="source-inline">Distance</strong> or <strong class="source-inline">JourneyTime</strong>; it just needs to know that when the <strong class="source-inline">delegate</strong> is invoked with a <strong class="source-inline">Car</strong> argument, it will get a double number back:<p class="source-code">            Yesterday = _valueSelector(yesterdayCar);</p></li>
<li>Do the same to extract the value for <strong class="source-inline">Today</strong> by using the same <strong class="source-inline">Func</strong> delegate, but passing in the <strong class="source-inline">todayCar</strong> instance instead:<p class="source-code">            Today = _valueSelector(todayCar);</p></li>
<li>Now it is just a case of calculating the difference between the two extracted numbers; you don't need to use the <strong class="source-inline">Func</strong> delegate to do that:<p class="source-code">            Difference = Yesterday - Today;</p><p class="source-code">        }</p><p class="source-code">     }</p></li>
<li>So, you have a class that knows how to invoke a <strong class="source-inline">Func</strong> delegate to extract a certain <strong class="source-inline">Car</strong> property when it is told how to. Now, you need a class to wrap up the <strong class="source-inline">Comparison</strong> instances. For this, add a class called <strong class="source-inline">JourneyComparer</strong>:<p class="source-code">    public class JourneyComparer</p><p class="source-code">    {</p><p class="source-code">        public JourneyComparer()</p><p class="source-code">        {</p></li>
<li>For the car journey, you need to calculate the difference between the <strong class="source-inline">Yesterday</strong> and <strong class="source-inline">Today</strong> <strong class="source-inline">Distance</strong> properties. To do so, create a <strong class="source-inline">Comparison</strong> class that is told how to extract a value from a <strong class="source-inline">Car</strong> instance. You may as well use the same name for this <strong class="source-inline">Comparison</strong> class as you will extract a car's <strong class="source-inline">Distance</strong>. Remember that the <strong class="source-inline">Comparison</strong> constructor needs a <strong class="source-inline">Func</strong> delegate that is passed a <strong class="source-inline">Car</strong> instance and returns a double value. You will add <strong class="source-inline">GetCarDistance()</strong> shortly; this will eventually be invoked by passing <strong class="source-inline">Car</strong> instances for yesterday's and today's journeys:<p class="source-code">          Distance = new Comparison(GetCarDistance);</p></li>
<li>Repeat the process as described in the preceding steps for a <strong class="source-inline">JourneyTime</strong> <strong class="source-inline">Comparison</strong>; this one should be told to use <strong class="source-inline">GetCarJourneyTime()</strong> as follows:<p class="source-code">          JourneyTime = new Comparison(GetCarJourneyTime);</p></li>
<li>Finally, add another <strong class="source-inline">Comparison</strong> property called <strong class="source-inline">AverageSpeed</strong> as follows. You will see shortly that <strong class="source-inline">GetCarAverageSpeed()</strong> is yet another function:<p class="source-code">           AverageSpeed = new Comparison(GetCarAverageSpeed);</p></li>
<li>Now for the <strong class="source-inline">GetCarDistance</strong> and <strong class="source-inline">GetCarJourneyTime</strong> local functions, they are passed a <strong class="source-inline">Car</strong> instance and return either <strong class="source-inline">Distance</strong> or <strong class="source-inline">JourneyTime</strong> accordingly:<p class="source-code">           static double GetCarDistance(Car car) =&gt; car.Distance; </p><p class="source-code">           static double GetCarJourneyTime(Car car) =&gt; car.JourneyTime;</p></li>
<li><strong class="source-inline">GetCarAverageSpeed</strong>, as the name suggests, returns the average speed. Here, you have shown that the <strong class="source-inline">Func</strong> delegate just needs a compatible function; it doesn't matter what it returns as long as it is <strong class="source-inline">double</strong>. The <strong class="source-inline">Comparison</strong> class does not need to know that it is returning a calculated value such as this when it invokes the <strong class="source-inline">Func</strong> delegate:<p class="source-code">          static double GetCarAverageSpeed(Car car)             =&gt; car.Distance / car.JourneyTime;</p><p class="source-code">       }</p></li>
<li>The three <strong class="source-inline">Comparison</strong> properties should be defined like this:<p class="source-code">        public Comparison Distance { get; }</p><p class="source-code">        public Comparison JourneyTime { get; }</p><p class="source-code">        public Comparison AverageSpeed { get; }</p></li>
<li>Now for the main <strong class="source-inline">Compare</strong> method. This will be passed two <strong class="source-inline">Car</strong> instances, one for <strong class="source-inline">yesterday</strong> and one for <strong class="source-inline">today</strong>, and it simply calls <strong class="source-inline">Compare</strong> on the three <strong class="source-inline">Comparison</strong> items passing in the two <strong class="source-inline">Car</strong> instances:<p class="source-code">        public void Compare(Car yesterday, Car today)</p><p class="source-code">        {</p><p class="source-code">            Distance.Compare(yesterday, today);</p><p class="source-code">            JourneyTime.Compare(yesterday, today);</p><p class="source-code">            AverageSpeed.Compare(yesterday, today);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>You need a console app to enter the miles traveled per day, so add a class called <strong class="source-inline">Program</strong> with a static <strong class="source-inline">Main</strong> entry point:<p class="source-code">    public class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>You can randomly assign journey times to save some input, so add a new <strong class="source-inline">Random</strong> instance and the start of a <strong class="source-inline">do-while</strong> loop, as follows:<p class="source-code">            var random = new Random();</p><p class="source-code">            string input;</p><p class="source-code">            do</p><p class="source-code">            {</p></li>
<li>Read for yesterday's distance, as follows:<p class="source-code">                Console.Write("Yesterday's distance: ");</p><p class="source-code">                input = Console.ReadLine();</p><p class="source-code">                double.TryParse(input, NumberStyles.Any,                    CultureInfo.CurrentCulture, out var distanceYesterday);</p></li>
<li>You can use the distance to create yesterday's <strong class="source-inline">Car</strong> with a random <strong class="source-inline">JourneyTime</strong>, as follows:<p class="source-code">                var carYesterday = new Car</p><p class="source-code">                {</p><p class="source-code">                    Distance = distanceYesterday,</p><p class="source-code">                    JourneyTime = random.NextDouble() * 10D</p><p class="source-code">                };</p></li>
<li>Do the same for today's distance:<p class="source-code">                Console.Write("    Today's distance: ");</p><p class="source-code">                input = Console.ReadLine();</p><p class="source-code">                double.TryParse(input, NumberStyles.Any,                    CultureInfo.CurrentCulture, out var distanceToday);</p><p class="source-code">                var carToday = new Car</p><p class="source-code">                {</p><p class="source-code">                    Distance = distanceToday,</p><p class="source-code">                    JourneyTime = random.NextDouble() * 10D</p><p class="source-code">                };</p></li>
<li>Now that you have two <strong class="source-inline">Car</strong> instances populated with values for yesterday and today, you can create the <strong class="source-inline">JourneyComparer</strong> instance and call <strong class="source-inline">Compare</strong>. This will then call <strong class="source-inline">Compare</strong> on your three <strong class="source-inline">Comparison</strong> instances:<p class="source-code">                var comparer = new JourneyComparer();</p><p class="source-code">                comparer.Compare(carYesterday, carToday);</p></li>
<li>Now, write the results to the console:<p class="source-code">                Console.WriteLine();</p><p class="source-code">                Console.WriteLine("Journey Details   Distance\tTime\tAvg Speed");</p><p class="source-code">                Console.WriteLine("-------------------------------------------------");</p></li>
<li>Write out yesterday's results:<p class="source-code">                Console.Write($"Yesterday         {comparer.Distance.Yesterday:N0}   \t");</p><p class="source-code">                Console.WriteLine($"{comparer.JourneyTime.Yesterday:N0}\t {comparer.AverageSpeed.Yesterday:N0}");</p></li>
<li>Write out today's results:<p class="source-code">                Console.Write($"Today             {comparer.Distance.Today:N0}     \t");                 Console.WriteLine($"{comparer.JourneyTime.Today:N0}\t {comparer.AverageSpeed.Today:N0}");</p></li>
<li>Finally, write the summary values using the <strong class="source-inline">Difference</strong> properties:<p class="source-code">                Console.WriteLine("=================================================");</p><p class="source-code">                Console.Write($"Difference             {comparer.Distance.Difference:N0}     \t");                Console.WriteLine($"{comparer.JourneyTime.Difference:N0} \t{comparer.AverageSpeed.Difference:N0}");</p><p class="source-code">               Console.WriteLine("=================================================");</p></li>
<li><a id="_idTextAnchor144"/>Finish off the <strong class="source-inline">do-while</strong> loop, exiting if the user enters an empty string:<p class="source-code">            } </p><p class="source-code">            while (!string.IsNullOrEmpty(input));</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Running the console and entering distances of <strong class="source-inline">1000</strong> and <strong class="source-inline">900</strong> produces the following results:</p>
<p class="source-code">Yesterday's distance: 1000</p>
<p class="source-code">    Today's distance: 900</p>
<p class="source-code">Journey Details   Distance      Time    Avg Speed</p>
<p class="source-code">-------------------------------------------------</p>
<p class="source-code">Yesterday         1,000         8       132</p>
<p class="source-code">Today             900           4       242</p>
<p class="source-code">=================================================</p>
<p class="source-code">Difference        100           4       -109</p>
<p>The program will run in a loop until you enter a blank value. You will notice a different output as the <strong class="source-inline">JourneyTime</strong> is set using a random value returned by an instance of <strong class="source-inline">Random</strong> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/EJTtS">https://packt.link/EJTtS</a>.</p>
<p>In this exercise, you have seen how a <strong class="source-inline">Func&lt;Car, double&gt;</strong> delegate is used to create general-purpose code that can be easily reused without the need to create extra interfaces or classes.</p>
<p>Now it is time to look at the second important aspect of deletes and their ability to chain multiple target methods together.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor145"/>Multicast Delegates</h2>
<p>So far, you have invoked delegates that have a single method assigned, typically in the form of a function call. Delegates offer the ability to combine a list of methods that are executed with a single invocation call, using the <strong class="bold">multicast</strong> feature. By using the <strong class="source-inline">+=</strong> operator, any number of additional target methods can be added to the target list. Every time the delegate is invoked, each one of the target methods gets invoked too. But what if you decide you want to remove a target method? That is where the <strong class="source-inline">-=</strong> operator is used.</p>
<p>In the following code snippet, you have an <strong class="source-inline">Action&lt;string&gt;</strong> delegate named <strong class="source-inline">logger</strong>. It starts with a single target method, <strong class="source-inline">LogToConsole</strong>. If you were to invoke this delegate, passing in a string, then the <strong class="source-inline">LogToConsole</strong> method will be called once:</p>
<p class="source-code"><a id="_idTextAnchor146"/>Action&lt;string&gt; logger = LogToConsole;</p>
<p class="source-code">logger("1. Calculating bill");  </p>
<p>If you were to watch the call stack, you would observe these calls:</p>
<p class="source-code">logger("1. Calculating bill")</p>
<p class="source-code">--&gt; LogToConsole("1. Calculating bill")</p>
<p>To add a new target method, you use the <strong class="source-inline">+=</strong> operator. The following statement adds <strong class="source-inline">LogToFile</strong> to the <strong class="source-inline">logger</strong> delegate's invocation list:</p>
<p class="source-code">logger += LogToFile;</p>
<p>Now, every time you invoke <strong class="source-inline">logger</strong>, both <strong class="source-inline">LogToConsole</strong> and <strong class="source-inline">LogToFile</strong> will be called. Now invoke <strong class="source-inline">logger</strong> a second time:</p>
<p class="source-code">logger("2. Saving order"); </p>
<p>The call stack looks like this:</p>
<p class="source-code">logger("2. Saving order")</p>
<p class="source-code">--&gt; LogToConsole("2. Saving order")</p>
<p class="source-code">--&gt; LogToFile("2. Saving order")</p>
<p>Again, suppose you use <strong class="source-inline">+=</strong> to add a third target method called <strong class="source-inline">LogToDataBase</strong> as follows:</p>
<p class="source-code">logger += LogToDataBase</p>
<p>Now invoke it once again:</p>
<p class="source-code">logger("3. Closing order"); </p>
<p>The call stack looks like this:</p>
<p class="source-code">logger("3. Closing order")</p>
<p class="source-code">--&gt; LogToConsole("3. Closing order")</p>
<p class="source-code">--&gt; LogToFile("3. Closing order")</p>
<p class="source-code">--&gt; LogToDataBase("3. Closing order")</p>
<p>However, consider that you may no longer want to include <strong class="source-inline">LogToFile</strong> in the target method list. In such a case, simply use the <strong class="source-inline">-=</strong> operator to remove it, as follows:</p>
<p class="source-code">logger -= LogToFile</p>
<p>You can again invoke the delegate as follows:</p>
<p class="source-code">logger("4. Closing customer"); </p>
<p>And now, the call stack looks like this:</p>
<p class="source-code">logger("4. Closing customer")</p>
<p class="source-code">--&gt; LogToConsole("4. Closing customer")</p>
<p class="source-code">--&gt; LogToDataBase("4. Closing customer")</p>
<p>As can be seen, this code resulted in just <strong class="bold">two</strong> method calls, <strong class="source-inline">LogToConsole</strong> and <strong class="source-inline">LogToDataBase</strong>.</p>
<p>By using delegates in this way, you can decide which target methods get called based on certain criteria at runtime. This allows you to pass this configured delegate into other methods, to be invoked as and when needed.</p>
<p>You have seen that <strong class="source-inline">Console.WriteLine</strong> can be used to write messages to the console window. To create a method that logs to a file (as <strong class="source-inline">LogToFile</strong> does in the preceding example), you need to use the <strong class="source-inline">File</strong> class from the <strong class="source-inline">System.IO</strong> namespace. <strong class="source-inline">File</strong> has many static methods that can be used to read and write files. You will not go into full details about <strong class="source-inline">File</strong> here, but it is worth mentioning the <strong class="source-inline">File.AppendAllText</strong> method, which can be used to create or replace a text file containing a string value, <strong class="source-inline">File.Exists</strong>, which is used to check for the existence of a file, and <strong class="source-inline">File.Delete</strong>, to delete a file.</p>
<p>Now it is time to practice what you have learned through an exercise.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor147"/>Exercise 3.03: Invoking a Multicast Delegate</h2>
<p>In this exercise, you will use a multicast delegate to create a cash machine that logs details when a user enters their PIN and asks to see their balance. For this, you will create a <strong class="source-inline">CashMachine</strong> class that invokes a configured <strong class="bold">logging</strong> delegate, which you can use as a controller class to decide whether messages are sent to the file or to the console.</p>
<p>You will use an <strong class="source-inline">Action&lt;string&gt;</strong> delegate as you do not need any values to return. Using <strong class="source-inline">+=</strong>, you can control which target methods get called when your delegate is invoked by <strong class="source-inline">CashMachine</strong>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise03</strong>, using the CLI <strong class="source-inline">dotnet</strong> command:<p class="source-code">source\Chapter03&gt;dotnet new console -o Exercise03</p></li>
<li>Open <strong class="source-inline">Chapter03\Exercise03.csproj</strong> and replace the entire file with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise03\Program.cs</strong> and clear the contents.</li>
<li>Add a new class called <strong class="source-inline">CashMachine</strong>. </li>
<li>Use the <strong class="source-inline">Chapter03.Exercise03</strong> namespace:<p class="source-code">using System;</p><p class="source-code">using System.IO;</p><p class="source-code">namespace Chapter03.Exercise03</p><p class="source-code">{</p><p class="source-code">    public class CashMachine</p><p class="source-code">    {</p><p class="source-code">        private readonly Action&lt;string&gt; _logger;</p><p class="source-code">        public CashMachine(Action&lt;string&gt; logger)</p><p class="source-code">        {</p><p class="source-code">            _logger = logger;</p><p class="source-code">        } </p></li>
</ol>
<p>The <strong class="source-inline">CashMachine</strong> constructor is passed the <strong class="source-inline">Action&lt;string&gt;</strong> delegate, which you can assign to a <strong class="source-inline">readonly</strong> class variable called <strong class="source-inline">_logger</strong>.</p>
<ol>
<li value="6">Add a <strong class="source-inline">Log</strong> helper function that checks whether the <strong class="source-inline">_logger</strong> delegate is null before invoking:<p class="source-code">        private void Log(string message)</p><p class="source-code">            =&gt; _logger?.Invoke(message);</p></li>
<li>When the <strong class="source-inline">VerifyPin</strong> and <strong class="source-inline">ShowBalance</strong> methods are called, a message should be logged with some details. Create these methods as follows:<p class="source-code">        public void VerifyPin(string pin) </p><p class="source-code">            =&gt; Log($"VerifyPin called: PIN={pin}");</p><p class="source-code">        public void ShowBalance() </p><p class="source-code">            =&gt; Log("ShowBalance called: Balance=999");</p><p class="source-code">    }</p></li>
<li>Now, add a console app that configures a <strong class="source-inline">logger</strong> delegate that you can pass into a <strong class="source-inline">CashMachine</strong> object. Note that this is a common form of usage: a class that is responsible for deciding how messages are logged by other classes. Use a constant, <strong class="source-inline">OutputFile</strong>, for the filename to be used for file logging, as follows:<p class="source-code">    public static class Program</p><p class="source-code">    {</p><p class="source-code">        private const string OutputFile = "activity.txt";</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Each time the program runs, it should start with a <strong class="bold">clean text file</strong> for logging, so use <strong class="source-inline">File.Delete</strong> to delete the output file:<p class="source-code">            if (File.Exists(OutputFile))</p><p class="source-code">            {</p><p class="source-code">                File.Delete(OutputFile);</p><p class="source-code">            }</p></li>
<li>Create a delegate instance, <strong class="source-inline">logger</strong>, that starts with a single target method, <strong class="source-inline">LogToConsole</strong>:<p class="source-code">            Action&lt;string&gt; logger = LogToConsole;</p></li>
<li>Using the <strong class="source-inline">+=</strong> operator, add <strong class="source-inline">LogToFile</strong> as a second target method to also be called whenever the delegate is invoked by <strong class="source-inline">CashMachine</strong>:<p class="source-code">            logger += LogToFile;</p></li>
<li>You will implement the two target logging methods shortly; for now, create a <strong class="source-inline">cashMachine</strong> instance and get ready to call its methods, as follows:<p class="source-code">            var cashMachine = new CashMachine(logger);</p></li>
<li>Prompt for a <strong class="source-inline">pin</strong> and pass it to the <strong class="source-inline">VerifyPin</strong> method:<p class="source-code">            Console.Write("Enter your PIN:");</p><p class="source-code">            var pin = Console.ReadLine();</p><p class="source-code">            if (string.IsNullOrEmpty(pin))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine("No PIN entered");</p><p class="source-code">                return;</p><p class="source-code">            }</p><p class="source-code">            cashMachine.VerifyPin(pin);</p><p class="source-code">            Console.WriteLine();</p></li>
</ol>
<p>In case you enter a blank value, then it is checked and a warning is displayed. This will then close the program using a <strong class="source-inline">return</strong> statement.</p>
<ol>
<li value="14">Wait for the <strong class="source-inline">Enter</strong> key to be pressed before calling the <strong class="source-inline">ShowBalance</strong> method:<p class="source-code">            Console.Write("Press Enter to show balance");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">            cashMachine.ShowBalance();</p><p class="source-code">            Console.Write("Press Enter to quit");</p><p class="source-code">            Console.ReadLine();</p></li>
<li>Now for the logging methods. They must be compatible with your <strong class="source-inline">Action&lt;string&gt;</strong> delegate. One writes a message to the console and the other appends it to the text file. Add these two static methods as follows:<p class="source-code">            static void LogToConsole(string message)</p><p class="source-code">                =&gt; Console.WriteLine(message);</p><p class="source-code">            static void LogToFile(string message)</p><p class="source-code">                =&gt; File.AppendAllText(OutputFile, message);</p><p class="source-code">        }</p><p class="source-code">     }</p><p class="source-code">}</p></li>
<li>Running the console app, you see that <strong class="source-inline">VerifyPin</strong> and <strong class="source-inline">ShowBalance</strong> calls are written to the console:<p class="source-code">Enter your PIN:12345</p><p class="source-code">VerifyPin called: PIN=12345</p><p class="source-code">Press Enter to show balance</p><p class="source-code">ShowBalance called: Balance=999</p></li>
<li>For each <strong class="source-inline">logger</strong> delegate invocation, the <strong class="source-inline">LogToFile</strong> method will also be called, so when opening <strong class="source-inline">activity.txt</strong>, you should see the following line:<p class="source-code">VerifyPin called: PIN=12345ShowBalance called: Balance=999</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/h9vic">https://packt.link/h9vic</a>.</p></li>
</ol>
<p>It is important to remember that delegates are immutable, so each time you use the <strong class="source-inline">+=</strong> or <strong class="source-inline">-=</strong> operators, you create a <strong class="bold">new</strong> delegate instance. This means that if you alter a delegate after you have passed it to a target class, you will not see any changes to the methods called from inside that target class.</p>
<p>You can see this in action in the following example:</p>
<p class="source-code-heading">MulticastDelegatesAddRemoveExample.cs</p>
<p class="source-code">using System;</p>
<p class="source-code">namespace Chapter03Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class MulticastDelegatesAddRemoveExample</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            Action&lt;string&gt; logger = LogToConsole;</p>
<p class="source-code">            Console.WriteLine($"Logger1 #={logger.GetHashCode()}");</p>
<p class="source-code">            logger += LogToConsole;</p>
<p class="source-code">            Console.WriteLine($"Logger2 #={logger.GetHashCode()}");</p>
<p class="source-code">            logger += LogToConsole;</p>
<p class="source-code">            Console.WriteLine($"Logger3 #={logger.GetHashCode()}");</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/vqZMF">https://packt.link/vqZMF</a>.</p>
<p>All objects in C# have a <strong class="source-inline">GetHashCode()</strong> function that returns a unique ID. Running the code produces this output:</p>
<p class="source-code">Logger1 #=46104728</p>
<p class="source-code">Logger2 #=1567560752</p>
<p class="source-code">Logger3 #=236001992</p>
<p>You can see that the <strong class="bold">hashcode</strong> is changing after each <strong class="source-inline">+=</strong> call. This shows that the object reference is changing each time.</p>
<p>Now look at another example using an <strong class="source-inline">Action&lt;string&gt;</strong> delegate. Here, you will use the <strong class="source-inline">+=</strong> operator to add target methods and then use <strong class="source-inline">-=</strong> to remove the target methods:</p>
<p class="source-code-heading">MulticastDelegatesExample.cs</p>
<p class="source-code">using System;</p>
<p class="source-code">namespace Chapter03Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class MulticastDelegatesExample</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            Action&lt;string&gt; logger = LogToConsole;</p>
<p class="source-code">            logger += LogToConsole;</p>
<p class="source-code">            logger("Console x 2");</p>
<p class="source-code">             </p>
<p class="source-code">            logger -= LogToConsole;</p>
<p class="source-code">            logger("Console x 1");</p>
<p class="source-code">            logger -= LogToConsole;</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/Xe0Ct">https://packt.link/Xe0Ct</a>.</p>
<p>You start with one target method, <strong class="source-inline">LogToConsole</strong>, and then add the same target method a second time. Invoking the logger delegate using <strong class="source-inline">logger("Console x 2")</strong> results in <strong class="source-inline">LogToConsole</strong> being called twice.</p>
<p>You then use <strong class="source-inline">-=</strong> to remove <strong class="source-inline">LogToConsole</strong> <strong class="bold">twice</strong> such that had two targets and now you do not have any at all. Running the code produces the following output:</p>
<p class="source-code">Console x 2</p>
<p class="source-code">Console x 2</p>
<p class="source-code">Console x 1</p>
<p>However, rather than <strong class="source-inline">logger("logger is now null")</strong> running correctly, you end up with an unhandled exception being thrown like so:</p>
<p class="source-code">System.NullReferenceException</p>
<p class="source-code">  HResult=0x80004003</p>
<p class="source-code">  Message=Object reference not set to an instance of an object.</p>
<p class="source-code">  Source=Examples</p>
<p class="source-code">  StackTrace:</p>
<p class="source-code">   at Chapter03Examples.MulticastDelegatesExample.Main() in Chapter03\MulticastDelegatesExample.cs:line 16</p>
<p>By removing the last target method, the <strong class="source-inline">-=</strong> operator returned a null reference, which you then assigned to the logger. As you can see, it is important to always check that a delegate is not null before trying to invoke it.</p>
<h3 id="_idParaDest-138"><a id="_idTextAnchor148"/>Multicasting with a Func Delegate</h3>
<p>So far, you have used <strong class="source-inline">Action&lt;string&gt;</strong> delegates within <strong class="bold">multicast</strong> scenarios. When invoked, a string value is passed to any target method. As the target methods do not return a value, you use <strong class="source-inline">Action</strong> delegates.</p>
<p>You have seen that <strong class="source-inline">Func</strong> delegates are used when a return value is required from an invoked delegate. It is also perfectly legal for the C# complier to use <strong class="source-inline">Func</strong> delegates in multicast delegates.</p>
<p>Consider the following example where you have a <strong class="source-inline">Func&lt;string, string&gt;</strong> delegate. This delegate supports functions that are passed a string and return a formatted string is returned. This could be used when you need to format an email address by removing the <strong class="source-inline">@</strong> sign and dot symbols:</p>
<p class="source-code">using System;</p>
<p class="source-code">namespace Chapter03Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class FuncExample</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p>You start by assigning the <strong class="source-inline">RemoveDots</strong> string function to <strong class="source-inline">emailFormatter</strong> and invoke it using the <strong class="source-inline">Address</strong> constant:</p>
<p class="source-code">            Func&lt;string, string&gt; emailFormatter = RemoveDots;</p>
<p class="source-code">            const string Address = "admin@google.com";</p>
<p class="source-code">            var first = emailFormatter(Address);</p>
<p class="source-code">            Console.WriteLine($"First={first}");</p>
<p>Then you add a second target, <strong class="source-inline">RemoveAtSign</strong>, and invoke <strong class="source-inline">emailFormatter</strong> a second time:</p>
<p class="source-code">            emailFormatter += RemoveAtSign;</p>
<p class="source-code">            var second = emailFormatter(Address);</p>
<p class="source-code">            Console.WriteLine($"Second={second}");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">            static string RemoveAtSign(string address)</p>
<p class="source-code">                =&gt; address.Replace("@", "");</p>
<p class="source-code">            static string RemoveDots(string address)</p>
<p class="source-code">                =&gt; address.Replace(".", "");</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">} </p>
<p>Running the code produces this output:</p>
<p class="source-code">First=admin@googlecom</p>
<p class="source-code">Second=admingoogle.com</p>
<p>The first invocation returns the <strong class="source-inline">admin@googlecom</strong> string. The <strong class="bold">dot</strong> symbol has been removed, but the next invocation, with <strong class="source-inline">RemoveAtSign</strong> added to the target list, returns a value with only the <strong class="source-inline">@</strong> symbol removed.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fshse">https://packt.link/fshse</a>.</p>
<p>Both <strong class="source-inline">Func1</strong> and <strong class="source-inline">Func2</strong> are invoked, but only the value from <strong class="source-inline">Func2</strong> is returned to both <strong class="source-inline">ResultA</strong> and <strong class="source-inline">ResultB</strong> variables, even though the correct arguments are passed in. When a <strong class="source-inline">Func&lt;&gt;</strong> delegate is used with multicast in this manner, all of the target <strong class="source-inline">Func</strong> instances are called, but the return value will be that of the last <strong class="source-inline">Func&lt;&gt;</strong> in the chain. <strong class="source-inline">Func&lt;&gt;</strong> is better suited in a single method scenario, although the compiler will still allow you to use it as a multicast delegate without any compilation error or warning.</p>
<h3 id="_idParaDest-139"><a id="_idTextAnchor149"/>What Happens When Things Go Wrong?</h3>
<p>When a delegate is invoked, all methods in the invocation list are called. In the case of single-name delegates, this will be one target method. What happens in the case of multicast delegates if one of those targets throws an exception?</p>
<p>Consider the following code. When the <strong class="source-inline">logger</strong> delegate is invoked, by passing in <strong class="source-inline">try log this</strong>, you may expect the methods to be called in the order that they were added: <strong class="source-inline">LogToConsole</strong>, <strong class="source-inline">LogToError</strong>, and finally <strong class="source-inline">LogToDebug</strong>:</p>
<p class="source-code-heading">MulticastWithErrorsExample.cs</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Diagnostics;</p>
<p class="source-code">namespace Chapter03Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class MulticastWithErrorsExample</p>
<p class="source-code">    {</p>
<p class="source-code">            public static void Main()</p>
<p class="source-code">            {</p>
<p class="source-code">                <a id="_idTextAnchor150"/>Action&lt;string&gt; logger = LogToConsole;</p>
<p class="source-code">                logger += LogToError;</p>
<p class="source-code">                logger += LogToDebug;</p>
<p class="source-code">                try</p>
<p class="source-code">                {</p>
<p class="source-code">                    logger("try log this");</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/Ti3Nh">https://packt.link/Ti3Nh</a>.</p>
<p>If any target method throws an exception, such as the one you see in <strong class="source-inline">LogToError</strong>, then the remaining targets are <strong class="bold">not</strong> called.</p>
<p>Running the code results in the following output:</p>
<p class="source-code">Console: try log this</p>
<p class="source-code">Caught oops!</p>
<p class="source-code">All done</p>
<p>You will see this output because the <strong class="source-inline">LogToDebug</strong> method wasn't called at all. Consider a UI with multiple targets listening to a mouse button click. The first method fires when a button is pressed and disables the button to prevent double-clicks, the second method changes the button's image to indicate success, and the third method enables the button.</p>
<p>If the second method fails, then the third method will not get called, and the button could remain in a disabled state with an incorrect image assigned, thereby confusing the user.</p>
<p>To ensure that all target methods are run regardless, you can enumerate through the invocation list and invoke each method manually. Take a look at the .NET <strong class="source-inline">MulticastDelegate</strong> type. You will find that there is a function, <strong class="source-inline">GetInvocationList</strong>, that returns an array of the delegate objects. This array contains the target methods that have been added:</p>
<p class="source-code">public abstract class MulticastDelegate : Delegate {</p>
<p class="source-code">  public sealed override Delegate[] GetInvocationList();</p>
<p class="source-code">}</p>
<p>You can then loop through those target methods and execute each one inside a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. Now practice what you learned through this exercise.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor151"/>Exercise 3.04: Ensuring All Target Methods Are Invoked in a Multicast Delegate</h2>
<p>Throughout this chapter, you have been using <strong class="source-inline">Action&lt;string&gt;</strong> delegates to perform various logging operations. In this exercise, you have a list of target methods for a logging delegate and you want to ensure that "all" target methods are invoked even if earlier ones fail. You may have a scenario where logging to a database or filesystem fails occasionally, maybe due to network issues. In such a situation, you will want other logging operations to at least have a chance to perform their logging activity.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise04</strong>, using the CLI <strong class="source-inline">dotnet</strong> command:<p class="source-code">source\Chapter03&gt;dotnet new console -o Exercise04</p></li>
<li>Open <strong class="source-inline">Chapter03\Exercise04.csproj</strong> and replace the entire file with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise04\Program.cs</strong> and clear the contents.</li>
<li>Now add a static <strong class="source-inline">Program</strong> class for your console app, including <strong class="source-inline">System</strong> and, additionally, <strong class="source-inline">System.IO</strong> as you want to create a file:<p class="source-code">using System;</p><p class="source-code">using System.IO;</p><p class="source-code">namespace Chapter03.Exercise04</p><p class="source-code">{</p><p class="source-code">    public static class Program</p><p class="source-code">    {</p></li>
<li>Use a <strong class="source-inline">const</strong> to name the logging file. This file is created when the program executes:<p class="source-code">        private const string OutputFile = "Exercise04.txt";</p></li>
<li>Now you must define the app's <strong class="source-inline">Main</strong> entry point. Here you delete the output file if it already exists. It is best to start with an empty file here, as otherwise, the log file will keep growing every time you run the app:<p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            if (File.Exists(OutputFile))</p><p class="source-code">            {</p><p class="source-code">                File.Delete(OutputFile);</p><p class="source-code">            }</p></li>
<li>You will start with <strong class="source-inline">logger</strong> having just one target method, <strong class="source-inline">LogToConsole</strong>, which you will add shortly:<p class="source-code">            Action&lt;string&gt; logger = LogToConsole;</p></li>
<li>You use the <strong class="source-inline">InvokeAll</strong> method to invoke the delegate, passing in <strong class="source-inline">"First call"</strong> as an argument. This will not fail as <strong class="source-inline">logger</strong> has a single valid method and you will add <strong class="source-inline">InvokeAll</strong> shortly, too:<p class="source-code">            InvokeAll(logger, "First call"); </p></li>
<li>The aim of this exercise is to have a multicast delegate, so add some additional target methods:<p class="source-code">            logger += LogToConsole;</p><p class="source-code">            logger += LogToDatabase;</p><p class="source-code">            logger += LogToFile; </p></li>
<li>Try a second call using <strong class="source-inline">InvokeAll</strong> as follows:<p class="source-code">            InvokeAll(logger, "Second call"); </p><p class="source-code">            Console.ReadLine();</p></li>
<li>Now for the target methods that were added to the delegate. Add the following code for this:<p class="source-code">            static void LogToConsole(string message)</p><p class="source-code">                =&gt; Console.WriteLine($"LogToConsole: {message}");</p><p class="source-code">            static void LogToDatabase(string message)</p><p class="source-code">                =&gt; throw new ApplicationException("bad thing happened!");</p><p class="source-code">            static void LogToFile(string message)</p><p class="source-code">                =&gt; File.AppendAllText(OutputFile, message);</p><p class="source-code">        </p></li>
<li>You can now implement the <strong class="source-inline">InvokeAll</strong> method: <p class="source-code">            static void InvokeAll(Action&lt;string&gt; logger, string arg)</p><p class="source-code">            {</p><p class="source-code">                if (logger == null)</p><p class="source-code">                     return;</p></li>
</ol>
<p>It is passed an <strong class="source-inline">Action&lt;string&gt;</strong> delegate that matches the <strong class="source-inline">logger</strong> delegate type, along with an <strong class="source-inline">arg</strong> string to use when invoking each target method. Before that though, it is important to check that <strong class="source-inline">logger</strong> is not already null and there is nothing you can do with a null delegate.</p>
<ol>
<li value="13">Use the delegate's <strong class="source-inline">GetInvocationList()</strong> method to get a list of all the target methods:<p class="source-code">                var delegateList = logger.GetInvocationList();</p><p class="source-code">                Console.WriteLine($"Found {delegateList.Length} items in {logger}"); </p></li>
<li>Now, loop through each item in the list as follows:<p class="source-code">                foreach (var del in delegateList)</p><p class="source-code">                {</p></li>
<li>After wrapping each loop element in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong>, cast <strong class="source-inline">del</strong> into an <strong class="source-inline">Action&lt;string&gt;</strong>:<p class="source-code">                   try</p><p class="source-code">                   {</p><p class="source-code">                     var action = del as Action&lt;string&gt;; </p></li>
</ol>
<p><strong class="source-inline">GetInvocationList</strong> returns each item as the base delegate type regardless of their actual type.</p>
<ol>
<li value="16">If it is the correct type and <strong class="bold">not</strong> null, then it is safe to try invoking:<p class="source-code">                      if (del is Action&lt;string&gt; action)</p><p class="source-code">                      {</p><p class="source-code">                          Console.WriteLine($"Invoking '{action.Method.Name}' with '{arg}'");</p><p class="source-code">                          action(arg);</p><p class="source-code">                      }</p><p class="source-code">                      else</p><p class="source-code">                      {</p><p class="source-code">                          Console.WriteLine("Skipped null");</p><p class="source-code">                      } </p></li>
</ol>
<p>You have added some extra details to show what is about to be invoked by using the delegate's <strong class="source-inline">Method.Name</strong> property.</p>
<ol>
<li value="17">Finish with a <strong class="source-inline">catch</strong> block that logs the error message if an error was caught:<p class="source-code">                  }</p><p class="source-code">                  catch (Exception e)</p><p class="source-code">                  {</p><p class="source-code">                      Console.WriteLine($"Error: {e.Message}");</p><p class="source-code">                  }</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the code, creates a file called <strong class="source-inline">Exercise04.txt</strong> with the following results:<p class="source-code">Found 1 items in System.Action`1[System.String]</p><p class="source-code">Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'First call'</p><p class="source-code">LogToConsole: First call</p><p class="source-code">Found 4 items in System.Action`1[System.String]</p><p class="source-code">Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'Second call'</p><p class="source-code">LogToConsole: Second call</p><p class="source-code">Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'Second call'</p><p class="source-code">LogToConsole: Second call</p><p class="source-code">Invoking '&lt;Main&gt;g__LogToDatabase|1_1' with 'Second call'</p><p class="source-code">Error: bad thing happened!</p><p class="source-code">Invoking '&lt;Main&gt;g__LogToFile|1_2' with 'Second call'</p></li>
</ol>
<p>You will see that it catches the error thrown by <strong class="source-inline">LogToDatabase</strong> and still allows <strong class="source-inline">LogToFile</strong> to be called.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Dp5H4">https://packt.link/Dp5H4</a>.</p>
<p>It is now important to expand upon the multicast concept using events.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor152"/>Events</h2>
<p>In the previous sections, you have created delegates and invoked them directly in the same method or passed them to another method for it to invoke when needed. By using delegates in this way, you have a simple way for code to be notified when something of interest happens. So far, this has not been a major problem, but you may have noticed that there appears to be no way to prevent an object that has access to a delegate from invoking it directly.</p>
<p>Consider the following scenario: you have created an application that allows other programs to register for notifications when a new email arrives by adding their target method to a delegate that you have provided. What if a program, either by mistake or for malicious reasons, decides to invoke your delegate itself? This could quite easily overwhelm all the target methods in your invocation list. Such listener programs should never be allowed to invoke a delegate in this way—after all, they are meant to be passive listeners.</p>
<p>You could add extra methods that allow listeners to add or remove their target methods from the invocation list and shield the delegate from direct access, but what if you have hundreds of such delegates available in an application? That is a great deal of code to write.</p>
<p>The <strong class="source-inline">event</strong> keyword instructs the C# complier to add extra code to ensure that a delegate can <strong class="bold">only</strong> be invoked by the class or struct that it is declared in. External code can add or remove target methods but is prevented from invoking the delegate. Attempting to do so results in a compiler error.</p>
<p>This pattern is commonly known as the pub-sub pattern. The object raising an event is called the event sender or <strong class="bold">publisher</strong>; the object(s) receiving the event are called event handlers or <strong class="bold">subscribers</strong>.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor153"/>Defining an Event</h2>
<p>The <strong class="source-inline">event</strong> keyword is used to define an event and its associated delegates. Its definition looks similar to the way delegates are defined, but unlike delegates, you cannot use the global namespace to define events:</p>
<p class="source-code">public event EventHandler MouseDoubleClicked</p>
<p>Events have four elements:</p>
<ul>
<li>Scope: An access modifier, such as <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, or <strong class="source-inline">protected</strong>, to define the scope.</li>
<li>The <strong class="source-inline">event</strong> keyword.</li>
<li>Delegate type: The associated delegate, <strong class="source-inline">EventHandler</strong> in this example.</li>
<li>Event name: This can be anything you like, <strong class="source-inline">MouseDoubleClicked</strong>, for example. However, the name must be unique within the namespace.</li>
</ul>
<p>Events are typically associated with the inbuilt .NET delegates, <strong class="source-inline">EventHandler</strong>, or its generic <strong class="source-inline">EventHandler&lt;&gt;</strong> version. It is rare to create custom delegates for events, but you may find this in older legacy code created prior to the <strong class="source-inline">Action</strong> and generic <strong class="source-inline">Action&lt;T&gt;</strong> delegates.</p>
<p>The <strong class="source-inline">EventHandler</strong> delegate was available in early versions of .NET. It has the following signature, taking a sender <strong class="source-inline">object</strong> and an <strong class="source-inline">EventArgs</strong> parameter: </p>
<p class="source-code">public delegate void EventHandler(object sender, EventArgs e); </p>
<p>The more recent generic-based <strong class="source-inline">EventHandler&lt;T&gt;</strong> delegate looks similar; it also takes a sender <strong class="source-inline">object</strong> and a parameter defined by the type <strong class="source-inline">T</strong>:</p>
<p class="source-code">public delegate void EventHandler&lt;T&gt;(object sender, T e); </p>
<p>The <strong class="source-inline">sender</strong> parameter is defined as <strong class="source-inline">object</strong>, allowing any type of object to be sent to subscribers for them to identify the sender of the event. This can be useful in a situation where you have a centralized method that needs to work on various types of objects rather than specific instances.</p>
<p>For example, in a UI app, you may have one subscriber that listens for an OK button being clicked, and a second subscriber that listens for a <strong class="bold">Cancel</strong> button being clicked–each of these could be handled by two separate methods. In the case of multiple checkboxes used to toggle options on or off, you could use a single target method that simply needs to be told that a checkbox is the sender, and to toggle the setting accordingly. This allows you to reuse the same checkbox handler rather than creating a method for every checkbox on a screen.</p>
<p>It is not mandatory to include details of the sender when invoking an <strong class="source-inline">EventHandler</strong> delegate. Often, you may not want to divulge the inner workings of your code to the outside; in this case, it is common practice to pass a null reference to the delegate.</p>
<p>The second argument in both delegates can be used to provide extra contextual information about the event (for example, was it the left or right mouse button that was pressed?). Traditionally, this extra information was wrapped up using a class derived from <strong class="source-inline">EventArgs</strong>, but that convention has been relaxed in newer .NET versions.</p>
<p>There are two standard .NET delegates you should for your event definition?</p>
<ul>
<li><strong class="source-inline">EventHandler</strong>: This can be used when there is no extra information to describe the event. For example, a checkbox click event may not need any extra information, it was simply clicked. In this case, it is perfectly valid to pass null or <strong class="source-inline">EventArgs.Empty</strong> as the second parameter. This delegate can often be found in legacy apps that use a class derived from <strong class="source-inline">EventArgs</strong> to describe the event further. Was it a double-click of the mouse that triggered this event? In this case, a <strong class="source-inline">Clicks</strong> property may have been added to an <strong class="source-inline">EventArgs</strong> derived class to provide such extra details.</li>
<li><strong class="source-inline">EventHandler&lt;T&gt;</strong>: Since the inclusion of generics in C#, this has become the more frequently used delegate for events, simply because using generics requires fewer classes to be created.</li>
</ul>
<p>Interestingly, no matter what scope you give to your event (<strong class="source-inline">public</strong>, for example), the C# compiler will internally create a private member with that name. This is the key concept with events: only the class that defines the event may <strong class="bold">invoke it</strong>. Consumers are free to add or remove their interest, but they <strong class="bold">cannot</strong> invoke it themselves.</p>
<p>When an event is defined, the publisher class in which it is defined can simply invoke it as and when needed, in the same way that you invoke delegates. In the earlier examples, a point was made of always checking that the delegate is not null before invoking. The same approach should be taken with events, as you have little control over how or when a subscriber may add or remove their target methods.</p>
<p>When a publisher class is initially created, all events have an initial value of null. This will change to not null when any subscriber adds a target method. Conversely, as soon as a subscriber removes a target method, the event will revert to null if there are no methods left in the invocation list and all this is handled by the runtime. This is the standard behavior you saw earlier with delegates.</p>
<p>You can prevent an event from ever becoming null by adding an empty delegate to the end of the event definition:</p>
<p class="source-code">public event EventHandler&lt;MouseEventArgs&gt; MouseDoubleClicked = delegate {};</p>
<p>Rather than having the default null value, you are adding your own default delegate instance—one that does nothing. Hence the blank between the <strong class="source-inline">{}</strong> symbols.</p>
<p>There is a common pattern often followed when using events within a publisher class, particularly in classes that may be subclassed further. You will now see this with the help of a simple example:</p>
<ol>
<li value="1">Define a class, <strong class="source-inline">MouseClickedEventArgs</strong>, that contains additional information about the event, in this case, the number of mouse clicks that were detected:<p class="source-code">using System;</p><p class="source-code">namespace Chapter03Examples</p><p class="source-code">{</p><p class="source-code">    public class MouseClickedEventArgs </p><p class="source-code">    {</p><p class="source-code">        public MouseClickedEventArgs(int clicks)</p><p class="source-code">        {</p><p class="source-code">            Clicks = clicks;</p><p class="source-code">        }</p><p class="source-code">        public int Clicks { get; }</p><p class="source-code">    }</p></li>
</ol>
<p>Observe the <strong class="source-inline">MouseClickPublisher</strong> class, This has a <strong class="source-inline">MouseClicked</strong> event defined using the generic <strong class="source-inline">EventHandler&lt;&gt;</strong> delegate.</p>
<ol>
<li value="2">Now add the <strong class="source-inline">delegate { };</strong> block to prevent <strong class="source-inline">MouseClicked</strong> from being null initially:<p class="source-code">    public class MouseClickPublisher</p><p class="source-code">    {</p><p class="source-code">     public event EventHandler&lt;MouseClickedEventArgs&gt; MouseClicked = delegate { };</p></li>
<li>Add an <strong class="source-inline">OnMouseClicked</strong> virtual method that gives any further subclassed <strong class="source-inline">MouseClickPublisher</strong> classes a chance to suppress or change the event notification, as follows:<p class="source-code">        protected virtual void OnMouseClicked( MouseClickedEventArgs e)</p><p class="source-code">        {</p><p class="source-code">            var evt = MouseClicked;</p><p class="source-code">            evt?.Invoke(this, e);</p><p class="source-code">        }</p></li>
<li>Now you need a method that tracks the mouse clicks. In this example, you will not actually show how mouse clicks are detected, but you will call <strong class="source-inline">OnMouseClicked</strong>, passing in <strong class="source-inline">2</strong> to indicate a double-click.</li>
<li>Notice how you have not invoked the <strong class="source-inline">MouseClicked</strong> event directly; you always go via the <strong class="source-inline">OnMouseClicked</strong> intermediary method. This provides a way for other implementations of <strong class="source-inline">MouseClickPublisher</strong> to override the event notification if they need to:<p class="source-code">        private void TrackMouseClicks()</p><p class="source-code">        {</p><p class="source-code">            OnMouseClicked(new MouseClickedEventArgs(2));</p><p class="source-code">        }</p><p class="source-code">    } </p></li>
<li>Now add a new type of publisher that is based on <strong class="source-inline">MouseClickPublisher</strong>: <p class="source-code">    public class MouseSingleClickPublisher : MouseClickPublisher</p><p class="source-code">    {</p><p class="source-code">        protected override void OnMouseClicked(MouseClickedEventArgs e)</p><p class="source-code">        {</p><p class="source-code">            if (e.Clicks == 1)</p><p class="source-code">            {</p><p class="source-code">                OnMouseClicked(e);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">} </p></li>
</ol>
<p>This <strong class="source-inline">MouseSingleClickPublisher</strong> overrides the <strong class="source-inline">OnMouseClicked</strong> method and only calls the base <strong class="source-inline">OnMouseClicked</strong> if a single click was detected. By implementing this type of pattern, you allow different types of publishers to control whether events are fired to subscribers in a customized manner.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/J1EiB">https://packt.link/J1EiB</a>.</p>
<p>You can now practice what you learned through the following exercise.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor154"/>Exercise 3.05: Publishing and Subscribing to Events</h2>
<p>In this exercise, you will create an alarm clock as an example of a publisher. The alarm clock will simulate a <strong class="bold">tick</strong> every minute and publish a <strong class="source-inline">Ticked</strong> event. You will also add a <strong class="source-inline">WakeUp</strong> event that is published when the current time matches an alarm time. In .NET, <strong class="source-inline">DateTime</strong> is used to represent a point in time, so you will use that for the current time and alarm time properties. You will use <strong class="source-inline">DateTime.Subtract</strong> to get the difference between the current time and the alarm time and publish the <strong class="source-inline">WakeUp</strong> event when it is due.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise05</strong>, using the CLI <strong class="source-inline">dotnet</strong> command:<p class="source-code">dotnet new console -o Exercise05</p></li>
<li>Open <strong class="source-inline">Chapter03\Exercise05.csproj</strong> and replace the entire file with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise05\Program.cs</strong> and clear the contents.</li>
<li>Add a new class called <strong class="source-inline">AlarmClock</strong>. Here you need to use a <strong class="source-inline">DateTime</strong> class, so include the <strong class="source-inline">System</strong> namespace:<p class="source-code">using System;</p><p class="source-code">namespace Chapter03.Exercise05</p><p class="source-code">{</p><p class="source-code">    public class AlarmClock</p><p class="source-code">    {</p></li>
</ol>
<p>You will offer two events for subscribers to listen to—<strong class="source-inline">WakeUp</strong>, based on the non-generic <strong class="source-inline">EventHandler</strong> delegate (since you will not pass any extra information in this event), and <strong class="source-inline">Ticked</strong>, which uses the generic <strong class="source-inline">EventHandler</strong> delegate with a <strong class="source-inline">DateTime</strong> parameter type. </p>
<ol>
<li value="5">You will use this to pass along the current time to display in the console. Notice that both have the initial <strong class="source-inline">delegate {};</strong> safety mechanism:<p class="source-code">        public event EventHandler WakeUp = delegate {};</p><p class="source-code">        public event EventHandler&lt;DateTime&gt; Ticked = delegate {};</p></li>
<li>Include an <strong class="source-inline">OnWakeUp</strong> override as an example, but do not do the same with <strong class="source-inline">Ticked</strong>; this is to show the different invocation approaches:<p class="source-code">        protected void OnWakeUp()</p><p class="source-code">        {</p><p class="source-code">            WakeUp.Invoke(this, EventArgs.Empty);</p><p class="source-code">        }</p></li>
<li>Now add two <strong class="source-inline">DateTime</strong> properties, the alarm and clock times, as follows:<p class="source-code">        public DateTime AlarmTime { get; set; }</p><p class="source-code">        public DateTime ClockTime { get; set; }</p></li>
<li>A <strong class="source-inline">Start</strong> method is used to start the clock. You simulate a clock ticking once every minute for <strong class="source-inline">24 hours</strong> using a simple loop as follows:<p class="source-code">        public void Start()</p><p class="source-code">        {</p><p class="source-code">            // Run for 24 hours</p><p class="source-code">            const int MinutesInADay = 60 * 24;</p></li>
<li>For each simulated minute, increment the clock using <strong class="source-inline">DateTime.AddMinute</strong> and publish the <strong class="source-inline">Ticked</strong> event, passing in <strong class="source-inline">this</strong> (the <strong class="source-inline">AlarmClock</strong> sender instance) and the clock time:<p class="source-code">            for (var i = 0; i &lt; MinutesInADay; i++)</p><p class="source-code">            {</p><p class="source-code">                ClockTime = ClockTime.AddMinutes(1);</p><p class="source-code">                Ticked.Invoke(this, ClockTime);</p></li>
</ol>
<p><strong class="source-inline">ClockTime.Subtract</strong> is used to calculate the difference between the click and alarm times. </p>
<ol>
<li value="10">You pass the <strong class="source-inline">timeRemaining</strong> value to the local function, <strong class="source-inline">IsTimeToWakeUp</strong>, calling the <strong class="source-inline">OnWakeUp</strong> method and break out of the loop if it is time to wake up:<p class="source-code">              var timeRemaining = ClockTime                 .Subtract(AlarmTime)                .TotalMinutes;</p><p class="source-code">               if (IsTimeToWakeUp(timeRemaining))</p><p class="source-code">                {</p><p class="source-code">                    OnWakeUp();</p><p class="source-code">                    break;</p><p class="source-code">                }</p><p class="source-code">            }</p></li>
<li>Use the <strong class="source-inline">IsTimeToWakeUp</strong>, a relational pattern, to see whether there is less than one minute remaining. Add the following code for this:<p class="source-code">            static bool IsTimeToWakeUp(double timeRemaining) </p><p class="source-code">                =&gt; timeRemaining is (&gt;= -1.0 and &lt;= 1.0);</p><p class="source-code">        }</p><p class="source-code">    }   </p></li>
<li>Now add a console app that subscribes to the alarm clock and its two events by starting from the static void <strong class="source-inline">Main</strong> entry point:<p class="source-code">         public static class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Create the <strong class="source-inline">AlarmClock</strong> instance and use the <strong class="source-inline">+=</strong> operator to subscribe to the <strong class="source-inline">Ticked</strong> event and the <strong class="source-inline">WakeUp</strong> events. You will define <strong class="source-inline">ClockTicked</strong> and <strong class="source-inline">ClockWakeUp</strong> shortly. For now, just add the following code:<p class="source-code">            var clock = new AlarmClock();</p><p class="source-code">            clock.Ticked += ClockTicked;</p><p class="source-code">            clock.WakeUp += ClockWakeUp; </p></li>
<li>Set the clock's current time, use <strong class="source-inline">DateTime.AddMinutes</strong> to add <strong class="source-inline">120</strong> minutes to the alarm time, and then start the clock, as follows:<p class="source-code">            clock.ClockTime = DateTime.Now;</p><p class="source-code">            clock.AlarmTime = DateTime.Now.AddMinutes(120);</p><p class="source-code">            Console.WriteLine($"ClockTime={clock.ClockTime:t}");</p><p class="source-code">            Console.WriteLine($"AlarmTime={clock.AlarmTime:t}");</p><p class="source-code">            clock.Start(); </p></li>
<li>Finish off <strong class="source-inline">Main</strong> by prompting for the <strong class="source-inline">Enter</strong> key to be pressed:<p class="source-code">            Console.WriteLine("Press ENTER");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        </p></li>
<li>Now you can add the event subscriber local methods:<p class="source-code">            static void ClockWakeUp(object sender, EventArgs e)</p><p class="source-code">            {</p><p class="source-code">               Console.WriteLine();</p><p class="source-code">               Console.WriteLine("Wake up");</p><p class="source-code">            }</p></li>
</ol>
<p><strong class="source-inline">ClockWakeUp</strong> is passed sender and <strong class="source-inline">EventArgs</strong> arguments. You don't use either of these, but they are required for the <strong class="source-inline">EventHandler</strong> delegate. When this subscriber's method is called, you write <strong class="source-inline">"Wake up"</strong> to the console.</p>
<ol>
<li value="17"><strong class="source-inline">ClockTicked</strong> is passed the <strong class="source-inline">DateTime</strong> argument as required by the <strong class="source-inline">EventHandler&lt;DateTime&gt;</strong> delegate. Here, you pass the current time, so you write that to the console using <strong class="source-inline">:t</strong> to show the time in a short format:<p class="source-code">             static void ClockTicked(object sender, DateTime e)</p><p class="source-code">                =&gt; Console.Write($"{e:t}...");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">} </p></li>
<li>Running the app produces this output:<p class="source-code">ClockTime=14:59</p><p class="source-code">AlarmTime=16:59</p><p class="source-code">15:00...15:01...15:02...15:03...15:04...15:05...15:06...15:07...15:08...15:09...15:10...15:11...15:12...15:13...15:14...15:15...15:16...15:17...15:18...15:19...15:20...15:21...15:22...15:23...15:24...15:25...15:26...15:27...15:28...15:29...15:30...15:31...15:32...15:33...15:34...15:35...15:36...15:37...15:38...15:39...15:40...15:41...15:42...15:43...15:44...15:45...15:46...15:47...15:48...15:49...15:50...15:51...15:52...15:53...15:54...15:55...15:56...15:57...15:58...15:59...16:00...16:01...16:02...16:03...16:04...16:05...16:06...16:07...16:08...16:09...16:10...16:11...16:12...16:13...16:14...16:15...16:16...16:17...16:18...16:19...16:20...16:21...16:22...16:23...16:24...16:25...16:26...16:27...16:28...16:29...16:30...16:31...16:32...16:33...16:34...16:35...16:36...16:37...16:38...16:39...16:40...16:41...16:42...16:43...16:44...16:45...16:46...16:47...16:48...16:49...16:50...16:51...16:52...16:53...16:54...16:55...16:56...16:57...16:58...16:59...</p><p class="source-code">Wake up</p><p class="source-code">Press ENTER</p></li>
</ol>
<p>In this example you see that the alarm clock simulates a tick every minute and publishes a <strong class="source-inline">Ticked</strong> event.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/GPkYQ">https://packt.link/GPkYQ</a>.</p>
<p>Now it is time to grasp the difference between events and delegates.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor155"/>Events or Delegates?</h1>
<p>On the face of it, events and delegates look remarkably similar:</p>
<ul>
<li>Events are an extended form of delegates.</li>
<li>Both offer <strong class="bold">late-bound</strong> semantics, so rather than calling methods that are known precisely at compile-time, you can defer a list of target methods when known at runtime.</li>
<li>Both are <strong class="bold">called</strong> using <strong class="source-inline">Invoke()</strong> or, more simply, the <strong class="source-inline">()</strong> suffix shortcut, ideally with a null check before doing so.</li>
</ul>
<p>The key considerations are as follows:</p>
<ul>
<li>Optionality: Events offer an optional approach; callers can decide to opt into events or not. If your component can complete its task without needing any subscriber methods, then it is preferable to use an event-based approach.</li>
<li>Return types: Do you need to handle return types? Delegates associated with events are always void.</li>
<li>Lifetime: Event subscribers typically have a shorter lifetime than their publishers, leaving the publisher to continue detecting new messages even if there are no active subscribers.</li>
</ul>
<h2 id="_idParaDest-145"><a id="_idTextAnchor156"/>Static Events Can Cause Memory Leaks</h2>
<p>Before you wrap up your look at events, it pays to be <strong class="bold">careful</strong> when using events, particularly those that are statically defined.</p>
<p>Whenever you add a subscriber's target method to a publisher's event, the publisher class will store a reference to your target method. When you have finished using a subscriber instance and it remains attached to a <strong class="source-inline">static</strong> publisher, it is possible that the memory used by your subscriber will not be cleared up.</p>
<p>These are often referred to as orphaned, phantom, or ghost events. To prevent this, always try to pair up each <strong class="source-inline">+=</strong> call with a corresponding <strong class="source-inline">-=</strong> operator.</p>
<p class="callout-heading">Note</p>
<p class="callout">Reactive Extensions (Rx) (<a href="https://github.com/dotnet/reactive">https://github.com/dotnet/reactive</a>) is a great library for leveraging and taming event-based and asynchronous programming using LINQ-style operators. Rx provides a way to time-shift, for example, buffering a very chatty event into manageable streams with just a few lines of code. What's more, Rx streams are very easy to unit test, allowing you to effectively take control of time.</p>
<p>Now read about the interesting topic of lambda expressions.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor157"/>Lambda Expressions</h1>
<p>Throughout the previous sections, you have mainly used class-level methods as targets for your delegates and events, such as the <strong class="source-inline">ClockTicked</strong> and <strong class="source-inline">ClockWakeUp</strong> methods, that were also used in <em class="italic">Exercise 3.05</em>:</p>
<p class="source-code"><a id="_idTextAnchor158"/>var clock = new AlarmClock();</p>
<p class="source-code">clock.Ticked += ClockTicked;</p>
<p class="source-code">clock.WakeUp += ClockWakeUp;</p>
<p class="source-code">static void ClockTicked(object sender, DateTime e)</p>
<p class="source-code">  =&gt; <a id="_idTextAnchor159"/>Console.Write($"{e:t}...");</p>
<p class="source-code">    </p>
<p class="source-code">static void ClockWakeUp(object sender, EventArgs e)</p>
<p class="source-code">{</p>
<p class="source-code">    <a id="_idTextAnchor160"/>Console.WriteLine();</p>
<p class="source-code">    Console.WriteLine("Wake up");</p>
<p class="source-code">}</p>
<p>The <strong class="source-inline">ClockWakeUp</strong> and <strong class="source-inline">ClockTicked</strong> methods are easy to follow and step through. However, by converting them into lambda expression syntax, you can have a more succinct syntax and closer proximity to where they are in code.</p>
<p>Now convert the <strong class="source-inline">Ticked</strong> and <strong class="source-inline">WakeUp</strong> events to use two different lambda expressions:</p>
<p class="source-code">clock.Ticked += (sender, e) =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">    Console.Write($"{e:t}..."); </p>
<p class="source-code">};  </p>
<p class="source-code">clock.WakeUp += (sender, e) =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">    Console.WriteLine();</p>
<p class="source-code">    Console.WriteLine("Wake up");</p>
<p class="source-code">}; </p>
<p>You have used the same <strong class="source-inline">+=</strong> operator, but instead of method names, you see <strong class="source-inline">(sender, e) =&gt;</strong> and identical blocks of code, as seen in <strong class="source-inline">ClockTicked</strong> and <strong class="source-inline">ClockWakeUp</strong>.</p>
<p>When defining a lambda expression, you can pass any parameters within parentheses, <strong class="source-inline">()</strong>, followed by <strong class="source-inline">=&gt;</strong> (this is often read as <strong class="bold">goes to</strong>), and then by your expression/statement block:</p>
<p class="source-code">(parameters) =&gt; expression-or-block</p>
<p>The code block can be as complex as you need and can return a value if it is a <strong class="source-inline">Func</strong>-based delegate.</p>
<p>The compiler can normally infer each of the parameter types, so you do not even need to specify their types. Moreover, you can omit the parentheses if there is only one argument and the compiler can infer its type.</p>
<p>Wherever a delegate (remember that <strong class="source-inline">Action</strong>, <strong class="source-inline">Action&lt;T&gt;</strong>, and <strong class="source-inline">Func&lt;T&gt;</strong> are inbuilt examples of a delegate) needs to be used as an argument, rather than creating a class or local method or function, you should consider using a lambda expression. The main reason is that this often results in less code, and that code is placed closer to the location where it is used.</p>
<p>Now consider another example on Lambda. Given a list of movies, you can use the <strong class="source-inline">List&lt;string&gt;</strong> class to store these string-based names, as shown in the following snippet:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">namespace Chapter03Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class LambdaExample</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            var names = new List&lt;string&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                "The A-Team",</p>
<p class="source-code">                "Blade Runner",</p>
<p class="source-code">                "There's Something About Mary",</p>
<p class="source-code">                "Batman Begins",</p>
<p class="source-code">                "The Crow"</p>
<p class="source-code">            };</p>
<p>You can use the <strong class="source-inline">List.Sort</strong> method to sort the names alphabetically (the final output will be shown at the end of this example):</p>
<p class="source-code">            names.Sort();</p>
<p class="source-code">            Console.WriteLine("Sorted names:");</p>
<p class="source-code">            foreach (var name in names)</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine(name);</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.WriteLine();</p>
<p>If you need more control over how this sort works, the <strong class="source-inline">List</strong> class has another <strong class="source-inline">Sort</strong> method that accepts a delegate of this form: <strong class="source-inline">delegate int Comparison&lt;T&gt;(T x, T y)</strong>. This delegate is passed two arguments of the same type (<strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>) and returns an <strong class="source-inline">int</strong> value. The <strong class="source-inline">int</strong> value can be used to define the sort order of items in the list without you having to worry about the internal workings of the <strong class="source-inline">Sort</strong> method.</p>
<p>As an alternative, you can sort the names to exclude <strong class="source-inline">"The"</strong> from the beginning of movie titles. This is often used as an alternative way to list names. You can achieve this by passing a lambda expression, using the <strong class="source-inline">( )</strong> syntax to wrap two strings, <strong class="source-inline">x, y</strong>, that will be passed by <strong class="source-inline">Sort()</strong> when it invokes your lambda.</p>
<p>If <strong class="source-inline">x</strong> or <strong class="source-inline">y</strong> starts with your noise word, <strong class="source-inline">"The"</strong>, then you use the <strong class="source-inline">string.Substring</strong> function to skip the first four characters. <strong class="source-inline">String.Compare</strong> is then used to return a numeric value that compares the resulting string values, as follows:</p>
<p class="source-code">            const string Noise = "The ";</p>
<p class="source-code">            names.Sort( (x, y) =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                if (x.StartsWith(Noise))</p>
<p class="source-code">                {</p>
<p class="source-code">                    x = x.Substring(Noise.Length);</p>
<p class="source-code">                }</p>
<p class="source-code">                if (y.StartsWith(Noise))</p>
<p class="source-code">                {</p>
<p class="source-code">                    y = x.Substring(Noise.Length);</p>
<p class="source-code">                }</p>
<p class="source-code">                return string.Compare(x , y);</p>
<p class="source-code">            });</p>
<p>You can then write out the sorted results to the console:</p>
<p class="source-code">            Console.WriteLine($"Sorted excluding leading '{Noise}':");</p>
<p class="source-code">            foreach (var name in names)</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine(name);</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">         }</p>
<p class="source-code">     }</p>
<p class="source-code">} </p>
<p>Running the example code produces the following output:</p>
<p class="source-code">Sorted names:</p>
<p class="source-code">Batman Begins</p>
<p class="source-code">Blade Runner</p>
<p class="source-code">The A-Team</p>
<p class="source-code">The Crow</p>
<p class="source-code">There's Something About Mary</p>
<p class="source-code">Sorted excluding leading 'The ':</p>
<p class="source-code">The A-Team</p>
<p class="source-code">Batman Begins</p>
<p class="source-code">Blade Runner</p>
<p class="source-code">The Crow</p>
<p class="source-code">There's Something About Mary </p>
<p>You can see that the second set of names is sorted with <strong class="source-inline">"The"</strong> is ignored.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="http://packt.link/B3NmQ">http://packt.link/B3NmQ</a>.</p>
<p>To see these lambda statements put into practice, try your hand at the following exercise.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor161"/>Exercise 3.06: Using a Statement Lambda to Reverse Words in a Sentence</h2>
<p>In this exercise, you are going to create a utility class that splits the words in a sentence and returns that sentence with the words in reverse order.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <strong class="source-inline">Chapter03</strong> folder and create a new console app, called <strong class="source-inline">Exercise06</strong>, using the CLI <strong class="source-inline">dotnet</strong> command:<p class="source-code">source\Chapter03&gt;dotnet new console -o Exercise06</p></li>
<li><a id="_idTextAnchor162"/>Open <strong class="source-inline">Chapter03\Exercise06.csproj</strong> and replace the entire file with these settings:<p class="source-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;</p><p class="source-code">  &lt;PropertyGroup&gt;</p><p class="source-code">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</p><p class="source-code">    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</p><p class="source-code">  &lt;/PropertyGroup&gt;</p><p class="source-code">&lt;/Project&gt;</p></li>
<li>Open <strong class="source-inline">Exercise02\Program.cs</strong> and clear the contents.</li>
<li>Add a new class named <strong class="source-inline">WordUtilities</strong> with a string function called <strong class="source-inline">ReverseWords</strong>. You need to include the <strong class="source-inline">System.Linq</strong> namespace to help with the string operations:<p class="source-code">using System;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter03.Exercise06</p><p class="source-code">{</p><p class="source-code">    public static class WordUtilities</p><p class="source-code">    {</p><p class="source-code">        public static string ReverseWords(string sentence)</p><p class="source-code">        {</p></li>
<li>Define a <strong class="source-inline">Func&lt;string, string&gt;</strong> delegate called <strong class="source-inline">swapWords</strong> that takes a string input and returns a string value:<p class="source-code">          Func&lt;string, string&gt; swapWords = </p></li>
<li>You will accept a string input argument named <strong class="source-inline">phrase</strong>:<p class="source-code">            phrase =&gt;</p></li>
<li>Now for the lambda statement body. Use the <strong class="source-inline">string.Split</strong> function to split the <strong class="source-inline">phrase</strong> string into an array of strings using a space as the splitting character:<p class="source-code">                  {</p><p class="source-code">                    const char Delimit = ' ';</p><p class="source-code">                    var words = phrase</p><p class="source-code">                        .Split(Delimit)</p><p class="source-code">                        .Reverse();</p><p class="source-code">                    return string.Join(Delimit, words);</p><p class="source-code">                };</p></li>
</ol>
<p><strong class="source-inline">String.Reverse</strong> reverses the order of strings in the array, before finally joining the reversed words string array in a single string using <strong class="source-inline">string.Join</strong>.</p>
<ol>
<li value="8">You have defined the required <strong class="source-inline">Func</strong>, so invoke it by passing the sentence parameter and returning that as the result:<p class="source-code">            return swapWords(sentence);</p><p class="source-code">         }</p><p class="source-code">    }</p></li>
<li>Now for a console app that prompts for a sentence to be entered, which is passed to <strong class="source-inline">WordUtilities.ReverseWords</strong>, with the result being written to the console:<p class="source-code">    public static class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            do</p><p class="source-code">            {</p><p class="source-code">                Console.Write("Enter a sentence:");</p><p class="source-code">                var input = Console.ReadLine();</p><p class="source-code">                if (string.IsNullOrEmpty(input))</p><p class="source-code">                {</p><p class="source-code">                    break;</p><p class="source-code">                }</p><p class="source-code">                var result = WordUtilities.ReverseWords(input);</p><p class="source-code">                Console.WriteLine($"Reversed: {result}")</p></li>
</ol>
<p>Running the console app produces results output similar to this:</p>
<p class="source-code">Enter a sentence:welcome to c#</p>
<p class="source-code">Reversed: c# to welcome</p>
<p class="source-code">Enter a sentence:visual studio by microsoft</p>
<p class="source-code">Reversed: microsoft by studio visual</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/z12sR">https://packt.link/z12sR</a>.</p>
<p>You will conclude this look at lambdas with some of the less obvious issues that you might not expect to see when running and debugging.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor163"/>Captures and Closures</h2>
<p>Lambda expressions can <strong class="bold">capture</strong> any of the variables or parameters within the method where they are defined. The word capture is used to describe the way that a lambda expression captures or reaches up into the parent method to access any variables or parameters.</p>
<p>To grasp this better, consider the following example. Here you will create a <strong class="source-inline">Func&lt;int, string&gt;</strong> called <strong class="source-inline">joiner</strong> that joins words together using the <strong class="source-inline">Enumerable.Repeat</strong> method. The <strong class="source-inline">word</strong> variable (known as an <strong class="source-inline">Outer Variables</strong>) is captured inside the body of the <strong class="source-inline">joiner</strong> expression:</p>
<p class="source-code">var word = "hello";</p>
<p class="source-code">Func&lt;int, string&gt; joiner = </p>
<p class="source-code">    input =&gt;</p>
<p class="source-code">    {</p>
<p class="source-code">        return string.Join(",", Enumerable.Repeat(word, input));</p>
<p class="source-code">    };  </p>
<p class="source-code">Console.WriteLine($"Outer Variables: {joiner(2)}"); </p>
<p>Running the preceding example produces the following output:</p>
<p class="source-code">Outer Variables: hello,hello</p>
<p>You invoked the <strong class="source-inline">joiner</strong> delegate by passing <strong class="source-inline">2</strong> as an argument. At that moment in time, the outer <strong class="source-inline">word</strong> variable has a value of <strong class="source-inline">"hello"</strong>, which is repeated twice.</p>
<p>This confirms that captured variables, from the parent method, were evaluated <strong class="bold">only</strong> when <strong class="source-inline">Func</strong> was invoked. Now change the value of <strong class="source-inline">word</strong> from <strong class="source-inline">hello</strong> to <strong class="source-inline">goodbye</strong> and invoke <strong class="source-inline">joiner</strong> once again, passing <strong class="source-inline">3</strong> as the argument:</p>
<p class="source-code">word = "goodbye";</p>
<p class="source-code">Console.WriteLine($"Outer Variables Part2: {joiner(3)}");</p>
<p>Running this example produces the following output:</p>
<p class="source-code">Outer Variables Part2: goodbye,goodbye,goodbye</p>
<p>It is worth remembering that it does not matter where in the code you defined <strong class="source-inline">joiner</strong>. You could have changed the value of <strong class="source-inline">word</strong> to any number of strings before or after declaring <strong class="source-inline">joiner</strong>.</p>
<p>Taking captures one step further, if you define a variable with the same name inside a lambda, it will be scoped <strong class="bold">locally</strong> to the expression. This time, you have a locally defined variable, <strong class="source-inline">word</strong>, which will have no effect on the outer variable with the same name:</p>
<p class="source-code">Func&lt;int, string&gt; joinerLocal =</p>
<p class="source-code">    input =&gt;</p>
<p class="source-code">    {</p>
<p class="source-code">        var word = "local";</p>
<p class="source-code">        return string.Join(",", Enumerable.Repeat(word, input));</p>
<p class="source-code">    };</p>
<p class="source-code">Console.WriteLine($"JoinerLocal: {joinerLocal(2)}");</p>
<p class="source-code">Console.WriteLine($"JoinerLocal: word={word}");   </p>
<p>The preceding example results in the following output. Notice how the outer variable, <strong class="source-inline">word</strong>, remains unchanged from <strong class="source-inline">goodbye</strong>:</p>
<p class="source-code">JoinerLocal: local,local</p>
<p class="source-code">JoinerLocal: word=goodbye</p>
<p>Finally, you will look at the concept of closures that is a subtle part of the C# language and often leads to unexpected results.</p>
<p>In the following example, you have a variable, <strong class="source-inline">actions</strong>, that contains a <strong class="source-inline">List</strong> of <strong class="source-inline">Action</strong> delegates. You use a basic <strong class="source-inline">for</strong> loop to add five separate <strong class="source-inline">Action</strong> instances to the list. The lambda expression for each <strong class="source-inline">Action</strong> simply writes that value of <strong class="source-inline">i</strong> from the <strong class="source-inline">for</strong> loop to the console. Finally, the code simply runs through each <strong class="source-inline">Action</strong> in the <strong class="source-inline">actions</strong> list and invokes each one:</p>
<p class="source-code">var actions = new List&lt;Action&gt;();</p>
<p class="source-code">for (var i = 0; i &lt; 5; i++)</p>
<p class="source-code">{</p>
<p class="source-code">    actions.Add( () =&gt; Console.WriteLine($"MyAction: i={i}")) ;</p>
<p class="source-code">}</p>
<p class="source-code">foreach (var action in actions)</p>
<p class="source-code">{</p>
<p class="source-code">    action();</p>
<p class="source-code">}</p>
<p>Running the example produces the following output:</p>
<p class="source-code">MyAction: i=5</p>
<p class="source-code">MyAction: i=5</p>
<p class="source-code">MyAction: i=5</p>
<p class="source-code">MyAction: i=5</p>
<p class="source-code">MyAction: i=5</p>
<p>The reason why <strong class="source-inline">MyAction: i</strong> did not start from <strong class="source-inline">0</strong> is that the value of <strong class="source-inline">i</strong>, when accessed from inside a <strong class="source-inline">Action</strong> delegate, is only evaluated once the <strong class="source-inline">Action</strong> is invoked. By the time each delegate is invoked, the outer loop has already repeated five times over.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/vfOPx">https://packt.link/vfOPx</a>.</p>
<p>This is similar to the capture concept you observed, where the outer variables, <strong class="source-inline">i</strong> in this case, are only evaluated when invoked. You used <strong class="source-inline">i</strong> in the <strong class="source-inline">for</strong> loop to add each <strong class="source-inline">Action</strong> to the list, but by the time you invoked each action, <strong class="source-inline">i</strong> had its final value of <strong class="source-inline">5</strong>.</p>
<p>This can often lead to unexpected behavior, especially if you assume that an <strong class="bold">incrementing</strong> value for <strong class="source-inline">i</strong> is being used inside each action's loop variable. To ensure that the incrementing value of <strong class="source-inline">i</strong> is used inside each lambda expression, you need to introduce a <strong class="bold">new</strong> local variable inside the <strong class="source-inline">for</strong> loop, one that takes a copy of the iterator variable.</p>
<p>In the following code snippet, you have added the <strong class="source-inline">closurei</strong> variable. It looks very subtle, but you now have a more locally scoped variable, which you access from inside the lambda expression, rather than the iterator, <strong class="source-inline">i</strong>:</p>
<p class="source-code">var actionsSafe = new List&lt;Action&gt;();</p>
<p class="source-code">for (var i = 0; i &lt; 5; i++)</p>
<p class="source-code">{</p>
<p class="source-code">    var closurei = i;</p>
<p class="source-code">    actionsSafe.Add(() =&gt; Console.WriteLine($"MyAction: closurei={closurei}"));</p>
<p class="source-code">}</p>
<p class="source-code">foreach (var action in actionsSafe)</p>
<p class="source-code">{</p>
<p class="source-code">    action();</p>
<p class="source-code">}</p>
<p>Running the example produces the following output. You can see that the incrementing value is used when each <strong class="source-inline">Action</strong> is invoked, rather than the value of <strong class="source-inline">5</strong> that you saw earlier:</p>
<p class="source-code">MyAction: closurei=0</p>
<p class="source-code">MyAction: closurei=1</p>
<p class="source-code">MyAction: closurei=2</p>
<p class="source-code">MyAction: closurei=3</p>
<p class="source-code">MyAction: closurei=4</p>
<p>You have covered the key aspects of delegates and events in event-driven applications. You extended this by using the succinct coding style offered by lambdas, to be notified when events of interest occur.</p>
<p>You will now bring these ideas together into an activity in which you will use some of the inbuilt .NET classes with their own events. You will need to adapt these events to your own format and publish so they can be subscribed to by a console app.</p>
<p>Now it is time to practice all you have learned through the following activity.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor164"/>Activity 3.01: Creating a Web File Downloader</h2>
<p>You plan to investigate patterns in US storm events. To do this, you need to download storm event datasets from online sources for later analysis. The National Oceanic and Atmospheric Administration is one such source of data and can be accessed from <a href="https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles">https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles</a>.</p>
<p>You are tasked with creating a .NET Core console app that allows a web address to be entered, the contents of which are downloaded to a local disk. To be as user-friendly as possible, the application needs to use events that signal when an invalid address is entered, the progress of a download, and when it completes.</p>
<p>Ideally, you should try to hide the internal implementation that you use to download files, preferring to adapt any events that you use to ones that your caller can subscribe to. This form of adaption is often used to make code more maintainable by hiding internal details from callers.</p>
<p>For this purpose, the <strong class="source-inline">WebClient</strong> class in C# can be used for download requests. As with many parts of .NET, this class returns objects that implement the <strong class="source-inline">IDisposable</strong> interface. This is a standard interface and it indicates that the object you are using should be wrapped in a <strong class="source-inline">using</strong> statement to ensure that any resources or memory are cleaned away for you when you have finished using the object. <strong class="source-inline">using</strong> takes this format:</p>
<p class="source-code">using (IDisposable) { statement_block }</p>
<p>Finally, the <strong class="source-inline">WebClient.DownloadFileAsync</strong> method downloads files in the background. Ideally, you should use a mechanism that allows one part of your code to <strong class="bold">wait</strong> for a signal to be <strong class="bold">set</strong> once the download has been completed. <strong class="source-inline">System.Threading.ManualResetEventSlim</strong> is a class that has <strong class="source-inline">Set</strong> and <strong class="source-inline">Wait</strong> methods that can help with this type of signaling.</p>
<p>For this activity, you will need to perform the following steps:</p>
<ol>
<li value="1">Add a progress changed <strong class="source-inline">EventArgs</strong> class (an example name could be <strong class="source-inline">DownloadProgressChangedEventArgs</strong>) that can be used when publishing progress events. This should have <strong class="source-inline">ProgressPercentage</strong> and <strong class="source-inline">BytesReceived</strong> properties.</li>
<li>The <strong class="source-inline">WebClient</strong> class from <strong class="source-inline">System.Net</strong> should be used to download a requested web file. You should create an adapter class (a suggested name is <strong class="source-inline">WebClientAdapter</strong>) that hides your internal usage of <strong class="source-inline">WebClient</strong> from your callers.</li>
<li>Your adapter class should provide three events—<strong class="source-inline">DownloadCompleted</strong>, <strong class="source-inline">DownloadProgressChanged</strong>, and <strong class="source-inline">InvalidUrlRequested</strong>—that a caller can subscribe to.</li>
<li>The adapter class will need a <strong class="source-inline">DownloadFile</strong> method that calls the <strong class="source-inline">WebClient</strong> class's <strong class="source-inline">DownloadFileAsync</strong> method to start the download request. This requires converting a string-based web address into a Uniform Resource Identifier (URI) class. The <strong class="source-inline">Uri.TryCreate()</strong> method can create an absolute address from the string entered via the console. If the call to <strong class="source-inline">Uri.TryCreate</strong> fails, you should publish the <strong class="source-inline">InvalidUrlRequested</strong> event to indicate this failure.</li>
<li><strong class="source-inline">WebClient</strong> has two events—<strong class="source-inline">DownloadFileCompleted</strong> and <strong class="source-inline">DownloadProgressChanged</strong>. You should subscribe to these two events and republish them using your own similar events.</li>
<li>Create a console app that uses an instance of <strong class="source-inline">WebClientAdapter</strong> (as created in <em class="italic">Step 2</em>) and subscribe to the three events.</li>
<li>By subscribing to the <strong class="source-inline">DownloadCompleted</strong> event, you should indicate success in the console.</li>
<li>By subscribing to <strong class="source-inline">DownloadProgressChanged</strong>, you should report progress messages to the console showing the <strong class="source-inline">ProgressPercentage</strong> and <strong class="source-inline">BytesReceived</strong> values.</li>
<li>By subscribing to the <strong class="source-inline">InvalidUrlRequested</strong> event, you should show a warning on the console using a different console background color.</li>
<li>Use a <strong class="source-inline">do</strong> loop that allows the user to repeatedly enter a web address. This address and a temporary destination file path can be passed to <strong class="source-inline">WebClientAdapter.DownloadFile()</strong> until the user enters a blank address to quit.</li>
<li>Once you run the console app with various download requests, you should see an output similar to the following:<p class="source-code">Enter a URL:</p><p class="source-code">https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz</p><p class="source-code">Downloading https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz...</p><p class="source-code">Downloading...73% complete (7,758 bytes)</p><p class="source-code">Downloading...77% complete (8,192 bytes)</p><p class="source-code">Downloading...100% complete (10,597 bytes)</p><p class="source-code">Downloaded to C:\Temp\StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz</p><p class="source-code">Enter a URL:</p><p class="source-code">https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz</p><p class="source-code">Downloading https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz...</p><p class="source-code">Downloading...29% complete (7,758 bytes)</p><p class="source-code">Downloading...31% complete (8,192 bytes)</p><p class="source-code">Downloading...54% complete (14,238 bytes)</p><p class="source-code">Downloading...62% complete (16,384 bytes)</p><p class="source-code">Downloading...84% complete (22,238 bytes)</p><p class="source-code">Downloading...93% complete (24,576 bytes)</p><p class="source-code">Downloading...100% complete (26,220 bytes)</p><p class="source-code">Downloaded to C:\Temp\StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz</p></li>
</ol>
<p>By completing this activity, you have seen how to subscribe to events from an existing .NET event-based publisher class (<strong class="source-inline">WebClient</strong>), adapting them to your own specification before republishing them in your adapter class (<strong class="source-inline">WebClientAdapter</strong>), which were ultimately subscribed to by a console app.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor165"/>Summary</h1>
<p>In this chapter, you took an in-depth look at delegates. You created custom delegates and saw how they could be replaced with their modern counterparts, the inbuilt <strong class="source-inline">Action</strong> and <strong class="source-inline">Func</strong> delegates. By using null reference checks, you discovered the safe way to invoke delegates and how multiple methods can be chained together to form multicast delegates. You extended delegates further to use them with the <strong class="source-inline">event</strong> keyword to restrict invocation and followed the preferred pattern when defining and invoking events. Finally, you covered the succinct lambda expression style and saw how bugs can be avoided by recognising the use of captures and closures.</p>
<p>In the next chapter, you will look at LINQ and data structures, the fundamental parts of the C# language.</p>
</div>
<div>
<div class="Content" id="_idContainer112">
</div>
</div>
</div>
</body></html>