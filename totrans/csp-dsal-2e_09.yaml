- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See in Action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, algorithms are almost everywhere, and there are many types
    and classifications. They are supported by numerous data structures and some of
    them you learned while reading the previous chapters. After some theoretical parts,
    it is high time to keep on practicing, based on interesting examples. They are
    chosen from various types of algorithms, summarizing many subjects that you have
    got to know.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will see how to calculate a given number from the **Fibonacci series**
    in a few variants that differ significantly in performance results, so you will
    get to know how you can optimize your code. Sometimes, even small changes can
    lead to huge performance improvements. Then, you will learn how to apply the greedy
    approach to solve the **minimum coin change** problem, as well as how to benefit
    from the divide-and-conquer algorithm to find the **closest pair of points** located
    on the two-dimensional surface. You will also see a beautiful **fractal** and
    the code that designs such graphics. The following examples will be related to
    applications of back-tracking with recursion to solve puzzles, namely **rat in
    a maze** and **Sudoku**. Coming closer to the end of the chapter, you will see
    how to apply a genetic algorithm to **guess a title** of this book, based on the
    rules of Darwinian theory of evolution and natural selection. The last example
    will be a brute-force algorithm for **guessing a** **secret password**.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are a lot of interesting examples just ahead of you, so
    be ready to write quite a lot of code and solve these tasks together. Let’s start!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum coin change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closest pair of points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fractal generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rat in a maze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sudoku puzzle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A title guess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A password guess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fibonacci series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the first example, let’s take a look at calculating a given number from
    the **Fibonacci series**, using the following **recursive** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A formula for calculating a number from the Fibonacci series](img/B18069_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A formula for calculating a number from the Fibonacci series
  prefs: []
  type: TYPE_NORMAL
- en: 'Its interpretation is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F(0)* is equal to 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F(1)* is equal to 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F(n)* is a sum of *F(n-1)* and *F(n-2)*, which means that this number is a
    sum of the two preceding ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, *F(2)* is equal to the sum of *F(0)* and *F(1)*. Thus, it is
    equal to 1, while *F(3)* is equal to 2\. It is worth mentioning that there are
    two base cases, namely for *n* equal to 0 and 1\. For both of them, there is a
    specific value defined, namely 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **recursive** implementation in the C# language is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, the `Fibonacci` method calls itself twice with different values
    of parameters, namely smaller by 1 and 2 than the `n` parameter passed to the
    method. If you call the method passing `25,` you will receive 75025 as a result,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the presented recursive version for calculating a value of
    the Fibonacci function is very inefficient and will be very slow for larger input
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can significantly improve its performance using **dynamic programming**,
    either with top-down or bottom-up approaches. First, let’s use the **top-down
    approach** with **memoization** to **cache the calculated results** for subproblems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You use the `Dictionary` class as a cache, where keys are values of `n` passed
    to the `Fibonacci` method and values are the calculated results, namely `Fibonacci(n)`.
    Within the method, you add the check on whether the cache contains a key equal
    to `n`. If so, you do not perform further operations and simply return the value
    from the cache. If the cache does not have such a key yet, you use the same approach
    as in the case of the recursive version and add the calculated result to the cache
    just before returning the result.
  prefs: []
  type: TYPE_NORMAL
- en: Is it worth introducing such changes? Let’s see some numbers regarding execution
    time for the 50th number from the Fibonacci series. In the basic recursive version,
    it took more than 88 seconds on my machine. Introducing the top-down approach
    caused the same result received in... less than 1 millisecond. This solution is
    almost 100,000 times faster!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know that dynamic programming can make a huge difference, let’s take
    a look at the **bottom-up approach** for the Fibonacci number calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, a bigger modification is introduced because you replace recursion with
    iteration. However, the code is very simple, as it consists of only one `for`
    loop that iterates from 2 until the given number and calculates the sum of the
    two preceding values. Of course, there are separate `if` conditions for the 0
    and 1 values of the `n` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: And what about the performance in this case? Let’s compare calculating the 5,000th
    number from the Fibonacci series using both the top-down and bottom-down approaches.
    The top-down approach requires about 2 milliseconds, while the bottom-up still
    takes less than 1 millisecond on my laptop. Keep in mind that we are now talking
    about the 5,000th number from the Fibonacci series, and previously, the tests
    were made for only the 50th number. Incredible performance boost, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Results can differ
  prefs: []
  type: TYPE_NORMAL
- en: The performance results are obtained on my computer and are calculated in a
    very simple way, even without repeating them several times. Of course, such results
    can be different in other circumstances, such as while using your machine. However,
    it is crucial to present some trend, not a precise result in milliseconds. This
    performance testing aims to show you a huge difference between a basic recursive
    version and any of the optimized versions with dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: After the first example, let’s proceed to solving the minimum coin change problem.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum coin change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second example shown in this chapter presents a **greedy algorithm** to
    solve the **minimum coin change** problem, for finding the minimum number of coins
    to receive the amount specified as the input.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.2 – \uFEFFIllustration of denominations in the case of the euro\
    \ currency](img/B18069_09_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Illustration of denominations in the case of the euro currency
  prefs: []
  type: TYPE_NORMAL
- en: For example, for the coin system consisting of 1, 2, 5, 10, 20, 50, 100, 200,
    and 500 denominations, if you want to get a value of 158, you need to pick 5 coins,
    namely 100, 50, 5, 2, and 1\. The greedy approach is very simple because you just
    **pick the largest possible denomination not greater than the remaining amount**.
    You perform this operation until the remaining amount is equal to 0\. As you see,
    the algorithm does not care about the overall solution and tries to choose the
    best solution at each step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C#-based implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most important role is performed by the `GetCoins` method, which takes one
    input, namely the amount to get. It returns a list of chosen coins. For example,
    if you call this method passing 158, you will see 100, 50, 5, 2, and 1 in the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a quick example! Now, let’s proceed to something a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Closest pair of points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another example is an algorithm to **find the closest pair of points** located
    on the two-dimensional surface. It is an interesting algorithmic problem that
    can be solved using the **divide-and-conquer** paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each point is represented by *x* and *y* coordinates, with values starting
    from (**0**, **0**) in the top-left corner of the surface. To find the closest
    pair of points, you first sort all points according to the *x* coordinate, as
    shown in the following diagrams, marked from **A** to **N**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Diagrams of the algorithm to find the closest pair of points](img/B18069_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Diagrams of the algorithm to find the closest pair of points
  prefs: []
  type: TYPE_NORMAL
- en: Then, you divide the surface into two halves. You can do this by calculating
    half of the points count, namely 7 in our example, and taking the first 7 points
    as the left half and the next 7 points as the right half.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a task for **recursion**, so you recursively find the closest points
    in both halves and store data as *r*l (points **D** and **E**) and *r*r (points
    **I** and **K**). You choose the closer pair by comparing such distances and store
    the result as *r*, namely points **D** and **E** in our case.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not all – you also need to check the distance between points from the
    left and the right half, as presented in the preceding diagram, on the right.
    To do so, you get an array with data of all points that are closer to the middle
    point (in respect to the *x* coordinate only) than the *r* distance of the already
    found pair of points (**D** and **E** in our example). Then, you find the closest
    pair of points in this array (**G** and **H** in the example). Let’s name the
    result *s*. To complete the task, choose which pair, from *r* (**D** and **E**)
    and *s* (**G** and **H**), is closer. Then, just return the result (**D** and
    **E** in our case).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, there is the base condition that terminates execution when the array
    of points is empty or contains only one element. Then, you check whether the number
    of points in the array is less than or equal to 3\. If so, you choose the closest
    pair of points in the collection just by checking all possible variants. Otherwise,
    you choose an index of the middle point and call the method recursively for the
    left and right halves. Then, you get points from both halves that are close enough
    to the middle point, taking only *x* coordinates into account. Next, you calculate
    the distance between all points in the `strip` array to get the closest pair from
    it. Finally, you just return the closer pair of points.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you see, the main part of the algorithm is pretty simple to implement and
    understand. So, let’s talk about the rest, starting with the `Point` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Result` record is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Result Closest(Point[] points)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Result result = new(points[0], points[0], double.MaxValue);
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < points.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = i + 1; j < points.Length; j++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: double distance = points[i].GetDistanceTo(points[j]);
  prefs: []
  type: TYPE_NORMAL
- en: if (distance < result.Distance)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: result = new(points[i], points[j], distance);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Result Closer(Result r1, Result r2) =>
  prefs: []
  type: TYPE_NORMAL
- en: 'r1.Distance < r2.Distance ? r1 : r2;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: List<Point> points =
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: new Point(6, 45),   // A
  prefs: []
  type: TYPE_NORMAL
- en: new Point(12, 8),   // B
  prefs: []
  type: TYPE_NORMAL
- en: new Point(14, 31),  // C
  prefs: []
  type: TYPE_NORMAL
- en: new Point(24, 18),  // D
  prefs: []
  type: TYPE_NORMAL
- en: new Point(32, 26),  // E
  prefs: []
  type: TYPE_NORMAL
- en: new Point(40, 41),  // F
  prefs: []
  type: TYPE_NORMAL
- en: new Point(44, 6),   // G
  prefs: []
  type: TYPE_NORMAL
- en: new Point(57, 20),  // H
  prefs: []
  type: TYPE_NORMAL
- en: new Point(60, 35),  // I
  prefs: []
  type: TYPE_NORMAL
- en: new Point(72, 9),   // J
  prefs: []
  type: TYPE_NORMAL
- en: new Point(73, 41),  // K
  prefs: []
  type: TYPE_NORMAL
- en: new Point(85, 25),  // L
  prefs: []
  type: TYPE_NORMAL
- en: new Point(92, 8),   // M
  prefs: []
  type: TYPE_NORMAL
- en: new Point(93, 43)   // N
  prefs: []
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: points.Sort((a, b) => a.X.CompareTo(b.X));
  prefs: []
  type: TYPE_NORMAL
- en: Result? closestPair = FindClosestPair(points.ToArray());
  prefs: []
  type: TYPE_NORMAL
- en: if (closestPair != null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"Closest pair: ({0}, {1}) and ({2}, {3})'
  prefs: []
  type: TYPE_NORMAL
- en: 'with distance: {4:F2}",'
  prefs: []
  type: TYPE_NORMAL
- en: closestPair.P1.X,
  prefs: []
  type: TYPE_NORMAL
- en: closestPair.P1.Y,
  prefs: []
  type: TYPE_NORMAL
- en: closestPair.P2.X,
  prefs: []
  type: TYPE_NORMAL
- en: closestPair.P2.Y,
  prefs: []
  type: TYPE_NORMAL
- en: closestPair.Distance);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Closest pair: (24, 18) and (32, 26) with distance: 11.31'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: void AddLine(int level, float x, float y,
  prefs: []
  type: TYPE_NORMAL
- en: float length, float angle)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (level < 0) { return; }
  prefs: []
  type: TYPE_NORMAL
- en: float endX = x + (float)(length * Math.Cos(angle));
  prefs: []
  type: TYPE_NORMAL
- en: float endY = y + (float)(length * Math.Sin(angle));
  prefs: []
  type: TYPE_NORMAL
- en: lines.Add(new(x, y, endX, endY));
  prefs: []
  type: TYPE_NORMAL
- en: AddLine(level - 1, endX, endY, length * 0.8f,
  prefs: []
  type: TYPE_NORMAL
- en: angle + (float)Math.PI * 0.3f);
  prefs: []
  type: TYPE_NORMAL
- en: AddLine(level - 1, endX, endY, length * 0.6f,
  prefs: []
  type: TYPE_NORMAL
- en: angle + (float)Math.PI * 1.7f);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: record Line(float X1, float Y1, float X2, float Y2)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public float GetLength() =>
  prefs: []
  type: TYPE_NORMAL
- en: (float)Math.Sqrt(Math.Pow(X1 - X2, 2)
  prefs: []
  type: TYPE_NORMAL
- en: + Math.Pow(Y1 - Y2, 2));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: using System.Drawing;
  prefs: []
  type: TYPE_NORMAL
- en: using System.Drawing.Drawing2D;
  prefs: []
  type: TYPE_NORMAL
- en: const int maxSize = 1000;
  prefs: []
  type: TYPE_NORMAL
- en: List<Line> lines = [];
  prefs: []
  type: TYPE_NORMAL
- en: maxSize). Then, you prepare an empty list for the lines. In the last line, you
    call the AddLine method. You indicate that 14 levels of pattern will be added.
  prefs: []
  type: TYPE_NORMAL
- en: The required NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: As you use elements from the `System.Drawing` and `System.Drawing.Drawing2D`
    namespaces, it is necessary to install an additional NuGet package, namely `System.Drawing.Common`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you have the collection of lines, you can calculate the minimum
    and maximum *x* and *y* coordinates, as well as the target *width* and *height*,
    as presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining part of code is related to printing the fractal on the bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Within the presented code, you create a new instance of the `Bitmap` class with
    the specified size, as well as prepare the `Graphics` object to draw on this bitmap.
    Then, you paint the whole bitmap with a white color, set anti-aliasing, and specify
    a black pen for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding piece of code involves the `foreach` loop. Within it, you calculate
    a line width, as well as the start and end coordinates. The last line in the loop
    simply draws the line. Finally, you save the prepared bitmap in the working directory
    in the file, whose name is created based on the current time.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see warnings?
  prefs: []
  type: TYPE_NORMAL
- en: The prepared code shows some warnings in the IDE. They inform you about the
    availability of graphics-related features only on the Windows platform. You can
    hide such warnings by adding the line `#pragma warning disable CA1416` just before
    the preceding code, as well as adding the line `#pragma warning restore CA1416`
    just at the end. What’s more, if you want to also draw graphics on other platforms,
    you can use other available NuGet packages, such as `SkiaSharp`. I strongly encourage
    you to create this example with `SkiaSharp` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all! You can now adjust various parameters to paint beautiful fractals,
    even better than presented in the preceding figure. Some of the other results
    are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Exemplary fractals generated using the recursive function](img/B18069_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Exemplary fractals generated using the recursive function
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot of content about fractals in the internet. However, an approach
    similar to presented here, is described at [http://www.csharphelper.com/howtos/howto_curly_tree.html](http://www.csharphelper.com/howtos/howto_curly_tree.html).
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you are satisfied with the design of your fractal, let’s move to
    the next section, where you will solve the *rat in a* *maze* puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Rat in a maze
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue our adventure with examples by solving the **rat in a maze**
    problem with a **back-tracking algorithm**. The diagram is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.6 – \uFEFFIllustration of the \uFEFFrat in a \uFEFFmaze example](img/B18069_09_6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Illustration of the rat in a maze example
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that a rat is located in the top-left field on the board, which
    is marked as **(0, 0)** in the preceding figure, and we need to find a path to
    the exit, which is located in the bottom-right field and is marked as **(7, 7)**.
    Of course, some blocks are disabled (shown in gray) and the rat cannot go through
    them. To reach the target, the rat can go up, down, left, or right only using
    the available blocks.
  prefs: []
  type: TYPE_NORMAL
- en: You can solve this problem using the **recursion** to check possible paths leading
    the rat from the entry to the exit. If the currently calculated path does not
    reach the exit, you **backtrack** and try other variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main part of the implementation is the `Go` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The method takes two parameters, namely `row` and `column`. It also uses three
    additional variables. The first is named `maze` and is a two-dimensional array
    representing the maze with available (filled with `true` values) and unavailable
    (`false`) fields for the rat. The second, namely `size`, stores the size of the
    maze, namely the number of rows, which is also equal to the number of columns.
    Another variable (`solution`) is similar to `maze`, but it stores the data of
    the currently checked path. The fields forming the solution are filled with `true`
    values, while others are filled with `false`.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the method, you check whether the rat already reached the
    exit. If so, you mark the final field as a part of the solution and return a value
    indicating that the rat completed its task and exited the maze. Otherwise, you
    check whether the rat is still within the maze and not on any unavailable field.
    If all of these conditions are met, you check whether this field is already a
    part of the path, and if so, you inform that this solution is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: If the rat is within the maze and on an available field that has not already
    been visited, you mark this field as a part of the solution and try to go down,
    right, up, and left by calling the `Go` method recursively. If none of these moves
    reaches the target (of course, also after the next steps), you indicate that the
    current field is not a part of the solution, which represents **back-tracking**.
    Then, you return a value indicating that the target has not been reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the code that calls the `Go` method for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: void Print()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int row = 0; row < size; row++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int col = 0; col < size; col++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.Write(solution[row, col] ? "x" : "-");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: x-------
  prefs: []
  type: TYPE_NORMAL
- en: x-------
  prefs: []
  type: TYPE_NORMAL
- en: xx------
  prefs: []
  type: TYPE_NORMAL
- en: -x------
  prefs: []
  type: TYPE_NORMAL
- en: -xx-----
  prefs: []
  type: TYPE_NORMAL
- en: --x-----
  prefs: []
  type: TYPE_NORMAL
- en: --xxxxxx
  prefs: []
  type: TYPE_NORMAL
- en: '-------x'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: bool Solve()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: (int row, int col) = GetEmpty();
  prefs: []
  type: TYPE_NORMAL
- en: if (row < 0 && col < 0) { return true; }
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 1; i <= 9; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (IsCorrect(row, col, i))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: board[row, col] = i;
  prefs: []
  type: TYPE_NORMAL
- en: if (Solve()) { return true; }
  prefs: []
  type: TYPE_NORMAL
- en: else { board[row, col] = 0; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: (int, int) GetEmpty()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int r = 0; r < 9; r++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int c = 0; c < 9; c++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (board[r, c] == 0) { return (r, c); }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (-1, -1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: bool IsCorrect(int row, int col, int num)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < 9; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (board[row, i] == num) { return false; }
  prefs: []
  type: TYPE_NORMAL
- en: if (board[i, col] == num) { return false; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int rs = row - row % 3;
  prefs: []
  type: TYPE_NORMAL
- en: int cs = col - col % 3;
  prefs: []
  type: TYPE_NORMAL
- en: for (int r = rs; r < rs + 3; r++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int c = cs; c < cs + 3; c++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (board[r, c] == num) { return false; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: int[,] board = new int[,]
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 0, 5, 0, 4, 0, 1, 0, 0, 6 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 0, 0, 9, 5, 0, 8, 0, 0 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 9, 0, 4, 0, 6, 0, 0, 0, 1 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 6, 2, 0, 0, 0, 5, 3, 0, 4 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 0, 9, 0, 0, 7, 0, 2, 0, 5 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 5, 0, 7, 0, 0, 0, 0, 8, 9 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 8, 0, 0, 5, 1, 9, 0, 0, 2 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 2, 3, 0, 0, 0, 6, 5, 0, 8 },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 4, 1, 0, 2, 0, 8, 6, 0, 0 }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a back-tracking algorithm can be successfully applied to solve
    both rat in a maze and Sudoku puzzles. You can achieve this goal with short and
    clear code that is also easy to understand. So, after these examples, let’s move
    on to the next section where you will see an interesting application of a genetic
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Title guess
  prefs: []
  type: TYPE_NORMAL
- en: It is high time to change a type of applied algorithm to a **heuristic** one,
    which has many applications and also subtypes. Here, we focus only on **genetic
    algorithms**, which are **adaptive heuristic search algorithms**. They are related
    to the Darwinian theory of evolution and natural selection. According to it, individuals
    in a population compete, and the **population evolves to create next generations
    that are better suited to survive**. The genetic algorithms operate on strings
    that evolve to receive possibly the highest value of **fitness**, complying with
    the **rule of survival** and **passing on the genes of the fittest parents**,
    also based on a **randomized data exchange**. The algorithm ends its operation
    when a suitable value of fitness is reached or when the maximum number of generations
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot of content about genetic algorithms in the internet, such
    as in the article published at [https://link.springer.com/article/10.1007/s11042-020-10139-6](https://link.springer.com/article/10.1007/s11042-020-10139-6).
    The simple approach to a genetic algorithm, which is shown in this chapter, is
    based on the solution presented at [https://www.geeksforgeeks.org/genetic-algorithms/](https://www.geeksforgeeks.org/genetic-algorithms/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a genetic algorithm application to guess
    the title of this book. The first part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you create an initial population, with 1,000 individuals. Each individual
    has a random chromosome, represented by a random string whose length is equal
    to the target string, which is a title of the book. Let’s go further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting part is located in the infinite `while` loop. Here, you
    sort the population from the best fitted to survive – that is, by fitness in decreasing
    order. To explain it in detail, fitness is equal to 0 when no chars in the chromosome
    string match the following chars in the target string. In turn, fitness is equal
    to 33 (i.e., the number of chars in the book title), when the chromosome string
    is equal to the target string. For this reason, if the first element from the
    population (namely the fittest) has a fitness equal to the target string length,
    it means that the solution is found, so you just print it and exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you clear the list with data of a new generation and add 200 best-fitted
    individuals to it. This means that **20% of the best-fitted individuals are moved
    automatically to the next generation**. For the remaining 800 places in the new
    generation, you perform **crossover** and **randomly choose parents, from 40%
    of the best-fitted individuals, to generate new individuals**. Then, you replace
    the current population with the new generation and proceed to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning the `Individual` record, the code for which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Individual Mate(Individual p1, Individual p2)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string child = string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < Target.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: float r = random.Next(101) / 100.0f;
  prefs: []
  type: TYPE_NORMAL
- en: if (r < 0.45f) { child += p1.Chromosome[i]; }
  prefs: []
  type: TYPE_NORMAL
- en: else if (r < 0.9f) { child += p2.Chromosome[i]; }
  prefs: []
  type: TYPE_NORMAL
- en: else { child += GetRandomGene(); }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return new Individual(child, GetFitness(child));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: char GetRandomGene() => Genes[random.Next(Genes.Length)];
  prefs: []
  type: TYPE_NORMAL
- en: string GetRandomChromosome()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string chromosome = string.Empty;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < Target.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: chromosome += GetRandomGene();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return chromosome;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: int GetFitness(string chromosome)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int fitness = 0;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < Target.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (chromosome[i] == Target[i]) { fitness++; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return fitness;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: void Print() => Console.WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '$"Generation {generationNo:D2}:'
  prefs: []
  type: TYPE_NORMAL
- en: '{population[0].Chromosome} / {population[0].Fitness}");'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Generation 00: UvWvvtycVTYAsJYxXZpanLkj#rDrmDIEI / 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 01: sXDGuQQDPnbjpRvWZs evqRNlg#yiwIPL / 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 02: j#TvvtmKToXuTjxBegpaCLkmNsornzg R / 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 03: fZCUBIT QrnuzwuWTskTOf bezodQwhmM / 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 04: CyDwafZZpinLziuPgs yID AevGrGf bs / 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 05: C# ZaBawSWwLoturSXOcIq wLeSgQOhme / 12 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 10:  Sboats ttrDcterus Mnt jmvGrifhms / 17 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 15: C kData ltrCkteres entbAagorZthmD / 21 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 20: C#VDatahStrdcturessanU Al#orithmd / 26 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 25: CZ Data StrunturOs awd Algorithms / 29 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 30: C# Data Structures Qjd Algorithms / 31 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 35: C# Data Structures and Algorothms / 32 (...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 37: C# Data Structures and Algorithms / 33'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: using System.Diagnostics;
  prefs: []
  type: TYPE_NORMAL
- en: using System.Text;
  prefs: []
  type: TYPE_NORMAL
- en: const string secretPassword = "csharp";
  prefs: []
  type: TYPE_NORMAL
- en: int charsCount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: char[] chars = new char[36];
  prefs: []
  type: TYPE_NORMAL
- en: for (char c = 'a'; c <= 'z'; c++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: chars[charsCount++] = c;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for (char c = '0'; c <= '9'; c++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: chars[charsCount++] = c;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: for (int length = 2; length <= 8; length++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch sw = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: int[] indices = new int[length];
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < length; i++) { indices[i] = 0; }
  prefs: []
  type: TYPE_NORMAL
- en: bool isCompleted = false;
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder builder = new();
  prefs: []
  type: TYPE_NORMAL
- en: long count = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while (!isCompleted)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: builder.Clear();
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: builder.Append(chars[indices[i]]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: string guess = builder.ToString();
  prefs: []
  type: TYPE_NORMAL
- en: if (guess == secretPassword)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Found.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: count++;
  prefs: []
  type: TYPE_NORMAL
- en: if (count % 10000000 == 0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($" > Checked: {count}.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: indices[length - 1]++;
  prefs: []
  type: TYPE_NORMAL
- en: if (indices[length - 1] >= charsCount)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = length - 1; i >= 0; i--)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: indices[i] = 0;
  prefs: []
  type: TYPE_NORMAL
- en: indices[i - 1]++;
  prefs: []
  type: TYPE_NORMAL
- en: if (indices[i - 1] < charsCount) { break; }
  prefs: []
  type: TYPE_NORMAL
- en: if (i - 1 == 0 && indices[0] >= charsCount)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: isCompleted = true;
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: sw.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: int seconds = (int)sw.ElapsedMilliseconds / 1000;
  prefs: []
  type: TYPE_NORMAL
- en: Console.ForegroundColor = ConsoleColor.White;
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"{length} chars: {seconds}s");'
  prefs: []
  type: TYPE_NORMAL
- en: Console.ResetColor();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
