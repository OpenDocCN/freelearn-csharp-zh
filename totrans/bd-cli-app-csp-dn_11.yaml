- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed the development and testing of our application, it
    is time to release it to the world! We will need to package and deploy it in order
    to distribute it to (millions of) users worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Each platform (such as Windows, macOS, and Linux) has its own approach to distributing
    applications. Since .NET 8 is cross-platform, we can distribute Bookmarkr to even
    more users, no matter what platform they are using.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we package and distribute the application, it is important that
    we test it on every target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore different packaging and deployment techniques
    that will help us achieve this goal. More specifically, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the different options when it comes to packaging and distributing a
    CLI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to package and distribute a cross-platform CLI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to deploy that CLI application to multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to manage versions of a distributed application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: A bit of terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you will come across the terms “packaging,” “distribution,”
    and “deployment.” For those of you who are not familiar with these terms, here
    is a brief definition of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packaging**: Packaging refers to the process of preparing the application
    for release. This includes bundling all necessary files, libraries, and resources
    into a single unit that can be easily installed or executed by our users. Effective
    packaging ensures that the application is compatible with various environments
    and simplifies the installation process. It often involves creating installers
    or archives that streamline the deployment of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-get` repositories). The goal of distribution is to make the application
    accessible to its intended audience while ensuring that it reaches them in a secure
    and efficient manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: Deployment is the mechanism by which the distributed application
    is installed and made operational on the user’s computer. This can involve configuring
    settings, integrating with existing systems, and ensuring that all components
    work appropriately. Deployment can be done manually or can be automated through
    various tools and scripts. The aim is to allow users to access and utilize the
    application effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you may have figured out, making an application (including a CLI application)
    available to a user is a three-step process that can be summarized by this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The process of making an application available to users](img/B22400_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The process of making an application available to users
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the terminology, let’s start by exploring the available
    options when it comes to the packaging, distribution, and deployment of a CLI
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and distribution options for CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to packaging a CLI application, several methods exist, and choosing
    the most appropriate one depends on the way we intend to distribute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MSI installer**: This option allows for a more traditional installation experience
    and can be achieved using tools such as WiX or Visual Studio Installer Projects.
    Keep in mind that this option only works for Windows. Hence, if we intend to distribute
    our CLI application to multiple platforms, this option may not be the best one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet tool install` command. Since our CLI application is built using a version
    of .NET that is cross-platform, we can distribute it as a .NET tool to various
    platforms. The downside of this approach is in the installation mechanism: it
    requires the .NET CLI. This is great if our audience is developers or IT professionals
    but not that appropriate otherwise. We should only consider this approach if our
    CLI application is a developer or IT administrator tool, which is not the case
    with our bookmark management application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker container**: This is also a great option for multiplatform distribution.
    A noticeable advantage of a Docker container is that it has a lower footprint
    on the local machine since no local installation is performed and limited access
    to the system is required. A Docker container is a self-contained file. However,
    as with the .NET tool option, this option mainly targets developers or IT administrators
    since users need to have knowledge of using Docker in order to deploy our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-get` package manager, while macOS provides Homebrew and Windows provides
    WinGet. These options are great since users of each platform are familiar with
    them no matter their technical knowledge. This means that these distribution mechanisms
    don’t just target developers and IT administrators but everyone! Once again, since
    our CLI application is built with cross-platform technology (.NET), we can use
    the same code and package it for distribution on each of these platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, several packaging and distribution options are provided to
    us, and you can use whichever best suits your situation. In this chapter, we will
    explore the last three packaging and distribution options: .NET tool, Docker container,
    and WinGet (as a platform-specific packaging option).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and distributing a CLI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the subtleties of packaging and distributing
    our application, Bookmarkr, using three different options. We will take this opportunity
    to explain when each approach is most appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #1 – as a .NET tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By packaging and distributing our application as a .NET tool, our users will
    be able to install it using the .NET CLI. It is, however, important that users
    ensure they have the appropriate .NET version installed to avoid version mismatches,
    which may cause unexpected behaviors in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – packaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to modify the `.csproj` file to add properties that indicate
    that it should be packaged as a tool. These properties should be added to the
    `<``PropertyGroup>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain what we have just added here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PackageId`: This represents the unique identifier for our package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Version`: This indicates the version of our package. We will need to change
    this value when we need to package a newer version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Authors`: This represents the author (or the list of authors) of a package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: This provides a brief description of what the application does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackAsTool`: Set to `true`, this indicates that the application should be
    packaged as a .NET tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToolCommandName`: This is the name of the command users will type into their
    terminal to execute our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageOutputPath`: Since a .NET tool is packaged as a NuGet package, an `.nupkg`
    file is then generated. This property indicates where this file will be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageLicenseExpression`: I chose to provide the code as an MIT license since
    it is a permissive license that allows for the reuse of the code in any project
    as long as the original copyright notice and license are included in all copies
    or substantial portions of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageReadmeFile`: This points to a Markdown file in which we explain the
    purpose of the application, how to get started using it, and a link to its documentation,
    among other things. The content of this Markdown file will be displayed on the
    package page on the NuGet site for the user to read. You will find that file in
    the code repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Copyright`: This presents the copyright details of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageProjectUrl`: This points to the home page of the project’s website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepositoryUrl`: This points to the repository where the application’s code
    resides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageTags`: This presents a semicolon-delimited list of keywords that can
    be used when searching for packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify the location and how to treat the `README.md` file, we need to add
    the following XML code to the `.``csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is to package the application. This is achieved by running
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that it will be generated at the location indicated by the value of
    the `PackageOutputPath` property.
  prefs: []
  type: TYPE_NORMAL
- en: Our package is now ready for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to distribute a .NET tool is to provide it through the NuGet
    site, located at [https://www.nuget.org](https://www.nuget.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s head to the NuGet site and click on the **Sign in** link in the top-right
    corner of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Signing in to the NuGet site](img/B22400_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Signing in to the NuGet site
  prefs: []
  type: TYPE_NORMAL
- en: 'I will be signing in with my personal account and granting the required permissions
    to the NuGet site, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Granting required permissions to the NuGet site](img/B22400_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Granting required permissions to the NuGet site
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is the first time I have signed in with this account, the NuGet
    site asks me to provide a username:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Choosing a username for the NuGet site](img/B22400_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Choosing a username for the NuGet site
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it! As a publisher of NuGet packages, I am now all set, and I can
    start uploading my packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – All set as a NuGet package publisher](img/B22400_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – All set as a NuGet package publisher
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now upload our package!
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is to click on `.nupkg` file we generated earlier. The package
    is then analyzed and the validation results are presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Uploading a package to the NuGet website](img/B22400_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Uploading a package to the NuGet website
  prefs: []
  type: TYPE_NORMAL
- en: Since our package is valid, we can submit it by clicking the **Submit** button
    at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once uploaded, it usually takes around 15 minutes (but can sometimes take up
    to an hour) for the package to be validated and indexed before it appears in search
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Package awaiting validation and indexing](img/B22400_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Package awaiting validation and indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package validation and indexing have been completed, it will appear
    on the NuGet website just as any other NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Bookmarkr is available on the NuGet website!](img/B22400_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Bookmarkr is available on the NuGet website!
  prefs: []
  type: TYPE_NORMAL
- en: Now that our application can be found by users, let’s see how it can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A user can deploy (that is, install) our application on their machine very
    easily by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is complete, the user can execute our application by
    typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! We’ve packaged, distributed, and deployed Bookmarkr as a .NET
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can deliver Bookmarkr to our users as a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #2 – as a Docker container'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packaging and distributing our application as a Docker container allows our
    users to install and use our application by reducing the footprint of the application
    on their environment (i.e., operating system and data).
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – packaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with containers, you may already know that in order to create
    a container image, a Dockerfile is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile is a file with no extension that should be located at the root
    of the project directory. For our application, its content is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In essence, this file instructs Docker to build and publish the application
    (the first six lines of it), and then to build a container image out of the published
    application (the remaining five lines).
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the command to actually build the image, we need to ensure that
    both Docker Desktop and **Windows Subsystem for Linux** (**WSL**) are installed
    and running. Note that Docker Desktop requires administrator privileges on the
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command for building a Docker image is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `-t bookmarkr` parameter is used to tag the Docker image to be generated
    with a name and an optional version number (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: The last dot character is neither a typo nor is it optional. It refers to what
    we call the **build context**. More specifically, it instructs Docker where to
    look for the Dockerfile, which, in this case, is the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation should take about five minutes, and once it is complete, the
    Docker image will be created, and it can be retrieved by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the container image has been generated on our local machine. We should,
    however, distribute it through a location that everyone can easily find.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to distribute Docker images is through Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to head to the Docker Hub portal, located at [https://hub.docker.com](https://hub.docker.com).
    If you don’t already have a Docker Hub account, you can create one from there.
    I already have such an account, and my username is `theAzurian`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s follow the steps to push our local Docker image to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s log in to our Docker Hub account using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I’m passing my `-p` parameter. This PAT was created through the Docker Hub portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to tag the image to include the Docker Hub username of its author,
    the name of the application, and its version, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to push the tagged image to Docker Hub using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure that the image has effectively been pushed to Docker Hub by heading
    to the portal and looking for it in our Docker Hub profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Bookmarkr is available in the Docker Hub portal!](img/B22400_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Bookmarkr is available in the Docker Hub portal!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also perform a search for it in the Docker Hub portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal](img/B22400_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal
  prefs: []
  type: TYPE_NORMAL
- en: Our application can now be found by our users. Let’s see how it can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for a user to run Docker on a Windows machine, they also need to have
    both Docker Desktop and WSL installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our user can obtain the application from Docker Hub by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'They can execute it by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Bookmarkr can then be run on the user’s computer as a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Bookmarkr running as a Docker container](img/B22400_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Bookmarkr running as a Docker container
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We packaged, distributed, and deployed Bookmarkr as a Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can deliver Bookmarkr to our users as a WinGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #3 – as a WinGet package'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By packaging and distributing our application as a WinGet package, we allow
    our users to install it as any other application they have installed using WinGet,
    Microsoft’s package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To package a .NET CLI application for distribution through WinGet (the official
    Windows package manager), we first need to create a manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to manually create and submit the manifest to the WinGet
    package repository on GitHub ([https://github.com/microsoft/winget-pkgs](https://github.com/microsoft/winget-pkgs)),
    the easiest way to do so is using the `WingetCreate` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first install it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create the new manifest, we first need to build our CLI application
    as a self-contained .NET application using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c Release`: Since this is a production-ready version of the application,
    we want to publish it using the Release configuration to ensure that it is optimized
    for performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r win-x64`: Since WinGet is the package manager for Windows (and Windows
    only), we specify the target runtime to be the 64-bit version of Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:selfcontained=true`: A self-contained application already includes the
    .NET runtime, so the user’s machine doesn’t need to have it installed. The application
    will then carry everything it needs to run, including the runtime, libraries,
    and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:IncludeNativeLibrariesForSelfExtract=true`: This ensures that platform-specific
    libraries, along with unmanaged native libraries, are included in the published
    application. This is useful if we use some specific Serilog sinks and for the
    SQLite library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:PublishSingleFile=true`: This instructs .NET to bundle everything (including
    the application code, the .NET runtime, and the dependencies) into a single executable
    file. While this makes it more convenient for distribution (because we are distributing
    a single file), it results in a file that is larger in size than framework-dependent
    publishing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application will be generated in the `bin\Release\net8.0\win-x64\publish`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will upload it to a location that should be accessible to the WinGet
    tool. It is common to pick a remote, publicly accessible, read-only location.
    I decided to use an Azure Storage account. Hence, the location of the executable
    will be [https://bookmarkr.blob.core.windows.net/releases/1.0.0/](https://bookmarkr.blob.core.windows.net/releases/1.0.0/).
  prefs: []
  type: TYPE_NORMAL
- en: About GitHub releases
  prefs: []
  type: TYPE_NORMAL
- en: If your application is built as an open source project on GitHub, you will likely
    make your executable versions available as releases. However, releases on GitHub
    follow certain guidelines that go way beyond the scope of this book. If this is
    a topic you are interested in, I recommend that you explore these guidelines by
    visiting [https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md](https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create our manifest files! We can do so using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool will ask a series of questions required to generate the manifest files.
    Here is an example of what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Generating the WinGet manifest files](img/B22400_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Generating the WinGet manifest files
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be three files generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version manifest (theAzurian.bookmarkr.yaml)**: Contains metadata about the
    specific version of the application being packaged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installer manifest (theAzurian.bookmarkr.installer.yaml)**: Details the installation
    specifics of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default locale manifest (theAzurian.bookmarkr.locale.en-CA.yaml)**: Defines
    localization settings for the application. It ensures that users receive a version
    of the application that is appropriately localized, enhancing user experience
    by presenting information in their preferred language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I personally like to keep these files inside my Visual Studio project, inside
    the following folder structure that I create at the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in our case, this folder structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before we submit our manifest to the WinGet team, it is recommended that we
    test it locally to ensure that it works as expected. This is important as submitting
    our package could lead to a delay during the WinGet approval process if the manifest
    contains issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to activate the ability to install applications from
    local manifests. This can be done by executing the following command in a terminal
    running as administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run this command, providing the path to the `manifests.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the application is installed and runs as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Testing the WinGet package locally before submission](img/B22400_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Testing the WinGet package locally before submission
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to submit our manifest to the WinGet team!
  prefs: []
  type: TYPE_NORMAL
- en: Submitting our manifest to the WinGet package repository requires us to generate
    a PAT for our GitHub account. We can do this using the `wingetcreate token` command,
    or we can skip this step and, when submitting the manifest, `wingetcreate` will
    prompt us to authenticate to our GitHub account. Let’s do it this way!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open the browser and take us to the GitHub sign-in page. We will
    have to log on to our account. Once done, we will need to provide the required
    authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Authorizing WingetCreate for our GitHub account](img/B22400_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Authorizing WingetCreate for our GitHub account
  prefs: []
  type: TYPE_NORMAL
- en: It will then take us to the Pull Request page where we can follow its progress.
    After about 30 minutes, the pull request is completed, and the package is available
    for our users to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can then install Bookmarkr using WinGet by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And voilà! We have packaged, distributed, and deployed Bookmarkr as a WinGet
    package.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have seen three different approaches to packaging, distributing, and
    deploying our application. But how do we manage multiple versions of that application?
    That’s what we are going to explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the options that we presented earlier provide version management mechanisms.
    Version management is as important as the packaging and distribution mechanism
    that we select.
  prefs: []
  type: TYPE_NORMAL
- en: As our application evolves and new features are added, modified, or removed,
    we want to offer a way for our users to consume these updates at their convenience.
    That is where versioning comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, only a single version of our application is distributed. We can hence
    install it by either omitting its version number or explicitly indicating it.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we update the application? How can we distribute the new version?
    And what if the new version introduces a bug and we need to roll back to the previous
    version?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how we can achieve this for each of the distribution methods that
    we covered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into managing different versions of an application, let us start
    by introducing **semantic versioning**.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with this approach to versioning applications, you know
    that it is probably the most common and widely adopted approach in the industry.
    If you haven’t heard about it before, let me give you a quick introduction. If
    you want to go deeper in your exploration of semantic versioning, I recommend
    that you visit its official website at [https://semver.org](https://semver.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, semantic versioning expresses a version number using this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: Indicates that this version of the application contains breaking
    changes that are incompatible with the previous major version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Indicates that this version of the application only adds new functionalities
    that are backward compatible with the previous versions of the same major version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: Indicates that this version of the application contains bug fixes
    that are backward compatible with the previous versions of the same major version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each part is represented as a number that is incremented with each new version.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand semantic versioning, let’s use it to manage different
    versions of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of a .NET tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you ran the version of Bookmarkr that we provided as a .NET tool, you will
    certainly have noticed that it returns the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Bookmarkr as a .NET tool fails to execute](img/B22400_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Bookmarkr as a .NET tool fails to execute
  prefs: []
  type: TYPE_NORMAL
- en: Let’s then fix the problem and distribute a new version.
  prefs: []
  type: TYPE_NORMAL
- en: The error comes from the fact that the `appsettings.json` file is not being
    made part of the package when the `dotnet pack` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, fixing this problem is straightforward. Locate the following entry
    in the `.``csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since the new version we are about to package and distribute only provides
    a bug fix, we shall increment the patch number, so the version number looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can now package and distribute the new version by following the same steps
    that we described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we distribute it, it is recommended to test it locally using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `--add-source` parameter allows us to specify a location from which the
    package will be deployed. Here, I am specifying the path where the NuGet package
    was generated on my local machine.
  prefs: []
  type: TYPE_NORMAL
- en: After ensuring that this new version works successfully on the local machine,
    we can proceed with pushing it to the NuGet website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can get a specific version of the tool by providing its version number
    as a parameter. In this case, this could be achieved by typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, they can simply type the following command to get the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once this command is executed, the previous version of the tool will be replaced
    by the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the new version of the application, we can now see that the error
    is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Bookmarkr as a .NET tool running successfully](img/B22400_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Bookmarkr as a .NET tool running successfully
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We now know how to manage versions of a .NET tool.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we manage versions of a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, when we pushed the Docker image to Docker Hub, we tagged
    it with a version number. Hence, if we want to distribute a new version, we can
    tag the new image with a different version number.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are familiar with Docker, you may know about working with containers
    without providing their version number or using the `latest` tag.
  prefs: []
  type: TYPE_NORMAL
- en: When distributing multiple versions of a container, it is important to indicate
    which one of these is the latest version, by tagging that version using the `latest`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s assume that we are distributing a new version of Bookmarkr and that
    we want to indicate that this new version is the latest one. We can achieve this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one creates a new Docker image that is tagged with version 2.0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one tags version 2.0.0 as the latest version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third command pushes the image tagged with version 2.0.0 to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth one pushes the image tagged with the latest version to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that we push the same image using two different tags allows our users
    to get it (using the `docker pull` command) with or without specifying its version
    number. Hence, as we keep updating the application and pushing new Docker images,
    we will tag the newest version with the `latest` tag. Should that version contain
    a bug, we can direct our users to a previous version by tagging it with the `latest`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we head to the Docker Hub portal, we will see that the new version has been
    successfully pushed. Notice that there are two versions of the same image: one
    with version number 2.0.0 as a tag, and the other with the `latest` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – New version of the Docker image pushed to Docker Hub](img/B22400_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – New version of the Docker image pushed to Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: 'On the user’s side, they can get a specific version by explicitly mentioning
    its tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, they can get the latest version (i.e., the version tagged as `latest`)
    by omitting the tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The user will then see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Running the new version of the Docker container](img/B22400_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Running the new version of the Docker container
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We now know how to manage versions of a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we manage versions of a WinGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of a WinGet package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to submit a new version of the application, following an update to
    the application’s code or functionalities, we first need to update the version
    number in the `.csproj` file (the `<``Version>` element).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to publish the application again using the same command we saw
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to upload the resulting binaries to our distribution location,
    which is our Azure Storage account, keeping in mind that we should create a new
    directory for the new version. The path will then look like this for version 1.0.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to update the manifest using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The new manifest is then generated and is ready for submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as we previously learned, it is always good practice to test the new
    version locally before submitting it. To do that, we will execute the same command
    as we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the tests are successful, we submit the new version using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The remaining steps are similar to those we followed when submitting the initial
    version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new version has been approved and added to the WinGet package repository,
    users can find it and install it. They can install the latest version using this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, they can install a specific version by passing the desired version number
    as a parameter to the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.19 – The updated version of Bookmarkr is available in WinGet](img/B22400_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – The updated version of Bookmarkr is available in WinGet
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! This is how we manage multiple versions of a WinGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to package and deploy Bookmarkr onto different
    platforms in order to distribute it to users all around the world, no matter their
    platform of choice, be it Windows, Linux, or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a milestone we achieved, from the inception of the idea of our
    CLI application all the way to getting it into the hands of millions of users
    worldwide. Let’s take a moment to celebrate this achievement and be proud of ourselves.
    Congratulations! 🎉
  prefs: []
  type: TYPE_NORMAL
- en: However, some users are telling us that the application is sometimes slow. We
    haven’t experienced these performance issues since we are running on fast and
    powerful computers, but that is not the case with all our users. Although we could
    simply specify the minimum requirements to run Bookmarkr, we don’t want to limit
    the number of users that can benefit from and be able to use it. So, we have decided
    to see whether there is something we can do.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore different techniques that will allow us
    to optimize the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: An even better way is by challenging yourself to complete tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 – allowing Linux users to install Bookmarkr using apt-get'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, Bookmarkr can be deployed to Windows using WinGet. However, this
    doesn’t work on Linux, where Linux users typically use `apt-get` for deploying
    applications. You are thus challenged to distribute Bookmarkr as an `apt-get`
    package so Linux users can also enjoy using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 – allowing macOS users to install Bookmarkr using Homebrew'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same applies to macOS users: they typically install their applications
    using the `brew` command. You are thus challenged to distribute Bookmarkr as a
    Homebrew formula.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Advanced Techniques and Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will explore crucial aspects of CLI application development
    that enhance performance, security, and functionality. You'll delve into performance
    optimization and tuning techniques, learning how to profile your CLI applications,
    identify bottlenecks, and implement efficient algorithms and data structures.
    This includes strategies like caching, load balancing, and code refactoring to
    improve execution speed and resource utilization. Next, you'll focus on security
    considerations specific to CLI applications, covering best practices and protection
    against common vulnerabilities. You'll learn how to implement strong authentication
    mechanisms, use encryption for sensitive data, and follow the principle of least
    privilege in your CLI tools. Finally, you'll explore additional resources and
    libraries that will allow you to dive deeper into the various concepts and techniques
    presented in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B22400_12.xhtml#_idTextAnchor205)*, Performance Optimization
    and Tuning*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B22400_13.xhtml#_idTextAnchor220)*, Security Considerations
    for CLI Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B22400_14.xhtml#_idTextAnchor236)*, Additional Resources and
    Libraries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
