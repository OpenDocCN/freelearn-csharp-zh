- en: Abstract Away Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象问题
- en: These days, it is quite easy to find resources on the internet to integrate
    into your application. Many provide functionality that would be perfectly suited
    to any number of applications. After all, why spend time reinventing the wheel
    when someone else has already done the bulk of the work for you?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很容易在网上找到资源集成到你的应用程序中。许多提供的功能非常适合任何数量的应用程序。毕竟，为什么要在别人已经做了大部分工作的基础上浪费时间呢？
- en: 'In this chapter, we will gain an understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解：
- en: Abstracting a Gravatar service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象Gravatar服务
- en: Extending the repository pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展存储库模式
- en: Using a generic repository and Entity Framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用存储库和Entity Framework
- en: Abstracting away problems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象问题
- en: There is an abundance of utilities and libraries these days to help make a full-featured
    application. It can be quite easy to integrate these third-party systems within
    your application. At times, however, you may need to replace one third-party library
    with another. Alternatively, you may find yourself relying on the implementation
    that a third-party system provides, only to find that the implementation has changed
    with a later update. How can you avoid these potential problems?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多工具和库可以帮助创建一个功能齐全的应用程序。在应用程序中集成这些第三方系统可能相当容易。然而，有时你可能需要用另一个第三方库替换一个。或者，你可能会发现自己依赖于第三方系统提供的实现，结果发现该实现随着后续更新而发生了变化。你该如何避免这些潜在的问题？
- en: Creating a dependency on code that is outside your control can create problems
    for you in the future. If a change is introduced in a library that you depend
    on, it could potentially break your system. Or, if your requirements change and
    the system no longer fits your specific needs you may have to rewrite large portions
    of your application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖外部控制之外的代码可能会在未来给你带来问题。如果依赖的库中引入了变更，可能会破坏你的系统。或者，如果你的需求发生变化，系统不再满足你的特定需求，你可能需要重写应用程序的大量部分。
- en: Don't depend directly on any third-party system. Abstract away the details so
    that your application depends only on an interface that you define. If you define
    the interface and expose only the functionality that you need, it can become trivial
    to make changes when they are required. Changes could include minor updates or
    replacing whole libraries. You want these changes to have minimal impact on the
    rest of your application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接依赖任何第三方系统。抽象出细节，使你的应用程序只依赖于你定义的接口。如果你定义了接口并且只暴露你需要的功能，那么在需要时进行更改将变得非常简单。更改可能包括小的更新或替换整个库。你希望这些更改对应用程序的其他部分影响最小。
- en: Don't rely on third-party implementations; focus on test driving your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖第三方实现；专注于驱动测试你的代码。
- en: While developing an application with Test-Driven Development in mind, it can
    often be tempting to test third-party software. While it is important to ensure
    that any third-party library or utility works well when integrated into your system,
    it is best to focus on the behavior of your system. Ensure that your system behaves
    well with the functionality that you wish to expose.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑测试驱动开发的应用程序开发过程中，往往会诱使人们测试第三方软件。虽然确保任何第三方库或工具集成到你的系统中表现良好很重要，但最好专注于你系统中的行为。确保你的系统能够良好地处理你希望公开的功能。
- en: This means that you should handle the *happy path* as well as any possible *exceptions*
    that may be thrown. Gracefully recovering from an error that crops up will allow
    your application to continue to function in the event that a third-party service
    is not functioning as you expect.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你应该处理*正常路径*以及可能抛出的任何*异常*。优雅地恢复错误将允许你的应用程序在第三方服务未按预期运行时继续运行。
- en: Gravatar
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gravatar
- en: The Speaker Meet application uses Gravatar to display speaker, community, and
    conference avatar images. Gravatar is an online service that associates an email
    address with an image. Users can create an account and add an image that they
    wish to be shown by any service that requests their image. The image is retrieved
    from the Gravatar service by creating an MD5 hash of the user's email address
    and requesting an image from Gravatar by supplying the hashed value. By relying
    on the hashed value, the user's email address is not exposed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet 应用程序使用 Gravatar 来显示演讲者、社区和会议头像图像。Gravatar 是一个在线服务，将电子邮件地址与图像关联起来。用户可以创建一个账户并添加他们希望任何请求其图像的服务显示的图像。通过创建用户的电子邮件地址的
    MD5 哈希并使用哈希值从 Gravatar 请求图像来检索图像。通过依赖哈希值，用户的电子邮件地址不会被暴露。
- en: 'The Gravatar service allows the consumer to supply optional parameters to the
    HTTP call in order to request a specific size, rating, or default image if none
    is found. Some of these options include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar 服务允许消费者向 HTTP 调用提供可选参数，以请求特定大小、评级或默认图像（如果未找到任何图像）。这些选项包括：
- en: '**s**: The requested size of the image; by default, this is 80 x 80 pixel'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s**：请求的图像大小；默认情况下，这是 80 x 80 像素'
- en: '**d**: The default image if none is found; options include 404, **mm** (**mystery-man**) ,
    identicon, and so on'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d**：如果未找到任何图像，则返回的默认图像；选项包括 404、**mm**（**神秘人**）、identicon 等'
- en: '**f**: Force default; always return the default icon, even if an image is found'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f**：强制默认；即使找到图像也总是返回默认图标'
- en: '**r**: Rating; users can label their image as G, PG, R, and X'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r**：评级；用户可以将他们的图像标记为 G、PG、R 和 X'
- en: By supplying these values, you have some control over the size and types of
    image you wish to display within your application. The Speaker Meet application
    relies on the default offerings from Gravatar.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供这些值，你可以控制你希望在应用程序中显示的图像的大小和类型。Speaker Meet 应用程序依赖于 Gravatar 的默认提供项。
- en: Starting with an interface
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从接口开始
- en: Looking at the Gravatar site, it appears that there a number of options available.
    In order to shield the rest of the application, the functionality of Gravatar
    will be exposed through a class contained within the Speaker Meet application.
    This functionality will first be defined by an interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 Gravatar 网站上有许多可用的选项。为了保护应用程序的其他部分，Gravatar 的功能将通过 Speaker Meet 应用程序中的一个类来公开。这个功能首先由一个接口定义。
- en: 'The desired interface might look something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的接口可能看起来像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To get started, you must first write some tests. Remember, you should not write
    a line of production code without a failing unit test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你必须首先编写一些测试。记住，你不应该在没有失败的单元测试的情况下编写任何生产代码。
- en: Implementing a test version of the interface
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口的测试版本
- en: 'In order to create an interface named `IGravatarService`, there first must
    be a need within the application. Create a test within a `SpeakerServiceTests`
    `Get` class entitled `ItTakesGravatarService`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个名为 `IGravatarService` 的接口，首先必须在应用程序中有一个需求。在 `SpeakerServiceTests` 的 `Get`
    类中创建一个名为 `ItTakesGravatarService` 的测试：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will cause a compilation error. Create an `IGravatarService` and modify
    the constructor of the `SpeakerService` so that this is a parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致编译错误。创建一个 `IGravatarService` 并修改 `SpeakerService` 的构造函数，使其成为一个参数。
- en: 'Interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接口：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`SpeakerService` method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakerService` 方法：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to get the tests to compile, create a `FakeGravatarService` that can
    be supplied to the `SpeakerService` under test. Remember, you're not testing the
    `FakeGravatarService`, merely that the `SpeakerService` accepts an `IGravatarService`
    instance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试编译，创建一个 `FakeGravatarService`，它可以提供给正在测试的 `SpeakerService`。记住，你并不是在测试 `FakeGravatarService`，而是在测试
    `SpeakerService` 是否接受一个 `IGravatarService` 实例。
- en: Now, ensure that the `FakeGravatarServiceGetGravatar` method is called when
    an individual *Speaker* is requested.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保当请求一个单独的 *Speaker* 时调用 `FakeGravatarServiceGetGravatar` 方法。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Modify the interface to add a `GetGravatar` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 修改接口以添加一个 `GetGravatar` 方法：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And implement this method in the `FakeGravatarService.` This is similar to
    the `GetCalled` check of the `FakeRepository` from [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195),
    *Test Driving C# Applications*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FakeGravatarService` 中实现此方法。这与 [第 7 章](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195)，*测试驱动
    C# 应用程序*中的 `FakeRepository` 的 `GetCalled` 检查类似：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, ensure that the `GetGravatar` function is executed when the `SpeakerService`
    `Get(id)` is called:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保当调用 `SpeakerService` 的 `Get(id)` 时执行 `GetGravatar` 函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The test should now pass. However, the `FakeGravatarService` isn''t providing
    any real value at the moment. The `GetGravatar` method should be executed with
    a provided email address:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在应该通过。然而，`FakeGravatarService` 目前并没有提供任何实际价值。`GetGravatar` 方法应该使用提供的电子邮件地址执行：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will need to modify the `SpeakerFactory` to accept an email address and
    the `Speaker` model class to house an email address property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改 `SpeakerFactory` 以接受电子邮件地址，并将 `Speaker` 模型类修改为包含电子邮件地址属性。
- en: 'Modify the `GetGravatar` method in the `FakeGravatarService` and the `IGravatarService` interface
    to accept a string `emailAddress`. Make sure you set the `CalledWith` property
    when the `GetGravatar` is executed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `FakeGravatarService` 和 `IGravatarService` 接口中的 `GetGravatar` 方法以接受一个字符串
    `emailAddress`。确保在执行 `GetGravatar` 时设置 `CalledWith` 属性：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And ensure the `GetGravatar` method is called with the speaker''s email address:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用演讲者的电子邮件地址调用 `GetGravatar` 方法：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, set the return value of the `GetGravatar` method to a new property
    on the `SpeakerDetail` object `Gravatar`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `GetGravatar` 方法的返回值设置到 `SpeakerDetail` 对象的新属性 `Gravatar` 上：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will need to modify the `FakeGravatarService` and its interface, and the
    `SpeakerService` `Get` method to return a string, and the `SpeakerDetail` class
    to add a `Gravatar` property:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改 `FakeGravatarService` 及其接口，以及 `SpeakerService` 的 `Get` 方法以返回一个字符串，并在 `SpeakerDetail`
    类中添加一个 `Gravatar` 属性：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The return value of the `GetGravatar` method doesn't matter, so long as it is
    a known value. Remember, you're not testing that the `FakeGravatarService` returns
    a valid Gravatar image URL, just that the method returns something and that the
    return value is set to the `Gravatar` property on the `SpeakerDetail` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGravatar` 方法的返回值不重要，只要它是一个已知的值。记住，你并不是在测试 `FakeGravatarService` 是否返回一个有效的
    Gravatar 图像 URL，只是测试该方法返回了某个值，并且返回值被设置到 `SpeakerDetail` 对象的 `Gravatar` 属性上。'
- en: Implementing the production version of the interface
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口的生产版本
- en: So far, an `IGravatarService` interface has been created with one method, `GetGravatar`.
    There are a number of options available to interact with Gravatar. You could choose
    to write your own methods to communicate directly with its public API. The Speaker
    Meet application uses one of the available `NuGet` packages, `GravatarHelper.NetStandard`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经创建了一个包含一个方法 `GetGravatar` 的 `IGravatarService` 接口。有几种选项可以用来与 Gravatar
    交互。你可以选择编写自己的方法来直接与其公共 API 通信。Speaker Meet 应用程序使用可用的 `NuGet` 包之一，`GravatarHelper.NetStandard`。
- en: Install the latest version of `GravatarHelper.NetStandard` through `NuGet` in
    order to follow along.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `NuGet` 安装 `GravatarHelper.NetStandard` 的最新版本以便跟随操作。
- en: 'While reviewing the Gravatar website, it appears that they offer a variety
    of optional parameters. To grow the `IGravatarService` interface and its implementation,
    create a new test class, `GetGravatar`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查 Gravatar 网站时，看起来他们提供了各种可选参数。为了扩展 `IGravatarService` 接口及其实现，创建一个新的测试类 `GetGravatar`：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now test that the `GravatarService` exists:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试 `GravatarService` 是否存在：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Make this test pass by creating a `GravatarService` class in the same location
    as the `SpeakerService`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `SpeakerService` 相同的位置创建一个 `GravatarService` 类来使这个测试通过：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, ensure that the `GravatarService` implements the `IGravatarInterface`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保 `GravatarService` 实现了 `IGravatarInterface`：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the previous set of tests, a `GetGravatar` method has already been defined
    within the interface. Make the test pass by implementing the interface:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的一组测试中，已经在接口中定义了一个 `GetGravatar` 方法。通过实现接口来使测试通过：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Verify that the `GetGravatar` method exists with a new test:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个新的测试来验证 `GetGravatar` 方法是否存在：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Allow this test to pass by returning an empty string:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回一个空字符串来允许这个测试通过：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following tests are classified as *integration tests* as they''re testing
    how the Speaker Meet application interacts with a third-party system. Decorate
    the class as such:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试被分类为 *集成测试*，因为它们正在测试 Speaker Meet 应用程序如何与第三方系统交互。将类装饰为这样的形式：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Many test runners will allow you to conditionally run or exclude these tests
    based on trait categories. Once the integration tests are defined and known to
    run successfully, you may choose to ignore or disable them on change or only run
    them before check-in.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 许多测试运行器允许你根据特征类别有条件地运行或排除这些测试。一旦定义了集成测试并且已知它们可以成功运行，你可以在更改时忽略或禁用它们，或者只在提交前运行它们。
- en: 'Now, test that the Gravatar service returns a known value when an email address
    is supplied. If you have a Gravatar account, feel free to supply your own email
    address and test for your Gravatar URL:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试当提供电子邮件地址时，Gravatar服务返回一个已知值。如果你有一个Gravatar账户，请随意提供你自己的电子邮件地址并测试你的Gravatar
    URL：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, make this test pass by calling the static method supplied by the `GravatarHelper`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过调用`GravatarHelper`提供的静态方法来使这个测试通过：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The test should now pass. You can see how the implementation has been hidden
    from the rest of the application. The interface was designed out of necessity
    through a series of tests in the `SpeakerService`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在应该通过了。你可以看到实现是如何从应用程序的其他部分隐藏起来的。界面是通过在`SpeakerService`中进行一系列测试而出于必要性设计的。
- en: So, why not just call the `GravatarHelper` methods directly from the `SpeakerService`
    and elsewhere? Remember, you shouldn't rely on third-party implementations. If
    the `GravatarHelper` is changed or swapped out for something else entirely, then
    any class that is calling it directly may need to change. By using an interface
    and a façade, the only class that would potentially need to change is the `GravatarService`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么不直接从`SpeakerService`和其他地方调用`GravatarHelper`方法呢？记住，你不应该依赖于第三方实现。如果`GravatarHelper`被更改或被完全替换，那么任何直接调用它的类可能都需要更改。通过使用接口和外观，唯一可能需要更改的类是`GravatarService`。
- en: Future planning
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来的规划
- en: Future planning can be bad. If you're writing code now in anticipation of future
    problems, you could be wasting effort. Don't write code you don't need. This could
    add complexity that can slow development.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的规划可能不好。如果你现在编写代码是为了预期未来的问题，你可能会浪费努力。不要编写你不需要的代码。这可能会增加复杂性，从而减慢开发速度。
- en: Remember the term **YAGNI** (**you ain't gonna need it**) as this applies to
    any code written without an immediate need. The additional `GravatarService` methods
    previously, could be used as an illustration of exactly that. Of the examples
    provided so far, none require the additional methods that were just created. If
    for some reason the implementation of the `GravatarHelper` changes*,* the code
    that has already been written may need to change. If it is not currently being
    used, this is a waste of effort.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住术语**YAGNI**（**你不需要它**），这适用于任何没有立即需求的代码。之前添加的`GravatarService`方法可以用作那个例子的说明。到目前为止提供的示例中，没有一个需要刚刚创建的额外方法。如果由于某种原因`GravatarHelper`的实现发生变化，那么已经编写的代码可能需要更改。如果它目前没有被使用，这将是徒劳的努力。
- en: So, where does future planning start and good abstraction end? Abstract away
    third-party systems. Only expose methods and functionalities that are an immediate
    need. Minimize the pain of change by shielding the rest of the application from
    the details of any third-party system. That includes things such as the .NET Framework
    and ORMs such as Entity Framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，未来的规划从哪里开始，好的抽象在哪里结束？抽象第三方系统。仅暴露立即需要的方法和功能。通过屏蔽应用程序的其他部分不受任何第三方系统细节的影响来最小化更改的痛苦。这包括.NET框架和诸如Entity
    Framework之类的ORM。
- en: Abstracting the data layer
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象数据层
- en: The data layer abstraction has already begun with the implementation of a repository
    pattern. In this section, we will work to create a valid abstraction for connecting
    to an Entity Framework. After we can communicate with the Entity Framework, we
    will then focus on making the repository more generic and able to work with multiple
    data models.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层抽象已经通过实现存储库模式开始了。在本节中，我们将努力创建一个有效的抽象，以便连接到Entity Framework。在我们能够与Entity Framework通信之后，我们将专注于使存储库更加通用，能够与多个数据模型一起工作。
- en: Extending the repository pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展存储库模式
- en: The first step in creating a valid data layer abstraction is to make sure CRUD
    has been handled. **CRUD** (**Create**, **Read**, **Update**, and **Delete**)
    are the basic operations that can be performed on any dataset. The `IRepository`
    does not yet provide access to all of these capabilities so we will begin by extending
    it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效数据层抽象的第一步是确保CRUD（**创建**、**读取**、**更新**和**删除**）已经被处理。**CRUD**是可以在任何数据集上执行的基本操作。`IRepository`尚未提供对所有这些功能的访问，因此我们将从扩展它开始。
- en: 'First create a folder to contain the tests for a `SpeakerRepository`. The folder
    should be named in line with the folders containing the `SpeakerService` tests
    and `SpeakerController` tests. As usual, we start with a failing test. In this
    case, the test is failing to compile:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个文件夹来包含`SpeakerRepository`的测试。这个文件夹应该与包含`SpeakerService`测试和`SpeakerController`测试的文件夹命名一致。像往常一样，我们从失败的测试开始。在这种情况下，测试失败是因为无法编译：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `SpeakerRepository` and the test should pass:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`SpeakerRepository`，测试应该通过：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `SpeakerRepository` needs to inherit from `IRepository` so either transform
    the existence test into a test for type, or create a new test:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakerRepository`需要继承自`IRepository`，因此要么将存在性测试转换为类型测试，要么创建一个新的测试：'
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, make the test pass by inheriting from `IRepository`. We don''t have tests
    for functionality at this point, so leave the repository methods as not implemented:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过继承自`IRepository`使测试通过。目前我们没有针对功能性的测试，所以将仓库方法留为未实现：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Get method
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取方法
- en: 'Now that `SpeakerRepository` properly inherits from `IRepository`, the two
    methods currently defined by `IRepository` need to be implemented. As we did for
    `SpeakerService`, we need to create a new test class specifically for the `Get`
    method. Again, while it might seem to be overkill at this point, creating a file
    per method will help with organization as the test suite grows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`SpeakerRepository`正确地继承自`IRepository`，目前由`IRepository`定义的两个方法需要实现。就像我们对`SpeakerService`所做的那样，我们需要为`Get`方法创建一个新的测试类。再次强调，虽然在这个阶段可能看起来有些过度，但为每个方法创建一个文件将有助于随着测试套件的扩展进行组织：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that the class exists, the first test method that can be written is a simple
    exists method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类已经存在，可以编写的第一个测试方法是简单的存在方法：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Initially this test will fail because the stub implementation provided by Visual
    Studio just throws a `NotImplementedException`. To fix this, we have to return
    something; so what should be returned? There is no test to explain what result
    is expected so we must go with something that will compile but is almost certainly
    incorrect. In this situation the correct, incorrect value to return is probably
    `null`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这个测试将失败，因为Visual Studio提供的占位符实现只是抛出`NotImplementedException`。为了修复这个问题，我们必须返回一些东西；那么应该返回什么呢？没有测试来解释期望的结果，所以我们必须选择一个可以编译但几乎肯定是不正确的值。在这种情况下，正确的、不正确的返回值可能是`null`：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The GetAll method
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有方法
- en: 'The test now passes. Let us pause here and get the same amount of testing around
    the `GetAll` method enforced by the interface. As previously, create a new class
    for `GetAll`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了。让我们在这里暂停一下，并围绕接口强制执行的`GetAll`方法进行相同数量的测试。像之前一样，为`GetAll`创建一个新的类：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create an exists method which will just ensure the method doesn''t throw when
    called:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个存在方法，它将确保当被调用时该方法不会抛出异常：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Create method
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法
- en: It will probably be easier to test the repository pattern if all the repository
    methods are assumed to exist. Unfortunately, a repository presents a chicken and
    egg scenario. How can we test `Get` or `GetAll` without some way of creating entries
    in the repository? At the same time, how can we test `Create` or `Delete` without
    some way of retrieving entries from the repository?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果假设所有仓库方法都存在，测试仓库模式可能会更容易。不幸的是，仓库呈现了一个鸡生蛋的问题。如果没有在仓库中创建条目的方法，我们如何测试`Get`或`GetAll`？同时，如果没有从仓库检索条目的方法，我们如何测试`Create`或`Delete`？
- en: 'Next create a new class for `Create`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个新的类用于`Create`：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As before, write a method to check for existence. In this test, we need to
    be sure to test against the repository, not the `Create` class implementation.
    This will force us to add to the interface:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写一个检查存在性的方法。在这个测试中，我们需要确保测试的是仓库，而不是`Create`类的实现。这将迫使我们添加到接口中：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You may have noticed, in this test, that we receive a result from the `Create`
    method. This may not be obvious since we received values from the `Get` and `GetAll`
    methods, but we are choosing to break **CQRS** (**Command Query Responsibility
    Separation**) in favor of a more RESTful approach. In **REST** (**Representational
    State Transfer**), because it must remain stateless and cannot provide information
    about an action that has already finished, a service will generally return either
    the object created or a way to retrieve that object in the future.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这个测试中，我们从`Create`方法中得到了一个结果。这可能不是很明显，因为我们从`Get`和`GetAll`方法中得到了值，但我们选择打破**CQRS**（**命令查询责任分离**）以支持更RESTful的方法。在**REST**（**表征状态转移**）中，因为它必须保持无状态并且不能提供关于已经完成的操作的信息，所以服务通常返回创建的对象或将来检索该对象的方式。
- en: In this case, you might think that we are now providing a leaky abstraction
    of the web. It could be interpreted that way. I prefer to look at this choice
    as opening options instead of limiting them. It will be easier to hide a CQRS
    implementation behind a RESTful interface than it would be to work things the
    other way around.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会认为我们现在提供了一个有漏洞的抽象的Web。它可以这样解释。我更喜欢将这个选择视为打开选项而不是限制它们。在隐藏CQRS实现背后比反过来工作要容易得多。
- en: 'Now, to pass the currently failing test, a method definition will need to be
    added to the `IRepository` interface, a method implementation will need to be
    added to the `SpeakerRepository`, and the `SpeakerRepository` implementation will
    need to be amended to not throw:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了通过当前失败的测试，需要在`IRepository`接口中添加一个方法定义，在`SpeakerRepository`中添加一个方法实现，并且需要修改`SpeakerRepository`的实现以避免抛出异常：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Speaker Save` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Speaker Save`方法：'
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A stub implementation will also have to be added to the `FakeRepository` that
    was defined in [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195), *Test
    Driving C# Applications*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在定义在[第7章](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195)，*测试驱动C#应用程序*中的`FakeRepository`中添加一个存根实现。
- en: The Delete method
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除方法
- en: 'Next, we will add the `Delete` method. Just as before, create a new test class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`Delete`方法。就像之前一样，创建一个新的测试类：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Just like for the `Create` method, we need to treat the `SpeakerRepository`
    as an `IRepository`. Create a `Delete` exists method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于`Create`方法一样，我们需要将`SpeakerRepository`视为`IRepository`。创建一个`Delete`存在的方法：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implementing this method will be slightly easier as it is a void method and
    we are not expecting a result. There are some decisions that will have to be made
    later regarding how the method should behave when it is passed to a speaker that
    does not exist. For now, we can just assume that nothing happens and the method
    is successful.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个方法将会稍微容易一些，因为它是一个无返回值的方法，我们并不期望得到结果。关于当方法传递给一个不存在的演讲者时应该如何表现，我们将在稍后做出一些决定。现在，我们可以假设什么也不发生，方法执行成功。
- en: 'As before, modify the `IRepository` to contain a `Delete` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，修改`IRepository`以包含一个`Delete`方法：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And now create the stub method in the `SpeakerRepository` and the `FakeRepository`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`SpeakerRepository`和`FakeRepository`中创建一个存根方法：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Update method
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新方法
- en: There is one last method required for a valid repository pattern and any useful
    system. We need the ability to update the models we are working with. As with
    the last two methods, this one does not yet exist in the repository, so let's
    add it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个有效的仓储模式和任何有用的系统来说，还需要一个最后的方法。我们需要能够更新我们正在工作的模型。与最后两个方法一样，这个方法在仓储中还不存在，所以让我们添加它。
- en: 'As before, begin by creating a test class for it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，首先为它创建一个测试类：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Just like the others, create an `ItExists` test referencing the `IRepository`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他方法一样，创建一个引用`IRepository`的`ItExists`测试：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As before, we are just stubbing functionality here so we don't yet have an actual
    speaker to update. This test, and the others, will almost certainly have to change
    as we begin testing for actual functionality. For now, they will suffice to ensure
    the interface and class have the appropriate methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们在这里只是存根功能，所以我们还没有实际的演讲者去更新。这个测试，以及其他测试，几乎肯定会在我们开始测试实际功能时发生变化。现在，它们足以确保接口和类有适当的方法。
- en: 'As before, add the method to the interface and then to the `SpeakerRepository`
    and the `FakeRepository`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，将方法添加到接口中，然后添加到`SpeakerRepository`和`FakeRepository`中：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Speaker Update` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Speaker Update`方法：'
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Ensuring functionality
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保功能
- en: Now that all the methods have been defined, we can begin writing tests for functionality.
    We will begin with `Create` and work our way down to `Delete`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的方法都已经定义好了，我们可以开始编写功能测试了。我们将从`Create`开始，然后逐步进行到`Delete`。
- en: Creating a speaker
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个演讲者
- en: The chicken and egg scenario mentioned earlier has us in a predicament. We can't
    read a speaker from the repository if no speakers have been created. We also can't
    verify that a speaker has in fact been created unless we can retrieve a speaker
    from the repository.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的“鸡生蛋”场景让我们陷入了困境。如果没有创建演讲者，我们就无法从存储库中读取演讲者。除非我们能从存储库中检索到一个演讲者，否则我们也无法验证一个演讲者实际上已经被创建。
- en: 'One way to solve this problem is by using a special kind of test double that
    exposes the internal functionality of a class for the purposes of asserting on
    that information. For `Create`, we will use this approach. In the `Create.cs`
    file, let''s add a test that assumes the testable class already exists:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用一种特殊的测试双胞胎，它暴露了类的内部功能，以便对相关信息进行断言。对于`Create`，我们将使用这种方法。在`Create.cs`文件中，让我们添加一个假设可测试类已经存在的测试：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To get past the compilation error, the testable class must be created. Create
    this class in the same file, for now, to make working with it more efficient:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决编译错误，必须创建可测试的类。现在，为了更有效地与之一起工作，在同一文件中创建这个类：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now the class is created and the initial compilation error is resolved, but
    a new error has risen:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类已经创建，初始的编译错误已经解决，但一个新的错误出现了：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This error is slightly more difficult to resolve. In reality, we want a collection
    of speakers to exist in the real repository. However, we have had no reason to
    expose that collection. No collection has actually been created as a result. Now,
    in this test we are asking whether a collection exists. The test requires that
    a collection exists for the `TestableSpeakerRepository` but we know we need one
    for the real `SpeakerRepository`. Let''s play devil''s advocate and actually do
    the thing we know is not quite right:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误稍微有点难以解决。实际上，我们希望在真实存储库中存在一个演讲者集合。然而，我们没有理由暴露这个集合。实际上并没有创建任何集合。现在，在这个测试中，我们正在询问是否存在一个集合。测试要求`TestableSpeakerRepository`存在一个集合，但我们知道我们还需要一个用于真实的`SpeakerRepository`。让我们扮演魔鬼的代言人，实际上做我们知道并不完全正确的事情：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This change doesn''t quite make the test pass; when writing the test we hastily
    accessed the `Count` property on Speakers. The `Count` property is only on a list,
    but to limit the exposure of an interface until we actually can require it with
    tests, we should really be using an `IQueryable`. We can quickly update the test
    to reflect this choice:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改并没有完全使测试通过；在编写测试时，我们匆忙访问了`Count`属性。`Count`属性只在列表上，但为了限制接口的暴露，直到我们实际上可以用测试来要求它，我们实际上应该使用一个`IQueryable`。我们可以快速更新测试以反映这个选择：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, execute the tests and it finally fails with an actual message. The solution
    to this failure is to add an entry to the speakers collection when `Create` is
    called. The problem is that Speakers is in a different class from `Create`. So,
    we must have a collection in `SpeakerRepository` as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行测试，它最终以实际消息失败。解决这个失败的方法是在调用`Create`时向演讲者集合添加一个条目。问题是`Speakers`类与`Create`类不同。因此，我们必须在`SpeakerRepository`中也有一个集合：
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What's important to note is the scope and type of `_speakers`. It is an `IList`,
    because we need to add an item to it; an `IQueryable` will not do. It is also
    protected; `_speakers` must be hidden from the outside world but also must be
    accessible from the testable class. The scope operator that gives us this functionality
    is protected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是`_speakers`的范围和类型。它是一个`IList`，因为我们需要向其中添加一个项目；一个`IQueryable`是不够的。它也是受保护的；`_speakers`必须对外部世界隐藏，但同时也必须可以从可测试的类中访问。提供这种功能的范围操作符是受保护的。
- en: 'We must also make changes in the testable class in order to make this test
    pass:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在可测试的类中进行更改，以便使这个测试通过：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Continuing with `Create`, we now need to verify that, when a new speaker is
    created, it  receives a unique ID:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`Create`，我们现在需要验证，当创建一个新的演讲者时，它将收到一个唯一的ID：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To make this test pass, we must come up with some kind of ID generation system.
    There are many options, but one of the simplest is to create a private field and
    increment the value each time `Create` is called:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们必须想出某种ID生成系统。有很多选择，但其中最简单的一个是在每次调用`Create`时创建一个私有字段并递增其值：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With that test passing, we can now turn our attention to a leak in the abstraction.
    We are simply placing the passed-in object into the dataset. This could cause
    an issue in an application that needs to be fixed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那个测试通过后，我们现在可以将注意力转向抽象中的漏洞。我们只是简单地将传入的对象放入数据集中。这可能会在需要修复的应用程序中引起问题。
- en: 'The repository should isolate its object from the rest of the application by
    passing and storing clones, instead of directly accessing and providing objects:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库应该通过传递和存储克隆对象来将其对象与应用程序的其他部分隔离，而不是直接访问和提供对象：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make this test pass, we will need some cloning mechanism. To make this test
    pass as soon as possible, we can simply use a new object and object initializer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们需要一些克隆机制。为了尽快使这个测试通过，我们可以简单地使用一个新的对象和对象初始化器：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we must handle the other direction for reference passing. The value stored
    in the speakers collection should not directly be handed back to us from the `Create`
    method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须处理引用传递的另一个方向。存储在演讲者集合中的值不应该直接从 `Create` 方法返回给我们：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice the extra auditing step. Sometimes, you will need to take an action and
    then assert on a deeply nested value or a distant value. In those cases, you can
    keep a clean single-step action by adding an audit step.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的审计步骤。有时，你可能需要采取一个行动，然后断言一个深层嵌套的值或一个遥远的值。在这种情况下，你可以通过添加审计步骤来保持一个干净的单一步骤行动。
- en: 'To make this test pass, we must take a similar action to what we are already
    doing at the top of the `Create` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们必须采取与我们在 `Create` 方法顶部已经做过的类似行动：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That completes the functionality required for the `Create` method. Now we should
    really do some long overdue refactoring. Firstly, let's focus on the tests and
    reduce the duplicated calls to create a new repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `Create` 方法所需的功能。现在我们真的应该做一些长期未完成的重构。首先，让我们专注于测试，并减少创建新仓库的重复调用。
- en: 'Create a constructor and a private `repo` field:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个构造函数和一个私有的 `repo` 字段：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Then replace all repository references in the tests with `_repo`. After reducing
    the number of repositories being created in the tests, the tests look pretty good.
    Now we can focus on the `SpeakerRepository` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在测试中将所有仓库引用替换为 `_repo`。在减少测试中创建的仓库数量后，测试看起来相当不错。现在我们可以专注于 `SpeakerRepository`
    类。
- en: One of the immediate standouts in the `SpeakerRepository` is the code we are
    using to clone a speaker. The same code has essentially been typed twice in the
    same method. Let's abstract this to a private function inside the repository for
    now. We may end up making a more sophisticated solution later on, but for now
    that should be good enough.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpeakerRepository` 中，一个立即引人注目的是我们用来克隆演讲者的代码。相同的代码在同一个方法中基本上被输入了两次。让我们现在将其抽象为仓库内部的私有函数。我们可能最终会做出更复杂的解决方案，但就目前而言，这应该足够了。
- en: 'At the bottom of the class, after all the public methods, we can create a `CloneSpeaker`
    method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的底部，在所有公共方法之后，我们可以创建一个 `CloneSpeaker` 方法：
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then we use the `CloneSpeaker` method in `Create`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `Create` 中使用 `CloneSpeaker` 方法：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Getting a single speaker
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取单个演讲者
- en: With the existence of `Create`, we can now very easily assert on the retrieval
    of an existing or non-existing speaker. According to Uncle Bob's Transformation
    Priority Premise, it is easier and simpler to test a singular item rather than
    a plural item, so while it doesn't completely fulfil the intent of the premise,
    we will test the retrieval of a singular speaker next.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `Create` 的存在，我们现在可以非常容易地断言检索现有或不存在演讲者。根据鲍勃叔叔的转换优先级前提，测试单个项目比测试复数项目更容易、更简单，所以虽然这并不完全符合前提的意图，但我们将测试检索单个演讲者。
- en: We already have an exists test, so what will the next test be? The simplest
    test would be the retrieval of a single speaker, but if we are trying to avoid
    the gold standard, the most appropriate test would be examining what happens when
    a speaker does not exist.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了存在性测试，那么下一个测试会是什么？最简单的测试是检索单个演讲者，但如果我们试图避免黄金标准，最合适的测试将是检查演讲者不存在时会发生什么。
- en: For non-existing speakers, we have a few immediately apparent options. We could
    throw an error stating that the requested speaker is not in the system. Another
    option would be returning a `null` object. And the last would be simply returning
    `null`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不存在的演讲者，我们有一些立即显而易见的选择。我们可以抛出一个错误，声明请求的演讲者不在系统中。另一个选项是返回一个 `null` 对象。最后一个选项是简单地返回
    `null`。
- en: 'Throwing an error is probably the most straightforward, so let''s examine this
    option first:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出错误可能是最直接的选择，所以让我们首先考察这个选项：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To make this test pass, first we must make it compile. The `SpeakerNotFoundException`
    in this case is not the same as the one we are using in the `SpeakerService`.
    So, it will need to be created:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，首先我们必须让它编译。在这个情况下，`SpeakerNotFoundException`与我们正在使用的`SpeakerService`中的不同。因此，需要创建它：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that the test is correctly compiling and failing, we can add the appropriate
    code to the repository to make the test pass:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经正确编译并失败，我们可以向仓库添加适当的代码以使测试通过：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another guideline for tests, to help you know you are on the right path and
    not digging yourself into a hole, is again from Uncle Bob, *A*s the tests get
    more specific the code gets more generic. If we look at the code we just wrote,
    it seems more specific then generic. Let''s refactor it to maintain a trend towards
    generics:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试的指导原则，帮助你了解你是否走在正确的道路上，而不是挖坑，再次来自Uncle Bob，*A*随着测试变得更加具体，代码变得更加通用。如果我们看看我们刚刚编写的代码，它似乎更具体而不是更通用。让我们重构它，以保持向通用性的趋势：
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The change here is subtle, but important. Thinking about the operation of this
    method in production, the default case really is to throw. There is only a small
    subset in the set containing all the integers that we actually have a speaker
    for, so the generic case is to throw. The specific case is actually to find a
    speaker.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化很微妙，但很重要。考虑这个方法在生产环境中的操作，默认情况确实是抛出异常。在包含所有整数的集合中，我们实际上有一个演讲者的情况只是一个很小的子集，所以通用情况是抛出异常。具体情况实际上是找到一个演讲者。
- en: One issue with the method of throwing when a speaker is not found is that it
    brings a possibly unexpected and abrupt end to the application flow. The entire
    logic path the application took to get to this method is now destroyed and the
    exception must be handled. Even when we handle the exception, C# uses extra CPU
    cycles on the first-chance exception error handling process. Sometimes throwing
    is definitely the right decision; however, exceptions should be reserved for truly
    exceptional events. As discussed earlier, it is far more likely that a `Get` could
    be called with an invalid ID than with a valid one. So, in this case it is not
    necessarily a properly exceptional event for an invalid speaker to be requested.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到演讲者时抛出错误的问题在于，它给应用程序流程带来了可能意外和突然的结束。应用程序到达这个方法的整个逻辑路径现在被破坏，并且必须处理异常。即使我们处理了异常，C#在第一次异常错误处理过程中也会使用额外的CPU周期。有时抛出确实是正确的决定；然而，异常应该保留给真正异常的事件。如前所述，`Get`被一个无效的ID调用比被一个有效的ID调用的可能性要大得多。所以，在这种情况下，请求一个无效的演讲者并不一定是一个适当的异常事件。
- en: 'Let''s explore the alternative of a NullObject. First, we need to revert our
    code to where it was when we started working on the `Get` method. We are using
    source control so we can very simply revert our code. If you are not using source
    control, I would suggest you start. Here is the state the `Get` method should
    be in before we begin again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索空对象模式的替代方案。首先，我们需要将我们的代码回滚到我们开始工作在`Get`方法时的状态。我们使用源代码控制，因此我们可以非常简单地回滚我们的代码。如果你没有使用源代码控制，我建议你开始使用。以下是我们在再次开始之前`Get`方法应该处于的状态：
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We can just delete the test that asserts an exception was thrown.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接删除断言抛出异常的测试。
- en: The NullObject pattern is a simple pattern with a slightly more complicated
    implementation. Basically, you create an object that inherits from the class needed,
    but it does absolutely nothing in just the right way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是一个简单的模式，但其实现稍微复杂一些。基本上，你创建一个从所需类继承的对象，但以完全正确的方式什么都不做。
- en: 'Thinking about this from our eventual website usage, a speaker null object
    would possibly have a name such as "Mr. Unknown" and would speak at conferences
    like "Mid-Nowhere Tech Fest." We could create a funny profile picture and fill
    out harmless user information that would let the user know they had requested
    a non-existent speaker. All of that information could be determined and filled
    out later. The important part of a null object is that it represents a fully capable
    object, but does absolutely nothing in the right way to not cause harm within
    your application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们最终网站使用的角度来看，一个空对象演讲者可能有一个像“Mr. Unknown”这样的名字，并在像“Mid-Nowhere Tech Fest”这样的会议上发表演讲。我们可以创建一个有趣的个人资料图片，并填写无害的用户信息，让用户知道他们请求了一个不存在的演讲者。所有这些信息都可以在之后确定并填写。空对象的重要部分是它代表一个完全有能力的对象，但以正确的方式什么都不做，不会对你的应用程序造成伤害：
- en: '[PRE65]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To fix the compilation error, create the `NullSpeaker` class and have it inherit
    from `Speaker`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Making the test pass is fairly simple. In this case we don''t have to worry
    about existing tests that could break from returning the null object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Superficially, the null object pattern seems like a pretty good solution. In
    reality, this is not always the case. It is very difficult to properly do nothing
    within a system. In the case of getting a speaker, the null object pattern would
    probably work just fine. We have one more option to explore though.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option is to simply return `null`. Well, simply may not be the best
    word choice. `Null` can cause a lot of trouble within a system. It will wreak
    havoc if you do not handle the null that was received and a distant part of the
    system tries to use the null as if it weren''t null. Earlier, when we were designing
    the service, we decided to expect null as a possible result from calling the repository;
    thus, in this case the range of effects should be short and null should not cause
    significant negative side-effects within the system. Let''s revert the code one
    more time and explore simply returning `null`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There is nothing to do in the `SpeakerRepository` because we are already returning
    `null`. Normally, this test would not be written here. We would wait to write
    this test until we had a test that was returning a valid speaker. The reason we
    want to delay this test is because we can't fail it. You will not see this test
    go red and that is generally a problem. Either the test is not needed because
    it is extraneous and covered elsewhere or the test is flawed because it can't
    fail.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The test we should write before this one is a test that should retrieve a valid
    value. For the moment, ignore this test and we will come back and watch it fail
    after the next test:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So, if we are about to test the retrieval of an existing speaker, which we called
    the gold standard before, why did we avoid it in the first place? The reason we
    are going to test the gold standard first now is solely because of implementation
    choices. If we were going to use either as an exception or a null object, we would
    have done those first. The problem right now is that our code is already returning
    `null` so testing for null would not have done us any good.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for an existing speaker, a speaker must first exist. In the arrange
    section of our test, we will need to make sure we create a speaker:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first step is to simply assert that the result is not null. This of course
    fails because all we are doing right now is returning `null`. Let''s fix that:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Even though we are now forced to go down the gold-standard path, we can still
    avoid it as much as possible. One way to do this is by playing devil's advocate,
    which we can do by returning a speaker, just not the right speaker.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We must now modify the test to make sure the values we care about are correct:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now to modify the code. We could continue to play devil''s advocate, but at
    this point that would only cause more unnecessary work in the tests:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来修改代码。我们可以继续扮演魔鬼的代言人，但在这个阶段，那只会导致测试中更多不必要的劳动：
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At this point, we are left with a conundrum. We can't call `Single` or `First`
    because they will throw an exception if the requested speaker is not found. We
    do have a system rule to return `null` when the speaker is not found though. The
    system is behaving correctly by default. We could simply put our test back into
    play and accept that the null test just won't be properly verifiable. Another
    option is to purposely write code to return a new speaker in the event that the
    speakers collection is missing the requested speaker. Taking the second option
    would allow us to see the null test fail, but we would just be removing it to
    make the test pass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们面临着一个难题。我们不能调用`Single`或`First`，因为如果找不到请求的演讲者，它们会抛出异常。尽管如此，我们确实有一个系统规则，当找不到演讲者时返回`null`。系统默认行为是正确的。我们可以简单地重新启用我们的测试，并接受空测试无法正确验证。另一个选择是有意编写代码，在演讲者集合缺少请求的演讲者时返回一个新的演讲者。选择第二个选项将允许我们看到空测试失败，但我们只是移除它以使测试通过。
- en: 'In this case, the second option is probably the most appropriate. Many of you
    will probably think that there is no reason to add the code that forces a non-null;
    many others will probably think that the test is not needed as it doesn''t seem
    to provide value. Both groups are correct and incorrect at the same time. They
    are correct: putting in code just to remove it two seconds later is stupid. Adding
    a test that can''t really fail is stupid too.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，第二个选项可能是最合适的。你们中很多人可能认为没有必要添加强制非空的代码；还有很多人可能认为不需要测试，因为它似乎没有提供价值。这两组人同时是正确的和错误的。他们是正确的：只是为了在两秒后删除而放入代码是愚蠢的。添加一个无法真正失败的测试也是愚蠢的。
- en: However, we need the test because at some point in the future a requirement
    could come in that would cause a null to be accidentally impossible and we need
    a record of the business requirement stating that the value should be null. We
    also need to see every test fail. In this particular case, we could probably get
    away with skipping that part, but if we get into a habit of skipping test failures
    it will quickly bite you.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要这个测试，因为在未来的某个时刻，可能会出现一个要求，导致空值意外地变得不可能，我们需要记录业务需求，说明该值应该是空的。我们还需要看到每个测试都失败。在这个特定的情况下，我们可能可以避开这部分，但如果我们养成了跳过测试失败的习惯，很快就会让你付出代价。
- en: So, let's make the appropriate change to force the null test to fail and then
    fix our "error:"
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们做出适当的更改，强制空测试失败，然后修复我们的“错误：”
- en: '[PRE74]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We can now remove the skip attribute on the null test and then come back here
    and remove the null coalescing operator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以移除空测试上的跳过属性，然后回到这里移除空合并运算符。
- en: 'We have one more test needed for `Get`. We must ensure the pointer for the
    returned speaker is not the same as the speaker in the repository:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个针对`Get`的测试。我们必须确保返回的演讲者指针与存储库中的演讲者不同：
- en: '[PRE75]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This test is significantly harder to follow, but necessary. We first have to
    create a speaker. Then we retrieve the speaker we created, update the retrieved
    speaker's name, and  retrieve the speaker again. Finally, we verify that the modified
    speaker is not the same as the retrieved speaker. They should not be the same
    because we have not saved the data, so no updates should have occurred.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很难理解，但却是必要的。我们首先必须创建一个演讲者。然后检索我们创建的演讲者，更新检索到的演讲者的名字，然后再检索演讲者。最后，我们验证修改后的演讲者与检索到的演讲者不同。它们不应该相同，因为我们没有保存数据，所以不应该发生任何更新。
- en: 'The fix for this issue has already been created and just needs to be implemented:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的修复方案已经创建好了，只需要实施：
- en: '[PRE76]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Lastly, we should refactor. Follow the same steps as you did for create and
    extract the repository creation into the constructor. The simplicity of this test
    class means it doesn't require any further refactoring.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该重构。遵循你为创建和提取存储库创建所采取的相同步骤。这个测试类的简单性意味着它不需要任何进一步的重构。
- en: Getting multiple speakers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取多个演讲者
- en: Getting many speakers is much easier than getting a single speaker. We are not
    going to have to worry about not finding speakers. We are not going to have to
    handle any error conditions. All we have to test for is retrieving the correct
    number of speakers, and ensuring data safety the same as we have done for the
    other methods so far.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 获取多个说话者比获取单个说话者容易得多。我们不必担心找不到说话者。我们也不必处理任何错误条件。我们只需测试的是检索正确的说话者数量，并确保数据安全性与我们迄今为止对其他方法所做的一样。
- en: 'Let''s start with retrieving all the speakers when there are no speakers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在没有说话者时检索所有说话者开始：
- en: '[PRE77]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is an easy fix in the repository:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这在仓库中是一个简单的修复：
- en: '[PRE78]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Remember, we are playing devil's advocate; this is the correct response for
    its purpose.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们是在扮演魔鬼的辩护者；这是其目的的正确回应。
- en: 'Now, we need to assert the type and size of the method''s response:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要断言方法响应的类型和大小：
- en: '[PRE79]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: I know we have already mentioned the single assert rule and how it doesn't mean
    what it sounds like it means. This test is still following the rule because we
    are asserting that `GetAll` returns a non-null empty collection of speakers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我们已经提到了单条断言规则以及它并不像听起来那样意味着什么。这个测试仍然遵循规则，因为我们正在断言`GetAll`返回一个非空空集合的说话者。
- en: 'Next, we test for a single speaker present in the repository:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试仓库中存在单个说话者的情况：
- en: '[PRE80]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Again, making the appropriate adjustment in the repository is fairly simple:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在仓库中进行适当的调整相当简单：
- en: '[PRE81]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Next, we want to close off this line of testing by making sure that the speaker
    returned is the speaker we created. We expect this to pass right way because we
    already know that is the case. This assertion is important to ensure the future
    integrity of the repository.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要通过确保返回的说话者是我们创建的说话者来结束这一系列的测试。我们预计这会立即通过，因为我们已经知道这是正确的。这个断言对于确保仓库未来的完整性非常重要。
- en: '[PRE82]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Notice the change to the action. Executing a count and retrieving the first
    element in the collection both cause an enumeration. Enumerations equal CPU cycles.
    To reduce test time and production execution time, we want to reduce the number
    of enumerations. Converting the `IQueryable` to a list will enforce a single enumeration.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意动作的变化。执行计数和检索集合中的第一个元素都会导致枚举。枚举等于CPU周期。为了减少测试时间和生产执行时间，我们想要减少枚举的数量。将`IQueryable`转换为列表将强制进行单个枚举。
- en: 'Let''s do one final test to ensure the proper return values and check that
    multiple speakers come back correctly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行最后一次测试，以确保返回值正确，并检查多个说话者是否能够正确返回：
- en: '[PRE83]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This test is just a sanity check and passes right away. Our next test is going
    to check data integrity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试只是一个理智的检查，会立即通过。我们的下一个测试将检查数据完整性：
- en: '[PRE84]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The update in the repository is similar to what we have done for the other
    methods with one exception. We are operating on an entire collection, instead
    of just a single item:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的更新与我们为其他方法所做的是相似的，只有一个例外。我们正在操作整个集合，而不仅仅是单个项目：
- en: '[PRE85]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Some of you may have seen this syntax before. What we have done is to pass
    the function pointer of the `CloneSpeaker` method in as the Lambda expression
    required by the `Select` method in linq. The preceding line is exactly the same,
    functionally, as the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一些同学可能之前见过这种语法。我们所做的是将`CloneSpeaker`方法的函数指针作为linq中`Select`方法所需的Lambda表达式传递。前面的行在功能上与下面的行完全相同：
- en: '[PRE86]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Time to clean up. We have the same clean-up steps as before. The only real refactoring
    needed is extracting the repository creation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候清理了。我们与之前相同的清理步骤。唯一真正需要重构的是提取仓库创建。
- en: Updating a speaker
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新说话者
- en: 'We can now create and retrieve speakers. We have also ensured that we cannot
    update them by accident. So, let''s make sure we can update them on purpose:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建和检索说话者。我们还确保了不能意外地更新它们。所以，让我们确保我们可以有意地更新它们：
- en: '[PRE87]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Playing devil''s advocate again, this is a simple update to the repository:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 再次扮演魔鬼的辩护者，这是对仓库的一个简单更新：
- en: '[PRE88]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is clearly the wrong solution; let''s write another, more specific test:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的解决方案；让我们写另一个更具体的测试：
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Making this test pass is a little tricky, but not too bad:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过有点棘手，但不算太坏：
- en: '[PRE90]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'However, making this change causes the exists test to fail. Looking at that
    test, it is failing for a good reason and should not really pass given our current
    understanding of how `Update` is supposed to work. Let''s make a small but significant
    update to that test:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个更改导致存在测试失败。查看那个测试，它失败是有好理由的，并且根据我们对`Update`当前理解的工作方式，实际上不应该通过。让我们对那个测试进行一个小但重要的更新：
- en: '[PRE91]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next up on our testing timeline, is handling the error that was highlighted
    by the failure of the exists test. If someone asks to update a speaker that doesn''t
    exist, the repository blows up. This could be the required behavior, but it should
    blow up with an informative exception, not an index out of bounds exception:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试时间表上接下来的是处理由存在测试失败所突出显示的错误。如果有人请求更新一个不存在的演讲者，存储库会崩溃。这可能是一种所需的行为，但它应该通过一个信息性异常崩溃，而不是索引越界异常：
- en: '[PRE92]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'A `SpeakerNotFoundException` already exists within the system, but this comes
    from a different layer so we need to create a new exception:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中已经存在一个`SpeakerNotFoundException`，但它来自不同的层，因此我们需要创建一个新的异常：
- en: '[PRE93]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As an exercise, see if you can cover this exception with tests. Being able to
    work backwards and write tests after the fact, as we will discuss in upcoming
    chapters, is a valuable skill to have.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，看看你是否可以用测试来覆盖这个异常。能够在后续章节中讨论的实际情况之后反向工作并编写测试，是一项非常有价值的技能。
- en: 'Now, let''s continue and make this test pass:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并使这个测试通过：
- en: '[PRE94]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As with the other tests, we must now ensure data integrity:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他测试一样，我们现在必须确保数据完整性：
- en: '[PRE95]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We are bordering on test complexity that is too high. If these tests get much
    more complex, we will want to consider rethinking our approach. This test confirms
    what we thought: the returned speaker is not protected against change. Let''s
    fix that:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正接近测试复杂度过高的边缘。如果这些测试变得更加复杂，我们将想要考虑重新思考我们的方法。这个测试证实了我们的想法：返回的演讲者没有受到更改的保护。让我们修复这个问题：
- en: '[PRE96]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'A fairly simple solution: just wrap the return with a `CloneSpeaker` call.
    Do you see another potential data integrity issue? What are we doing to protect
    against further changes to the speaker that was passed? Let''s write a test to
    ensure that changes after the fact to the speaker that was passed in don''t affect
    the repository:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当简单的解决方案：只需将返回值用`CloneSpeaker`调用包裹起来。你是否看到了另一个潜在的数据完整性问题？我们正在做些什么来保护传递给演讲者的演讲者免受进一步更改？让我们编写一个测试来确保对传递给演讲者的演讲者所做的任何事后更改都不会影响存储库：
- en: '[PRE97]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This test looks almost identical to the previous test. The only significant
    change is the action. Instead of changing the value on the `updatedSpeaker`, we
    are now changing the value on the original speaker. To make this test pass, the
    change to the repository is similar to the previous fix:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试看起来几乎与上一个测试相同。唯一的重大变化是操作。我们不是在`updatedSpeaker`上更改值，而是在原始演讲者上更改值。为了使这个测试通过，对存储库的更改与之前的修复类似：
- en: '[PRE98]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: All that is left to refactor and clean up are the tests and repository.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要重构和清理的只有测试和存储库。
- en: Deleting a speaker
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除演讲者
- en: We are finally at the last method in this repository. For Speaker Meet, we don't
    really want to delete the speakers; we might flag a speaker as deleted, but we
    don't really want to remove them from the dataset. So, our `Delete` method will
    be more like an update.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了这个存储库中的最后一个方法。对于演讲者会议，我们并不真的想删除演讲者；我们可能会将演讲者标记为已删除，但我们并不真的想从数据集中删除他们。因此，我们的`Delete`方法将更像是一个更新。
- en: We don't have any strange behavior or constraints for `Delete`, so we should
    start with the failure case. What should happen if we ask to delete a user that
    doesn't exist? Should we throw an exception? In this case, we can actually just
    assume that the job is done. If there is no speaker with the given ID then the
    deletion of that speaker could be considered a success.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Delete`，我们没有任何奇怪的行为或约束，因此我们应该从失败情况开始。如果我们请求删除一个不存在的用户，会发生什么？我们应该抛出异常吗？在这种情况下，我们实际上可以假设工作已经完成。如果没有具有给定ID的演讲者，那么该演讲者的删除可以被认为是成功的。
- en: 'Well, now that we have considered the failure case, we see that it does have
    special behavior that would cause the failure case to simply pass straight away.
    Let''s take a look at the success case and see if it would cause a failing test:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们已经考虑了失败情况，我们看到它确实有特殊的行为，这会导致失败情况直接通过。让我们看看成功情况，看看它是否会导致测试失败：
- en: '[PRE99]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Making this test pass should be fairly easy: we can just call into the local
    update method after changing the `isDeleted` flag to `true`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过应该相当简单：我们只需在将`isDeleted`标志更改为`true`后调用本地更新方法：
- en: '[PRE100]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Don't forget to fix any other tests that fail as a result of adding this code,
    after making sure the failure is for a valid reason. If tests fail while we are
    writing more tests we need to check the requirements and make sure they are not
    in disagreement with each other. We never want to break existing requirements
    unintentionally.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记修复由于添加此代码而失败的任何其他测试，在确认失败是有效原因之后。如果我们编写更多测试时测试失败，我们需要检查需求并确保它们之间没有冲突。我们绝不想无意中破坏现有的需求。
- en: 'We now have to deal with what happens if the speaker didn''t exist in the context.
    As decided earlier, we are okay with just ignoring this request as a failure to
    delete a non-existing speaker results in the same situation as successfully deleting
    an existing speaker:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须处理如果演讲者不存在于上下文中的情况。如之前决定的那样，我们对此请求的失败可以忽略，因为删除一个不存在的演讲者会导致与成功删除一个现有演讲者相同的情况：
- en: '[PRE101]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To pass this one we have to do something that is normally not recommended or
    preferred. We have to swallow an exception. Before taking a step like this and
    ignoring an exception, make sure you only ignore a specific exception and make
    sure you have thought it through thoroughly:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过这个测试，我们必须做一些通常不推荐或不首选的事情。我们必须吞下异常。在采取这样的步骤并忽略异常之前，确保你只忽略特定的异常，并确保你已经彻底思考过：
- en: '[PRE102]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'And for the last test for this method, we must make sure that we don''t accidently
    pollute the object that was passed in:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方法的最后一个测试，我们必须确保我们没有意外地污染传入的对象：
- en: '[PRE103]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can use the same method we have been using to ensure data integrity:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们一直在使用的相同方法来确保数据完整性：
- en: '[PRE104]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Genericizing the repository
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型化仓库
- en: This repository is great, but do we really want to repeat this logic and all
    these tests for every single data model that we need to be retrieved from some
    data source? The answer is no; if you find yourself doing the same thing over
    and over as a developer, you are doing something wrong.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库很棒，但我们真的希望为每个需要从数据源检索的数据模型重复这个逻辑和所有这些测试吗？答案是：不；如果你发现自己作为开发者反复做同样的事情，你就是在做错事。
- en: So, how can we protect ourselves from that drudgery?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何保护自己免受这种繁琐的困扰？
- en: One way is to use generics. Let's refactor the `SpeakerRepository` to use generics,
    this will also involve refactoring many of the tests to make them apply to the
    `GenericRepository` instead of the concrete `SpeakerRepository`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是用泛型。让我们重构 `SpeakerRepository` 以使用泛型，这还将涉及重构许多测试，使它们适用于 `GenericRepository`
    而不是具体的 `SpeakerRepository`。
- en: Step one – abstract interface
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步 – 抽象接口
- en: 'In the `IRepository`, everywhere we use `Speaker` we need to replace it with
    C# generics:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IRepository` 中，我们每处使用 `Speaker` 都需要用 C# 泛型来替换：
- en: '[PRE105]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This change will cause a break in the `SpeakerRepository` that we need to fix.
    Right now, we are chasing the compiler and leaning on it to tell us what we are
    breaking. Once the tests pass again, we will know we are back to good:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改将导致 `SpeakerRepository` 中断，我们需要修复。目前，我们正在追逐编译器，依赖它告诉我们我们打破了什么。一旦测试再次通过，我们就知道我们又回到了正轨：
- en: '[PRE106]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now we have to make some changes in the SpeakerService as it is no longer able
    to reference a simple IRepository but instead needs an `IRepository<Speaker>`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 SpeakerService 中做一些更改，因为它不再能够引用简单的 IRepository，而是需要一个 `IRepository<Speaker>`：
- en: '[PRE107]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We must update the fake repository to use the correct generic repository type.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更新模拟仓库以使用正确的泛型仓库类型。
- en: '`public class FakeRepository : IRepository<Speaker>`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`public class FakeRepository : IRepository<Speaker>`'
- en: And lastly, we have several tests that need to be updated. No secret code there;
    just update `IRepository` to `IRepository<Speaker>`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一些需要更新的测试。没有秘密代码；只需将 `IRepository` 更改为 `IRepository<Speaker>`。
- en: Step two – abstract the concrete class
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二步 – 抽象具体类
- en: 'Now that the interface is generic, we can start to work on the `SpeakerRepository`.
    First let''s rename it to `InMemorySpeakerRepository`. Now, we want to start using
    generics. Create a new class, `InMemoryRepository<T>` and have the speaker repository
    inherit from it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在接口已经是泛型了，我们可以开始处理 `SpeakerRepository`。首先，让我们将其重命名为 `InMemorySpeakerRepository`。现在，我们想要开始使用泛型。创建一个新的类，`InMemoryRepository<T>`，并让演讲者仓库继承自它：
- en: '[PRE108]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In order to move slow and have the tests passing as much as possible, we are
    using abstract and will have to have each method in the speaker repository override
    the base class methods. This gives us the ability to move each method individually
    into the abstract as we discover what needs to be done, instead of trying to tackle
    the whole problem all at once.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓慢移动并尽可能多地通过测试，我们使用抽象的，并将不得不让演讲者仓库中的每个方法覆盖基类方法。这使我们能够将每个方法单独移动到抽象中，而不是一次尝试解决整个问题。
- en: 'Inherit from the in-memory repository and add override to each inherited method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存仓库继承，并为每个继承的方法添加覆盖：
- en: '[PRE109]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Converting Create to a generic method
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Create`转换为通用方法
- en: 'We will begin our generic method journey with `Create`. The first step is to
    copy the body of the `Create` method from the speaker repository to the generic
    repository. In order to do this, we must change the abstract `Create` method to
    a virtual `Create` method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的通用方法之旅，从`Create`开始。第一步是将`Create`方法的内容从演讲者仓库复制到通用仓库。为了做到这一点，我们必须将抽象的`Create`方法更改为虚拟的`Create`方法：
- en: '[PRE110]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Instantly, we run into trouble. We don't have a generic clone method. For now
    let's fake it until we make it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们遇到了麻烦。我们没有通用的克隆方法。现在，我们先伪造它，直到我们找到真正的解决方案。
- en: 'Add the following protected abstract method to the generic repository:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用仓库中添加以下受保护的抽象方法：
- en: '[PRE111]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we can make similar changes in the code we copied from the speaker repository''s
    `Create` method:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在从演讲者仓库的`Create`方法复制的代码中做出类似的变化：
- en: '[PRE112]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Its''s looking much better now, but we still have one issue. We can''t expect
    `Id` to exist on just any object. The compiler is quite mad about this right now.
    There are several solutions, but we are going to create a simple data model interface
    and place a constraint on `T` that it must inherit from that interface. The only
    thing in the interface will be a property of `Id` with an integer type:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了，但我们仍然有一个问题。我们不能期望`Id`在任意对象上存在。编译器现在非常生气。有几个解决方案，但我们将创建一个简单的数据模型接口，并在`T`上放置一个约束，它必须继承该接口。接口中唯一的东西将是一个整型`Id`属性：
- en: '[PRE113]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This causes a break in the speaker repository. We must also have Speaker inherit
    from `IIdentity`. Now, we have relocated all of the logic in the `Create` method
    into the generic repository. Delete the `Create` method in the speaker repository.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致演讲者仓库中断。我们还必须让`Speaker`继承自`IIdentity`。现在，我们已经将`Create`方法中的所有逻辑移动到了通用仓库。删除演讲者仓库中的`Create`方法。
- en: Many tests fail because we need to repoint the other methods in the speaker
    repository to use the backing objects from the generic repository. Go through
    the speaker repository and update all the references to Speakers to Entities,
    instead.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将演讲者仓库中的其他方法重新指向通用仓库中的支持对象，因此许多测试失败了。相反，遍历演讲者仓库并更新所有对`Speakers`的引用到`Entities`。
- en: 'We also need to make an adjustment to the `TestableSpeakerRepository` class:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整`TestableSpeakerRepository`类：
- en: '[PRE114]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Converting Get to a generic method
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Get`转换为通用方法
- en: 'Next on the list is the `Get` method. Just like with the `Create` method, copy
    all the contents into the generic repository and fix any errors that occur:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是列表中的`Get`方法。就像`Create`方法一样，将所有内容复制到通用仓库，并修复出现的任何错误：
- en: '[PRE115]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This method turns out to be an easy one to copy. Now, delete the existing method
    in the speaker repository. No tests break this time so we can move on to the next
    method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法证明是很容易复制的。现在，删除演讲者仓库中现有的方法。这次没有测试失败，所以我们可以继续到下一个方法。
- en: Converting GetAll to a generic method
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`GetAll`转换为通用方法
- en: '`GetAll` is the easiest of the methods to convert. It doesn''t even reference
    speakers textually:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAll`是转换起来最简单的方法。它甚至没有以文本形式引用演讲者：'
- en: '[PRE116]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Delete the existing method in the speaker repository and move on to the next
    method, update.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 删除演讲者仓库中现有的方法，继续到下一个方法，更新。
- en: Converting Update to a generic method
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Update`转换为通用方法
- en: 'The process for update is the same as with the other methods. Copy the body
    of the existing code, rename any speaker references to entity references, and
    then delete the existing method:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 更新过程与其他方法相同。复制现有代码的主体，将任何演讲者引用重命名为实体引用，然后删除现有方法：
- en: '[PRE117]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Converting Delete to a generic method
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Delete`转换为通用方法
- en: '`Delete` is a different story: every object is likely to have different requirements
    for deleting it. Some will actually be deleted and others, such as Speaker, will
    merely be flagged as deleted. For this and many other reasons, we choose to leave
    the `Delete` implementation up to concrete repositories and the generic repository
    will throw a not implemented exception instead.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete` 是一个不同的情况：每个对象在删除时可能都有不同的要求。一些实际上会被删除，而其他，如 Speaker，则仅仅会被标记为已删除。出于这个原因以及许多其他原因，我们选择将
    `Delete` 的实现留给具体的仓储，而通用仓储将抛出一个未实现异常。'
- en: 'Let''s write a `Delete` test class just for this functionality. It should be
    short and quick:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个功能编写一个 `Delete` 测试类。它应该是简短且快速的：
- en: '[PRE118]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Writing this test also makes us change the generic repository from an abstract
    class to a normal class. Changing the class type makes us change the `CloneEntity`
    method from abstract to virtual:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个测试也让我们将通用仓储从抽象类更改为普通类。更改类类型使我们不得不将 `CloneEntity` 方法从抽象更改为虚拟：
- en: '[PRE120]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, we can write the method that will pass the test:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以写出通过测试的方法：
- en: '[PRE121]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Step three – reorient the tests to use the generic repository
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三步 – 将测试重新定向以使用通用仓储
- en: We began this process when we dealt with the `Delete` method. But let's continue
    with the other methods. All the methods that were moved into the generic repository
    can have most of their tests moved as well.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理 `Delete` 方法时开始了这个过程。但让我们继续处理其他方法。所有移动到通用仓储的方法都可以将大部分测试一起移动。
- en: We will be leaving the data integrity tests because they are directly tied to
    the functionality in the speaker repository. We will leave all the delete tests
    for the same reason.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放弃数据完整性测试，因为这些测试直接与演讲者仓储中的功能相关。出于相同的原因，我们将保留所有删除测试。
- en: InMemoryRepository Create tests
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InMemoryRepository 创建测试
- en: 'To implement the rest of the functionality for the `InMemoryRepository`, we
    will start with the tests for the `Create` method:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `InMemoryRepository` 的其余功能，我们将从 `Create` 方法的测试开始：
- en: '[PRE122]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: InMemoryRepository Get tests
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InMemoryRepository 获取测试
- en: 'Now that we can create using the `InMemoryRepository`, we should be able to
    accurately test the `Get` method:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `InMemoryRepository` 创建，我们应该能够准确测试 `Get` 方法：
- en: '[PRE124]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: InMemoryRepository GetAll tests
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InMemoryRepository 获取所有测试
- en: 'With getting a single object working, lets test getting all the objects:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个对象获取工作后，让我们测试获取所有对象：
- en: '[PRE125]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: InMemoryRepository Update tests
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InMemoryRepository 更新测试
- en: Last but not least, we will add the ability to update records using the `InMemoryRepository:`
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将添加使用 `InMemoryRepository` 更新记录的能力：
- en: '[PRE126]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We now have a generic repository that can be used with any data model as long
    as that data model has an ID. We also have a way to ensure data integrity if we
    need to, by inheriting and creating a method to clone the data object that we
    need to protect.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以与任何具有 ID 的数据模型一起使用的通用仓储。如果我们需要确保数据完整性，我们还可以通过继承并创建一个克隆所需保护的数据对象的方法来实现。
- en: Entity Framework
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体框架
- en: '**Object-Relation Mapping** (**ORM**) frameworks such as Entity Framework help
    increase productivity and optimize code reuse and maintainability. However, you
    should not tightly couple your application to the ORM. Abstract away ORMs such
    as Entity Framework just as you would any third-party library or system.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）框架，如 Entity Framework，有助于提高生产力和优化代码重用及可维护性。然而，您不应将应用程序紧密耦合到
    ORM。像对待任何第三方库或系统一样，抽象化 ORM，如 Entity Framework。'
- en: Speaker Meet uses Entity Framework through a generic repository; in order to
    get started, add a NuGet reference to Entity Framework – Sql Server.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Speaker Meet 通过通用仓储使用 Entity Framework；为了开始，添加对 Entity Framework – Sql Server
    的 NuGet 引用。
- en: '[PRE127]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, add a connection string to the `appsettings.json`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将连接字符串添加到 `appsettings.json`：
- en: '[PRE128]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: DbContext
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DbContext
- en: The latest version of Entity Framework, EF Core 2.0, has added DbContext pooling,
    which helps improve performance by saving some of the cost of initializing a new
    instance of the `DbContext` with each request.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的 Entity Framework，EF Core 2.0，已添加 DbContext 缓存，这有助于通过节省每次请求初始化新的 `DbContext`
    实例的一些成本来提高性能。
- en: 'Modify the `Startup.cs` ConfigureServices to reference the connection string:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `Startup.cs` 中的 ConfigureServices 以引用连接字符串：
- en: '[PRE129]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Add a `DbContext` to your application. Create a new file named `SpeakerMeetContext`
    with options as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 `DbContext` 添加到您的应用程序中。创建一个名为 `SpeakerMeetContext` 的新文件，并使用以下选项：
- en: '[PRE130]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Models
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Entity Framework models may contain additional information that you might not
    necessarily want to expose to other parts of the system or application consumers.
    Create a new model named `Speaker`. This will be the model used by Entity Framework
    and the generic repository. The services or business layer will be responsible
    for converting the Entity Framework models to **Data Transfer Objects** (**DTOs**)
    or ViewModels used by the rest of the application:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework模型可能包含您可能不希望暴露给系统其他部分或应用程序消费者的额外信息。创建一个名为`Speaker`的新模型。这将是由Entity
    Framework和通用仓库使用的模型。服务或业务层将负责将Entity Framework模型转换为应用程序其他部分使用的**数据传输对象**（**DTOs**）或ViewModels：
- en: '[PRE131]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Generic repository
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用仓库
- en: 'In order to see the Entity Framework specific Generic repository run you may
    want to add the following class to your application:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到Entity Framework特定的通用仓库运行，您可能需要将以下类添加到您的应用程序中：
- en: '[PRE132]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Dependency Injection
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In order to wire everything up, the Speaker Meet application leverages the built
    in **Dependency Injection** (**DI**) container. Dependency Injection allows the
    system to be loosely coupled. There are ways to achieve this without the use of
    a container (poor man’s DI, and so on) which will be covered in a later chapter.
    The tests themselves do not rely on DI, instead opting to instantiate classes
    as needed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有组件连接起来，Speaker Meet 应用程序利用了内置的 **依赖注入**（**DI**）容器。依赖注入允许系统实现松耦合。有一些方法可以在不使用容器的情况下实现这一点（例如“穷人版DI”等），这些方法将在后面的章节中介绍。测试本身并不依赖于DI，而是选择按需实例化类。
- en: Wire it all up
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接所有组件
- en: 'In order to configure the DI container, add the following to ConfigureServices
    in `Startup.cs`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置DI容器，请将以下内容添加到`Startup.cs`中的`ConfigureServices`：
- en: '[PRE133]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This will avoid the need to instantiate the `SpeakerService` from within the
    `SpeakerController`. The DI container handles this for you.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免在`SpeakerController`内部实例化`SpeakerService`的需要。DI容器会为您处理这个问题。
- en: If you've created your database and populated the speaker table, you now should
    be able to run the application and hit the `SpeakerController` endpoints. Give
    it a shot!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经创建了数据库并填充了演讲者表，现在您应该能够运行应用程序并访问`SpeakerController`端点。试一试吧！
- en: '`http://localhost:41436/api/speaker/`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:41436/api/speaker/`'
- en: '`http://localhost:41436/api/speaker/1`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:41436/api/speaker/1`'
- en: '`http://localhost:41436/api/speaker/search?searchString=test`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:41436/api/speaker/search?searchString=test`'
- en: Postman
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman
- en: There are a variety of tools available for manually exercising an API. Postman
    is just one such tool and is a favorite in the industry. Postman offers a lot
    of functionality to help you with your API development and testing. It's worth
    a look if you're interested.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于手动测试API。Postman只是其中之一，并且在业界很受欢迎。Postman提供了许多功能来帮助您进行API开发和测试。如果您对此感兴趣，值得一试。
- en: 'To install Postman, simply visit the website ([http://www.getpostman.com](http://www.getpostman.com))
    and follow the instructions. With the Speaker Meet application running, enter
    the URL (example: `http://localhost:41436/api/speaker/search`) into the box, add
    params (example: `[{"key":"searchString","value":"te","description":""}]`), and
    hit Send. The response shows as JSON by default in the body of the message.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Postman，只需访问网站（[http://www.getpostman.com](http://www.getpostman.com)）并按照说明操作。当Speaker
    Meet应用程序运行时，将URL（例如：`http://localhost:41436/api/speaker/search`）输入框中，添加参数（例如：`[{"key":"searchString","value":"te","description":""}]`），然后点击发送。默认情况下，响应显示在消息体的JSON中。
- en: This can be an extremely powerful tool. As the complexity and feature set of
    the Speaker Meet API grows, more complex messages can be sent with `POST`, `PUT`,
    `PATCH`, and `DELETE`. These will be covered in a later chapter.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个非常强大的工具。随着Speaker Meet API的复杂性和功能集的增长，可以使用`POST`、`PUT`、`PATCH`和`DELETE`发送更复杂的消息。这些将在后面的章节中介绍。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was all about abstraction: when and how to use it. You should
    now see why it''s so important to create abstractions between code you write yourself
    and that of a third party. You should also have a good idea of how those abstractions
    can be achieved.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述了抽象：何时以及如何使用它。你现在应该明白为什么在您自己编写的代码和第三方代码之间创建抽象如此重要。你也应该对如何实现这些抽象有一个很好的了解。
- en: In this chapter, we abstracted a Gravatar service, extended the repository pattern,
    and used a generic repository for Entity Framework.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们抽象了一个Gravatar服务，扩展了仓库模式，并使用通用仓库为Entity Framework。
- en: In [Chapter 9](part0318.html#9F8IS0-d186949d2da74f5c95dd1712efae1195), *Testing
    JavaScript Applications*, we'll focus on testing JavaScript applications. We'll
    walk through creating a React application and discuss different approaches to
    testing a JavaScript application.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0318.html#9F8IS0-d186949d2da74f5c95dd1712efae1195)，*测试JavaScript应用程序*，我们将专注于测试JavaScript应用程序。我们将逐步创建一个React应用程序，并讨论测试JavaScript应用程序的不同方法。
