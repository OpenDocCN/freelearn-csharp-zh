<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Design Patterns for Web Applications - Part 1</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will continue building the <strong>FlixOne</strong> Inventory Management application (see <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml"/><a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns Basics â€“ Part 1</em>), and we will discuss the conversion of a console application to a web application. The web application should be more appealing to users, as opposed to a console application; Here, we will also discuss why we are going for this change.</p>
<p class="mce-root">The following topics will be covered in this chapter:</p>
<ul>
<li>Creating a .NET Core web application</li>
<li class="h1">Crafting a web application</li>
<li>Implementing CRUD pages</li>
</ul>
<p>If you have not looked at the earlier chapters yet, please note that the <strong>FlixOne Inventory Management</strong> web application is an imaginary product. We are creating this application to discuss the various design patterns required in web projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter contains various code examples to explain the concepts. The code is kept simple and is just for demonstration purposes. Most of the examples involve a <strong>.NET Core</strong> console application written in C#.</p>
<p>To run and execute the code, you need the following:</p>
<ul>
<li>Visual Studio 2019 (you can also run the application using Visual Studio 2017 Update 3 or later)</li>
<li>Environment Setup for .NET Core</li>
<li>SQL Server (the Express edition is used in this chapter)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Visual Studio</h1>
                
            
            
                
<p>To run these code examples, you need to install Visual Studio (2017), or later version such as 2019 (or you can use your preferred IDE). To do this, follow these steps:</p>
<ol>
<li>Download Visual Studio from: <a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions included. Multiple versions are available for the Visual Studio installation. In this chapter, we are using Visual Studio for Windows.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up .NET Core</h1>
                
            
            
                
<p class="mce-root">If you do not have .NET Core installed, you need to follow these steps:</p>
<ol>
<li class="mce-root">Download .NET Core from: <a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li>Follow the installation instructions and follow the related library: <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.<a href="https://dotnet.microsoft.com/download/dotnet-core/2.2"/></li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing SQL Server</h1>
                
            
            
                
<p class="mce-root">If you do not have SQL Server installed, you need to follow these instructions:</p>
<ol>
<li>Download SQL Server from: <a href="https://www.microsoft.com/en-in/download/details.aspx?id=1695">https://www.microsoft.com/en-in/download/details.aspx?id=1695</a>.</li>
<li>You can find the installation instructions at: <a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017</a>.</li>
</ol>
<p>For troubleshooting and for more information, refer to: <a href="https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm">https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm</a>.</p>
<p>This section is meant to provide the prerequisite information to get started with web applications. We'll look at more details in the subsequent sections. In this chapter, we will use code examples to elaborate on various terms and sections.</p>
<p>The complete source code is available at: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter6">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter6</a>.<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter6"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a .Net Core web application</h1>
                
            
            
                
<p>At the beginning of this chapter, we discussed our FlixOne console-based application, and there are various reasons to go with a web application as identified by the business team. Now it's time to make changes in the application. In this section, we will start the creation of a new UI of our existing FlixOne application with a new look and feel. We will also discuss all the requirements and initialization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Kicking off the project</h1>
                
            
            
                
<p>In continuation of our existing FlixOne console application, management has decided to revamp our FlixOne Inventory console application with a lot of features. Management came to the conclusion that we have to convert our existing console application into a web-based solution.</p>
<p>The tech team and the business team sat down together and identified the various reasons why the decision was made to scrap the current console application:</p>
<ul>
<li>The interface is not interactive.</li>
<li>The application is not available everywhere.</li>
<li>It is complex to maintain.</li>
<li>The growing business needs a scalable system with higher performance and adaptability.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing requirements</h1>
                
            
            
                
<p class="mce-root">The following list of requirements was produced as the outcome of the discussions. The high-level requirements identified are as follows:</p>
<ul>
<li>Product categorization</li>
<li>Product addition</li>
<li>Product updating</li>
<li>Product deletion</li>
</ul>
<p>The actual requirements that the business demands fall on the developers. These technical requirements include the following:</p>
<ul>
<li><strong>A landing or home page</strong>: This should be a dashboard that contains various widgets, and it should show a summary of the store.</li>
<li><strong>A product page</strong>: This should have the ability to add, update, and delete products and categories.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Crafting a web application</h1>
                
            
            
                
<p>According to the requirements just discussed, our main goal is to convert our existing console application to a web application. In the process of this conversion, we will discuss various design patterns for web applications, and the importance of these design patterns in the context of web applications.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Web applications and how they work</h1>
                
            
            
                
<p>Web applications are one of the best implementations of the client-server architecture. A web application can be a small piece of code, a program, or a complete solution for a problem or a business scenario in which users interact with one another or with the server, using browsers. A web application serves requests and responses via browsers, mainly through the use of <strong>HyperText Transfer Protocol</strong> (<strong>HTTP</strong>).</p>
<p>Whenever any communication occurs between the client and the server, two things happen: the client initiates the request and the server generates the response. This communication is made up of HTTP requests and HTTP responses. For more information, refer to the documentation at: <a href="https://www.w3schools.com/whatis/whatis_http.asp">https://www.w3schools.com/whatis/whatis_http.asp</a>.</p>
<p>In the following diagram, you can see an overview of a web application and how it works:</p>
<div><img src="img/a6f3af7f-d494-4645-afd7-0f7b4f81254d.png" style=""/></div>
<p>From this diagram, you can easily see that with the use of a browser (as a client), you're opening doors for millions of users who can access the website from anywhere in the world and can interact with you as a user. With a web application, you and your customers can communicate easily. Generally, effective engagement is only possible when you capture and store the data with all the necessary information required for your business and your users. This information is then processed, and the results are presented to your users.</p>
<p>In general, web applications use a combination of server-side code to handle the storage and retrieval of the information, and client-side scripts to present the information to the users.</p>
<p>The web application requires a web server (such as <strong>IIS</strong> or <strong>Apache</strong>) to manage requests coming from the client (from the browser, as can be seen in the previous diagram). An application server (such as IIS or Apache Tomcat) is also required to perform the tasks requested. A database is sometimes needed to store the information as well.</p>
<p>Put simply, both a web server and an application server are designed to serve HTTP content, but with certain variations. Web servers serve static HTTP content, such as HTML pages. Application servers can, apart from serving static HTTP content, also serve dynamic content, using different programming languages. For more information, refer to <a href="https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server">https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server</a>.</p>
<p>We can elaborate on the workflow of a web application as follows. These are known as the five-step working processes of a web application:</p>
<ol>
<li>A request is triggered by the client (browser) to the web server using HTTP (in most cases) over the internet. This usually happens through a web browser or the application's user interface.</li>
<li>The request arises at the web server, and the web server forwards the request to the application server (for different requests, there would be different application servers).</li>
<li>In the application server, the requested tasks are completed. This might involve querying the database server, retrieving information from the database, processing information, and building results.</li>
<li>The generated results (the requested information or the processed data) are sent to the web server.</li>
<li>Finally, the response is sent back to the requester (the client) from the web server with the requested information. This appears on the user's display.</li>
</ol>
<p>The following diagram shows a pictorial overview of these five steps:</p>
<div><img src="img/195177cd-d19e-474a-a84a-242a3be32cb4.png" style=""/></div>
<p>In the following sections, I will describe the working process of the web application using the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coding the web application</h1>
                
            
            
                
<p>Up until now, we have gone through the requirements and looked at our aim, which is to convert a console application into a web-based platform or application. In this section, we will develop the actual web application using Visual Studio.</p>
<p>Carry out the following steps to create a web application using Visual Studio:</p>
<ol>
<li>Open the Visual Studio instance.</li>
<li>Click on File|New|Project or press <em>Ctrl + Shift + N</em>, as shown in the following screenshot:</li>
</ol>
<div><img src="img/111a9983-9056-44db-a155-8f0a4352373e.png" style=""/></div>
<ol start="3">
<li>From the New Project window, select Web|.NET Core|ASP.NET Core Web Application.</li>
</ol>
<ol start="4">
<li>Name it (for example, <kbd>FlixOne.Web</kbd>), select the location, and then you can update the solution name. By default, the solution name will be the same as the project name. Check the Create directory for solution checkbox. You can also choose to check the Create new Git repository checkbox (if you want to create a new repository for this, you need a valid Git account).</li>
</ol>
<p style="padding-left: 60px">The following screenshot shows the creation process of a New project:</p>
<div><img src="img/d8703640-dbe5-4058-9740-1905a9b25e98.png" style=""/></div>
<ol start="5">
<li>The next step is to select the proper template for your web application and the .NET Core version. We are not going to enable Docker support for this project, as we are not going to deploy our application using Docker as the container. We will go with the HTTP protocol only, instead of HTTPS. Both the Enable Docker Support and Configure HTTPs checkboxes should, therefore, remain unchecked, as shown in the following screenshot:</li>
</ol>
<div><img src="img/e62d22ed-9dc7-4f16-a021-994702496622.png"/></div>
<p style="padding-left: 60px">We now have a complete project with our template and example code, using the MVC framework. The following screenshot shows our solution so far:</p>
<div><img src="img/6af17baa-1c2c-4b81-8653-5bfa980d6f69.png" style=""/></div>
<p>Architectural patterns are a way of implementing best practices within the design of the user interface and application itself. They provide us with reusable solutions to common problems. These patterns also allow us to easily implement a separation of concerns.<br/>
<br/>
The most popular architectural patterns are as follows:<br/>
<ul>
<li><strong>Model-View-Controller</strong> (<strong>MVC</strong>)</li>
<li><strong>Model-view-presenter</strong> (<strong>MVP</strong>)</li>
<li><strong>Model-view-viewmodel</strong> (<strong>MVVM</strong>)</li>
</ul>
</p>
<p style="padding-left: 60px">You can try to run the application by hitting <em>F5</em>. The following screenshot shows the default home page of the web application:</p>
<div><img src="img/3a4a7a9a-9dd8-47c7-8ad0-f19344748448.png"/></div>
<p>In the coming sections, I will discuss MVC patterns and create <strong>CRUD</strong> (<strong>Create</strong>, <strong>Update</strong>, and <strong>Delete</strong>) pages to interact with the users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing CRUD pages</h1>
                
            
            
                
<p>In this section, we will start creating functional pages to create, update, and delete products. To get started, open your <kbd>FlixOne</kbd> solution, and add the following classes into the specified folders:</p>
<p><strong><kbd>Models</kbd></strong>: Add the following files in the <kbd>Models</kbd> folder of the solution:</p>
<ul>
<li><kbd>Product.cs</kbd>: The code snippet of the <kbd>Product</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 60px">public class Product<br/>{<br/>   public Guid Id { get; set; }<br/>   public string Name { get; set; }<br/>   public string Description { get; set; }<br/>   public string Image { get; set; }<br/>   public decimal Price { get; set; }<br/>   public Guid CategoryId { get; set; }<br/>   public virtual Category Category { get; set; }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Product</kbd> class represents almost all the elements of the product. It has a <kbd>Name</kbd>, a complete <kbd>Description</kbd>, an <kbd>Image</kbd>, a <kbd>Price</kbd>, and a unique <kbd>ID</kbd> so that our system recognizes it. The <kbd>Product</kbd> class also has a <kbd>Category ID</kbd> to which this product belongs. It also includes a complete definition of the <kbd>Category</kbd>.</p>
<div><strong>Why should we define a <kbd>virtual</kbd> property?</strong><br/>
In our <kbd>Product</kbd> class, we have defined a <kbd>virtual</kbd> property. This is because, in the <strong>Entity Framework</strong> (<strong>EF</strong>), this property helps to create a proxy for the virtual property. In this way, the property can support lazy loading and more efficient change tracking. This means that data is available on demand. EF loads the data when you request to use the <kbd>Category</kbd> property.</div>
<ul>
<li><kbd>Category.cs</kbd>: The code snippet of the <kbd>Category</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 60px">public class Category<br/>{<br/>    public Category()<br/>    {<br/>        Products = new List&lt;Product&gt;();<br/>    }<br/><br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public virtual IEnumerable&lt;Product&gt; Products { get; set; }<br/>}</pre>
<p style="padding-left: 60px">Our <kbd>Category</kbd> class represents the actual category of the product. A category has a unique <kbd>ID</kbd>, a <kbd>Name</kbd>, a complete <kbd>Description</kbd>, and a collection of <kbd>Products</kbd> that belong to this category. Whenever we initialize our <kbd>Category</kbd> class, it initializes our <kbd>Product</kbd> class.</p>
<ul>
<li><kbd>ProductViewModel.cs</kbd>: The code snippet of the <kbd>ProductViewModel</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 60px">public class ProductViewModel<br/>{<br/>    public Guid ProductId { get; set; }<br/>    public string ProductName { get; set; }<br/>    public string ProductDescription { get; set; }<br/>    public string ProductImage { get; set; }<br/>    public decimal ProductPrice { get; set; }<br/>    public Guid CategoryId { get; set; }<br/>    public string CategoryName { get; set; }<br/>    public string CategoryDescription { get; set; }<br/>}</pre>
<p style="padding-left: 60px">Our <kbd>ProductViewModel</kbd> class represents a complete <kbd>Product</kbd> which is having attributes like a unique <kbd>ProductId</kbd>, a <kbd>ProductName</kbd>, a complete <kbd>ProductDescription</kbd>, a <kbd>ProductImage</kbd>, a <kbd>ProductPrice</kbd>, a unique <kbd>CategoryId</kbd>, a <kbd>CategoryName</kbd>, and a complete <kbd>CategoryDescription</kbd>.</p>
<p><kbd>Controllers</kbd>: Add the following files to the <kbd>Controllers</kbd> folder of the solution:</p>
<ul>
<li><kbd>ProductController</kbd> is responsible for all operations related to products. Let's take a look at the code and the operations that we are trying to achieve in this controller:</li>
</ul>
<pre style="padding-left: 60px">public class ProductController : <strong>Controller</strong><br/>{<br/>    private readonly IInventoryRepositry _repositry;<br/>    public ProductController(IInventoryRepositry inventoryRepositry) =&gt; _repositry = inventoryRepositry;<br/><br/>...<br/>}</pre>
<p style="padding-left: 60px">Here, we defined the <kbd>ProductController</kbd> that inherits from a <kbd>Controller</kbd> class. We used <strong>dependency injection</strong>, which is built-in support from the ASP.NET Core MVC framework.</p>
<p>We discussed the inversion of control in detail in <a href="fd71001a-4673-4391-a10b-2490e07f135e.xhtml">Chapter 5</a>, <em>Implementing Design Patterns - .Net Core;</em> <kbd>Controller</kbd> is a base class for an MVC controller. For more information, refer to: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller</a>.</p>
<p>We have created our main controller, <kbd>ProductController</kbd>. Let's now start adding functionalities for our CRUD operations.</p>
<p>The following code is simply a <kbd>Read</kbd> or <kbd>Get</kbd> operation that requests the repository (<kbd>_</kbd><kbd>inventoryRepository</kbd>) to list all available products, and then transposes this product list to the <kbd>ProductViewModel</kbd> type and returns an <kbd>Index</kbd> view:</p>
<pre>   public IActionResult Index() =&gt; View(_repositry.GetProducts().ToProductvm());<br/>   public IActionResult Details(Guid id) =&gt; View(_repositry.GetProduct(id).ToProductvm());</pre>
<p>In the preceding code snippet, the <kbd>Details</kbd> method returns the details of a specific <kbd>Product</kbd> based on its unique <kbd>Id</kbd>. This is also a <kbd>Get</kbd> operation that is similar to our <kbd>Index</kbd> method, but it provides a single object instead of a list.</p>
<p>The methods of the <strong>MVC controller</strong> are also called <strong>action methods</strong> and have the return type of <kbd>ActionResult</kbd>. In this case, we are using <kbd>IActionResult</kbd>. In general, you can say that <kbd>IActionResult</kbd> is an interface of the <kbd>ActionResult</kbd> class. It also provides us a way to return many things, including the following:<br/>
<ul>
<li><kbd>EmptyResult</kbd></li>
<li><kbd>FileResult</kbd></li>
<li><kbd>HttpStatusCodeResult</kbd></li>
<li><kbd>ContentResult</kbd></li>
<li><kbd>JsonResult</kbd></li>
<li><kbd>RedirectToRouteResult</kbd></li>
<li><kbd>RedirectResult</kbd></li>
</ul>
We are not going to discuss all of these in detail, as these are beyond the scope of this book. To find out more about return types, refer to: <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types">https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types</a>.</p>
<p>In the following code, we are creating a new product. The following code snippet has two action methods. One has the <kbd>[HttpPost]</kbd> attribute, and the other is without the attribute:</p>
<pre>public IActionResult Create() =&gt; View();<br/>[HttpPost]<br/>[ValidateAntiForgeryToken]<br/>public IActionResult Create([FromBody] Product product)<br/>{<br/>    try<br/>    {<br/>        _repositry.AddProduct(product);<br/>        return RedirectToAction(nameof(Index));<br/>    }<br/>    catch<br/>    {<br/>        return View();<br/>    }<br/>}</pre>
<p>The first method simply returns a <kbd>View</kbd>. This will return a <kbd>Create.cshtml</kbd> page.</p>
<p>If any of the action methods in the <strong>MVC framework</strong> do not have any attribute, it will use the <kbd>[HttpGet]</kbd> attribute by default. In other views, by default, action methods are <kbd>Get</kbd> requests. Whenever a user views a page, we use <kbd>[HttpGet]</kbd>, or a <kbd>Get</kbd> request. Whenever a user submits a form or performs an action, we use <kbd>[HttpPost]</kbd>, or a <kbd>Post</kbd> request.<br/>
<br/>
If we did not explicitly mention the view name in our action method, then the MVC framework looks like a view name in this format: <kbd>actionmethodname.cshtml</kbd> or <kbd>actionmethodname.vbhtml</kbd>. In our case, the view name is <kbd>Create.cshtml</kbd> because we are using the C# language. It would be <kbd>vbhtml</kbd> if we used Visual Basic. It first looks in the folder that has a name that is similar to the controller's folder name. If it does not find a file in this folder, it looks in the <kbd>shared</kbd> folder.</p>
<p>The second action method in the previous code snippet uses the <kbd>[HttpPost]</kbd> attribute, which means it handles <kbd>Post</kbd> requests. This action method simply adds the product by calling the <kbd>AddProduct</kbd> method of <kbd>_repository</kbd>. In this action method, we have used the <kbd>[ValidateAntiForgeryToken]</kbd> attribute and <kbd>[FromBody]</kbd>, which is a model binder.</p>
<p>The MVC framework provides a lot of security to protect our application from <strong>Cross-Site Scripting</strong>/<strong>Cross-Site Request Forgery</strong> (<strong>XSS/CSRF</strong>) attacks by providing the <kbd>[ValidateAntiForgeryToken]</kbd> attribute. These type of attacks generally include some dangerous client-side script code.</p>
<p>Model binding in MVC maps data from <kbd>HTTP</kbd> requests to action method parameters. Frequently used model binding attributes with action methods are as follows:</p>
<ul>
<li><kbd>[FromHeader]</kbd></li>
<li><kbd><kbd>[FromQuery]</kbd></kbd></li>
<li><kbd>[FromRoute]</kbd></li>
<li><kbd>[FromForm]</kbd></li>
</ul>
<p>We are not going to discuss these in more detail, as this is beyond the scope of this book. However, you can find complete details from the official documentation at <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding</a>.</p>
<p>In the previous code snippets, we discussed the <kbd>Create</kbd> and <kbd>Read</kbd> operations. It's now time to write a code for the <kbd>Update</kbd> operation. In the following code, we have two action methods: one is <kbd>Get</kbd>, and the other is a <kbd>Post</kbd> request:</p>
<pre>public IActionResult Edit(Guid id) =&gt; View(_repositry.GetProduct(id));<br/><br/>[HttpPost]<br/>[ValidateAntiForgeryToken]<br/>public IActionResult Edit(Guid id, [FromBody] Product product)<br/>{<br/>    try<br/>    {<br/>        _repositry.UpdateProduct(product);<br/>        return RedirectToAction(nameof(Index));<br/>    }<br/>    catch<br/>    {<br/>        return View();<br/>    }<br/>}</pre>
<p>The first action method of the previous code gets a <kbd>Product</kbd> based on the <kbd>ID</kbd> and returns a <kbd>View</kbd>. The second action method takes the data from the view and updates the requested <kbd>Product</kbd> based on its ID:</p>
<pre>public IActionResult Delete(Guid id) =&gt; View(_repositry.GetProduct(id));<br/><br/>[HttpPost]<br/>[ValidateAntiForgeryToken]<br/>public IActionResult Delete(Guid id, [FromBody] Product product)<br/>{<br/>    try<br/>    {<br/>        _repositry.RemoveProduct(product);<br/>        return RedirectToAction(nameof(Index));<br/>    }<br/>    catch<br/>    {<br/>        return View();<br/>    }<br/>}</pre>
<p>Finally, the previous code represents the <kbd>Delete</kbd> operation from our <kbd>CRUD</kbd> operations. It also has two action methods; one retrieves the data from the repository and serves it to the view, and another takes the data request and deletes the specific <kbd>Product</kbd> based on its ID.</p>
<p><kbd>CategoryController</kbd> is responsible for all the operations of the <kbd>Product</kbd> category. Add the following code to the controller, it represents the <kbd>CategoryController</kbd>, where we have used dependency injections to initialize our <kbd>IInventoryRepository</kbd>:</p>
<pre>public class CategoryController: Controller<br/>{<br/>  private readonly IInventoryRepositry _inventoryRepositry;<br/>  public CategoryController(IInventoryRepositry inventoryRepositry) =&gt; _inventoryRepositry = inventoryRepositry;<br/> //code omitted<br/>}</pre>
<p>The following code contains two action methods. The first gets a list of categories, and the second is a specific category based on its unique ID:</p>
<pre>public IActionResult Index() =&gt; View(_inventoryRepositry.GetCategories());<br/>public IActionResult Details(Guid id) =&gt; View(_inventoryRepositry.GetCategory(id));</pre>
<p>The following  code is for the <kbd>Get</kbd> and the <kbd>Post</kbd> request to create a new category in the system:</p>
<pre>public IActionResult Create() =&gt; View();<br/>    [HttpPost]<br/>    [ValidateAntiForgeryToken]<br/>    public IActionResult Create([FromBody] Category category)<br/>    {<br/>        try<br/>        {<br/>            _inventoryRepositry.AddCategory(category);<br/><br/>            return RedirectToAction(nameof(Index));<br/>        }<br/>        catch<br/>        {<br/>            return View();<br/>        }<br/>    }</pre>
<p>In the following code, we are updating our existing category. The code contains the <kbd>Edit</kbd> action methods with <kbd>Get</kbd> and <kbd>Post</kbd> requests:</p>
<pre>public IActionResult Edit(Guid id) =&gt; View(_inventoryRepositry.GetCategory(id));<br/>    [HttpPost]<br/>    [ValidateAntiForgeryToken]<br/>    public IActionResult Edit(Guid id, [FromBody]Category category)<br/>    {<br/>        try<br/>        {<br/>            _inventoryRepositry.UpdateCategory(category);<br/><br/>            return RedirectToAction(nameof(Index));<br/>        }<br/>        catch<br/>        {<br/>            return View();<br/>        }<br/>    }</pre>
<p>Finally, we have a <kbd>Delete</kbd> action method. This is the final operation of our <kbd>CRUD</kbd> pages for <kbd>Category</kbd> deletion as shown in the following code:</p>
<pre>public IActionResult Delete(Guid id) =&gt; View(_inventoryRepositry.GetCategory(id));<br/><br/>    [HttpPost]<br/>    [ValidateAntiForgeryToken]<br/>    public IActionResult Delete(Guid id, [FromBody] Category category)<br/>    {<br/>        try<br/>        {<br/>            _inventoryRepositry.RemoveCategory(category);<br/><br/>            return RedirectToAction(nameof(Index));<br/>        }<br/>        catch<br/>        {<br/>            return View();<br/>        }<br/>    }</pre>
<p><kbd>Views</kbd>: Add the following views to their respective folders:</p>
<ul>
<li><kbd>Index.cshtml</kbd></li>
<li><kbd>Create.cshtml</kbd></li>
<li><kbd>Edit.cshtml</kbd></li>
<li><kbd>Delete.cshtml</kbd></li>
<li><kbd>Details.cshtml</kbd></li>
</ul>
<p><kbd>Contexts</kbd>: Add the <kbd>InventoryContext.cs</kbd> file to the <kbd>Contexts</kbd> folder with the following code:</p>
<pre>public class InventoryContext : DbContext<br/>{<br/>    public InventoryContext(DbContextOptions&lt;InventoryContext&gt; options)<br/>        : base(options)<br/>    {<br/>    }<br/><br/>    public InventoryContext()<br/>    {<br/>    }<br/><br/>    public DbSet&lt;Product&gt; Products { get; set; }<br/>    public DbSet&lt;Category&gt; Categories { get; set; }<br/>}</pre>
<p>The preceding code provides the various methods needed to interact with the database using EF. You might face the following exception while running the code:</p>
<div><img src="img/09846618-7502-478b-ae84-e203b2782913.png"/></div>
<p>To fix this exception, you should map to the <kbd>IInventoryRepository</kbd> in the <kbd>Startup.cs</kbd> file, as shown in the following screenshot:</p>
<div><img src="img/f418bdc3-b1ce-46c5-a0b7-41d831833606.png" style=""/></div>
<p>We have now added various functionalities to our web application, and our solution now looks as shown in the following screenshot:</p>
<div><img src="img/73cc1b91-de98-4cbb-b856-17e25a46a91b.png" style=""/></div>
<p>Refer to the GitHub repository for this chapter (<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter6">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter6</a>).</p>
<p>If we were to visualize the MVC model, then it would work as shown in the following diagram:</p>
<div><img src="img/6b34db05-1e93-4888-b96c-87eec3c74beb.png" style=""/></div>
<p class="packt_figref CDPAlignLeft CDPAlign">The preceding image was adapted from <a href="https://commons.wikimedia.org/wiki/File:MVC-Process.svg">https://commons.wikimedia.org/wiki/File:MVC-Process.svg</a></p>
<p>As shown in the previous diagram, whenever a user raises a request, it comes to the controller and triggers the action method to be further manipulated or updated, if required, to the model, and then serves the view to the user.</p>
<p>In our case, whenever a user requests <kbd>/Product</kbd>, the request goes to the <kbd>Index</kbd> action method of <kbd>ProductController</kbd> and serves the <kbd>Index.cshtml</kbd> view after fetching the list of products. You will get the product listing as shown in the following screenshot:</p>
<div><img src="img/2fdb3ea4-40db-49a3-852d-d682bc005bcb.png" style=""/></div>
<p>The preceding screenshot is a simple product listing, and it represents the <kbd>Read</kbd> section of the <kbd>CRUD</kbd> operations. On this screen, the application shows the total available products and their categories.</p>
<p>The following diagram depicts how our application interacts:</p>
<div><img src="img/d2db4ee2-a842-4379-8522-3b31f80147af.png"/></div>
<p>It shows the pictorial overview of the process of our application. The <kbd>InventoryRepository</kbd> depends on the <kbd>InventoryContext</kbd> for database operations and interacts with our model classes, <kbd>Category</kbd> and <kbd>Product</kbd>. Our controllers for <kbd>Product</kbd> and <kbd>Category</kbd> use the <kbd>IInventoryRepository</kbd> interface to interact with the repository for CRUD operations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The main goal of this chapter was to start a basic web application.</p>
<p>We started the chapter by discussing business requirements, why we needed a web application, and why we wanted to upgrade our console application. We then covered the step-by-step creation of a web application using Visual Studio in the MVC pattern. We also discussed how a web application can work as a client-server model, and looked at user interface patterns. We also started building CRUD pages.</p>
<p>In the next chapter, we will continue with the web application and discuss more design patterns for web applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<p class="mce-root">The following questions will allow you to consolidate the information contained in this chapter:</p>
<ol>
<li>What is a web application?</li>
<li>Craft a web application of your choice, and depict how it works.</li>
<li>What is inversion of control?</li>
<li>What are the architectural patterns that we've covered in this chapter? Which one do you like and why?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Congratulations! You've completed this chapter. We have covered a lot of things related to authentication, authorization, and testing projects. This is not the end of your learning; it is just the beginning, and there are more books you can refer to increase your understanding. The following books provide an in-depth look at RESTful web services and test-driven development:</p>
<ul>
<li><em>Building RESTful Web services with .NET Core</em>, by <em>Gaurav Aroraa</em>, <em>Tadit Dash</em>, from <em>Packt Publishing</em>, at: <a href="https://www.packtpub.com/application-development/building-restful-web-services-net-core">https://www.packtpub.com/application-development/building-restful-web-services-net-core</a></li>
<li><em>C# and .NET Core Test Driven Development</em>, by <em>Ayobami Adewole</em>, from <em>Packt Publishing</em>, at: <a href="https://www.packtpub.com/application-development/c-and-net-core-test-driven-development">https://www.packtpub.com/application-development/c-and-net-core-test-driven-development</a></li>
</ul>


            

            
        
    </body></html>