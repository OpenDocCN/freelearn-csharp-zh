- en: '*Chapter 7*: Understanding the Mathematics of Computer Graphics in Unity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematics is a topic that is often discussed in game development. Although
    Unity has provided game developers with many helper functions to reduce the complexity
    of using mathematics in Unity, it is still necessary to have some basic mathematical
    knowledge about computer graphics, such as coordinate systems, vectors, matrices,
    and quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with coordinate systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the transformation matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have mathematical knowledge of computer
    graphics and know how to use vectors, matrices, quaternions, and Euler angles
    in scripts correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with coordinate systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many files, most model files are binary files. When a game engine, such
    as Unity, needs to render a model, the data of the model, such as the vertex array
    of the model and the index of the vertex array, will be extracted and processed
    through the render pipeline of the game engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the render pipeline in computer graphics
    at [https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview).
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphics render pipeline mainly includes two functions: one to convert the
    3D coordinates of an object into 2D coordinates in the screen space and the other
    to color each pixel of the screen. Finally, the 3D model is rendered on the 2D
    screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of the render pipeline, a lot of coordinate system conversion
    work will be involved, as you can see in *Figure 7.1*. So, it''s an important
    topic and we will introduce information about coordinate systems in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Coordinate transformation process (CC BY 4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Coordinate transformation process (CC BY 4.0)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding left-handed and right-handed coordinate systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A coordinate system is a geometric system that typically uses numbers to determine
    the position of a point in space.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, there are many different types of coordinate systems, such as
    the **number line coordinate system**, **Cartesian coordinate system**, and **polar
    coordinate system**. In computer graphics, the **Cartesian coordinate system**
    is the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Cartesian coordinate system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Cartesian coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: The Cartesian coordinate system is also very common in our daily lives, that
    is, the *x* axis, *y* axis, and *z* axis are used to describe the coordinate information
    of the object. When used to describe 3D space, the Cartesian coordinate system
    can be either a **left-handed coordinate system** or a **right-handed coordinate
    system**. As their names imply, we can actually distinguish between the two by
    using the left hand and the right hand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Coordinate systems (CC BY-SA 3.0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Coordinate systems (CC BY-SA 3.0)
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.3*, we can distinguish between the left-handed coordinate
    system and the right-handed coordinate system by visualizing the thumb pointing
    to the *x* axis, the index finger to the *y* axis, and the middle finger to the
    *z* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Left-handed coordinate system in Unity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Left-handed coordinate system in Unity
  prefs: []
  type: TYPE_NORMAL
- en: If we look in the Unity Editor, we can see that Unity uses the left-handed coordinate
    system, as shown in *Figure 7.4*.
  prefs: []
  type: TYPE_NORMAL
- en: Local space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coordinate space is the space where 3D positions and transformations exist within
    the coordinate system, such as **local space** and **world space**. In Unity,
    we often work with local space or world space. Local space is related to the concept
    of the **parent-child relationship**, which means it uses the origin and axes
    of the GameObject's parent node in the hierarchy of GameObjects. The position,
    rotation, and scaling of the parent GameObject will affect the local space defined
    by it. Therefore, this is useful not when we are dealing with the transformation
    of a single GameObject but of a group of GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in *Figure 7.5*, the five cube objects are all children of the
    GameObject named **LocalSpace**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – LocalSpace parent object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – LocalSpace parent object
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `0`. Now, let's move this parent object down 2 units along
    the *y* axis and also rotate it 45 degrees around the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – LocalSpace parent object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – LocalSpace parent object
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.6*, all these cubes have moved down 2 units along the
    *y* axis and rotated 45 degrees around the *y* axis. However, if we look at the
    position and rotation of individual cubes in the **Inspector** window, we can
    see that these values have not changed. This is because, currently, they are in
    local space defined by their parent object, and the position and rotation of a
    single cube relative to its parent object have not changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Local space child object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Local space child object
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the local position, local rotation, and local scale of a child
    object through C# code at runtime, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach this script to the child object named **Cube (1)** and run the game.
    We can see in the following screenshot that the child object has moved 2 units
    along the *x* axis relative to the parent object and is magnified 2 times along
    the *y* axis relative to the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Changing the local postion and local scale'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Changing the local postion and local scale
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed local space. Next, we will explore world space.
  prefs: []
  type: TYPE_NORMAL
- en: World space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike local space, which is defined by a parent GameObject, world space is
    the coordinate system for the entire Scene. The center of the Scene is the origin
    of world space.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new Cube object in the Scene and this time, this new cube is
    not a child of other GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – World space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – World space
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.9*, when the position of the cube is `0`, the cube is
    located in the center of the Scene. If we change the *x* value of the cube position
    from `0` to `1`, then the cube will advance 1 unit along the *x* axis of world
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Moving in world space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Moving in world space
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also modify the position, rotation, and scale of a GameObject in world
    space in a C# script. The following code snippet shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `position` property is the world space position of the transform. In addition
    to directly modifying the `position` or `rotation` properties, we can also call
    the following method to modify the `position` and `rotation` properties of the
    object at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this method requires a `Vector3`-type parameter and a `Quaternion`-type
    parameter. We will introduce vectors and quaternions later in the *Working with
    vectors* and *Working with quaternions* sections, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Screen space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this section, the coordinate system can
    be used to determine a point in space. This refers to not only 3D space but also
    2D space. Screen space is the space defined by the viewer's screen. It means that
    the screen space projects the content onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In screen space, the coordinates are in 2D; (**0,0**) is the lower-left corner
    and (screen.width, screen.height) is the upper-right corner, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Screen space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Screen space
  prefs: []
  type: TYPE_NORMAL
- en: '2D elements are often described in screen space, and the most common is the
    UI. Another common use of screen space is to get the position of the mouse input.
    The reason is obvious: the mouse moves on the screen. The following code snippet
    demonstrates how to get the position of the mouse in a C# script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePosition` property of the `Input` class will return the current mouse
    position in screen space, and the preceding code will print the mouse position
    to the **Console** window, as shown in *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Mouse position'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Mouse position
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining the screen space position of the mouse, we can use the methods
    provided by Unity's `Camera` class to convert the screen space position to the
    world space position. In addition, Unity allows us to create a ray that goes from
    the camera through a screen point to the game world. This can help us deal with
    a common situation in games where we need to know what the player is clicking
    on in the 3D game world, even though the player can only actually click on a 2D
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method signatures of some methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we just mentioned, the `ScreenPointToRay` method is very useful because it
    returns a `Ray` instance from the camera pointing to the mouse position in the
    world space. I hope you still remember the Collider component in the physics system
    we introduced in the previous chapter because we can use this method to cast a
    ray to the collider and get the details of the collider, and it can also be used
    to draw a line in the Scene view of the Unity Editor to help with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will modify the previous code to implement a function that can detect
    whether there is a collider at the mouse click position and draw a red line in
    the Scene view if there is a collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As the code snippet shows, we are calling the `ScreenPointToRay` method to
    create a ray pointing in the direction of the mouse from the location of the main
    camera in the scene, and then using this ray to detect colliders in the Scene
    by calling `Physics.Raycast`, and finally calling `Debug.DrawLine` to draw a red
    line in the Scene view, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Drawing a red line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Drawing a red line
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.13*, the top is the game view, which is the window where the game
    is running, and the bottom is the Scene view, which is the window for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have introduced you to coordinate systems in this section. Next, we will
    discuss another very important topic: vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In game development, we use vectors to define directions and positions. As
    shown in the following figure, we draw a line between two points to represent
    a vector. In this case, the vector starts from the origin, which is point **B
    (0, 0)** on the graph, to point **A (6, 2)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – 2D position'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – 2D position
  prefs: []
  type: TYPE_NORMAL
- en: We can see this vector is made up of two components, namely *x* and *y*. They
    represent the distance from the origin along the *x* axis and the *y* axis. Therefore,
    this vector can be used to define the position of point `(x*x+y*y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, we will use the Vector2 structure to represent 2D vectors and points.
    The magnitude property of Vector2 returns the value of the magnitude of this 2D
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 3D vectors are similar to 2D vectors, but we also need to consider the value
    of the *z* axis. The magnitude of a 3D vector is the square root of `(x*x+y*y+z*z)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity also provides the `Vector3` structure to represent 3D vectors and points.
    If you look at the Inspector window of a GameObject in the Scene, you will find
    that the **Position**, **Rotation**, and **Scale** properties of the object are
    all Vector3 types, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Transform of a GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Transform of a GameObject
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since vectors can be used to describe positions, they can also be used to describe
    positions that change over time. A moving object has a velocity, which is the
    speed of the object in a given direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Vector addition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Vector addition
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.16*, suppose an object is currently located at point
    **A** and its velocity is (1, 1) per minute, which means the object will move
    in a direction that is 1 unit further on the *x* axis and 1 unit further on the
    *y* axis. So, we will add its current position vector to its velocity vector to
    calculate where it will end up after 1 minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(6, 2) + (1, 1) = (7, 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: The new position of this object after 1 minute is (7, 3).
  prefs: []
  type: TYPE_NORMAL
- en: How to subtract vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vector subtraction and vector addition are very similar. We can reverse the
    direction of the second vector and use vector addition. Let's still use the previous
    example. Suppose a moving object is currently located at point A and its velocity
    is (-1, -1) per minute, which means the object will move in a direction that is
    -1 unit further on the *x* axis and -1 unit further on the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Vector subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – Vector subtraction
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add its current position vector to its velocity vector to calculate
    where it will end up after 1 minute again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(6, 2) - (1, 1) = (6, 2) + (-1, -1) = (5, 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: The new position of this object after 1 minute is (5, 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, we can add vectors and subtract vectors in C# code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we created two 3D vectors, `(1, 1, 1)` and `(1,
    2, 3`). Then, we added and subtracted them respectively and printed the results
    to the **Console** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Adding vectors and subtracting vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.18 – Adding vectors and subtracting vectors
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to move objects in Unity, knowledge of vectors is needed. But sometimes
    we don''t have to directly calculate the result of vector addition or subtraction
    in the code. This is because Unity provides us with the `Transform.Translate`
    function to move objects. Of course, we still need to pass a vector parameter
    to provide velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates how to move an object by calling the
    `Transform.Translate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Dot product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to vector addition and vector subtraction, 3D vector operations
    commonly used in game development also include **dot product** operations and
    **cross product** operations. We will introduce them separately in this section
    and the next section.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will explore the dot product in Unity. The dot product or scalar product
    takes two vectors and returns a single scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose there are two 3D vectors, named *vector1* and *vector2*;the calculation
    process of the dot product is very simple, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scalar value = (x1 * x2) + (y1 * y1) + (z1 * z2)`'
  prefs: []
  type: TYPE_NORMAL
- en: In game development, vector dot product operations are often used to find out
    whether these two vectors are perpendicular to each other. If the result of their
    dot product operation is 0, the two vectors are perpendicular to each other. If
    the result is positive, the angle between the two vectors is less than 90 degrees.
    If the result is negative, the angle between the two vectors is greater than 90
    degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can create two 3D vectors in the Unity Editor to demonstrate how to
    use the vector dot product operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Two 3D vectors in the Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – Two 3D vectors in the Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.19*, the green line represents the first vector, which
    is (0, 5, 0), and the yellow line represents the other vector, which is (5, 0,
    5). The result of the dot product operation of these two vectors is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0 = (0 * 5) + (5 * 0) + (0 * 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we can see in *Figure 7.19* that these two vectors are perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first vector is (0, 5, 5), the result of the dot product operation of
    these two vectors will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`25 = (0 * 5) + (5 * 0) + (5 * 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.20*, the two vectors are not perpendicular this time,
    and the included angle is less than 90 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Two 3D vectors in the Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.20 – Two 3D vectors in the Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first vector is (0, 1, -1), the result of the dot product operation
    of these two vectors will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-5 = (0 * 5) + (1 * 0) + (-1 * 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.21*, the two vectors are not perpendicular this time,
    and the included angle is greater than 90 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Two 3D vectors in the Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – Two 3D vectors in the Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity provides us with a function to calculate the result of the dot product
    of two 3D vectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a static function and we can call it directly in our C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cross product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the other hand, the cross product takes two vectors as well but returns another
    vector instead of a single scalar value. This vector is perpendicular to both
    of the original two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Cross product (CC BY-SA 4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Cross product (CC BY-SA 4.0)
  prefs: []
  type: TYPE_NORMAL
- en: Compared with the dot product, the calculation process of the cross product
    is more complicated. The preceding figure demonstrates this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity also offers another helpful function to calculate the result of the cross
    product of two 3D vectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a static function and we can call it directly in our C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we calculate the result of the cross product of vector1
    and vector2 and at the same time, we also draw these three vectors in the Unity
    Editor, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Cross product'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – Cross product
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced vectors and explored how to use vectors correctly
    in Unity scripts. Next, let's continue to explore another important concept in
    computer graphics, namely matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the transformation matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In game development, the **transformation matrix** is also a common term. Specifically,
    we use the transformation matrix to encode transformations, including translation,
    rotation, and scaling transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides us with the Matrix4x4 struct in C# to represent a standard 4x4
    transformation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – A 4x4 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.24 – A 4x4 matrix
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.24*, a transformation matrix is a grid of numbers. Although
    it is a common term, we rarely use this matrix directly in scripts. This is because
    the calculation of the matrix is relatively cumbersome, and Unity, as an easy-to-use
    game engine, has encapsulated the complex calculations in the `Transform` class
    for us, and we only need to call some functions. Therefore, in this section, we
    only give a brief introduction to the transformation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, you should know that transformations include translation, rotation,
    scaling, and these operations can be represented as matrices. We will discuss
    them one by one in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Translation matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can move an object by using a translation matrix. The following diagram
    shows a translation matrix and how to move the original vector by multiplying
    the translation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Translation matrix (CC BY 4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.25 – Translation matrix (CC BY 4.0)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a C# script and demonstrate how to move an object by using a
    matrix directly in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this code snippet, we used four `Vector4` instances to create
    an instance of the `Matrix4x4` struct. It should be noted here that each `Vector4`
    we used to create the matrix represents a column of the matrix, not a row. Therefore,
    the code creates a matrix, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Creating a matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.26 – Creating a matrix
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculated the new position of the object by calling the `MultiplyPoint`
    function of `Matrix4x4`, where the parameter is the original position of the object.
    Finally, we set the position of the object to this new vector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Changing the position of the object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.27 – Changing the position of the object
  prefs: []
  type: TYPE_NORMAL
- en: If we create an object at the origin and run this script, the result will be
    that the object is moved to the point (3, 2, 1), as shown in *Figure 7.27*.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, a matrix can also be used to rotate an object, that is, a rotation
    matrix. This time, we also need to create an instance of `Matrix4x4` in the C#
    script, but instead of calling its constructor, we call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Rotate` function is a static function of `Matrix4x4`, and it creates and
    returns a rotation matrix. This function requires a quaternion-type parameter.
    We will introduce quaternions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some code to rotate the object by using `Matrix4x4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code will move the point from its original position to a place rotated
    90 degrees around the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Rotation matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.28 – Rotation matrix
  prefs: []
  type: TYPE_NORMAL
- en: Let's set the original position of this object to (1, 0, 0) and then run the
    code. The new position of this object should be (0, 0, -1), as shown in the preceding
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – The real result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.29 – The real result
  prefs: []
  type: TYPE_NORMAL
- en: After running the code, we can see that the real result is consistent with what
    we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we scale a vector, we will keep its direction unchanged and change the
    length by the amount we want to scale. We can also use a scaling matrix to scale
    a point away from the origin. You can imagine that a model is composed of many
    vertices. When we scale a model, we actually extend or shrink the positions of
    the vertices that make it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity also provides us with the following function to directly create a scaling
    matrix in a C# script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Matrix4x4`, and it creates and returns a scaling matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In order to demonstrate how to apply a scaling matrix to a point, we created
    the preceding code snippet. As you can see in the code, we created a new `Vector3`
    to present the scaling factors. Then, we created a scaling matrix by calling the
    `Matrix4x4.Scale` function and finally, we applied this matrix to a point.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new GameObject in the Scene and locate this GameObject at the
    position (1, 1, 0).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – GameObject at (1, 1, 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.30 – GameObject at (1, 1, 0)
  prefs: []
  type: TYPE_NORMAL
- en: Then, attach this script to it and run the script.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – Apply the scaling matrix to this object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.31 – Apply the scaling matrix to this object
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.31*, the new position of this object is (3, 2, 0). This
    is because this scaling matrix increases the point three times along the *x* axis
    from its original position and two times along the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Scaling a point'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.32 – Scaling a point
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this section, in Unity development, matrix
    operations are relatively low-level operations. Unity has provided us with many
    functions to cover up the complexity of matrices. Developers don't often use matrices
    directly, but as an important concept, we still need to understand some concepts
    around them. However, when it comes to object rotation, Unity often uses another
    type to save rotation data. If you are interested in this, let's continue to explore
    **quaternions**.
  prefs: []
  type: TYPE_NORMAL
- en: Working with quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, the rotation of a transform is stored internally as a **quaternion**,
    which has four componenets, namely *x*, *y*, *z*, and *w*. However, these four
    components do not represent angles or axes, and we developers usually do not need
    to access them directly. You may be confused because if you look at the Inspector
    window of a transform, you will find the rotation is displayed as a Vector3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Rotation property in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.33 – Rotation property in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: This is because although Unity uses quaternions to store rotations internally,
    in addition to quaternions, rotations can also be represented by three angle values
    of *x*, *y*, and *z*, namely **Euler angles**.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for the convenience of developers to edit, Unity displays the value
    of the equivalent Euler angle in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: So, why doesn't Unity use Euler angles to store rotations directly? It is composed
    of three axes angles and is in a format that is easy for humans to read. This
    is because the Euler angle is affected by the **gimbal lock**, which means that
    the "degree of freedom" is lost.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using quaternion rotation will not cause the gimbal lock
    issue. Therefore, Unity uses quaternions to store rotations internally. But what
    you have to remember is that the four components of a quaternion do not represent
    angles, so we will not modify the value of a component individually, and it is
    very complicated to modify a quaternion directly. Fortunately, Unity provides
    us with many built-in C# functions in the `Quaternion` struct to manage quaternion
    rotations easily. It is our best choice to use the `Quaternion` structure and
    its functions to manage the rotation values in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We can divide these functions into three groups according to their purpose,
    namely creating rotations, manipulating rotations, and working with Euler angles.
    Let's explore them next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating rotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function we will introduce is `LookRotation` and the function signature
    of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a static function; you can pass in parameters to specify the forward
    and upward direction for it, and it will return the correct rotation value according
    to the passed-in parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we set up a Scene in which there are two objects,
    named `target` and `player`, and created a new C# script called `LookAtScript.cs`.
    We then attached this script to the player object, as shown in *Figure 7.34*.
    The blue cube represents the player and the red sphere represents the target object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – Objects in the Scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.34 – Objects in the Scene
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following script, we demonstrate how to implement the function that
    the player always faces the target object no matter where the target moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we calculated the direction from the player to the target. Next, we called
    the `Quaternion.LookRotation` function to calculate the rotation value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35 – The player facing the target'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.35 – The player facing the target
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we moved the target object and the player also moved to face the target,
    as shown in *Figure 7.35*.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating rotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some functions that are used to manipulate rotations and `Quaternion.Slerp`
    is one of them. The following is the function signature of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a static function. The result of calling `Quaternion.Slerp` is that
    the object will start to rotate, slower, then faster in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we still use the Scene we set up earlier, this time
    creating a new C# script called `OrbitScript.cs`. Then, we will attach this script
    to the player object to implement a gravity orbit effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36 – Attaching the script to the GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.36 – Attaching the script to the GameObject
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `OrbitScript.cs` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we reused some code from `LookAtScript.cs`. We also first calculated
    the angle of the player toward the target. But unlike the previous script, we
    did not directly modify the player's rotation, but saved the target rotation and
    the player's current rotation with two temporary variables, namely `targetRotation`
    and `currentRotation`. Then, the `Quaternion.Slerp` function was called to make
    the player gradually turn to the target, which is also the key to achieving the
    effect of gravity orbit. Finally, we called the `transform.Translate` function
    to keep the player moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37 – Running the game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.37 – Running the game
  prefs: []
  type: TYPE_NORMAL
- en: If we run the game, we will find that the player will move around the target
    and turn to face the target, as shown in *Figure 7.37*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Euler angles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If in some cases you prefer to use Euler angles instead of quaternions, Unity
    allows you to convert Euler angles to a quaternion, but you should not retrieve
    Euler angles from a quaternion and apply it to the quaternion after modifying
    it, because this may cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: '`Quaternion.Euler` is one of these functions that we can use to convert Euler
    angles into quaternions. The following is its function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function requires a `Vector3`-type parameter, which provides the angle
    around the *x* axis, the angle around the *y* axis, and the angle around the *z*
    axis. Based on this data, this function returns the corresponding quaternion rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to use Euler angles in the script
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we created Euler angles that rotate around the *x* axis, and then
    called the `Quaternion.Euler` function to convert Euler angles into quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38 – Converting Euler angles into quaternions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.38 – Converting Euler angles into quaternions
  prefs: []
  type: TYPE_NORMAL
- en: Attach this script to a cube and run the game. You will find the cube rotates
    around the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced you to quaternions and explored how to use quaternions
    correctly in Unity scripts. It should be noted that in Unity, rotation can not
    only be represented by quaternions, but also by Euler angles. When Euler angles
    are used to represent rotation, its format is easy for humans to read, but due
    to the influence of the gimbal lock, Unity still uses quaternions to save rotations
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter first introduced the concept of the coordinate system in computer
    graphics, and then discussed the coordinate system used by Unity. Then, we discussed
    the concept of vectors and how to perform vector operations such as vector addition,
    vector subtraction, dot product, and cross product in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced the concept of a matrix and demonstrated how to use a matrix
    to translate, rotate, and scale in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored how to create rotations and manipulate rotations in quaternions,
    and demonstrated how to use Euler angles in the script correctly.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this chapter, you should now have a bit more mathematical knowledge
    about computer graphics. In the next chapter, we will introduce the Scriptable
    Render Pipeline in Unity.
  prefs: []
  type: TYPE_NORMAL
