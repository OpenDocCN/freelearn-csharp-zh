- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core Fundamentals (Part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18971_03.xhtml#_idTextAnchor130), we learned about three
    important components in ASP.NET Core: routing, configuration, and environment.
    Next, let’s continue to explore the other components in ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core provides a flexible logging API that works with many logging providers.
    We can send and store the logs in various destinations, such as the console, text
    files, Azure Application Insights, and so on. When the application has issues,
    logs can help us find out what is going on. Logging belongs to a bigger topic
    called *observability*, which is a set of practices that help us understand the
    state of the application. In this chapter, we will learn how to use the logging
    API in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a component that can be plugged into the request pipeline to handle
    requests and responses. It is one of the most important improvements in ASP.NET
    Core compared to the traditional ASP.NET framework. The request pipeline is a
    chain of middleware components, and each of these components can do something
    with the request or response, or pass it to the next middleware component in the
    pipeline. In this chapter, we will learn how to use built-in middleware components
    and how to develop custom middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the logging API to log messages,
    set up log levels, and configure log providers. Additionally, you will be able
    to develop custom middleware components to process requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4).
    You can use VS 2022 or VS Code to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is an important part of any application. A well-designed logging system
    can capture data that helps you diagnose problems and monitor the application
    in production. Logging gives you insight into how, when, where, and why significant
    system events occurred so that you know how the application is performing and
    how users are interacting with it. Logging may help you to identify security weaknesses
    or potential attacks. Logging can also help you audit users activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging should not impact the performance of the application. It should be
    fast and efficient. It should not affect any logic of the application. When you
    add logging to an application, you should consider the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: What information should be logged?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What format should log messages be in?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should log messages be sent?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long should log messages be kept?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make sure log messages won’t impact the performance of the application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will discuss how to use the logging system in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project to learn how to use the logging API. Create a new
    ASP.NET Core web API project named `LoggingDemo` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the source code named `LoggingDemo` from the `samples/chapter4`
    folder in the chapter’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in logging providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core supports a logging API that works with various logging providers,
    including built-in logging providers and third-party logging providers. The default
    ASP.NET Core web API template has the following logging providers registered:'
  prefs: []
  type: TYPE_NORMAL
- en: Console logging provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug logging provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventSource` logging provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventLog` logging provider (Windows only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To clearly see how these logging providers work, let’s remove all the pre-registered
    logging providers and then add the console logging provider. Open the `Program.cs`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, only the console logging provider is enabled. Let''s use the console logging
    provider to output log messages. Open the `WeatherForecastController.cs` file;
    you can see the `ILogger<WeatherForecastController>` interface is injected into
    the constructor already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `WeatherForecastController.cs` file in the project. Add the following
    code to the `Get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application using the `dotnet run` command. Request the `/WeatherForecast`
    endpoint using the browser. You can see the log message in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application in VS 2022 and run the application using the *F5*
    key, you can see a log message in the console window, but you cannot see it in
    the **Output** window of VS 2022:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Output window for debug messages in VS 2022](img/B18971_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Output window for debug messages in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'To send logging messages to the `Debug` logging provider. Open the `Program.cs`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *F5* to run the application in VS 2022 again. Now, you can see the log
    message in the **Output** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Debug logging messages in VS 2022](img/B18971_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Debug logging messages in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: So, if want to add more other logging providers, we can call the extension methods
    of the `ILoggingBuilder` interface. Some third-party logging providers also provide
    the extension methods of the `ILoggingBuilder` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to write the log messages to the Windows event log,
    we can add the `EventLog` logging provider. Add the following code to the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Test the application and we should be able to see the log messages in the Windows
    event log.
  prefs: []
  type: TYPE_NORMAL
- en: Wait – why can’t we see it in the event log?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a specific scenario for the `EventLog` logging provider. Because it
    is a Windows-only logging provider, it does not inherit the default logging provider
    settings. We need to specify the logging level in the `appsettings.json` file.
    Open the `appsettings.Development.json` file and update the `Logging` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add an `EventLog` section to specify the logging level for the `EventLog`
    logging provider. If it is not specified, the default logging level is `Warning`,
    which is higher than `Information`. This would result in us not being able to
    see `Information` logging messages. Run the application again, and now we can
    see the log messages in the event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Event log on Windows](img/B18971_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Event log on Windows
  prefs: []
  type: TYPE_NORMAL
- en: We just introduced a new term – **logging level**. What is it?
  prefs: []
  type: TYPE_NORMAL
- en: Logging levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we used a `Log` method that accepts a `LogLevel`
    parameter. The `LogLevel` parameter indicates the severity of the log message.
    The `LogLevel` parameter can be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Trace` | `0` | Used for the most detailed messages. These messages may contain
    sensitive application data. These messages are disabled by default and should
    never be enabled in a production environment. |'
  prefs: []
  type: TYPE_TB
- en: '| `Debug` | `1` | Used for debugging information and development. Use with
    caution in production because of the high volume. Normally, these logs should
    not have a long-term value. |'
  prefs: []
  type: TYPE_TB
- en: '| `Information` | `2` | Used for tracking the general flow of the application.
    These logs should have a long-term value. |'
  prefs: []
  type: TYPE_TB
- en: '| `Warning` | `3` | Used to indicate potential problems or unexpected events.
    These issues typically do not cause the application to fail. |'
  prefs: []
  type: TYPE_TB
- en: '| `Error` | `4` | Used to indicate failures in the current operation or request
    and not an application-wide failure. These errors and exceptions cannot be handled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Critical` | `5` | Used to indicate critical failures that require immediate
    attention; for example, data loss scenarios. |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | `6` | Used to specify a logging category that should not write messages.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Logging levels
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the method call, the `ILogger<TCategoryName>` interface provides
    the following extension methods to log messages for different logging levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LogTrace()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogDebug()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogInformation()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogWarning()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogError()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogCritical()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the `LogInformation()` method to replace the `Log()` method in
    the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You will see the same log message in the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a `LogTrace()` method in the `WeatherForecastController.cs` file,
    which will send a `Trace` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application using `dotnet run` and request the `WeatherForecast` endpoint
    again. You will not see the trace message in the console window. Why? Because
    the trace message is disabled by default. Open the `appsettings.json` file; we
    can find the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Based on the configuration, the default logging level is `Information`. Look
    back at the logging level table we introduced before. The `Trace` logging level
    is 0, which is less than the `Information` logging level. So, the `Trace` logging
    level will not output by default. To enable the `Trace` logging level, we need
    to change the `Default` logging level to `Trace`. But there is another question
    – should we enable `Trace` logging for all environments?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is *it depends*. The `Trace` logging level is used for the most
    detailed messages, which means it may contain sensitive application data. We can
    enable `Trace` logging in the development environment, but we may not want to
    enable it in the production environment. To achieve this, we can use the `appsettings.Development.json`
    file to override the `appsettings.json` file. That is what we learned in [*Chapter
    3*](B18971_03.xhtml#_idTextAnchor130). Open the `appsettings.Development.json`
    file and update the following configuration to enable the `Trace` log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application again. You should be able to see a trace message in
    the console window for the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To specify the logging level for the production environment, we can add an `appsettings.Production.json`
    file, and then override the settings for the `Logging` section.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the logging levels such as `Trace`, `Debug`, and `Information`
    will produce a lot of log messages. If we need to enable them in the production
    environment for troubleshooting, we need to be careful. Think about where we want
    to store logging messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that in the `appsettings.json` file, there is a `Microsoft.AspNetCore`
    logging section. It is used to control the logging level for the ASP.NET Core
    framework. ASP.NET Core uses the category name to differentiate logging messages
    produced from the framework and the application. Check the code where we inject
    the `ILogger` service into the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ILogger<TCategoryName>` interface is defined in the `Microsoft.Extensions.Logging`
    namespace. The `TCategoryName` type parameter is used to categorize log messages.
    You can use any string values for the category name, but using the class name
    as the logging category name is a common practice.
  prefs: []
  type: TYPE_NORMAL
- en: Logging parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These `Log{LOG LEVEL}()` methods have some overloads, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Log{LOG LEVEL}(string? message, params` `object?[] args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log{LOG LEVEL}(EventId eventId, string? message, params` `object?[] args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log{LOG LEVEL}(Exception exception, string message, params` `object[] args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log{LOG LEVEL}(EventId eventId, Exception? exception, string? message, params`
    `object?[] args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters of these methods are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `eventId` parameter is used to identify the log message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `message` parameter is used as a format string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `args` parameter is used to pass arguments for the format string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exception` parameter is used to pass the exception object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can define an `EventIds` class to identify log messages, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `eventId` parameter to identify log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Some logging providers can use the `eventId` parameter to filter log messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have introduced how to use the `message` parameter. You can use a plain
    string as the message, or you can use a format string and use the `args` parameter
    to pass arguments for the format string. Here is an example that uses the `message`
    and `args` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If an exception occurs, you can use the `LogError()` method with the `exception`
    parameter to log the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When using the `LogError()` method to log an exception, it is important to pass
    the exception object to the `exception` parameter. This is essential in order
    to preserve stack trace information; simply logging the exception message is not
    sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party logging providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logging system in ASP.NET Core is designed to be extensible. The default
    logging providers, including the console logging provider and the `Debug` logging
    provider, can output logging messages in the console window or debug window, which
    is convenient for development. But in the production environment, we may want
    to send log messages to a file, a database, or a remote logging service. We can
    use third-party logging providers to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many third-party logging frameworks or libraries that work with ASP.NET
    Core, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logging provider** | **Website** | **GitHub repo** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Serilog` | [https://serilog.net/](https://serilog.net/) | [https://github.com/serilog/serilog-aspnetcore](https://github.com/serilog/serilog-aspnetcore)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NLog` | [https://nlog-project.org/](https://nlog-project.org/) | [https://github.com/NLog/NLog.Extensions.Logging](https://github.com/NLog/NLog.Extensions.Logging)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `log4net` | [https://logging.apache.org/log4net/](https://logging.apache.org/log4net/)
    | [https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore](https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore)
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Third-party logging providers
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other platforms provide rich features for collecting and analyzing the
    log messages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceptionless** ([https://exceptionless.com/](https://exceptionless.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ELK** **Stack** ([https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sumo** **Logic** ([https://www.sumologic.com/](https://www.sumologic.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seq** ([https://datalust.co/seq](https://datalust.co/seq))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sentry** ([https://sentry.io](https://sentry.io))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These platforms can provide a dashboard to view log messages. Technically, they
    are not just logging providers but also platforms for observability that contain
    logging, tracing, metrics, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple example. How can we print logging messages to a file?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use **Serilog** to write the log messages to a file. Serilog is a popular
    logging framework that works with .NET. It provides a standard logging API and
    a rich set of sinks that write log events to storage in various formats. These
    sinks target a variety of destinations, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Application Insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Blob Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Cosmos DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon CloudWatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Kinesis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptionless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sumo Logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Serilog provides a `Serilog.AspNetCore` NuGet package that integrates with
    ASP.NET Core. It has a set of extension methods to configure the logging system.
    To use it, install the `Serilog.AspNetCore` NuGet package by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s use the `Serilog.Sinks.File` sink to write log messages to a file.
    Install the `Serilog.Sinks.File` NuGet package with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `Program.cs` file to configure the logging system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first clear the default logging providers. Then, we
    create a `Serilog.ILogger` instance and add it to the logging system. The `WriteTo.File`
    method is used to configure the `Serilog.Sinks.File` sink. It will write log messages
    to a file named `log.txt` in the `logs` folder. The `rollingInterval` parameter
    is used to specify the rolling interval. In the current example, we set it up
    as daily. The `retainedFileCountLimit` parameter is used to specify the maximum
    number of log files to keep. In this case, we have kept the number of files to
    90\. Then, we call the `CreateLogger` method to create a `Serilog.ILogger` instance.
    Finally, we call the `AddSerilog()` method to add the `Serilog.ILogger` instance
    to the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to change the code that uses the `ILogger` service. The `ILogger`
    service is still injected into the controller. The only difference is that log
    messages will be written to a file instead of the console window.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application again and request the `/WeatherForecast` endpoint. You should
    be able to see log messages in the `logs/log.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you write logging messages to a file, please make sure that there is enough
    disk space and that proper retention policies are set. Otherwise, the disk space
    may get exhausted. Also, it is recommended to use some professional logging systems
    for monitoring in the production environment. For example, if your application
    is deployed in Azure, you can easily integrate it with Azure Application Insights.
    Storing logging messages in a text file is not easy to manage and analyze.
  prefs: []
  type: TYPE_NORMAL
- en: If the amount of logging messages is huge, consider sending them to a message
    queue, such as RabbitMQ, and then have a separate process to consume the messages
    and write them to a database. Keep in mind that the logging system should not
    be a bottleneck for the application. Do not use asynchronous methods for logging
    because logging should be fast, and frequently switching between threads may cause
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `LoggingDemo` project, we have already configured the logging system
    to write log messages to a file. You can check the `Program.cs` file to see how
    it works. Serilog provides a rich set of sinks, and it supports various configurations
    as well. You can find more provided sinks here: [https://github.com/serilog/serilog/wiki/Provided-Sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks).'
  prefs: []
  type: TYPE_NORMAL
- en: Structured logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Logging parameters* section, we showed how we can use the `args` parameter
    to format a message string. You may wonder if we can use string concatenation
    to achieve the same outcome; for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The answer is yes and no. If you do not care about the values of the parameters,
    it does seem to work. However, a modern way to handle logs is to use **structured
    logging** instead of a plain string message. Structured logging is a way to log
    messages in a structured format. Parameters such as the day of the week are identified
    and structured so that a system can process them, which means we can perform special
    operations on them, such as filtering, searching, and so on. Let’s dive into the
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serilog efficiently supports structured logging when you use `args` parameters
    instead of string concatenation. Let’s update the `Program.cs` file to send logs
    to the console window in a structured format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Serilog supports multiple sinks in the same logging pipeline. In the preceding
    code, we add the console sink after the file sink. The console sink is automatically
    installed with the `Serilog.AspNetCore` NuGet package, so you do not need to manually
    install it. `JsonFormatter` is used to format log messages in JSON format. You
    can also specify the `formatter` type for the file sink.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `LoggingController` file, add a new action method to compare the structured
    logs and string concatenation logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the application again and request the `api/Logging/structured-logging` endpoint.
    You should be able to see log messages in the console window in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log messages with structured logging look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Log messages with string concatenation look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the structured logging has `Week` and `Time` properties, while the
    string concatenation does not. Structured logging is more flexible and easier
    to process. Therefore, structured logging is recommended instead of string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great tool to analyze structured logging messages is Seq ([https://datalust.co/seq](https://datalust.co/seq)).
    Seq is a powerful log management tool that creates the visibility you need to
    quickly identify and diagnose problems in your applications. It is a commercial
    product, but it provides a free trial. You can download it here: [https://datalust.co/download](https://datalust.co/download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it on your local machine. When you see the following window, please
    take note of the `5341`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Installing Seq](img/B18971_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Installing Seq
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure Serilog to send log messages to Seq. Serilog has
    a sink for Seq, so we can easily install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Program.cs` file, update the logging configuration to send log messages
    to Seq:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application again and request the `api/Logging/structured-logging`
    endpoint. You should be able to see log messages in Seq:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Structured logging in Seq](img/B18971_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Structured logging in Seq
  prefs: []
  type: TYPE_NORMAL
- en: 'We can search the `Week` property to filter log messages, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Filtering structured logs in Seq](img/B18971_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Filtering structured logs in Seq
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we understand why structured logging is more powerful than string concatenation
    when you send logs. Serilog provides many powerful features for logging, such
    as enrichers. You can find more information about Serilog on its official website:
    [https://serilog.net/](https://serilog.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Seq is a good choice for local development. However, you may need to purchase
    a license for your critical applications and services for better support, or you
    may want to use another logging system. Please carefully consider your requirements
    before you choose a logging system. Don’t forget that we can use configurations
    to switch between different logging systems for different environments.
  prefs: []
  type: TYPE_NORMAL
- en: What should/shouldn’t we log?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logging is a powerful tool to help us diagnose problems, monitor an application,
    audit a system, and so on. But logging is not free. It consumes resources and
    may slow down applications. Depending on the purpose of logging, we may need to
    log different information. Generally, there are some scenarios that we should
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: Input/output validation errors, such as invalid input parameters or invalid
    response data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application errors, exceptions, and warnings, such as database connection errors,
    network errors, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application startup and shutdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-risk operations, such as deleting a record from the database, changing
    a user’s password, transferring money, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legal compliance, such as auditing, terms of service, personal data consent,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical business events, such as a new order being placed, a new user being
    registered, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any suspicious activities, such as brute-force attacks, account lockouts, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What information should we log? If the information in the log message is not
    sufficient to diagnose the problem, it would be useless. Generally, we should
    log the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When**: What time did the event happen?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Where**: What is the application name and version? What is the hostname or
    IP address? What is the module or component name?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who**: Which user or client is involved in the event? What is the username,
    request ID, or client ID?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What**: What is the event? What severity level does the event have? What
    is the error message or stack trace? Any other descriptive information?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may need to include more information based on the requirements. For example,
    for web API applications, we also need to log the request path, HTTP method, headers,
    status code, and so on. For database applications, we may need to log the SQL
    statement, parameters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some information that we should not log:'
  prefs: []
  type: TYPE_NORMAL
- en: Application source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive application information, such as application secrets, passwords, encryption
    keys, database connection strings, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive user information, such as **personally identifiable information**
    (**PII**); for example, health status, government identification, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bank account information, credit card information, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information that users do not consent to share
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other information that may violate the law or regulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have explained the basics of logging in ASP.NET Core. Next, we will learn
    another important component of ASP.NET Core: middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce middleware, which is one of the most important
    improvements in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow this section, you can run the following command to create a new ASP.NET
    Core web API project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can download the example project named `MiddlewareDemo` from the chapter’s
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core is a middleware-based framework. An ASP.NET Core application is
    built upon a set of middleware components. Middleware is a software component
    that is responsible for handling requests and responses. Multiple middleware components
    form a pipeline to process requests and generate responses. In this pipeline,
    each middleware component can perform a specific task, such as authentication,
    authorization, logging, and so on. Then, it passes the request to the next middleware
    component in the pipeline. It is a huge improvement over the traditional ASP.NET
    framework, which is based on the HTTP module and HTTP handler. In this way, the
    ASP.NET Core framework is more flexible and extensible. You can add or remove
    middleware components as needed. You can also write your own middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a middleware pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Middleware pipeline](img/B18971_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Middleware pipeline
  prefs: []
  type: TYPE_NORMAL
- en: A middleware component can perform tasks before and after the next middleware
    component in the pipeline. It can also choose whether to pass the request to the
    next middleware component or stop processing the request and generate a response
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see an example. Open the `MiddlewareDemo` project in VS Code. Add the
    following code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `builder.Build()` returns a `WebApplication` instance.
    It is the host for the web API project, which is responsible for app startup and
    lifetime management. It also manages logging, DI, configuration, middleware, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application with `dotnet run` or `dotnet watch`, and you will see all
    requests will return a `Hello world!` response, regardless of the URL. This is
    because the `app.Run()` method handles all requests. In this case, the middleware
    short-circuits the pipeline and returns the response directly. We can also call
    it *terminal middleware*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use multiple middleware components, we can use the `app.Use()` method. The
    `app.Use()` method adds a middleware component to the pipeline. Update the `Program.cs`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and request the `/weatherforecast` endpoint. You can see
    the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WebApplication` instance uses an `app.Use()` method to add a simple middleware
    component to the pipeline. The middleware component is an anonymous function that
    takes two parameters: `context` and `next`. Let’s take a closer look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: The `context` parameter is an instance of the `HttpContext` class that contains
    request and response information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `next` parameter is a delegate that is used to pass the request to the next
    middleware component in the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `await next()` statement passes the request to the next middleware component
    in the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This middleware does not do anything with the request and response. It only
    outputs some information to the console. Let us add another middleware component
    to the pipeline. Update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we add two middleware components to the pipeline. The first
    middleware component adds a `ClientName` HTTP header to the request. The second
    middleware component sets the response status code to `202 Accepted`. Run the
    application and request the `/weatherforecast` URL. You will see the following
    output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The original request does not contain the `ClientName` HTTP header. So, the
    value of the `ClientName` HTTP header in `Middleware 1` is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before `Middleware 1` passes the request to `Middleware 2`, `Middleware 1` adds
    the `ClientName` HTTP header to the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Middleware 1` does not output `My Middleware 1 - After` to the console after
    its `await next(context);` code. Instead, `Middleware 2` outputs the `ClientName`
    HTTP header value to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Middleware 2` changes the response status code to `202 Accepted`. The response
    will be passed to `Middleware 1`. Then, `Middleware 1` outputs `My Middleware
    1 - After` with the new response status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That indicates how middleware components work in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: How to assemble middleware components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the `app.Use()` method, the `WebApplication` class also provides `Map()`,
    `MapWhen()`, `UseWhen()`, and `Run()` methods to add middleware components to
    a pipeline. The following table shows the differences between these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app.Map()` | Maps a request path to a sub-request pipeline. The middleware
    component is only executed when the request path matches the specified path. |'
  prefs: []
  type: TYPE_TB
- en: '| `app.MapWhen()` | Runs a sub-request pipeline when a given predicate is matched.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `app.Use()` | Adds an inline delegate to the application’s request pipeline.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `app.UseWhen()` | Adds an inline delegate to the application’s request pipeline
    when a given predicate is matched. It is rejoined to the main pipeline if it does
    not short-circuit or contain terminal middleware. |'
  prefs: []
  type: TYPE_TB
- en: '| `app.Run()` | Adds a terminal middleware component to the pipeline. It prevents
    further middleware components from processing requests. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – The differences between the app.Map(), app.MapWhen(), app.Use(),
    app.UseWhen(), and app.Run() methods
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle a request, we use `app.Map()` or `app.MapWhen()` to configure which
    request path (or predicate) should be handled by which middleware component. The
    `app.Use()` and `app.Run()` methods are used to add middleware components to the
    pipeline. One pipeline can have multiple `app.Use()` methods. But only one `app.Run()`
    method is allowed in one pipeline, and the `app.Run()` method must be the last
    method in the pipeline. The following diagram illustrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run()
    methods](img/B18971_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run()
    methods
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example. We will develop a lottery application that allows users
    to call an API to check whether they get the lucky number. Lucky numbers are generated
    randomly. We will add a couple of middleware components to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fun lottery program. Let’s see how it is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use the `app.Map()` method to map the `/lottery` request path to
    a sub-request pipeline. In this part, there are a couple of things to do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a `Random` instance to generate a lucky number. Note that this number
    is generated only once when the application starts.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add a middleware component to the pipeline using the `app.UseWhen()`
    method. This middleware works only when the request has a query string. If the
    query string is the same as the lucky number, it uses `app.Run()` to write the
    response. This branch is done.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we add another middleware component when the request does not have a
    query string. This middleware consists of two sub-middleware components:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one generates a random number and adds it to the HTTP header, then
    passes it to the second sub-middleware.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one uses `app.UseWhen()` to check the HTTP headers of the request.
    If the HTTP header contains the lucky number, it uses `app.Run()` to write the
    response. This branch is done. This part shows how we use the `app.UseWhen()`
    method to rejoin a middleware component to the main pipeline.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we add a middleware component to the pipeline using the `app.Run()` method.
    This middleware component is used to handle all other requests for the `/lottery`
    URL. It writes the response to the client and shows the number that the client
    has chosen. Note that if the user already got the lucky number, this part will
    not be executed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the program, we have another middleware component using the `app.Run()`
    method. This middleware component is used to handle all other requests. It shows
    how to play the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application and request the `/lottery` endpoint a couple of times. Sometimes,
    you will see you win the lottery. Or, you can include a query string in the URL,
    such as `/lottery?1`. You should be able to notice that the lucky number is the
    same for all requests. If you restart the application, the lucky number may change,
    because it is generated randomly when the application starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: A middleware component is initialized only once when the application starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix the `app.Map()`, `app.MapWhen()`, `app.Use()`, `app.UseWhen()`,
    and `app.Run()` methods in one pipeline. But be careful to use them in the right
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.Run()` must be the last method in a pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot change the response after `await next();` or `await next.Invoke();`
    is called because it may cause a protocol violation or corrupt the response body
    format. For example, if the response has been sent to the client, if you change
    the headers or the status code, it will throw an exception. If you want to change
    the response, please do so before `await next();` or `await next.Invoke();` is
    called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may wonder what the difference between `app.MapWhen()` and `app.UseWhen()`
    is. Both of them are used to configure a conditional middleware execution. The
    differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.MapWhen()`: Used to branch the request pipeline based on the given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.UseWhen()`: Used to conditionally add a branch in the request pipeline
    that is rejoined to the main pipeline if it does not short-circuit or contain
    a terminal middleware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To clarify the difference, update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application using `dotnet run` and request the `http://localhost:5170/?branch=1`
    URL. You will see the console window outputs the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And the response is `Hello world!`. If you request any other URL, such as `http://localhost:5170/test`,
    you will still see a `Hello world!` response. But you will not see the console
    window that outputs the log message. That says `app.UseWhen()` only works when
    the predicate is `true`. If the predicate is `false`, the pipeline will continue
    to execute the next middleware component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us try to change `app.UseWhen()` to `app.MapWhen()`. Update the `Program.cs`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and request the `http://localhost:5170/?branch=1` URL again.
    You will see a log message in the console window, but it returns a `404` error!
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: That is because the `app.MapWhen()` method is used to branch the request pipeline
    based on the given predicate. If the predicate is `true`, the request pipeline
    will be branched to the sub-pipeline defined in this `app.MapWhen()` method. But
    when the `next()` method is called, it does not have a next middleware component
    to execute, even though there is an `app.Run()` method defined at the end of the
    program. So, it returns a `404` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it work, we need to add another `app.Run()` method to the sub-pipeline.
    Update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application again and request the `http://localhost:5170/?branch=1`
    URL. You can see the logging message is `From MapWhen(): Branch used = 1`, and
    the response is returned as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: The middleware mechanism is very powerful. It makes the ASP.NET Core application
    incredibly flexible. But it may cause issues if you make incorrect orders. Please
    use it wisely.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced how to apply middleware components using delegate
    methods. ASP.NET Core provides a lot of built-in middleware components to simplify
    development. In the next section, we will explore some of the built-in middleware
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core framework provides a lot of built-in middleware components. Check
    the code of the `Program.cs` file. You can find some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some middleware components to enable Swagger, HTTPS redirection,
    authorization, and so on. You can find a full list of built-in middleware components
    here: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common built-in middleware components. Note the **Order** column.
    Some middleware components must be called in a specific order. Some middleware
    may terminate the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Middleware** | **Description** | **Order** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication | Enables authentication support. | Before `HttpContext.User`
    is needed. Terminal for OAuth callbacks. |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization | Enables authorization support. | Immediately after the Authentication
    middleware. |'
  prefs: []
  type: TYPE_TB
- en: '| CORS | Configures **cross-origin resource** **sharing** (**CORS**). | Before
    components that use CORS. `UseCors` currently must go before `UseResponseCaching`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Health Check | Checks the health status of the application and its dependencies.
    | Terminal if a request matches a health check endpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| HTTPS Redirection | Redirects all HTTP requests to HTTPS. | Before components
    that consume the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| Response Caching | Enables response cache. | Before components that require
    caching. `UseCors` must come before `UseResponseCaching`. |'
  prefs: []
  type: TYPE_TB
- en: '| Endpoint Routing | Defines and constrains request routes. | Terminal for
    matching routes. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Common built-in middleware components
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover all the built-in middleware components in this book. But we
    will introduce some of them in the following sub-sections, such as rate-limiting,
    request timeouts, short-circuits, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using the rate-limiting middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rate-limiting middleware is a new built-in middleware provided in ASP.NET
    Core 7\. It is used to limit the number of requests that a client can make in
    a given time window. It is very useful to prevent **distributed denial-of-service**
    (**DDoS**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rate-limiting middleware defines four policies:'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliding window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section is just to introduce how to use the middleware, so we will not
    cover details of the policies. We will use the fixed window policy in this section.
    This policy uses a fixed time window to limit the number of requests. For example,
    we can limit the number of requests to 10 per 10 seconds. When the time window
    expires, a new time window starts, and the counter is reset to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds the rate-limiting middleware to a minimal API request
    pipeline. It creates a fixed window policy named `fixed`. The `options` property
    means a maximum of 5 requests per each 10-second window are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and request the `http://localhost:5170/rate-limiting-mini`
    URL 10 times. You will see the response is `Hello 638005...`. But the sixth request
    will be pending until the time window expires. You can try other policies if you
    want. To practice more, you can move the configuration for the policy to the `appsettings.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this rate-limiting middleware to a controller-based API, we need to
    add the `EnableRateLimiting` attribute to the controller or action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will introduce another built-in middleware component: the request
    timeout middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the request timeouts middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Core 8 introduces the request timeout middleware, which allows developers
    to set a timeout for an endpoint. If the request is not completed within the allotted
    time, a `HttpContext.RequestAborted` cancellation token is triggered, allowing
    the application to handle the timeout request. This feature helps to prevent the
    application from being blocked by long-running requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the request timeout middleware to the ASP.NET Core web API project,
    update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The request timeout middleware can be used for a specific endpoint. To do this,
    we need to add the `EnableRequestTimeout` attribute to the controller or action,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `RequestTimeout` attribute to set the timeout
    to 5 seconds. In the action method, we use a `Task.Delay()` method to simulate
    a long-running task. The delay time is generated randomly. If the request is not
    completed within 5 seconds, a `Request.HttpContext.RequestAborted` cancellation
    token is triggered. Then, we can handle the timeout request in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application using the `dotnet run` command and request the `/api/request-timeout`
    endpoint a few times. Sometimes, you will get a `503` response. Note that the
    request timeout middleware does not work in the debug mode. To test this middleware,
    please ensure that the debugger is not attached to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you want to apply this middleware to a minimal API, you can use
    the `WithRequestTimeout` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The timeout configuration can be configured with a policy. Then, we can apply
    the policy to the controller or action. Update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines three timeout policies. `DefaultPolicy` is used
    when no policy is specified. `ShortTimeoutPolicy` is used for short-running requests
    with a timeout of 2 seconds, while `LongTimeoutPolicy` is used for long-running
    requests with a timeout of 10 seconds. To apply the policy to the controller or
    action, the `EnableRequestTimeout` attribute can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the action method does not specify a policy, `DefaultPolicy` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the short-circuit middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The short-circuit middleware is another new middleware component introduced
    in ASP.NET Core 8\. This middleware is used to short-circuit a request when it
    is not necessary to continue processing the request. For example, web robots may
    request the `/robots.txt` file to check if the website allows crawling. As a web
    API application, we do not need to process this request. However, the execution
    of the request pipeline will still continue. The short-circuit middleware can
    be used to short-circuit the request and return a response directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the short-circuit middleware to a specific endpoint, add the following
    code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `ShortCircuit()` method to short-circuit the request.
    If the request path is `/robots.txt`, it will return a text/plain response directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use the short-circuit middleware is to use `MapShortCircuit`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when a request is made to `/robots.txt` or `/favicon.ico`,
    a `404 Not Found` response will be returned directly. This ensures that the server
    is not burdened with unnecessary requests.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The short-circuit middleware should be placed at the start of the pipeline to
    prevent other middleware components from processing the request unnecessarily.
    This will ensure that the request is handled in the most efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core provides a wide range of built-in middleware components. These
    components use extension methods such as `AddXXX()` and `UseXXX()` to add middleware
    components to the pipeline. In the following section, we will explore how to create
    a custom middleware component and apply it to the pipeline using an extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom middleware component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the built-in middleware cannot meet your requirements, you can create your
    own middleware components. A custom middleware component does not have to derive
    from a base class or an interface. But a middleware class does need to follow
    some conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: It must have a public constructor that accepts a `RequestDelegate` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a public method named `Invoke()` or `InvokeAsync()` that accepts
    a `HttpContext` parameter and returns a `Task`. The `HttpContent` parameter must
    be the first parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use DI to inject additional dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extension method is needed to add the middleware to the `IApplicationBuilder`
    instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider this scenario. For better tracking, we want to use the concept of correlation
    ID in the application. The correlation ID is a unique identifier for each request.
    It is used to track the request through the application, especially in a microservice
    architecture. ASP.NET Core provides a `HttpContext.TraceIdentifier` property to
    store the unique identifier. By default, Kestrel generates the ID using the `{ConnectionId}:{Request
    number}` format; for example, `0HML6LNF87PBV:00000001`.
  prefs: []
  type: TYPE_NORMAL
- en: If we have multiple services, such as *Service A* and *Service B*, when the
    client calls *Service A*, *Service A* will generate a `TraceIdentifier` instance
    for the current request, then *Service A* will call *Service B*, and *Service
    B* will generate another `TraceIdentifier` instance. It is hard to track the request
    through multiple services. We need to use the same `TraceIdentifier` instance
    for the request to be tracked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to generate a correlation ID for each request chain. Then, set
    it in the `X-Correlation-Id` header for request/response as well. When we call
    *Service B* from *Service A*, attach the `X-Correlation-Id` header to the HTTP
    request headers so that we can attach the `X-Correlation-Id` value in the logs
    for future diagnostics. To do this, we need to create a custom middleware component.
    Create a new class named `CorrelationIdMiddleware` in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `CorrelationIdMiddleware` class has a public constructor
    that accepts a `RequestDelegate` parameter. It also has a public method named
    `InvokeAsync()` that accepts a `HttpContext` parameter and returns a `Task` instance.
    The `InvokeAsync()` method is the entry point of the middleware. It gets the correlation
    ID from the request header. If it is not found, it generates a new one. Then,
    it sets the `HttpContext.TraceIdentifier` property and adds the correlation ID
    to the response header. Finally, it calls the next middleware component in the
    pipeline. It also uses a logger via DI to log the correlation ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a new extension method to the `IApplicationBuilder` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can apply the correlation ID middleware in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `WeatherForecastController.cs` file and add the following code to
    the `Get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and request the `http://localhost:5170/WeatherForecast`
    URL. You will see the response header contains the `X-Correlation-Id` property,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see the correlation ID in the log, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can use the correlation ID to track the request through multiple
    services, especially in a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We did not call any other services in this example. You can have a try yourself.
    Create another service and call it from the current service. Apply the same correlation
    ID middleware in another service. It can get the `X-Correlation-Id` header from
    the request headers and continue to use it. Then, you will see the same correlation
    ID is used for each request chain in both services.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is purely for demonstration purposes. Microsoft provides
    a NuGet package called `Microsoft.AspNetCore.HeaderPropagation` that can be used
    to propagate headers to downstream services. You can find the sample code here:
    [https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample](https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample).
    You can also check [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671) to learn more
    about the distributed tracing using OpenTelemetry.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the logging framework in ASP.NET Core, and
    introduced a third-party logging framework, Serilog, to help us write logs to
    different sinks, such as files, console, and Seq, which is a tool that analyzes
    logs using structured logging. We also learned what middleware is, how to use
    the built-in middleware components, and how to create a custom middleware component.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to implement some real business logic in the next chapter. We will
    introduce **Entity Framework Core** (**EF Core**), a powerful **object-relational
    mapper** (**ORM**) framework, to help us access the database.
  prefs: []
  type: TYPE_NORMAL
