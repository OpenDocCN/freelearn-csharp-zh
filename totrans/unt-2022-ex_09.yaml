- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Object Pooling in Unity 2022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096), we imported and prepped
    artwork for use with additional 2D animation tooling, which is bringing the game
    to life. We also processed player input using an input action map – instead of
    reading device input directly – with the new Input System, and we made a `PlayerController`
    script to move the player.
  prefs: []
  type: TYPE_NORMAL
- en: We dove deeper into Mecanim as we learned how to transition between animations
    and drive animation state changes from code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to object pooling while we use this
    optimization pattern for the player’s shooting mechanic, and we’ll accomplish
    that using Unity’s object pooling API. The object pooling software design will
    be based on a pooled player shooting model UML diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The object pooling pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pooled player shooting model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create an optimized shooting mechanic
    for a ranged weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the following GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6).'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop, or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: The object pooling pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **object pooling** design pattern is a type of **creational** or **abstract
    factory** design pattern that uses a stack to hold a collection of initialized
    object instances. It is excellent for use in situations when you will have either
    a large number of objects that need to be spawned or objects that will be created
    and destroyed rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be shooting projectile objects from a weapon – which can be performed
    at a high rate by the player – this is a great place to apply object pooling because
    repeatedly instantiating and destroying objects comes with a high cost. In this
    case, object pooling provides a way to optimize CPU, memory, and **garbage** **collection**
    (**GC**).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating a new projectile object directly every time the player
    needs to shoot, we’ll instead reuse an already instantiated projectile object
    by requesting it from the objects in the pool. As such, the Object Pool provides
    methods for requesting (getting) and returning (releasing) objects. So, for example,
    for a pool of 10 projectile objects, we’ll get one at a time from the pool when
    the player shoots and return the projectile that was shot when it expires (e.g.,
    hit something).
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from our **Game Design Document** (**GDD**) in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    specifically *Table 4.1*, we defined shooting capabilities, so we’ll use object
    pooling to implement this mechanic in a performant and optimized way, using Unity’s
    new **object** **pooling** **API**.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity object pooling API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity has added a new namespace to the engine – `UnityEngine.Pool` – that includes
    several new classes to implement the object pooling pattern. For our requirement
    of a weapon to shoot bullets, we’ll use the `ObjectPool<T0>` class.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**ObjectPool<T0>**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of required actions we’ll need when working with the
    object pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Creating` (instantiating): Making a new object instance in the pool available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Getting` (requesting): Retrieving an available object instance from the pool
    (or creating and returning a new one if more are needed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Releasing` (returning): Putting an active object instance back into the pool
    for reuse when it’s finished with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destroying` (removing): Removing an instantiated object from the pool completely
    if it grows over its size limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, or by design, the `ObjectPool<T0>` class provides everything we
    need, such as creating a pool and taking and returning items to the pool. Now,
    let’s create a new object pool for our projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new object pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code that creates a new object pool of `BulletPrefab`
    projectiles (of type `ProjectileBase`; there’ll be more on this shortly in the
    *Creating the pooled player shooting* *model* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see a method (a local function in this case) declared
    for each of the required `ObjectPool` parameters, corresponding to the actions
    we listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: A local function (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The new **ObjectPool** creation code uses local functions instead of a common
    approach, using lambdas (anonymous delegates), so that we, for one, avoid unnecessary
    memory allocations. We create a local function by declaring a method inside the
    body of an already existing method; this also limits the scope of a local function
    to only being able to be called from within the method, which promotes encapsulation
    over using private member methods (we don’t need these methods outside the scope
    of setting up the object pool, and they only need to be called once).
  prefs: []
  type: TYPE_NORMAL
- en: A delegate has to be created when using a lambda, which is an unnecessary allocation
    if a local function is used. Allocations to capture local variables are also avoided,
    as local functions are really just functions; no delegates are necessary. In addition,
    calling a local function is also cheaper, and performance can be increased even
    further if in-lined by the compiler (eliminating call-linkage overhead).
  prefs: []
  type: TYPE_NORMAL
- en: Also, local functions just look better! They provide better code readability
    and verbose parameter names – a lambda anonymous delegate would obscure each parameter
    type! (Can you tell I’m just a bit biased here?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some additional reading on the subject: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some interesting design notes from when local functions were added
    to C# 7: [https://github.com/dotnet/roslyn/issues/3911](https://github.com/dotnet/roslyn/issues/3911).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve declared the following local functions within the `Start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreatePooledItem`: This will instantiate an object of type `ProjectileBase`
    when a new item is needed. This is a bullet Prefab we have a reference to on the
    player’s weapon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnGetFromPool`: We’ll use `_poolProjectiles.Get()` to return a `ProjectileBase`
    object instance, while this method calls `gameObject.SetActive(true)` to enable
    the object for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnReturnToPool`: Calling `_poolProjectiles.Release(projectile)` will execute
    `projectile.gameObject.SetActive(false)` on the object instance passed in, making
    sure it’s inactive (disabled) while sitting in the pool waiting to be retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroyPoolItem`: Calling `Destroy(projectile.gameObject)` when an item
    is removed from the pool means the object will no longer exist in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To clarify some of the preceding actions, *instantiate* means an object is created
    and exists in the Scene. When the instantiated object’s active state is `SetActive(true)`,
    it is visible in the Scene, and code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the GameObject as `SetActive(false)` will ensure that it doesn’t display
    in the Scene, and for each component, the `Update()` method will no longer be
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Additional parameters affecting the object pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond the preceding action methods, we have three additional parameters that
    affect how the pool functions. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collectionCheck`: We can save some CPU cycles if we set this parameter to
    `false`, as it won’t check whether an object was returned to the pool already
    (be cautious with this value, since it will throw errors if you try to release
    an item already in the pool).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultCapacity`: You should set this value to the number of projectiles we’ll
    generally need to have available on screen simultaneously (you can best determine
    this number by playtesting the rate of fire).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxSize`: This value will prevent the pool from growing too large and getting
    out of hand. Any instances above this number will be destroyed instead of being
    returned to the pool (exceeding the maximum size often will trigger unwanted garbage
    collection, and resizing is an expensive operation – more CPU cycles – so you’ll
    want to fine-tune this value by playtesting too).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s put our new Object Pool to good use now by implementing the shooting mechanic,
    using a pool of bullet projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: A pooled player shooting model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use an **OOP** (**object-oriented programming**) design approach to
    the player shooting setup, allowing for easy future extensibility of new types
    of weapons and projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pooled player shooting model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A pooled player shooting UML class diagram](img/B18347_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A pooled player shooting UML class diagram
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.1* presents a UML diagram. **UML** stands for **Unified Modeling
    Language**, and it’s a standardized approach to specifying and visualizing the
    relationships of artifacts within software projects. There are several types of
    UML diagrams, each serving a specific purpose. The class diagram we’re using displays
    the static structure of a system, including classes, attributes, methods, and
    their relationships. It’s one of the most widely used diagrams in software architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'UML: [https://www.uml.org/what-is-uml.htm](https://www.uml.org/what-is-uml.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: 'PlantUML Language Reference Guide: [https://plantuml.com/guide](https://plantuml.com/guide)'
  prefs: []
  type: TYPE_NORMAL
- en: 'PlantText UML Editor: [https://www.planttext.com/](https://www.planttext.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we’ve modeled the system for the pooled player shooting part of our game’s
    code, but what does it mean? Referring to the diagram in *Figure 6**.1*, let’s
    break down the structure with these points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerShootingPooled` class (*C*) – responds to `SendMessage()` of player
    input’s `OnFire()` event to shoot the weapon’s projectile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This uses the `_poolProjectiles` object, which represents the stack of instantiated
    `ProjectileBase` objects (that is, `Bullet`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets the `Bullet` (*C*) object Prefab (derived from the `ProjectileBase`
    (*A*) class type) for use in the `_poolProjectiles` (the `ObjectPool<ProjectileBase>`
    type) stack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a reference to the current ranged weapon (the `WeaponRanged` (*C*) class
    type) equipped to the player
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `WeaponRanged` class (*C*) – represents any number of ranged weapon types
    we can equip the player with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It implements the `IWeapon` (*I*) interface, meaning that we must declare the
    same members (like a contract). Therefore, any classes that implement the interface
    will have the same members available (this allows us to swap out object types
    without having to change code that consumes the interface members).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Bullet` class (*C*) is a component added to our bullet Prefab and assigned
    in the Inspector to the `WeaponRanged`-serialized `_bulletPrefab` field. The bullet
    Prefab is retrieved via the public `BulletPrefab` property (encapsulating the
    private variable) for consumption in the `PlayerShootingPooled` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This extends the inherited abstract class, `ProjectileBase` (making `Bullet`
    a subclass); we cannot instantiate a class-declared `abstract` and must instead
    use the derived class. However, members declared in the `base` class are available
    in the derived class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When we say *serializable*, we’re indicating that we’ll be able to make an assignment
    in the Inspector – a private field in most cases (in a C# script, the private
    field is decorated with the **[****SerializeField]** attribute).
  prefs: []
  type: TYPE_NORMAL
- en: After reading through the preceding details and reviewing the class diagram,
    you may have started visualizing what our code should look like `… … …`
  prefs: []
  type: TYPE_NORMAL
- en: Well, you can stop daydreaming about it now because the code follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in `Assets/Scripts`, named `PlayerShootingPooled.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ve declared the `_weapon1` variable to assign the reference to the `WeaponRanged`
    Prefab object attached to the player’s hand in the Editor (at design time). We
    also declared public variables `PoolDefaultCapacity` and `PoolMaxSize`, with default
    values of `10` and `25`, respectively, for the default and maximum sizes of our
    private `ObjectPool`, declared as `_poolProjectiles`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then use the `Start()` code from the previous *The Unity object pooling
    API* section (excluded from the preceding code) and declare an `OnFire()` method,
    to be called via `PlayerInput SendMessage()` when the player presses the *fire*
    button. Within `OnFire()`, we will provide a `Bullet` instance, returned from
    calling `_poolProjectiles.Get()`, to shoot with.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will declare the `ReturnProjectile()` method, since it will be invoked
    by the `_weapon1.Shoot()` callback when the bullet is finished… doing what bullets
    do.
  prefs: []
  type: TYPE_NORMAL
- en: A note on code architecture
  prefs: []
  type: TYPE_NORMAL
- en: When we create the pool item, we could pass a reference to **_poolProjectiles**
    and call **Release()** on it directly, but if we make this an **event**, we can
    provide **ReturnProjectile()** as a callback. Plus, we have the option of adding
    any additional callbacks. I don’t have any immediate plans for it. Still, it’s
    nice to consider the options to create a flexible approach, without having to
    refactor the code later to introduce the ability and possibly break functioning/tested
    code in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new C# script in `Assets/Scripts` named `WeaponRanged.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `WeaponRanged` script is where we’ll assign a reference to our bullet Prefab
    in the Inspector, using the serialized private field, `_bulletPrefab` – a weapon
    that shoots will require something to shoot, after all.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve kept `_bulletPrefab` encapsulated and then allowed only read (getter)
    access to the reference via the `BulletPrefab` public property. So, *encapsulation*
    here means we don’t want any other classes to have access to set a bullet reference.
    The weapon will manage its own projectiles (although we could still add functionality
    later to assign a new bullet Prefab via a public setter method, such as `WeaponRanged.SetBulletPrefab(GameObject)`
    or similar).
  prefs: []
  type: TYPE_NORMAL
- en: The `Transform` variable, `_projectileSpawn`, provides a location where we’ll
    spawn the bullet Prefab that is shot from the weapon – we will set this up in
    the `WeaponRanged 1` Prefab later.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `Shoot()` method sets the position of the projectile that the pool
    provided to the projectile spawn position, and then it calls the `Init()` method
    on it (presumably to fire it off in the correct direction by applying some force
    to it).
  prefs: []
  type: TYPE_NORMAL
- en: We will also provide a reference to `poolingReturnCallback` so that the bullet
    Prefab can be released back to the pool when it collides with another object,
    or its lifespan expires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new C# script in `Assets/Scripts/Interfaces` named `IWeapon.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `WeaponRanged` class implements the `IWeapon` interface to satisfy the contract,
    which means `WeaponRanged` must implement the `BulletPrefab` property and the
    `Shoot()` method declared in the `IWeapon` interface. Note that interface members
    in C# are public by default!
  prefs: []
  type: TYPE_NORMAL
- en: The weapon and object pooling portions of the class diagram in *Figure 6**.1*
    are now satisfied. Let’s finish up the class diagram implementation with the projectile
    that will be shot from the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in `Assets/Scripts` named `Bullet.cs`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Bullet` class extends the `ProjectileBase` class, meaning that it will
    inherit all the members and/or be required to **override** members. You can declare
    unique properties for a derived class that differentiate it from other derived
    classes (a tenet of **inheritance** in OOP design).
  prefs: []
  type: TYPE_NORMAL
- en: We’re overriding the `OnTriggerEnter2D()` method – we’re required to, since
    it’s declared as `abstract` in the inherited `ProjectileBase` class – to perform
    the specific Bullet collision action.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’re also calling the `Collided()` method in the inherited class
    by using the `base` keyword. `Collided()` is declared as `virtual`, which means
    we can redefine it in a derived class while also using it for the same basic/default
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This bit of code – `((CollideWith & (1 << collision.gameObject.layer)) != 0)`
    – in the `OnTriggerEnter2D()` method evaluates whether the GameObject the `Bullet`
    collided with is included in the layers selected in `CollideWith LayerMask`. For
    example, we’ll select *Environment*, *Wall*, *Ground*, *Enemy*, and so on, but
    not *Player* for `Bullet` to collide with.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'LayerMask: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitwise and shift operators: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how `Bullet` extends the `ProjectileBase` class (via OOP inheritance),
    so let’s have a look at the `ProjectileBase` class now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in `Assets/Scripts` named `ProjectileBase.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see our bullet projectile’s default properties and behavior. By
    declaring `ProjectileBase` as an abstract base class, it cannot be instantiated
    (made a new instance of) directly, so we must declare a new class that extends
    or inherits from it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that any derived classes can still be referenced by the base class it extends
    (in OOP, this is the **polymorphism** principle). The derived class must override
    any members declared as abstract but can optionally override members declared
    as virtual (while also being able to call base virtual methods for default behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the code’s relevant items:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations for `_rb`, `_velocity`, and `_lifetime` provide a reference
    to the `RigidBody2D` component of the projectile Prefab, as well as configurable
    values for the rate of velocity and lifetime of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `Init()` is called, the passed-in callback action is assigned to `_onCollisionAction`
    to be invoked later, and then `_rg.velocity` is set for `direction` and rate of
    `_velocity`, firing it off in the direction the weapon is pointing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we have two abstract methods that must be overridden in the derived class(es)
    (for example, `Bullet`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTriggerEnter2D()`: This Unity message event is called when another object
    collides with the object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LifetimeExpired()`: In `Init()`, we invoke this method with a delay so that
    the projectile object only exists active in the Scene for a certain amount of
    time (releasing it back to the pool to be reused). The `_lifetime` value should
    be adjusted during playtesting so that the weapon’s range works well in-game.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the `Collided()` method, which first cancels calling the `LifetimeExpired()`
    method at the `_lifetime` value (for example, as we don’t want to call `LifetimeExpired()`
    if `Collided()` was already called by a collision event) and then invokes the
    `_onCollisionAction` callback (releasing the object back to the pool).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pooled player shooting model code
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete aforementioned pooled Player shooting code can be downloaded from
    the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: Following the design model from the UML class diagram in *Figure 6**.1*, we
    have now finished writing the code portion and are ready to move on to implementing
    it with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the pooled shooting model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s see how we implement the pooled player shooting model by creating
    the required Prefabs – a weapon and a projectile – for integration with the player.
    The Prefabs we’ll need, along with the steps to create them, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bullet 1`: The first projectile Prefab asset we’ll shoot from a ranged weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `bullet1` artwork from the project files to the `Assets/Sprites`
    folder and set the PPU to `1280` (to set our larger bullet sprite to a good in-game
    size, which will be possibly adjusted later in relation to the size of the weapon
    firing the bullet). Also, set `64` for optimization, since it is a relatively
    small and fast-moving sprite.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty GameObject in the `Bullet 1`. Remember that you can easily
    parent a GameObject in the `Rigidbody2D` and `CircleCollider2D` components to
    the parent object to enable `Rigidbody2D` component, set `0`, and enable `CircleCollider2D`
    component, set `0.13`), as shown in *Figure 6**.2*:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – the bullet Prefab setup](img/B18347_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – the bullet Prefab setup
  prefs: []
  type: TYPE_NORMAL
- en: Now, add the `Bullet` script to the parent object, and assign the `Rigidbody2D`
    field by clicking and dragging the `Rigidbody2D` section title to the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Velocity** and **Lifetime** to some initial starting values, and then
    assign the layers that the bullet should collide with, using the **CollideWith**
    field (note that you may need to add a new layer before you can assign it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, drag the parent `Bullet 1` object from the `Assets/Prefabs` folder.
    Our bullet Prefab is now ready to be used with the weapon Prefab we’ll create
    next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WeaponRanged 1`: A ranged weapon that the player will hold and shoot a bullet
    projectile from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `gun1` weapon artwork, and in the Sprite Editor, set a custom pivot
    (see *A* in *Figure 6**.3*) on the handle so that when it is attached (or spawned)
    to the player, it is in the correct position and can rotate on a pivot point (as
    you might expect it to behave).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pivot | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: When working with a GameObject, the pivot serves as the reference point to position,
    rotate, and scale it. In Unity, when using the Transform tools, you can switch
    between the pivot or center of a GameObject in the Tool Settings overlay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Position GameObjects | Gizmo handle position toggles: [https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the gun sprite into the `WeaponRanged 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add a new empty GameObject, named `ProjectileSpawnPoint`, as a sibling
    to the gun sprite object that we’ll use as the **Transform** position to spawn
    the projectile. Position this GameObject at the front of the gun’s muzzle (see
    *B* in *Figure 6**.3*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup](img/B18347_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup
  prefs: []
  type: TYPE_NORMAL
- en: Now, add `WeaponRanged` as a component to the parent GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only two assignments we need to make on the `WeaponRanged` component are
    the `Bullet 1` from the `ProjectileSpawnPoint` object to the `WeaponRanged 1`
    object from the `Assets/Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our pooled player shooting model is ready to be used with the player character.
    Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Adding pooled shooting to the player character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll dig right into adding the weapon to our player. You can either make sure
    the player is in the current Scene or double-click on the `Player` Prefab in the
    **Project** window to open it up in **Prefab** Mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the player’s (actor’s) bones to ensure the weapon follows the character’s
    hand while animating. Perform the following steps to anchor the weapon to the
    player’s hand:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the hand bone under the `root_bone` hierarchy. In our case, it’s `bone_8`
    as shown in *Figure 6**.4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty GameObject as a child of `bone_8`, and name it `Weapon_Attachment`;
    this will serve as the attachment point for the weapon. Making it separate from
    the bone provides additional options for positioning/rotating. Also, naming it
    with an `_Attachment` suffix means we can easily search for any/all objects in
    the **Hierarchy** that serve as attachment points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now go ahead and drag the `WeaponRanged 1` Prefab from the `Weapon_Attachment`
    object (this becomes a nested Prefab, which means we can configure its properties
    at any time, independent of the `Player` Prefab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our player setup with the weapon in hand. In
    the following *Figure 6**.4*, you can see that I have also temporarily dragged
    in a `Bullet 1` Prefab to check its scale in relation to the weapon (seen in context
    with the player character):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The weapon Prefab added to the player](img/B18347_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The weapon Prefab added to the player
  prefs: []
  type: TYPE_NORMAL
- en: As a final step, we need to add the `PlayerShootingPooled` script as a component
    to the root object of our `Player` Prefab. Then, we will drag the `WeaponRanged
    1` object from the **Hierarchy** to the **Weapon 1** field on the component (as
    shown in *Figure 6**.4*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our Prefab components – based on the classes in our UML diagram
    – look like in the Inspector with all their respective field assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Prefab configuration for the pooled player shooting setup](img/B18347_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Prefab configuration for the pooled player shooting setup
  prefs: []
  type: TYPE_NORMAL
- en: New to Unity 2022
  prefs: []
  type: TYPE_NORMAL
- en: This may not be new specifically to the 2022 tech stream, but I believe it’s
    a workflow improvement worth mentioning. You can simultaneously open up a focused
    **Inspector** window for different assets or GameObjects, without constantly changing
    your selection and using the Inspector. First, select the object, and then either
    right-click and choose **Properties…** (at the bottom) or press *Alt/Cmd +* *P*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and playtest the results of our efforts!
  prefs: []
  type: TYPE_NORMAL
- en: Referring to *Figure 6**.4*, enter `PlayerCharacter1` object to pose the actor’s
    arm with the weapon attachment in a shooting position – using the IK `LimbSolver2D`
    target makes this easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll give the player a proper shooting animation that points the weapon in
    a direction in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151) so that we can
    target those pesky robot enemies (not that it’s their fault!).
  prefs: []
  type: TYPE_NORMAL
- en: This section taught us how to add a ranged weapon to the player by attaching
    it to a character’s limb, all while using previously created Prefabs. I can’t
    stress how important it is to understand and use a good Prefab workflow in your
    projects!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced object pooling and implemented it for the player’s shooting
    mechanic, using Unity’s object pooling API, while basing the software design on
    our pooled player shooting model UML diagram.
  prefs: []
  type: TYPE_NORMAL
- en: We finished by attaching the ranged weapon to the player, using our configured
    Prefab components.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we’ll add some juice to the player character with
    some visual effects, create some enemy NPCs (non-player characters), and finish
    by introducing enemy behavior through a state pattern.
  prefs: []
  type: TYPE_NORMAL
