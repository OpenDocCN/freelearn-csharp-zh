<html><head></head><body>
        

                            
                    <h1 class="header-title">Tactical Tips and Tricks</h1>
                
            
            
                
<p>Software engineers are an optimistic bunch and, as such, we often underestimate the amount of work it takes to fully implement new features or make changes to an existing code base. A common mistake is to only consider how long it will take to write the code that's required to create that feature. In such cases, we forget to include the time it takes for several important tasks. We often need to spend time refactoring other subsystems to support the changes we're making. This can happen either because we didn't think it would be necessary at the time, or because we thought of a better way to implement it halfway through, which can quickly turn into a rabbit hole dive of redesign and refactoring if we don't plan far ahead. We should also consider the time that's needed for testing and documentation. Even if a QA team does a testing pass against the change after it has been implemented, we still need to run through some scenarios on our own system during implementation in order to ensure that the change actually does what it's intended to do.</p>
<p>The one constant cost that's included in all performance optimization work is time. So, with limited time at our disposal to implement our features and keep everything working, an important skill for any developer to learn about is workflow optimization. Having a better understanding of the tools we use will save us more time in the long run, and hopefully provide the extra time we need to implement everything we want to, which applies not only to the Unity engine, but to every tool we use—IDEs, build systems, analytics systems, social media platforms, app stores, and so on.</p>
<p>There are a lot of little nuances to using the Unity engine that can help improve our project workflow. However, quite a lot of the Editor's functionality is not well documented, well-known, or just not something we think about until after quite some time—we realize the fact that it could have been applied perfectly to solve a particular problem we were having 6 months ago.</p>
<p>The internet is crammed full of blogs, tweets, and forum posts that try to help other Unity developers learn about these useful features, but they only tend to focus on a handful of tips at a time. There doesn't seem to be any online resources that group many of them in one place. As a result, the internet browsers of intermediate and advanced Unity developers are probably bursting at the seams with links to these tips that we bookmark for later and then completely forget about.</p>
<p>So, because this book is primarily for such users, I felt like it was worth including a short chapter to pool many of these tips and tricks together into one location. This chapter serves as a reference list in the hope of saving us time during future development efforts.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Editor hotkey tips</li>
<li>Editor UI tips</li>
<li>Scripting tips</li>
<li>Custom Editor scripts and menu tips</li>
<li>External tips</li>
<li>Other tips</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Editor hotkey tips</h1>
                
            
            
                
<p>The Editor is rife with hotkeys that can aid rapid development, and it's worth checking out the documentation. However, let's be honest—nobody reads the manual until they need something specific from it. In this section, we will go over some of the most useful, yet less well-known, hotkeys that are available when we're playing with the Unity Editor.</p>
<p>For each case we'll be looking at, the Windows hotkey is listed. If the macOS hotkey requires a different set of keystrokes, then it will be shown in parentheses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with GameObjects</h1>
                
            
            
                
<p>GameObjects can be duplicated by selecting them in the Hierarchy window and pressing <em>Ctrl</em> + <em>D</em> (<em>cmd </em>+ <em>D</em>). New, empty GameObjects can be created by pressing <em>Ctrl</em> + <em>Shift</em> + <em>N</em> (<em>cmd</em> + <em>shift</em> + <em>N</em>).</p>
<p>Press <em>Ctrl</em> + <em>Shift</em> + <em>A</em> (<em>cmd</em> + <em>shift</em> + <em>A</em>) to quickly open the Add Component menu. From there, you can type in the name of the component you wish to add.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scene window</h1>
                
            
            
                
<p>Pressing <em>Shift</em> + <em>F</em> will lock the camera on an object in the Scene window (assuming that the Scene window is open and visible), which can be helpful for tracking high-velocity objects or figuring out why objects may be falling out of our scene.</p>
<p>Holding <em>Alt</em> and left-click and dragging with the mouse in the Scene window will make the Scene window's camera orbit the currently selected object (as opposed to looking around it). Holding <em>Alt</em> and right-click and dragging with the mouse in the Scene window will zoom the camera in/out (<em>Alt</em> + <em>Ctrl</em> + left-drag).</p>
<p>Holding <em>Ctrl</em> and left-click and dragging will cause the selected object to snap to the grid as it moves. The same can be done for rotation by holding <em>Ctrl</em> as we adjust the rotation widgets around the object. In the Scene window, you can click on the arrow near the grid icon (see the following screenshot) to open a window where we can edit the grid that objects snap to on a per-axis basis:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7f276200-b30d-4812-9684-eedc2453e25a.png"/></p>
<p class="mce-root">In Unity 2020.1, the snap to grid setting has been moved from the Scene view toolbar to the main window toolbar (where the Play/Pause/Step buttons are):</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/04831f19-3ccd-4e34-a5bc-36764e4476fc.png" style="width:36.58em;height:3.33em;"/></p>
<p>We can force objects to snap to each other through their vertices by holding down the <em>V</em> key as we move an object around in the Scene window. By doing so, the selected object will automatically snap its vertices to the nearest vertex of the nearest object. This is very useful for aligning scene pieces, such as floors, walls, platforms, and other tile-based systems, without needing to make small manual position adjustments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Arrays</h1>
                
            
            
                
<p>We can duplicate array elements that have been exposed in the Inspector window by selecting them and pressing <em>Ctrl</em> + <em>D</em> (<em>cmd</em> + <em>D</em>). This will copy the element and insert it into the array immediately after the current selection.</p>
<p>We can remove entries from an array of references (for example, an array of GameObjects) by selecting the element, right-clicking on it, and selecting Delete Array Element. This will strip the element and condense the array. Removing elements from arrays of primitive types (<kbd>int</kbd>, <kbd>float</kbd>, and so on) can be accomplished by simply pressing <em>delete</em> without the <em>shift</em> key (<em>cmd</em>) modifier being held down:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/31a751e3-cd0a-4931-ac6b-9c60afb8a67a.png" style="width:25.42em;height:8.75em;"/></p>
<p>While holding down the right mouse button in the Scene window, we can use the <em>W</em>, <em>A</em>, <em>S</em>, and <em>D</em> keys to fly around with the camera in a typical first-person camera control style. The <em>Q</em> and <em>E</em> keys can also be used to fly up and down, respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interface</h1>
                
            
            
                
<p>We can press <em>Alt</em> and click on any Hierarchy window arrow (the small gray arrow to the left of any parent object's name) to expand the object's entire hierarchy, rather than just the next level in the Hierarchy window. This works on GameObjects in the Hierarchy window, folders and Prefabs within the Project window, lists in the Inspector window, and so on.</p>
<p>We can save and restore object selections in the Hierarchy or Project windows much like a typical RTS game. Make the selection and press <em>Ctrl</em> + <em>Alt</em> + &lt;<em>0-9</em>&gt; (<em>cmd </em>+ <em>alt</em> + &lt;<em>0</em>-<em>9</em>&gt;) to save the selection. Press <em>Ctrl</em> + <em>Shift</em> + <em>&lt;0</em>-<em>9&gt;</em> (<em>cmd</em> + <em>shift</em> + &lt;<em>0-9</em>&gt;) to restore it. This is exceptionally useful if we find ourselves selecting the same handful of objects over and over again while we're making adjustments. You can also find the save/load selections commands in Edit | Selection:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d84aacd2-8c0b-4702-8ea5-b7bc748ecb81.png" style="width:26.33em;height:38.50em;"/></p>
<p>Pressing <em>Shift</em> + spacebar will expand the window under the mouse cursor so that it fills the entire Editor screen. Pressing it again will shrink the window and restore it to its previous location.</p>
<p>Pressing <em>Ctrl</em> + <em>Shift</em> + <em>P</em> (<em>cmd</em> + <em>shift</em> + <em>P</em>) will toggle the Pause button while in Playmode. This is usually an awkward key combination to press if we're trying to pause in a hurry, so it often helps to create a custom hotkey for pausing:</p>
<pre>void Update() {<br/>    if (Input.GetKeyDown(KeyCode.P)) {<br/>        Debug.Break();<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">In-editor documentation</h1>
                
            
            
                
<p>We can quickly access the documentation of any Unity keyword or class by highlighting it in Visual Studio Community and pressing <em>Ctrl</em> + <em>'</em> (<em>cmd</em> + <em>'</em>). This will open the default browser and perform a search on the Unity documentation for the given keyword or class.</p>
<p>Note that users with European keyboards may also need to hold down the <em>Shift</em> key for this feature to work.</p>
<p>The same can be done in Visual Studio by pressing <em>Ctrl</em> + <em>Alt</em> + <em>M</em>, followed by <em>Ctrl</em> + <em>H</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Editor UI tips</h1>
                
            
            
                
<p>The Editor's default behavior is designed to be efficient and satisfy every user; however, each of us is different, just like beautiful snowflakes, and so are our working preferences. Fortunately, Unity allows us to customize many aspects of the Editor's workflow. Let's see how with the following collection of tips.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script Execution Order</h1>
                
            
            
                
<p>We can prioritize which scripts will have their <kbd>Update()</kbd> and <kbd>FixedUpdate()</kbd> callbacks called before others by navigating to Edit | Project Settings | Script Execution Order. If we find ourselves trying to solve complex problems using this feature (with the exception of time-sensitive systems, such as audio processing), it implies that we've got some very fragile and tight coupling going on between our components. From a software design perspective, this can be a warning sign that we may need to approach the problem from another angle. However, this can be helpful to use as a quick fix.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Editor files</h1>
                
            
            
                
<p>Integrating Unity projects with a source control solution can be a little tricky. The first step is to include the <kbd>.meta</kbd> files that Unity generates for various assets; if we don't do this, then anyone pulling data into their local Unity project must regenerate their own metadata files. This could potentially cause conflicts, so it is essential that everyone uses the same versions. This can be enabled by navigating to Edit | Project Settings | Editor | Version Control | Mode | Visible Meta Files.</p>
<p>It can also be helpful to convert certain asset data into text-only format, rather than into binary data, to allow data files to be manually edited. This turns many data files into the much more human-readable YAML format. For instance, if we're using ScriptableObjects to store custom data, we can use a text editor to search for and edit these files without having to do it all through the Unity Editor and serialization system. This can save a lot of time, especially when we're searching for a particular data value or performing multi-editing across different derived types. This option can be enabled by navigating to Edit | Project Settings | Editor | Asset Serialization | Mode | Force Text.</p>
<p>The Editor has a log file that can be accessed by opening the Console window (where log messages are printed), left-clicking on the hamburger icon in the top right corner (which looks like three thin horizontal lines), and selecting Open Editor Log. This can help us get more information about build failures.</p>
<p>Alternatively, if we successfully built our project, it will contain a breakdown of the compressed file sizes of all of the assets that were packed into the executable, ordered by size. This is an extremely helpful way of figuring out which assets consume the majority of our application's footprint (hint: it's almost always texture files) and which files take up more space than we would expect:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5ffba58c-a1b8-4e8b-ac08-5961623a10b1.png" style="width:29.42em;height:9.17em;"/></p>
<p>Additional windows can be added to the Editor by right-clicking on the title of an existing window and selecting Add Tab. This also allows us to add duplicate windows, such as having more than one Project window or Inspector window open at a time. This can be particularly useful for moving files between different locations via multiple Project windows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c1f14e08-c729-498a-adf6-3cb3d5f6d2e6.png" style="width:21.00em;height:19.92em;"/></p>
<p>Having duplicate Inspector windows can be virtually redundant, since they'll show the exact same information when we click on a new object. However, by making use of the <em>lock icon</em>, we can lock the given Inspector window to its current selection. When we select an object, all the Inspector windows will be updated to show the object's data, except for any locked Inspector windows, which continue to show the data of the object they were locked to:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e369b91a-6711-489c-bcb1-f9b246ee6fa3.png" style="width:14.75em;height:2.75em;"/></p>
<p>Some common tricks that make use of window locking include the following:</p>
<ul>
<li>Using two of the same window (Inspector, Animation, and so on) to compare two objects side by side or to easily copy data from one object to another</li>
<li>Watching what happens to any dependent object if an object is tweaked during Playmode</li>
<li>Selecting multiple objects in the Project window and then dragging and dropping them into a serialized array in the Inspector window without losing the original selection</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Inspector window</h1>
                
            
            
                
<p>We can enter calculations into numeric Inspector window fields. For example, typing <kbd>4*128</kbd> into an <kbd>int</kbd> field will resolve the value to <kbd>512</kbd>, sparing us from having to pull out a calculator or do the math in our head.</p>
<p>Array elements can be duplicated and deleted from a list (in the same fashion as hotkeys can) by right-clicking on the root element and selecting Duplicate Array Element or Delete Array Element.</p>
<p>A component's context menu can be accessed by clicking on the small <em>cog</em> icon in the upper right corner or by right-clicking on the name of the component. Every component's context menu contains a Reset option, which resets all of the values back to their default states, sparing us from having to reset values manually. This is useful when we're working with <kbd>Transform</kbd> components as this option will set the object's position and rotation to <kbd>(0,0,0)</kbd> and its scale to <kbd>(1,1,1)</kbd>.</p>
<p>It's commonly known that, if <kbd>GameObject</kbd> was spawned from a Prefab, then the entire object can be reverted back to its initial Prefab state using the Revert button at the top of the Inspector window. However, it's less well-known that individual values can be reverted by right-clicking on the name of the value and selecting Revert Value to Prefab. This restores the selected value while leaving the rest untouched.</p>
<p>The Inspector window has a Debug mode that can be accessed by left-clicking on the hamburger icon next to the lock icon and selecting Debug. This will disable all custom Inspector window drawing from Editor scripts and instead reveal all the pieces of raw data within the given <kbd>GameObject</kbd> and its components. Even <kbd>private</kbd> data fields become visible. Although they are grayed out and cannot be modified through the Inspector window, this still gives us a useful way of examining the <kbd>private</kbd> data and other hidden values during Playmode. The Debug mode of the Inspector window also reveals internal ObjectIDs, which can be useful if we're doing interesting things with Unity's serialization system and want to resolve conflicts. Since Editor scripts are also disabled in this mode, it can be useful to debug such scripts by comparing its internal data to what we are trying to reveal in our Editor script.</p>
<p>If we have an array of data elements serialized in the Inspector window, then they are typically labeled Element N, where <kbd>N</kbd> represents the array index of that element, starting from <kbd>0</kbd>. This can make it tricky to find a specific element if our array elements are a series of serialized classes or structs, which tend to have multiple children themselves. However, if the very first field in the object is a string, then the elements will be named after the value of the string field:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f50cf3c4-9990-401b-96fd-b44c942321bb.png" style="width:28.67em;height:18.00em;"/></p>
<p>When a mesh object is selected, the Preview subsection at the bottom of the Inspector window is often fairly small, which makes it hard for us to look at the details in the mesh and what it will look like when it appears in our scene. However, if we right-click on the top bar of the Preview subsection, it will be detached and enlarged into a separate Preview window, making it much easier for us to see our mesh. We don't have to worry about setting the detached window back to its original home because if the detached window is closed, then the Preview subsection will return to the bottom of the Inspector window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Project window</h1>
                
            
            
                
<p>The Project window's search bar allows us to filter for objects of a particular type by clicking on the small icon to the right of the search bar. This provides a list of different types that we can filter by revealing all the objects of that type within the entire project. However, selecting these options simply fills the search bar with a string of the <kbd>t:&lt;type&gt;</kbd> format, which applies the appropriate filter.</p>
<p>Thus, we can simply type the equivalent strings into the search bar for the sake of speed. For instance, typing <kbd>t:prefab</kbd> will filter for all Prefabs, no matter where they are in the Hierarchy window. Similarly, <kbd>t:texture</kbd> will reveal textures, <kbd>t:scene</kbd> will reveal scene files, and so on. Adding multiple search filters to the search bar will include objects of all types (it doesn't reveal objects that only satisfy both filters). These filters are modifiers in addition to name-based filtering, so adding a plain text string will cause a name-based search to occur through the filtered objects. For example, <kbd>t:texture normalmap</kbd> will find all the texture files that include the word <kbd>normalmap</kbd> in their name.</p>
<p>If we're making use of Asset Bundles and the built-in labeling system, the Project window's search bar also allows us to hunt down bundled objects by their label using <kbd>l:&lt;label type&gt;</kbd>.</p>
<p>If a <kbd>MonoBehaviour</kbd> script contains serialized references (using <kbd>[SerializeField]</kbd> or <kbd>public</kbd>) to Unity assets, such as meshes and textures, then we can assign default values to the script directly. Select the script file in the Project window; the Inspector window should contain a field for the asset so that we can drag and drop the default assignment into it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d34f6416-57a8-4786-8c34-b771a4758c4b.png" style="width:43.75em;height:19.25em;"/></p>
<p>By default, the Project window splits files and folders into two columns and treats them separately. If we prefer the Project window to have a typical hierarchical folder and file structure, then we can set it to One Column Layout in its context menu (the hamburger icon at the top right). This can be a great space saver in some Editor layouts.</p>
<p>Right-clicking on any object in the Project window and selecting Select Dependencies will reveal all the objects that this asset relies on so that it can exist, such as textures, meshes, and <kbd>MonoBehaviour</kbd> script files. For scene files, it will list all the entities that are referenced within that scene. This is helpful if we're trying to perform asset cleanup.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Hierarchy window</h1>
                
            
            
                
<p>A less well-known feature of the Hierarchy window is its ability to perform component-based filtering within the currently active scene. This can be accomplished by typing <kbd>t:&lt;component name&gt;</kbd>. For example, typing <kbd>t:light</kbd> inside the Hierarchy window search bar will reveal all the objects in the scene that contain a Light component.</p>
<p>This feature is not case-sensitive, but the string we input must match the full component name for the search to be completed. Components that derive from the given type will also be revealed, so typing <kbd>t:renderer</kbd> will reveal all the objects with derived components, such as <kbd>MeshRenderer</kbd> and <kbd>SkinnedMeshRenderer</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Scene and Game windows</h1>
                
            
            
                
<p>The Scene window camera is not visible from the Game window, but it is generally a lot easier to move around and place through the use of the hotkeys we mentioned previously. The Editor allows us to align the selected object to the same position and rotate the Scene window camera by navigating to GameObject | Align with View or pressing <em>Ctrl</em> + <em>Shift</em> + <em>F</em> (<em>cmd</em> + <em>shift</em> + <em>F</em>). This means that we can use the camera controls to place the Scene window camera where we would like our object to be and place the object there by aligning it with the camera.</p>
<p>Similarly, we can align the Scene window camera to the selected object by selecting GameObject | Align View to Selected (note that there is no hotkey for this on either Windows or macOS). This is useful for checking whether the given object is pointing in the right direction.</p>
<p>We can perform similar component-based filtering on the Scene window, just like we can with the Hierarchy window, by using the <kbd>t:&lt;component&gt;</kbd> syntax within its search bar. This will cause the Scene window to only render objects containing the given component (or those that derive from it). Note that this textbox is linked to the same textbox in the Hierarchy window, so anything we type in one will automatically affect the other, which is very helpful when we're searching for elusive objects.</p>
<p>At the very top right of the Unity Editor is a dropdown menu labeled Layers. This contains a layer-based filtering and locking system for the Scene window. Enabling the eye icon for a given layer will show/hide all the objects of that layer within the Scene window. Toggling the lock icon will allow or prevent objects of the given layer from being selected or modified (through the Editor UI, at least).</p>
<p>This is helpful when we wish to prevent someone from accidentally selecting and moving background objects that have already been placed correctly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/37a01587-902c-4fbf-953f-e6173e46467e.png"/></p>
<p>A well-known and useful feature of the Editor is that GameObjects can be given special icons or labels to make them easier to find in the Scene window. This is particularly helpful for objects with no renderer but that we wish to find easily. For instance, objects such as Lights and cameras have built-in icons that identify them in our Scene window more easily. However, the same gizmos can be revealed within the Game window by clicking on the Gizmos button at the top right of the Game window. The dropdown for this option determines what gizmos will be visible when this option is enabled.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Playmode</h1>
                
            
            
                
<p>Since Playmode changes are not automatically saved, it is wise to modify the tint color that's applied during Playmode to make it blatantly obvious which mode we're currently working with. This value can be set by navigating to Edit | Preferences | Colors | Playmode tint.</p>
<p>Changes can be saved from Playmode simply using the clipboard. If we're tweaking an object in Playmode and we're happy with its settings, then we can copy the object into the clipboard using <em>Ctrl</em> + <em>C</em> (<em>cmd</em> + <em>C</em>) and paste it back into the scene once Playmode ends via <em>Ctrl</em> + <em>V</em> (<em>cmd</em> + <em>V</em>).</p>
<p>All of the settings that have been applied to the object at the time of the copy will be kept. The same can be done with individual values of entire components if we use the Copy Component and Paste Component options in the component's context menu. However, the clipboard can only contain data for one <kbd>GameObject</kbd>, component, or value at a time.</p>
<p>Another approach, which allows us to save the data of multiple objects during Playmode, is to create Prefabs from them by dragging and dropping them into the Project window at runtime once we're happy with the settings. If the original object was derived from a Prefab, and we wish to update it across all instances, then we only need to overwrite the old Prefab with the new one we created by dragging and dropping the copy on top of the original. Note that this also works while Playmode is active, but it can be dangerous since there is no dialog popup to confirm the overwrite. Be very careful not to overwrite the wrong Prefab.</p>
<p>We can use the Frame Skip button (the button to the right of the Pause button in the Editor) to iterate one frame at a time. This can be useful for watching frame by frame physics or gameplay behavior. Keep in mind that this causes one <kbd>FixedUpdate</kbd> and one <kbd>Update</kbd> to be called per iteration, in equal counts, which may not reflect the actual runtime behavior, where we tend to have an unequal number of calls to these callbacks.</p>
<p>If the Pause button is enabled when Playmode begins, then the game will be paused just after the very first frame, giving us a chance to observe any anomalies that occurred during the initialization of our scene.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scripting tips</h1>
                
            
            
                
<p>If you are a developer, you will spend a lot of time editing code. While artists and designers are playing with colorful images and visual effects, you may find yourself stuck in the black and white code editor domain. Coding may be hard sometimes, but it doesn't need to be tedious. In the following tips, we will learn how to simplify some of the most boring parts of the job.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">General</h1>
                
            
            
                
<p>We can modify various templates of the new script, as well as shader and compute shader files. This can be helpful if we want to remove the empty Update stubs which, as we covered in <a href="">Chapter 2</a>, <em>Scripting Strategies</em>, can cause unnecessary runtime overhead. These files can be found in the following locations:</p>
<ul>
<li>Windows: <kbd>&lt;Unity install&gt;\Editor\Data\Resources\ScriptTemplates\</kbd></li>
<li>macOS: <kbd>/Applications/Unity/Editor/Data/Resources/ScriptTemplates/</kbd></li>
</ul>
<p>The <kbd>Assert</kbd> class allows for assert-based debugging, which some developers are more comfortable with, as opposed to exception-based debugging. Check out the Unity documentation for more information on <kbd>Assert</kbd>: <a href="http://docs.unity3d.com/ScriptReference/Assertions.Assert.html">http://docs.unity3d.com/ScriptReference/Assertions.Assert.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attributes</h1>
                
            
            
                
<p>Attributes are very useful meta-level tags that can be given to almost any target in C#. They are commonly used on fields and classes, allowing us to flag them with special properties so that they can be processed differently. Intermediate and advanced Unity developers will find it worthwhile to read the C# documentation on attributes and use their imagination to come up with their own attributes that help accelerate their workflow. There are quite a few attributes built into the Unity engine that can be exceptionally useful when used in the right place.</p>
<p>Advanced users will note that attributes can also be given to enums, delegates, methods, parameters, events, modules, and even assemblies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Variable attributes</h1>
                
            
            
                
<p>The <kbd>[Range]</kbd> attribute can be added to an integer or floating-point field to convert it into a slider in the Inspector window. We can provide minimum and maximum values, thus limiting the range that the value can contain.</p>
<p>Normally, if a variable is renamed, even if we do a refactor through our IDE, then the values are lost as soon as Unity recompiles the <kbd>MonoBehaviour</kbd> and makes the appropriate changes to any instances of the component. However, the <kbd>[FormerlySerializedAs]</kbd> attribute is incredibly helpful if we want to rename a variable that has been previously serialized, since it will copy the data from the variable that was named within the attribute into the given variable at compile time. No more lost data due to renaming stuff!</p>
<p>Note that it isn't safe to remove the <kbd>[FormerlySerializedAs]</kbd> attribute after the conversion is completed unless the variable has been manually changed and resaved into every relevant Prefab since the attribute was included. The <kbd>.prefab</kbd> data file will still contain the old variable name, and so it still needs the <kbd>[FormerlySerializedField]</kbd> attribute to figure out where it should place the data the next time the file is loaded (for example, when the Editor is closed and reopened). Thus, this is a helpful attribute, but extended use does tend to clutter up our code base a lot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Class attributes</h1>
                
            
            
                
<p>The <kbd>[SelectionBase]</kbd> attribute will mark any <kbd>GameObject</kbd> the component is attached to as the root of selection for the Scene window. This is especially useful if we have meshes that are children of other objects since we may want the parent object to be selected with the first click, instead of the object with the <kbd>MeshRenderer</kbd> component.</p>
<p>If we have components with a strong dependency, we can use the <kbd>[RequireComponent]</kbd> attribute to force level designers to attach vital components to the same <kbd>GameObject</kbd>. This ensures that any dependencies that our code base relies on will be satisfied by designers, without us having to write out a whole bunch of documentation for them.</p>
<p>The <kbd>[ExecuteInEditMode]</kbd> attribute will force the object's <kbd>Update()</kbd>, <kbd>OnGUI()</kbd>, and <kbd>OnRenderObject()</kbd> callbacks to be called during Edit Mode. However, there are some caveats to this, as follows:</p>
<ul>
<li>The <kbd>Update()</kbd> method is only called if something changes in the scene, such as moving the camera around or changing an object property</li>
</ul>
<ul>
<li><kbd>OnGUI()</kbd> is only called during Game window events and not for other window events, such as the Scene window</li>
<li><kbd>OnRenderObject()</kbd> is called during any repaint event for the Scene and Game windows</li>
</ul>
<p>However, this attribute gives such objects a different set of event hooks and entry points compared to typical Editor scripts, so it still has its uses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logging</h1>
                
            
            
                
<p>We can add rich text tags to debug strings. Tags such as <kbd>&lt;size&gt;</kbd>, <kbd>&lt;b&gt;</kbd> (bold), <kbd>&lt;i&gt;</kbd> (italics), and <kbd>&lt;color&gt;</kbd> work on debug strings. This can help us differentiate between the different kinds of log messages and allows us to highlight specific elements, as follows:</p>
<pre>Debug.Log ("&lt;color=red&gt;[ERROR]&lt;/color&gt;This is a &lt;i&gt;very&lt;/i&gt; &lt;size=14&gt;&lt;b&gt;specific&lt;/b&gt;&lt;/size&gt; kind of log message");</pre>
<p>The error message we will obtain is as shown as follows: </p>
<div><img src="img/95010d6d-9171-49ff-ad7c-455b1351bf09.png" style="width:19.42em;height:1.08em;"/></div>
<p>The <kbd>MonoBehaviour</kbd> class has a <kbd>print()</kbd> method for convenience, which does the same thing as <kbd>Debug.Log()</kbd>.</p>
<p>It can help to create a custom logger class, which automatically appends <kbd>\n\n</kbd> to the end of every log message. This will push away the unnecessary <kbd>UnityEngine.Debug:Log(Object)</kbd> clutter that tends to fill the Console window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Useful links</h1>
                
            
            
                
<p>Unity provides many useful tutorials on the usage of various scripting features, which primarily target beginner- and intermediate-level developers. These tutorials can be found at <a href="https://unity3d.com/learn/tutorials/topics/scripting">https://unity3d.com/learn/tutorials/topics/scripting</a>.</p>
<p>There's a helpful post on Unity Answers that provides a reference list that covers many of the different scripting and compilation errors we may run into during development. This can be found by searching for <kbd>Scripting</kbd> at <a href="https://learn.unity.com/">https://learn.unity.com/</a>.</p>
<p>Nested coroutines is an interesting and useful area of scripting that is not well documented. However, the following old but still valid third-party blog post, which covers a lot of the interesting details, should be considered when working with nested coroutines: <a href="http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper">http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom Editor scripts and menu tips</h1>
                
            
            
                
<p>While it's common knowledge that we can create an Editor menu item in an Editor script with the <kbd>[MenuItem]</kbd> attribute, a less well-known ability is being able to set custom hotkeys for menu items. For example, we can make the <q>K</q> key trigger our menu item method by defining that the <kbd>[MenuItem]</kbd> attribute ends with <kbd>_k</kbd>, as follows:</p>
<pre>[MenuItem("My Menu/Menu Item _k")]</pre>
<p>We can also include modifier keys such as <em>Ctrl</em> (<em>cmd</em>), <em>Shift</em>, and <em>Alt</em> using the <kbd>%</kbd>, <kbd>#</kbd>, and <kbd>&amp;</kbd> characters, respectively.</p>
<p><kbd>[MenuItem]</kbd> also has two overloads, which allow us to set two additional parameters: a Boolean that determines whether the menu item requires a validation method and an integer that determines the menu item's priority in the Hierarchy window.</p>
<p>Check out the documentation for <kbd>[MenuItems]</kbd> for a complete list of available hotkey modifiers, special keys, and how to create validation methods: <a href="http://docs.unity3d.com/ScriptReference/MenuItem.html">http://docs.unity3d.com/ScriptReference/MenuItem.html</a>.</p>
<p>It is also possible to <em>ping</em> an object in the Hierarchy window, similar to what happens when we click on a <kbd>GameObject</kbd> reference in the Inspector window and call <kbd>EditorGUIUtility.PingObject()</kbd>.</p>
<p>The original implementation of the <kbd>Editor</kbd> class, and the way that most people learned how to write Editor scripts, originally involved writing all the logic and content drawing in the same class. However, the <kbd>PropertyDrawer</kbd> class is an effective way of delegating Inspector window drawings to a different class from the main <kbd>Editor</kbd> class. This effectively separates input and validation behavior from display behavior, thus allowing for more fine-tuned control of rendering on a per-field basis and more effective reuse of code. We can even use <kbd>PropertyDrawer</kbd> to override default Unity drawings for built-in objects, such as <kbd>Vector</kbd> and <kbd>Quaternion</kbd>.</p>
<p><kbd>PropertyDrawer</kbd> makes use of the <kbd>SerializedProperty</kbd> class to accomplish the serialization of individual fields, and they should be preferred when writing Editor scripts since they make use of built-in undo, redo, and multi-edit functionality. Data validation can be a little problematic, and the best solution is to use <kbd>OnValidate()</kbd> calls in the <em>setter</em> properties. A session at Unite 2013, by Unity Technologies developer Tim Cooper, explains the benefits and pitfalls of various serialization and validation approaches in great detail (<a href="https://www.youtube.com/watch?v=Ozc_hXzp_KU">https://www.youtube.com/watch?v=Ozc_hXzp_KU</a>).</p>
<p>We can add entries to component context menus and even the context menus of individual fields with the <kbd>[ContextMenu]</kbd> and <kbd>[ContextMenuItem]</kbd> attributes. This allows us to customize the Inspector window's behavior for our components without needing to write broad <kbd>Editor</kbd> classes or custom Inspector windows.</p>
<p>Advanced users may find it useful to store custom data within Unity metadata files through the <kbd>AssetImporter.userData</kbd> variable. There's also a multitude of opportunities to make use of Reflection in the Unity code base. Ryan Hipple's session at Unite 2014 outlines a huge number of neat little hacks and tricks we can use with Reflection in the Unity Editor (<a href="https://www.youtube.com/watch?v=SyR4OYZpVqQ">https://www.youtube.com/watch?v=SyR4OYZpVqQ</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">External tips</h1>
                
            
            
                
<p>The following tips and tricks are related to topics outside the Unity Editor itself but can help Unity development workflow enormously.</p>
<p>The Twitter hashtag <kbd>#unitytips</kbd> is a great resource for useful tips and tricks for Unity development and is, in fact, where many of the tips in this chapter originate from. However, hashtags are difficult to filter for tips you haven't seen before, and it tends to be abused for marketing. A great resource that pulls together a bundle of weekly tips from <kbd>#unitytips</kbd> can be found at <a href="http://devdog.io/blog">http://devdog.io/blog</a>.</p>
<p>Googling Unity-related problems or concerns can be made a lot faster if we start the search with <kbd>site:unity3d.com</kbd>, which will filter all the results so that only those under the <kbd>unity3d.com</kbd> domain will appear.</p>
<p>If the Unity Editor crashes, for whatever reason, then we can potentially restore our scene by renaming the following file to include the <kbd>.unity</kbd> extension (for scene files) and copying it into our <kbd>Assets</kbd> folder:</p>
<pre>\&lt;project folder&gt;\Temp\_EditModeScene</pre>
<p>There is a great resource for game programming patterns (or, rather, typical programming patterns explained in a way that is pertinent to game development), and it's completely free and available online. The following guide includes more information on several of the design patterns and game features we explored in this book, such as the Singleton pattern, the Observer pattern, the Game loop, and doubling-up on frame buffers: <a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a>.</p>
<p>Keep an eye on any session videos that come from Unite conferences whenever they happen (or better yet, try to attend them). A couple of panels at each conference are usually held by Unity employees and experienced developers who will share lots of cool and interesting things they've been able to accomplish with the Engine and Editor. In addition to this, make sure that you involve yourself in the Unity community through the forums on<a href="https://unity3d.com/" target="_blank"> https://unity3d.com</a>, Twitter, Reddit, Stack Overflow, Unity Answers, or at whatever social gathering places pop out of the woodwork in the coming years.</p>
<p>Every single tip that was included in this book wasn't conjured out of thin air. It started out as an idea or tidbit of knowledge that someone shared, somewhere, at some point, and somehow eventually found its way into this book. So, the best way to keep up to date on the best tips, tricks, and techniques is to keep our fingers on the pulse of where Unity is heading by staying involved in its community.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other tips</h1>
                
            
            
                
<p>Finally, this section contains tips that didn't quite fit into the other categories.</p>
<p>It's always a good idea to organize our scenes using empty GameObjects and use them as parents for a group of objects while naming them something sensible for that group. The only drawback to this method is that the empty object's transform is included during position or rotation changes and is included during recalculations. As we know, reparenting <kbd>GameObject</kbd> to another transform has its own costs. Proper object referencing, transform change caching, and/or use of <kbd>localPosition</kbd>/<kbd>localRotation</kbd> can be used to solve some of these problems adequately. In almost all cases, the benefits of having a workflow from scene organization are significantly more valuable than such trivial performance losses.</p>
<p>Animator Override Controllers were introduced way back in Unity v4.3 but tend to be forgotten or rarely mentioned. They are an alternative to standard Animation Controllers, which allow us to reference an existing Animation Controller and then override specific animation states so that we can use different animation files. This allows for much faster workflows since we don't need to duplicate and tweak Animation Controllers multiple times; we only need to change a handful of animation states.</p>
<p>The amazing customizability of the Unity Editor and its ever-growing feature set means that there are tons of little opportunities to improve workflows, and more are being discovered or invented every single day. The asset store marketplace is absolutely rife with different products that try to solve some kind of problem that modern developers are having trouble with, which makes it a great place to browse if we're looking for ideas or, if we're willing, drop some money to save us a ton of hassle.</p>
<p>Since these assets tend to sell to a broad audience, this keeps prices low, and we can pick up some amazingly useful tools and scripts for little to no cost. In almost all cases, it would take us a significant number of hours to develop the same solution ourselves. If we consider our time as valuable, then scanning the asset store once in a while can be a very cost-effective approach to development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This brings us to the end of this book. Hopefully, you have enjoyed the ride. To reiterate, perhaps the most important tip in this book is to always make sure that you verify the source of the performance bottleneck via benchmarking before making a single change. The last thing we want to waste time on is chasing ghosts in the code base when 5 minutes of Profiler testing can save us an entire day of work. In a lot of cases, the solution requires a cost-benefit analysis to determine whether we're not sacrificing too much in any other area at the risk of adding further bottlenecks. Make sure that you have a reasonable understanding of the root cause of the bottleneck to avoid putting other performance metrics at risk. To also reiterate the second most important tip in this book, always profile and test after making changes to ensure they had the intended effect.</p>
<p>Performance enhancement is all about problem-solving, which can be a lot of fun since, due to the complexity of modern computer hardware, small tweaks can yield big rewards. There are many techniques that can be implemented to improve application performance or speed up our workflows. Some of these are hard to fully realize unless we have the necessary experience, skills, and time to implement them. In most cases, these fixes are relatively simple if we simply take the time to find and understand the source of the problem. So, go forth and use your repository of knowledge to make your games the best they can be!</p>


            

            
        
    </body></html>