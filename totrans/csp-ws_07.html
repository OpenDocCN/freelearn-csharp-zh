<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer148">
</div>
</div>
<div class="Content" id="_idContainer149">
<h1 id="_idParaDest-251"><a id="_idTextAnchor282"/>7. Creating Modern Web Applications with ASP.NET</h1>
</div>
<div class="Content" id="_idContainer163">
<p class="callout-heading">Overview</p>
<p class="callout">There are many types of applications in use nowadays and web apps top the list of the most used ones. In this chapter, you will be introduced to ASP.NET, a web framework built with C# and the .NET runtime, made to create web apps with ease. You will also learn the anatomy of a basic ASP.NET application, web application development approaches such as server-side rendering and single-page applications, and how C# helps implement these approaches to build safe, performant, and scalable applications.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor283"/>Introduction</h1>
<p>In <em class="italic">Chapter 1</em>, <em class="italic">Hello C#</em>, you learned that .NET is what brings C# to life, as it contains both a Software Development Kit (SDK) used to build your code and a runtime that executes the code. In this chapter, you will learn about ASP.NET, which is an open-source and cross-platform framework embedded within the .NET runtime. It is used for building applications for both frontend and backend applications for web, mobile, and IoT devices.</p>
<p>It is a complete toolbox for these kinds of development, as it provides several built-in features, such as lightweight and customizable HTTP pipelines, dependency injection, and support for modern hosting technologies, such as containers, web UI pages, routing, and APIs. A well-known example is Stack Overflow; its architecture is built entirely on top of ASP.NET.</p>
<p>The focus of this chapter is to acquaint you with the fundamentals of ASP.NET and to give you both an introduction and an end-to-end overview of web application development with Razor Pages, a built-in toolbox included in ASP.NET to build web apps.</p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor284"/>Anatomy of an ASP.NET Web App</h1>
<p>You'll begin this chapter by creating a new Razor Pages application with ASP.NET. It is just one of the various types of apps that can be created with ASP.NET but will be an effective starting point as it shares and showcases a lot of commonalities with other web application types that can be built with the framework.</p>
<ol>
<li>To create a new Razor Pages app, enter the following commands in the CLI:<p class="source-code">dotnet new razor -n ToDoListApp dotnet new sln -n ToDoList dotnet sln add ./ToDoListApp</p></li>
</ol>
<p>Here you are creating a to-do list application with Razor Pages. Once the preceding command is executed, you will see a folder with the following structure:</p>
<p class="source-code">/ToDoListApp |-- /bin |-- /obj |-- /Pages</p>
<p class="source-code">|-- /Properties |-- /wwwroot |-- appsettings.json |-- appsettings.Development.json |-- Program.cs</p>
<p class="source-code">|-- ToDoListApp.csproj</p>
<p class="source-code">|ToDoList.sln</p>
<ol>
<li value="2">Open the root folder in Visual Studio Code.</li>
</ol>
<p>There are some files inside these folders that will be covered in the upcoming sections. For now, consider this structure:</p>
<ul>
<li><strong class="source-inline">bin</strong> is the folder where the final binaries go after the application is built.</li>
<li><strong class="source-inline">obj</strong> is the folder where the compiler places intermediate outputs during the build process.</li>
<li><strong class="source-inline">Pages</strong> is the folder where the application Razor Pages will be placed.</li>
<li><strong class="source-inline">Properties</strong> is a folder containing the <strong class="source-inline">launchSettings.json</strong> file, a file where the run configurations are placed. In this file, you can define some configuration for local run i.e., environment variables and application ports.</li>
<li><strong class="source-inline">wwwroot</strong> is the folder where all the static files of the application go.</li>
<li><strong class="source-inline">appsettings.json</strong> is a configuration file.</li>
<li><strong class="source-inline">appsettings.Development.json</strong> is a configuration file for the Development environment.</li>
<li><strong class="source-inline">Program.cs</strong> is the program class that you have seen since <em class="italic">Chapter 1</em>, <em class="italic">Hello C#</em>. It is the entry point of an application.</li>
</ul>
<p>Now that you know that in .NET 6.0, it is the <strong class="source-inline">Program.cs</strong> file, created at the root of the folder, that brings a <strong class="source-inline">WebApplication</strong> to life, you can begin to explore <strong class="source-inline">Program.cs</strong> in greater depth in the next section.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor285"/>Program.cs and the WebApplication</h2>
<p>As mentioned earlier, <strong class="source-inline">Program.cs</strong> is the entry point of any C# application. In this section, you will see how a typical <strong class="source-inline">Program</strong> class is structured for an ASP.NET app. Consider the following example of <strong class="source-inline">Program.cs</strong>, which describes a very simple ASP.NET application:</p>
<p class="source-code-heading">Program.cs</p>
<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
<p class="source-code">// Add services to the container.</p>
<p class="source-code">builder.Services.AddRazorPages();</p>
<p class="source-code">var app = builder.Build();</p>
<p class="source-code">// Configure the HTTP request pipeline.</p>
<p class="source-code">if (!app.Environment.IsDevelopment())</p>
<p class="source-code">{</p>
<p class="source-code">app.UseExceptionHandler("/Error");</p>
<p class="source-code">// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</p>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/tX9iK">https://packt.link/tX9iK</a>.</p>
<p>The first thing done here is the creation of a <strong class="source-inline">WebApplicationBuilder</strong> object. This object contains everything that's needed to bootstrap a basic Web Application in ASP.NET—Configuration, Logging, DI, and Service Registration, Middlewares, and other Host configurations. This Host is the one responsible for the lifetime management of a web application; they set up a web server and a basic HTTP pipeline to process HTTP requests.</p>
<p>As you can see, it is quite impressive how, in a few lines of code, so many things can be done that enable you to run a well-structured web application. ASP.NET does all of that so that you can focus on providing value through the functionalities you will build.</p>
<p class="callout-heading">Note</p>
<p class="callout">Bootstrap is a CSS library for the beautification of web content. You can know more about it at the official website.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor286"/>Middlewares</h2>
<p>Think of middleware as small pieces of applications that connect to each other to form a pipeline for handling HTTP requests and responses. Each piece is a component that can do some work either before or after another component is executed on the pipeline. They are also linked to each other through a <strong class="source-inline">next()</strong> call, as shown in <em class="italic">Figure 7.1</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 7.1: The Middleware for an HTTP pipeline " height="520" src="image/B16835_07_01.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 7.1: The Middleware for an HTTP pipeline</p>
<p>Middleware is a whole universe unto itself. The following list defines the salient features for building a web application:</p>
<ul>
<li>The order in which the middleware is placed matters. As they are chained one after another, the placement of each component impacts the way the pipeline is processed.</li>
<li>The <strong class="source-inline">before</strong> logic, as shown in <em class="italic">Figure 7.1</em>, is executed until the endpoint is finally reached. Once the endpoint is reached, the pipeline continues to process the response using the <strong class="source-inline">after</strong> logic.</li>
<li><strong class="source-inline">next()</strong> is a method call that will execute the next middleware in the pipeline, before executing the <strong class="source-inline">after</strong> logic of the current middleware.</li>
</ul>
<p>In ASP.NET applications, middleware can be defined in the <strong class="source-inline">Program.cs</strong> file after the <strong class="source-inline">WebApplicationBuilder</strong> calls the <strong class="source-inline">Build </strong>method with a <strong class="source-inline">WebApplication?</strong> object as a result of this operation.</p>
<p>The application you created in the <em class="italic">Program.cs and the WebApplication</em> section, already contains a set of middlewares placed for new boilerplate Razor Pages applications that will be called sequentially when an <strong class="bold">HTTP request</strong> arrives.</p>
<p>This is easily configurable because the <strong class="source-inline">WebApplication</strong> object contains a generic <strong class="source-inline">UseMiddleware&lt;T&gt;</strong> method. This method allows you to create middleware to embed into the HTTP pipeline for requests and responses. When used within the <strong class="source-inline">Configure</strong> method, each time the application receives an incoming request, this request will go through all the middleware in the order the requests are placed within the <strong class="source-inline">Configure</strong> method. By default, ASP.NET provides basic error handling, <strong class="source-inline">autoredirection</strong> to HTTPS, and serves static files, along with some basic routing and authorization.</p>
<p>However, you might notice in your <strong class="source-inline">Program.cs</strong> file, of the <em class="italic">Program.cs and the WebApplication</em> section, there are no <strong class="source-inline">UseMiddleware&lt;&gt;</strong> calls. That's because you can write extension methods to give a more concise name and readability to the code, and the ASP.NET framework already does it by default for some built-in middlewares. For instance, consider the following example:</p>
<p class="source-code">using Microsoft.AspNetCore.HttpsPolicy;</p>
<p class="source-code">public static class HttpsPolicyBuilderExtensions</p>
<p class="source-code">{</p>
<p class="source-code">public static IApplicationBuilder UseHttpsRedirection(this WebApplication app)</p>
<p class="source-code">      { </p>
<p class="source-code">           app.UseMiddleware&lt;HttpsRedirectionMiddleware&gt;();</p>
<p class="source-code">           return app;</p>
<p class="source-code">}</p>
<p class="source-code">}</p>
<p><a id="_idTextAnchor287"/>Here, a sample of the built-in <strong class="source-inline">UseHttpsRedirection</strong> extension method is used for enabling a redirect middleware.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor288"/>Logging</h2>
<p>Logging might be understood as the simple process of writing everything that is done by an application to an output. This output might be the console application, a file, or even a third-party logging monitor application, such as the ELK Stack or Grafana. Logging has an important place in assimilating the behavior of an application, especially with regard to error tracing. This makes it an important concept to learn.</p>
<p>One thing that enables ASP.NET to be an effective platform for enterprise applications is its modularity. Since it is built on top of abstractions, any new implementation can be easily done without loading too much into the framework. The <strong class="bold">logging</strong> abstractions are some of these.</p>
<p>By default, the <strong class="source-inline">WebApplication</strong> object created in <strong class="source-inline">Program.cs</strong> adds some logging providers on top of these logging abstractions, which are <strong class="source-inline">Console</strong>, <strong class="source-inline">Debug</strong>, <strong class="source-inline">EventSource</strong>, and <strong class="source-inline">EventLog</strong>. The latter—<strong class="source-inline">EventLog</strong>—is an advanced feature specific to the Windows OS only. The focus here will be the <strong class="source-inline">Console</strong> logging provider. As the name suggests, this provider will output all the logged information to your application console. You'll learn more about it later in this section.</p>
<p>As logs basically write everything your application does, you might wonder whether these logs will end up being huge, especially for large-scale apps. They might be, but an important thing while writing application logs is to grasp the <strong class="bold">severity</strong> of the log. There might be some information that is crucial to log, such as an unexpected exception. There might also be information that you would only like to log to a development environment, to know some behaviors better. That said, a log in .NET has seven possible log levels, which are:</p>
<ul>
<li><strong class="source-inline">Trace</strong> = 0</li>
<li><strong class="source-inline">Debug</strong> = 1</li>
<li><strong class="source-inline">Information</strong> = 2</li>
<li><strong class="source-inline">Warning</strong> = 3</li>
<li><strong class="source-inline">Error</strong> = 4</li>
<li><strong class="source-inline">Critical</strong> = 5</li>
<li><strong class="source-inline">None</strong> = 6</li>
</ul>
<p>Which level is output to the provider is defined via variables set either as environment variables or via the <strong class="source-inline">appSettings.json</strong> file in the <strong class="source-inline">Logging:LogLevel</strong> section, as in the following example:</p>
<p class="source-code">{</p>
<p class="source-code">  "Logging": {</p>
<p class="source-code">    "LogLevel": {</p>
<p class="source-code">      "Default": "Information",</p>
<p class="source-code">      "ToDoListApp": "Warning",</p>
<p class="source-code">      "ToDoListApp.Pages": "Information"</p>
<p class="source-code">    }</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>In this file, there are log categories, which are either the <strong class="source-inline">Default</strong> category or part of the namespace of the type that wants to set the log. That is exactly why these namespaces exist. For instance, you could set two different levels of logging for files inside the namespace.</p>
<p>In the preceding example configuration, the entire <strong class="source-inline">ToDoListApp</strong> is a set namespace to write logs only with <strong class="source-inline">LogLevel</strong> equal to or higher than <strong class="source-inline">Warning</strong>. You are also specifying that, for the <strong class="source-inline">ToDoListApp.Pages</strong> category/ namespace, the application will write all logs with a level equal to or higher than <strong class="source-inline">Information</strong>. This means that the changes on a more specific namespace override the settings that were set at a higher level.</p>
<p>This section showed you how to configure log levels for an application. With this knowledge, you can now grasp the concept of DI, as discussed in the following section.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor289"/>Dependency Injection</h2>
<p>Dependency Injection (DI) is a technique supported natively by the ASP.NET framework. It is a form of achieving a famous concept in object-oriented programming called Inversion of Control (IoC).</p>
<p>Any component that an object requires to function can be termed a dependency. In the case of a class, this might refer to parameters that need to be constructed. In the case of a method, it might be the method that parameters need for the execution. Using IoC with dependencies means delegating the responsibility of creating a class to the framework, instead of doing everything manually.</p>
<p>In <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>, you learned about interfaces. Interfaces are basically a common form of establishing a contract. They allow you to focus on what the outcome is of a call, rather than how it is executed. When you use IoC, your dependencies can now be interfaces instead of concrete classes. This allows your classes or methods to focus on the contracts established by these interfaces, instead of implementation details. This brings the following advantages:</p>
<ul>
<li>You can easily replace implementations without affecting any class that depends on the contracts.</li>
<li>It decouples the application boundaries and modules, as the contracts usually do not need any hardened dependencies.</li>
<li>It makes testing easier, allowing you to create these explicit dependencies as mocks, or fakes, and focus on behavior instead of real implementation details.</li>
</ul>
<p>Imagine now that to create the middleware of your application, you need to construct each of their dependencies, and you have a lot of middleware chained to each other on the constructor. Clearly, this would be a cumbersome process. Also, testing any of this middleware would be a tedious process, as you would need to rely on every single concrete implementation to create an object.</p>
<p>By injecting dependencies, you tell the compiler how to construct a class that has its dependencies declared on the constructor. The DI mechanism does this at runtime. This is equivalent to telling the compiler that whenever it finds a dependency of a certain type, it should resolve it using the appropriate class instance.</p>
<p>ASP.NET provides a native DI container, which stores the information pertaining to how a type should be resolved. You'll next learn how to store this information in the container.</p>
<p>In the <strong class="source-inline">Program.cs</strong> file, you'll see the call <strong class="source-inline">builder.Services.AddRazorPages()</strong>. The <strong class="source-inline">Services </strong>property is of type <strong class="source-inline">IServiceCollection</strong> and it holds the entire set of dependencies—also known as services—that is injected into the container. A lot of the required dependencies for an ASP.NET application to run are already injected in the <strong class="source-inline">WebApplication.CreateBuilder(args)</strong> method called at the top of the <strong class="source-inline">Program.cs</strong> file. This is true, for instance, for some native logging dependencies as you will see in the next exercise.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor290"/>Exercise 7.01: Creating Custom Logging Middleware</h2>
<p>In this exercise, you will create custom logging middleware that will output the details and the duration of an HTTP request to the console. After creating it, you will place it in the HTTP pipeline so that it is called by every request your application receives. The purpose is to give you a first practical introduction to the concepts of middleware, logging, and DI.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Create a new folder called <strong class="source-inline">Middlewares</strong>.</li>
<li>Inside this folder, create a new class named <strong class="source-inline">RequestLoggingMiddleware</strong>.</li>
<li>Create a new private readonly field named <strong class="source-inline">RequestDelegate</strong> and initialize this field inside the constructor:<p class="source-code">private readonly RequestDelegate _next;</p><p class="source-code">public RequestLoggingMiddleware(RequestDelegate next)</p><p class="source-code">{</p><p class="source-code">    _next = next; </p><p class="source-code">}</p></li>
</ol>
<p>This is the reference that ASP.NET gathers as the next middleware to be executed on the HTTP pipeline. By initializing this field, you can call the next registered middleware.</p>
<ol>
<li value="4">Add a <strong class="source-inline">using</strong> statement to the <strong class="source-inline">System.Diagnostics</strong> namespace so that a special class named <strong class="source-inline">Stopwatch</strong> can be added It will be used to measure the request time length:<p class="source-code">using System.Diagnostics;</p></li>
<li>Create a private <strong class="source-inline">readonly ILogger</strong> field. The <strong class="source-inline">ILogger</strong> interface is the default interface provided by .NET to manually log information.</li>
<li>After that, place a second parameter inside the constructor for the <strong class="source-inline">ILoggerFactory</strong> type. This interface is another one provided by .NET that allows you to create <strong class="source-inline">ILogger</strong> objects.</li>
<li>Use the <strong class="source-inline">CreateLogger&lt;T&gt;</strong> method from this factory to create a logger object:<p class="source-code">private readonly ILogger _logger;</p><p class="source-code">private readonly RequestDelegate _next;</p><p class="source-code">public RequestLoggingMiddleware(RequestDelegate next, ILoggerFactory loggerFactory)</p><p class="source-code">{</p><p class="source-code">    _next = next; </p><p class="source-code">    <strong class="bold">_logger = loggerFactory.CreateLogger&lt;RequestLoggingMiddleware&gt;()</strong>;</p><p class="source-code">}</p></li>
</ol>
<p>Here, <strong class="source-inline">T</strong> is a generic parameter that refers to a type, which is the log category, as seen in the <em class="italic">Logging</em> section. In this case, the category will be the type of the class where the logging will be done that is, the <strong class="source-inline">RequestLoggingMiddleware</strong> class.</p>
<ol>
<li value="8">Once the fields have been initialized, create a new method with the following signature:<p class="source-code">public async Task InvokeAsync(HttpContext context) { }</p></li>
<li>Inside this method, declare a variable called <strong class="source-inline">Stopwatch</strong> and assign the <strong class="source-inline">Stopwatch.StartNew()</strong> value to it:<p class="source-code">var stopwatch = Stopwatch.StartNew();</p></li>
</ol>
<p>The <strong class="source-inline">Stopwatch</strong> class is a helper that measures the execution time from the moment the .<strong class="source-inline">StartNew()</strong> method is called.</p>
<ol>
<li value="10">After this variable, write a <strong class="source-inline">try-catch</strong> block with code to call the next request as well as a call to the <strong class="source-inline">.Stop()</strong> method from the <strong class="source-inline">stopwatch</strong> to measure the elapsed time that the <strong class="source-inline">_next()</strong> call took:<p class="source-code">using System.Diagnostics;</p><p class="source-code">namespace ToDoListApp.Middlewares;</p><p class="source-code">public class RequestLoggingMiddleware</p><p class="source-code">{</p><p class="source-code">    private readonly ILogger _logger;</p><p class="source-code">    private readonly RequestDelegate _next;</p><p class="source-code">    public RequestLoggingMiddleware(RequestDelegate next, ILoggerFactory loggerFactory)</p><p class="source-code">    {</p><p class="source-code">        _next = next;</p><p class="source-code">        _logger = loggerFactory.CreateLogger&lt;RequestLoggingMiddleware&gt;();</p><p class="source-code">    }</p></li>
</ol>
<p>You can also deal with a possible exception here. So, it is better to wrap these two calls inside a <strong class="source-inline">try-catch</strong> method.</p>
<ol>
<li value="11">In the <strong class="source-inline">Program.cs</strong> file, call the custom middleware by placing the declaration as follows:<p class="source-code">var app = builder.Build();</p><p class="source-code">// Configure the HTTP request pipeline.app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();</p></li>
</ol>
<p>Write it in the line right below where the <strong class="source-inline">app</strong> variable is assigned.</p>
<ol>
<li value="12">Finally, in the <strong class="source-inline">Program.cs</strong> file, place a <strong class="source-inline">using</strong> statement to <strong class="source-inline">ToDoListApp.Middlewares</strong>:<p class="source-code-heading">Program.cs</p><p class="source-code">using ToDoListApp.Middlewares;</p><p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">// Add services to the container.</p><p class="source-code">builder.Services.AddRazorPages();</p><p class="source-code">var app = builder.Build();</p><p class="source-code">// Configure the HTTP request pipeline.</p><p class="source-code">app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();</p><p class="source-code">if (!app.Environment.IsDevelopment())</p><p class="source-code">{</p><p class="source-code">    app.UseExceptionHandler("/Error");</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/tX9iK">https://packt.link/tX9iK</a>.</p>
<ol>
<li value="13">To see the application running on your web browser and its output in the Visual Studio Code, type the following command at the address bar:<p class="source-code">localhost:####</p></li>
</ol>
<p>Here <strong class="source-inline">####</strong> represents the port number. This would be different for different  systems.</p>
<ol>
<li value="14">After pressing enter, the following screen gets displayed:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 7.2: Application running on the browser " height="832" src="image/B16835_07_02.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 7.2: Application running on the browser</p>
<ol>
<li value="15">Perform <em class="italic">Step 13</em> each time after executing the exercise/ activity in VS Code.</li>
<li>Press <strong class="source-inline">Control+C</strong> inside the VS code terminal to break the task before executing another exercise/ activity.</li>
<li>After executing the application in your browser, you'll see a similar output in the Visual Studio Code terminal:<p class="source-code">info: ToDoListApp.Middlewares.RequestLoggingMiddleware[0]</p><p class="source-code">      HTTP GET request for path / with status 200 executed in 301 ms</p><p class="source-code">info: ToDoListApp.Middlewares.RequestLoggingMiddleware[0]</p><p class="source-code">      HTTP GET request for path /lib/bootstrap/dist/css/bootstrap.min.css with status 200 executed in 18 ms</p><p class="source-code">info: ToDoListApp.Middlewares.RequestLoggingMiddleware[0]</p><p class="source-code">      HTTP GET request for path /css/site.css with status 200 executed in 1 ms</p><p class="source-code">info: ToDoListApp.Middlewares.RequestLoggingMiddleware[0]</p><p class="source-code">      HTTP GET request for path /favicon.ico with status 200 executed in 1 ms</p></li>
</ol>
<p>You will observe that the output on the console logs messages with an elapsed time of HTTP requests coming in the middleware pipelines. Since you've declared it with your methods, it should take the execution time considering all the pipeline chains.</p>
<p>In this exercise, you created your first middleware—the <strong class="source-inline">RequestLoggingMiddleware</strong>. This middleware measures the execution time of an HTTP request, in your HTTP pipeline. By placing it right before all other middlewares, you will be able to measure the entire execution time of a request that goes through the entire middleware pipeline.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/i04Iq">https://packt.link/i04Iq</a>.</p>
<p>Now imagine you have 10 to 20 middleware for the HTTP pipeline, each has its own dependencies, and you must manually instantiate each middleware. IoC comes in handy in such cases by delegating to ASP.NET the instantiation of these classes, as well as injecting their dependencies. You have already seen how to create custom middleware that uses the native ASP.NET logging mechanism with DI.</p>
<p>In ASP.NET, logging and DI are powerful mechanisms that allow you to create very detailed logs for an application. This is possible, as you've seen, through <strong class="source-inline">logger</strong> injection via constructors. For these loggers, you can create an object of a log category in two ways:</p>
<ul>
<li>As shown in the exercise, one way is the injection of <strong class="source-inline">ILoggerFactory</strong>. You could call the <strong class="source-inline">CreateLogger(categoryName)</strong> method, which receives a string as an argument. You could also call the <strong class="source-inline">CreateLogger&lt;CategoryType&gt;()</strong> method, which receives a generic type. This approach is preferable as it sets the category for the <strong class="source-inline">logger</strong> as the full name of the type (including the namespace).</li>
<li>Another way would be through the injection of <strong class="source-inline">ILogger&lt;CategoryType&gt;</strong>. In this case, the category type is usually the type of the class where you are injecting the logger, as seen in the previous exercise. In the previous exercise, you could replace the injection of <strong class="source-inline">ILoggerFactory</strong> with <strong class="source-inline">ILogger&lt;RequestLoggingMiddleware&gt;</strong> and assign this new injected dependency directly to the <strong class="source-inline">ILogger</strong> private field as follows:<p class="source-code">private readonly ILogger _logger;</p><p class="source-code">private readonly RequestDelegate _next;</p><p class="source-code">public RequestLoggingMiddleware(RequestDelegate next, ILogger&lt; RequestLoggingMiddleware&gt; logger)</p><p class="source-code">{</p><p class="source-code">    _next = next; </p><p class="source-code">    _logger = logger;</p><p class="source-code">}</p></li>
</ul>
<p>You now know that logging and DI are powerful mechanisms that allow you to create very detailed logs for an application. Before moving to Razor pages, it is important to learn about the life cycle of an object within an application. This is called the dependency lifetimes.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor291"/>Dependency Lifetimes</h2>
<p>Before moving on to the next and main topic of this chapter, it is important to talk about dependency lifetimes. All the dependencies used in the previous exercise were injected via the constructor. But the resolution of these dependencies was only possible because ASP.NET registers these dependencies beforehand, as mentioned in the <strong class="source-inline">Program.cs</strong> section. In the following code, you can see an example of code built into ASP.NET that deals with the logging dependency registration, by adding the <strong class="source-inline">ILoggerFactory</strong> dependency to the services container:</p>
<p class="source-code-heading">LoggingServiceCollectionExtensions.cs</p>
<p class="source-code">public static IServiceCollection AddLogging(this IServiceCollection services, Action&lt;ILoggingBuilder&gt; configure)</p>
<p class="source-code">{T</p>
<p class="source-code">if (services == null)</p>
<p class="source-code">     {</p>
<p class="source-code">     throw new ArgumentNullException(nameof(services));</p>
<p class="source-code">     }</p>
<p class="source-code">     services.AddOptions();</p>
<p class="source-code">     services.TryAdd(ServiceDescriptor.Singleton&lt;ILoggerFactory, LoggerFactory&gt;());</p>
<p class="source-code">     </p>
<p class="source-code">services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger&lt;&gt;), typeof(Logger&lt;&gt;)));</p>
<p class="source-code">services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IConfigureOptions&lt;LoggerFilterOptions&gt;&gt;(new DefaultLoggerLevelConfigureOptions(LogLevel.Information)));</p>
<p class="source-code">configure(new LoggingBuilder(services));</p>
<p class="source-code">return services;</p>
<p class="source-code">}</p>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/g4JPp">https://packt.link/g4JPp</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The preceding code is an example from a standard library and built into ASP.NET that deals with the logging dependency registration.</p>
<p>A lot is going on here, but the two important things to consider are as follows:</p>
<ul>
<li>The method here is <strong class="source-inline">TryAdd</strong>, which registers a dependency on the DI container.</li>
<li>The <strong class="source-inline">ServiceDescriptor.Singleton</strong> method is what defines a dependency lifetime. This is the final important concept of the <em class="italic">Dependency Injection</em> section of this chapter.</li>
</ul>
<p>A dependency lifetime describes the life cycle of an object within an application. ASP.NET has three default lifetimes that can be used to register a dependency:</p>
<ul>
<li>Transient: Objects with this lifetime are created every time they are requested and disposed of after use. This is effective for stateless dependencies, which are dependencies that do not need to keep the state when they are called. For instance, if you need to connect to an HTTP API to request some information, you can register a dependency with this lifetime, since HTTP requests are stateless.</li>
<li>Scoped: Objects with a scoped lifetime are created once for each client connection. For instance, in an HTTP request, a scoped dependency will have the same instance for the entire request, no matter how many times it is called. This dependency carries some state around for a certain amount of time. At the end of the connection, the dependency is disposed of.</li>
<li>Singleton: Objects with a singleton lifetime are created once for an entire application's lifetime. Once they are requested, their instance will be carried on while the application is running. This kind of lifetime should be considered carefully as it might consume a lot of memory.</li>
</ul>
<p>As mentioned before, the manual registration of these dependencies can be done in the <strong class="source-inline">ConfigureServices</strong> method located in the <strong class="source-inline">Startup</strong> class. Every new dependency that is not provided and automatically registered by ASP.NET should be manually registered there and knowing about these lifetimes is important as they allow the application to manage the dependencies in different ways.</p>
<p>You have learned that the resolution of these dependencies was only possible because ASP.NET registers three default lifetimes that can be used to register a dependency. You will now move on to Razor pages that enable the construction of page-based applications with all the capabilities provided and powered by ASP.NET.</p>
<h2 id="_idParaDest-260">R<a id="_idTextAnchor292"/>azor Pages</h2>
<p>Now that you have covered the main aspects pertaining to an ASP.NET application, you'll continue to build the application that you started at the beginning of the chapter. The goal here is to build a to-do list application, where you can easily create and manage a list of tasks on a Kanban-style board.</p>
<p>Earlier sections have referenced Razor Pages, but what exactly is it? Razor Pages is a framework that enables the construction of page-based applications with all the capabilities provided and powered by ASP.NET. It was created to enable the building of dynamic data-driven applications with a clear separation of concerns that is, having each method and class with separate but complementary responsibilities.</p>
<h3 id="_idParaDest-261">B<a id="_idTextAnchor293"/>asic Razor Syntax</h3>
<p>Razor Pages uses Razor syntax, a syntax powered by Microsoft that enables a page to have static HTML/ CSS/ JS, C# code, and custom tag helpers, which are reusable components that enable the rendering of HTML pieces in pages.</p>
<p>If you look at the <strong class="source-inline">.cshtml</strong> files generated by the <strong class="source-inline">dotnet new</strong> command that you ran in the first exercise, you will notice a lot of HTML code and, inside this code, some methods, and variables with a <strong class="source-inline">@</strong> prefix. In Razor, as soon as you write this symbol, the compiler detects that some C# code will be written. You're already aware that HTML is a markup language used to build web pages. Razor uses it along with C# to create powerful markup combined with server-rendered code.</p>
<p>If you want to place a block of code, it can be done within brackets like:</p>
<p class="source-code">@{ … }</p>
<p>Inside this block, you are allowed to do basically everything you can do with C# syntax, from local variable declarations to loops and more. If you want to put a <strong class="source-inline">static @</strong>, you have to escape it by placing two <strong class="source-inline">@</strong> symbols for it to be rendered in HTML. That happens, for instance, in email IDs, such as <strong class="source-inline">james@@bond.com</strong>.</p>
<h3 id="_idParaDest-262">F<a id="_idTextAnchor294"/>ile Structure</h3>
<p>Razor Pages end with the <strong class="source-inline">.cshtml</strong> extension and might have another file, popularly called the <strong class="bold">code-behind </strong>file, which has the same name but with the <strong class="source-inline">.cshtml.cs</strong> extension. If you go to the root folder of your application and navigate to the <strong class="source-inline">Pages</strong> folder, you will see the following structure generated upon the creation of a page:</p>
<p class="source-code">|-- /Pages</p>
<p class="source-code">|---- /Shared |------ _Layout.cshtml |------ _ValidationScriptsPartial.cshtml |---- _ViewImports.cshtml</p>
<p class="source-code">|---- _ViewStart.cshtml</p>
<p class="source-code">|---- Error.cshtml</p>
<p class="source-code">|---- Error.cshtml.cs</p>
<p class="source-code">|---- Index.cshtml</p>
<p class="source-code">|---- Index.cshtml.cs</p>
<p class="source-code">|---- Privacy.cshtml</p>
<p class="source-code">|---- Privacy.cshtml.cs</p>
<p>The <strong class="source-inline">Index</strong>, <strong class="source-inline">Privacy</strong>, and <strong class="source-inline">Error</strong> pages are automatically generated after project creation. Briefly look at the other files here.</p>
<p>The <strong class="source-inline">/Shared</strong> folder contains a shared <strong class="source-inline">Layout</strong> page that is used by default in the application. This page contains some shared sections, such as navbars, headers, footers, and metadata, that repeat in almost every application page:</p>
<p class="source-code-heading">_Layout.cshtml</p>
<p class="source-code">&lt;!DOCTYPE html&gt;</p>
<p class="source-code">&lt;html lang="en"&gt;</p>
<p class="source-code">&lt;head&gt;</p>
<p class="source-code">    &lt;meta charset="utf-8" /&gt;</p>
<p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</p>
<p class="source-code">    &lt;title&gt;@ViewData["Title"] - ToDoListApp&lt;/title&gt;    &lt;link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" /&gt;</p>
<p class="source-code">    &lt;link rel="stylesheet" href="~/css/site.css" asp-append-version="true" /&gt;</p>
<p class="source-code">    &lt;link rel="stylesheet" href="~/ToDoListApp.styles.css" asp-append-version="true" /&gt;</p>
<p class="source-code">&lt;/head&gt;</p>
<p class="source-code">&lt;body&gt;</p>
<p class="source-code">    &lt;header&gt;</p>
<p class="source-code">        &lt;nav class="navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3"&gt;</p>
<p class="source-code">            &lt;div class="container"&gt;</p>
<p class="source-code">                &lt;a class="navbar-brand" asp-area="" asp-page="/Index"&gt;ToDoListApp&lt;/a&gt;</p>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/2Hb8r">https://packt.link/2Hb8r</a>.</p>
<p>Keeping these shared sections in a single file makes reusability and maintainability easier. If you look at this <strong class="source-inline">Layout</strong> page generated in your boilerplate, there are some things worth highlighting:</p>
<ul>
<li>By default, a Razor Pages app is generated using Twitter Bootstrap for design—a library used for writing beautiful, simple, and responsive websites—and jQuery for basic scripting. This can be customized for each application, as those are just static files.</li>
<li>There is a special <strong class="source-inline">RenderBody()</strong> method that indicates where the generated HTML for the application pages will be placed.</li>
<li>Another method, named <strong class="source-inline">RenderSection()</strong>, is useful for rendering predefined sections per page. It is useful, for instance, when some static file, such as an image, script, or stylesheet, is needed only for some pages. In this way, you can place these files inside specific sections only in the pages where they are needed and call the <strong class="source-inline">RenderSection</strong> method at the level of the HTML you want them to be rendered. This is done on the <strong class="source-inline">_Layout.cshtml</strong> page.</li>
</ul>
<p>The <strong class="source-inline">_ViewImports.cshtml</strong> file is another important file; it enables the application pages to share common directives and reduces effort by placing these directives on every page. It is where all the global using namespaces, tag helpers, and global <strong class="source-inline">Pages</strong> namespaces are defined. Some of the directives this file supports are as follows:</p>
<ul>
<li><strong class="source-inline">@namespace</strong>: Used to set the base namespace for <strong class="source-inline">Pages</strong>.</li>
<li><strong class="source-inline">@inject</strong>: Used to place DI within the page.</li>
<li><strong class="source-inline">@model</strong>: Includes <strong class="source-inline">PageModel</strong>, a class that will determine what information the page will handle.</li>
<li><strong class="source-inline">@using</strong>: Similar to the <strong class="source-inline">.cs</strong> files, this directive allows you to fully qualify namespaces at the top level of a Razor page to avoid repeating these namespaces throughout the code.</li>
</ul>
<p>The <strong class="source-inline">_ViewStart.cshtml</strong> file is used to place code that will be executed at the start of each page call. On this page, you define the <strong class="source-inline">Layout</strong> property while setting the <strong class="source-inline">Layout</strong> page.</p>
<p>Now that you are familiar with the basics of Razor Pages, it is time to start working on your application and dive into some more interesting topics. You will start by creating the basic structure of the to-do list application.</p>
<h2 id="_idParaDest-263">E<a id="_idTextAnchor295"/>xercise 7.02: Creating a Kanban Board with Razor</h2>
<p>The goal of this exercise will be to start the to-do application creation with its first component—a Kanban board. This board is used for controlling workflows, where people can divide their work into cards and move these cards between different statuses, such as To Do, Doing, and Done. A popular application that uses this is Trello. The same <strong class="source-inline">ToDoListApp</strong> project created in the <em class="italic">Exercise 7.01 </em>will be used throughout this chapter to learn new concepts and incrementally evolve the application, including in this exercise. Perform the following steps:</p>
<ol>
<li value="1">Navigate to the root folder of your application and create a folder named <strong class="source-inline">Models</strong>.</li>
<li>Inside the <strong class="source-inline">Models</strong> folder, create a new <strong class="source-inline">enum</strong> called <strong class="source-inline">ETaskStatus</strong> with the <strong class="source-inline">ToDo</strong>, <strong class="source-inline">Doing</strong>, and <strong class="source-inline">Done</strong> options:<p class="source-code">public enum ETaskStatus {</p><p class="source-code">ToDo,</p><p class="source-code">Doing,</p><p class="source-code">Done</p><p class="source-code">}</p></li>
<li>Again, in the <strong class="source-inline">Models</strong> folder, create a new class called <strong class="source-inline">ToDoTask</strong> that will be used to create a new task for your to-do list with the following properties:<p class="source-code">namespace ToDoListApp.Models;</p><p class="source-code">public class ToDoTask</p><p class="source-code">{</p><p class="source-code">    public Guid Id { get; set; }</p><p class="source-code">    public DateTime CreatedAt { get; set; }</p><p class="source-code">    public DateTime? DueTo { get; set; }</p><p class="source-code">    public string Title { get; set; }</p><p class="source-code">    public string? Description { get; set; }</p><p class="source-code">    public ETaskStatus Status { get; set; }</p><p class="source-code">}</p></li>
<li>Create two constructors as shown here for the <strong class="source-inline">ToDoTask</strong> class:<p class="source-code-heading">ToDoTask.cs</p><p class="source-code">namespace ToDoListApp.Models;</p><p class="source-code">public class ToDoTask</p><p class="source-code">{</p><p class="source-code">    public ToDoTask()</p><p class="source-code">    {</p><p class="source-code">        CreatedAt = DateTime.UtcNow;</p><p class="source-code">        Id = Guid.NewGuid();</p><p class="source-code">    }</p><p class="source-code">    public ToDoTask(string title, ETaskStatus status) : this()</p><p class="source-code">    {</p><p class="source-code">        Title = title;</p><p class="source-code">        Status = status;</p><p class="source-code">    }</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/nFk00">https://packt.link/nFk00</a>.</p>
<p>Create one with no parameters to set the default values for the <strong class="source-inline">Id</strong> and <strong class="source-inline">CreatedAt</strong> properties, and the other with lowercase-named parameters for the preceding class to initialize the <strong class="source-inline">Title</strong> and <strong class="source-inline">Status</strong> properties.</p>
<p>The <strong class="source-inline">Pages</strong>/ <strong class="source-inline">Index.cshtml</strong> is automatically generated in your application boilerplate. It is this page that will be the entry point of your application.</p>
<ol>
<li value="5">Now, customize it by editing the file <strong class="source-inline">Pages</strong>/ <strong class="source-inline">Index.cshtml.cs</strong> and replacing the boilerplate code with the code shown as follows:<p class="source-code-heading">Index.cshtml.cs</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using Microsoft.AspNetCore.Mvc.RazorPages;</p><p class="source-code">using ToDoListApp.Models;</p><p class="source-code">namespace ToDoListApp.Pages;</p><p class="source-code">public class IndexModel : PageModel</p><p class="source-code">{</p><p class="source-code">    public IList&lt;ToDoTask&gt; Tasks { get; set; } = new List&lt;ToDoTask&gt;();</p><p class="source-code">    public IndexModel()</p><p class="source-code">    {</p><p class="source-code">    }</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/h8mni">https://packt.link/h8mni</a>.</p>
<p>Basically, this code fills your model. Here, the <strong class="source-inline">OnGet</strong> method of <strong class="source-inline">PageModel</strong> is used to tell the application that when the page is loaded, it should fill the model with the properties assigned to <strong class="source-inline">Task</strong> </p>
<ol>
<li value="6">Replace the code within <strong class="source-inline">Pages</strong>/ <strong class="source-inline">Index.cshtml</strong> with the code shown as follows in order to create your Kanban board with the task cards:<p class="source-code-heading">Index.cshtml</p><p class="source-code">@page</p><p class="source-code">@using ToDoListApp.Models</p><p class="source-code">@model IndexModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "My To Do List";</p><p class="source-code">}</p><p class="source-code">&lt;div class="text-center"&gt;</p><p class="source-code">    &lt;h1 class="display-4"&gt;@ViewData["Title"]&lt;/h1&gt;</p><p class="source-code">    &lt;div class="row"&gt;</p><p class="source-code">        &lt;div class="col-4"&gt;</p><p class="source-code">            &lt;div class="card bg-light"&gt;</p><p class="source-code">                &lt;div class="card-body"&gt;</p><p class="source-code">                    &lt;h6 class="card-title text-uppercase text-truncate py-2"&gt;To Do&lt;/h6&gt;</p><p class="source-code">                    &lt;div class="border border-light"&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/IhELU">https://packt.link/IhELU</a>.</p>
<p>This page is your view. It shares the properties from the <strong class="source-inline">Pages</strong>/ <strong class="source-inline">Index.cshtml.cs</strong> class (also called the code-behind class). When you assign a value to the <strong class="source-inline">Tasks</strong> property in the code-behind class, it becomes visible to the view. With this property, you can populate the HTML from the page.</p>
<ol>
<li value="7">Now, run your application with the <strong class="source-inline">dotnet run</strong> command. You will see the following on the <strong class="source-inline">Index</strong> page when the application is loaded on the browser:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 7.3: Displaying your first application, the Kanban board " height="607" src="image/B16835_07_03.jpg" width="1321"/>
</div>
</div>
<p class="figure-caption">Figure 7.3: Displaying your first application, the Kanban board</p>
<p>Notice that, for now, the application does not contain any logic. What you built here is simply a UI powered by the <strong class="source-inline">PageModel</strong> data.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/1PRdq">https://packt.link/1PRdq</a>.</p>
<p>As you saw in <em class="italic">Exercise 7.02</em>, for every page created there are two main types of files which are a <strong class="source-inline">.cshtml</strong> and a <strong class="source-inline">.cshtml.cs</strong> file. These files form the foundations of each Razor page. The next section will detail about this difference in the filename suffix and how these two files complement each other.</p>
<h2 id="_idParaDest-264">Pa<a id="_idTextAnchor296"/>geModel</h2>
<p>In the <strong class="source-inline">Index.cshtml.cs</strong> file that you created in <em class="italic">Exercise 7.02</em>, you might have noticed that the class inside it inherits from the <strong class="source-inline">PageModel</strong> class. Having this code-behind class provides some advantages—such as a clear separation of concerns between the client and the server—and this makes maintenance and development easier. It also enables you to create both unit and integration tests for the logic placed on the server. You will learn more about testing in <em class="italic">Chapter 10</em>, <em class="italic">Automated Testing</em>.</p>
<p>A <strong class="source-inline">PageModel</strong> may contain some properties that are bound to the view. In <em class="italic">Exercise 7.02</em>, the <strong class="source-inline">IndexModel </strong>page has a property that is a <strong class="source-inline">List&lt;ToDoTask&gt;</strong>. This property is then populated when the page loads on the <strong class="source-inline">OnGet()</strong> method. So how does populating happen? The next section will discuss the life cycle of populating properties and using them within <strong class="source-inline">PageModel</strong>.</p>
<h3 id="_idParaDest-265">Th<a id="_idTextAnchor297"/>e Life Cycle with Page Handlers</h3>
<p>Handler methods are a core feature of Razor Pages. These methods are automatically executed when the server receives a request from the page. In <em class="italic">Exercise 7.02</em>, for instance, the <strong class="source-inline">OnGet</strong> method will be executed each time the page receives a <strong class="source-inline">GET</strong> request.</p>
<p>By convention, the handler methods will answer according to the HTTP verb of the request. So, for instance, if you wanted something to be executed after a <strong class="source-inline">POST</strong> request, you should have an <strong class="source-inline">OnPost</strong> method. Also, after a <strong class="source-inline">PUT</strong> request, you should have an <strong class="source-inline">OnPut</strong> method. Each of these methods has an asynchronous equivalent, which changes the method's signature; an <strong class="source-inline">Async</strong> suffix is added to the method name, and it returns a <strong class="source-inline">Task</strong> property instead of <strong class="source-inline">void</strong>. This also makes the <strong class="source-inline">await</strong> functionality available for the method.</p>
<p>There is, however, one tricky scenario in which you may want a form to perform multiple actions with the same HTTP verb. In that case, you could perform some confusing logic on the backend to handle different inputs. Razor Pages, however, provides you with a functionality right out of the box called <strong class="bold">tag helpers</strong>, which allows you to create and render HTML elements on the server before placing them on the client. The anchor tag helper has an attribute called <strong class="source-inline">asp-page-handler</strong> that allows you to specify the name of the handler being called on the server. Tag helpers will be discussed in the next section, but for now, consider the following code as an example. The code contains an HTML form containing two submit buttons, to perform two different actions—one for creating an order, and the other for canceling an order:</p>
<p class="source-code">&lt;form method="post"&gt;</p>
<p class="source-code">    &lt;button asp-page-handler="PlaceOrder"&gt;Place Order&lt;/button&gt;</p>
<p class="source-code">    &lt;button asp-page-handler="CancelOrder"&gt;Cancel Order&lt;/button&gt;</p>
<p class="source-code">&lt;/form&gt;</p>
<p>On the server side, you only need to have two handlers, one for each action, as shown in the following code:</p>
<p class="source-code">public async Task&lt;IActionResult&gt; OnPostPlaceOrderAsync()</p>
<p class="source-code">{</p>
<p class="source-code">    // …</p>
<p class="source-code">}</p>
<p class="source-code">public async Task&lt;IActionResult&gt; OnPostCancelOrderAsync()</p>
<p class="source-code">{</p>
<p class="source-code">    // …</p>
<p class="source-code">}</p>
<p>Here, the code behind the page matches the value of the <strong class="source-inline">form</strong> method and the <strong class="source-inline">asp-page-handler</strong> tag on the <strong class="source-inline">.cshtml</strong> file to the method name on the code-behind file. That way, you can have multiple actions for the same HTTP verb in the same form.</p>
<p>A final note on this subject is that in this case, the method name on the server should be written as:</p>
<p class="source-code">On + {VERB} + {HANDLER}</p>
<p>This is written with or without the <strong class="source-inline">Async</strong> suffix. In the previous example, the <strong class="source-inline">OnPostPlaceOrderAsync</strong> method is the <strong class="source-inline">PlaceOrder</strong> handler for the <strong class="source-inline">PlaceOrder</strong> button, and <strong class="source-inline">OnPostCancelOrderAsync</strong> is the handler for the <strong class="source-inline">CancelOrder</strong> button.</p>
<h3 id="_idParaDest-266">Re<a id="_idTextAnchor298"/>ndering Reusable Static Code with Tag Helpers</h3>
<p>One thing you might have noticed is that the HTML written previously is lengthy. You created Kanban cards, lists, and a board to wrap it all. If you take a closer look at the code, it has the same pattern repeated all the way through. That raises one major problem, maintenance. It is hard to imagine having to handle, maintain, and evolve all this plain text.</p>
<p>Fortunately, tag helpers can be immensely useful in this regard. They are basically components that render static HTML code. ASP.NET has a set of built-in tag helpers with custom server-side attributes, such as anchors, forms, and images. Tag helpers are a core feature that helps make advanced concepts easy to handle, such as model binding, which will be discussed a little further ahead.</p>
<p>Besides the fact that they add rendering capabilities to built-in HTML tags, they are also an impressive way to achieve reusability on static and repetitive code. In the next exercise, you will learn how to create a customized tag helper.</p>
<h2 id="_idParaDest-267">Ex<a id="_idTextAnchor299"/>ercise 7.03: Creating Reusable Components with Tag Helpers</h2>
<p>In this exercise, you are going to improve upon your work in the previous one. The improvement here will be to simplify the HTML code by moving part of this code that could be reused to custom tag helpers.</p>
<p>To do so, perform the following steps:</p>
<ol>
<li value="1">Open the <strong class="source-inline">_ViewImports.cshtml</strong> file, which was created with your application.</li>
<li>Add the following lines to the end with the content to define custom tag helpers <strong class="source-inline">@addTagHelper</strong> directive:<p class="source-code">@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers</p><p class="source-code">@addTagHelper *, ToDoListApp </p></li>
</ol>
<p>In the preceding code, you added all the custom tag helpers that exist within this namespace using the asterisk (<strong class="source-inline">*</strong>).</p>
<ol>
<li value="3">Now, create a new folder under the project's root (<strong class="source-inline">ToDoApp</strong>) called <strong class="source-inline">TagHelpers</strong>.</li>
<li>Create a new class inside this folder called <strong class="source-inline">KanbanListTagHelper.cs</strong>.</li>
<li>Make this class inherit from the <strong class="source-inline">TagHelper</strong> class:<p class="source-code">namespace ToDoListApp.TagHelpers;</p></li>
<li>This inheritance is what allows ASP.NET to identify both built-in and custom tag helpers.</li>
<li>Now place a <strong class="source-inline">using</strong> statement for the <strong class="source-inline">Microsoft.AspNetCore.Razor.TagHelpers</strong> namespace:<p class="source-code">using Microsoft.AspNetCore.Razor.TagHelpers;</p><p class="source-code">namespace ToDoListApp.TagHelpers;</p><p class="source-code">public class KanbanListTagHelper : TagHelper</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>For the <strong class="source-inline">KanbanListTagHelper</strong> class, create two string properties, called <strong class="source-inline">Name</strong> and <strong class="source-inline">Size</strong>, with getters and setters:<p class="source-code">using Microsoft.AspNetCore.Razor.TagHelpers;</p><p class="source-code">namespace ToDoListApp.TagHelpers;</p><p class="source-code">public class KanbanListTagHelper : TagHelper</p><p class="source-code">{</p><p class="source-code">    public string? Name { get; set; }</p><p class="source-code">    public string? Size { get; set; }</p><p class="source-code">}</p></li>
<li>Override the base asynchronous <strong class="source-inline">ProcessAsync (TagHelperContext context</strong>, <strong class="source-inline">TagHelperOutput)</strong> output method with the following code:<p class="source-code-heading">KanbanListTagHelper.cs</p><p class="source-code">public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)</p><p class="source-code">{</p><p class="source-code">     output.TagName = "div";</p><p class="source-code">     output.Attributes.SetAttribute("class", $"col-{Size}");</p><p class="source-code">     output.PreContent.SetHtmlContent(</p><p class="source-code">     $"&lt;div class=\"card bg-light\"&gt;"</p><p class="source-code">          + "&lt;div class=\"card-body\"&gt;"</p><p class="source-code">          + $"&lt;h6 class=\"card-title text-uppercase text-truncate py-     2\"&gt;{Name}&lt;/h6&gt;"</p><p class="source-code">          + "&lt;div class \"border border-light\"&gt;");</p><p class="source-code">     var childContent = await output.GetChildContentAsync();</p><p class="source-code">     output.Content.SetHtmlContent(childContent.GetContent());</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/bjFIk">https://packt.link/bjFIk</a>.</p>
<p>Every tag helper has a standard HTML tag as an output. That is why, at the beginning of your methods, the <strong class="source-inline">TagName</strong> property was called from the <strong class="source-inline">TagHelperOutput</strong> object to specify the HTML tag that will be used as output. Additionally, you can set the attributes for this HTML tag by calling the <strong class="source-inline">Attributes</strong> property and its <strong class="source-inline">SetAttribute</strong> method from the <strong class="source-inline">TagHelperOutput</strong> object. That is what you did right after specifying the HTML output tag.</p>
<ol>
<li value="10">Now, create another class named <strong class="source-inline">KanbanCardTagHelper.cs</strong> with the same inheritance and namespace using a statement such as the previous one:<p class="source-code">namespace ToDoListApp.TagHelpers;</p><p class="source-code">using Microsoft.AspNetCore.Razor.TagHelpers;</p><p class="source-code">public class KanbanCardTagHelper: TagHelper</p><p class="source-code">{</p><p class="source-code">    public string? Task { get; set; }</p><p class="source-code">}</p></li>
</ol>
<p>For this class, create a <strong class="source-inline">string</strong> property with public getters and setters named <strong class="source-inline">Task.</strong></p>
<ol>
<li value="11">In this new class, override the base synchronous <strong class="source-inline">Process(TagHelperContext context, TagHelperOutput output)</strong> method. Within this method, write the following code:<p class="source-code">public override void Process(TagHelperContext context, TagHelperOutput output)</p><p class="source-code">{</p><p class="source-code">     output.TagName = "div";</p><p class="source-code">     output.Attributes.SetAttribute("class", "card");</p><p class="source-code">     output.PreContent.SetHtmlContent(</p><p class="source-code">     "&lt;div class=\"card-body p-2\"&gt;"</p><p class="source-code">          + "&lt;div class=\"card-title\"&gt;");</p><p class="source-code">     output.Content.SetContent(Task);</p><p class="source-code">     output.PostContent.SetHtmlContent(</p><p class="source-code">     "&lt;/div&gt;"</p><p class="source-code">          + "&lt;button class=\"btn btn-primary btn-sm\"&gt;View&lt;/button&gt;"</p><p class="source-code">          + "&lt;/div&gt;");</p><p class="source-code">output.TagMode = TagMode.StartTagAndEndTag;</p><p class="source-code">}</p></li>
</ol>
<p>An important concept to know about is how the HTML content is placed within the tag helper. As you can see, the code uses three different properties from the <strong class="source-inline">TagHelperOutput</strong> object to place the content:</p>
<ul>
<li><strong class="source-inline">PreContent</strong></li>
<li><strong class="source-inline">Content</strong></li>
<li><strong class="source-inline">PostContent</strong></li>
</ul>
<p>The pre-and post-properties are useful to set the content right before and after that you want to generate. A use case for them is when you want to set up fixed content as <strong class="source-inline">div</strong> containers, headers, and footers.</p>
<p>Another thing you did here was set how the tag helper will be rendered through the <strong class="source-inline">Mode</strong> property. You used <strong class="source-inline">TagMode.StartTagAndEndTag</strong> as a value because you used a <strong class="source-inline">div</strong> container as a tag output for the tag helper, and <strong class="source-inline">div</strong> elements have both start and end tags in HTML. If the output tag were some other HTML element, such as email, which is self-closing, you would use <strong class="source-inline">TagMode.SelfClosing</strong> instead.</p>
<ol>
<li value="12">Finally, go to the <strong class="source-inline">Index.cshtml</strong> file under the Pages folder and replace the HTML created in <em class="italic">Exercise 7.02</em> with the tag helpers to make your code concise:<p class="source-code-heading">Index.cshtml </p><p class="source-code">@page</p><p class="source-code">@using ToDoListApp.Models</p><p class="source-code">@model IndexModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "My To Do List";</p><p class="source-code">}</p><p class="source-code">&lt;div class="text-center"&gt;</p><p class="source-code">    &lt;h1 class="display-4"&gt;@ViewData["Title"]&lt;/h1&gt;</p><p class="source-code">    &lt;div class="row"&gt;</p><p class="source-code">        &lt;kanban-list name="To Do" size="4"&gt;</p><p class="source-code">            @foreach (var task in Model.Tasks.Where(t =&gt; t.Status == ETaskStatus.ToDo))</p><p class="source-code">            {</p><p class="source-code">                &lt;kanban-card task="@task.Description"&gt;</p><p class="source-code">                &lt;/kanban-card&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/YIgdp">https://packt.link/YIgdp</a>.</p>
<ol>
<li value="13">Now run the application with the following command:<p class="source-code">dotnet run</p></li>
<li>In your browser, navigate to the localhost:#### address provided by the Visual Studio console output just like you did in the last exercise:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 7.4: The frontend displayed in the browser " height="670" src="image/B16835_07_04.jpg" width="1321"/>
</div>
</div>
<p class="figure-caption">Figure 7.4: The frontend displayed in the browser</p>
<p>You will see the same result at the frontend that you had before, as shown in <em class="italic">Figure 7.3</em>. The improvement is in the fact that even though the output is the same, you have now a much more modular and concise code to maintain and evolve.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/YEdiU">https://packt.link/YEdiU</a>.</p>
<p>In this exercise, you used tag helpers to create reusable components that generate static HTML code. You can see now that the HTML code is much cleaner and more concise. The next section will detail about creating interactive pages by linking what's on the Code Behind with your HTML view using the concept of model binding.</p>
<h2 id="_idParaDest-268">Mod<a id="_idTextAnchor300"/>el Binding</h2>
<p>So far, you have covered concepts that helped create a foundation for the to-do app. As a quick recap, the main points are as follows:</p>
<ul>
<li><strong class="source-inline">PageModel</strong> is used to add data to a page.</li>
<li>Tag helpers add custom static rendering to the HTML generated by the server.</li>
<li>Handler methods define the way a page interacts with an HTTP request.</li>
</ul>
<p>One final overarching concept that is central to building Razor Pages applications is model binding. The data used as arguments in handler methods and passed through the page model is rendered through this mechanism. It consists of extracting data in key/ value pairs from HTTP requests and placing them in either the client-side HTML or the server-side code, depending on the direction of the binding that is, whether the data is moving from client to server or from server to client.</p>
<p>This data might be placed in routes, forms, or query strings and is binding to .NET types, either primitive or complex. <em class="italic">Exercise 7.04</em> will help clarify how the model binding works when coming from the client to the server.</p>
<h2 id="_idParaDest-269">Exe<a id="_idTextAnchor301"/>rcise 7.04: Creating a New Page to Submit Tasks</h2>
<p>The goal of this exercise is to create a new page. It will be used to create new tasks that will be displayed on the Kanban board. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the project root folder, run the following commands:<p class="source-code">dotnet add package Microsoft.EntityFrameworkCore</p><p class="source-code">dotnet add package Microsoft.EntityFrameworkCore.Sqlite</p><p class="source-code">dotnet add package Microsoft.EntityFrameworkCore.Design</p></li>
<li>At the root of the project, create a new folder named <strong class="source-inline">Data</strong> with a <strong class="source-inline">ToDoDbContext</strong> class inside it. This class will inherit from Entity Framework's <strong class="source-inline">DbContext</strong> and will be used to access the database.</li>
<li>Now add the following code in it:<p class="source-code">using Microsoft.EntityFrameworkCore;</p><p class="source-code">using ToDoListApp.Models;</p><p class="source-code">namespace ToDoListApp.Data;</p><p class="source-code">public class ToDoDbContext : DbContext</p><p class="source-code">{</p><p class="source-code">    public ToDoDbContext(DbContextOptions&lt;ToDoDbContext&gt; options) : base(options)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">    public DbSet&lt;ToDoTask&gt; Tasks { get; set; } </p><p class="source-code">}</p></li>
<li>Update your <strong class="source-inline">Program.cs</strong> file to match the following:<p class="source-code-heading">Program.cs</p><p class="source-code">using Microsoft.EntityFrameworkCore;</p><p class="source-code">using ToDoListApp.Data;</p><p class="source-code">using ToDoListApp.Middlewares;</p><p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">// Add services to the container.builder.Services.AddRazorPages();</p><p class="source-code">builder.Services.AddDbContext&lt;ToDoDbContext&gt;(opt =&gt; opt.UseSqlite("Data Source=Data/ToDoList.db")); </p><p class="source-code">var app = builder.Build();</p><p class="source-code">// Configure the HTTP request pipeline.app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/D4M8o">https://packt.link/D4M8o</a>.</p>
<p>This change will register the <strong class="source-inline">DbContext</strong> dependencies within the DI container, as well as sets up the database access.</p>
<ol>
<li value="5">Run the following commands on the terminal to install the <strong class="source-inline">dotnet ef</strong> tool. This is a CLI tool that will help you to iterate with database helpers, such as schema creation and update:<p class="source-code">dotnet tool install --global dotnet-ef</p></li>
<li>Now, build the application and run the following commands on the terminal:<p class="source-code">dotnet ef migrations add 'FirstMigration'</p><p class="source-code">dotnet ef database update</p></li>
</ol>
<p>These commands will create a new migration that will create the schema from your database and apply this migration to your database.</p>
<ol>
<li value="7">After the migration has run and the database is updated, create a new folder called <strong class="source-inline">Tasks</strong> inside the <strong class="source-inline">Pages</strong> folder.</li>
<li>Move the Index page files—<strong class="source-inline">index.cshtml</strong> and <strong class="source-inline">index.cshtml.cs</strong>—to the <strong class="source-inline">Tasks</strong> folder.</li>
<li>Next, replace the <strong class="source-inline">AddRazorPages</strong> call in the <strong class="source-inline">Program.cs</strong> with the following call:<p class="source-code">builder.Services.AddRazorPages(opt =&gt;{    opt.Conventions.AddPageRoute("/Tasks/Index", ""); });</p></li>
</ol>
<p>This will add a convention for the page routes to be called.</p>
<ol>
<li value="10">Replace the header tag inside the <strong class="source-inline">_Layout.cshtml</strong> file (under <strong class="source-inline">Pages/Shared/</strong>) to create a shared <strong class="source-inline">navbar</strong> for the application:<p class="source-code">&lt;header&gt;</p><p class="source-code">        &lt;nav class="navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3"&gt;</p><p class="source-code">            &lt;div class="container"&gt;</p><p class="source-code">                &lt;a class="navbar-brand" asp-area="" asp-page="/Index"&gt;MyToDos&lt;/a&gt;</p><p class="source-code">                &lt;button class="navbar-toggler" type="button" data-toggle="collapse" data-target=".navbar-collapse" aria-controls="navbarSupportedContent"</p><p class="source-code">                        aria-expanded="false" aria-label="Toggle navigation"&gt;</p><p class="source-code">                    &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt;</p><p class="source-code">                &lt;/button&gt;</p><p class="source-code">                &lt;div class="navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse"&gt;</p><p class="source-code">                    &lt;ul class="navbar-nav flex-grow-1"&gt;</p><p class="source-code">                        &lt;li class="nav-item"&gt;</p><p class="source-code">                            &lt;a class="nav-link text-dark" asp-area="" asp-page="/tasks/create"&gt;Create Task&lt;/a&gt;</p><p class="source-code">                        &lt;/li&gt;</p><p class="source-code">                    &lt;/ul&gt;</p><p class="source-code">                &lt;/div&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">        &lt;/nav&gt;</p><p class="source-code">    &lt;/header&gt;</p></li>
</ol>
<p>This <strong class="source-inline">navbar</strong> will allow you to access the newly created page.</p>
<ol>
<li value="11">Create the <strong class="source-inline">Create.cshtml</strong> page (under <strong class="source-inline">Pages/Tasks/</strong>) and add the following code:<p class="source-code-heading">Create.cshtml</p><p class="source-code">@page "/tasks/create"</p><p class="source-code">@model CreateModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "Task";</p><p class="source-code">}</p><p class="source-code">&lt;h2&gt;Create&lt;/h2&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;h4&gt;@ViewData["Title"]&lt;/h4&gt;</p><p class="source-code">    &lt;hr /&gt;</p><p class="source-code">    &lt;dl class="row"&gt;</p><p class="source-code">        &lt;form method="post" class="col-6"&gt;</p><p class="source-code">            &lt;div class="form-group"&gt;</p><p class="source-code">                &lt;label asp-for="Task.Title"&gt;&lt;/label&gt;</p><p class="source-code">                &lt;input asp-for="Task.Title" class="form-control" /&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/2NjdN">https://packt.link/2NjdN</a>.</p>
<p>This should contain a form that will use a <strong class="source-inline">PageModel</strong> class to create the new tasks. For each form input field, an <strong class="source-inline">asp-for</strong> attribute is used inside the <strong class="source-inline">input</strong> tag helper. This attribute is responsible for filling the HTML input with a proper value in the <strong class="source-inline">name</strong> attribute.</p>
<p>Since you are binding to a complex property inside the page model named <strong class="source-inline">Task</strong>, the name value is generated with the following syntax:</p>
<p class="source-code">{PREFIX}_{PROPERTYNAME} pattern</p>
<p>Here <strong class="source-inline">PREFIX</strong> is the complex object name on the <strong class="source-inline">PageModel</strong>. So, for an ID of a task, an input with <strong class="source-inline">name="Task_Id"</strong> is generated on the client-side and the input is populated with the <strong class="source-inline">value</strong> attribute having the <strong class="source-inline">Task.Id</strong> property value that comes from the server. In the case of the page, as you are creating a new task, the field does not come previously populated. That is because with the <strong class="source-inline">OnGet</strong> method you assigned a new object to the <strong class="source-inline">Task</strong> property of the <strong class="source-inline">PageModel</strong> class.</p>
<ol>
<li value="12">Now, create the code-behind page, named <strong class="source-inline">CreateModel.cshtml.cs</strong> (placed in <strong class="source-inline">Pages/Tasks/</strong>):<p class="source-code-heading">Create.cshtml.cs</p><p class="source-code">using Microsoft.AspNetCore.Mvc;</p><p class="source-code">using Microsoft.AspNetCore.Mvc.RazorPages;</p><p class="source-code">using ToDoListApp.Data;</p><p class="source-code">using ToDoListApp.Models;</p><p class="source-code">namespace ToDoListApp.Pages.Tasks;</p><p class="source-code">public class CreateModel : PageModel {</p><p class="source-code">    private readonly ToDoDbContext _context;</p><p class="source-code">    public CreateModel(ToDoDbContext context)</p><p class="source-code">    {</p><p class="source-code">        _context = context;</p><p class="source-code">    }</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/06ciR">https://packt.link/06ciR</a>.</p>
<p>When posting a form, all the values inside the form are placed in the incoming <strong class="source-inline">HttpRequest</strong>. The call to <strong class="source-inline">TryUpdateModelAsync</strong> tries to populate an object with these values that the request brought from the client-side. Since the form is created with the <strong class="source-inline">name</strong> attribute in the input element with the format that has been explained previously, this method knows how to extract these values and bind them to the object. Put simply, that is the magic behind model binding.</p>
<ol>
<li value="13">Now, replace the code of <strong class="source-inline">Index.cshtml</strong> (under <strong class="source-inline">Pages/Tasks/</strong>) with the following:<p class="source-code-heading">Index.cshtml</p><p class="source-code">@page</p><p class="source-code">@using ToDoListApp.Models</p><p class="source-code">@model IndexModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "My To Do List";</p><p class="source-code">}</p><p class="source-code">&lt;div class="text-center"&gt;</p><p class="source-code">    @if (TempData["SuccessMessage"] != null)</p><p class="source-code">    {</p><p class="source-code">        &lt;div class="alert alert-success" role="alert"&gt;</p><p class="source-code">            @TempData["SuccessMessage"]</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">    }</p><p class="source-code">    &lt;h1 class="display-4"&gt;@ViewData["Title"]&lt;/h1&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/hNOTx">https://packt.link/hNOTx</a>.</p>
<p>This code adds a section that introduces an alert to be displayed if there is an entry with the <strong class="source-inline">SuccessMessage</strong> key in the <strong class="source-inline">TempData</strong> dictionary.</p>
<ol>
<li value="14">Finally, add some display and validation rules via data annotations to the <strong class="source-inline">Models/ToDoTask.cs</strong> class properties:<p class="source-code-heading">ToDoTask.cs</p><p class="source-code">using System.ComponentModel;</p><p class="source-code">using System.ComponentModel.DataAnnotations;</p><p class="source-code">namespace ToDoListApp.Models;</p><p class="source-code">public class ToDoTask</p><p class="source-code">{</p><p class="source-code">    public ToDoTask()</p><p class="source-code">    {</p><p class="source-code">        CreatedAt = DateTime.UtcNow;</p><p class="source-code">        Id = Guid.NewGuid();</p><p class="source-code">    }</p><p class="source-code">    public ToDoTask(string title, ETaskStatus status) : this()</p><p class="source-code">    {</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/yau4p">https://packt.link/yau4p</a>.</p>
<p>Here the <strong class="source-inline">Required</strong> data annotation over the property is to ensure that this property is set with a valid value. In this exercise, you added persistence with Entity Framework Core and SQLite and created a new page that creates a task for the to-do application, finally saving it into the database.</p>
<ol>
<li value="15">Now run the code in VS Code.</li>
<li>To see the output on your web browser, type the following command on the address bar:<p class="source-code">Localhost:####</p></li>
</ol>
<p>Here <strong class="source-inline">####</strong> represents the port number. This would be different for different systems.</p>
<p>After pressing enter, the following screen is displayed:</p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<img alt="Figure 7.5: Home page with Create Task button in the navigation bar " height="727" src="image/B16835_07_05.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 7.5: Home page with Create Task button in the navigation bar</p>
<ol>
<li value="17">Click on the <strong class="source-inline">Create Task</strong> button, and you'll see the page you just created to insert new cards into your Kanban Board:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer155">
<img alt="Figure 7.6: The Create Task page " height="951" src="image/B16835_07_06.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 7.6: The Create Task page</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/3FPaG">https://packt.link/3FPaG</a>.</p>
<p>Now, you'll take a deep dive into how model binding brings it all together, enabling you to transport data back and forth between the client and the server. You will also know more about validations in the next section.</p>
<h2 id="_idParaDest-270">Valid<a id="_idTextAnchor302"/>ation</h2>
<p>Validating data is something you will often need to do while developing an application. Validating a field may either mean that it is a required field or that it should follow a specific format. An important thing you may have noticed in the final part of the previous exercise is that you placed some <strong class="source-inline">[Required]</strong> attributes on top of some model properties in the final step of the last exercise. Those attributes are called data annotations and are used to create server-side validations. Moreover, you can add some client-side validation combined with this technique.</p>
<p>Note that in <em class="italic">Step 10</em> of <em class="italic">Exercise 7.04</em>, the frontend has some span tag helpers with an <strong class="source-inline">asp-validation-for</strong> attribute pointing to the model properties. There is one thing that binds this all together—the inclusion of the <strong class="source-inline">_ValidationScriptsPartial.cshtml</strong> partial page. Partial pages are a subject discussed in the next section, but for now, it is enough to know that they are pages that can be reused inside other ones. The one just mentioned includes default validation for the pages.</p>
<p>With those three placed together (that is, the required annotation, the <strong class="source-inline">asp-validation-for</strong> tag helper, and the <strong class="source-inline">ValidationScriptsPartial</strong> page), validation logic is created on the client-side that prevents the form from being submitted with invalid values. If you want to perform the validation on the server, you could use the built-in <strong class="source-inline">TryValidateModel </strong>method, passing the model to be validated.</p>
<h2 id="_idParaDest-271">Dynam<a id="_idTextAnchor303"/>ic Behavior with Partial Pages</h2>
<p>So far, you have built a board to display tasks and a way to create and edit them. Still, there is one major feature for a to-do application that needs adding—a way to move tasks across the board. You can start as simple as moving one way only—from to-do to doing, and from doing to done.</p>
<p>Until now, your task cards were built using tag helpers. However, tag helpers are rendered as <strong class="source-inline">static</strong> components and do not allow any dynamic behavior to be added during rendering. You could add tag helpers directly to your page, but you would have to repeat it for every board list. That is exactly where a major Razor Pages feature comes into play and that is Partial Pages. They allow you to create reusable page code snippets in smaller pieces. That way, you can share the base page dynamic utilities and still avoid duplicate code in your application.</p>
<p>This concludes the theoretical portion of this section. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-272">Exerc<a id="_idTextAnchor304"/>ise 7.05: Refactoring a Tag Helper to a Partial Page with Custom Logic</h2>
<p>In this exercise, you will create a partial page to replace <strong class="source-inline">KanbanCardTagHelper</strong> and add some dynamic behavior to your task's cards, such as changing content based on custom logic. You will see how partial pages help in reducing duplicate code and make it more easily reusable. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the <strong class="source-inline">Pages/Tasks</strong> folder, create a new file called <strong class="source-inline">_TaskItem.cshtml</strong> with the following content:<p class="source-code-heading">_TaskItem.cshtml</p><p class="source-code">@model ToDoListApp.Models.ToDoTask</p><p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    &lt;div class="card"&gt;</p><p class="source-code">        &lt;div class="card-body p-2"&gt;</p><p class="source-code">            &lt;div class="card-title"&gt;</p><p class="source-code">                @Model.Title</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">            &lt;a class="btn btn-primary btn-sm" href="/tasks/@Model.Id"&gt;View&lt;/a&gt;</p><p class="source-code">            @if (Model.Status == Models.ETaskStatus.ToDo)</p><p class="source-code">            {</p><p class="source-code">                &lt;button type="submit" class="btn btn-warning btn-sm" href="@Model.Id" asp-page-handler="StartTask" asp-route-id="@Model.Id"&gt;</p><p class="source-code">                    Start </p><p class="source-code">                &lt;/button&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/aUOcj">https://packt.link/aUOcj</a>.</p>
<p>The <strong class="source-inline">_TaskItem.cshtml</strong> is basically a partial page that contains the <strong class="source-inline">.cshtml</strong> code of a card from the Kanban board.</p>
<ol>
<li value="2">Now, replace the code within the <strong class="source-inline">Index.cshtml.cs</strong> file with the following code that can read the saved tasks from the database and place the actions you created on the partial page:<p class="source-code-heading">Index.cshtml.cs</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">using Microsoft.AspNetCore.Mvc;</p><p class="source-code">using Microsoft.AspNetCore.Mvc.RazorPages;</p><p class="source-code">using ToDoListApp.Data;</p><p class="source-code">using ToDoListApp.Models;</p><p class="source-code">namespace ToDoListApp.Pages</p><p class="source-code">{</p><p class="source-code">    public class IndexModel : PageModel</p><p class="source-code">    {</p><p class="source-code">        private readonly ToDoDbContext _context;</p><p class="source-code">        public IndexModel(ToDoDbContext context)</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/Tqgup">https://packt.link/Tqgup</a>.</p>
<p>This code creates handler methods for the three HTTP requests—a GET request and two POST requests. It also places the logic to be executed on these handlers. You will read values from the database with GET and save them back with POST.</p>
<ol>
<li value="3">Finally, update the <strong class="source-inline">Index.cshtml</strong> page with the following code to replace the use of tag helpers by the partial Razor page with your Kanban cards:<p class="source-code-heading">Index.cshtml</p><p class="source-code">@page</p><p class="source-code">@using ToDoListApp.Models</p><p class="source-code">@model IndexModel</p><p class="source-code">@{</p><p class="source-code">    ViewData["Title"] = "MyToDos";</p><p class="source-code">}</p><p class="source-code">&lt;div class="text-center"&gt;</p><p class="source-code">    </p><p class="source-code">    @if(TempData["SuccessMessage"] != null)</p><p class="source-code">    {</p><p class="source-code">        &lt;div class="alert alert-success" role="alert"&gt;</p><p class="source-code">            @TempData["SuccessMessage"]</p><p class="source-code">        &lt;/div&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/9SRsY">https://packt.link/9SRsY</a>.</p>
<p>Doing so, you'll notice how much duplicate code gets eliminated.</p>
<ol>
<li value="4">Now run the application with the following command:<p class="source-code">dotnet run</p></li>
<li>Next click at the Create Task button and fill the form. After a Task is created, you'll see a confirmation message, as shown in <em class="italic">Figure 7.7</em>.</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer156">
<img alt="Figure 7.7: The Home screen after a Task creation " height="538" src="image/B16835_07_07.jpg" width="1545"/>
</div>
</div>
<p class="figure-caption">Figure 7.7: The Home screen after a Task creation</p>
<p class="callout-heading">Note</p>
<p class="callout">If you have created some tasks in the previous screen, the screen display might be different on your system.</p>
<p>In this exercise, you created an almost fully functional to-do application in which you can create tasks and save them to the database, and even log your requests to see how long they take.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/VVT4M">https://packt.link/VVT4M</a>.</p>
<p>Now, it is time to work on an enhanced feature through an activity.</p>
<h2 id="_idParaDest-273">Activi<a id="_idTextAnchor305"/>ty 7.01: Creating a Page to Edit an Existing Task</h2>
<p>Now it's time to enhance the previous exercise with a new and fundamental feature that is, to move tasks across the Kanban board. You must build this application using the concepts covered in this chapter such as model binding, tag helpers, partial pages, and DI.</p>
<p>To complete this activity, you need to add a page to edit the tasks. The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a new file called <strong class="source-inline">Edit.cshtml</strong> with the same form as <strong class="source-inline">Create.cshtml</strong>.</li>
<li>Change the route at the page directive to receive <strong class="source-inline">"/tasks/{id}"</strong>.</li>
<li>Create the code-behind file that loads a task by the <strong class="source-inline">OnGet ID</strong> from the <strong class="source-inline">DbContext</strong> schema. If the ID does not return a task, redirect it to the <strong class="source-inline">Create</strong> page.</li>
<li>On the Post form, recover the task from the database, update its values, send a success message, and redirect to the Index view afterward.</li>
</ol>
<p>The output of a page is displayed as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<img alt="Figure 7.8: The Edit Task Page as output to the activity " height="449" src="image/B16835_07_08.jpg" width="792"/>
</div>
</div>
<p class="figure-caption">Figure 7.8: The Edit Task Page as output to the activity</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>With the examples and activity so far, you now know how to develop pages with Razor. In the <a id="_idTextAnchor306"/><a id="_idTextAnchor307"/>next section, you will learn how to work with a tool that has an even smaller scope of isolated and reusable logic called view components.</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor308"/>View Components</h1>
<p>So far, you have seen two ways of creating reusable components to provide better maintenance and reduce the amount of code and that is tag helpers and partial pages. While a tag helper produces mainly static HTML code (as it translates a custom tag into an existing HTML tag with some content inside it), a <strong class="source-inline">partial page</strong> is a small Razor page inside another Razor page that shares the page data-binding mechanism and can perform some actions such as form submission. The only downside to <strong class="source-inline">partial pages</strong> is that the dynamic behavior relies on the page that contains it.</p>
<p>This section is about another tool that allows you to create reusable components that is, view components. View components are somewhat similar to partial pages, as they also allow you to provide dynamic functionality and have logic on the backend. However, they are even more powerful as they are self-contained. This self-containment allows them to be developed independently of the page and be fully testable on their own.</p>
<p>There are several requirements for creating view components, as follows:</p>
<ul>
<li>The custom component class must inherit from <strong class="source-inline">Microsoft.AspNetCore.Mvc.ViewComponent</strong>.</li>
<li>It must either have the <strong class="source-inline">ViewComponent</strong> suffix in the class name or be decorated with the <strong class="source-inline">[ViewComponent]</strong> attribute.</li>
<li>This class must implement either a <strong class="source-inline">IViewComponentResult Invoke()</strong> synchronous method or a <strong class="source-inline">Task&lt;IViewComponentResult&gt; InvokeAsync()</strong> asynchronous method (when you need to call async methods from within).</li>
<li>The result of both previous methods is typically the <strong class="source-inline">View(model)</strong> method with the view component model as an argument. On the frontend, the default view filename should, by convention, be called <strong class="source-inline">Default.cshtml</strong>.</li>
<li>For the view to be rendered, it must be located in either <strong class="source-inline">Pages/Components/{MY_COMPONENT_NAME}/Default.cshtml</strong> or <strong class="source-inline">/Views/Shared/Components/{MY_COMPONENT_NAME}/Default.cshtml</strong>.</li>
<li>If not located in any of the preceding paths, the location of the view must be explicitly passed as an argument on the <strong class="source-inline">View</strong> method returned in the <strong class="source-inline">Invoke</strong> or <strong class="source-inline">InvokeAsync</strong> methods.</li>
</ul>
<p>This concludes the theoretical portion of this section. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-275">Exercis<a id="_idTextAnchor309"/>e 7.06: Creating a View Component to Display Task Statistics</h2>
<p>In this exercise, you will create a view component that allows you to display some statistics regarding delayed tasks on the navbar of the application. Working through this exercise, you will learn the basic syntax of view components and how to place them in Razor Pages. Perform the following steps to do so:</p>
<ol>
<li value="1">Under the root of the <strong class="source-inline">ToDoListApp</strong> project, create a new folder called <strong class="source-inline">ViewComponents</strong>.</li>
<li>Inside this folder, create a new class called <strong class="source-inline">StatsViewComponent</strong>:<p class="source-code">namespace ToDoListApp.ViewComponents;</p><p class="source-code">public class StatsViewComponent</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Again, inside the <strong class="source-inline">ViewComponents</strong> folder, create a new class named <strong class="source-inline">StatsViewModel</strong> with two public <strong class="source-inline">int</strong> properties, named <strong class="source-inline">Delayed</strong> and <strong class="source-inline">DueToday</strong>:<p class="source-code">namespace ToDoListApp.ViewComponents;</p><p class="source-code">public class StatsViewModel</p><p class="source-code">{</p><p class="source-code">    public int Delayed { get; set; }</p><p class="source-code">    public int DueToday { get; set; }</p><p class="source-code">}</p></li>
<li>Edit the <strong class="source-inline">StatsViewComponent</strong> class to inherit from the <strong class="source-inline">ViewComponent</strong> class that is contained in the <strong class="source-inline">Microsoft.AspNetCore.Mvc</strong> namespace:<p class="source-code">using Microsoft.AspNetCore.Mvc;</p><p class="source-code">public class StatsViewComponent : ViewComponent</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Inject <strong class="source-inline">ToDoDbContext</strong> via a constructor initializing a <strong class="source-inline">private readonly</strong> field:<p class="source-code">public class StatsViewComponent : ViewComponent</p><p class="source-code">{</p><p class="source-code">    private readonly ToDoDbContext _context;</p><p class="source-code">    public StatsViewComponent(ToDoDbContext context) =&gt; _context = context;</p><p class="source-code">}</p></li>
</ol>
<p>Place the proper <strong class="source-inline">using</strong> namespaces.</p>
<ol>
<li value="6">Create a method named <strong class="source-inline">InvokeAsync</strong> with the following signature and content:<p class="source-code-heading">StatsViewComponent.cs</p><p class="source-code">using ToDoListApp.Data;</p><p class="source-code">using Microsoft.AspNetCore.Mvc;</p><p class="source-code">using Microsoft.EntityFrameworkCore;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace ToDoListApp.ViewComponents;</p><p class="source-code">public class StatsViewComponent : ViewComponent</p><p class="source-code">{</p><p class="source-code">    private readonly ToDoDbContext _context;</p><p class="source-code">    public StatsViewComponent(ToDoDbContext context) =&gt; _context = context;</p><p class="source-code">    public async Task&lt;IViewComponentResult&gt; InvokeAsync()</p><p class="source-code">    {</p><p class="source-code">        var delayedTasks = await _context.Tasks.Where(t =&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/jl2Ue">https://packt.link/jl2Ue</a>.</p>
<p>This method will use <strong class="source-inline">ToDoDbContext</strong> to query the database and retrieve the delayed tasks, as well as the ones that are due on the current day.</p>
<ol>
<li value="7">Now under the <strong class="source-inline">Pages</strong> folder, create a new folder called <strong class="source-inline">Components</strong>.</li>
<li>Under it make another folder called <strong class="source-inline">Stats</strong>.</li>
<li>Then, inside the <strong class="source-inline">Stats</strong> folder, create a new file called <strong class="source-inline">default.cshtml</strong> with the following content:<p class="source-code">@model ToDoListApp.ViewComponents.StatsViewModel</p><p class="source-code">&lt;form class="form-inline my-2 my-lg-0"&gt;</p><p class="source-code">    @{</p><p class="source-code">         var delayedEmoji = Model.Delayed &gt; 0 ? "<img alt="Icon1 " height="14" src="image/B16835_07_08_IconA.png" width="14"/>" : "<img alt="Icon2 " height="12" src="image/B16835_07_08_IconB.png" width="12"/>";</p><p class="source-code">         var delayedClass = Model.Delayed &gt; 0 ? "btn-warning" : "btn-success";</p><p class="source-code">         var dueClass = Model.DueToday &gt; 0 ? "btn-warning" : "btn-success";</p><p class="source-code">     }</p><p class="source-code">    &lt;button type="button" class="btn @delayedClass my-2 my-sm-0"&gt;</p><p class="source-code">        &lt;span class="badge badge-light"&gt;@Model.Delayed&lt;/span&gt; Delayed Tasks @delayedEmoji</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">    &amp;nbsp;</p><p class="source-code">    &lt;button type="button" class="btn @dueClass my-2 my-sm-0"&gt;</p><p class="source-code">        &lt;span class="badge badge-light"&gt;@Model.DueToday&lt;/span&gt; Tasks Due Today <img alt="Icon3 " height="13" src="image/B16835_07_08_IconC.png" width="14"/></p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
</ol>
<p>The <strong class="source-inline">default.cshtml</strong> will contain the view part of the view component class. Here, you are basically creating a <strong class="source-inline">.cshtml</strong> file based on a model specified.</p>
<ol>
<li value="10">Finally, in <strong class="source-inline">_Layout.cshtml</strong> (under <strong class="source-inline">Pages/Shared/</strong>), add a call to the <strong class="source-inline">ViewComponent</strong> by adding the <strong class="source-inline">&lt;vc:stats&gt;&lt;/vc:stats&gt;</strong> tag inside your navbar. Replace the page code with the following:<p class="source-code-heading">_Layout.cshtml</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="utf-8" /&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</p><p class="source-code">    &lt;title&gt;@ViewData["Title"] - ToDoListApp&lt;/title&gt;</p><p class="source-code">    &lt;link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" /&gt;</p><p class="source-code">    &lt;link rel="stylesheet" href="~/css/site.css" asp-append-version="true" /&gt;</p><p class="source-code">    &lt;link rel="stylesheet" href="~/ToDoListApp.styles.css" asp-append-version="true" /&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;header&gt;</p><p class="source-code">        &lt;nav class="navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3"&gt;</p></li>
</ol>
<p class="source-code-link">The complete code can be found here: <a href="https://packt.link/DNUBC">https://packt.link/DNUBC</a>.</p>
<ol>
<li value="11">Run the application to see your navbar as shown in <em class="italic">Figure 7.8</em>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer161">
<img alt="Figure 7.9: The Task stats view component " height="604" src="image/B16835_07_09.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 7.9: The Task stats view component</p>
<p>In this exercise, you created your first view component which is a task stat displayed right on your navbar. As you may have noticed, one efficient thing about view components that distinguishes them from partial pages is that they are independent of the page they are displayed on. You build both your frontend and backend all self-contained inside the component, with no external dependencies on the page.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/j9eLW">https://packt.link/j9eLW</a>.</p>
<p>This exercise covered view components, which allow you to display some statistics regarding delayed tasks on the navbar of the application. With this knowledge, you will now complete an activity wherein you will work in a view component to show a log history.</p>
<h2 id="_idParaDest-276">Activity 7<a id="_idTextAnchor310"/>.02: Writing a View Component to Display Task Log</h2>
<p>As the final step of this chapter, this activity will be based on a common task in real-world applications—to have a log of user activities. In this case, you will write every change the user does to a field to the database and display it in a view. To do so, you would need to use a view component.</p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a new class under the <strong class="source-inline">Models</strong> folder named <strong class="source-inline">ActivityLog</strong>. This class should have the following properties: <strong class="source-inline">Guid Id</strong>, <strong class="source-inline">String EntityId</strong>, <strong class="source-inline">DateTime</strong> <strong class="source-inline">Timestamp</strong>, <strong class="source-inline">String Property</strong>, <strong class="source-inline">String OldValue</strong>, and <strong class="source-inline">String NewValue</strong>.</li>
<li>Create a new <strong class="source-inline">DbSet&lt;ActivityLog&gt;</strong> property for this model under <strong class="source-inline">ToDoDbContext</strong>.</li>
<li>Under your <strong class="source-inline">DbContext</strong>, create a method to generate activity logs for the modified properties of <strong class="source-inline">Entries</strong> under the Entity Framework's <strong class="source-inline">ChangeTracker</strong> with <strong class="source-inline">EntityState.Modified</strong>.</li>
<li>Override <strong class="source-inline">SaveChangesAsync()</strong> in <strong class="source-inline">DbContext</strong>, by adding the generated logs to <strong class="source-inline">DbSet</strong> right before calling the <strong class="source-inline">base</strong> method.</li>
<li>Create a new Entity Framework Core migration and update the database to support this migration.</li>
<li>Create the <strong class="source-inline">ViewComponent</strong> class, which should load all logs for a given <strong class="source-inline">taskId</strong> passed on the invocation and return them to the <strong class="source-inline">ViewComponent</strong>.</li>
<li>Create the <strong class="source-inline">ViewComponent</strong> view, which should take a collection of <strong class="source-inline">ActivityLog</strong> as a model and display them in a Bootstrap table, if any exists. If no logs are recorded, show an alert saying that no logs are available.</li>
<li>Add the view component to the <strong class="source-inline">Edit</strong> page, passing the <strong class="source-inline">taskId</strong> property.</li>
<li>Run the application and check the final output by opening a task's details. You will see a box on the right with your activity logs or a message with no logs, if there are no activity logs recorded, for that task yet.</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer162">
<img alt="Figure 7.10: The Activity log being displayed with no logs " height="490" src="image/B16835_07_10.jpg" width="1154"/>
</div>
</div>
<p class="figure-caption">Figure 7.10: The Activity log being displayed with no logs</p>
<p>In this activity, you were able to create an isolated view component with completely new functionality that's decoupled from a page, allowing it to work on a single feature at a time.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor311"/>Summary</h1>
<p>In <a id="_idTextAnchor312"/><a id="_idTextAnchor313"/>this chapter, you learned the foundations of building a modern web application with C# and Razor Pages. You focused on important concepts at the beginning of the chapter, such as middleware, logging, DI, and configuration. Next, you used Razor Pages to create CRUD models along with Entity Framework and used some more advanced features, such as custom tag helpers, partial pages, and view components, which enable you to create more easily maintainable application features.</p>
<p>Finally, you saw how ASP.NET model binding works so that there can be a two-way data binding between the client and the server. By now, you should have an effective foundation for building modern web applications with ASP.NET and Razor Pages on your own.</p>
<p>Over the next two chapters, you will learn about building and communicating with APIs.</p>
</div>
</div>
</body></html>