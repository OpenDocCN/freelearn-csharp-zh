- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: 'Victory or Defeat: Win and Lose Conditions'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 胜利或失败：胜负条件
- en: Now that we have a basic gameplay experience, it’s time to make the game end
    with the outcomes of winning or losing. One common way to implement this is through
    separated components with the responsibility of overseeing a set of objects to
    detect certain situations that need to happen, such as the player’s life becoming
    0 or all of the waves being cleared. We will implement this through the concept
    of **managers**, components that will manage and monitor several objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的游戏体验，是时候让游戏以胜利或失败的结果结束。实现这一点的常见方法是通过分离的组件，这些组件负责监督一组对象以检测需要发生的情况，例如玩家的生命值变为0或所有波次都被清除。我们将通过**管理器**的概念来实现这一点，管理器将管理和监控多个对象。
- en: 'In this chapter, we will examine the following manager concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下管理器概念：
- en: Creating object managers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: Creating game modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: Improving our code with events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件改进我们的代码
- en: With this knowledge, you will be able to not only create the victory and loss
    conditions of the game but also do this in a properly structured way using design
    patterns such as **Singleton** and **Event Listeners**. These skills are not only
    useful for creating the winning and losing code of the game but any code in general.
    First, let’s begin by creating managers to represent concepts such as score or
    game rules.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你将能够不仅创建游戏的胜负条件，而且还能以正确的方式使用设计模式，如**单例（Singleton**）和**事件监听器（Event Listeners**）来创建这些条件。这些技能不仅对创建游戏的胜负代码有用，对任何一般的代码都很有用。首先，让我们从创建代表如得分或游戏规则等概念的管理器开始。
- en: Creating object managers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: 'Not every object in your Scene should be something that can be seen, heard,
    or collided with. Some objects can also exist with a conceptual meaning, not something
    tangible. For example, imagine you need to keep a count of the number of enemie­s:
    where do you save that? You also need some place to save the current score of
    the player, and you may be thinking it could be on the player itself, but what
    happens if the player dies and respawns?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并非场景中的每个对象都应该是可以看到、听到或与之碰撞的。一些对象也可以存在概念意义，而不是有形的东西。例如，想象一下你需要计算敌人的数量：你将把它保存在哪里？你还需要一个地方来保存玩家的当前得分，你可能认为它应该在玩家本身上，但如果玩家死亡并重生了呢？
- en: The data would be lost! In such scenarios, the concept of a **manager** can
    be a useful way of solving this in our first games, so let’s explore it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将会丢失！在这种情况下，**管理器**的概念可以是我们早期游戏中解决这一问题的有用方式，所以让我们来探索它。
- en: 'In this section, we are going to see the following object manager concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到以下对象管理器概念：
- en: Sharing variables with the Singleton design pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例设计模式共享变量
- en: Sharing variables in Visual Scripting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视觉脚本中共享变量
- en: Creating managers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管理器
- en: We will start by discussing what the Singleton design pattern is and how it
    helps us simplify the communication of objects. With it, we will create manager
    objects that allow us to centralize information about a group of objects, among
    other things. Let’s start by discussing the Singleton design pattern.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论单例设计模式是什么以及它如何帮助我们简化对象的通信。有了它，我们将创建管理器对象，使我们能够集中管理一组对象的信息，以及其他方面。让我们先从讨论单例设计模式开始。
- en: Sharing variables with the Singleton design pattern
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单例设计模式共享变量
- en: Design patterns are usually described as common solutions to common problems.
    There are several coding design decisions you will have to make while you code
    your game, but luckily, the ways to tackle the most common situations are well
    known and documented. In this section, we are going to discuss one of the most
    common design patterns, **Singleton**, a convenient one to implement in simple
    projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常被描述为对常见问题的常见解决方案。在编写游戏代码时，你将不得不做出几个编码设计决策，但幸运的是，处理最常见情况的方法是众所周知的，并且有详细的文档。在本节中，我们将讨论最常见的设计模式之一，**单例（Singleton**），它在简单项目中易于实现。
- en: The Singleton pattern is used when we need a single instance of an object, meaning
    that there shouldn’t be more than one instance of a class and that we want it
    to be easily accessible (not necessary, but useful in our scenario). We have plenty
    of cases in our game where this can be applied, for example, `ScoreManager`, a
    component that will hold the current score. In this case, we will never have more
    than one score, so we can take advantage of the benefits of the Singleton manager
    here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个对象的单个实例时，会使用Singleton模式，这意味着不应该有超过一个类的实例，并且我们希望它易于访问（虽然不是必需的，但在我们的场景中很有用）。在我们的游戏中有很多情况可以应用Singleton模式，例如，`ScoreManager`，一个将保存当前分数的组件。在这种情况下，我们永远不会有多于一个分数，因此我们可以利用Singleton管理器的优势。
- en: One benefit is being sure that we won’t have duplicated scores, which makes
    our code less error-prone. Also, so far, we have needed to create public references
    and drag objects via the editor to connect two objects, or look for them using
    `GetComponent`; with this pattern, however, we will have global access to our
    Singleton component, meaning you can just write the name of the component in your
    script and you will access it. In the end, there’s just one `ScoreManager` component,
    so specifying one via the editor is redundant. This is similar to `Time.deltaTime`,
    the class responsible for managing time—we have just one time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是确保我们不会有重复的分数，这使我们的代码更不容易出错。此外，到目前为止，我们需要创建公共引用并通过编辑器拖动对象来连接两个对象，或者使用`GetComponent`来查找它们；然而，使用这种模式，我们将能够全局访问我们的Singleton组件，这意味着你只需在脚本中写下组件的名称，就可以访问它。最后，只有一个`ScoreManager`组件，所以通过编辑器指定一个就多余了。这类似于`Time.deltaTime`，负责管理时间的类——我们只有一个时间。
- en: If you are an advanced programmer, you may be thinking about code testing and
    dependency injection now, and you are right, but remember, we are trying to write
    simple code so far, so we will stick to this simple solution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个高级程序员，你现在可能正在考虑代码测试和依赖注入，你是对的，但请记住，到目前为止，我们正在尝试编写简单的代码，所以我们将坚持这个简单的解决方案。
- en: 'Let’s create a **Score Manager** object, responsible for handling the score,
    to show an example of a Singleton by doing the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个**Score Manager**对象，负责处理分数，以下是如何通过以下方式展示Singleton的一个例子：
- en: Create an empty GameObject (**GameObject | Create Empty**) and call it `ScoreManager`;
    usually, managers are put in empty objects, separated from the rest of the Scene’s
    objects.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的GameObject（**GameObject | Create Empty**），并将其命名为`ScoreManager`；通常，管理者被放在空对象中，与场景中的其他对象分离。
- en: Add a script called **ScoreManager** to this object with an **int** field called
    **amount** that will hold the current score.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此对象添加一个名为**ScoreManager**的脚本，并添加一个名为**amount**的**int**字段，该字段将保存当前分数。
- en: 'Add a field of the **ScoreManager** type called **instance**, but add the **static**
    keyword to it; this will make the variable global, meaning it can be accessed
    anywhere by just writing its name:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为**instance**的**ScoreManager**类型字段，但向其添加**static**关键字；这将使变量全局，意味着只需写出其名称就可以在任何地方访问它：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_01_PE.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，自动生成描述，置信度低](img/B21361_08_01_PE.png)'
- en: 'Figure 8.1: A static field that can be accessed anywhere in the code'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：可以在代码的任何地方访问的静态字段
- en: In **Awake**, check whether the **instance** field is not `null`, and in that
    case, set this **ScoreManager** instance as the instance reference using the **this**
    reference.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Awake**方法中，检查**实例**字段是否不为`null`，如果是，则使用**this**引用将此**ScoreManager**实例设置为实例引用。
- en: In the `else` clause of the `null` checking `if` statement, print a message
    indicating that there’s a second **ScoreManager** instance that must be destroyed:![A
    picture containing text, screenshot, font, line  Description automatically generated](img/B21361_08_02_PE.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`null`检查`if`语句的`else`子句中，打印一条消息，指出存在一个必须销毁的第二个**ScoreManager**实例：![包含文本、截图、字体、行描述的图片，自动生成](img/B21361_08_02_PE.png)
- en: 'Figure 8.2: Checking whether there’s only one Singleton instance'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.2：检查是否存在唯一的Singleton实例
- en: The idea is to save the reference to the only **ScoreManager** instance in the
    `instance` static field, but if by mistake the user creates two objects with the
    **ScoreManager** component, this `if` statement will detect it and inform the
    user of the error, asking them to take action. In this scenario, the first **ScoreManager**
    instance to execute **Awake** will find that there’s no instance set (the field
    is `null`) so it will set itself as the current instance, while the second **ScoreManager**
    instance will find the instance is already set and will print the message.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略是将对唯一的**ScoreManager**实例的引用保存在`instance`静态字段中，但如果用户不小心创建了带有**ScoreManager**组件的两个对象，这个`if`语句将检测到它，并通知用户错误，要求他们采取行动。在这种情况下，第一个执行**Awake**的**ScoreManager**实例会发现没有设置实例（字段是`null`），因此它会将自己设置为当前实例，而第二个**ScoreManager**实例会发现实例已经设置，并将打印出消息。
- en: Remember that `instance` is a static field, shared between all classes, unlike
    regular reference fields, where each component will have its own reference, so
    in this case, we have two `ScoreManager` instances added to the scene, and they
    will share the same instance field.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，`instance`是一个静态字段，在所有类之间共享，与常规引用字段不同，每个组件都将有自己的引用，所以在这种情况下，场景中添加了两个`ScoreManager`实例，它们将共享相同的实例字段。
- en: 'To improve the example a little bit, it would be ideal to have a simple way
    to find the second `ScoreManager` in the game. It will be hidden somewhere in
    the Hierarchy and it may be difficult to find, but we fix this by doing the following:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了稍微改进一下示例，最好有一种简单的方法来找到游戏中第二个`ScoreManager`。它可能隐藏在层级结构中的某个地方，可能很难找到，但我们可以通过以下方式解决这个问题：
- en: Replace `print` with `Debug.Log`. `Debug.Log` is similar to `print` but has
    a second argument that expects an object to be highlighted when the message is
    clicked in the console. In this case, we will pass the `gameObject` reference
    to allow the console to highlight the duplicated object:![](img/B21361_08_03_PE.png)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`print`替换为`Debug.Log`。`Debug.Log`与`print`类似，但有一个期望在控制台中点击消息时突出显示对象的第二个参数。在这种情况下，我们将传递`gameObject`引用，以便控制台突出显示重复的对象：![img/B21361_08_03_PE.png]
- en: 'Figure 8.3: Printing messages in the console with Debug.Log'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.3：使用Debug.Log在控制台中打印消息
- en: 'After clicking the log message, the GameObject containing the duplicated `ScoreManager`
    will be highlighted in the Hierarchy:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击日志消息后，包含重复`ScoreManager`的GameObject将在层级结构中高亮显示：
- en: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_04_PE.png)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_04_PE.png)'
- en: 'Figure 8.4: The highlighted object after clicking the message'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4：点击消息后的高亮对象
- en: 'Finally, a little improvement can be made here by replacing `Debug.Log` with
    `Debug.LogError`, which will also print the message but with an error icon. In
    a real game, you will have lots of messages in the console, and highlighting the
    errors over the information messages will help us to identify them quickly:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以通过将`Debug.Log`替换为`Debug.LogError`来在这里进行一点小小的改进，这将打印出消息，但带有错误图标。在实际游戏中，控制台将有很多消息，突出显示错误信息而不是信息消息将帮助我们快速识别它们：
- en: '![](img/B21361_08_05_PE.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_08_05_PE.png]'
- en: 'Figure 8.5: Using LogError to print an error message'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：使用LogError打印错误消息
- en: Try the code and observe the error message in the console:![A screenshot of
    a computer error message  Description automatically generated with low confidence](img/B21361_08_06_PE.png)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行代码并观察控制台中的错误消息：![A screenshot of a computer error message  Description automatically
    generated with low confidence](img/B21361_08_06_PE.png)
- en: 'Figure 8.6: An error message in the console'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.6：控制台中的错误消息
- en: 'The next step would be to use this Singleton object somewhere, so in this case,
    we will make the enemies give points when they are killed by doing the following:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是在某个地方使用这个单例对象，所以在这种情况下，我们将让敌人被杀死时获得分数，具体操作如下：
- en: Add a script to the `Enemy` Prefab called `ScoreOnDeath` with an `int` field
    called `amount`, which will indicate the number of points the enemy will give
    when killed. Remember to set the value to something other than `0` in the editor
    for the Prefab.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ScoreOnDeath`的脚本添加到`Enemy`预制件中，其中有一个名为`amount`的`int`字段，该字段将指示敌人被杀死时将获得的分数。请记住，在编辑器中将值设置为除`0`以外的其他值。
- en: Create the `OnDestroy` event function, which will be automatically called by
    Unity when this object is destroyed – in our case, the enemy:![A picture containing
    text, font, design  Description automatically generated](img/B21361_08_07_PE.png)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`OnDestroy`事件函数，当这个对象被销毁时，Unity会自动调用它——在我们的案例中，是敌人：![包含文本、字体、设计的图片  描述由低置信度自动生成](img/B21361_08_07_PE.png)
- en: 'Figure 8.7: The OnDestroy event function'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.7：OnDestroy事件函数
- en: Consider that the `OnDestroy` function is also called when we change scenes
    or the game is quitting, so in this scenario, we might get points when changing
    scenes, which is not correct. So far, this is not a problem in our case, but later
    in this chapter, we will see a way to prevent this.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到`OnDestroy`函数在改变场景或游戏退出时也会被调用，所以在这种情况下，我们在改变场景时可能会获得分数，这是不正确的。到目前为止，在我们的案例中这并不是问题，但稍后在本章中，我们将看到一种防止这种情况的方法。
- en: 'Access the Singleton reference in the `OnDestroy` function by writing `ScoreManager.instance`,
    and add the `amount` field of our script to the `amount` field of the Singleton
    to increase the score when an enemy is killed:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnDestroy`函数中通过编写`ScoreManager.instance`来访问单例引用，并将我们脚本中的`amount`字段添加到单例的`amount`字段中，以便在敌人被杀死时增加分数：
- en: '![A screen shot of a computer code  Description automatically generated with
    low confidence](img/B21361_08_08_PE.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码的屏幕截图  描述由低置信度自动生成](img/B21361_08_08_PE.png)'
- en: 'Figure 8.8: Full ScoreOnDeath component class contents'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：完整的ScoreOnDeath组件类内容
- en: Select `ScoreManager` in the Hierarchy, hit **Play**, and kill some enemies
    to see the score rise with every kill. Remember to set the `amount` field of the
    `ScoreOnDeath` component of the Prefab.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`ScoreManager`，按**播放**，然后杀死一些敌人以看到每次击杀分数都会上升。记得设置Prefab的`ScoreOnDeath`组件的`amount`字段。
- en: As you can see, the Singleton pattern has simplified the way we access `ScoreManager`
    and have security measures to prevent duplicates of itself a lot, which will help
    us to reduce errors in our code. Something to take into account is that now you
    will be tempted to just make everything a Singleton, such as the player’s life
    or player’s bullets, and just to make your life easier when creating gameplay
    mechanics such as power-ups.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，单例模式简化了我们访问`ScoreManager`的方式，并采取了大量安全措施来防止其自身的重复，这将帮助我们减少代码中的错误。需要注意的是，现在你可能会倾向于将一切事物都做成单例，比如玩家的生命或玩家的子弹，以便在创建游戏机制，如增强效果时使你的生活更轻松。
- en: While that will totally work, remember that your game will change, and I mean
    change a lot; any real project will experience constant change. Maybe today, the
    game has just one player, but in the future, you may want to add a second player
    or an AI companion, and you’ll want the power-ups to affect them too. If you abuse
    the Singleton pattern, you will have trouble handling those scenarios and many
    more. Maybe a future player companion will try to get the health pickup but the
    main player will be healed instead!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样完全可行，但请记住，你的游戏将发生很大变化；任何真实的项目都会经历不断的变更。也许今天，游戏只有一个玩家，但将来你可能想添加第二个玩家或一个AI伴侣，并且你希望增强效果也能影响他们。如果你过度使用单例模式，你将难以处理这些场景以及更多的情况。也许未来的玩家伴侣会尝试获取生命值恢复，但主玩家却被治愈了！
- en: The point here is to try to use the pattern as few times as you can, in case
    you don’t have any other way to solve the problem. To be honest, there are always
    ways to solve problems without Singleton, but they are a little bit more difficult
    to implement for beginners, so I prefer to simplify your life a little bit to
    keep you motivated. With enough practice, you will reach a point where you will
    be ready to improve your coding standards.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是尽量少地使用这个模式，以防你没有其他解决问题的方法。说实话，总是有不用单例解决问题的方法，但它们对初学者来说实现起来要困难一些，所以我更喜欢简化你的生活，让你保持动力。随着足够的练习，你将达到一个可以准备提高你的编码标准的点。
- en: 'There are lots of design patterns out there to help you design your game. Once
    you get comfortable with Unity scripting, we recommend reading the following Unity
    official game programming patterns book: [https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns](https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns).
    This book also includes an advanced implementation of Singleton.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多设计模式可以帮助你设计游戏。一旦你对Unity脚本编程感到舒适，我们建议阅读以下Unity官方游戏编程模式书籍：[https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns](https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns)。这本书还包括了单例的高级实现。
- en: Now, let’s discuss how to achieve this in Visual Scripting, which deserves its
    own section given that it will be a little bit different. You may consider skipping
    the following section if you are not interested in the Visual Scripting side of
    these scripts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何在视觉脚本中实现这一点，鉴于它会有所不同，因此值得单独成章。如果您对视觉脚本方面不感兴趣，可以考虑跳过以下部分。
- en: Sharing variables with Visual Scripting
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视觉脚本共享变量
- en: 'Visual Scripting has a mechanism that replaces Singleton as a holder of variables
    to be shared between objects: **scene variables**. If you check the left panel
    in the **Script Graph** editor (the window where we edit the nodes of a script)
    under the `Blackboard` panel (the panel that shows the variables of our object),
    you will notice it will have many tabs: **Graph, Object, Scene, App**, and **Saved**.
    If you don’t see the **Blackboard** panel, click the third button from left to
    right in the top-left part of the window – the button at the right of the **i**
    (information) button:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉脚本有一个机制，用**场景变量**替换单例作为在对象之间共享变量的持有者：**场景变量**。如果您检查**脚本图**编辑器（我们编辑脚本节点窗口）左侧的面板（显示我们对象变量的面板）下的`黑板`面板（显示我们对象变量的面板），您会注意到它将有许多标签页：**图、对象、场景、应用**和**已保存**。如果您看不到**黑板**面板，请点击窗口左上角从左到右的第三个按钮——位于**i**（信息）按钮右侧的按钮：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_09_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，置信度中等](img/B21361_08_09_PE.png)'
- en: 'Figure 8.9: Blackboard (variables) editor in Script Graph'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：脚本图中的黑板（变量）编辑器
- en: 'So far, when we created a variable in the **Variables** component of any object,
    we were actually creating **Object Variables**: variables that belong to an object
    and are shared between all Visual Scripts in that object, but that’s not the only
    scope a variable can have. Here’s a list of the remaining scopes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们创建任何对象的**变量**组件中的变量时，我们实际上是在创建**对象变量**：属于对象且在该对象的所有视觉脚本之间共享的变量，但这并不是变量可以拥有的唯一作用域。以下是一个剩余作用域的列表：
- en: '**Graph**: Variables that can only be accessed by our current graph. No other
    script can read or write that variable. This is useful to save internal state,
    like private variables in C#.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图**: 只能通过我们当前图访问的变量。其他脚本无法读取或写入该变量。这有助于保存内部状态，例如C#中的私有变量。'
- en: '**Scene**: Variables that can be accessed by all objects in the current scene.
    When we change the scene, those variables are lost.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**: 可以被当前场景中所有对象访问的变量。当我们更改场景时，这些变量就会丢失。'
- en: '**App**: Variables that can be accessed in any part of the game at any time.
    This is useful to move values from one scene to another. For example, you can
    increase the score in one level and keep increasing it in the next, instead of
    restarting the score from 0.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**: 可以在任何游戏部分随时访问的变量。这有助于将值从一个场景移动到另一个场景。例如，您可以在一个级别中增加分数，并在下一个级别中继续增加，而不是从0重新开始分数。'
- en: '**Saved**: Variables whose values are kept between game runs. You can save
    persistent data such as the Player Level or Inventory to continue the quest, or
    simpler things such as the sound volume as set by the user in the **Options**
    menu (if you created one).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已保存**: 价值在游戏运行之间保持的变量。您可以保存持久数据，例如玩家等级或库存以继续任务，或者更简单的事情，例如用户在**选项**菜单中设置的声音音量（如果您创建了一个）。'
- en: In this case, the **Scene** scope is the one we want, as the score we intend
    to increase will be accessed by several objects in the scene (more on that later)
    and we don’t want it to persist if we reset the level to play again; it will need
    to be set again to 0 in each run of the level and game.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**场景**作用域是我们想要的，因为我们打算增加的分数将被场景中的多个对象访问（稍后会有更多介绍），我们不希望它在重置级别以再次播放时持续存在；它需要在每个级别的运行和游戏中重新设置为0。
- en: To create scene variables, you can simply select the **Scene** tab in the **Blackboard**
    pane of the **Script Graph** editor while you are editing any script graph, or
    you can also use the **Scene Variables** GameObject that was created automatically
    when you started editing any graph. That object is the one that really holds the
    variables and must not be deleted. You will notice that it will have a **Variables**
    component as we have used before, but it will also have the **Scene Variables**
    component, indicating those variables are scene variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建场景变量，你可以在编辑任何脚本图时，在**Script Graph**编辑器的**Blackboard**面板中选择**Scene**选项卡，或者你也可以使用当你开始编辑任何图时自动创建的**Scene
    Variables** GameObject。那个对象是真正持有变量的对象，不得删除。你会注意到它将有一个**Variables**组件，就像我们之前使用的那样，但它还将有一个**Scene
    Variables**组件，表示这些变量是场景变量。
- en: In the following screenshot, you can see how we have simply added the **score**
    variable to the **Scene Variables** tab to make it accessible in any of our script
    graphs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到我们如何简单地添加了**score**变量到**Scene Variables**选项卡，使其在我们的任何脚本图中都可以访问。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_10_PE.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_08_10_PE.png)'
- en: 'Figure 8.10: Adding scene variables to our game'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：将场景变量添加到我们的游戏中
- en: Finally, for the score-increasing behavior, we can add the following graph to
    our enemy. Remember, as usual, to have the C# or the Visual Scripting version
    of the scripts, not both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于增加分数的行为，我们可以在敌人中添加以下图。记住，像往常一样，只保留C#或Visual Scripting版本的脚本，不要两者都保留。
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_11_PE.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由低置信度自动生成](img/B21361_08_11_PE.png)'
- en: 'Figure 8.11: Adding score when this object is destroyed'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：当此对象被销毁时增加分数
- en: At first, this script seems pretty similar to our C# version; we add the `s`**coreToAdd**
    variable of our object (**Object** scope) and then we add it to the whole scene’s
    `score` variable, as specified in the node. The main difference you can see is
    that here we are using the **On Disable** event instead of **OnDestroy.** Actually,
    **OnDestroy** is the correct one, but in the current version of Visual Scripting,
    there is a bug that prevents it from working properly, so I replaced it for now.
    The problem with **On Disable** is that it executes whenever the object is disabled,
    and while the object is disabled before it is destroyed, it can also be disabled
    in other circumstances (for example, using **Object Pooling**, a way to recycle
    objects instead of destroying and instancing them constantly), but so far it is
    enough for us. Please consider trying with **OnDestroy** first when you try this
    graph to see if it runs properly in your Unity or Visual Scripting package version.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个脚本看起来与我们的C#版本非常相似；我们添加了对象（**Object**作用域）的`s**coreToAdd**`变量，然后根据节点添加到整个场景的`score`变量中。你可以看到的主要区别是，这里我们使用的是**On
    Disable**事件而不是**OnDestroy**。实际上，**OnDestroy**是正确的选择，但在当前版本的Visual Scripting中，存在一个阻止其正常工作的bug，所以我暂时替换了它。**On
    Disable**的问题在于它会在对象被禁用时执行，而对象在被销毁之前可能已经被禁用，也可能在其他情况下被禁用（例如，使用**Object Pooling**，这是一种回收对象而不是不断销毁和实例化对象的方法），但到目前为止这已经足够我们使用了。请在尝试此图时首先考虑使用**OnDestroy**，看看它是否在你的Unity或Visual
    Scripting包版本中运行正常。
- en: Something to highlight is the usage of the **Has Variable** node to check if
    the **score** variable exists. This is done because **OnDisable** can be executed
    either at the moment the enemy is destroyed or when the scene changes, which we
    will do later in this chapter with the lose/win screen. If we try to get a Scene
    variable at that moment, we risk getting an error if the **Scene Variables** object
    is destroyed before the **GameMode** object, given the change of Scene involves
    destroying every object in the Scene first.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用**Has Variable**节点来检查**分数**变量是否存在。这样做是因为**OnDisable**可以在敌人被销毁或场景改变时执行，我们将在本章后面的内容中通过输赢屏幕来实现这一点。如果我们试图在那个时刻获取场景变量，如果**Scene
    Variables**对象在**GameMode**对象之前被销毁，由于场景的改变涉及首先销毁场景中的所有对象，我们可能会遇到错误。
- en: As you may have noticed by now, even though Visual Scripting is mostly extremely
    similar to C#, one has concepts to solve certain scenarios that the other doesn’t.
    Now that we know how to share variables, let’s finish some other managers that
    we will need later in the game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经注意到的，尽管视觉脚本与 C# 非常相似，但有一种概念可以解决另一种无法解决的问题。现在我们知道了如何共享变量，让我们完成一些我们将在游戏后期需要的其他管理器。
- en: Creating managers
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管理器
- en: Sometimes, we need a place to put together information about a group of similar
    objects, for example, `EnemyManager`, to check the number of enemies and potentially
    access an array of them to iterate over them and do any extra gameplay implementation
    we want, for instance making our `MissionManager`, to have access to all of the
    active missions in our game. Again, these cases can be considered Singletons,
    single objects that won’t be repeated (in our current game design), so let’s create
    the ones we will need in our game, that is, `EnemyManager` and `WaveManager`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个地方来汇总一组相似对象的信息，例如，`EnemyManager`，以检查敌人的数量，并可能访问它们的数组以迭代它们并执行任何额外的游戏实现，例如使我们的
    `MissionManager` 能够访问游戏中所有活动的任务。同样，这些情况可以被认为是 Singleton，即不会重复的单个对象（在我们的当前游戏设计中），因此让我们创建我们将在游戏中需要的那些，即
    `EnemyManager` 和 `WaveManager`。
- en: In our game, `EnemyManager` and `WaveManager` will just be used as places to
    save an array of references to the existing enemies and waves in our game, just
    as a way to know their current amount. There are ways to search all objects of
    a certain type to calculate their count, but those functions are expensive and
    not recommended for use unless you really know what you are doing. So, having
    a manager implemented as a Singleton, with a separate updated list of references
    to the target object type will require more code but will perform better. Also,
    as the game features increase, these managers will have more functionality and
    helper functions to interact with those objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，`EnemyManager` 和 `WaveManager` 将仅用作保存现有敌人波次的引用数组的场所，就像知道它们当前数量的方式一样。有方法可以搜索特定类型的所有对象来计算它们的数量，但这些函数成本高昂，除非你真的知道你在做什么，否则不建议使用。因此，将管理器实现为
    Singleton，并具有针对目标对象类型的单独更新引用列表，将需要更多的代码，但性能会更好。此外，随着游戏功能的增加，这些管理器将具有更多功能和支持函数来与这些对象交互。
- en: 'Let’s start with the enemies manager by doing the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从敌人管理器开始，按照以下步骤进行：
- en: Add a script called `Enemy` to the **Enemy** Prefab; this will be the script
    that will connect this object with `EnemyManager` in a moment.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为 `Enemy` 的脚本添加到 **Enemy** 预制件中；这将是一个将此对象与 `EnemyManager` 连接的脚本。
- en: Create an empty `GameObject` called `EnemyManager` and add a script to it called
    `EnemiesManager`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `EnemyManager` 的空 `GameObject`，并向其添加一个名为 `EnemiesManager` 的脚本。
- en: Create a `public` static field of the `EnemiesManager` type called `instance`
    inside the script and add the Singleton repetition check in `Awake` as we did
    in `ScoreManager`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本内部创建一个名为 `instance` 的 `EnemiesManager` 类型的 `public` 静态字段，并在 `Awake` 方法中添加与我们在
    `ScoreManager` 中所做的相同的 Singleton 重复检查。
- en: Create a public field of the `List<Enemy>` type called `enemies`:![](img/B21361_08_12_PE.png)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `enemies` 的 `List<Enemy>` 类型的公共字段：![](img/B21361_08_12_PE.png)
- en: 'Figure 8.12: List of Enemy components'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.12：敌人组件列表
- en: 'A list in C# represents a dynamic array, an array capable of adding and removing
    objects. You will see that you can add and remove elements to and from this list
    in the editor, but keep the list empty; we will add enemies another way. Take
    into account that `List` is in the `System.Collections.Generic` namespace; you
    will find the `using` sentence at the beginning of our script. Also, consider
    that you can make the list private and expose it to the code via a getter instead
    of making it a public field; but as usual, we will make our code as simple as
    possible for now:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C# 中的列表表示一个动态数组，一个能够添加和删除对象的数组。您将看到您可以在编辑器中向此列表添加和删除元素，但请保持列表为空；我们将以另一种方式添加敌人。请注意，`List`
    在 `System.Collections.Generic` 命名空间中；您将在我们脚本的开始处找到 `using` 语句。此外，请考虑您可以将列表设为私有，并通过
    getter 而不是公共字段将其暴露给代码；但像往常一样，我们现在将使代码尽可能简单：
- en: '![A picture containing text, font, white, screenshot  Description automatically
    generated](img/B21361_08_13_PE.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![包含文本、字体、白色、截图的图片，自动生成描述](img/B21361_08_13_PE.png)'
- en: 'Figure 8.13: Using needed to use the List class, inside System.Collections.Generic'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.13：使用 `List` 类，位于 `System.Collections.Generic` 中
- en: Consider that `List` is a class type, so it must be instantiated, but as this
    type has exposing support in the editor, Unity will automatically instantiate
    it. You must use the `new` keyword to instantiate it in cases where you want a
    non-editor-exposed list, such as a private one or a list in a regular non-component
    C# class.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到 `List` 是一个类类型，所以它必须被实例化，但因为这个类型在编辑器中有暴露支持，Unity 会自动实例化它。当你想要一个非编辑器暴露的列表时，例如一个私有列表或在常规的非组件
    C# 类中的列表，你必须使用 `new` 关键字来实例化它。
- en: The C# list internally is implemented as an array. If you need a linked list,
    use the **LinkedList** collection type instead.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C# 列表在内部实现为一个数组。如果你需要一个链表，请使用 **LinkedList** 集合类型代替。
- en: In the `Start` function of the `Enemy` script, access the `EnemyManager` Singleton
    and, using the `Add` function of the enemies list, add this object to the list.
    This will “register” this enemy as active in the manager, so other objects can
    access the manager and check for the current enemies. The `Start` function is
    called after all of the `Awake` function calls, and this is important because
    we need to be sure that the `Awake` function of the manager is executed prior
    to the `Start` function of the enemy to ensure that there is a manager set as
    the instance.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Enemy` 脚本的 `Start` 函数中，访问 `EnemyManager` 单例，并使用敌人列表的 `Add` 函数将此对象添加到列表中。这将“注册”此敌人作为活动状态在管理器中，以便其他对象可以访问管理器并检查当前敌人。`Start`
    函数在所有 `Awake` 函数调用之后被调用，这是很重要的，因为我们需要确保在敌人的 `Start` 函数之前执行管理器的 `Awake` 函数，以确保有一个设置为实例的管理器。
- en: The problem we solved with the `Start` function is called a race condition,
    that is, when two pieces of code are not guaranteed to be executed in the same
    order, whereas the `Awake` execution order can change due to different reasons.
    There are plenty of situations in code where this will happen, so pay attention
    to the possible race conditions in your code. Also, you might consider using more
    advanced solutions such as lazy initialization here, which can give you better
    stability, but again, for the sake of simplicity and exploring the Unity API,
    we will use the `Start` function approach for now.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `Start` 函数解决的问题被称为竞态条件，即当两段代码不能保证按相同顺序执行时，而 `Awake` 执行顺序可能会因不同原因而改变。代码中有很多情况会发生这种情况，所以请注意你代码中可能存在的竞态条件。此外，你可能考虑使用更高级的解决方案，例如在这里使用懒初始化，这可以给你更好的稳定性，但再次强调，为了简单和探索
    Unity API，我们目前将使用 `Start` 函数方法。
- en: 'In the `OnDestroy` function, remove the enemy from the list to keep the list
    updated with just the active ones:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnDestroy` 函数中，从列表中删除敌人以保持列表只更新活动对象：
- en: '![A screen shot of a computer program  Description automatically generated
    with low confidence](img/B21361_08_14_PE.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序的屏幕截图  描述自动生成，置信度低](img/B21361_08_14_PE.png)'
- en: 'Figure 8.14: The enemy script to register ourselves as an active enemy'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14：将自身注册为活动敌人的敌人脚本
- en: With this, now we have a centralized place to access all of the active enemies
    in a simple but efficient way. I challenge you to do the same with the waves,
    using **WaveManager**, which will have the collection of all active waves to later
    check whether all waves finished their work to consider the game as won.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在有一个集中的地方可以以简单而有效的方式访问所有活动敌人。我挑战你使用 **WaveManager** 做同样的事情，它将包含所有活动波浪的集合，以便稍后检查是否所有波浪都完成了它们的工作，从而认为游戏胜利。
- en: 'Take some time to solve this; you will find the solution in the following screenshots,
    starting with **WavesManager**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间解决这个问题；你将在以下屏幕截图中发现解决方案，从 **WavesManager** 开始：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_08_15_PE.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序的截图  描述自动生成，置信度中等](img/B21361_08_15_PE.png)'
- en: 'Figure 8.15: The full WavesManager script'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15：完整的 WavesManager 脚本
- en: 'You will also need the `WaveSpawner` script:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要 `WaveSpawner` 脚本：
- en: '![A screenshot of a computer code  Description automatically generated with
    medium confidence](img/B21361_08_16_PE.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码的截图  描述自动生成，置信度中等](img/B21361_08_16_PE.png)'
- en: 'Figure 8.16: The modified WaveSpawner script to support WavesManager'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：修改后的 WaveSpawner 脚本以支持 WavesManager
- en: As you can see, `WavesManager` is created the same way `EnemyManager` was –
    just a Singleton with a list of `WaveSpawner` references, but `WaveSpawner` is
    different. We execute the `Add` function of the list in the `Start` event of `WaveSpawner`
    to register the wave as an active one, but the `Remove` function needs more work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`WavesManager`的创建方式与`EnemyManager`相同——只是一个带有`WaveSpawner`引用列表的单例，但`WaveSpawner`是不同的。我们在`WaveSpawner`的`Start`事件中执行列表的`Add`函数，将波注册为活动波，但`Remove`函数需要更多的工作。
- en: The idea is to deregister the wave from the active waves list when the spawner
    finishes its work. Before this modification, we used `Invoke` to call the `CancelInvoke`
    function after a while to stop the spawning, but now we need to do more after
    the end time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在生成器完成其工作后，从活动波列表中注销该波。在这次修改之前，我们使用`Invoke`在一段时间后调用`CancelInvoke`函数来停止生成，但现在我们需要在结束时间之后做更多的事情。
- en: Instead of calling `CancelInvoke` after the specified wave end time, we will
    call a custom function called `EndSpawner`, which will call `CancelInvoke` to
    stop the spawner, `Invoke Repeating`, but also will call the remove-from-`WavesManager`-list
    function to make sure the removing-from-the-list function is called exactly when
    `WaveSpawner` finishes its work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的波结束时间之后，我们不会调用`CancelInvoke`，而是调用一个名为`EndSpawner`的自定义函数，该函数将调用`CancelInvoke`来停止生成器，`Invoke
    Repeating`，同时还会调用从`WavesManager`列表中移除函数，以确保在`WaveSpawner`完成其工作后，移除列表中的函数被准确调用。
- en: 'Regarding the Visual Scripting version, we can add two lists of the GameObject
    type to the Scene variables to hold the references to the existing waves and enemies
    so we can keep track of them. Just search `List of GameObject` in the search bar
    of the variable type selector and you will find it. In this case, the lists contain
    only GameObjects given that the Visual Scripting versions of `WaveSpawner` and
    enemy scripts are not types we can reference like C# ones. If you did both C#
    and Visual Scripting versions of these, you will see you can reference the C#
    versions, but we are not going to mix C# and Visual Scripting as it is out of
    the scope of the book, so ignore them. Anyway, given how the **Variables** system
    of Visual Scripting works, we can still access variables inside if needed using
    the **GetVariable** node—remember the variables are not in the Visual Scripts
    but in the **Variables** node:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，我们可以将两个GameObject类型的列表添加到场景变量中，以保存现有波和敌人的引用，这样我们就可以跟踪它们。只需在变量类型选择器的搜索栏中搜索`List
    of GameObject`，你就可以找到它。在这种情况下，由于`WaveSpawner`和敌人脚本的视觉脚本版本不是我们可以像C#那样引用的类型，所以列表中只包含GameObject。如果你同时创建了这些的C#和视觉脚本版本，你会看到你可以引用C#版本，但我们不会混合C#和视觉脚本，因为这不属于本书的范围，所以忽略它们。无论如何，鉴于视觉脚本**变量**系统的工作方式，如果需要，我们仍然可以使用**GetVariable**节点访问变量——记住变量不在视觉脚本中，而是在**变量**节点中：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_17_PE.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，置信度中等](img/B21361_08_17_PE.png)'
- en: 'Figure 8.17: Adding lists to the Scene variables'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：向场景变量中添加列表
- en: 'Then, we can add the following to the **WaveSpawner** graph:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在**WaveSpawner**图中添加以下内容：
- en: '![A picture containing text, screenshot, font, diagram  Description automatically
    generated](img/B21361_08_18_PE.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、图表的图片，描述自动生成](img/B21361_08_18_PE.png)'
- en: 'Figure 8.18: Adding elements to List'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：向列表中添加元素
- en: 'We used the **Add List Item** node to add our GameObject to the **waves** variable.
    We did this as the first thing to do in the **On Start** event node before anything.
    And to remove that wave from the active ones, you will need to make the following
    change:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**Add List Item**节点将我们的GameObject添加到**waves**变量中。我们在**On Start**事件节点之前将其作为第一件事来做。要移除该波从活动波中，你需要进行以下更改：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_19_PE.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图，描述自动生成，置信度低](img/B21361_08_19_PE.png)'
- en: 'Figure 8.19: Removing elements from List'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：从列表中移除元素
- en: We remove this spawner from the list using the **Exit** flow output pin of **For
    Loop**, which is executed when the `for` loop finishes iterating.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**For Loop**的**Exit**流程输出引脚从列表中移除这个生成器，该引脚在`for`循环完成迭代时执行。
- en: 'Finally, regarding **Enemy**, you will need to create a new **Enemy Script**
    graph, which will look similar:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于**敌人**，你需要创建一个新的**敌人脚本**图，它看起来类似：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_20_PE.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由低置信度自动生成](img/B21361_08_20_PE.png)'
- en: 'Figure 8.20: Enemy adding and removing itself from the lists'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：敌人将自己添加到列表中并从中移除
- en: As you can see, we simply add the enemy on **On Start** and remove it in **OnDisable**.
    Remember to first try using **OnDestroy** instead of **OnDisable** due to the
    bug we mentioned previously. You can check these changes by playing the game while
    having the **Scene Variables** GameObject selected and seeing how its value changes.
    Also, remember the need to use the **Has Variable** node in case we are changing
    scenes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们只需在**On Start**时添加敌人，并在**OnDisable**时移除它。记得由于我们之前提到的错误，首先尝试使用**OnDestroy**而不是**OnDisable**。你可以通过在具有**Scene
    Variables** GameObject被选中的情况下玩游戏来检查这些更改，并观察其值如何变化。此外，记得如果我们正在更改场景，需要使用**Has Variable**节点。
- en: Using object managers, we now have centralized information about a group of
    objects, and we can add all sorts of object group logic here. We created the `EnemiesManager`,
    `WavesManager`, and `ScoreManager` as centralized places to store several game
    systems’ information, such as the enemies and waves present in the scene, and
    the score as well. We also saw the Visual Scripting version, centralizing that
    data in the Scene Variables object, so all Visual Scripts can read that data.
    But aside from having this information for updating the UI (which we will do in
    the next chapter), we can use this information to detect whether the victory and
    loss conditions of our game are met, creating a **Game Mode** object to detect
    that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象管理器，我们现在可以集中管理一组对象的信息，并且可以在这里添加各种对象组逻辑。我们创建了`EnemiesManager`、`WavesManager`和`ScoreManager`作为集中存储几个游戏系统信息的地方，例如场景中存在的敌人和波次，以及分数。我们还看到了视觉脚本版本，将数据集中存储在场景变量对象中，这样所有的视觉脚本都可以读取这些数据。但除了用于更新UI（我们将在下一章中这样做）的信息之外，我们还可以使用这些信息来检测我们的游戏是否满足胜利和失败条件，创建一个**游戏模式**对象来检测这一点。
- en: Creating Game Modes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: We have created objects to simulate lots of gameplay aspects of our game, but
    the game needs to end sometime, whether we win or lose. As always, the question
    is where to put this logic, and that leads us to further questions. The main questions
    would be, will we always win or lose the game the same way? Will we have a special
    level with different criteria than “kill all of the waves,” such as timed survival?
    Only you know the answer to those questions, but if right now the answer is no,
    it doesn’t mean that it won’t change later, so it is advisable to prepare our
    code to adapt seamlessly to changes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了对象来模拟游戏中的许多游戏玩法方面，但游戏需要结束，无论我们赢或输。一如既往，问题是逻辑应该放在哪里，这引出了更多的问题。主要问题将是，我们是否总是以相同的方式赢或输？我们是否会有一个具有不同于“消灭所有波次”的不同标准的特殊关卡，比如限时生存？只有你知道这些问题的答案，但如果你现在的答案是“不”，这并不意味着它不会在以后改变，因此建议我们准备代码以无缝适应变化。
- en: To be honest, preparing code to adapt seamlessly to changes is almost impossible;
    there’s no way to have code that considers every possible case, and we will always
    need to rewrite some code sooner or later. We will try to make the code as generic
    as possible to adapt to changes, but we need to find a balance between necessary
    and unnecessary adaptability. Creating generic code tends to generate complex
    codebases and takes more time, and while a certain degree of complexity is certainly
    necessary, many times, I have seen programmers go beyond what’s needed, taking
    a huge amount of time to solve simple cases, creating tools that ended up being
    under-utilized.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，编写能够无缝适应变化的代码几乎是不可能的；没有一种方法可以考虑到所有可能的情况，我们迟早都需要重写一些代码。我们将尽力使代码尽可能通用，以适应变化，但我们需要在必要性和不必要的适应性之间找到平衡。创建通用代码往往会生成复杂的代码库，并且需要更多的时间，尽管一定程度的复杂性肯定是必要的，但很多时候，我看到程序员们超出了所需，花费大量时间来解决简单的情况，创建了最终利用率低下的工具。
- en: To do this, we will separate the victory and loss conditions’ logic in its own
    object, which I like to call the “GameMode” (not necessarily an industry standard).
    This will be a component that will oversee the game, checking conditions that
    need to be met in order to consider the game over. It will be like the referee
    of our game. The Game Mode will constantly check the information in the object
    managers, and maybe other sources of information, to detect the needed conditions.
    Having this object separated from other objects allows us to create different
    levels with different Game Modes; just use another Game Mode script in that level
    and that’s all.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将胜利和失败条件的逻辑分离到其自己的对象中，我喜欢将其称为“GameMode”（不一定是行业标准）。这将是一个将监督游戏、检查需要满足的条件以考虑游戏结束的组件。它将像我们游戏中的裁判。游戏模式将不断检查对象管理器中的信息，以及可能的其他信息源，以检测所需条件。将此对象与其他对象分离，使我们能够创建具有不同游戏模式的级别；只需在该级别使用另一个游戏模式脚本即可。
- en: 'In our case, we will have a single Game Mode for now, which will check whether
    the number of waves and enemies becomes 0, meaning that we have killed all of
    the possible enemies and the game is won. Also, it will check whether the life
    of the player reaches 0, considering the game lost in that situation. Let’s create
    it by doing the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们现在将只有一个游戏模式，该模式将检查波浪和敌人的数量是否变为`0`，这意味着我们已经杀死了所有可能的敌人，游戏胜利。同时，它还将检查玩家的生命值是否达到`0`，考虑到在这种情况下游戏失败。让我们通过以下步骤创建它：
- en: Create an empty `GameMode` object and add a `WavesGameMode` script to it. As
    you can see, we gave the script a descriptive name considering that we can add
    other Game Modes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空`GameMode`对象，并向其添加一个`WavesGameMode`脚本。正如你所见，我们给脚本起了一个描述性的名字，考虑到我们可以添加其他游戏模式。
- en: In its `Update` function, check whether the number of enemies and waves has
    reached `0` by using the `Enemy` and `Wave` managers; in that case, just `print`
    a message in the console for now. All lists have a `Count` property, which will
    tell you the number of elements stored inside.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`Update`函数中，通过使用`Enemy`和`Wave`管理器检查敌人数量和波浪数量是否达到`0`；在这种情况下，目前只需在控制台`print`一条消息。所有列表都有一个`Count`属性，它将告诉你存储在内部元素的数量。
- en: Add a `public` field of the `Life` type called `PlayerLife` and drag the player
    to that one; the idea is to also detect the loss condition here.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`PlayerLife`的`Life`类型的`public`字段，并将玩家拖到该字段；这里的想法是也要在这里检测失败条件。
- en: 'In `Update`, add another check to detect whether the life amount of the `playerLife`
    reference reached `0`, and in that case, `print` a lose message in the console:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，添加另一个检查以检测`playerLife`引用的生命值是否达到`0`，如果是这样，则在控制台`print`一条失败信息：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_21_PE.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_08_21_PE.png)'
- en: 'Figure 8.21: Win and lose condition checks in WavesGameMode'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：WavesGameMode中的胜利和失败条件检查
- en: Play the game and test both cases – whether the player’s life reaches 0 or whether
    you have killed all enemies and waves.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并测试两种情况——玩家的生命值是否达到`0`，或者你是否杀死了所有敌人和波浪。
- en: 'Now, it is time to replace the messages with something more interesting. For
    now, we will just change the current scene to a **Win Scene** or **Lose Scene**,
    which will only have a UI with a win or lose message and a button to play again.
    In the future, you could add a **Main Menu** **Scene** and have an option to get
    back to it. Let’s implement this by doing the following:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，是时候用更有趣的消息替换它们了。目前，我们只需将当前场景更改为**胜利场景**或**失败场景**，该场景将只有一个带有胜利或失败消息和重新播放按钮的UI。将来，你可以添加一个**主菜单****场景**，并有一个选项返回到它。让我们通过以下步骤实现这一点：
- en: Create a new scene (**File | New Scene**) and save it, calling it `WinScreen`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景（**文件 | 新场景**）并保存它，将其命名为`WinScreen`。
- en: Add something to indicate that this is the win screen, such as simply a sphere
    with the camera pointing to it. This way, we know when we change to the win screen.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些指示这是胜利场景的东西，比如简单地用一个球体，相机指向它。这样，我们知道何时切换到胜利场景。
- en: Select the scene in the **Project** view and press *Ctrl* + *D* (*Cmd* + *D*
    on Mac) to duplicate the scene. Rename it `LoseScreen`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中选择场景，然后按*Ctrl* + *D*（在Mac上为*Cmd* + *D*）来复制场景。将其重命名为`LoseScreen`。
- en: Double-click the `LoseScreen` scene to open it and change the sphere to something
    different, maybe a cube.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`LoseScreen`场景以打开它，并将球体更改为不同的东西，比如一个立方体。
- en: Go to **File | Build Settings** to open the **Scenes In Build** list inside
    this window.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件 | 构建设置**以打开此窗口内的**构建中的场景**列表。
- en: 'The idea is that Unity needs you to explicitly declare all Scenes that must
    be included in the game. You might have test Scenes or Scenes that you don’t want
    to release yet, so that’s why we need to do this. In our case, our game will have
    `WinScreen`, `LoseScreen`, and the Scene we have created so far with the game
    scenario, which I called `Game`, so just drag those Scenes from the **Project**
    view to the list of the **Build Settings** window; we will need this to make the
    Game Mode script change between Scenes properly. Also, consider that the first
    Scene in this list will be the first Scene to be opened when we play the game
    in its final version (known as the build), so you may want to rearrange the list
    according to that:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是Unity需要你明确声明所有必须包含在游戏中的场景。你可能有一些测试场景或者你还不打算发布的场景，这就是为什么我们需要这样做。在我们的案例中，我们的游戏将包含`WinScreen`、`LoseScreen`以及我们迄今为止创建的带有游戏场景的场景，我将其称为`Game`，所以只需将这些场景从**项目**视图拖到**构建设置**窗口的列表中；我们需要这样做才能使游戏模式脚本在场景之间正确切换。此外，考虑到这个列表中的第一个场景将是我们在最终版本（即构建版本）中玩游戏时首先打开的场景，所以你可能需要根据这一点重新排列列表：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_08_22_PE.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由中等置信度自动生成](img/B21361_08_22_PE.png)'
- en: 'Figure 8.22: Registering the Scenes to be included in the build of the game'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：将场景注册到游戏构建中
- en: In `WavesGameMode`, add a `using` statement for the `UnityEngine.SceneManagement`
    namespace to enable the scene-changing functions in this script.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`中，添加一个`using`语句用于`UnityEngine.SceneManagement`命名空间，以启用此脚本中的场景切换功能。
- en: Replace the console `print` messages with calls to the `SceneManager.LoadScene`
    function, which will receive a string with the name of the Scene to load; in this
    case, it would be `WinScreen` and `LoseScreen`. You just need the Scene name,
    not the entire path to the file.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制台`print`消息替换为对`SceneManager.LoadScene`函数的调用，该函数将接收一个包含要加载的场景名称的字符串；在这种情况下，将是`WinScreen`和`LoseScreen`。你只需要场景名称，而不需要文件的完整路径。
- en: 'If you want to chain different levels, you can create a `public` string field
    to allow you to specify via editor which Scenes to load. Remember to have the
    Scenes added to **Build Settings**. If you don’t, you will receive an error message
    in the console when you try to change the Scenes:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要连接不同的关卡，你可以创建一个`public`字符串字段，以便你可以在编辑器中指定要加载哪些场景。记住将场景添加到**构建设置**中。如果不这样做，当你尝试更改场景时，控制台将显示错误信息：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_08_23_PE.png)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由中等置信度自动生成](img/B21361_08_23_PE.png)'
- en: 'Figure 8.23: Changing Scenes with SceneManager'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.23：使用SceneManager切换场景
- en: Play the game and check whether the Scenes change properly.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩游戏并检查场景是否正确切换。
- en: Right now, we picked the simplest way to show whether we lost or won, but in
    the future, you may want something gentler than a sudden change of Scene, such
    as maybe waiting a few moments with `Invoke` to delay that change or directly
    show the winning message inside the game without changing Scenes. Bear this in
    mind when testing the game with people and checking whether they understood what
    happened when they were playing—game feedback is important to keep the player
    aware of what is happening and is not an easy task to tackle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们选择了最简单的方式来显示我们输赢，但将来，你可能想要比突然切换场景更柔和的方式，比如可能使用`Invoke`等待几秒钟来延迟这个变化，或者直接在游戏中显示胜利信息而不切换场景。当测试游戏并检查人们在玩游戏时是否理解发生了什么时，请记住这一点——游戏反馈对于让玩家了解正在发生的事情非常重要，并且不是一项容易的任务。
- en: 'Regarding the Visual Scripting version, we added a new script graph to a separate
    object. Let’s examine it piece by piece to see it clearly. Let’s start with the
    win condition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，我们在一个单独的对象中添加了一个新的脚本图。让我们逐个检查它，以便清楚地看到它。让我们从胜利条件开始：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_24_PE.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由低置信度自动生成](img/B21361_08_24_PE.png)'
- en: 'Figure 8.24: Win condition in Visual Scripting'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：视觉脚本中的胜利条件
- en: Here, we are getting the **enemies** list from the scene context (**Get Variable**
    node), and knowing that it contains a List, we are using the **Count Items** node
    to check how many enemies remain in this list. Remember we have a script that
    adds the enemy to the list when it’s spawned and removes it when it is destroyed.
    We do the same for the waves, so combine the conditions with an **And** node and
    connect it with an **If** to then do something (more on that in a moment).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从场景上下文中获取**敌人**列表（**获取变量**节点），并且知道它包含一个列表，因此我们使用**计数项**节点来检查这个列表中剩余多少敌人。记住，我们有一个脚本在敌人被生成时将其添加到列表中，在它被销毁时将其移除。我们对波次也做同样的处理，所以使用**与**节点将条件组合起来，并通过**如果**节点连接，然后执行某些操作（稍后详细介绍）。
- en: 'Now let’s examine the lose condition:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来检查失败条件：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_25_PE.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_08_25_PE.png)'
- en: 'Figure 8.25: Lose condition in Visual Scripting'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：视觉脚本中的失败条件
- en: As the player’s life is not in the Scene context (and shouldn’t be), and the
    player is a different GameObject from the one called `GameMode` (the one we created
    specifically for this script), we need a variable of type Game Object called **Player**
    to reference it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家的生命状态不在场景上下文中（而且不应该在），并且玩家是一个与名为`GameMode`的GameObject不同的GameObject（我们专门为这个脚本创建的），我们需要一个类型为GameObject的变量名为**Player**来引用它。
- en: As you can see, we dragged our player to it in the **Variables** component.
    Finally, we used **GetVariable** to access our player reference in the graph,
    and then another **GetVariable** to extract the life from it. We accomplished
    that by connecting the player reference to the **GetVariable** node of the **life**
    variable. Then we repeated this for the player’s base.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在**变量**组件中将我们的玩家拖拽到上面。最后，我们使用**获取变量**来访问图中的玩家引用，然后使用另一个**获取变量**来提取其生命值。我们通过将玩家引用连接到**获取变量**节点的**生命**变量来实现这一点。然后我们对玩家的基础重复这一过程。
- en: 'Finally, we load the scenes by doing the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过以下方式加载场景：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_26_PE.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_08_26_PE.png)'
- en: 'Figure 8.26: Loading scenes in Visual Scripting'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：在视觉脚本中加载场景
- en: As you can see, we use the **Scene Manager Load Scene (SceneName)** node to
    load the Scenes. Notice how we load both Scenes we created before (**WinScene**
    and **LoseScene**). Remember that these two Scenes need to be added to the **Scenes
    In Build** section inside **Build Settings** as we did before, in order to be
    available to be loaded by the Scene Manager here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用**场景管理器加载场景（场景名称）**节点来加载场景。注意我们加载了我们之前创建的两个场景（**WinScene**和**LoseScene**）。记住，这两个场景需要像之前一样添加到**构建设置**中的**构建中的场景**部分，以便在这里可以被场景管理器加载。
- en: Now we have a fully functional simple game, with mechanics and win and lose
    conditions, and while this is enough to start developing other aspects of our
    game, I want to discuss some issues with our current manager approach and how
    to solve them with events.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能齐全的简单游戏，具有机制和胜负条件，虽然这足以开始开发我们游戏的其它方面，但我想要讨论一下我们当前管理方法的问题以及如何通过事件来解决这些问题。
- en: Improving our code with events
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件改进我们的代码
- en: So far, we have used Unity event functions to detect situations that can happen
    in the game such as `Awake` and `Update`. There are other similar functions that
    Unity uses to allow components to communicate with each other, as in the case
    of `OnTriggerEnter`, which is a way for the Rigidbody component to inform other
    components in the GameObject that a collision has happened. In our case, we are
    using `if` statements inside the `Update` method to detect changes on other components,
    such as `GameMode` checking whether the number of enemies has reached 0\. But
    we can improve this if we are informed by the Enemy manager when something has
    changed, and just do the check at that moment, such as with the Rigidbody component
    telling us when collisions occur instead of checking for collisions every frame.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Unity事件函数来检测游戏中可能发生的情况，例如`Awake`和`Update`。Unity还使用其他类似函数来允许组件之间相互通信，例如`OnTriggerEnter`，这是Rigidbody组件通知GameObject中其他组件发生碰撞的一种方式。在我们的情况下，我们使用`Update`方法中的`if`语句来检测其他组件的变化，例如`GameMode`检查敌人数量是否达到0。但如果我们从敌人管理器那里得知有变化，我们就可以在那个时刻进行检查，例如，使用Rigidbody组件告诉我们何时发生碰撞，而不是每帧检查碰撞。
- en: Also, sometimes, we rely on Unity events to execute logic, such as the score
    being given in the `OnDestroy` event, which informs us when the object is destroyed,
    but due to the nature of the event, it can be called in situations we don’t want
    to add to the score, such as when the Scene is changed, or the game is closed.
    Objects are destroyed in those cases, but not because the player killed the enemy,
    leading to the score increasing when it shouldn’t. In this case, it would be great
    to have an event that tells us that life reached 0 to execute this logic, instead
    of relying on the general-purpose `OnDestroy` event.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时我们依赖于Unity事件来执行逻辑，例如在`OnDestroy`事件中给出的分数，它通知我们对象何时被销毁，但由于事件的本性，它可能在我们不希望添加到分数的情况中被调用，例如当场景改变或游戏关闭时。在这些情况下，对象会被销毁，但不是因为玩家杀死了敌人，导致在不应该增加分数的情况下分数增加。在这种情况下，有一个告诉我们生命值达到0的事件来执行这个逻辑会很好，而不是依赖于通用的`OnDestroy`事件。
- en: The idea of events is to improve the model of communication between our objects,
    with the assurance that at the exact moment something happens, the relevant parts
    in that situation are notified to react accordingly. Unity has lots of events,
    but we can create ones specific to our gameplay logic. Let’s start by applying
    this in the score scenario we discussed earlier; the idea is to make the `Life`
    component have an event to communicate to the other components that the object
    was destroyed because life reached 0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的概念是为了改进我们对象之间的通信模型，确保在某个事件发生的确切时刻，该情境中的相关部分被通知并相应地做出反应。Unity有很多事件，但我们可以创建针对我们游戏逻辑特定的事件。让我们从应用我们之前讨论过的得分场景开始；想法是让`Life`组件有一个事件来通知其他组件对象被销毁是因为生命值达到了0。
- en: There are several ways to implement this, and we will use a little bit of a
    different approach than the **Awake** and **Update** methods; we will use the
    `UnityEvent` field type. This is a field type capable of holding references to
    functions to be executed when we want to, like C# delegates, but with other benefits,
    such as better Unity editor integration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点，我们将使用与**Awake**和**Update**方法略有不同的方法；我们将使用`UnityEvent`字段类型。这是一种字段类型，可以存储在需要执行时将要执行的函数的引用，就像C#委托一样，但具有其他好处，例如更好的Unity编辑器集成。
- en: 'To implement this, do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请执行以下操作：
- en: 'In the `Life` component, create a `public` field of the `UnityEvent` type called
    `onDeath`. This field will represent an event where other classes can subscribe
    to it to be made aware when `Life` reaches 0:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Life`组件中，创建一个名为`onDeath`的`public`类型的`UnityEvent`字段。该字段将代表一个事件，其他类可以订阅它，以便在`Life`达到0时得到通知：
- en: '![A picture containing text, font, screenshot, line  Description automatically
    generated](img/B21361_08_27_PE.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、行描述的图片，描述自动生成](img/B21361_08_27_PE.png)'
- en: 'Figure 8.27: Creating a custom event field'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：创建自定义事件字段
- en: If you save the script and go to the editor, you can see the event in the Inspector.
    Unity events support being subscribed to methods in the editor so we can connect
    two objects together. We will use this in the UI scripting chapter, so let’s just
    ignore this for now:![A screenshot of a computer  Description automatically generated
    with medium confidence](img/B21361_08_28_PE.png)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您保存脚本并进入编辑器，您可以在检查器中看到事件。Unity事件支持在编辑器中订阅方法，因此我们可以将两个对象连接起来。我们将在UI脚本章节中使用这个功能，所以现在就忽略它吧：![计算机截图  描述由中等置信度自动生成](img/B21361_08_28_PE.png)
- en: 'Figure 8.28: UnityEvents showing up in the Inspector'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.28：UnityEvents在检查器中显示
- en: You can use the generic delegate action or a custom delegate to create events
    instead of using `UnityEvent`, and aside from certain performance aspects, the
    only noticeable difference is that `UnityEvent` will show up in the editor, as
    demonstrated in *step 2*.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用通用委托操作或自定义委托来创建事件，而不是使用`UnityEvent`，除了某些性能方面外，唯一明显的区别是`UnityEvent`将在编辑器中显示，如*步骤
    2*所示。
- en: 'When life reaches `0`, call the `Invoke` function of the event. This way, we
    will be telling any script interested in the event that it has happened:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生命值达到`0`时，调用事件的`Invoke`函数。这样，我们将告诉任何对事件感兴趣的脚本它已经发生：
- en: '![A screenshot of a computer code  Description automatically generated with
    medium confidence](img/B21361_08_29_PE.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码的截图  描述由中等置信度自动生成](img/B21361_08_29_PE.png)'
- en: 'Figure 8.29: Executing the event'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：执行事件
- en: In `ScoreOnDeath`, rename the `OnDestroy` function to `GivePoints` or whatever
    name you prefer; the idea here is to stop giving points in the `OnDestroy` event.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`中，将`OnDestroy`函数重命名为`GivePoints`或您喜欢的任何名称；这里的想法是在`OnDestroy`事件中停止给予分数。
- en: In the `Awake` function of the `ScoreOnDeath` script, get the `Life` component
    using `GetComponent` and save it in a local variable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`脚本的`Awake`函数中，使用`GetComponent`获取`Life`组件并将其保存在局部变量中。
- en: Call the `AddListener` function of the `onDeath` field of the `Life` reference
    and pass the `GivePoints` function as the first argument. This is known as **subscribing**
    our `listener` method, `GivePoints`, to the `onDeath` event. The idea is to tell
    `Life` to execute `GivePoints` when the `onDeath` event is invoked. This way,
    `Life` informs us about that situation. Remember that you don’t need to call `GivePoints`,
    but just pass the function as a field:![A picture containing text, screenshot,
    font, line  Description automatically generated](img/B21361_08_30_PE.png)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Life`引用的`onDeath`字段的`AddListener`函数，并将`GivePoints`函数作为第一个参数传递。这被称为**订阅**我们的`listener`方法`GivePoints`到`onDeath`事件。想法是告诉`Life`在`onDeath`事件被调用时执行`GivePoints`。这样，`Life`会通知我们这种情况。记住，您不需要调用`GivePoints`，只需将其作为字段传递即可：![包含文本、截图、字体、行的图片  描述由自动生成](img/B21361_08_30_PE.png)
- en: 'Figure 8.30: Subscribing to the OnDeath event to give points in that scenario'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.30：订阅OnDeath事件以在该场景中给予分数
- en: Consider calling `RemoveListener` in `OnDestroy`; as usual, it is convenient
    to unsubscribe listeners when possible to prevent any memory leak (when a reference
    is preventing the GC from deallocating memory). In this scenario, it is not entirely
    necessary because both the `Life` and `ScoreOnDeath` components will be destroyed
    at the same time, but try to get used to this as a good practice.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑在`OnDestroy`中调用`RemoveListener`；像往常一样，在可能的情况下取消订阅监听器以防止任何内存泄漏（当引用阻止GC释放内存时）。在这种情况下，这并不是完全必要的，因为`Life`和`ScoreOnDeath`组件将同时被销毁，但尽量养成这种良好习惯。
- en: Save, select `ScoreManager` in the editor, and hit **Play** to test this. Try
    deleting an enemy from the Hierarchy while in **Play** mode to check that the
    score doesn’t rise because the enemy was destroyed for a reason other than their
    life becoming 0; you must destroy an enemy by shooting at them to see the score
    increase.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，在编辑器中选择`ScoreManager`，然后按**播放**来测试这个功能。在**播放**模式下尝试从层次结构中删除一个敌人，以检查分数是否没有上升，因为敌人被销毁的原因不是他们的生命值变为0；您必须射击敌人以看到分数增加。
- en: 'Now that `Life` has an `onDeath` event, we can also replace the player’s `Life`
    check from the `WavesGameMode` to use the event by doing the following:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，由于`Life`有一个`onDeath`事件，我们也可以通过以下方式将玩家的`Life`检查从`WavesGameMode`替换为使用事件：
- en: Create an `OnPlayerDied` function on the `WavesGameMode` script and move the
    loading of the `LoseScreen` scene from `Update` to this function. You will be
    removing the `if` that checks the life from the `Update` method, given that the
    event version will replace it.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`脚本上创建一个`OnPlayerDied`函数，并将`LoseScreen`场景的加载从`Update`方法移动到这个函数。由于事件版本将替代它，你将移除`Update`方法中检查生命的`if`语句。
- en: 'In `Awake`, add this new function to the `onDeath` event of the player’s `Life`
    component reference, called `playerLife` in our script:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，将这个新函数添加到玩家`Life`组件引用的`onDeath`事件中，在我们的脚本中称为`playerLife`：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_08_31_PE.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图，描述由低置信度自动生成](img/B21361_08_31_PE.png)'
- en: 'Figure 8.31: Checking the lose condition with events'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31：使用事件检查失败条件
- en: As you can see, creating custom events allows you to detect more specific situations
    other than the defaults in Unity, and keeps your code clean, without needing to
    constantly check several conditions in the `Update` function, which is not necessarily
    bad, but the event approach generates clearer code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建自定义事件允许你检测Unity中除了默认情况之外更具体的情况，并保持你的代码整洁，无需在`Update`函数中不断检查几个条件，这并不一定是坏事，但事件方法生成的代码更清晰。
- en: 'Remember that we can also lose our game by the player’s base `Life` reaching
    0, so let’s create a cube that represents the object that enemies will attack
    to reduce the base `Life`. Taking this into account, I challenge you to add this
    second lose condition (player’s base life reaching 0) to our script. When you
    finish, you can check the solution in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们也可以通过玩家的基础`Life`达到0来输掉游戏，所以让我们创建一个代表敌人将攻击以减少基础`Life`的对象的立方体。考虑到这一点，我挑战你将这个第二个失败条件（玩家的基础生命达到0）添加到我们的脚本中。当你完成时，你可以在下面的屏幕截图中检查解决方案：
- en: '![A screen shot of a computer program  Description automatically generated
    with low confidence](img/B21361_08_32_PE.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图，描述由低置信度自动生成](img/B21361_08_32_PE.png)'
- en: 'Figure 8.32: Complete WavesGameMode lose condition'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32：完整的WavesGameMode失败条件
- en: As you can see, we just repeat the `life` event subscription, remember to create
    an object to represent the player’s base damage point, add a `Life` script to
    it, and drag that one as the player base `Life` reference of the `WavesGameMode`.
    Something interesting here is that we subscribed the same function called `OnPlayerOrBaseDied`
    to both player `Life` and base `Life` `onDeath` events, given that we want the
    same result in both situations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是重复了`life`事件订阅，记得创建一个对象来表示玩家的基础伤害点，并给它添加一个`Life`脚本，然后将它拖动到`WavesGameMode`中的玩家基础`Life`参考。这里有趣的是，我们为玩家`Life`和基础`Life`的`onDeath`事件订阅了同一个名为`OnPlayerOrBaseDied`的函数，因为我们希望在这两种情况下得到相同的结果。
- en: 'Now, let’s keep illustrating this concept by applying it to the managers to
    prevent the Game Mode from checking conditions every frame:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续通过将其应用于经理来阐述这个概念，以防止游戏模式每帧都检查条件：
- en: Add a `UnityEvent` field to `EnemyManager` called `onChanged`. This event will
    be executed whenever an enemy is added or removed from the list.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyManager`中添加一个名为`onChanged`的`UnityEvent`字段。这个事件将在每次将敌人添加到列表或从列表中删除时执行。
- en: Create two functions, `AddEnemy` and `RemoveEnemy`, both receiving a parameter
    of the `Enemy` type. The idea is that instead of `Enemy` adding and removing itself
    from the list directly, it should use these functions.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个函数，`AddEnemy`和`RemoveEnemy`，都接收一个`Enemy`类型的参数。想法是，而不是让`Enemy`直接从列表中添加和删除自己，它应该使用这些函数。
- en: Inside these two functions, invoke the `onChanged` event to inform others that
    the enemies list has been updated. The idea is that anyone who wants to add or
    remove enemies from the list needs to use these functions:![A screenshot of a
    computer code  Description automatically generated with medium confidence](img/B21361_08_33_PE.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个函数内部，调用`onChanged`事件来通知其他人敌人列表已被更新。想法是，任何想要从列表中添加或删除敌人的人都需要使用这些函数：![计算机代码屏幕截图，描述由中等置信度自动生成](img/B21361_08_33_PE.png)
- en: 'Figure 8.33: Calling events when enemies are added or removed'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.33：在添加或删除敌人时调用事件
- en: Here, we have the problem that nothing stops us from bypassing those two functions
    and using the list directly. You can solve that by making the list private and
    exposing it using the `IReadOnlyList` interface. Remember that, this way, the
    list won’t be visible in the editor for debugging purposes.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们面临的问题是没有任何东西阻止我们绕过这两个函数并直接使用列表。你可以通过将列表设为私有并使用`IReadOnlyList`接口暴露它来解决这个问题。记住，这样，列表在编辑器中不可见，便于调试。
- en: 'Change the `Enemy` script to use these functions:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Enemy`脚本更改为使用这些函数：
- en: '![A screen shot of a computer program  Description automatically generated
    with low confidence](img/B21361_08_34_PE.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图，描述自动生成，低置信度](img/B21361_08_34_PE.png)'
- en: 'Figure 8.34: Making the Enemy use the add and remove functions'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34：使敌人使用添加和删除函数
- en: Repeat the same process for `WaveManager` and `WaveSpawner`, create an `onChanged`
    event, and create the `AddWave` and `RemoveWave` functions and call them in `WaveSpawner`
    instead of directly accessing the list. This way, we are sure the event is called
    when necessary as we did with `EnemyManager`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`WaveManager`和`WaveSpawner`重复相同的步骤，创建一个`onChanged`事件，创建`AddWave`和`RemoveWave`函数，并在`WaveSpawner`中调用它们而不是直接访问列表。这样，我们可以确保在必要时调用事件，就像我们对`EnemyManager`所做的那样。
- en: 'Try to solve this step by yourself and then check the solution in the following
    screenshot, starting with `WavesManager`:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试自己解决这个问题，然后检查以下屏幕截图中的解决方案，从`WavesManager`开始：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_08_35_PE.png)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，中等置信度](img/B21361_08_35_PE.png)'
- en: 'Figure 8.35: WavesManager OnChanged event implementation'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.35：WavesManager OnChanged事件实现
- en: 'Also, `WaveSpawner` needed the following changes:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`WaveSpawner`还需要以下更改：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_08_36_PE.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，中等置信度](img/B21361_08_36_PE.png)'
- en: 'Figure 8.36: Implementing the AddWave and RemoveWave functions'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36：实现AddWave和RemoveWave函数
- en: 'In `WavesGameMode`, rename `Update` to `CheckWinCondition` and subscribe this
    function to the `onChanged` event of `EnemyManager` and the `onChanged` event
    of `WavesManager`. The idea is to check for the number of enemies and waves being
    changed only when necessary. Remember to do the subscription to the events in
    the `Start` function due to the Singletons being initialized in `Awake`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`中，将`Update`重命名为`CheckWinCondition`，并将此函数订阅到`EnemyManager`和`WavesManager`的`onChanged`事件。目的是仅在必要时检查敌人数量和波浪的变化。由于单例在`Awake`中初始化，请记住在`Start`函数中进行事件订阅：
- en: '![A screen shot of a computer program  Description automatically generated
    with low confidence](img/B21361_08_37_PE.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图，描述自动生成，低置信度](img/B21361_08_37_PE.png)'
- en: 'Figure 8.37: Checking the win condition when the enemies or waves amount is
    changed'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37：当敌人或波浪数量变化时检查胜利条件
- en: 'Regarding the Visual Scripting version, let’s start checking the lose condition
    with events, first checking some changes needed in the **Life Script Graph**:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，让我们首先通过事件检查失败条件，首先检查**生命脚本图**中需要的一些更改：
- en: '![](img/B21361_08_38_PE.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_08_38_PE.png)'
- en: 'Figure 8.38: Triggering a Custom Event in our Life script graph'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38：在我们的Life脚本图中触发自定义事件
- en: 'First, after destroying the object when life reaches 0, we use the **Trigger
    Custom Event** node, specifying the name of our event is `OnDeath`. This will
    tell anyone waiting for the execution of the `OnDeath` event that it has been
    executed. Remember, this is our **Life Script Graph**. Be sure to call **destroy**
    after triggering the event—while most of the time the order doesn’t matter, given
    that the **destroy** action doesn’t actually happen until the end of the frame,
    sometimes it can cause issues, so better be safe here. In this case, Game Mode
    should listen to the player’s `OnDeath` event, so let’s make the following change
    in our **Game Mode Graph**:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当生命值降至0时销毁对象后，我们使用**触发自定义事件**节点，指定事件名称为`OnDeath`。这将通知任何等待`OnDeath`事件执行的人它已经执行。记住，这是我们**生命脚本图**。确保在触发事件后调用**destroy**——虽然大多数时候顺序并不重要，因为**destroy**动作实际上是在帧末发生的，有时可能会引起问题，所以这里还是小心为妙。在这种情况下，游戏模式应该监听玩家的`OnDeath`事件，所以让我们在我们的**游戏模式图**中进行以下更改：
- en: '![](img/B21361_08_39_PE.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_08_39_PE.png)'
- en: 'Figure 8.39: Listening to the OnDeath event of Player in Visual Scripting'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39：在视觉脚本中监听玩家的OnDeath事件
- en: We used the **Custom Event** node, connecting it to the player reference of
    our GameMode. This way, we are specifying that if that player executes that event,
    we will execute the **Load Scene** node. Remember that the player reference is
    crucial to specify from whom we want to execute the `OnDeath` event, and remember
    that the **Life Visual Graph** will also be present in the enemies and we are
    not interested in them here. Also, remember to remove the `If` node and the condition
    nodes we used previously to detect this – the only `If` our Game Mode will have
    is the one for the win condition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**自定义事件**节点，将其连接到我们的游戏模式的玩家引用。这样，我们指定如果那个玩家执行该事件，我们将执行**加载场景**节点。记住，玩家引用是至关重要的，因为它指定了我们想要从谁那里执行`OnDeath`事件，记住**生命视觉图表**也会出现在敌人中，而我们对此不感兴趣。此外，记得移除我们之前用来检测此情况的`If`节点和条件节点——我们的游戏模式将拥有的唯一`If`是胜利条件。
- en: Essentially, we made any object with the `Life` script have an `OnDeath` event,
    and we made the GameMode listen to the `OnDeath` event of the player specifically.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们让任何使用`Life`脚本的物体都拥有一个`OnDeath`事件，并且让游戏模式专门监听玩家的`OnDeath`事件。
- en: We could also create events for enemies and waves, but that would complicate
    our graphs somewhat, given that we don’t have `WaveManager` or `EnemyManager`
    in the Visual Scripting versions. We could certainly create those to accomplish
    this, but sometimes the point of using Visual Scripting is to create simple logic,
    and these kinds of changes tend to make a graph grow quite a bit.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为敌人和波次创建事件，但这可能会使我们的图表变得有些复杂，因为我们没有在视觉脚本版本中的`WaveManager`或`EnemyManager`。我们当然可以创建这些来完成任务，但有时使用视觉脚本的目的就是创建简单的逻辑，这类改变往往会使得图表变得相当庞大。
- en: Another possible solution is to make the enemy and wave directly inform the
    Game Mode. We could use **Trigger Custom Event** in the enemies and waves, connecting
    that node to the Game Mode, to finally let the Game Mode have a **Custom Event**
    node from which to listen. The issue is that that would violate the correct dependencies
    between our objects; lower-level objects such as enemies and waves shouldn’t communicate
    with higher-level objects such as Game Mode.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是让敌人和波次直接通知游戏模式。我们可以在敌人和波次中使用**触发自定义事件**，将其节点连接到游戏模式，最终让游戏模式拥有一个**自定义事件**节点，从而可以监听。问题是这会违反我们对象之间的正确依赖关系；较低级别的对象，如敌人和波次，不应该与较高级别的对象，如游戏模式，进行通信。
- en: Essentially, Game Mode was supposed to be an overseer. If we apply the solution
    described in the previous paragraph, we won’t be able to have an enemy in another
    scene or game without having a Game Mode. So, for simplicity and code decoupling
    purposes, let’s keep the other conditions as they are—more complex logic such
    as this would probably be handled in C# in full-production projects.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，游戏模式原本应该是一个监管者。如果我们应用前一段描述的解决方案，我们就不可能在另一个场景或游戏中没有游戏模式的情况下拥有敌人。所以，为了简单和代码解耦的目的，让我们保持其他条件不变——更复杂的逻辑可能完全在C#的完整生产项目中处理。
- en: Yes, using events means that we have to write more code than before, and in
    terms of functionality, we didn’t obtain anything new, but in bigger projects,
    managing conditions through `Update` checks will lead to different kinds of problems,
    as previously discussed, such as race conditions and performance issues. Having
    a scalable code base sometimes requires more code, and this is one of those cases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，使用事件意味着我们不得不比以前写更多的代码，从功能上来说，我们没有获得任何新的东西，但在更大的项目中，通过`Update`检查来管理条件会导致之前讨论过的一些问题，例如竞争条件和性能问题。有时，拥有可扩展的代码库需要更多的代码，而这正是其中之一。
- en: Before we finish, something to consider is that Unity events are not the only
    way to create this kind of event communication in Unity; you will find a similar
    approach called **Action**, the native C# version of events, which I recommend
    you look into if you want to see all of the options out there.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，有一点需要考虑的是，Unity事件并不是在Unity中创建此类事件通信的唯一方式；你将发现一个类似的方法称为**Action**，这是事件的本地C#版本，如果你想要查看所有可用的选项，我建议你了解一下。
- en: 'We explored some programming patterns in this chapter, but there are plenty.
    You can learn more about them here: [https://gameprogrammingpatterns.com/](https://gameprogrammingpatterns.com/)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了一些编程模式，但还有很多。你可以在这里了解更多：[https://gameprogrammingpatterns.com/](https://gameprogrammingpatterns.com/)
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we finished an important part of the game: the ending, both
    by victory and by defeat. We discussed a simple but powerful way to separate the
    different layers of responsibilities by using managers created through Singletons,
    to guarantee that there isn’t more than one instance of every kind of manager
    and simplifying the connections between them through static access. Also, we visited
    the concept of events to streamline communication between objects to prevent problems
    and create more meaningful communication between objects.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了游戏的一个重要部分：结局，无论是通过胜利还是失败。我们讨论了一种简单但强大的方法，通过使用单例创建的管理器来分离不同的责任层，以确保每种类型的管理器只有一个实例，并通过静态访问简化它们之间的连接。此外，我们还探讨了事件的概念，以简化对象之间的通信，防止问题并创建更有意义的对象间通信。
- en: With this knowledge, you are now able not only to detect the victory and loss
    conditions of the game but you can also do it in a better-structured way. These
    patterns can be useful to improve our game code in general, and I recommend you
    try to apply them in other relevant scenarios.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些知识，你现在不仅能够检测游戏的胜利和失败条件，而且还能以更结构化的方式进行。这些模式可以用来改进我们的游戏代码，我建议你尝试在其他相关场景中应用它们。
- en: In the next chapter, we are going to start *Section 3*, *Elevating Visuals,
    Effects, and Audio* of the book, where we are going to see different Unity systems
    to improve the graphics and audio aspects of our game, starting by seeing how
    we can create materials to modify aspects of our objects and create shaders with
    Shader Graph.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始书的**第3节**，**提升视觉效果、效果和音频**，我们将探讨不同的Unity系统来改善我们游戏的图形和音频方面，首先看看我们如何创建材料来修改我们对象的一些属性，以及如何使用Shader
    Graph创建着色器。
- en: Learn more on Discord
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过Ask Me Anything（问我任何问题）环节与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
