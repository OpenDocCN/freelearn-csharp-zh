["```cs\nstring text = \"MARCIN\";\nStack<char> chars = new();\nforeach (char c in text) { chars.Push(c); }\nwhile (chars.Stack class is created. In this scenario, the stack can contain only char elements. Then, you iterate through all characters using a foreach loop and insert each character at the top of the stack by calling the Push method. The remaining part of the code consists of a while loop, which is executed until the stack is empty. This condition is checked using the Count property. In each iteration, the top element is removed from the stack (by calling Pop) and written in the console (using the Write static method of the Console class).\nAfter running the code, you will receive the following result:\n\n```", "```cs\n\n Example – Tower of Hanoi\nThe next example is a significantly more complex application of stacks. It is related to the mathematical game *Tower of Hanoi*. The game requires three rods, onto which you can put discs. Each disc has a different size. At the beginning, all discs are placed on the first rod, forming a stack, ordered from the smallest (at the top) to the biggest (at the bottom). It is presented in the following diagram (on the left):\n![Figure 5.3 – ﻿Illustration of the Tower of Hanoi example](img/B18069_05_03.jpg)\n\nFigure 5.3 – Illustration of the Tower of Hanoi example\nThe aim of the game is to `FROM`) `TO`). However, during the whole game, you **cannot place a bigger disc on a smaller one**. Moreover, you **can only move one disc at a time**, and, of course, you **can only take a disc from the top of** **any rod**.\nHow could you move discs between the rods to comply with the aforementioned rules? The problem can be divided into sub-problems:\n\n*   `FROM` to `TO`, without using the `AUXILIARY` rod.\n*   `FROM` to `AUXILIARY`. Then, you move the remaining disc from `FROM` to `TO`. At the end, you move a disc from `AUXILIARY` to `TO`.\n*   `FROM` to `AUXILIARY`, using the mechanism described earlier. The operation involves `TO` as the auxiliary rod. Then, you move the remaining disc from `FROM` to `TO`, and then move two discs from `AUXILIARY` to `TO`, using `FROM` as the auxiliary rod.\n\nAs you can see, you can solve the problem of `FROM` to `AUXILIARY`, using `TO` as the auxiliary rod. Then, you should move the remaining disc from `FROM` to `TO`. At the end, you just need to move *n-1* discs from `AUXILIARY` to the `TO` rod, using `FROM` as the auxiliary rod.\nNow that you know the basic rules, let’s proceed to the code. First, let’s focus on the `Game` class, which contains the logic related to the game:\n\n```", "```cs\n\n The class contains five properties, representing the following:\n\n*   Three rods (`From`, `To`, `Auxiliary`)\n*   The overall number of discs (`DiscsCount`)\n*   The number of performed moves (`MovesCount`)\n\nThe `MoveCompleted` event is declared as well. It is fired after each move to inform that the user interface should be refreshed. Therefore, you can show the proper content, illustrating the current state of the rods.\nApart from the properties and the event, the class also has the following constructor:\n\n```", "```cs\n\n The constructor takes only one parameter, namely the number of discs (`discsCount`), and sets it as a value of the `DiscsCount` property. Then, new instances of the `Stack` class are created, and references to them are stored in the `From`, `To`, and `Auxiliary` properties. At the end, a `for` loop is used to create the necessary number of discs and to add elements to the first stack (`From`), using the `Push` method.\nIt is worth noting that `From`, `To`, and `Auxiliary` stacks only store integer values (`Stack<int>`). Each integer value represents the size of a particular disc. Such data is crucial due to the rules of moving discs between rods.\nOne of the most interesting and important parts of the code is the `MoveAsync` recursive method. It takes four parameters, namely the number of discs and references to three stacks. However, what happens in the `MoveAsync` method? Let’s look inside:\n\n```", "```cs\n\n As `MoveAsync` is called recursively, it is necessary to specify an exit condition to prevent the method from being called infinitely. In this case, the method will not call itself when the value of the `discs` parameter is equal to `0`.\nOtherwise, the `MoveAsync` method is called, but the order of stacks is changed. Then, the element is removed from the stack represented by the second parameter (`from`), and inserted at the top of the stack represented by the third parameter (`to`).\nIn the following lines, the number of moves (`MovesCount`) is incremented and the `MoveCompleted` event is fired. It is responsible for refreshing the user interface. Then, the algorithm stops for 250 milliseconds to show the following steps of the operation in a way well visible to a user.\nAt the end, the `MoveAsync` method is called again, with another configuration of rod order. By calling this method several times, the discs will be moved from the first (`From`) rod to the second (`To`) rod. The operations performed in the `MoveAsync` method are consistent with the description of the problem of moving *n* discs between rods, as explained in the introduction to this example.\nWhen the class with the logic regarding the *Tower of Hanoi* game is created, let’s see how to create a user interface that allows you to present the following moves of the algorithm. Such a task is accomplished by the `Visualization` class:\n\n```", "```cs\n\n It contains three private fields, namely storing a reference to data of the game (`_game`), the number of characters to present a single rod (`_columnSize`), as well as a two-dimensional array with visualization of all rods, shown in the console (`_board`). The constructor takes only one parameter and sets values for all private fields.\nColumn size is calculated using the `GetDiscWidth` auxiliary method:\n\n```", "```cs\npublic void Show(Game game)\n{\n    Console.Clear();\n    if (game.DiscsCount <= 0) { return; }\n    FillEmptyBoard();\n    FillRodOnBoard(1, game.From);\n    FillRodOnBoard(2, game.To);\n    FillRodOnBoard(3, game.Auxiliary);\n    Console.WriteLine(Center(\"FROM\")\n        + Center(\"TO\") + Center(\"AUXILIARY\"));\n    DrawBoard();\n    Console.WriteLine($\"\\nMoves: {game.MovesCount}\");\n    Console.WriteLine($\"Discs: {game.DiscsCount}\");\n}\n```", "```cs\nprivate void FillEmptyBoard()\n{\n    for (int y = 0; y < _board.GetLength(0); y++)\n    {\n        for (int x = 0; x < _board.GetLength(1); x++)\n        {\n            _board[y, x] = ' ';\n        }\n    }\n}\n```", "```cs\nprivate void FillRodOnBoard(int column, Stack<int> stack)\n{\n    int discsCount = _game.DiscsCount;\n    int margin = _columnSize * (column - 1);\n    for (int y = 0; y < stack.Count; y++)\n    {\n        int size = stack.ElementAt(y);\n        int row = discsCount - (stack.Count - y);\n        int columnStart = margin + discsCount - size;\n        int columnEnd = columnStart + GetDiscWidth(size);\n        for (int x = columnStart; x <= columnEnd; x++)\n        {\n            _board[row, x] = '=';\n        }\n    }\n}\n```", "```cs\nprivate string Center(string text)\n{\n    int margin = (_columnSize - text.Length) / 2;\n    return text.PadLeft(margin + text.Length)\n        .PadRight(_columnSize);\n}\n```", "```cs\nprivate void DrawBoard()\n{\n    for (int y = 0; y < _board.GetLength(0); y++)\n    {\n        string line = string.Empty;\n        for (int x = 0; x < _board.GetLength(1); x++)\n        {\n            line += _board[y, x];\n        }\n        Console.WriteLine(line);\n    }\n}\n```", "```cs\nGame game = new(10);\nVisualization vis = new(game);\ngame.MoveCompleted += (s, e) => vis.Show((Game)s!);\nawait game.MoveAsync(game.DiscsCount,\n    Game class is created. The parameter indicates that 10 discs are used. In the next line, you create a new instance of the Visualization class responsible for showing the following steps of the game. You also specify that the Show method is called when the MoveCompleted event is fired. Finally, you call the MoveAsync method to start moving discs between rods.\nYou already added the necessary code to run the *Tower of Hanoi* mathematical game. Let’s launch the application and see it in action! Just after starting the program, you see that all discs are located in the first rod (`FROM`). In the next step, the smallest disc is moved from the top of the first rod (`FROM`) to the top of the third rod (`AUXILIARY`), as shown in the following screenshot:\n![Figure 5.4 – The second step in the Tower of Hanoi example](img/B18069_05_04.jpg)\n\nFigure 5.4 – The second step in the Tower of Hanoi example\nWhile making many other moves in the program, you can see how discs are moved between all three rods. One of the intermediate steps is as follows:\n![Figure 5.5 – One of the intermediate steps in the Tower of Hanoi example](img/B18069_05_05.jpg)\n\nFigure 5.5 – One of the intermediate steps in the Tower of Hanoi example\nWhen the necessary moves are completed, all discs are moved from the first rod (`FROM`) to the second one (`TO`). The final result is presented next:\n![Figure 5.6 – Final step in the Tower of Hanoi example](img/B18069_05_06.jpg)\n\nFigure 5.6 – Final step in the Tower of Hanoi example\nFinally, it is worth mentioning the number of moves necessary to complete the *Tower of Hanoi* game. In the case of 10 discs, the number of moves is 1,023\\. If you use only 3 discs, the number of moves is 7\\. Generally speaking, **the number of moves can be calculated with the formula** **2**n**-1**, where *n* is the number of discs.\nThat’s all! In this section, you learned the first limited access data structure, namely a stack. Now, it is high time that you get to know more about queues.\nQueues\nA **queue** is a data structure that allows you **to add a new element only at the end of the queue** (referred to as an **enqueue** operation) and **to get an element only from the beginning of the queue** (a **dequeue** operation). For this reason, a queue is consistent with the **FIFO** principle, which stands for **First-In First-Out**.\nImagine a queue\nIf you want to better imagine a queue, let’s take a break from learning data structures and algorithms, wear your favorite jacket, and go to a shop in the vicinity. You buy your favorite ice cream, and you see five people waiting for checkout. Oh no... You are the last one, so you need to wait until the first, second, third, fourth, and fifth person pay. These lines in shops can be frustrating! In general, new people stand at the end of the line, and the next person is taken to the checkout from the beginning of the line. No one is allowed to choose a person from the middle and serve them in a different order. The queue data structure operates similarly. You can only add new elements at the end of the queue and remove an element from the beginning of the queue. So, people who come first (first-in) are served at the beginning (first-out).\nThe operation of a queue is presented in the following diagram:\n![Figure 5.7 – ﻿Illustration of a queue](img/B18069_05_07.jpg)\n\nFigure 5.7 – Illustration of a queue\nIt is worth mentioning that a queue is a **recursive data structure**, similar to a stack. This means that **a queue can be either empty or consists of the first element and the rest of the queue, which also forms a queue**. Let’s take a look at the following diagram, where the beginning of the queue is marked with a bold line:\n![Figure 5.8 – A queue as a recursive data structure](img/B18069_05_08.jpg)\n\nFigure 5.8 – A queue as a recursive data structure\nThe queue data structure seems to be very easy to understand, as well as being similar to a stack, apart from the way of removing an element. Does this mean that you can also use a built-in class to use a queue in your programs? Fortunately, yes! The available generic class is `Queue` from the `System.Collections.Generic` namespace.\nWhere can you find more information?\nYou can find content regarding a queue at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1).\nThe `Queue` class contains the following set of methods:\n\n*   `Enqueue` adds an element at the end of the queue\n*   `Dequeue` removes an element from the beginning of the queue and returns it\n*   `Peek` returns an element from the beginning of the queue without removing it\n*   `Clear` removes all elements from the queue\n*   `Contains` checks whether the queue contains the given element\n\nThe `Queue` class also contains the `Count` property, which returns the total number of elements located in the queue. It can be used to check whether the queue is empty.\nWhat about the performance?\nIt is worth mentioning that the `Enqueue` method is either an *O(1)* operation, if the internal array does not need to be reallocated, or *O(n)* otherwise, where *n* is the number of elements in the queue. Both `Dequeue` and `Peek` are *O(1)* operations.\nThe great performance results are supported by a very easy application of this data structure, as shown in the following part of the code:\n\n```", "```cs\n\n Here, you create a new list and a queue containing only integer values. Then, you add all elements from the list to the queue, using the `Enqueue` method. At the end, you use a `while` loop to dequeue all the elements, using the `Dequeue` method.\nIt is worth noting that in the third line, you do not use the lambda expression and simply use the name of the method. Of course, you can use the following form instead:\n\n```", "```cs\npublic class IncomingCall\n{\n    public int Id { get; set; }\n    public int ClientId { get; set; }\n    public DateTime CallTime { get; set; }\n    public DateTime? AnswerTime { get; set; }\n    public DateTime? EndTime { get; set; }\n    public string? Consultant { get; set; }\n}\n```", "```cs\npublic class CallCenter\n{\n    private int _counter = 0;\n    public Queue<IncomingCall> Calls { get; private set; }\n    public CallCenter() =>\n        Calls = new Queue<IncomingCall>();\n}\n```", "```cs\npublic IncomingCall Call(int clientId)\n{\n    IncomingCall call = new()\n    {\n        Id = ++_counter,\n        ClientId = clientId,\n        CallTime = DateTime.Now\n    };\n    Calls.Enqueue(call);\n    return call;\n}\n```", "```cs\npublic IncomingCall? Answer(string consultant)\n{\n    if (!AreWaitingCalls()) { return null; }\n    IncomingCall call = Calls.Dequeue();\n    call.Consultant = consultant;\n    call.AnswerTime = DateTime.Now;\n    return call;\n}\n```", "```cs\npublic void End(IncomingCall call)\n    => call.EndTime = DateTime.Now;\n```", "```cs\npublic bool Program.cs file and its code:\n\n```", "```cs\n\n You create a new instance of the `Random` class (for getting random numbers), as well as an instance of the `CallCenter` class. Then, you simulate making a few calls by clients, namely with the following identifiers: `1234`, `5678`, `1468`, and `9641`. The most interesting part of the code is located in the `while` loop, which is executed until there are no waiting calls in the queue. Within the loop, the consultant answers the call (using the `Answer` method) and a log is generated (using the `Log` auxiliary method). Then, you wait for a random number of milliseconds (between `1000` and `10000`) to simulate the various lengths of a call. When this has elapsed, the call ends (by calling the `End` method), and a proper log is generated.\nThe last part of the code necessary for this example is the `Log` method:\n\n```", "```cs\n\n When you run the example, you will receive a result similar to the following:\n\n```", "```cs\n\n Congratulations! You just completed the first example regarding a queue data structure. If you want to learn more about the thread-safe version of the queue-related class, let’s proceed to the next example.\nExample – call center with many consultants\nThe example shown in the preceding section was intentionally simplified to make understanding a queue much simpler. However, it is high time you make it more related to real-world problems. In this section, you will see how to expand it to support many consultants, as shown in the following diagram:\n![Figure 5.10 – ﻿Illustration of the call center with many consultants example](img/B18069_05_10.jpg)\n\nFigure 5.10 – Illustration of the call center with many consultants example\nWhat is important is that both clients and consultants operate at the same time. If there are more incoming calls than available consultants, a new call will be added to the queue and will wait until there is a consultant who can answer the call. If there are too many consultants and few calls, the consultants will wait for a call. To perform this task, you create a few threads, which access the queue. Therefore, you use a thread-safe version of the queue, namely the `ConcurrentQueue` class.\nLet’s take a look at the code! First, you need to declare an `IncomingCall` class, the code of which is exactly the same as in the previous example. Various modifications are necessary in the `CallCenter` class, as presented next:\n\n```", "```cs\n\n As the `Enqueue` method is available in both the `Queue` and `ConcurrentQueue` classes, no changes are necessary in the `Call` method.\nHowever, the `Dequeue` method does not exist in `ConcurrentQueue`. For this reason, you need to modify the `Answer` method to use the `TryDequeue` method. It returns a value indicating whether the element is removed from the queue. The removed element is returned using the `out` parameter, as shown next:\n\n```", "```cs\n\n You can also slightly modify the `AreWaitingCalls` method to use the `IsEmpty` property instead of `Count`, presented as follows:\n\n```", "```cs\nRandom random = new();\nCallCenter center = new();\nParallel.Invoke(\n  () => Clients(center),\n  () => Consultant(center, \"Marcin\", ConsoleColor.Red),\n  () => Consultant(center, \"James\", ConsoleColor.Yellow),\n  () => CallCenter instance, you start execution of four actions, namely representing clients and three consultants, using the Invoke static method of the Parallel class from the System.Threading.Tasks namespace. The lambda expressions are used to specify methods that are called, namely Clients for client-related operations and Consultant for consultant-related tasks. You also specify additional parameters, such as a name and a color for a given consultant.\nThe `Clients` method represents operations performed cyclically by many clients. Its code is shown in the following block:\n\n```", "```cs\n\n Within the `while` loop, you get a random number as an identifier of a client (`clientId`), and the `Call` method is called. The client identifier is logged, together with the number of waiting calls. At the end, the client-related thread is suspended for a random number of milliseconds in the range between 500 ms and 2,000 ms, to simulate the delay between another call made by the next client.\nThe following method is named `Consultant` and is executed on a separate thread for each consultant. The method takes three parameters, namely an instance of `CallCenter`, as well as a name and color for the consultant. The code is as follows:\n\n```", "```cs\n\n Within the `while` loop, the consultant waits for a random period, between 0.5 and 1 second. Then, they try to answer the first waiting call, using the `Answer` method. If there are no waiting calls, you skip to the next iteration. Otherwise, the log is presented in a color of the current consultant. Then, the thread is suspended for a random period of time between 1 and 10 seconds. After this time, the consultant ends the call, which is indicated by calling the `End` method, and a log is generated.\nThe last method is named `Log` and is similar to the previous example:\n\n```", "```cs\n\n When you run the program and wait for some time, you will receive a result similar to the one shown in the following screenshot:\n![Figure 5.11 – ﻿Screenshot of the call center with many consultants example](img/B18069_05_11.jpg)\n\nFigure 5.11 – Screenshot of the call center with many consultants example\nYou just completed two examples representing the application of a queue in the case of a call center scenario. Are you already a queue master?\nTry to modify parameters on your own\nIt is a good idea to modify various parameters of the program, such as the number of consultants, as well as delay times, especially the delay between following calls performed by clients. Then, you will see how the algorithm works in the case when there are too many clients, as well as too many or too few consultants.\nHowever, how can you handle clients with priority support? In the current solution, they wait in the same queue as clients with the standard support plan. Do you need to create two queues and first take clients from the prioritized queue? If so, what should happen if you introduce another support plan? Do you need to add another queue and introduce such modifications in the code? Fortunately, no! You can use another data structure, namely a priority queue, as explained in detail in the following section.\nPriority queues\nA `0`, while lower priority is specified by `1`, `2`, `3`, and so on.\nImagine a priority queue\nIf you want to better visualize a priority queue, close your eyes for a moment and imagine yourself going on the greatest vacation of your life. All passengers are already lining up at the gate, including you, but it turns out that right next to it, there is a much shorter queue for people who have a gold airline card. There are only 3 people in that line, and in yours there are over 100\\. These 3 people will be served first, and only then will the service of your queue begin. Well, that’s how a priority queue works! You first serve all the highest priority items in the order they were added to the priority queue. Then, you return all lower priority items, also in the order they were added to the priority queue. Then, you take all items with an even lower priority, and so on, until all priorities are properly handled. And now the dream about holidays is over, it’s time to get back to further learning data structures and algorithms!\nA diagram of a priority queue is presented next:\n![Figure 5.12 – ﻿Illustration of a priority queue](img/B18069_05_12.jpg)\n\nFigure 5.12 – Illustration of a priority queue\nLet’s analyze the diagram. First, the priority queue contains two elements with the same priority (equal to `1`), namely `Marcin` (first) and `Lily` (second). Then, `Mary` is added with the lowest priority (`2`), which means that this element is placed at the end of the queue. In the next step, `John` is added with the highest priority (`0`), so it is added at the beginning of the priority queue. The third column presents the addition of `Emily` with a priority equal to `1` -  the same as `Marcin` and `Lily`. As `Emily` is added last, it is added after `Lily`. According to the aforementioned rules, you add the following elements - namely, `Sarah` with a priority set to `2` and `Luke` with a priority equal to `1`. The final order is shown on the right-hand side of the preceding diagram.\nOf course, it is possible to implement a priority queue `PriorityQueue` from the `System.Collections.Generic` namespace. The mentioned class requires you to specify two types, namely for the stored data and for the priority. The class contains some useful methods, such as the following:\n\n*   `Enqueue` adds an element to the priority queue\n*   `Dequeue` removes an element from the beginning and returns it\n*   `Clear` removes all elements from the priority queue\n*   `Peek` returns an element from the beginning of the queue without removing it\n\nYou can also get the number of elements in the queue using the `Count` property. The class contains a set of other methods as well - for example, `TryDequeue` and `TryPeek`.\nWhere can you find more information?\nYou can find content regarding a priority queue at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2).\nTo make your horizons even broader, you will learn how to use `OptimizedPriorityQueue`. More information about this package is available at [https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue).\nHow to install a NuGet package?\nDo you know how you can add a NuGet package to your project? If not, select **Manage NuGet Packages** from the context menu of the project node in the **Solution Explorer** window. Then, choose the **Browse** tab in the opened window and type the name of the package in the **Search** box. Click on the name of the package and press **Install**. Confirm this operation and wait until the installation is ready.\nWhile the package is being installed, do you know that you can also be an author of a NuGet package that can be later used by developers from various regions of the world? If you create something great, please let me know! In the meantime, please keep in mind that you always should comply with the license terms of particular packages, and you should not fully trust all available packages, especially those with a smaller number of downloads. However, NuGet packages are a nice feature that can significantly simplify and speed up your work.\nThe `OptimizedPriorityQueue` library simplifies the application of a priority queue. Within it, the `SimplePriorityQueue` generic class is available, which contains some useful methods, such as the following:\n\n*   `Enqueue` adds an element to the priority queue\n*   `Dequeue` removes an element from the beginning of the queue and returns it\n*   `GetPriority` returns the priority of the element\n*   `UpdatePriority` updates the priority of the element\n*   `Contains` checks whether the element exists in the priority queue\n*   `Clear` removes all elements from the priority queue\n\nYou can get the number of elements currently available in the priority queue using the `Count` property. If you want to get an element from the beginning of the priority queue without removing it, you can use the `First` property. Moreover, the class contains a set of other methods, such as `TryDequeue` and `TryRemove`. As you can see, the names of some members of the class are even the same, as in the case of the `PriorityQueue` built-in class. Thus, you can easily change one implementation to another and check the impact of the implementation on the results or the performance of your solution.\nWhat about the performance?\nBoth `Enqueue` and `Dequeue` methods are *O(log* *n)* operations.\nIf you want to see in action the priority queue depicted in the preceding diagram, you can use the following part of the code:\n\n```", "```cs\n\n At the beginning, you create a new priority queue containing only `string` values. Then, you add all elements in the correct order, together with specifying their priority, using the `Enqueue` method. At the end, you use a `while` loop to dequeue all the elements, using the `Dequeue` method. Pretty simple and easy to understand, isn’t it?\nWhen you run the code, you will get the following result:\n\n```", "```cs\n\n After this short introduction to the topic of priority queues, let’s proceed to the example of a call center with priority support, which is described next.\nExample – call center with priority support\nAs an example of a priority queue, let’s present a simple approach to the call center solution, where there are many clients (with different identifiers), and only one consultant who answers waiting calls, first from clients with the priority support plan, and then from clients with the standard support plan.\nThis scenario is presented in the following diagram. Calls with standard priority are marked with `–`, while calls with priority support are indicated by `∆`, as follows:\n![Figure 5.13 – ﻿Illustration of the call center with priority support example](img/B18069_05_13.jpg)\n\nFigure 5.13 – Illustration of the call center with priority support example\nThe priority queue contains only three elements, which will be served in the following order: `#5678` (the priority support), `#1234`, and `#1468`. However, the call from the client with the `#9641` identifier causes the order to change to `#5678`, `#9641` (due to priority support), `#1234`, and `#1468`.\nIt is high time to write some code! Let’s proceed to the implementation of the `IncomingCall` class:\n\n```", "```cs\n\n Here, there is only one change in comparison to the previously presented scenario of the simple call center application - namely, the `IsPriority` property is added. It indicates whether the current call has priority (`true`) or standard support (`false`).\nSome modifications are also necessary for the `CallCenter` class, where a type of the `Calls` property is changed to `SimplePriorityQueue<IncomingCall>`, as shown next:\n\n```", "```cs\n\n The following changes are necessary for the `Call` method:\n\n```", "```cs\n\n Here, a value of the `IsPriority` property is set using the parameter. Moreover, while calling the `Enqueue` method, two parameters are used, not only the value of the element (an instance of the `IncomingCall` class), but also an integer value representing the priority, namely `0` in the case of priority support, or `1` otherwise.\nNo more changes are necessary in the methods of the `CallCenter` class, namely in `Answer`, `End`, and `AreWaitingCalls`, which are shown next for your convenience:\n\n```", "```cs\nRandom random = new();\nCallCenter center = new();\ncenter.Call(1234, false);\ncenter.Call(5678, true);\ncenter.Call(1468, false);\ncenter.Call(9641, true);\nwhile (center.AreWaitingCalls())\n{\n    IncomingCall call = center.Answer(\"Marcin\")!;\n    Log($\"Call #{call.Id} from client #{call.ClientId} is\n        answered by {call.Consultant}.\", call.IsPriority);\n    await Task.Delay(random.Next(1000, 10000));\n    center.End(call);\n    Log($\"Call #{call.Id} from client #{call.ClientId} is\n        ended by {call.Consultant}.\", call.IsPriority);\n}\nvoid Log(string text, bool isPriority)\n{\n    Console.ForegroundColor = isPriority\n        ? ConsoleColor.Red : ConsoleColor.Gray;\n    Console.WriteLine($\"[{DateTime.Now:HH:mm:ss}] {text}\");\n    Console.ResetColor();\n}\n```", "```cs\npublic class CircularQueue<T>(int size)\n    where T : struct\n{\n    private readonly T[] _items = new T[size];\n    private int _front = -1;\n    private int _rear = -1;\n    private int _count = 0;\n    public int Count { get { return _count; } }\n}\n```", "```cs\npublic bool Enqueue(T item)\n{\n    if (_count == _items.Length) { return false; }\n    if (_front < 0) { _front = _rear = 0; }\n    else { _rear = ++_rear % _items.Length; }\n    _items[_rear] = item;\n    _count++;\n    return true;\n}\n```", "```cs\npublic T? Dequeue()\n{\n    if (_count == 0) { return null; }\n    T result = _items[_front];\n    if (_front == _rear) { _front = _rear = -1; }\n    else { _front = ++_front % _items.Length; }\n    _count--;\n    return result;\n}\n```", "```cs\npublic T? Peek()\n{\n    if (_count == 0) { return null; }\n    return _items[_front];\n}\n```", "```cs\nCircularQueue<int> queue = new(8);\nqueue.Enqueue(2);\nqueue.Enqueue(-4);\nqueue.Enqueue(1);\nqueue.Enqueue(8);\nqueue.Enqueue(5);\nint item = queue.Dequeue();\nConsole.WriteLine(item);\n```", "```cs\nusing QueueItem = (System.DateTime StartedAt,\n    System.ConsoleColor Color);\nconst int rideSeconds = 10;\nRandom random = new();\nCircularQueue<QueueItem> queue = new(12);\nConsoleColor color = ConsoleColor.Black;\n```", "```cs\nwhile (true)\n{\n    while (queue.Peek() != null)\n    {\n        QueueItem item = queue.Peek()!.Value;\n        TimeSpan elapsed = DateTime.Now - item.StartedAt;\n        if (elapsed.TotalSeconds < rideSeconds) { break; }\n        queue.Dequeue();\n        Log($\"> Exits\\tTotal: {queue.Count}\", item.Color);\n    }\n    bool isNew = random.Next(3) == 1;\n    if (isNew)\n    {\n        color = color == ConsoleColor.White\n            ? ConsoleColor.DarkBlue\n            : (ConsoleColor)(((int)color) + 1);\n        if (queue.Enqueue((DateTime.Now, color)))\n        {\n            Log($\"< Enters\\tTotal: {queue.Count}\", color);\n        }\n        else\n        {\n            Log($\"! Not allowed\\tTotal: {queue.Count}\",\n                ConsoleColor.DarkGray);\n        }\n    }\n    await Task.Delay(500);\n}\n```", "```cs\nvoid Log(string text, ConsoleColor color)\n{\n    Console.ForegroundColor = color;\n    Console.WriteLine($\"{DateTime.Now:HH:mm:ss} {text}\");\n    Console.ResetColor();\n}\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]