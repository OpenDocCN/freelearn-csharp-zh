<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract Away Problems</h1>
                
            
            <article>
                
<p class="calibre2">These days, it is quite easy to find resources on the internet to integrate into your application. Many provide functionality that would be perfectly suited to any number of applications. After all, why spend time reinventing the wheel when someone else has already done the bulk of the work for you?</p>
<p class="calibre2">In this chapter, we will gain an understanding of:</p>
<ul class="calibre7">
<li class="calibre8">Abstracting a Gravatar service</li>
<li class="calibre8">Extending the repository pattern</li>
<li class="calibre8">Using a generic repository and Entity Framework</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstracting away problems</h1>
                
            
            <article>
                
<p class="calibre2">There is an abundance of utilities and libraries these days to help make a full-featured application. It can be quite easy to integrate these third-party systems within your application. At times, however, you may need to replace one third-party library with another. Alternatively, you may find yourself relying on the implementation that a third-party system provides, only to find that the implementation has changed with a later update. How can you avoid these potential problems?</p>
<p class="calibre2">Creating a dependency on code that is outside your control can create problems for you in the future. If a change is introduced in a library that you depend on, it could potentially break your system. Or, if your requirements change and the system no longer fits your specific needs you may have to rewrite large portions of your application.</p>
<p class="calibre2">Don't depend directly on any third-party system. Abstract away the details so that your application depends only on an interface that you define. If you define the interface and expose only the functionality that you need, it can become trivial to make changes when they are required. Changes could include minor updates or replacing whole libraries. You want these changes to have minimal impact on the rest of your application.</p>
<div class="packt_tip">
<p class="calibre36">Don't rely on third-party implementations; focus on test driving your code.</p>
</div>
<p class="calibre2">While developing an application with Test-Driven Development in mind, it can often be tempting to test third-party software. While it is important to ensure that any third-party library or utility works well when integrated into your system, it is best to focus on the behavior of your system. Ensure that your system behaves well with the functionality that you wish to expose.</p>
<p class="calibre2">This means that you should handle the <em class="calibre12">happy path</em> as well as any possible <em class="calibre12">exceptions</em> that may be thrown. Gracefully recovering from an error that crops up will allow your application to continue to function in the event that a third-party service is not functioning as you expect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Gravatar</h1>
                
            
            <article>
                
<p class="calibre2">The Speaker Meet application uses Gravatar to display speaker, community, and conference avatar images. Gravatar is an online service that associates an email address with an image. Users can create an account and add an image that they wish to be shown by any service that requests their image. The image is retrieved from the Gravatar service by creating an MD5 hash of the user's email address and requesting an image from Gravatar by supplying the hashed value. By relying on the hashed value, the user's email address is not exposed.</p>
<p class="calibre2">The Gravatar service allows the consumer to supply optional parameters to the HTTP call in order to request a specific size, rating, or default image if none is found. Some of these options include:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">s</strong>: The requested size of the image; by default, this is 80 x 80 pixel</li>
<li class="calibre8"><strong class="calibre1">d</strong>: The default image if none is found; options include 404, <strong class="calibre1">mm</strong> <span>(<strong class="calibre1">mystery-man</strong>) </span>, identicon, and so on</li>
<li class="calibre8"><strong class="calibre1">f</strong>: Force default; always return the default icon, even if an image is found</li>
<li class="calibre8"><strong class="calibre1">r</strong>: Rating; users can label their image as G, PG, R, and X</li>
</ul>
<p class="calibre2">By supplying these values, you have some control over the size and types of image you wish to display within your application. The Speaker Meet application relies on the default offerings from Gravatar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting with an interface</h1>
                
            
            <article>
                
<p class="calibre2">Looking at the Gravatar site, it appears that there a number of options available. In order to shield the rest of the application, the functionality of Gravatar will be exposed through a class contained within the Speaker Meet application. This functionality will first be defined by an interface.</p>
<p class="calibre2">The desired interface might look something like this:</p>
<pre class="calibre19">  public interface IGravatarService<br class="title-page-name"/>  {<br class="title-page-name"/>    string GetGravatar(string emailAddress);<br class="title-page-name"/>    string GetGravatar(string emailAddress, int size);<br class="title-page-name"/>    string GetGravatar(string emailAddress, int size, string rating);<br class="title-page-name"/>    string GetGravatar(string emailAddress, int size, string rating, <br class="title-page-name"/>    string imageType);<br class="title-page-name"/>  }</pre>
<p class="calibre2">To get started, you must first write some tests. Remember, you should not write a line of production code without a failing unit test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a test version of the interface</h1>
                
            
            <article>
                
<p class="calibre2">In order to create an interface named <kbd class="calibre11">IGravatarService</kbd>, there first must be a need within the application. Create a test within a <kbd class="calibre11">SpeakerServiceTests</kbd> <kbd class="calibre11">Get</kbd> class entitled <kbd class="calibre11">ItTakesGravatarService</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItTakesGravatarService()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var fakeGravatarService = new FakeGravatarService();<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository, fakeGravatarService);           <br class="title-page-name"/>}</pre>
<p class="calibre2">This will cause a compilation error. Create an <kbd class="calibre11">IGravatarService</kbd> and modify the constructor of the <kbd class="calibre11">SpeakerService</kbd> so that this is a parameter.</p>
<p class="calibre2">Interface:</p>
<pre class="calibre19">public interface IGravatarService<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre11">SpeakerService</kbd> method:</p>
<pre class="calibre19"><br class="title-page-name"/>public SpeakerService(IRepository repository, IGravatarService gravatarService)<br class="title-page-name"/>{<br class="title-page-name"/>  _repository = repository;<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to get the tests to compile, create a <kbd class="calibre11">FakeGravatarService</kbd> that can be supplied to the <kbd class="calibre11">SpeakerService</kbd> under test. Remember, you're not testing the <kbd class="calibre11">FakeGravatarService</kbd>, merely that the <kbd class="calibre11">SpeakerService</kbd> accepts an <kbd class="calibre11">IGravatarService</kbd> instance.</p>
<p class="calibre2">Now, ensure that the <kbd class="calibre11">FakeGravatarServiceGetGravatar</kbd> method is called when an individual <em class="calibre12">Speaker</em> is requested.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsGravatarService()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository);<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository, _fakeGravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  service.Get(expectedSpeaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(_fakeGravatarService.GetGravatarCalled);<br class="title-page-name"/>}</pre>
<p class="calibre2">Modify the interface to add a <kbd class="calibre11">GetGravatar</kbd> method:</p>
<pre class="calibre19">public interface IGravatarService<br class="title-page-name"/>{<br class="title-page-name"/>  void GetGravatar();<br class="title-page-name"/>}</pre>
<p class="calibre2">And implement this method in the <kbd class="calibre11">FakeGravatarService.</kbd> This is similar to the <kbd class="calibre11">GetCalled</kbd> check of the <kbd class="calibre11">FakeRepository</kbd> from <a target="_blank" href="part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 7</a>, <em class="calibre12">Test Driving C# Applications</em>:</p>
<pre class="calibre19">public class FakeGravatarService : IGravatarService<br class="title-page-name"/>{<br class="title-page-name"/>  public bool GetGravatarCalled { get; set; }<br class="title-page-name"/><br class="title-page-name"/>  public void GetGravatar()<br class="title-page-name"/>  {<br class="title-page-name"/>    GetGravatarCalled = true;<br class="title-page-name"/>  } <br class="title-page-name"/>}</pre>
<p class="calibre2">Next, ensure that the <kbd class="calibre11">GetGravatar</kbd> function is executed when the <kbd class="calibre11">SpeakerService</kbd> <kbd class="calibre11">Get(id)</kbd> is called:</p>
<pre class="calibre19">private readonly IRepository _repository;<br class="title-page-name"/>private readonly IGravatarService _gravatarService;<br class="title-page-name"/><br class="title-page-name"/>public SpeakerService(IRepository repository, IGravatarService gravatarService)<br class="title-page-name"/>{<br class="title-page-name"/>  _repository = repository;<br class="title-page-name"/>  _gravatarService = gravatarService;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public Models.SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null || speaker.IsDeleted)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  var gravatar = _gravatarService.GetGravatar();<br class="title-page-name"/><br class="title-page-name"/>  return new Models.SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">The test should now pass. However, the <kbd class="calibre11">FakeGravatarService</kbd> isn't providing any real value at the moment. The <kbd class="calibre11">GetGravatar</kbd> method should be executed with a provided email address:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsGravatarServiceWithEmail()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository, emailAddress: "example@test.com");<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository, _fakeGravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  service.Get(expectedSpeaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(_fakeGravatarService.WithEmailCalled);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.EmailAddress, _fakeGravatarService.CalledWith);<br class="title-page-name"/>}</pre>
<p class="calibre2">You will need to modify the <kbd class="calibre11">SpeakerFactory</kbd> to accept an email address and the <kbd class="calibre11">Speaker</kbd> model class to house an email address property.</p>
<p class="calibre2">Modify the <kbd class="calibre11">GetGravatar</kbd> method in the <kbd class="calibre11">FakeGravatarService</kbd> and the <kbd class="calibre11">IGravatarService</kbd> interface to accept a string <kbd class="calibre11">emailAddress</kbd>. Make sure you set the <kbd class="calibre11">CalledWith</kbd> property when the <kbd class="calibre11">GetGravatar</kbd> is executed:</p>
<pre class="calibre19">public string CalledWith { get; set; }<br class="title-page-name"/><br class="title-page-name"/>public void GetGravatar(string emailAddress)<br class="title-page-name"/>{<br class="title-page-name"/>  GetGravatarCalled = true;<br class="title-page-name"/>  CalledWith = emailAddress;<br class="title-page-name"/>}</pre>
<p class="calibre2">And ensure the <kbd class="calibre11">GetGravatar</kbd> method is called with the speaker's email address:</p>
<pre class="calibre19">public Models.SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null || speaker.IsDeleted)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  var gravatar = _gravatarService.GetGravatar(speaker.EmailAddress);<br class="title-page-name"/><br class="title-page-name"/>  return new Models.SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, set the return value of the <kbd class="calibre11">GetGravatar</kbd> method to a new property on the <kbd class="calibre11">SpeakerDetail</kbd> object <kbd class="calibre11">Gravatar</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenGravatarServiceThenItSetsGravatar()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository);<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository, <br class="title-page-name"/>   _fakeGravatarService);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var actualSpeaker = service.Get(expectedSpeaker.Id);<br class="title-page-name"/>  var expectedGravatar = <br class="title-page-name"/>   _fakeGravatarService.GetGravatar(expectedSpeaker.EmailAddress);<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(_fakeGravatarService.WithEmailCalled);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Id, actualSpeaker.Id);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Name, actualSpeaker.Name);<br class="title-page-name"/>  Assert.Equal(expectedGravatar, actualSpeaker.Gravatar);<br class="title-page-name"/>}</pre>
<p class="calibre2">You will need to modify the <kbd class="calibre11">FakeGravatarService</kbd> and its interface, and the <kbd class="calibre11">SpeakerService</kbd> <kbd class="calibre11">Get</kbd> method to return a string, and the <kbd class="calibre11">SpeakerDetail</kbd> class to add a <kbd class="calibre11">Gravatar</kbd> property:</p>
<pre class="calibre19">public string GetGravatar(string emailAddress)<br class="title-page-name"/>{<br class="title-page-name"/>  WithEmailCalled = true;<br class="title-page-name"/>  CalledWith = emailAddress;<br class="title-page-name"/><br class="title-page-name"/>  return System.Reflection.MethodBase.GetCurrentMethod().Name;<br class="title-page-name"/>}</pre>
<p class="calibre2">The return value of the <kbd class="calibre11">GetGravatar</kbd> method doesn't matter, so long as it is a known value. Remember, you're not testing that the <kbd class="calibre11">FakeGravatarService</kbd> returns a valid Gravatar image URL, just that the method returns something and that the return value is set to the <kbd class="calibre11">Gravatar</kbd> property on the <kbd class="calibre11">SpeakerDetail</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the production version of the interface</h1>
                
            
            <article>
                
<p class="calibre2">So far, an <kbd class="calibre11">IGravatarService</kbd> interface has been created with one method, <kbd class="calibre11">GetGravatar</kbd>. There are a number of options available to interact with Gravatar. You could choose to write your own methods to communicate directly with its public API. The Speaker Meet application uses one of the available <kbd class="calibre11">NuGet</kbd> packages, <kbd class="calibre11">GravatarHelper.NetStandard</kbd>.</p>
<p class="calibre2">Install the latest version of <kbd class="calibre11">GravatarHelper.NetStandard</kbd> through <kbd class="calibre11">NuGet</kbd> in order to follow along.</p>
<p class="calibre2">While reviewing the Gravatar website, it appears that they offer a variety of optional parameters. To grow the <kbd class="calibre11">IGravatarService</kbd> interface and its implementation, create a new test class, <kbd class="calibre11">GetGravatar</kbd>:</p>
<pre class="calibre19">public class GetGravatar<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Now test that the <kbd class="calibre11">GravatarService</kbd> exists:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  var gravatarService = new GravatarService();<br class="title-page-name"/>}</pre>
<p class="calibre2">Make this test pass by creating a <kbd class="calibre11">GravatarService</kbd> class in the same location as the <kbd class="calibre11">SpeakerService</kbd>:</p>
<pre class="calibre19">namespace SpeakerMeet.Api.Services<br class="title-page-name"/>{<br class="title-page-name"/>  public class GravatarService<br class="title-page-name"/>  {}<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, ensure that the <kbd class="calibre11">GravatarService</kbd> implements the <kbd class="calibre11">IGravatarInterface</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItImplementsIGravatarInterface()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var gravatarService = new GravatarService();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IGravatarService&gt;(gravatarService);<br class="title-page-name"/>}</pre>
<p class="calibre2">From the previous set of tests, a <kbd class="calibre11">GetGravatar</kbd> method has already been defined within the interface. Make the test pass by implementing the interface:</p>
<pre class="calibre19">public class GravatarService : IGravatarService<br class="title-page-name"/>{<br class="title-page-name"/>  public string GetGravatar(string emailAddress)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new System.NotImplementedException();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Verify that the <kbd class="calibre11">GetGravatar</kbd> method exists with a new test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasGetGravatarMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IGravatarService gravatarService = new GravatarService();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  gravatarService.GetGravatar("example@test.com");<br class="title-page-name"/>}</pre>
<p class="calibre2">Allow this test to pass by returning an empty string:</p>
<pre class="calibre19">public string GetGravatar(string emailAddress)<br class="title-page-name"/>{<br class="title-page-name"/>  return string.Empty;<br class="title-page-name"/>}</pre>
<p class="calibre2">The following tests are classified as <em class="calibre12">integration tests</em> as they're testing how the Speaker Meet application interacts with a third-party system. Decorate the class as such:</p>
<pre class="calibre19">[Trait("Category", "Integration")]<br class="title-page-name"/>public class GetGravatar</pre>
<p class="calibre2">Many test runners will allow you to conditionally run or exclude these tests based on trait categories. Once the integration tests are defined and known to run successfully, you may choose to ignore or disable them on change or only run them before check-in.</p>
<p class="calibre2">Now, test that the Gravatar service returns a known value when an email address is supplied. If you have a Gravatar account, feel free to supply your own email address and test for your Gravatar URL:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenEmailAddressThenGravatarReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IGravatarService gravatarService = new GravatarService();<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  var actual = gravatarService.GetGravatar("example@test.com");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("http://www.gravatar.com/avatar/29e3f53ee49fae541ee0f48fb712c231", actual);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, make this test pass by calling the static method supplied by the <kbd class="calibre11">GravatarHelper</kbd>:</p>
<pre class="calibre19">public string GetGravatar(string emailAddress)<br class="title-page-name"/>{<br class="title-page-name"/>  return Gravatar.GetGravatarImageUrl(emailAddress);<br class="title-page-name"/>}</pre>
<p class="calibre2">The test should now pass. You can see how the implementation has been hidden from the rest of the application. The interface was designed out of necessity through a series of tests in the <kbd class="calibre11">SpeakerService</kbd>.</p>
<p class="calibre2">So, why not just call the <kbd class="calibre11">GravatarHelper</kbd> methods directly from the <kbd class="calibre11">SpeakerService</kbd> and elsewhere? Remember, you shouldn't rely on third-party implementations. If the <kbd class="calibre11">GravatarHelper</kbd> is changed or swapped out for something else entirely, then any class that is calling it directly may need to change. By using an interface and a façade, the only class that would potentially need to change is the <kbd class="calibre11">GravatarService</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Future planning</h1>
                
            
            <article>
                
<p class="calibre2">Future planning can be bad. If you're writing code now in anticipation of future problems, you could be wasting effort. Don't write code you don't need. This could add complexity that can slow development.</p>
<p class="calibre2">Remember the term <strong class="calibre1">YAGNI</strong> (<strong class="calibre1">you ain't gonna need it</strong>) as this applies to any code written without an immediate need. The additional <kbd class="calibre11">GravatarService</kbd> methods previously, could be used as an illustration of exactly that. Of the examples provided so far, none require the additional methods that were just created. If for some reason the implementation of the <kbd class="calibre11">GravatarHelper</kbd> changes<em class="calibre12">,</em> the code that has already been written may need to change. If it is not currently being used, this is a waste of effort.</p>
<p class="calibre2">So, where does future planning start and good abstraction end? Abstract away third-party systems. Only expose methods and functionalities that are an immediate need. Minimize the pain of change by shielding the rest of the application from the details of any third-party system. That includes things such as the .NET Framework and ORMs such as Entity Framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstracting the data layer</h1>
                
            
            <article>
                
<p class="calibre2">The data layer abstraction has already begun with the implementation of a repository pattern. In this section, we will work to create a valid abstraction for connecting to an Entity Framework. After we can communicate with the Entity Framework, we will then focus on making the repository more generic and able to work with multiple data models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extending the repository pattern</h1>
                
            
            <article>
                
<p class="calibre2">The first step in creating a valid data layer abstraction is to make sure CRUD has been handled. <strong class="calibre1">CRUD</strong> (<strong class="calibre1">Create</strong>, <strong class="calibre1">Read</strong>, <strong class="calibre1">Update</strong>, and <strong class="calibre1">Delete</strong>) are the basic operations that can be performed on any dataset. The <kbd class="calibre11">IRepository</kbd> does not yet provide access to all of these capabilities so we will begin by extending it.</p>
<p class="calibre2">First create a folder to contain the tests for a <kbd class="calibre11">SpeakerRepository</kbd>. The folder should be named in line with the folders containing the <kbd class="calibre11">SpeakerService</kbd> tests and <kbd class="calibre11">SpeakerController</kbd> tests. As usual, we start with a failing test. In this case, the test is failing to compile:</p>
<pre class="calibre19"><span>[Trait("Category", "SpeakerRepository")]</span><br class="title-page-name"/>public class Class<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    var repo = new SpeakerRepository();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Create the <kbd class="calibre11">SpeakerRepository</kbd> and the test should pass:</p>
<pre class="calibre19">public class SpeakerRepository<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre11">SpeakerRepository</kbd> needs to inherit from <kbd class="calibre11">IRepository</kbd> so either transform the existence test into a test for type, or create a new test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItIsARepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange / Act<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IRepository&lt;Speaker&gt;&gt;(repo);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, make the test pass by inheriting from <kbd class="calibre11">IRepository</kbd>. We don't have tests for functionality at this point, so leave the repository methods as not implemented:</p>
<pre class="calibre19">public class SpeakerRepository : IRepository&lt;Speaker&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  public Speaker Get(int id)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new System.NotImplementedException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new System.NotImplementedException();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Get method</h1>
                
            
            <article>
                
<p class="calibre2">Now that <kbd class="calibre11">SpeakerRepository</kbd> properly inherits from <kbd class="calibre11">IRepository</kbd>, the two methods currently defined by <kbd class="calibre11">IRepository</kbd> need to be implemented. As we did for <kbd class="calibre11">SpeakerService</kbd>, we need to create a new test class specifically for the <kbd class="calibre11">Get</kbd> method. Again, while it might seem to be overkill at this point, creating a file per method will help with organization as the test suite grows:</p>
<pre class="calibre19">[Trait("Category", "SpeakerRepository")]<br class="title-page-name"/>public class Get<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Now that the class exists, the first test method that can be written is a simple exists method:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasGetMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(0);<br class="title-page-name"/>}</pre>
<p class="calibre2">Initially this test will fail because the stub implementation provided by Visual Studio just throws a <kbd class="calibre11">NotImplementedException</kbd>. To fix this, we have to return something; so what should be returned? There is no test to explain what result is expected so we must go with something that will compile but is almost certainly incorrect. In this situation the correct, incorrect value to return is probably <kbd class="calibre11">null</kbd>:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return null;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The GetAll method</h1>
                
            
            <article>
                
<p class="calibre2">The test now passes. Let us pause here and get the same amount of testing around the <kbd class="calibre11">GetAll</kbd> method enforced by the interface. As previously, create a new class for <kbd class="calibre11">GetAll</kbd>:</p>
<pre class="calibre19">[Trait("Category", "SpeakerRepository")]<br class="title-page-name"/>public class GetAll<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Create an exists method which will just ensure the method doesn't throw when called:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasGetAllMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange  <br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.GetAll();<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Create method</h1>
                
            
            <article>
                
<p class="calibre2">It will probably be easier to test the repository pattern if all the repository methods are assumed to exist. Unfortunately, a repository presents a chicken and egg scenario. How can we test <kbd class="calibre11">Get</kbd> or <kbd class="calibre11">GetAll</kbd> without some way of creating entries in the repository? At the same time, how can we test <kbd class="calibre11">Create</kbd> or <kbd class="calibre11">Delete</kbd> without some way of retrieving entries from the repository?</p>
<p class="calibre2">Next create a new class for <kbd class="calibre11">Create</kbd>:</p>
<pre class="calibre19">[Trait("Category", "SpeakerRepository")]<br class="title-page-name"/>public class Create<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">As before, write a method to check for existence. In this test, we need to be sure to test against the repository, not the <kbd class="calibre11">Create</kbd> class implementation. This will force us to add to the interface:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasCreateMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IRepository&lt;Speaker&gt; repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Create(new Speaker());<br class="title-page-name"/>}</pre>
<p class="calibre2">You may have noticed, in this test, that we receive a result from the <kbd class="calibre11">Create</kbd> method. This may not be obvious since we received values from the <kbd class="calibre11">Get</kbd> and <kbd class="calibre11">GetAll</kbd> methods, but we are choosing to break <strong class="calibre1">CQRS</strong> (<strong class="calibre1">Command Query Responsibility Separation</strong>) in favor of a more RESTful approach. In <strong class="calibre1">REST</strong> (<strong class="calibre1">Representational State Transfer</strong>), because it must remain stateless and cannot provide information about an action that has already finished, a service will generally return either the object created or a way to retrieve that object in the future.</p>
<p class="calibre2">In this case, you might think that we are now providing a leaky abstraction of the web. It could be interpreted that way. I prefer to look at this choice as opening options instead of limiting them. It will be easier to hide a CQRS implementation behind a RESTful interface than it would be to work things the other way around.</p>
<p class="calibre2">Now, to pass the currently failing test, a method definition will need to be added to the <kbd class="calibre11">IRepository</kbd> interface, a method implementation will need to be added to the <kbd class="calibre11">SpeakerRepository</kbd>, and the <kbd class="calibre11">SpeakerRepository</kbd> implementation will need to be amended to not throw:</p>
<pre class="calibre19">public interface IRepository&lt;T&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  T Get(int id);<br class="title-page-name"/>  IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  T Create(T item);<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre11">Speaker Save</kbd> method:</p>
<pre class="calibre19">public Speaker Save(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/> return null;<br class="title-page-name"/>}</pre>
<p class="calibre2">A stub implementation will also have to be added to the <kbd class="calibre11">FakeRepository</kbd> that was defined in <a target="_blank" href="part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 7</a><span>, </span><em class="calibre12">Test Driving C# Applications</em><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Delete method</h1>
                
            
            <article>
                
<p class="calibre2">Next, we will add the <kbd class="calibre11">Delete</kbd> method. Just as before, create a new test class:</p>
<pre class="calibre19">[Trait("Category","SpeakerRepository")]<br class="title-page-name"/>public class Delete<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Just like for the <kbd class="calibre11">Create</kbd> method, we need to treat the <kbd class="calibre11">SpeakerRepository</kbd> as an <kbd class="calibre11">IRepository</kbd>. Create a <kbd class="calibre11">Delete</kbd> exists method:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasDeleteMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IRepository&lt;Speaker&gt; repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = new Speaker();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  repo.Delete(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Implementing this method will be slightly easier as it is a void method and we are not expecting a result. There are some decisions that will have to be made later regarding how the method should behave when it is passed to a speaker that does not exist. For now, we can just assume that nothing happens and the method is successful.</p>
<p class="calibre2">As before, modify the <kbd class="calibre11">IRepository</kbd> to contain a <kbd class="calibre11">Delete</kbd> method:</p>
<pre class="calibre19">public interface IRepository&lt;T&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  T Get(int id);<br class="title-page-name"/>  IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  T Create(T item);<br class="title-page-name"/>  void Delete(T item);<br class="title-page-name"/>}</pre>
<p class="calibre2">And now create the stub method in the <kbd class="calibre11">SpeakerRepository</kbd> and the <kbd class="calibre11">FakeRepository</kbd>:</p>
<pre class="calibre19">public void Delete(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Update method</h1>
                
            
            <article>
                
<p class="calibre2">There is one last method required for a valid repository pattern and any useful system. We need the ability to update the models we are working with. As with the last two methods, this one does not yet exist in the repository, so let's add it.</p>
<p class="calibre2">As before, begin by creating a test class for it:</p>
<pre class="calibre19">[Trait("Category", "SpeakerRepository")]<br class="title-page-name"/>public class Update<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Just like the others, create an <kbd class="calibre11">ItExists</kbd> test referencing the <kbd class="calibre11">IRepository</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasUpdateMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IRepository&lt;Speaker&gt; repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = new Speaker();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Update(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">As before, we are just stubbing functionality here so we don't yet have an actual speaker to update. This test, and the others, will almost certainly have to change as we begin testing for actual functionality. For now, they will suffice to ensure the interface and class have the appropriate methods.</p>
<p class="calibre2">As before, add the method to the interface and then to the <kbd class="calibre11">SpeakerRepository</kbd> and the <kbd class="calibre11">FakeRepository</kbd>:</p>
<pre class="calibre19">public interface IRepository<br class="title-page-name"/>{<br class="title-page-name"/>  TGet(int id);<br class="title-page-name"/>  IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  T Create(T item);<br class="title-page-name"/>  T Update(T item);<br class="title-page-name"/>  void Delete(T item);<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre11">Speaker Update</kbd> method:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  return null;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ensuring functionality</h1>
                
            
            <article>
                
<p class="calibre2">Now that all the methods have been defined, we can begin writing tests for functionality. We will begin with <kbd class="calibre11">Create</kbd> and work our way down to <kbd class="calibre11">Delete</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a speaker</h1>
                
            
            <article>
                
<p class="calibre2">The chicken and egg scenario mentioned earlier has us in a predicament. We can't read a speaker from the repository if no speakers have been created. We also can't verify that a speaker has in fact been created unless we can retrieve a speaker from the repository.</p>
<p class="calibre2">One way to solve this problem is by using a special kind of test double that exposes the internal functionality of a class for the purposes of asserting on that information. For <kbd class="calibre11">Create</kbd>, we will use this approach. In the <kbd class="calibre11">Create.cs</kbd> file, let's add a test that assumes the testable class already exists:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAddsASpeakerToTheRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new TestableSpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Create(new Speaker());<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, repo.SpeakersCollection.Count);<br class="title-page-name"/>}</pre>
<p class="calibre2">To get past the compilation error, the testable class must be created. Create this class in the same file, for now, to make working with it more efficient:</p>
<pre class="calibre19">public class TestableSpeakerRepository : SpeakerRepository<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Now the class is created and the initial compilation error is resolved, but a new error has risen:</p>
<pre class="calibre19">// Assert<br class="title-page-name"/>Assert.Equal(1, repo.SpeakersCollection.Count);</pre>
<p class="calibre2">This error is slightly more difficult to resolve. In reality, we want a collection of speakers to exist in the real repository. However, we have had no reason to expose that collection. No collection has actually been created as a result. Now, in this test we are asking whether a collection exists. The test requires that a collection exists for the <kbd class="calibre11">TestableSpeakerRepository</kbd> but we know we need one for the real <kbd class="calibre11">SpeakerRepository</kbd>. Let's play devil's advocate and actually do the thing we know is not quite right:</p>
<pre class="calibre19">public class TestableSpeakerRepository : SpeakerRepository<br class="title-page-name"/>{<br class="title-page-name"/>  public IQueryable&lt;Speaker&gt; SpeakersCollection { get; set; }<br class="title-page-name"/>}</pre>
<p class="calibre2">This change doesn't quite make the test pass; when writing the test we hastily accessed the <kbd class="calibre11">Count</kbd> property on Speakers. The <kbd class="calibre11">Count</kbd> property is only on a list, but to limit the exposure of an interface until we actually can require it with tests, we should really be using an <kbd class="calibre11">IQueryable</kbd>. We can quickly update the test to reflect this choice:</p>
<pre class="calibre19">// Assert<br class="title-page-name"/>Assert.Equal(1, repo.SpeakersCollection.Count);</pre>
<p class="calibre2">Now, execute the tests and it finally fails with an actual message. The solution to this failure is to add an entry to the speakers collection when <kbd class="calibre11">Create</kbd> is called. The problem is that Speakers is in a different class from <kbd class="calibre11">Create</kbd>. So, we must have a collection in <kbd class="calibre11">SpeakerRepository</kbd> as well:</p>
<pre class="calibre19">protected readonly IList&lt;Speaker&gt; Speakers = new List&lt;Speaker&gt;();<br class="title-page-name"/><br class="title-page-name"/>public Speaker Create(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  Speakers.Add(speaker);<br class="title-page-name"/><br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">What's important to note is the scope and type of <kbd class="calibre11">_speakers</kbd>. It is an <kbd class="calibre11">IList</kbd>, because we need to add an item to it; an <kbd class="calibre11">IQueryable</kbd> will not do. It is also protected; <kbd class="calibre11">_speakers</kbd> must be hidden from the outside world but also must be accessible from the testable class. The scope operator that gives us this functionality is protected.</p>
<p class="calibre2">We must also make changes in the testable class in order to make this test pass:</p>
<pre class="calibre19">internal class TestableSpeakerRepository : SpeakerRepository<br class="title-page-name"/>{<br class="title-page-name"/>  public IList&lt;Speaker&gt; SpeakersCollection =&gt; Speakers;<br class="title-page-name"/>}</pre>
<p class="calibre2">Continuing with <kbd class="calibre11">Create</kbd>, we now need to verify that, when a new speaker is created, it  receives a unique ID:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAssignsUniqueIdsToEachSpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new TestableSpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker1 = repo.Create(new Speaker());<br class="title-page-name"/>  var speaker2 = repo.Create(new Speaker());<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual(speaker1.Id, speaker2.Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">To make this test pass, we must come up with some kind of ID generation system. There are many options, but one of the simplest is to create a private field and increment the value each time <kbd class="calibre11">Create</kbd> is called:</p>
<pre class="calibre19">private int _currentId = 0;<br class="title-page-name"/><br class="title-page-name"/>public Speaker Create(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  speaker.Id = ++_currentId;<br class="title-page-name"/>  <br class="title-page-name"/>  Speakers.Add(speaker);<br class="title-page-name"/><br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">With that test passing, we can now turn our attention to a leak in the abstraction. We are simply placing the passed-in object into the dataset. This could cause an issue in an application that needs to be fixed.</p>
<p class="calibre2">The repository should isolate its object from the rest of the application by passing and storing clones, instead of directly accessing and providing objects:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsANewSpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new TestableSpeakerRepository();<br class="title-page-name"/>  var speaker = new Speaker { Id = 0 };<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Create(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(0, speaker.Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">To make this test pass, we will need some cloning mechanism. To make this test pass as soon as possible, we can simply use a new object and object initializer:</p>
<pre class="calibre19">public Speaker Create(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var newSpeaker = new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = ++_currentId,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>    IsDeleted = speaker.IsDeleted<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  Speakers.Add(newSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  return newSpeaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we must handle the other direction for reference passing. The value stored in the speakers collection should not directly be handed back to us from the <kbd class="calibre11">Create</kbd> method:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstObjectChangesAfterCreation()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new TestableSpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker());<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  speaker.Name = "test name";<br class="title-page-name"/><br class="title-page-name"/>  // Audit<br class="title-page-name"/>  var result = repo.SpeakersCollection.First();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual("test name", result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">Notice the extra auditing step. Sometimes, you will need to take an action and then assert on a deeply nested value or a distant value. In those cases, you can keep a clean single-step action by adding an audit step.</p>
<p class="calibre2">To make this test pass, we must take a similar action to what we are already doing at the top of the <kbd class="calibre11">Create</kbd> method:</p>
<pre class="calibre19">public Speaker Create(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var newSpeaker = new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = ++_currentId,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>    IsDeleted = speaker.IsDeleted<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  Speakers.Add(newSpeaker);<br class="title-page-name"/>  <br class="title-page-name"/>  var returnableSpeaker = new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = newSpeaker.Id,<br class="title-page-name"/>    Name = newSpeaker.Name,<br class="title-page-name"/>    Location = newSpeaker.Location,<br class="title-page-name"/>    IsDeleted = newSpeaker.IsDeleted<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  return returnableSpeaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">That completes the functionality required for the <kbd class="calibre11">Create</kbd> method. Now we should really do some long overdue refactoring. Firstly, let's focus on the tests and reduce the duplicated calls to create a new repository.</p>
<p class="calibre2">Create a constructor and a private <kbd class="calibre11">repo</kbd> field:</p>
<pre class="calibre19">private readonly TestableSpeakerRepository _repo;<br class="title-page-name"/><br class="title-page-name"/>public Create()<br class="title-page-name"/>{<br class="title-page-name"/>  _repo = new TestableSpeakerRepository();<br class="title-page-name"/>}</pre>
<p class="calibre2">Then replace all repository references in the tests with <kbd class="calibre11">_repo</kbd>. After reducing the number of repositories being created in the tests, the tests look pretty good. Now we can focus on the <kbd class="calibre11">SpeakerRepository</kbd> class.</p>
<p class="calibre2">One of the immediate standouts in the <kbd class="calibre11">SpeakerRepository</kbd> is the code we are using to clone a speaker. The same code has essentially been typed twice in the same method. Let's abstract this to a private function inside the repository for now. We may end up making a more sophisticated solution later on, but for now that should be good enough.</p>
<p class="calibre2">At the bottom of the class, after all the public methods, we can create a <kbd class="calibre11">CloneSpeaker</kbd> method:</p>
<pre class="calibre19">private Speaker CloneSpeaker(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  return new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>    IsDeleted = speaker.IsDeleted<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">Then we use the <kbd class="calibre11"><span>CloneSpeaker</span></kbd> method in <kbd class="calibre11">Create</kbd>:</p>
<pre class="calibre19">public Speaker Create(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var newSpeaker = CloneSpeaker(speaker);<br class="title-page-name"/><br class="title-page-name"/>  newSpeaker.Id = ++_currentId;<br class="title-page-name"/><br class="title-page-name"/>  Speakers.Add(newSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  return CloneSpeaker(newSpeaker);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting a single speaker</h1>
                
            
            <article>
                
<p class="calibre2">With the existence of <kbd class="calibre11">Create</kbd>, we can now very easily assert on the retrieval of an existing or non-existing speaker. According to Uncle Bob's Transformation Priority Premise, it is easier and simpler to test a singular item rather than a plural item, so while it doesn't completely fulfil the intent of the premise, we will test the retrieval of a singular speaker next.</p>
<p class="calibre2">We already have an exists test, so what will the next test be? The simplest test would be the retrieval of a single speaker, but if we are trying to avoid the gold standard, the most appropriate test would be examining what happens when a speaker does not exist.</p>
<p class="calibre2">For non-existing speakers, we have a few immediately apparent options. We could throw an error stating that the requested speaker is not in the system. Another option would be returning a <kbd class="calibre11">null</kbd> object. And the last would be simply returning <kbd class="calibre11">null</kbd>.</p>
<p class="calibre2">Throwing an error is probably the most straightforward, so let's examine this option first:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItThrowsWhenSpeakerIsNotFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = Record.Exception(() =&gt; repo.Get(-1));<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsType&lt;SpeakerNotFoundException&gt;(result.GetBaseException());<br class="title-page-name"/>}</pre>
<p class="calibre2">To make this test pass, first we must make it compile. The <kbd class="calibre11">SpeakerNotFoundException</kbd> in this case is not the same as the one we are using in the <kbd class="calibre11">SpeakerService</kbd>. So, it will need to be created:</p>
<pre class="calibre19">public class SpeakerNotFoundException : Exception<br class="title-page-name"/>{<br class="title-page-name"/>  public SpeakerNotFoundException()<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now that the test is correctly compiling and failing, we can add the appropriate code to the repository to make the test pass:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  if (id == -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return null;<br class="title-page-name"/>}</pre>
<p class="calibre2">Another guideline for tests, to help you know you are on the right path and not digging yourself into a hole, is again from Uncle Bob, <em class="calibre12">A</em>s the tests get more specific the code gets more generic. If we look at the code we just wrote, it seems more specific then generic. Let's refactor it to maintain a trend towards generics:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  if (id &gt; -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    return null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  throw new SpeakerNotFoundException();<br class="title-page-name"/>}</pre>
<p class="calibre2">The change here is subtle, but important. Thinking about the operation of this method in production, the default case really is to throw. There is only a small subset in the set containing all the integers that we actually have a speaker for, so the generic case is to throw. The specific case is actually to find a speaker.</p>
<p class="calibre2">One issue with the method of throwing when a speaker is not found is that it brings a possibly unexpected and abrupt end to the application flow. The entire logic path the application took to get to this method is now destroyed and the exception must be handled. Even when we handle the exception, C# uses extra CPU cycles on the first-chance exception error handling process. Sometimes throwing is definitely the right decision; however, exceptions should be reserved for truly exceptional events. As discussed earlier, it is far more likely that a <kbd class="calibre11">Get</kbd> could be called with an invalid ID than with a valid one. So, in this case it is not necessarily a properly exceptional event for an invalid speaker to be requested.</p>
<p class="calibre2">Let's explore the alternative of a NullObject. First, we need to revert our code to where it was when we started working on the <kbd class="calibre11">Get</kbd> method. We are using source control so we can very simply revert our code. If you are not using source control, I would suggest you start. Here is the state the <kbd class="calibre11">Get</kbd> method should be in before we begin again:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return null;<br class="title-page-name"/>}</pre>
<p class="calibre2">We can just delete the test that asserts an exception was thrown.</p>
<p class="calibre2">The NullObject pattern is a simple pattern with a slightly more complicated implementation. Basically, you create an object that inherits from the class needed, but it does absolutely nothing in just the right way.</p>
<p class="calibre2">Thinking about this from our eventual website usage, a speaker null object would possibly have a name such as "Mr. Unknown" and would speak at conferences like "Mid-Nowhere Tech Fest." We could create a funny profile picture and fill out harmless user information that would let the user know they had requested a non-existent speaker. All of that information could be determined and filled out later. The important part of a null object is that it represents a fully capable object, but does absolutely nothing in the right way to not cause harm within your application:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsANullSpeakerWhenNotFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsType&lt;NullSpeaker&gt;(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">To fix the compilation error, create the <kbd class="calibre11">NullSpeaker</kbd> class and have it inherit from <kbd class="calibre11">Speaker</kbd>:</p>
<pre class="calibre19">public class NullSpeaker : Speaker<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Making the test pass is fairly simple. In this case we don't have to worry about existing tests that could break from returning the null object:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new NullSpeaker();<br class="title-page-name"/>}</pre>
<p class="calibre2">Superficially, the null object pattern seems like a pretty good solution. In reality, this is not always the case. It is very difficult to properly do nothing within a system. In the case of getting a speaker, the null object pattern would probably work just fine. We have one more option to explore though.</p>
<p class="calibre2">The last option is to simply return <kbd class="calibre11">null</kbd>. Well, simply may not be the best word choice. <kbd class="calibre11">Null</kbd> can cause a lot of trouble within a system. It will wreak havoc if you do not handle the null that was received and a distant part of the system tries to use the null as if it weren't null. Earlier, when we were designing the service, we decided to expect null as a possible result from calling the repository; thus, in this case the range of effects should be short and null should not cause significant negative side-effects within the system. Let's revert the code one more time and explore simply returning <kbd class="calibre11">null</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsNullWhenNotFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Null(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">There is nothing to do in the <kbd class="calibre11">SpeakerRepository</kbd> because we are already returning <kbd class="calibre11">null</kbd>. Normally, this test would not be written here. We would wait to write this test until we had a test that was returning a valid speaker. The reason we want to delay this test is because we can't fail it. You will not see this test go red and that is generally a problem. Either the test is not needed because it is extraneous and covered elsewhere or the test is flawed because it can't fail.</p>
<p class="calibre2">The test we should write before this one is a test that should retrieve a valid value. For the moment, ignore this test and we will come back and watch it fail after the next test:</p>
<pre class="calibre19">[Fact(Skip = "Can't fail")]<br class="title-page-name"/>public void ItReturnsNullWhenNotFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Null(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">So, if we are about to test the retrieval of an existing speaker, which we called the gold standard before, why did we avoid it in the first place? The reason we are going to test the gold standard first now is solely because of implementation choices. If we were going to use either as an exception or a null object, we would have done those first. The problem right now is that our code is already returning <kbd class="calibre11">null</kbd> so testing for null would not have done us any good.</p>
<p class="calibre2">To test for an existing speaker, a speaker must first exist. In the arrange section of our test, we will need to make sure we create a speaker:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsASpeakerWhenFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Speaker"});<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(speaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">The first step is to simply assert that the result is not null. This of course fails because all we are doing right now is returning <kbd class="calibre11">null</kbd>. Let's fix that:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new Speaker();<br class="title-page-name"/>}</pre>
<p class="calibre2">Even though we are now forced to go down the gold-standard path, we can still avoid it as much as possible. One way to do this is by playing devil's advocate, which we can do by returning a speaker, just not the right speaker.</p>
<p class="calibre2">We must now modify the test to make sure the values we care about are correct:</p>
<pre class="calibre19">// Assert<br class="title-page-name"/>Assert.NotNull(result);<br class="title-page-name"/>Assert.Equal("Test Speaker", result.Name);</pre>
<p class="calibre2">Now to modify the code. We could continue to play devil's advocate, but at this point that would only cause more unnecessary work in the tests:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return Speakers.SingleOrDefault(s =&gt; s.Id == id);<br class="title-page-name"/>}</pre>
<p class="calibre2">At this point, we are left with a conundrum. We can't call <kbd class="calibre11">Single</kbd> or <kbd class="calibre11">First</kbd> because they will throw an exception if the requested speaker is not found. We do have a system rule to return <kbd class="calibre11">null</kbd> when the speaker is not found though. The system is behaving correctly by default. We could simply put our test back into play and accept that the null test just won't be properly verifiable. Another option is to purposely write code to return a new speaker in the event that the speakers collection is missing the requested speaker. Taking the second option would allow us to see the null test fail, but we would just be removing it to make the test pass.</p>
<p class="calibre2">In this case, the second option is probably the most appropriate. Many of you will probably think that there is no reason to add the code that forces a non-null; many others will probably think that the test is not needed as it doesn't seem to provide value. Both groups are correct and incorrect at the same time. They are correct: putting in code just to remove it two seconds later is stupid. Adding a test that can't really fail is stupid too.</p>
<p class="calibre2">However, we need the test because at some point in the future a requirement could come in that would cause a null to be accidentally impossible and we need a record of the business requirement stating that the value should be null. We also need to see every test fail. In this particular case, we could probably get away with skipping that part, but if we get into a habit of skipping test failures it will quickly bite you.</p>
<p class="calibre2">So, let's make the appropriate change to force the null test to fail and then fix our "error:"</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return Speakers.SingleOrDefault(s =&gt; s.Id == id) ?? new Speaker();<br class="title-page-name"/>}</pre>
<p class="calibre2">We can now remove the skip attribute on the null test and then come back here and remove the null coalescing operator.</p>
<p class="calibre2">We have one more test needed for <kbd class="calibre11">Get</kbd>. We must ensure the pointer for the returned speaker is not the same as the speaker in the repository:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstObjectChanges()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker { Name = "Test Speaker" });<br class="title-page-name"/>  var retrievedSpeaker = repo.Get(speaker.Id);<br class="title-page-name"/>  retrievedSpeaker.Name = "New Speaker Name";<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Get(speaker.Id);<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual(retrievedSpeaker.Name, result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">This test is significantly harder to follow, but necessary. We first have to create a speaker. Then we retrieve the speaker we created, update the retrieved speaker's name, and  retrieve the speaker again. Finally, we verify that the modified speaker is not the same as the retrieved speaker. They should not be the same because we have not saved the data, so no updates should have occurred.</p>
<p class="calibre2">The fix for this issue has already been created and just needs to be implemented:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = Speakers.SingleOrDefault(s =&gt; s.Id == id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker != null)<br class="title-page-name"/>  {<br class="title-page-name"/>    speaker = CloneSpeaker(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">Lastly, we should refactor. Follow the same steps as you did for create and extract the repository creation into the constructor. The simplicity of this test class means it doesn't require any further refactoring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting multiple speakers</h1>
                
            
            <article>
                
<p class="calibre2">Getting many speakers is much easier than getting a single speaker. We are not going to have to worry about not finding speakers. We are not going to have to handle any error conditions. All we have to test for is retrieving the correct number of speakers, and ensuring data safety the same as we have done for the other methods so far.</p>
<p class="calibre2">Let's start with retrieving all the speakers when there are no speakers:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsNoSpeakersWhenThereAreNoSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">This is an easy fix in the repository:</p>
<pre class="calibre19">public IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return new List&lt;Speaker&gt;().AsQueryable();<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember, we are playing devil's advocate; this is the correct response for its purpose.</p>
<p class="calibre2">Now, we need to assert the type and size of the method's response:</p>
<pre class="calibre19">// Assert<br class="title-page-name"/>Assert.NotNull(result);<br class="title-page-name"/>Assert.IsAssignableFrom&lt;IQueryable&lt;Speaker&gt;&gt;(result);<br class="title-page-name"/>Assert.Equal(0, result.Count());</pre>
<p class="calibre2">I know we have already mentioned the single assert rule and how it doesn't mean what it sounds like it means. This test is still following the rule because we are asserting that <kbd class="calibre11">GetAll</kbd> returns a non-null empty collection of speakers.</p>
<p class="calibre2">Next, we test for a single speaker present in the repository:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsASingleSpeakerWhenOnlyOneSpeakerExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  repo.Create(new Speaker { Name = "Test Speaker"});<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, result.Count());<br class="title-page-name"/>}</pre>
<p class="calibre2">Again, making the appropriate adjustment in the repository is fairly simple:</p>
<pre class="calibre19">public IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return Speakers.AsQueryable();<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, we want to close off this line of testing by making sure that the speaker returned is the speaker we created. We expect this to pass right way because we already know that is the case. This assertion is important to ensure the future integrity of the repository.</p>
<pre class="calibre19">// Act<br class="title-page-name"/>var result = repo.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>// Assert<br class="title-page-name"/>Assert.Single(result);<br class="title-page-name"/>Assert.Equal("Test Speaker", result.First().Name);</pre>
<p class="calibre2">Notice the change to the action. Executing a count and retrieving the first element in the collection both cause an enumeration. Enumerations equal CPU cycles. To reduce test time and production execution time, we want to reduce the number of enumerations. Converting the <kbd class="calibre11">IQueryable</kbd> to a list will enforce a single enumeration.</p>
<p class="calibre2">Let's do one final test to ensure the proper return values and check that multiple speakers come back correctly:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsManySpeakersWhenManySpeakersExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  repo.Create(new Speaker());<br class="title-page-name"/>  repo.Create(new Speaker());<br class="title-page-name"/>  repo.Create(new Speaker());<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(3, result.Count);           <br class="title-page-name"/>}</pre>
<p class="calibre2">This test is just a sanity check and passes right away. Our next test is going to check data integrity:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstObjectChanges()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/>  var speakers = repo.GetAll().ToList();<br class="title-page-name"/>  speakers.First().Name = "New Name";<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual(speakers.First().Name, result.First().Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">The update in the repository is similar to what we have done for the other methods with one exception. We are operating on an entire collection, instead of just a single item:</p>
<pre class="calibre19">public IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return Speakers.Select(CloneSpeaker).AsQueryable();<br class="title-page-name"/>}</pre>
<p class="calibre2">Some of you may have seen this syntax before. What we have done is to pass the function pointer of the <kbd class="calibre11">CloneSpeaker</kbd> method in as the Lambda expression required by the <kbd class="calibre11">Select</kbd> method in linq. The preceding line is exactly the same, functionally, as the following:</p>
<pre class="calibre19">public IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return Speakers.Select(CloneSpeaker).AsQueryable();<br class="title-page-name"/>}</pre>
<p class="calibre2"><span>Time</span> to clean up. We have the same clean-up steps as before. The only real refactoring needed is extracting the repository creation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating a speaker</h1>
                
            
            <article>
                
<p class="calibre2">We can now create and retrieve speakers. We have also ensured that we cannot update them by accident. So, let's make sure we can update them on purpose:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItUpdatesASpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/>  speaker.Name = "New Name";<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Update(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(speaker.Name, result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">Playing devil's advocate again, this is a simple update to the repository:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">This is clearly the wrong solution; let's write another, more specific test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItUpdatesASpeakerInTheRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/>  speaker.Name = "New Name";<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var updatedSpeaker = repo.Update(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Audit<br class="title-page-name"/>  var result = repo.Get(speaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("New Name", result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">Making this test pass is a little tricky, but not too bad:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var oldSpeaker = Speakers.FirstOrDefault(s =&gt; s.Id == speaker.Id);<br class="title-page-name"/>  var index = Speakers.IndexOf(oldSpeaker);<br class="title-page-name"/>  Speakers[index] = speaker;           <br class="title-page-name"/><br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">However, making this change causes the exists test to fail. Looking at that test, it is failing for a good reason and should not really pass given our current understanding of how <kbd class="calibre11">Update</kbd> is supposed to work. Let's make a small but significant update to that test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasUpdateMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IRepository&lt;Speaker&gt; repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker());<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = repo.Update(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Next up on our testing timeline, is handling the error that was highlighted by the failure of the exists test. If someone asks to update a speaker that doesn't exist, the repository blows up. This could be the required behavior, but it should blow up with an informative exception, not an index out of bounds exception:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItThrowsNotFoundExceptionWhenSpeakerDoesNotExist()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = new Speaker {Id = 5, Name = "Test Name"};<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = Record.Exception(() =&gt; repo.Update(speaker));<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerNotFoundException&gt;(result.GetBaseException());<br class="title-page-name"/>}</pre>
<p class="calibre2">A <kbd class="calibre11">SpeakerNotFoundException</kbd> already exists within the system, but this comes from a different layer so we need to create a new exception:</p>
<pre class="calibre19">public class SpeakerNotFoundException : Exception<br class="title-page-name"/>{<br class="title-page-name"/>  public SpeakerNotFoundException(int id) : base($"Speaker {id} not found.")<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">As an exercise, see if you can cover this exception with tests. Being able to work backwards and write tests after the fact, as we will discuss in upcoming chapters, is a valuable skill to have.</p>
<p class="calibre2">Now, let's continue and make this test pass:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var oldSpeaker = Speakers.FirstOrDefault(s =&gt; s.Id == speaker.Id);<br class="title-page-name"/>  var index = Speakers.IndexOf(oldSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  if (index == -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException(speaker.Id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Speakers[index] = speaker;<br class="title-page-name"/><br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">As with the other tests, we must now ensure data integrity:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstObjectChanges()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/>  speaker.Name = "New Name";<br class="title-page-name"/>  var updatedSpeaker = repo.Update(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  updatedSpeaker.Name = "Updated Name";<br class="title-page-name"/><br class="title-page-name"/>  // Audit<br class="title-page-name"/>  var result = repo.Get(updatedSpeaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual("Updated Name", result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">We are bordering on test complexity that is too high. If these tests get much more complex, we will want to consider rethinking our approach. This test confirms what we thought: the returned speaker is not protected against change. Let's fix that:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var oldSpeaker = Speakers.FirstOrDefault(s =&gt; s.Id == speaker.Id);<br class="title-page-name"/>  var index = Speakers.IndexOf(oldSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  if (index == -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException(speaker.Id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Speakers[index] = speaker;<br class="title-page-name"/><br class="title-page-name"/>  return CloneSpeaker(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">A fairly simple solution: just wrap the return with a <kbd class="calibre11">CloneSpeaker</kbd> call. Do you see another potential data integrity issue? What are we doing to protect against further changes to the speaker that was passed? Let's write a test to ensure that changes after the fact to the speaker that was passed in don't affect the repository:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstOriginalObjectChanges()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker { Name = "Test Name" });<br class="title-page-name"/>  speaker.Name = "New Name";<br class="title-page-name"/>  var updatedSpeaker = repo.Update(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  speaker.Name = "Updated Name";<br class="title-page-name"/><br class="title-page-name"/>  // Audit<br class="title-page-name"/>  var result = repo.Get(updatedSpeaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotEqual("Updated Name", result.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">This test looks almost identical to the previous test. The only significant change is the action. Instead of changing the value on the <kbd class="calibre11">updatedSpeaker</kbd>, we are now changing the value on the original speaker. To make this test pass, the change to the repository is similar to the previous fix:</p>
<pre class="calibre19">public Speaker Update(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var oldSpeaker = Speakers.FirstOrDefault(s =&gt; s.Id == speaker.Id);<br class="title-page-name"/>  var index = Speakers.IndexOf(oldSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  if (index == -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException(speaker.Id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Speakers[index] = CloneSpeaker(speaker);<br class="title-page-name"/><br class="title-page-name"/>  return CloneSpeaker(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">All that is left to refactor and clean up are the tests and repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deleting a speaker</h1>
                
            
            <article>
                
<p class="calibre2">We are finally at the last method in this repository. For Speaker Meet, we don't really want to delete the speakers; we might flag a speaker as deleted, but we don't really want to remove them from the dataset. So, our <kbd class="calibre11">Delete</kbd> method will be more like an update.</p>
<p class="calibre2">We don't have any strange behavior or constraints for <kbd class="calibre11">Delete</kbd>, so we should start with the failure case. What should happen if we ask to delete a user that doesn't exist? Should we throw an exception? In this case, we can actually just assume that the job is done. If there is no speaker with the given ID then the deletion of that speaker could be considered a success.</p>
<p class="calibre2">Well, now that we have considered the failure case, we see that it does have special behavior that would cause the failure case to simply pass straight away. Let's take a look at the success case and see if it would cause a failing test:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItMarksTheGivenSpeakerAsDeleted()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  repo.Delete(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Audit<br class="title-page-name"/>  var result = repo.Get(speaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(result.IsDeleted);<br class="title-page-name"/>}</pre>
<p class="calibre2">Making this test pass should be fairly easy: we can just call into the local update method after changing the <kbd class="calibre11">isDeleted</kbd> flag to <kbd class="calibre11">true</kbd>:</p>
<pre class="calibre19">public void Delete(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  speaker.IsDeleted = true;<br class="title-page-name"/><br class="title-page-name"/>  Update(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Don't forget to fix any other tests that fail as a result of adding this code, after making sure the failure is for a valid reason. If tests fail while we are writing more tests we need to check the requirements and make sure they are not in disagreement with each other. We never want to break existing requirements unintentionally.</p>
<p class="calibre2">We now have to deal with what happens if the speaker didn't exist in the context. As decided earlier, we are okay with just ignoring this request as a failure to delete a non-existing speaker results in the same situation as successfully deleting an existing speaker:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItDoesNothingWhenDeletingANonexistingSpeaker()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = new Speaker();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = Record.Exception(() =&gt; repo.Delete(speaker));<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Null(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">To pass this one we have to do something that is normally not recommended or preferred. We have to swallow an exception. Before taking a step like this and ignoring an exception, make sure you only ignore a specific exception and make sure you have thought it through thoroughly:</p>
<pre class="calibre19">public void Delete(Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  speaker.IsDeleted = true;<br class="title-page-name"/><br class="title-page-name"/>  try<br class="title-page-name"/>  {<br class="title-page-name"/>    Update(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/>  catch (SpeakerNotFoundException ex)<br class="title-page-name"/>  {<br class="title-page-name"/>    // We can assume non-existing speakers are deleted<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">And for the last test for this method, we must make sure that we don't accidently pollute the object that was passed in:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItProtectsAgainstPassedObjectChanges()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var repo = new SpeakerRepository();<br class="title-page-name"/>  var speaker = repo.Create(new Speaker {Name = "Test Name"});<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  repo.Delete(speaker);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.False(speaker.IsDeleted);<br class="title-page-name"/>}</pre>
<p class="calibre2">We can use the same method we have been using to ensure data integrity:</p>
<pre class="calibre19">speaker = CloneSpeaker(speaker);<br class="title-page-name"/>speaker.IsDeleted = true;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Genericizing the repository</h1>
                
            
            <article>
                
<p class="calibre2">This repository is great, but do we really want to repeat this logic and all these tests for every single data model that we need to be retrieved from some data source? The answer is no; if you find yourself doing the same thing over and over as a developer, you are doing something wrong.</p>
<p class="calibre2">So, how can we protect ourselves from that drudgery?</p>
<p class="calibre2">One way is to use generics. Let's refactor the <kbd class="calibre11">SpeakerRepository</kbd> to use generics, this will also involve refactoring many of the tests to make them apply to the <kbd class="calibre11">GenericRepository</kbd> instead of the concrete <kbd class="calibre11">SpeakerRepository</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step one – abstract interface</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre11">IRepository</kbd>, everywhere we use <kbd class="calibre11">Speaker</kbd> we need to replace it with C# generics:</p>
<pre class="calibre19">public interface IRepository&lt;T&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  T Create(T item);<br class="title-page-name"/>  T Get(int id);<br class="title-page-name"/>  IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  T Update(T item);<br class="title-page-name"/>  void Delete(T item);<br class="title-page-name"/>}</pre>
<p class="calibre2">This change will cause a break in the <kbd class="calibre11">SpeakerRepository</kbd> that we need to fix. Right now, we are chasing the compiler and leaning on it to tell us what we are breaking. Once the tests pass again, we will know we are back to good:</p>
<pre class="calibre19">public class SpeakerRepository : IRepository&lt;Speaker&gt;</pre>
<p class="calibre2">Now we have to make some changes in the SpeakerService as it is no longer able to reference a simple IRepository but instead needs an <kbd class="calibre11">IRepository&lt;Speaker&gt;</kbd>:</p>
<pre class="calibre19">public class SpeakerService : ISpeakerService<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly IRepository&lt;Speaker&gt; _repository;<br class="title-page-name"/><br class="title-page-name"/>  public SpeakerService(IRepository&lt;Speaker&gt; repository)<br class="title-page-name"/>  {<br class="title-page-name"/>    _repository = repository;<br class="title-page-name"/>  }<br class="title-page-name"/> …</pre>
<p class="calibre2">We must update the fake repository to use the correct generic repository type.</p>
<p class="calibre2"><kbd class="calibre11">public class FakeRepository : IRepository&lt;Speaker&gt;</kbd></p>
<p class="calibre2">And lastly, we have several tests that need to be updated. No secret code there; just update <kbd class="calibre11">IRepository</kbd> to <kbd class="calibre11">IRepository&lt;Speaker&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step two – abstract the concrete class</h1>
                
            
            <article>
                
<p class="calibre2">Now that the interface is generic, we can start to work on the <kbd class="calibre11">SpeakerRepository</kbd>. First let's rename it to <kbd class="calibre11">InMemorySpeakerRepository</kbd>. Now, we want to start using generics. Create a new class, <kbd class="calibre11">InMemoryRepository&lt;T&gt;</kbd> and have the speaker repository inherit from it:</p>
<pre class="calibre19">public abstract class InMemoryRepository&lt;T&gt; : IRepository&lt;T&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  public abstract T Create(T speaker);<br class="title-page-name"/>  public abstract T Get(int id);<br class="title-page-name"/>  public abstract IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  public abstract T Update(T speaker);<br class="title-page-name"/>  public abstract void Delete(T speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to move slow and have the tests passing as much as possible, we are using abstract and will have to have each method in the speaker repository override the base class methods. This gives us the ability to move each method individually into the abstract as we discover what needs to be done, instead of trying to tackle the whole problem all at once.</p>
<p class="calibre2">Inherit from the in-memory repository and add override to each inherited method:</p>
<pre class="calibre19">public class InMemorySpeakerRepository : InMemoryRepository&lt;Speaker&gt;<br class="title-page-name"/>public overrideSpeaker Create(Speaker speaker)<br class="title-page-name"/>public override Speaker Get(int id)<br class="title-page-name"/>public override IQueryable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>public override Speaker Update(Speaker speaker)<br class="title-page-name"/>public override void Delete(Speaker speaker)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting Create to a generic method</h1>
                
            
            <article>
                
<p class="calibre2">We will begin our generic method journey with <kbd class="calibre11">Create</kbd>. The first step is to copy the body of the <kbd class="calibre11">Create</kbd> method from the speaker repository to the generic repository. In order to do this, we must change the abstract <kbd class="calibre11">Create</kbd> method to a virtual <kbd class="calibre11">Create</kbd> method:</p>
<pre class="calibre19">public virtual T Create(T speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  var newSpeaker = CloneSpeaker(speaker);<br class="title-page-name"/>  newSpeaker.Id = ++CurrentId;<br class="title-page-name"/>  Speakers.Add(newSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  return CloneSpeaker(newSpeaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Instantly, we run into trouble. We don't have a generic clone method. For now let's fake it until we make it.</p>
<p class="calibre2">Add the following protected abstract method to the generic repository:</p>
<pre class="calibre19">protected abstract T CloneEntity(T entity);</pre>
<p class="calibre2">Now, we can make similar changes in the code we copied from the speaker repository's <kbd class="calibre11">Create</kbd> method:</p>
<pre class="calibre19">protected readonly IList&lt;T&gt; Entities = new List&lt;T&gt;();<br class="title-page-name"/>protected int CurrentId;<br class="title-page-name"/><br class="title-page-name"/>public virtual T Create(T entity)<br class="title-page-name"/>{<br class="title-page-name"/>  var newSpeaker = CloneEntity(entity);<br class="title-page-name"/>  newSpeaker.Id = ++CurrentId;<br class="title-page-name"/>  Entities.Add(newSpeaker);<br class="title-page-name"/><br class="title-page-name"/>  return CloneEntity(newSpeaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Its's looking much better now, but we still have one issue. We can't expect <kbd class="calibre11">Id</kbd> to exist on just any object. The compiler is quite mad about this right now. There are several solutions, but we are going to create a simple data model interface and place a constraint on <kbd class="calibre11">T</kbd> that it must inherit from that interface. The only thing in the interface will be a property of <kbd class="calibre11">Id</kbd> with an integer type:</p>
<pre class="calibre19">public interface IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  int Id { get; set; }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public abstract class InMemoryRepository&lt;T&gt; : IRepository&lt;T&gt; where T: IIdentity</pre>
<p class="calibre2">This causes a break in the speaker repository. We must also have Speaker inherit from <kbd class="calibre11">IIdentity</kbd>. Now, we have relocated all of the logic in the <kbd class="calibre11">Create</kbd> method into the generic repository. Delete the <kbd class="calibre11">Create</kbd> method in the speaker repository.</p>
<p class="calibre2">Many tests fail because we need to repoint the other methods in the speaker repository to use the backing objects from the generic repository. Go through the speaker repository and update all the references to Speakers to Entities, instead.</p>
<p class="calibre2">We also need to make an adjustment to the <kbd class="calibre11">TestableSpeakerRepository</kbd> class:</p>
<pre class="calibre19">internal class TestableSpeakerRepository : InMemorySpeakerRepository<br class="title-page-name"/>{<br class="title-page-name"/>  public IQueryable&lt;Speaker&gt; SpeakersCollection =&gt; Entities;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting Get to a generic method</h1>
                
            
            <article>
                
<p class="calibre2">Next on the list is the <kbd class="calibre11">Get</kbd> method. Just like with the <kbd class="calibre11">Create</kbd> method, copy all the contents into the generic repository and fix any errors that occur:</p>
<pre class="calibre19">public virtual T Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var entity = Entities.SingleOrDefault(e =&gt; e.Id == id);<br class="title-page-name"/><br class="title-page-name"/>  if (entity != null)<br class="title-page-name"/>  {<br class="title-page-name"/>    entity = CloneEntity(entity);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return entity;<br class="title-page-name"/>}</pre>
<p class="calibre2">This method turns out to be an easy one to copy. Now, delete the existing method in the speaker repository. No tests break this time so we can move on to the next method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting GetAll to a generic method</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">GetAll</kbd> is the easiest of the methods to convert. It doesn't even reference speakers textually:</p>
<pre class="calibre19">public virtual IQueryable&lt;T&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return Entities.Select(CloneEntity).AsQueryable();<br class="title-page-name"/>}</pre>
<p class="calibre2">Delete the existing method in the speaker repository and move on to the next method, update.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting Update to a generic method</h1>
                
            
            <article>
                
<p class="calibre2">The process for update is the same as with the other methods. Copy the body of the existing code, rename any speaker references to entity references, and then delete the existing method:</p>
<pre class="calibre19">public virtual T Update(T entity)<br class="title-page-name"/>{<br class="title-page-name"/>  var oldEntity = Entities.FirstOrDefault(s =&gt; s.Id == entity.Id);<br class="title-page-name"/>  var index = Entities.IndexOf(oldEntity);<br class="title-page-name"/><br class="title-page-name"/>  if (index == -1)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new EntityNotFoundException(entity.Id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Entities[index] = CloneEntity(entity);<br class="title-page-name"/><br class="title-page-name"/>  return CloneEntity(entity);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting Delete to a generic method</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">Delete</kbd> is a different story: every object is likely to have different requirements for deleting it. Some will actually be deleted and others, such as Speaker, will merely be flagged as deleted. For this and many other reasons, we choose to leave the <kbd class="calibre11">Delete</kbd> implementation up to concrete repositories and the generic repository will throw a not implemented exception instead.</p>
<p class="calibre2">Let's write a <kbd class="calibre11">Delete</kbd> test class just for this functionality. It should be short and quick:</p>
<pre class="calibre19">public class Delete<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItThrowsNotImplementException()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var repo = new InMemoryRepository&lt;TestEntity&gt;();<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = Record.Exception(() =&gt; repo.Delete(new TestEntity()));<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;NotImplementedException&gt; <br class="title-page-name"/>    (result.GetBaseException());<br class="title-page-name"/>     Assert.Equal("Delete is not avaliable for TestEntity", <br class="title-page-name"/>     result.Message);<br class="title-page-name"/>  } <br class="title-page-name"/>}</pre>
<pre class="calibre19">public class TestEntity : IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  public int Id { get; set; }<br class="title-page-name"/>}</pre>
<p class="calibre2">Writing this test also makes us change the generic repository from an abstract class to a normal class. Changing the class type makes us change the <kbd class="calibre11">CloneEntity</kbd> method from abstract to virtual:</p>
<pre class="calibre19">protected virtual T CloneEntity(T entity)<br class="title-page-name"/>{<br class="title-page-name"/>  return entity;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we can write the method that will pass the test:</p>
<pre class="calibre19">public virtual void Delete(T speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  throw new NotImplementedException($"Delete is not avaliable for {typeof(T).Name}");<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step three – reorient the tests to use the generic repository</h1>
                
            
            <article>
                
<p class="calibre2">We began this process when we dealt with the <kbd class="calibre11">Delete</kbd> method. But let's continue with the other methods. All the methods that were moved into the generic repository can have most of their tests moved as well.</p>
<p class="calibre2">We will be leaving the data integrity tests because they are directly tied to the functionality in the speaker repository. We will leave all the delete tests for the same reason.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">InMemoryRepository Create tests</h1>
                
            
            <article>
                
<p class="calibre2">To implement the rest of the functionality for the <kbd class="calibre11">InMemoryRepository</kbd>, we will start with the tests for the <kbd class="calibre11">Create</kbd> method:</p>
<pre class="calibre19">public class Create<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly TestableEntityRepository _repo;<br class="title-page-name"/><br class="title-page-name"/>  public Create()<br class="title-page-name"/>  {<br class="title-page-name"/>    _repo = new TestableEntityRepository();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Create(new TestEntity());<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItAddsAEntityToTheRepository()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Create(new TestEntity());<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(1, _repo.EntityCollection.Count());<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItAssignsUniqueIdsToEachEntity()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var entity1 = _repo.Create(new TestEntity());<br class="title-page-name"/>    var entity2 = _repo.Create(new TestEntity());<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotEqual(entity1.Id, entity2.Id);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<pre class="calibre19">internal class TestableEntityRepository : InMemoryRepository&lt;TestEntity&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  public IQueryable&lt;TestEntity&gt; EntityCollection =&gt; Entities;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">InMemoryRepository Get tests</h1>
                
            
            <article>
                
<p class="calibre2">Now that we can create using the <kbd class="calibre11">InMemoryRepository</kbd>, we should be able to accurately test the <kbd class="calibre11">Get</kbd> method:</p>
<pre class="calibre19">public class Get<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly InMemoryRepository&lt;TestEntity&gt; _repo;<br class="title-page-name"/><br class="title-page-name"/>  public Get()<br class="title-page-name"/>  {<br class="title-page-name"/>    _repo = new InMemoryRepository&lt;TestEntity&gt;();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Get(0);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsAnEntityWhenFound()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var entity = _repo.Create(new TestEntity() { Name = "Test Entity" });<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Get(entity.Id);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(result);<br class="title-page-name"/>    Assert.Equal("Test Entity", result.Name);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsNullWhenNotFound()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Null(result);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">InMemoryRepository GetAll tests</h1>
                
            
            <article>
                
<p class="calibre2">With getting a single object working, lets test getting all the objects:</p>
<pre class="calibre19">public class GetAll<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly InMemoryRepository&lt;TestEntity&gt; _repo;<br class="title-page-name"/><br class="title-page-name"/>  public GetAll()<br class="title-page-name"/>  {<br class="title-page-name"/>    _repo = new InMemoryRepository&lt;TestEntity&gt;();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.GetAll();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsNoEntitiesWhenThereAreNoEntities()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.GetAll();<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.NotNull(result);<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;IQueryable&lt;TestEntity&gt;&gt;(result);<br class="title-page-name"/>    Assert.Equal(0, result.Count());<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsASingleEntityWhenOnlyOneEntityExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    _repo.Create(new TestEntity { Name = "Test Entity" });<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(1, result.Count);<br class="title-page-name"/>    Assert.Equal("Test Entity", result.First().Name);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItReturnsManyEntitiesWhenManyEntitiesExist()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    _repo.Create(new TestEntity());<br class="title-page-name"/>    _repo.Create(new TestEntity());<br class="title-page-name"/>    _repo.Create(new TestEntity());<br class="title-page-name"/><br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(3, result.Count);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">InMemoryRepository Update tests</h1>
                
            
            <article>
                
<p class="calibre2">Last but not least, we will add the ability to update records using the <kbd class="calibre11">InMemoryRepository:</kbd></p>
<pre class="calibre19">public class Update<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly InMemoryRepository&lt;TestEntity&gt; _repo;<br class="title-page-name"/><br class="title-page-name"/>  public Update()<br class="title-page-name"/>  {<br class="title-page-name"/>    _repo = new InMemoryRepository&lt;TestEntity&gt;();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItExists()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var entity = _repo.Create(new TestEntity());<br class="title-page-name"/>   // Act<br class="title-page-name"/>    var result = _repo.Update(entity);<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItUpdatesAnEntity()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var entity = _repo.Create(new TestEntity(){ Name = "Test Name" });<br class="title-page-name"/>    entity.Name = "New Name";<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = _repo.Update(entity);<br class="title-page-name"/>   // Assert<br class="title-page-name"/>    Assert.Equal(entity.Name, result.Name);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItUpdatesAnEntityInTheRepository()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var entity = _repo.Create(new TestEntity() { Name = "Test Name" });<br class="title-page-name"/>    entity.Name = "New Name";<br class="title-page-name"/>   // Act<br class="title-page-name"/>    var updatedEntity = _repo.Update(entity);<br class="title-page-name"/>   // Audit<br class="title-page-name"/>    var result = _repo.Get(entity.Id);<br class="title-page-name"/>   // Assert<br class="title-page-name"/>    Assert.Equal("New Name", result.Name);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItThrowsNotFoundExceptionWhenEntityDoesNotExist()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var entity = new TestEntity { Id = 5, Name = "Test Name" };<br class="title-page-name"/>    // Act<br class="title-page-name"/>    var result = Record.Exception(() =&gt; _repo.Update(entity));<br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.IsAssignableFrom&lt;EntityNotFoundException&gt;(result.GetBaseException());<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We now have a generic repository that can be used with any data model as long as that data model has an ID. We also have a way to ensure data integrity if we need to, by inheriting and creating a method to clone the data object that we need to protect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Entity Framework</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre1">Object-Relation Mapping</strong> (<strong class="calibre1">ORM</strong>) frameworks such as Entity Framework help increase productivity and optimize code reuse and maintainability. However, you should not tightly couple your application to the ORM. Abstract away ORMs such as Entity Framework just as you would any third-party library or system.</p>
<p class="calibre2">Speaker Meet uses Entity Framework through a generic repository; in order to get started, add a NuGet reference to Entity Framework – Sql Server.</p>
<pre class="calibre19">Microsoft.EntityFrameworkCore.SqlServer</pre>
<p class="calibre2">Next, add a connection string to the <kbd class="calibre11">appsettings.json</kbd>:</p>
<pre class="calibre19"> "ConnectionStrings": {"DefaultConnection":   <br class="title-page-name"/> "Server=.;Database=SpeakerMeetBook;Trusted_Connection=True;MultipleAct<br class="title-page-name"/>  iveResultSets=true"}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DbContext</h1>
                
            
            <article>
                
<p class="calibre2">The latest version of Entity Framework, EF Core 2.0, has added DbContext pooling, which helps improve performance by saving some of the cost of initializing a new instance of the <kbd class="calibre11">DbContext</kbd> with each request.</p>
<p class="calibre2">Modify the <kbd class="calibre11">Startup.cs</kbd> ConfigureServices to reference the connection string:</p>
<pre class="calibre19"> var connectionString =   <br class="title-page-name"/>  Configuration.GetConnectionString("DefaultConnection");<br class="title-page-name"/> services.AddDbContextPool&lt;SpeakerMeetContext&gt;(options =&gt;   <br class="title-page-name"/>  options.UseSqlServer(connectionString));</pre>
<p class="calibre2">Add a <kbd class="calibre11">DbContext</kbd> to your application. Create a new file named <kbd class="calibre11">SpeakerMeetContext</kbd> with options as follows:</p>
<pre class="calibre19">using Microsoft.EntityFrameworkCore;<br class="title-page-name"/><br class="title-page-name"/>namespace SpeakerMeet.Api.Entities<br class="title-page-name"/>{<br class="title-page-name"/>  public class SpeakerMeetContext : DbContext<br class="title-page-name"/>  {<br class="title-page-name"/>    public SpeakerMeetContext(DbContextOptions&lt;SpeakerMeetContext&gt; options) : base(options)<br class="title-page-name"/>    { }<br class="title-page-name"/><br class="title-page-name"/>    public virtual DbSet&lt;Speaker&gt; Speakers { get; set; }<br class="title-page-name"/><br class="title-page-name"/>    protected override void OnModelCreating(ModelBuilder modelBuilder)<br class="title-page-name"/>    {<br class="title-page-name"/>      modelBuilder.Entity&lt;Speaker&gt;().ToTable("Speaker");<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Models</h1>
                
            
            <article>
                
<p class="calibre2">Entity Framework models may contain additional information that you might not necessarily want to expose to other parts of the system or application consumers. Create a new model named <kbd class="calibre11">Speaker</kbd>. This will be the model used by Entity Framework and the generic repository. The services or business layer will be responsible for converting the Entity Framework models to <strong class="calibre1">Data Transfer Objects</strong> (<strong class="calibre1">DTOs</strong>) or ViewModels used by the rest of the application:</p>
<pre class="calibre19">using System.ComponentModel.DataAnnotations;<br class="title-page-name"/><br class="title-page-name"/>namespace SpeakerMeet.Api.Entities<br class="title-page-name"/>{<br class="title-page-name"/>  public class Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    public int Id { get; set; }<br class="title-page-name"/><br class="title-page-name"/>    [Required]<br class="title-page-name"/>    [StringLength(50)]<br class="title-page-name"/>    public string Name { get; set; }<br class="title-page-name"/><br class="title-page-name"/>    [Required]<br class="title-page-name"/>    [StringLength(50)]<br class="title-page-name"/>    public string Location { get; set; }<br class="title-page-name"/><br class="title-page-name"/>    [Required]<br class="title-page-name"/>    [StringLength(255)]<br class="title-page-name"/>    public string EmailAddress { get; set; }<br class="title-page-name"/><br class="title-page-name"/>    public bool IsDeleted { get; set; }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generic repository</h1>
                
            
            <article>
                
<p class="calibre2">In order to see the Entity Framework specific Generic repository run you may want to add the following class to your application:</p>
<pre class="calibre19">using System;<br class="title-page-name"/>using System.Linq;<br class="title-page-name"/>using Microsoft.EntityFrameworkCore;<br class="title-page-name"/><br class="title-page-name"/>namespace SpeakerMeet.Api.Repository<br class="title-page-name"/>{<br class="title-page-name"/>  public class Repository&lt;T&gt; : IRepository&lt;T&gt; where T : class<br class="title-page-name"/>  {<br class="title-page-name"/>    private readonly DbSet&lt;T&gt; _dbSet;<br class="title-page-name"/>    protected readonly DbContext Context;<br class="title-page-name"/><br class="title-page-name"/>    public Repository(DbContext context)<br class="title-page-name"/>    {<br class="title-page-name"/>      Context = context;<br class="title-page-name"/>      _dbSet = context.Set&lt;T&gt;();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public T Create(T entity)<br class="title-page-name"/>    {<br class="title-page-name"/>      throw new NotImplementedException();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public T Get(int id)<br class="title-page-name"/>    {<br class="title-page-name"/>      return _dbSet.Find(id);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public IQueryable&lt;T&gt; GetAll()<br class="title-page-name"/>    {<br class="title-page-name"/>      return _dbSet;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public T Update(T speaker)<br class="title-page-name"/>    {<br class="title-page-name"/>      throw new NotImplementedException();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public void Delete(T entity)<br class="title-page-name"/>    {<br class="title-page-name"/>      throw new NotImplementedException();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection</h1>
                
            
            <article>
                
<p class="calibre2">In order to wire everything up, the Speaker Meet application leverages the built in <strong class="calibre1">Dependency Injection</strong> (<strong class="calibre1">DI</strong>) container. Dependency Injection allows the system to be loosely coupled. There are ways to achieve this without the use of a container (poor man’s DI, and so on) which will be covered in a later chapter. The tests themselves do not rely on DI, instead opting to instantiate classes as needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Wire it all up</h1>
                
            
            <article>
                
<p class="calibre2">In order to configure the DI container, add the following to ConfigureServices in <kbd class="calibre11">Startup.cs</kbd>:</p>
<pre class="calibre19">services.AddSingleton(typeof(DbContext), typeof(SpeakerMeetContext));<br class="title-page-name"/>services.AddScoped(typeof(IRepository&lt;&gt;), typeof(Repository&lt;&gt;));<br class="title-page-name"/>services.AddTransient&lt;ISpeakerService, SpeakerService&gt;();<br class="title-page-name"/>services.AddTransient&lt;IGravatarService, GravatarService&gt;();</pre>
<p class="calibre2">This will avoid the need to instantiate the <kbd class="calibre11">SpeakerService</kbd> from within the <kbd class="calibre11">SpeakerController</kbd>. The DI container handles this for you.</p>
<p class="calibre2">If you've created your database and populated the speaker table, you now should be able to run the application and hit the <kbd class="calibre11">SpeakerController</kbd> endpoints. Give it a shot!</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">http://localhost:41436/api/speaker/</kbd></li>
<li class="calibre8"><kbd class="calibre11">http://localhost:41436/api/speaker/1</kbd></li>
<li class="calibre8"><kbd class="calibre11">http://localhost:41436/api/speaker/search?searchString=test</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Postman</h1>
                
            
            <article>
                
<p class="calibre2">There are a variety of tools available for manually exercising an API. Postman is just one such tool and is a favorite in the industry. Postman offers a lot of functionality to help you with your API development and testing. It's worth a look if you're interested.</p>
<p class="calibre2">To install Postman, simply visit the website (<a href="http://www.getpostman.com" class="calibre10">http://www.getpostman.com</a>) and follow the instructions. With the Speaker Meet application running, enter the URL (example: <kbd class="calibre11">http://localhost:41436/api/speaker/search</kbd>) into the box, add params (example: <kbd class="calibre11">[{"key":"searchString","value":"te","description":""}]</kbd>), and hit <span>Send</span>. The response shows as JSON by default in the body of the message.</p>
<p class="calibre2">This can be an extremely powerful tool. As the complexity and feature set of the Speaker Meet API grows, more complex messages can be sent with <kbd class="calibre11">POST</kbd>, <kbd class="calibre11">PUT</kbd>, <kbd class="calibre11">PATCH</kbd>, and <kbd class="calibre11">DELETE</kbd>. These will be covered in a later chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was all about abstraction: when and how to use it. You should now see why it's so important to create abstractions between code you write yourself and that of a third party. You should also have a good idea of how those abstractions can be achieved.</p>
<p class="calibre2">In this chapter, we abstracted a Gravatar service, extended the repository pattern, and used a generic repository for Entity Framework.</p>
<p class="calibre2">In <a target="_blank" href="part0318.html#9F8IS0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 9</a>, <em class="calibre12">Testing JavaScript Applications</em>, we'll focus on testing JavaScript applications. We'll walk through creating a React application and discuss different approaches to testing a JavaScript application.</p>


            </article>

            
        </section>
    </body></html>