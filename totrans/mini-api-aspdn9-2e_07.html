<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-91">
    <a id="_idTextAnchor119">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-92">
    <a id="_idTextAnchor120">
    </a>
    
     Dependency Injection in Minimal APIs
    
   </h1>
   <p>
    
     In any software project, developers rarely craft the application entirely from scratch.
    
    
     At some level, generic libraries and toolsets will be absorbed into the application to accelerate and optimize the project.
    
    <strong class="bold">
     
      ASP.NET
     
    </strong>
    
     as a
    
    <a id="_idIndexMarker230">
    </a>
    
     framework is no different.
    
    
     In fact, it requires that developers take on dependencies; third-party or independently created code that plays a key role in the smooth running of
    
    
     
      the system.
     
    
   </p>
   <p>
    
     The result is a (hopefully) finely tuned and well-designed architecture, formed of modules and components, some of which run code that was written by developers on the project, and the rest being more generic, boilerplate code that was written and pre-compiled before the
    
    
     
      project started.
     
    
   </p>
   <p>
    
     Keeping track of dependencies
    
    <a id="_idIndexMarker231">
    </a>
    
     is one of the classic problems facing software developers, and the problems that arise from this can progress to a point that results in what the industry refers to as
    
    <strong class="bold">
     
      dependency hell
     
    </strong>
    
     – a
    
    <a id="_idIndexMarker232">
    </a>
    
     nightmarish scenario in which developers are retracing their steps, trying to figure out where a dependency was introduced, and finding ways that they can overcome the challenge of conflicting dependencies across a potentially massive
    
    
     
      code base.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Dependency injection
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DI
     
    </strong>
    
     ) is a
    
    <a id="_idIndexMarker233">
    </a>
    
     way of standardizing and simplifying the experience of consuming dependencies in
    
    
     
      software projects.
     
    
   </p>
   <p>
    
     In this chapter, we are going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      
       Understanding DI
      
     
    </li>
    <li>
     
      Configuring DI in
     
     
      
       minimal APIs
      
     
    </li>
    <li>
     
      DI
     
     
      
       best practices
      
     
    </li>
   </ul>
   <p>
    
     By the end of the chapter, you will have improved your understanding of DI principles, as well as the benefits they can bring to minimal APIs and ASP.NET projects
    
    
     
      in general.
     
    
   </p>
   <p>
    
     You will also have gained practical experience in the configuration of DI containers and registration
    
    
     
      of services.
     
    
   </p>
   <p>
    
     Let us start by improving our understanding
    
    
     
      of DI.
     
    
   </p>
   <h1 id="_idParaDest-93">
    <a id="_idTextAnchor121">
    </a>
    
     Understanding DI
    
   </h1>
   <p>
    
     DI
    
    <a id="_idIndexMarker234">
    </a>
    
     started out as a design pattern in software development, aimed at centralizing common dependencies and making them available to consumers in a
    
    
     
      consistent manner.
     
    
   </p>
   <p>
    
     Using this approach, common development tasks such as testing, swapping out dependencies, modification of dependency logic, centralization of dependencies, and so on, can be easily achieved through one
    
    
     
      straightforward system.
     
    
   </p>
   <p>
    
     Over time, .NET made DI more of a feature rather than just a design pattern.
    
    
     In ASP.NET, there is a robust DI toolset that is simple to use
    
    
     
      and understand.
     
    
   </p>
   <p>
    
     Developers can register their dependencies in a centralized location, making them available to
    
    <em class="italic">
     
      inject
     
    </em>
    
     into the constructors of classes as arguments when they
    
    
     
      are instantiated.
     
    
   </p>
   <p>
    
     With DI, dependencies live within a
    
    <em class="italic">
     
      container
     
    </em>
    
     , making them centrally available to consuming classes.
    
    
     But what is
    
    
     
      a container?
     
    
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor122">
    </a>
    
     The DI container
    
   </h2>
   <p>
    
     On the startup of your application, dependencies are registered in the container.
    
    
     The
    
    <strong class="bold">
     
      container
     
    </strong>
    
     is simply
    
    <a id="_idIndexMarker235">
    </a>
    
     a group of dependencies that have been registered for DI.
    
    
     Each of the dependencies has a lifetime specification that defines how they are instantiated when injected into a
    
    <a id="_idIndexMarker236">
    </a>
    
     consuming class.
    
    
     We’ll explore dependency lifetimes in more detail later in
    
    
     
      the chapter.
     
    
   </p>
   <p>
    
     When a class that has a dependency is instantiated, it reaches out to the container, which takes care of the business of resolving the dependency and instantiating it according to the lifetime setting that was configured when the dependency
    
    
     
      was registered.
     
    
   </p>
   <p>
    
     It might sound like this is an extra layer of complexity for something as simple as using a class within another, but there is good reason for mandating the use of DI as a best practice.
    
    
     Let us explore this in
    
    
     
      more detail.
     
    
   </p>
   <h2 id="_idParaDest-95">
    <a id="_idTextAnchor123">
    </a>
    
     The case for DI
    
   </h2>
   <p>
    
     Think back to your
    
    <a id="_idIndexMarker237">
    </a>
    
     career to date as a software engineer.
    
    
     Whether you’re still at the beginning, or you’ve been doing this for a while, you may have spent considerable time
    
    <em class="italic">
     
      newing up
     
    </em>
    
     dependencies in the form
    
    
     
      of classes.
     
    
   </p>
   <p>
    
     Let’s say you’re building an API endpoint that needs to reach into a SQL database.
    
    
     (I’m deliberately not using Entity Framework for this example for simplicity.) You may have already created a class that abstracts away the specifics (we’ll call it
    
    <strong class="source-inline">
     
      SqlHelper
     
    </strong>
    
     ), such as creating an instance of
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     , opening the connection, building
    
    <strong class="source-inline">
     
      SqlCommand
     
    </strong>
    
     , and so on.
    
    
     What do you think you’ll need to do each time you realize that you need this
    
    
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
    
    
     
      class?
     
    
   </p>
   <p>
    
     The first thing you’ll notice is that you have to create a new instance of
    
    <strong class="source-inline">
     
      SqlHelper
     
    </strong>
    
     at any point that the need for interaction with your SQL Server arises.
    
    
     On the face of it, this sounds harmless enough, but from a design perspective, it’s problematic.
    
    
     Let’s look at the potential pitfalls of this approach a little
    
    
     
      more closely:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Tight coupling
      
     </strong>
     
      : Without
     
     <a id="_idIndexMarker238">
     </a>
     
      DI, you create a concrete implementation of
     
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
     
      each time you use it.
     
     
      Whenever you have a concrete implementation of a class, you run the risk of being forced to change each class that consumes it if you need to significantly change
     
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
     
      .
     
     
      This means that your consuming classes become tightly coupled
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        SqlHelper
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Difficulties in testing
      
     </strong>
     
      : Being able to mock dependencies is critical to effective testing.
     
     
      Without DI, you will have to be more hands-on in ensuring that dependencies are properly instantiated, mocked, and then accessible for each test.
     
     
      The added need for manual instantiation increases the potential for mistakes in setting up the tests.
     
     
      This is problematic because it can make your
     
     
      
       tests unreliable.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Resource management issues
      
     </strong>
     
      : When dependencies are using resources as
     
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
     
      is (it will have a connection to a SQL Server), there is always the risk that those resources are not managed effectively.
     
     
      In the case of something like a SQL connection, spinning up a lot of these connections over time without adequate disposal could exhaust the connections, leading to
     
     
      
       performance issues.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Violation of single responsibility, open-closed principle, Liskov substitution, interface segregation principle, dependency inversion principle (SOLID) principles
      
     </strong>
     
      : We’ve not yet explored SOLID principles in this book, but they are an important part of any object-oriented software system.
     
     
      One of the guiding principles of SOLID
     
     <a id="_idIndexMarker239">
     </a>
     
      is
     
     <em class="italic">
      
       single responsibility
      
     </em>
     
      , in which we
     
     <a id="_idIndexMarker240">
     </a>
     
      are expected to ensure that classes have a primary responsibility.
     
     
      In the case of a class consuming
     
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
     
      , their primary responsibility is to the logic that is requesting or manipulating data.
     
     
      Forcing the class to instantiate
     
     <strong class="source-inline">
      
       SqlHelper
      
     </strong>
     
      means you’re giving it a new responsibility; a responsibility of managing its own dependencies.
     
     
      DI removes this added responsibility, simply passing the
     
     <a id="_idIndexMarker241">
     </a>
     
      dependencies into the class when the class
     
     
      
       is constructed.
      
     
    </li>
   </ul>
   <p>
    
     Hopefully, this breakdown has painted a picture of how not using DI can make your code base inconsistent and messy.
    
    
     Now, let us explore how DI is achieved
    
    
     
      in ASP.NET.
     
    
   </p>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor124">
    </a>
    
     Configuring DI in minimal APIs
    
   </h1>
   <p>
    
     As standard, ASP.NET
    
    <a id="_idIndexMarker242">
    </a>
    
     offers a way for us to
    
    <a id="_idIndexMarker243">
    </a>
    
     declare that a class we have created can be registered as a service.
    
    
     Converting a class into a service means it can be reused via DI.
    
    
     For example, say you’ve got a piece of logic that calculates overtime pay for any given employee.
    
    
     That logic is the same, but you’ll need it in many other areas of the code base.
    
    
     To avoid writing the same logic again, it’s obvious that you would simply call on the same logic, but as we’ve already discussed, creating a new instance of the class to get to this logic whenever you need it is messy; so, by registering the class as a service, we can cleanly inject it into any other class that
    
    
     
      needs it.
     
    
   </p>
   <p>
    
     Moreover, DI allows us to control the life cycle of the service when it is injected.
    
    
     In essence, we can dictate how the dependency is instantiated on each injection and how long it
    
    
     
      should exist.
     
    
   </p>
   <p>
    
     There are three built-in lifetime options
    
    
     
      in ASP.NET:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Singleton
      
     </strong>
     
      : The service is created once, as a single instance.
     
     
      This instance is then shared across the code
     
     <a id="_idIndexMarker244">
     </a>
     
      base.
     
     
      This can be useful when you need to maintain state on a global scale.
     
     
      Logging is a good use case for this, as all log entries can be channeled through one single service that has access to the relevant output resource.
     
     
      For example, a  logging service that creates logs in
     
     
      
       a file.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scoped
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker245">
     </a>
     
      service is created once for every incoming request.
     
     
      This means that when a client makes a request to the API, a service is created when needed and that instance is in use for the duration of the request.
     
     
      This is ideal when you need to manage state within a request.
     
     
      It is also favorable if you do not want to share the same service between
     
     
      
       different requests.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Transient
      
     </strong>
     
      : The service
     
     <a id="_idIndexMarker246">
     </a>
     
      has an instance created every time it is injected.
     
     
      This means that regardless of the request being made to the API, each time a service is injected, that service will be a new instance.
     
     
      This is ideal for scenarios where state does not need to
     
     
      
       be maintained.
      
     
    </li>
   </ul>
   <p>
    
     Let’s set up a new minimal API project to use as an example of how we can benefit
    
    
     
      from DI.
     
    
   </p>
   <p>
    
     Please note, if you haven’t read them already, refer to the first two chapters to understand how you can create a new minimal API project.
    
    
     This will allow you to follow along with the examples in
    
    
     
      this chapter.
     
    
   </p>
   <h2 id="_idParaDest-97">
    <a id="_idTextAnchor125">
    </a>
    
     Setting up a scoped DI project
    
   </h2>
   <p>
    
     For our new API project, we’re
    
    <a id="_idIndexMarker247">
    </a>
    
     going to use the example of an order-processing API.
    
    
     It will contain a series of products or services that can be put together to create
    
    
     
      an order.
     
    
   </p>
   <p>
    
     First, we need models to represent products and orders.
    
    
     Create two classes,
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Order
     
    </strong>
    
     .
    
    
     In the first code, we create the
    
    
     <strong class="source-inline">
      
       Product
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public float RRP { get; set; }
    }</pre>
   <p>
    
     In the following code, we create the
    
    
     <strong class="source-inline">
      
       Order
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
    public class Order
    {
        public int Id { get; set; }
        public List&lt;Product&gt; Products { get; set; }
        public decimal DiscountAmount { get; set; }
        public DateTime DeliveryDate { get; set; }
    }</pre>
   <p>
    
     We need to be able to refer to a collection of available products.
    
    
     Ordinarily, we would store this information in a database and then use either
    
    <strong class="source-inline">
     
      SqlConnection
     
    </strong>
    
     or an
    
    <strong class="bold">
     
      Object Relational Mapping
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ORM
     
    </strong>
    
     ) framework, such as  Microsoft’s Entity Framework, to
    
    <a id="_idIndexMarker248">
    </a>
    
     access
    
    <a id="_idIndexMarker249">
    </a>
    
     the database, mapping the data to the models (
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Order
     
    </strong>
    
     ) we’ve created.
    
    
     However, database connections are not within the scope of this chapter and will be covered later in
    
    
     
      the book.
     
    
   </p>
   <p>
    
     For now, and for simplicity, we will simply create a JSON file containing an array of objects that can be read into the project as text and deserialized into the strongly typed object,
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     .
    
    
     I’ve created an example of five products that can be saved in JSON format, in the following code.
    
    
     Feel free to copy my examples or create your own.
    
    
     Whatever you do, save the products in a file called
    
    <strong class="source-inline">
     
      Products.json
     
    </strong>
    
     in an accessible location.
    
    
     Ensure that each project is a JSON object contained within a single JSON array and that the values you use match the data types of the properties in
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     ; otherwise, it will not be possible to deserialize
    
    
     
      the JSON:
     
    
   </p>
   <pre class="source-code">
[
    {
        "Id": 1,
        "Name": "Laptop",
        "Description": "A high-performance laptop suitable
                       for all your computing needs.",
        "RRP": 999.99
    },
    {
        "Id": 2,
        "Name": "Smartphone",
        "Description": "A latest generation smartphone with
                       a stunning display and excellent
                       camera.",
        "RRP": 799.99
    },
    {
        "Id": 3,
        "Name": "Headphones",
        "Description": "Noise-cancelling headphones with
                       superior sound quality.",
        "RRP": 199.99
    },
    {
        "Id": 4,
        "Name": "Smartwatch",
        "Description": "A smartwatch with fitness tracking
                       and health monitoring features.",
        "RRP": 299.99
    },
    {
        "Id": 5,
        "Name": "Tablet",
        "Description": "A lightweight tablet with a vibrant
                       display, perfect for entertainment
                       on the go.",
        "RRP": 399.99
    }
]</pre>
   <p>
    
     Now, let’s create a means of bringing these objects into memory when they are needed.
    
    
     (Again, not the most efficient example as we’re not using a database, but we will be covering database usage later in
    
    
     
      the book.)
     
    
   </p>
   <p>
    
     For this example, we’ll
    
    <a id="_idIndexMarker250">
    </a>
    
     do this by creating a class, called
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     .
    
    
     This class can be used to access a list of objects of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       Product
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Add the
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     class as per the
    
    
     
      example here:
     
    
   </p>
   <pre class="source-code">
public class ProductRepository
{
    public List&lt;Product&gt; Products { get; private set; }
}</pre>
   <p>
    
     As you can see, this
    
    <a id="_idIndexMarker251">
    </a>
    
     is a very simple class that just holds a list of
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     .
    
    
     We need to somehow populate this list with the JSON objects we’ve saved as text.
    
    
     We could very easily just fetch the items when we instantiate the class, but we want to do this using an injected service, so we’ll come back to
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     shortly.
    
    
     Before that, let’s create a service that will have the responsibility of retrieving the products from the text file.
    
    
     We’ll call
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       ProductRetrievalService
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
    public class ProductRetrievalService
    {
        private const string _dataPath =
            @"C:/Products.json";
        public List&lt;Product&gt; LoadProducts()
        {
            var productJson = File.ReadAllText(_dataPath);
            return JsonSerializer
                .Deserialize&lt;List&lt;Product&gt;&gt;(
                    productJson
                );
        }
    }</pre>
   <p>
    
     This simple service reads the contents of the JSON file and uses the
    
    <strong class="source-inline">
     
      JsonSerializer
     
    </strong>
    
     class found within
    
    <strong class="source-inline">
     
      System.Text.Json
     
    </strong>
    
     to convert, or deserialize, the JSON content into the strongly typed
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     type, putting each
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     into
    
    
     
      the list.
     
    
   </p>
   <p class="callout-heading">
    
     Permissions on C:/
    
   </p>
   <p class="callout">
    
     If you have trouble writing or reading from
    
    <strong class="source-inline">
     
      C:/
     
    </strong>
    
     , you may not have permission to do so.
    
    
     You can work around this by creating a folder in a location to which you do have read/write permissions, and then change the path in the code to match the
    
    
     
      new one.
     
    
   </p>
   <p>
    
     At this point, the products have been retrieved.
    
    
     This means that we can simply call
    
    <strong class="source-inline">
     
      LoadProducts()
     
    </strong>
    
     and we will always get the latest data.
    
    
     However, how do we access
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     to do this?
    
    
     Our
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     class will need this logic in order to populate its
    
    
     <strong class="source-inline">
      
       Product
      
     </strong>
    
    
     
      list.
     
    
   </p>
   <p>
    
     Here is where DI becomes useful.
    
    
     We can inject an instance of
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     any time we use
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     .
    
    
     To make this possible, we first need to register
    
    <strong class="source-inline">
     
      ProductRetreivalService
     
    </strong>
    
     as
    
    
     
      a service.
     
    
   </p>
   <p>
    
     The following code
    
    <a id="_idIndexMarker252">
    </a>
    
     demonstrates registration of this service for DI
    
    
     
      within
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public static void Main(string[] args)
{
    var builder = WebApplication.CreateBuilder(args);
    builder.Services.AddScoped&lt;ProductRetrievalService&gt;();
    var app = builder.Build();
    app.Run();
}</pre>
   <p>
    
     By adding
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     as a scoped service, an instance will be created for the duration of the incoming request.
    
    
     Now that it is registered, we can inject
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     into
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     when we instantiate it, via its constructor.
    
    
     Let us look at an example of this in an API
    
    
     
      endpoint example.
     
    
   </p>
   <p>
    
     Create a new HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method, mapped onto the
    
    <strong class="source-inline">
     
      getProductById
     
    </strong>
    
     route, as shown in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
    app.MapGet("/getProductById/{id}", (int id) =&gt;
    {
    });</pre>
   <p>
    
     The endpoint takes an integer parameter in the form of the product ID.
    
    
     We can now use this to get the product with the matching ID.
    
    
     First things first, let’s add a new instance of
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     to
    
    
     
      the endpoint:
     
    
   </p>
   <pre class="source-code">
  app.MapGet("/getProductById{id}", (int id) =&gt;
  {
      var productRepository = new ProductRepository();
  });</pre>
   <p>
    
     We have a
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     instance now, which has a list of
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     , but this list is empty.
    
    
     We need
    
    <a id="_idIndexMarker253">
    </a>
    
     to modify
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     to inject
    
    <strong class="source-inline">
     
      ProductRetreivalService
     
    </strong>
    
     , to populate that list.
    
    
     The following code shows an example of how the service can be injected into
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     via the constructor before being used to populate the products held within
    
    
     
      a
     
    
    
     <strong class="source-inline">
      
       List&lt;Product&gt;
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public class ProductRepository
{
    public List&lt;Product&gt; Products { get; private set; }
    public ProductRepository(
        ProductRetrievalService productRetrievalService
    )
    {
        Products = productRetrievalService.LoadProducts();
    }
}</pre>
   <p>
    
     Now, we should be able to use some logic in the endpoint to get the relevant product from
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     .
    
    
     However, we have a problem.
    
    
     If we try to instantiate a new instance of
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     in the endpoint, we will see
    
    
     
      an error.
     
    
   </p>
   <p>
    
     The reason we see an error is that we have changed the way
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     is instantiated.
    
    
     It now requires a
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     to be passed as an argument to the constructor, but how are we supposed to get hold
    
    
     
      of this?
     
    
   </p>
   <p>
    
     This is where minimal APIs allow us to, within an endpoint, take advantage of services registered within the
    
    
     
      DI container.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      ProductRetreivalService
     
    </strong>
    
     can be passed as an argument within the parameters we pass into the lambda expression within the body of the endpoint.
    
    
     This makes it the same as the ID parameter passed in by the client, except it’s not coming from the client, it’s coming from the
    
    
     
      DI container.
     
    
   </p>
   <p>
    
     To make this possible, you
    
    <a id="_idIndexMarker254">
    </a>
    
     need to prefix the
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     argument with an attribute that indicates that it was injected.
    
    
     This attribute
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       [FromServices]
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Injecting
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     with this attribute will now allow us to pass the required
    
    <strong class="source-inline">
     
      ProductRetrievalService
     
    </strong>
    
     to the constructor of
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     , as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/getProductById/{id}",
    (
        int id,
        [FromServices] ProductRetrievalService
            productRetrievalService
    ) =&gt;
    {
    var productRepository = new ProductRepository(
        productRetrievalService
    );
    return Results.Ok(
        productRepository.Products
            .FirstOrDefault(x =&gt; x.Id == id)
    );
});</pre>
   <p>
    
     It is also worth
    
    <a id="_idIndexMarker255">
    </a>
    
     noting that the instance of
    
    <strong class="source-inline">
     
      ProductRepository
     
    </strong>
    
     we created in this example could itself be injected into the class
    
    
     
      using DI.
     
    
   </p>
   <p>
    
     Let’s move on to our next
    
    
     
      example now.
     
    
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor126">
    </a>
    
     Creating a singleton DI project
    
   </h2>
   <p>
    
     Let’s look at another example, but
    
    <a id="_idIndexMarker256">
    </a>
    
     this time, we’ll use a different life cycle for the dependency.
    
    
     In this use case, we will create an endpoint for creating an order.
    
    
     The incoming
    
    <strong class="source-inline">
     
      Order
     
    </strong>
    
     object will have a list of
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     that can be used to submit a new customer order into the system.
    
    
     However, we also need to establish a
    
    
     
      delivery date.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     To avoid repeating ourselves, we can for this example, simply use a collection such as
    
    <strong class="source-inline">
     
      List&lt;DateTime&gt;
     
    </strong>
    
     rather than feeding them in from a
    
    
     
      JSON file.
     
    
   </p>
   <p>
    
     Let’s imagine that there is a feed of upcoming available dates that are centrally managed.
    
    
     We could create a service that has the available context to be able to choose the next available date.
    
    
     This decouples the logic from the endpoint and can be reused in
    
    
     
      other endpoints.
     
    
   </p>
   <p>
    
     The code shows an example of this kind
    
    
     
      of service:
     
    
   </p>
   <pre class="source-code">
public class DeliveryDateBookingService
{
    private ConcurrentQueue&lt;DateTime&gt;
        _availableDates = new ConcurrentQueue&lt;DateTime&gt;();
    public DeliveryDateBookingService()
    {
        _availableDates.Enqueue(DateTime.Now.AddDays(1));
        _availableDates.Enqueue(DateTime.Now.AddDays(2));
        _availableDates.Enqueue(DateTime.Now.AddDays(3));
        _availableDates.Enqueue(DateTime.Now.AddDays(4));
        _availableDates.Enqueue(DateTime.Now.AddDays(5));
    }
    public DateTime GetNextAvailableDate()
    {
        if(_availableDates.Count == 0)
        {
            throw new Exception("No Dates Available");
        }
        var dequeuedDate = _availableDates
            .TryDequeue(out var result);
        if (dequeuedDate == false)
        {
            throw new Exception("An error occured");
        }
        return result;
    }
}</pre>
   <p>
    
     This service allows requests to get the next available date, throwing an exception if there is no date available.
    
    
     We have a queue to hold the available dates so they can be removed as they are retrieved to ensure that the same date is not
    
    
     
      offered twice.
     
    
   </p>
   <p>
    
     We also must consider thread safety here.
    
    
     You could have multiple requests all trying to get an available date, which is very likely to lead to a race condition, where two requests end up dequeuing the same available date.
    
    
     To avoid this, we are using
    
    <strong class="source-inline">
     
      ConcurrentQueue
     
    </strong>
    
     , which will handle the business of ensuring thread safety
    
    
     
      between requests.
     
    
   </p>
   <p>
    
     We now need to register this
    
    <a id="_idIndexMarker257">
    </a>
    
     as a service that can be injected into the endpoint that posts the order.
    
    
     With multiple requests in mind, we want to ensure that all requests are retrieving dates from the same list.
    
    
     Therefore, we will register the service using
    
    <strong class="source-inline">
     
      AddSingleton()
     
    </strong>
    
     , which will ensure that only one instance of the service is used between threads and requests
    
    
     
      during injection.
     
    
   </p>
   <p>
    
     Once the service has been registered in this way,
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     should look like the code
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication
                .CreateBuilder(args);
            builder.Services
                .AddScoped&lt;ProductRetrievalService&gt;();
            builder.Services
                .AddSingleton&lt;DeliveryDateBookingService&gt;()
                ;
            var app = builder.Build();
            app.MapGet("/getProductById/{id}",
                (int id,
                [FromServices] ProductRetrievalService
                productRetreivalService) =&gt;
            {
                var productRepository = new
                    ProductRepository(
                        productRetreivalService
                );
                return Results.Ok(
                    productRepository.Products
                        .FirstOrDefault(
                            x =&gt; x.Id == id)
                );
            });
            app.Run();
        }
    }</pre>
   <p>
    
     Now that the API has our second service registered, it is time to create the endpoint for creating
    
    
     
      an order.
     
    
   </p>
   <p>
    
     Seeing as we are creating a new record, we should use a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method to achieve our goal.
    
    
     The
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method will take in a JSON object, which is implicitly parsed into an
    
    <strong class="source-inline">
     
      Order
     
    </strong>
    
     object within the
    
    
     
      endpoint parameter.
     
    
   </p>
   <p>
    
     Following this, we indicate
    
    <a id="_idIndexMarker258">
    </a>
    
     that we are injecting
    
    <strong class="source-inline">
     
      DeliveryDateBookingService
     
    </strong>
    
     into
    
    
     
      the request.
     
    
   </p>
   <p>
    
     Once this is done, we can complete the endpoint by adding the relevant logic to the body of the
    
    
     
      lambda expression.
     
    
   </p>
   <p>
    
     The endpoint with logic for fetching the next delivery date is
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
  app.MapPost(
      "/order",
      (Order order,
       [FromServices] DeliveryDateBookingService
       deliveryDateBookingService) =&gt;
  {
      order.DeliveryDate =
          deliveryDateBookingService.GetNextAvailableDate()
          ;
      // save order to repository
  });</pre>
   <p>
    
     Whilst we created a repository for
    
    <strong class="source-inline">
     
      Product
     
    </strong>
    
     , we have not yet created one for
    
    <strong class="source-inline">
     
      Order
     
    </strong>
    
     .
    
    
     Furthermore, we did not demonstrate saving entities to their
    
    
     
      respective repositories.
     
    
   </p>
   <p>
    
     This kind of logic will be covered later in the book as we explore design patterns (such as the repository pattern) and data sources, but for now, here is an example of how you can save the new order in the
    
    
     
      preceding endpoint:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       OrderRetreivalService
      
     </strong>
     
      class so we stay consistent in using a service to retrieve entities (as we did
     
     
      
       for products):
      
     
     <pre class="source-code">
public class OrderRetrievalService
{
    private const string _dataPath =
        @"C:/Orders.json";
    public List&lt;Order&gt; LoadOrders()
    {
        var ordersJson = File.ReadAllText(_dataPath);
        return JsonSerializer
            .Deserialize&lt;List&lt;Order&gt;&gt;(ordersJson);
    }
}</pre>
    </li>
    <li>
     
      Register
     
     <strong class="source-inline">
      
       OrderRetrievalService
      
     </strong>
     
      as a scoped service in the DI container
     
     
      
       within
      
     
     
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
            builder.Services
                .AddScoped&lt;OrderRetrievalService&gt;();</pre>
    </li>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       OrderRespository
      
     </strong>
     
      class that follows the same style as
     
     <strong class="source-inline">
      
       ProductRespository
      
     </strong>
     
      .
     
     
      The added difference is that a
     
     <strong class="source-inline">
      
       SaveOrder()
      
     </strong>
     
      method is added to allow
     
     <a id="_idIndexMarker259">
     </a>
     
      for saving the
     
     <strong class="source-inline">
      
       Order
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      endpoint.
     
     
      Also, the collection being used to hold the orders is
     
     <strong class="source-inline">
      
       ConcurrentQueue&lt;Order&gt;
      
     </strong>
     
      rather than a list.
     
     
      This is because we expect orders to be saved from multiple concurrent requests and we need to allow for
     
     
      
       thread safety:
      
     
     <pre class="source-code">
public class OrderRepository
{
    public ConcurrentQueue&lt;Order&gt;
        Orders { get; private set; }
    public OrderRepository(
        OrderRetrievalService orderRetrievalService)
    {
        var retrievedOrders =
            orderRetrievalService.LoadOrders();
        foreach (var order in retrievedOrders)
        {
            Orders.Enqueue(order);
        }
    }
    public void SaveOrder(Order order)
    {
        Orders.Enqueue(order);
    }
}</pre>
    </li>
    <li>
     
      Register
     
     <strong class="source-inline">
      
       OrderRepository
      
     </strong>
     
      as a singleton service in
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      so that we can always add to it on a single
     
     <a id="_idIndexMarker260">
     </a>
     
      instance regardless of how many requests are
     
     
      
       saving orders:
      
     
     <pre class="source-code">
            builder.Services
                .AddSingleton&lt;OrderRepository&gt;();</pre>
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      endpoint
     
     <a id="_idIndexMarker261">
     </a>
     
      can now be updated to inject
     
     <strong class="source-inline">
      
       OrderRepository
      
     </strong>
     
      and to use it for saving the
     
     
      
       incoming order:
      
     
     <pre class="source-code">
  app.MapPost(
      "/order",
      (Order order,
       [FromServices] DeliveryDateBookingService
       deliveryDateBookingService,
       [FromServices] OrderRepository
       orderRepository) =&gt;
      {
          order.DeliveryDate =
              deliveryDateBookingService
                  .GetNextAvailableDate();
          orderRepository.SaveOrder(order);
  });</pre>
    </li>
   </ol>
   <p>
    
     Now that you have some experience creating dependencies as services and registering them for injection, let’s go over some basic best practices for using DI in
    
    
     
      minimal APIs.
     
    
   </p>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor127">
    </a>
    
     DI best practices
    
   </h1>
   <p>
    
     DI is integral to
    
    <a id="_idIndexMarker262">
    </a>
    
     most ASP.NET projects, and minimal APIs are
    
    <a id="_idIndexMarker263">
    </a>
    
     often particularly reliant on them.
    
    
     As a result, it’s important to ensure that we are following best practices when it comes to dependencies and the methods of
    
    
     
      accessing them.
     
    
   </p>
   <p>
    
     There are some simple rules of thumb when it comes to implementing DI in minimal APIs.
    
    
     We look at these rules in the next
    
    
     
      few sections.
     
    
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor128">
    </a>
    
     Avoiding the service locator pattern
    
   </h2>
   <p>
    
     There is an anti-pattern in minimal
    
    <a id="_idIndexMarker264">
    </a>
    
     APIs known as the
    
    <strong class="bold">
     
      service locator pattern
     
    </strong>
    
     .
    
    
     In this pattern, instead of explicitly injecting your
    
    <a id="_idIndexMarker265">
    </a>
    
     dependency, you inject
    
    <strong class="source-inline">
     
      IServiceProvider
     
    </strong>
    
     containing the dependency, and then you fish the service out of it within the body of your method
    
    
     
      or function.
     
    
   </p>
   <p>
    
     An example of the service locator pattern is shown in the following code, in which the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method we made for creating orders is altered to
    
    
     
      use
     
    
    
     <strong class="source-inline">
      
       IServiceProvider
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
  app.MapPost(
      "/order",
      (Order order,
       IServiceProvider provider) =&gt;
      {
          var deliveryDateBookingService =
              provider.GetService
                  &lt;DeliveryDateBookingService&gt;();
          order.DeliveryDate =
              deliveryDateBookingService
                  .GetNextAvailableDate();
      // save order to repository in same way we did for
      // Product using ProductRepository
  });</pre>
   <p>
    
     A significant drawback to this practice is that it makes the code harder to read.
    
    
     It is less obvious from the parameter that you are injecting specific services, and you have to write extra lines of code to get the service
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       IServiceProvider
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     It also makes it more difficult to write unit tests for your endpoints, because it is less clear which objects you need to instantiate
    
    
     
      for mocking.
     
    
   </p>
   <p>
    
     Probably the
    
    <a id="_idIndexMarker266">
    </a>
    
     most destructive aspect of this anti-pattern is the potential for runtime failures to be hard to diagnose.
    
    
     When injecting
    
    <strong class="source-inline">
     
      IServiceProvider
     
    </strong>
    
     , the compiler doesn’t know if the service you actually need is registered, whereas if you
    
    <a id="_idIndexMarker267">
    </a>
    
     attempt to explicitly inject your service and it isn’t registered, it will become apparent much more quickly, allowing for
    
    
     
      easier debugging.
     
    
   </p>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor129">
    </a>
    
     Registering services with an extension method
    
   </h2>
   <p>
    
     You can make your
    
    <a id="_idIndexMarker268">
    </a>
    
     code more readable by creating an extension
    
    <a id="_idIndexMarker269">
    </a>
    
     method on
    
    <strong class="source-inline">
     
      IServiceCollection
     
    </strong>
    
     .
    
    
     This means that within
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , you can register all your services with just one line of code or group your services together in an appropriate way and register
    
    
     
      each group.
     
    
   </p>
   <p>
    
     Here is an example of how you can write such an
    
    
     
      extension method:
     
    
   </p>
   <pre class="source-code">
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddMyServices(
        this IServiceCollection services)
    {
        services.AddScoped&lt;IMyService, MyService&gt;();
        services.AddSingleton&lt;IOtherService,
            OtherService&gt;();
        return services;
    }
}</pre>
   <p>
    
     After implementing the extension method, you can simply write the following in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     to register
    
    
     
      all services:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddMyServices();</pre>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor130">
    </a>
    
     Using sensible service lifetimes
    
   </h2>
   <p>
    
     When registering services, it is
    
    <a id="_idIndexMarker270">
    </a>
    
     important to consider the lifetime you are assigning to them.
    
    
     Here are some examples of when you would use each
    
    
     
      service lifetime:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Transient
      
     </strong>
     
      : Use
     
     <a id="_idIndexMarker271">
     </a>
     
      this lifetime if your service is lightweight, stateless, and is only to be used for a short period
     
     
      
       of time.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scoped
      
     </strong>
     
      : Use this lifetime when your service must maintain state within a single request, and the state
     
     <a id="_idIndexMarker272">
     </a>
     
      needs to be unique to the
     
     
      
       current request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Singleton
      
     </strong>
     
      : Use this lifetime
     
     <a id="_idIndexMarker273">
     </a>
     
      when your service must maintain state across the whole application.
     
     
      It is also useful for situations where you need to create heavy services that are costly to create.
     
     
      Creating them once reduces
     
     
      
       the overhead.
      
     
    </li>
   </ul>
   <p>
    
     Making the
    
    <a id="_idIndexMarker274">
    </a>
    
     effort to follow best practices when creating and managing dependencies is a long-term investment, and is a selfless act, ensuring that the code base is easy to maintain for other developers in
    
    
     
      the future.
     
    
   </p>
   <p>
    
     Let’s summarize what we’ve covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor131">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We started the chapter by exploring DI from a high level, gaining an understanding of the benefits it brings to minimal APIs by encouraging good design, loose coupling, and reusability across the
    
    
     
      code base.
     
    
   </p>
   <p>
    
     We then looked at how dependencies can be created in the form of services, before being registered for injection, using the example of an order
    
    
     
      processing API.
     
    
   </p>
   <p>
    
     It was demonstrated that parameter attributes can be used within a minimal API endpoint to inject services into the scope of an endpoint’s execution, and we covered the various lifetimes available to services when they
    
    
     
      are registered.
     
    
   </p>
   <p>
    
     Finally, some best practices were outlined, helping you to ensure that your use of DI is productive, efficient, sustainable, and testable, whilst also being easy to read for other developers who may be less familiar with
    
    
     
      the project.
     
    
   </p>
   <p>
    
     DI is a fundamental aspect of not only minimal APIs but software engineering in general.
    
    
     Having a good grounding in it will be essential for your success as
    
    
     
      a developer.
     
    
   </p>
   <p>
    
     In this chapter, we also used some pretty unorthodox methods of storing and reading in data for use within the example API endpoints.
    
    
     There is good reason for this.
    
    
     Normally, we would use more standardized data sources to host and retrieve entities, which is something we are going to explore in detail in the
    
    
     
      next chapter.
     
    
   </p>
  </div>
 </body></html>