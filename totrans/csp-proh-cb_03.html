<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Object-Oriented Programming in C#</h1></div></div></div><p>This chapter will introduce you to the foundation of C# and <strong>object-oriented programming</strong> (<strong>OOP</strong>). In this chapter, you will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using inheritance in C#</li><li class="listitem" style="list-style-type: disc">Using abstraction</li><li class="listitem" style="list-style-type: disc">Leveraging encapsulation</li><li class="listitem" style="list-style-type: disc">Implementing polymorphism</li><li class="listitem" style="list-style-type: disc">Single responsibility principle</li><li class="listitem" style="list-style-type: disc">Open/closed principle</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Introduction</h1></div></div></div><p>During your career as a creator of software, you will hear the term OOP many times. This design philosophy allows for objects to exist independently and can be reused by different sections of code. This is all made possible by what we refer to as the four pillars of OOP, namely inheritance, encapsulation, abstraction, and polymorphism.</p><p>In order to grasp this, you need to start thinking of objects (which are basically instantiated classes) that perform a specific task. Classes need to adhere to the SOLID design principle. This principle is explained here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Single responsibility </strong><a class="indexterm" id="id168"/><strong>principle</strong> (<strong>SRP</strong>)</li><li class="listitem" style="list-style-type: disc">Open/closed principle</li><li class="listitem" style="list-style-type: disc"><strong>Liskov substitution</strong><a class="indexterm" id="id169"/><strong> principle</strong> (<strong>LSP</strong>)</li><li class="listitem" style="list-style-type: disc">Interface segregation principle</li><li class="listitem" style="list-style-type: disc">Dependency inversion principle</li></ul></div><p>Let's start off with an explanation of the four pillars of OOP, after which we will have a look at the SOLID principle in more detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Using inheritance in C#</h1></div></div></div><p>In today's world, inheritance is usually associated with the end of things. In OOP, however, it is associated with the beginning of something new and better. When we create a new class, we can take an <a class="indexterm" id="id170"/>already existing class and have our new class inherit from it. This means that our new object will have all the features of the inherited class, as well as<a class="indexterm" id="id171"/> the additional features added to the new class. This is at the root of inheritance. We call a class that inherits from another a derived class.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Getting ready</h2></div></div></div><p>To illustrate the concept of inheritance, we will create a few classes that inherit from another to form new, more feature-rich objects.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new class library by right-clicking on your solution and selecting <strong>Add</strong> and then <strong>New Project</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_03_01.jpg"/></div></li><li class="listitem">From the <strong>Add New Project</strong> <a class="indexterm" id="id172"/>dialog screen, select <strong>Class Library</strong><a class="indexterm" id="id173"/> from the installed templates and call your class <code class="literal">Chapter3</code>:<div><img alt="How to do it…" src="img/B05391_03_02.jpg"/></div></li><li class="listitem">Your new class library will be <a class="indexterm" id="id174"/>added to your solution with a default name <code class="literal">Class1.cs</code>, which we renamed to <code class="literal">Recipes.cs</code> in order to distinguish the code properly. You can, however, rename your class to whatever you like<a class="indexterm" id="id175"/> if it makes more sense to you.</li><li class="listitem">To rename your class, simply click on the class name in the <strong>Solution Explorer</strong> and select <strong>Rename</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_03_03.jpg"/></div></li><li class="listitem">Visual Studio will ask you to<a class="indexterm" id="id176"/> confirm the renaming of all<a class="indexterm" id="id177"/> references to the code element <strong>Class1</strong> in the project. Just click on <strong>Yes</strong>:<div><img alt="How to do it…" src="img/B05391_03_04.jpg"/></div></li><li class="listitem">Now, let's create a new class called <code class="literal">SpaceShip</code>:<div><pre class="programlisting">public class SpaceShip
{

}</pre></div></li><li class="listitem">Our <code class="literal">SpaceShip</code> class will contain a<a class="indexterm" id="id178"/> few methods that describe the<a class="indexterm" id="id179"/> basics of a spaceship. Go ahead and add these methods to your <code class="literal">SpaceShip</code> class:<div><pre class="programlisting">public class SpaceShip
{
    public void ControlBridge()
    {

    }
    public void MedicalBay(int patientCapacity)
    {

    }
    public void EngineRoom(int warpDrives)
    {

    }
    public void CrewQuarters(int crewCapacity)
    {

    }
    public void TeleportationRoom()
    {

    }
}</pre></div><p>Because the <code class="literal">SpaceShip</code> class forms part of all other intergalactic vessels, it becomes the blueprint for every other vessel.</p></li><li class="listitem">Next, we want to create a <code class="literal">Destroyer</code> class. To accomplish this, we will create a <code class="literal">Destroyer</code> class and<a class="indexterm" id="id180"/> use a colon after the class name to indicate that we want to inherit from another class (the <code class="literal">SpaceShip</code> class). Therefore, the following needs to be added when creating the <code class="literal">Destroyer</code> class:<div><pre class="programlisting">public class Destroyer : SpaceShip
{

}</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>We can also say that the <code class="literal">Destroyer</code> class is derived from the <code class="literal">SpaceShip</code> class. The <code class="literal">SpaceShip</code> <a class="indexterm" id="id181"/>class is therefore the base class of all other intergalactic vessels.</p></div></div></li><li class="listitem">Next, add a few methods to the <code class="literal">Destroyer</code> class that are unique to a destroyer. These methods belong only to the <code class="literal">Destroyer</code> class and not to the <code class="literal">SpaceShip</code> class:<div><pre class="programlisting">public class Destroyer : SpaceShip
{
    public void WarRoom()
    {

    }
    public void Armory(int payloadCapacity)
    {

    }

    public void WarSpecialists(int activeBattalions)
    {

    }
}</pre></div></li><li class="listitem">Finally, create a third class called <code class="literal">Annihilator</code>. This is the most powerful intergalactic vessel and is used to wage war on planets. Let the <code class="literal">Annihilator </code>class inherit from the <code class="literal">Destroyer</code> class by creating the class and marking it as derived from the <code class="literal">Destroyer</code> class as follows <code class="literal">Annihilator : Destroyer</code>:<div><pre class="programlisting">public class Annihilator : Destroyer
{
    
}</pre></div></li><li class="listitem">Finally, add a few methods to the <code class="literal">Annihilator</code> class that only belong to this type of <code class="literal">SpaceShip</code> class:<div><pre class="programlisting">public class Annihilator : Destroyer
{
    public void TractorBeam()
    {

    }

    public void PlanetDestructionCapability()
    {

    }
}</pre></div></li><li class="listitem">Inside the console application, add a<a class="indexterm" id="id182"/> reference to the <code class="literal">Chapter3</code> class library<a class="indexterm" id="id183"/> by right-clicking on <strong>References</strong> under the <strong>CodeSamples</strong> project and selecting <strong>Add Reference</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_03_05.jpg"/></div></li><li class="listitem">In the <strong>Reference Manager</strong><a class="indexterm" id="id184"/> window, select the <code class="literal">Chapter3</code> solution under <strong>Projects</strong> | <strong>Solutions</strong>. This will allow you to use the classes we just created in<a class="indexterm" id="id185"/> your console application:<div><img alt="How to do it…" src="img/B05391_03_06.jpg"/></div></li><li class="listitem">What we see now is that <a class="indexterm" id="id186"/>when we create a new instance of the <code class="literal">SpaceShip</code> class, only<a class="indexterm" id="id187"/> the methods defined in that class are available to us. This is because the <code class="literal">SpaceShip</code> class does not inherit from any other class:<div><img alt="How to do it…" src="img/B05391_03_07.jpg"/></div></li><li class="listitem">Go ahead and create the <code class="literal">SpaceShip</code> class with its methods in the console application:<div><pre class="programlisting">SpaceShip transporter = new SpaceShip();
transporter.ControlBridge();
transporter.CrewQuarters(1500);
transporter.EngineRoom(2);
transporter.MedicalBay(350);
transporter.TeleportationRoom();</pre></div><p>You will see that these are the only methods available to us when instantiating a new instance of this class.</p></li><li class="listitem">Next, create a new instance of the <code class="literal">Destroyer</code> class. You will notice that the <code class="literal">Destroyer</code> class contains <a class="indexterm" id="id188"/>more methods than what we defined when we<a class="indexterm" id="id189"/> created the class. This is because the <code class="literal">Destroyer</code> class is inheriting the <code class="literal">SpaceShip</code> class and therefore inherits the methods of the <code class="literal">SpaceShip</code> class:<div><img alt="How to do it…" src="img/B05391_03_08.jpg"/></div></li><li class="listitem">Go ahead and create the <code class="literal">Destroyer</code> class with all its methods in the console application:<div><pre class="programlisting">Destroyer warShip = new Destroyer();
warShip.Armory(6);
warShip.ControlBridge();
warShip.CrewQuarters(2200);
warShip.EngineRoom(4);
warShip.MedicalBay(800);
warShip.TeleportationRoom();
warShip.WarRoom();
warShip.WarSpecialists(1);</pre></div></li><li class="listitem">Finally, create a new instance of the <code class="literal">Annihilator</code> class. This class contains all the methods of the <code class="literal">Destroyer</code> class as well as the methods from the <code class="literal">SpaceShip</code> class. This<a class="indexterm" id="id190"/> is because <code class="literal">Annihilator</code> inherits from <code class="literal">Destroyer</code>, which, in turn, inherits from <code class="literal">SpaceShip</code>:<div><img alt="How to do it…" src="img/B05391_03_09.jpg"/></div></li><li class="listitem">Go ahead and <a class="indexterm" id="id191"/>create the <code class="literal">Annihilator</code> class with all its methods in the console application:<div><pre class="programlisting">Annihilator planetClassDestroyer = new Annihilator();
planetClassDestroyer.Armory(12);
planetClassDestroyer.ControlBridge();
planetClassDestroyer.CrewQuarters(4500);
planetClassDestroyer.EngineRoom(7);
planetClassDestroyer.MedicalBay(3500);
planetClassDestroyer.PlanetDestructionCapability();
planetClassDestroyer.TeleportationRoom();
planetClassDestroyer.TractorBeam();
planetClassDestroyer.WarRoom();
planetClassDestroyer.WarSpecialists(3);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>How it works…</h2></div></div></div><p>We can see that inheritance allowed us to easily extend our classes by reusing functionality that already exists within another class created earlier. You also need to be aware though that any changes to the <code class="literal">SpaceShip</code> class will be inherited up the stack to the top-most derived class.</p><p>Inheritance is a very powerful<a class="indexterm" id="id192"/> feature of C#, which allows developers to write less code and reuse working and tested methods.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Using abstraction</h1></div></div></div><p>With abstraction, we take from the object we want to create the basic functionality that all objects derived from the abstracted <a class="indexterm" id="id193"/>object must have. To explain this in simple terms, we abstract the common functionality and put it in a single class that will be used to provide this shared functionality to all classes that inherit from it.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Getting ready</h2></div></div></div><p>To explain abstraction, we will use abstract classes. Imagine that you are dealing with trainee space astronauts who need to progress through the ranks as they get trained. The truth is that once you as trainee learn a new skill, that skill is learned and will remain with you even though you learn more advanced ways to do things. You must also implement all the previous skills learned in the new object you create. Abstract classes demonstrate this concept very nicely.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create an abstract class called <code class="literal">SpaceCadet</code>. This is the first type of astronaut you can be when starting with training. The abstract class and its members are defined using the <code class="literal">abstract</code> keyword. A thing to note is that abstract classes cannot be instantiated. The members represent the skills that <code class="literal">SpaceCadet</code> will have, such as negotiation and basic weapons training:<div><pre class="programlisting">public abstract class SpaceCadet
{
    public abstract void ChartingStarMaps();
    public abstract void BasicCommunicationSkill();
    public abstract void BasicWeaponsTraining();
    public abstract void Negotiation();
}</pre></div></li><li class="listitem">Next, create another abstract class called <code class="literal">SpacePrivate</code>. This abstract class inherits from the <code class="literal">SpaceCadet</code> abstract class. What we are basically saying is that when a space cadet is trained as a space private, they will still have all the skills learned as a space cadet:<div><pre class="programlisting">public abstract class SpacePrivate : SpaceCadet
{
    public abstract void AdvancedCommunicationSkill();
    public abstract void AdvancedWeaponsTraining();
    public abstract void Persuader();
}</pre></div></li><li class="listitem">To demonstrate this, create a class called <code class="literal">LabResearcher</code> and inherit the <code class="literal">SpaceCadet</code> abstract class. Inheriting from the abstract class is done by defining a colon and<a class="indexterm" id="id194"/> abstract class name after the newly created class name. This tells the compiler that the <code class="literal">LabResearcher</code> class inherits from the <code class="literal">SpaceCadet</code> class:<div><pre class="programlisting">public class LabResearcher : SpaceCadet
{
    
}</pre></div><p>Because we are inheriting an abstract class, the compiler will underline the <code class="literal">LabResearcher</code> class name to warn us that the derived class does not implement any of the methods in the <code class="literal">SpaceCadet</code> abstract class.</p></li><li class="listitem">If you hover your mouse over the squiggly line, you will see that the lightbulb tip provides us with the issues discovered:<div><img alt="How to do it…" src="img/B05391_03_10.jpg"/></div></li><li class="listitem">Visual Studio does a great job of providing a solution to the issues discovered. By typing <em>Ctrl </em>+ <em>.</em> (Control key and dot), you can let Visual Studio show you some potential fixes (in this case, only one fix) for the issues identified:<div><img alt="How to do it…" src="img/B05391_03_11.jpg"/></div></li><li class="listitem">After Visual Studio has added the required methods, you will see that these are the same methods defined in the <code class="literal">SpaceCadet</code> abstract class. Abstract classes, therefore, require<a class="indexterm" id="id195"/> the classes inheriting from the abstract class to implement the methods defined in the abstract class. You will also notice that the methods added to the <code class="literal">LabResearcher</code> class contain no implementation and will throw an exception if used as is:<div><pre class="programlisting">public class LabResearcher : SpaceCadet
{
    public override void BasicCommunicationSkill()
    {
        throw new NotImplementedException();
    }

    public override void BasicWeaponsTraining()
    {
        throw new NotImplementedException();
    }

    public override void ChartingStarMaps()
    {
        throw new NotImplementedException();
    }

    public override void Negotiation()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">Next, create a class called <code class="literal">PlanetExplorer</code> and make this class inherit from the <code class="literal">SpacePrivate</code> abstract class. You will remember that the <code class="literal">SpacePrivate</code> abstract class inherited from the <code class="literal">SpaceCadet</code> abstract class:<div><pre class="programlisting">public class PlanetExplorer : SpacePrivate
{
    
}</pre></div></li><li class="listitem">Visual Studio will once <a class="indexterm" id="id196"/>again warn you that your new class does not implement the methods of the abstract class that you are inheriting from. Here, however, you will notice that the lightbulb tip informs you that you are not implementing any of the methods in the <code class="literal">SpacePrivate</code> and <code class="literal">SpaceCadet</code> abstract classes. This is because the <code class="literal">SpacePrivate</code> abstract class is inheriting from the <code class="literal">SpaceCadet</code> abstract class:<div><img alt="How to do it…" src="img/B05391_03_12.jpg"/></div></li><li class="listitem">To fix the issues identified, type <em>Ctrl </em>+ <em>.</em> (Control key and dot) and let Visual Studio show you some potential fixes (in this case, only one fix) for the issues identified:<div><img alt="How to do it…" src="img/B05391_03_13.jpg"/></div></li><li class="listitem">After the fixes have been added to your code, you will see that the <code class="literal">PlanetExplorer</code> class <a class="indexterm" id="id197"/>contains all the methods in the <code class="literal">SpacePrivate</code> and <code class="literal">SpaceCadet</code> abstract classes:<div><pre class="programlisting">public class PlanetExplorer : SpacePrivate
{
    public override void AdvancedCommunicationSkill()
    {
        throw new NotImplementedException();
    }

    public override void AdvancedWeaponsTraining()
    {
        throw new NotImplementedException();
    }

    public override void BasicCommunicationSkill()
    {
        throw new NotImplementedException();
    }

    public override void BasicWeaponsTraining()
    {
        throw new NotImplementedException();
    }

    public override void ChartingStarMaps()
    {
        throw new NotImplementedException();
    }

    public override void Negotiation()
    {
        throw new NotImplementedException();
    }

    public override void Persuader()
    {
        throw new NotImplementedException();
    }
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>How it works…</h2></div></div></div><p>Abstraction has allowed us to <a class="indexterm" id="id198"/>define a common set of functionality that is to be shared among all the classes that derive from the abstract classes. The difference between inheriting from the abstract class and a normal class is that with an abstract class, you have to implement all the methods defined in that abstract class.</p><p>This makes the class easy to version and change. If you need to add new functionality, you can do so by adding that functionality to the abstract class without breaking any of the existing code. Visual Studio will require that all inherited classes implement the new method defined in the abstract class.</p><p>You can, therefore, be assured that the change applied will be implemented in all your classes that derive from the abstract classes in your code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Leveraging encapsulation</h1></div></div></div><p>What is encapsulation? Simply put, it is hiding the inner workings of a class that aren't necessary for the implementation of that class. Think of encapsulation as follows: most people who own a car know that it runs <a class="indexterm" id="id199"/>on gas. They don't need to know the inner workings of an internal combustion engine to be able to use a car. They only need to know that they need to fill it up with gas when it is close to empty and that they need to check the oil and tyre pressure. Even then, it is usually not done by the car owner. This is true for classes and encapsulation.</p><p>The owner of the class is the one who uses it. The inner workings of that class need not be exposed to the developer using the class. The class is, therefore, like a black box. You know that the class will be consistent in its functionality, given the correct set of parameters. How exactly the class gets to the output is of no concern to the developer as long as the input is correct.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Getting ready</h2></div></div></div><p>To illustrate the concept of encapsulation, we will create a class that is somewhat complex in its inner workings. We need to calculate the <a class="indexterm" id="id200"/>
<strong>thrust to weight ratio</strong> (<strong>TWR</strong>) of a space shuttle to determine whether it will be able to take off vertically. It needs to exert more thrust than its weight to counteract gravity and get into a stable orbit. This also depends on which planet the shuttle takes off from, because different planets exert different gravitational forces on objects on their surface. In simple terms, the TWR must be greater than one.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">LaunchSuttle</code>. Then, add the following private variables to the class for engine thrust; the mass of the shuttle; the local gravitational acceleration; the constant values for the gravity of the Earth, Moon, and Mars (these are constants because they will never change); the universal gravitational constant; and an enumerator for the planet we are dealing with:<div><pre class="programlisting">public class LaunchShuttle
{
    private double _EngineThrust;
    private double _TotalShuttleMass;
    private double _LocalGravitationalAcceleration;

    private const double EarthGravity = 9.81;
    private const double MoonGravity = 1.63;
    private const double MarsGravity = 3.75;
    private double UniversalGravitationalConstant;

    public enum Planet { Earth, Moon, Mars }
}</pre></div></li><li class="listitem">To our class, we will add three overloaded constructors that are essential to perform the calculation of the TWR based on the known facts at the time of instantiation (we assume that<a class="indexterm" id="id201"/> we will always know the engine thrust capability and mass of the shuttle). We will pass the gravitational acceleration for the first constructor. This is useful if we know beforehand what that value will be. For example, the gravitational acceleration of the Earth is 9.81 m/s<sup>2</sup>.<p>The second constructor will use the <code class="literal">Planet</code> enumerator to calculate the TWR that uses the constant variable values.</p><p>The third constructor will use the radius and mass of the planet to calculate the gravitational acceleration when those values are knows to return the TWR:</p><div><pre class="programlisting">public LaunchShuttle(double engineThrust, double totalShuttleMass, double gravitationalAcceleration)
{
    _EngineThrust = engineThrust;
    _TotalShuttleMass = totalShuttleMass;
    _LocalGravitationalAcceleration = gravitationalAcceleration;

}

public LaunchShuttle(double engineThrust, double totalShuttleMass, Planet planet)
{
    _EngineThrust = engineThrust;
    _TotalShuttleMass = totalShuttleMass;
    SetGraviationalAcceleration(planet);

}

public LaunchShuttle(double engineThrust, double totalShuttleMass, double planetMass, double planetRadius)
{
    _EngineThrust = engineThrust;
    _TotalShuttleMass = totalShuttleMass;
    SetUniversalGravitationalConstant();
    _LocalGravitationalAcceleration = Math.Round(CalculateGravitationalAcceleration (planetRadius, planetMass), 2);
}</pre></div></li><li class="listitem">In order to use the second overloaded constructor that passes the <code class="literal">Planet</code> enumerator as a parameter to the class, we need to create another method that has been scoped as <code class="literal">private</code> to calculate the gravitational acceleration. We also need to set the <code class="literal">_LocalGravitationalAcceleration</code> variable to the specific constant that matches the enumerator value. This method is something that the user of the <a class="indexterm" id="id202"/>class does not need to see in order to use the class. It is, therefore, scoped as <code class="literal">private</code> in order to hide that functionality from the user:<div><pre class="programlisting">private void SetGraviationalAcceleration(Planet planet)
{
    switch (planet)
    {
         case Planet.Earth:
            _LocalGravitationalAcceleration = EarthGravity;
            break;
         case Planet.Moon:
            _LocalGravitationalAcceleration = MoonGravity;
            break;
         case Planet.Mars:
            _LocalGravitationalAcceleration = MarsGravity;
            break;
        default:
            break;
    }
}</pre></div></li><li class="listitem">Of the following methods, only one is defined as public and will, therefore, be visible to the user of the class. Create the private methods to set the universal gravitational constant, to calculate the TWR, and to calculate the gravitational acceleration. These are all scoped as private, because the developer does not need to know what these methods do in order to use the class:<div><pre class="programlisting">private void SetUniversalGravitationalConstant()
{
    UniversalGravitationalConstant = 6.6726 * Math.Pow(10, -11);
}

private double CalculateThrustToWeightRatio()
{
    // TWR = Ft/m.g &gt; 1
    return _EngineThrust / (_TotalShuttleMass * _LocalGravitationalAcceleration);
}

private double CalculateGravitationalAcceleration(double radius, double mass)
{
    return (UniversalGravitationalConstant * mass) / Math.Pow(radius, 2);
}

public double TWR()
{
    return Math.Round(CalculateThrustToWeightRatio(), 2);
}</pre></div></li><li class="listitem">Finally, in your console<a class="indexterm" id="id203"/> application, create the following variables with their known vales:<div><pre class="programlisting">double thrust = 220; // kN
double shuttleMass = 16.12; // t
double graviatatonalAccelerationEarth = 9.81;
double earthMass = 5.9742 * Math.Pow(10, 24);
double earthRadius = 6378100;
double thrustToWeightRatio = 0;</pre></div></li><li class="listitem">Create a new instance of the <code class="literal">LaunchShuttle</code> class and pass it the values needed to calculate the TWR:<div><pre class="programlisting">LaunchShuttle NasaShuttle1 = new LaunchShuttle(thrust, shuttleMass, graviatatonalAccelerationEarth);
thrustToWeightRatio = NasaShuttle1.TWR();
Console.WriteLine(thrustToWeightRatio);</pre></div></li><li class="listitem">When you use the dot operator on the <code class="literal">NasaShuttle1</code> variable, you will notice that IntelliSense only shows the <code class="literal">TWR</code> method. The class exposes nothing of the inner workings of how it gets to the calculated TWR value. The only thing that the developer knows is that the <code class="literal">LaunchShuttle</code> class will consistently return the correct TWR value, given the same input parameters:<div><img alt="How to do it…" src="img/B05391_03_14.jpg"/></div></li><li class="listitem">To test this, create two more instances of the <code class="literal">LaunchShuttle</code> class and call a different constructor each time:<div><pre class="programlisting">LaunchShuttle NasaShuttle2 = new LaunchShuttle(thrust, shuttleMass, LaunchShuttle.Planet.Earth);
thrustToWeightRatio = NasaShuttle2.TWR();
Console.WriteLine(thrustToWeightRatio);

LaunchShuttle NasaShuttle3 = new LaunchShuttle(thrust, shuttleMass, earthMass, earthRadius);
thrustToWeightRatio = NasaShuttle3.TWR();
Console.WriteLine(thrustToWeightRatio);

Console.Read();</pre></div></li><li class="listitem">If you run your console <a class="indexterm" id="id204"/>application, you will see that the same value is returned for the TWR. The value indicates that a shuttle weighing 16.12 tons with a rocket that puts out 220 kilonewtons of thrust will be able to lift off the surface of the Earth (if only just):<div><img alt="How to do it…" src="img/B05391_03_15.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>How it works…</h2></div></div></div><p>The class uses the scoping rules to hide certain functionality inside the class from the developer using the class. As mentioned earlier, the developer does not need to know how the calculations are done to<a class="indexterm" id="id205"/> return the value for the TWR. This all aids in making the class more useful and easy to implement. Here is a list of the various scopes available in C#, along with their uses:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Public</code>: This is used with<a class="indexterm" id="id206"/> variables, properties, types, and methods and is visible anywhere.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Private</code>: This is used <a class="indexterm" id="id207"/>with variables, properties, types, and methods and is visible only in the block where they are defined.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Protected</code>: This is used <a class="indexterm" id="id208"/>with variables, properties, and methods. Don't think of this in terms of public or private. The protected scope is only visible inside the class in which it is used, as well as in any inherited classes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Friend</code>: This is used<a class="indexterm" id="id209"/> with variables, properties, and methods and can only be used by code in the same project or assembly.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Protected Friend</code>: This is used <a class="indexterm" id="id210"/>with variables, properties, and methods and is a combination (as the name suggests) of the protected and friend scopes.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Implementing polymorphism</h1></div></div></div><p>Polymorphism is a concept that is quite easy to grasp once you have looked at and understood the other pillars of OOP. Polymorphism literally means that something can have many forms. This means that from a single interface, you can create multiple implementations.</p><p>There are two subsections to this, namely <a class="indexterm" id="id211"/>static and dynamic polymorphism. With static polymorphism, you are dealing with the overloading of methods and functions. You can use the same method, but perform many different tasks.</p><p>With dynamic polymorphism, you are dealing with the creation and implementation of abstract classes. These abstract classes act as a blueprint that tells you what a derived class should implement. The following section looks at both.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Getting ready</h2></div></div></div><p>We will begin by illustrating the use<a class="indexterm" id="id212"/> of an abstract class, which is an example of dynamic polymorphism. We will then create overloaded constructors as an example of static polymorphism.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create an abstract class called <code class="literal">Shuttle</code> and give it a member called <code class="literal">TWR</code>, which is the calculation of the TWR of the shuttle:<div><pre class="programlisting">public abstract class Shuttle
{
    public abstract double TWR();
}</pre></div></li><li class="listitem">Next, create a class called <code class="literal">NasaShuttle</code> and have it inherit from the abstract class <code class="literal">Shuttle</code>, by putting the abstract class name after a colon at the end of the <code class="literal">NasaShuttle</code> class declaration:<div><pre class="programlisting">public class NasaShuttle : Shuttle
{
    
}</pre></div></li><li class="listitem">Visual Studio will underline the <code class="literal">NasaShuttle</code> class because you have told the compiler that the class inherits from an abstract class, but you have not yet implemented the members of that abstract class:<div><img alt="How to do it…" src="img/B05391_03_16.jpg"/></div></li><li class="listitem">To fix the issues<a class="indexterm" id="id213"/> identified, type <em>Ctrl </em>+ <em>.</em> (Control key and dot) and let Visual Studio show you some potential fixes (in this case, only one fix) for the issues identified:<div><img alt="How to do it…" src="img/B05391_03_17.jpg"/></div></li><li class="listitem">Visual Studio then adds the missing implementation to your <code class="literal">NasaShuttle</code> class. By default, it will add it as not implemented, because you are required to provide implementation for the abstract member you overrode in the abstract class:<div><pre class="programlisting">public class NasaShuttle : Shuttle
{
    public override double TWR()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">Create another class called <code class="literal">RoscosmosShuttle</code> and inherit from the same <code class="literal">Shuttle</code> abstract class:<div><pre class="programlisting">public class RoscosmosShuttle : Shuttle
{

}</pre></div></li><li class="listitem">Visual Studio will underline the <code class="literal">RoscosmosShuttle</code> class because you have told the compiler that the<a class="indexterm" id="id214"/> class inherits from an abstract class, but you have not yet implemented the members of that abstract class:<div><img alt="How to do it…" src="img/B05391_03_18.jpg"/></div></li><li class="listitem">To fix the issues identified, type <em>Ctrl </em>+ <em>.</em> (Control key and dot) and let Visual Studio show you some potential fixes (in this case, only one fix) for the issues identified:<div><img alt="How to do it…" src="img/B05391_03_19.jpg"/></div></li><li class="listitem">The overridden method is then added to the <code class="literal">RoscosmosShuttle</code> class as not implemented. You have just seen an example of dynamic polymorphism in action:<div><pre class="programlisting">public class RoscosmosShuttle : Shuttle
{
    public override double TWR()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">To see an example of static <a class="indexterm" id="id215"/>polymorphism, create the following overloaded constructor for <code class="literal">NasaShuttle</code>. The constructor name stays the same, but the signature of the constructor changes, which makes it overloaded:<div><pre class="programlisting">public NasaShuttle(double engineThrust, double totalShuttleMass, double gravitationalAcceleration)
{

}

public NasaShuttle(double engineThrust, double totalShuttleMass, double planetMass, double planetRadius)
{

}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How it works…</h2></div></div></div><p>Polymorphism is something you will easily be using already by simply applying good object oriented principles to the design of your classes. With the abstract <code class="literal">Shuttle</code> class, we saw that the class took on the shape of the <code class="literal">NasaShuttle</code> class and the <code class="literal">RoscosmosShuttle</code> class when it was used to derive those new classes from its abstraction. The constructor of the <code class="literal">NasaShuttle</code> class was then overridden to provide the same method name, but implemented using different signatures.</p><p>This is at the heart of polymorphism. Most likely, you have been using it without knowing about it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Single responsibility principle</h1></div></div></div><p>When talking about SOLID principles, we will start <a class="indexterm" id="id216"/>off with the SRP. Here, we are actually saying that a class has a specific task that it needs to fulfil and it should not do anything else.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Getting ready</h2></div></div></div><p>You will create a new class and write code to log an error to the database when an exception is thrown on adding<a class="indexterm" id="id217"/> more troops to the star ship, causing it to be over capacity.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new class<a class="indexterm" id="id218"/> called <code class="literal">StarShip</code>:<div><pre class="programlisting">public class Starship
{
       
}</pre></div></li><li class="listitem">To your class, add a new method that will set the maximum troop capacity of the <code class="literal">StarShip</code> class:<div><pre class="programlisting">public void SetMaximumTroopCapacity(int capacity)
{            

}</pre></div></li><li class="listitem">Inside this method, add a <code class="literal">trycatch</code> clause that will attempt to set the maximum troop capacity, but for some reason, it will fail. Upon failure, it will write the error to the log table inside the database:<div><pre class="programlisting">try
{
    // Read current capacity and try to add more
}
catch (Exception ex)
{
    string connectionString = "connection string goes here";
    string sql = $"INSERT INTO tblLog (error, date) VALUES ({ex.Message}, GetDate())";
    using (SqlConnection con = new SqlConnection(connectionString))
    {
        SqlCommand cmd = new SqlCommand(sql);
        cmd.CommandType = CommandType.Text;
        cmd.Connection = con;
        con.Open();
        cmd.ExecuteNonQuery();
    }
    throw ex;
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>How it works…</h2></div></div></div><p>If you have code that looks like the preceding one, you are in contravention of the SRP. The <code class="literal">StarShip</code> class is no longer responsible for just itself and things that have to do with star ships. It now has to fulfill the<a class="indexterm" id="id219"/> role of logging errors to the database too. You see the problem here is that the database-logging code does not belong in the <code class="literal">catch</code> clause of the <code class="literal">SetMaximumTroopCapacity</code> method. A better approach would be to create a separate <code class="literal">DatabaseLogging</code> class with methods to create connections and write exceptions to the appropriate log table. You will also find that you are going to have to write that logging code in multiple places (in every <code class="literal">catch</code> clause). If you are finding that you are repeating code (by copying and pasting from other areas), you probably need to put that code into a common class, and you have likely broken the SRP rule.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Open/closed principle</h1></div></div></div><p>When creating classes, we need to ensure that the class prohibits any breaking modifications by needing to change internal code. We<a class="indexterm" id="id220"/> say that such a class is closed. If we need to change it somehow, we can do so by extending the class. This extensibility is where we say that the class is open for extensions.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>Getting ready</h2></div></div></div><p>You will create a class that determines the skills of a trooper by looking at the class of trooper. We will show you the way many developers create such a class and the way it can be created using the open/closed principle.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a class called <code class="literal">StarTrooper</code>:<div><pre class="programlisting">public class StarTrooper
{
    
}</pre></div></li><li class="listitem">To this class, add an enumerator called <code class="literal">TrooperClass</code> to identify the type of trooper we want to return the skills of. Also, create a <code class="literal">List&lt;string&gt;</code> variable to contain the skills of the specific trooper class. Finally, create a method called <code class="literal">GetSkills</code> that returns the specific set of skills for the given trooper class.<p>The class is quite straightforward, but the implementation of the code is something we see a lot. Sometimes, instead of a <code class="literal">switch</code> statement, you will see a whole lot of <code class="literal">if</code> <code class="literal">else</code> statements. While the functionality of the code is clear, it is not easy to add another class of trooper to the <code class="literal">StarTrooper</code> class without changing code. Assume that you now have to add an additional <code class="literal">Engineer</code> class to the <code class="literal">StarTrooper</code> class. You would have to modify the <code class="literal">TrooperClass</code> enumeration and the code in the <code class="literal">switch</code> statement.</p><p>This changing of<a class="indexterm" id="id221"/> code can cause you to introduce bugs into code that was previously working fine. We now see that the <code class="literal">StarTrooper</code> class is not closed and can't be extended easily to accommodate additional <code class="literal">TrooperClass</code> objects:</p><div><pre class="programlisting">public enum TrooperClass { Soldier, Medic, Scientist }
List&lt;string&gt; TroopSkill;

public List&lt;string&gt; GetSkills(TrooperClass troopClass)
{
    switch (troopClass)
    {
        case TrooperClass.Soldier:
        return TroopSkill = new List&lt;string&gt;(new string[] { "Weaponry", "TacticalCombat", "HandToHandCombat" });

        case TrooperClass.Medic:
        return TroopSkill = new List&lt;string&gt;(new string[] { "CPR", "AdvancedLifeSupport" });

        case TrooperClass.Scientist:
        return TroopSkill = new List&lt;string&gt;(new string[] { "Chemistry", "MollecularDeconstruction", "QuarkTheory" });

        default:
            return TroopSkill = new List&lt;string&gt;(new string[] { "none" });
    }
}</pre></div></li><li class="listitem">The solution to this problem is inheritance. Instead of having to change code, we extend it. Start off by rewriting the above <code class="literal">StarTrooper</code> class and create a <code class="literal">Trooper</code> class. The <code class="literal">GetSkills</code> method is declared as <code class="literal">virtual</code>:<div><pre class="programlisting">public class Trooper
{
    public virtual List&lt;string&gt; GetSkills()
    {
        return new List&lt;string&gt;(new string[] { "none" });
    }
}</pre></div></li><li class="listitem">Now, we can easily create<a class="indexterm" id="id222"/> derived classes for the <code class="literal">Soldier</code>, <code class="literal">Medic</code>, and <code class="literal">Scientist</code> trooper classes available. Create the following derived classes that inherit from the <code class="literal">Trooper</code> class. You can see that the <code class="literal">override</code> keyword is used when creating the <code class="literal">GetSkills</code> method:<div><pre class="programlisting">public class Soldier : Trooper
{
    public override List&lt;string&gt; GetSkills()
    {
         return new List&lt;string&gt;(new string[] { "Weaponry", "TacticalCombat", "HandToHandCombat" });
    }
}

public class Medic : Trooper
{
    public override List&lt;string&gt; GetSkills()
    {
        return new List&lt;string&gt;(new string[] { "CPR", "AdvancedLifeSupport" });
    }
}

public class Scientist : Trooper
{
    public override List&lt;string&gt; GetSkills()
    {
        return new List&lt;string&gt;(new string[] { "Chemistry", "MollecularDeconstruction", "QuarkTheory" });
    }
}</pre></div></li><li class="listitem">The code becomes extremely easy to implement when extending the class to add an additional class of <code class="literal">Trooper</code>. If we now want to add the <code class="literal">Engineer</code> class, we would simply override the <code class="literal">GetSkills</code> method after inheriting from the <code class="literal">Trooper</code> class created earlier:<div><pre class="programlisting">public class Engineer : Trooper
{
public override List&lt;string&gt; GetSkills()
    {
        return new List&lt;string&gt;(new string[] { "Construction", "Demolition" });
    }
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How it works…</h2></div></div></div><p>The classes derived from the <code class="literal">Trooper</code> class are extensions of the <code class="literal">Trooper</code> class. We can say that each class is closed, because <a class="indexterm" id="id223"/>modifying it does not necessitate changing the original code. The <code class="literal">Trooper</code> class is also extensible because we have been able to easily extend the class by creating derived classes from it.</p><p>Another by-product of this design is smaller, more manageable code that is easier to read and understand.</p></div></div></body></html>